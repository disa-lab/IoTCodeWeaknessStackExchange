PostId,PostTypeId,ParentId,CreationDate,Score,ViewCount,OwnerUserId,OwnerDisplayName,LastActivityDate,LastEditDate,CommentCount,FavouriteCount,Body,,QIds,QViewCounts
824083,2,824029,2009-05-05T09:32:11.513,2,,100766,,2009-05-05T09:32:11.513,,0,,"<p>you have to open the appropriate com-device with <code>CreateFile</code> like so. Adapt to your needs. </p>

<pre><code>// Handle of the communication connection 
void *comHandle;

// Port parameters, set to your own needs
unsigned portIndex;
unsigned baudRate;
unsigned dataBits;
Parity   parity;
unsigned stopBits;
bool     handShake;
int      readIntervalTimeout;
int      readTotalTimeoutMultiplier;
int      readTotalTimeoutConstant;
int      writeTotalTimeoutMultiplier;
int      writeTotalTimeoutConstant;
DCB dcb;
COMMTIMEOUTS ct;

// Create COM-device name string 
char comDevice[20];
sprintf(comDevice, ""\\\\.\\COM%d"", portIndex);

// Open serial port
_comHandle = CreateFile(comDevice, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
if (comHandle == INVALID_HANDLE_VALUE)
{
  return false;
}


ct.ReadIntervalTimeout         = readIntervalTimeout;        
ct.ReadTotalTimeoutMultiplier  = readTotalTimeoutMultiplier; 
ct.ReadTotalTimeoutConstant    = readTotalTimeoutConstant;   
ct.WriteTotalTimeoutMultiplier = writeTotalTimeoutMultiplier;
ct.WriteTotalTimeoutConstant   = writeTotalTimeoutConstant;  

if (!GetCommState(_comHandle,&amp;dcb))
{
  disconnect();
  return false;
}

dcb.BaudRate        = baudRate;  
dcb.ByteSize        = (BYTE)dataBits;
dcb.Parity          = (parity == None) ? NOPARITY : ((parity == Even) ? EVENPARITY : ODDPARITY);
dcb.StopBits        = (stopBits &gt; 1) ? TWOSTOPBITS : ONESTOPBIT;
dcb.fRtsControl     = handShake ? RTS_CONTROL_HANDSHAKE : RTS_CONTROL_ENABLE;
dcb.fOutxCtsFlow    = handShake;
dcb.fOutxDsrFlow    = handShake;
dcb.fDtrControl     = handShake ? DTR_CONTROL_HANDSHAKE : DTR_CONTROL_ENABLE;
dcb.fDsrSensitivity = handShake;
dcb.fOutX           = FALSE;
dcb.fInX            = FALSE;
dcb.fErrorChar      = FALSE;
dcb.fNull           = FALSE;
dcb.fAbortOnError   = TRUE;

// Set port state
if( !SetCommState(_omHandle, &amp;dcb) ||
    !SetCommTimeouts(comHandle, &amp;ct) ||
    !SetupComm(comHandle, 64, 64) ||
    !PurgeComm(comHandle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR))
{
  disconnect();
  return false;
} 
</code></pre>

<p>Read the appropriate MSDN entries for the various functions called. Also, I've left out the disconnect method for brevity reasons.</p>
",,824029,6323
899226,2,899098,2009-05-22T18:16:25.293,1,,95706,,2009-05-22T18:50:40.150,2009-05-22T18:50:40.150,2,,"<p>As Nikolai mentioned, it looks like you are doing assignment (=) rather than comparison (==) in your ""if"" statements.</p>

<p>A good habit that some C programmers get into is to put rvalues on the left-hand side of comparisons, so that the compiler will generate an error if you accidentally use the assignment operator instead of the comparison operator:</p>

<pre>
if (50 == usbnumber) {   // This is okay.
    ...
}

if (50 = usbnumber) {    // The compiler will generate an error here.
    ...
}
</pre>

<p>This works, regardless of what compiler flags or warning level you are using since assigning to an rvalue is illegal.</p>

<p>I should add that this ""safety net"" doesn't work if you need to compare two lvalues.</p>
",,899098,11287
949915,2,949890,2009-06-04T11:17:47.173,0,,14860,,2009-06-04T11:29:10.287,2009-06-04T11:29:10.287,1,,"<p>Sure, you put this in one of your your header files, say preinit.h:</p>

<pre><code>class Init { public: Init() { initialize(); } }; Init init;
</code></pre>

<p>and then, in <em>one</em> of your compilation units, put:</p>

<pre><code>void initialize(void) {
    // weave your magic here.
}
#include ""preinit.h""
</code></pre>

<p>I know that's a kludge but I'm not aware of <em>any</em> portable way to do pre-main initialization without using a class constructor executed at file scope.</p>

<p>You should also be careful of including more than one of these initialization functions since I don't believe C++ dictates the order - it could be random.</p>

<p>I'm not sure of this ""sketch"" of which you speak but would it be possible to transform the main compilation unit with a script before having it passed to the compiler, something like:</p>

<pre><code>awk '{print;if (substr($0,0,11) == ""int main ("") {print ""initialize();""};}'
</code></pre>

<p>You can see how this would affect your program because:</p>

<pre><code>echo '#include &lt;stdio.h&gt;
int main (void) {
    int x = 1;
    return 0;
}' | awk '{
    print;
    if (substr($0,0,11) == ""int main ("") {
        print ""    initialize();""
    }
}'
</code></pre>

<p>generates the following with the <code>initialize()</code> call added:</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    initialize();
    int x = 1;
    return 0;
}
</code></pre>

<p>It may be that you can't post-process the generated file in which case you should ignore that final option, but that's what I'd be looking at first.</p>
",,949890,9387
949916,2,949890,2009-06-04T11:17:55.910,0,,83153,,2009-06-04T11:17:55.910,,4,,"<p>Use static members of classes. They are initialized before entering to main. The disadvantage is that you can't control the order of the initialization of the static class members.</p>

<p>Here is your example transformed:</p>

<pre><code>class Init {
private:
    // Made the constructor private, so to avoid calling it in other situation
    // than for the initialization of the static member.
    Init() { initialize(); }

private:
    static Init INIT;
};


Init Init::INIT;
</code></pre>
",,981608,14886
949981,2,949890,2009-06-04T11:33:56.110,2,,30579,,2009-06-04T12:04:23.897,2009-06-04T12:04:23.897,1,,"<p>If you are using the Arduino environment, is there any reason you can't place it in the <a href=""http://arduino.cc/en/Reference/Setup"" rel=""nofollow noreferrer"">setup method</a>?</p>

<p>Of course, this is after the Arduino-specific hardware setup, so if you have such low-level stuff that it really has to go before <code>main</code>, then you need some constructor magic.</p>

<p>UPDATE:</p>

<p>Ok, if it has to be done before the main I think the only way is to use a constructor like you already do.</p>

<p>You can always make a preprocessor macro of it:</p>

<pre><code>#define RUN_EARLY(code) \
namespace { \
    class Init { \
        Init() { code; } \
    }; \
    Init init; \
}
</code></pre>

<p>Now this should work:</p>

<pre><code>RUN_EARLY(initialize())
</code></pre>

<p>But it's not really making things shorter, just moving the verbose code around.</p>
",,1027416,822
950307,2,949890,2009-06-04T12:40:28.567,4,,11698,,2009-06-04T12:48:14.633,2009-06-04T12:48:14.633,1,,"<p>You can make the above very slightly shorter by giving ""initialize"" a return type, and using that to initialize a global variable:</p>

<pre><code>int initialize();
int dummy = initialize();
</code></pre>

<p>However, you need to be careful with this, the standard does not guarantee that the above initialization (or the one for your init object) takes place before main is run (3.6.2/3):</p>

<blockquote>
  <p>It is implementation-defined whether or not the dynamic initialization (8.5, 9.4, 12.1, 12.6.1) of an object of namespace scope is done before the first statement of main.</p>
</blockquote>

<p>The only thing that is guaranteed is that the initialization will take place before 'dummy' is ever used.</p>

<p>A more intrusive option (if it's possible) might be to use ""-D main=avr_main"" in your makefile.  You could then add your own main as follows:</p>

<pre><code>// Add a declaration for the main declared by the avr compiler.
int avr_main (int argc, const char * argv[]);  // Needs to match exactly

#undef main
int main (int argc, const char * argv[])
{
  initialize ();
  return avr_main (argc, argv);
}
</code></pre>

<p>At least here you're guaranteed that the initialization will take place when you expect.</p>
",,1197111,3479
951046,2,949890,2009-06-04T14:46:09.607,3,,20270,,2009-06-04T15:50:56.560,2009-06-04T15:50:56.560,1,,"<p>Here's a somewhat evil method of achieving this:</p>

<pre><code>#include &lt;stdio.h&gt;

static int bar = 0;

int __real_main(int argc, char **argv);

int __wrap_main(int argc, char **argv)
{
    bar = 1;
    return __real_main(argc, argv);
}

int main(int argc, char **argv)
{
    printf(""bar %d\n"",bar);
    return 0;
}
</code></pre>

<p>Add the following to the linker flags: <code>--wrap main</code></p>

<p>eg.</p>

<pre><code>gcc -Xlinker --wrap -Xlinker main a.c
</code></pre>

<p>The linker will replace all calls to <code>main</code> with calls to <code>__wrap_main</code>, see the <a href=""http://unixhelp.ed.ac.uk/CGI/man-cgi?ld"" rel=""nofollow noreferrer"">ld man page</a> on <code>--wrap</code></p>
",,1787106,21442
37435037,2,949890,2016-05-25T10:56:46.370,0,,6271082,,2016-05-25T11:32:58.507,2016-05-25T11:32:58.507,0,,"<p>There is how I perform pre-main coding.
There are sever init sections executed before main, refers to <a href=""http://www.nongnu.org/avr-libc/user-manual/mem_sections.html"" rel=""nofollow"">http://www.nongnu.org/avr-libc/user-manual/mem_sections.html</a> initN sections.</p>

<p>Anyhow, this only works on -O0 optimization for some reason. I still try to find out which option ""optimized"" my pre-main assembly code away.</p>

<pre><code>static void
__attribute__ ((naked))
__attribute__ ((section ("".init8"")))    /* run this right before main */
__attribute__ ((unused))    /* Kill the unused function warning */
stack_init(void) {assembly stuff}
</code></pre>

<p>Update, it turns out I claimed this function is unused, leading to optimize the routine away. I was intended to kill function unused warning. It is fixed to used used attribute instead.</p>
",,1851393,4243
981639,2,981608,2009-06-11T14:59:27.943,30,,1898,,2012-07-03T13:44:09.370,2012-07-03T13:44:09.370,6,,"<p>Try:</p>

<pre><code>x ^= 0x14;
</code></pre>

<p>That toggles both bits. It's a little bit unclear in question as you first mention swap and then give a toggle example. Anyway, to swap the bits:</p>

<pre><code>x = precomputed_lookup [x];
</code></pre>

<p>where precomputed_lookup is a 256 byte array, could be the fastest way, it depends on the memory speed relative to the processor speed. Otherwise, it's:</p>

<pre><code>x = (x &amp; ~0x14) | ((x &amp; 0x10) &gt;&gt; 2) | ((x &amp; 0x04) &lt;&lt; 2);
</code></pre>

<p>EDIT: Some more information about toggling bits.</p>

<p>When you xor (<code>^</code>) two integer values together, the xor is performed at the bit level, like this:</p>

<pre><code>for each (bit in value 1 and value 2)
   result bit = value 1 bit xor value 2 bit
</code></pre>

<p>so that bit 0 of the first value is xor'ed with bit 0 of the second value, bit 1 with bit 1 and so on. The xor operation doesn't affect the other bits in the value. In effect, it's a parallel bit xor on many bits.</p>

<p>Looking at the truth table for xor, you will see that xor'ing a bit with the value '1' effectively toggles the bit.</p>

<pre><code> a  b a^b
 0  0  0
 0  1  1
 1  0  1
 1  1  0
</code></pre>

<p>So, to toggle bits 1 and 3, write a binary number with a one where you want the bit to toggle and a zero where you want to leave the value unchanged:</p>

<pre><code>00001010
</code></pre>

<p>convert to hex: 0x0a. You can toggle as many bits as you want:</p>

<pre><code>0x39 = 00111001
</code></pre>

<p>will toggle bits 0, 3, 4 and 5</p>
",,1991628,3145
982139,2,981608,2009-06-11T16:24:32.403,5,,117503,,2012-07-07T05:19:29.200,2017-05-23T12:01:24.707,1,,"<p>The following method is NOT a single C instruction, it's just another bit fiddling method. The method was simplified from <em><a href=""http://graphics.stanford.edu/~seander/bithacks.html#SwappingBitsXOR"" rel=""nofollow noreferrer"">Swapping individual bits with XOR</a></em>.</p>

<p>As stated in <a href=""https://stackoverflow.com/questions/981608/toggle-two-bits-with-a-single-operation-in-c/981693#981693"">Roddy's answer</a>, a lookup table would be best. I only suggest this in case you didn't want to use one. This will indeed swap bits also, not just toggle (that is, whatever is in bit 2 will be in 4 and vice versa). </p>

<ul>
<li>b: your original value - ???1?0?? for instance  </li>
<li>x: just a temp   </li>
<li><p>r: the result  </p>

<p>x = ((b >> 2) ^ (b >> 4)) &amp; 0x01<br>
r = b ^ ((x &lt;&lt; 2) | (x &lt;&lt; 4))  </p></li>
</ul>

<p>Quick explanation: get the two bits you want to look at and XOR them, store the value to <code>x</code>. By shifting this value back to bits 2 and 4 (and OR'ing together) you get a mask that when XORed back with <code>b</code> will swap your two original bits. The table below shows all possible cases.</p>

<pre><code>bit2: 0 1 0 1  
bit4: 0 0 1 1  
x   : 0 1 1 0   &lt;-- Low bit of x only in this case 
r2  : 0 0 1 1  
r4  : 0 1 0 1
</code></pre>

<p>I did not fully test this, but for the few cases I tried quickly it seemed to work.</p>
",,2018177,1710
982213,2,981608,2009-06-11T16:39:04.740,2,,100754,,2009-06-11T16:39:04.740,,0,,"<p>The function below will swap bits 2 and 4. You can use this to precompute a lookup table, if necessary (so that swapping becomes a single operation):</p>

<pre><code>unsigned char swap24(unsigned char bytein) {
    unsigned char mask2 = ( bytein &amp; 0x04 ) &lt;&lt; 2;
    unsigned char mask4 = ( bytein &amp; 0x10 ) &gt;&gt; 2;
    unsigned char mask  = mask2 | mask4 ;
    return ( bytein &amp; 0xeb ) | mask;
}
</code></pre>

<p>I wrote each operation on a separate line to make it clearer.</p>
",,2487911,5487
1671941,2,981608,2009-11-04T06:07:35.990,4,,202370,,2015-01-03T13:28:51.390,2015-01-03T13:28:51.390,2,,"<p>This might not be optimized, but it should work:</p>

<pre><code>unsigned char bit_swap(unsigned char n, unsigned char pos1, unsigned char pos2)
{
    unsigned char mask1 = 0x01 &lt;&lt; pos1;
    unsigned char mask2 = 0x01 &lt;&lt; pos2;
   if ( !((n &amp; mask1) != (n &amp; mask2)) )
        n ^= (mask1 | mask2);
    return n;
}
</code></pre>
",,2527437,884
19951359,2,981608,2013-11-13T10:29:57.443,0,,1292348,,2013-11-13T10:29:57.443,,0,,"<pre><code>#include&lt;stdio.h&gt;

void printb(char x) {
    int i;
    for(i =7;i&gt;=0;i--) 
        printf(""%d"",(1 &amp; (x &gt;&gt; i)));
    printf(""\n"");
}

int swapb(char c, int p, int q) {
    if( !((c &amp; (1 &lt;&lt; p)) &gt;&gt; p) ^ ((c &amp; (1 &lt;&lt; q)) &gt;&gt; q) )
        printf(""bits are not same will not be swaped\n"");
    else {
        c = c ^ (1 &lt;&lt; p);
        c = c ^ (1 &lt;&lt; q);
    }
    return c;
}

int main() 
{
    char c = 10;
    printb(c);
    c = swapb(c, 3, 1);
    printb(c);
    return 0;
}
</code></pre>
",,2695358,3989
32964796,2,981608,2015-10-06T08:08:18.873,0,,1745064,,2015-10-06T08:08:18.873,,0,,"<pre><code>void swap_bits(uint32_t&amp; n, int a, int b) {
    bool r = (n &amp; (1 &lt;&lt; a)) != 0;
    bool s = (n &amp; (1 &lt;&lt; b)) != 0;

    if(r != s) {
        if(r) {
            n |= (1 &lt;&lt; b);
            n &amp;= ~(1 &lt;&lt; a);
        }
        else {
            n &amp;= ~(1 &lt;&lt; b);
            n |= (1 &lt;&lt; a);
        }
    }
}
</code></pre>

<p><code>n</code> is the integer you want to be swapped in, <code>a</code> and <code>b</code> are the positions (indexes) of the bits you want to be swapped, counting from the less significant bit and starting from zero.</p>

<p>Using your example (<code>n = ???1?0??</code>), you'd call the function as follows:</p>

<pre><code>swap_bits(n, 2, 4);
</code></pre>

<p><strong>Rationale</strong>: you only need to swap the bits if they are different (that's why <code>r != s</code>). In this case, one of them is 1 and the other is 0. After that, just notice you want to do exactly one <strong>bit set</strong> operation and one <strong>bit clear</strong> operation.</p>
",,2889722,6879
1027458,2,1027416,2009-06-22T14:15:09.090,-1,,63925,,2009-06-22T14:15:09.090,,1,,"<p>Are you able to use std::string?  You could have it as <code>std::string name_</code> and have the STL take care of the memory allocation for you..</p>

<pre><code>class TestSuite {
    public:
      TestSuite(const char* name) : name_(name) {}

      ~TestSuite() {}

    private:
      std::string name_;
};
</code></pre>

<p>Don't forget to include <code>&lt;string&gt;</code>.</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow noreferrer"">Reference</a></p>
",,3031413,10682
1027460,2,1027416,2009-06-22T14:15:35.267,1,,38924,,2009-06-22T15:01:34.473,2009-06-22T15:01:34.473,4,,"<p>Well, you can use a std::string that will take care of all memory allocation</p>

<pre><code>class TestSuite {
public:
  TestSuite(const std::string &amp;name):name_(name) {
  }

  ~TestSuite() {
  }

private:
  std::string name_;
};
</code></pre>

<p><strong>Edit</strong> : 
If it is the call to malloc() that you want to avoid you could do this :</p>

<pre><code>class TestSuite {
public:
  TestSuite(const char *name){
    memcpy(name_, name, min(16, strlen(name));
  }

private:
  char name_[16];
};
</code></pre>

<p>This will waste some memory however, which can be an issue on embedded platforms.</p>
",,3069862,827
1027469,2,1027416,2009-06-22T14:18:13.250,1,,101361,,2009-06-22T14:18:13.250,,2,,"<p>Documentation. For example,</p>

<pre><code>/**
* Test suite constructor.
* @param name test suite name cstring, shared
*/
TestSuite(char const *name) {
// ...
</code></pre>

<p>A shared pointer implies that the pointed object must be alive during the lifetime of this object.</p>
",,3142038,2078
1197139,2,1197111,2009-07-28T22:36:06.070,3,,130717,,2009-07-28T22:36:06.070,,1,,"<p>It can be clearer if you remove the need to use constants <code>HIGH</code> and <code>LOW</code>, by splitting into two methods. Just make <code>bitSet</code> and <code>bitClear</code> methods. <code>bitSet</code> sets the bit to <code>HIGH</code>, and <code>bitClear</code> sets the bit to <code>LOW</code>. Then it becomes:</p>

<pre><code>#define SHIFT_BIT 0

if (bitRead(_flags, SHIFT_BIT) == HIGH)
{
    bitClear(_flags, SHIFT_BIT);
}
else
{
    bitSet(_flags, SHIFT_BIT);
}
</code></pre>

<p>And of course, if you just have <code>HIGH == 1</code> and <code>LOW == 0</code>, then you don't need the == check.</p>
",,3198031,3051
1197164,2,1197111,2009-07-28T22:44:48.690,0,,130352,,2009-07-28T22:44:48.690,,6,,"<p>For bit fields, it's better to use logical operations, so you could do:</p>

<pre><code>if (flags &amp; FLAG_SHIFT) {
   flags &amp;= ~FLAG_SHIFT;
} else {
   flags |= FLAG_SHIFT;
}
</code></pre>

<p>This now has the look of the former with the efficiency of the latter. Now you could have macros rather than functions, so (if I've got this right - it would be something like):</p>

<pre><code>#define bitIsSet(flags,bit) flags | bit
#define bitSet(flags,bit) flags |= bit
#define bitClear(flags,bit) flags &amp;= ~bit
</code></pre>

<p>You don't have the overhead of calling functions, and the code becomes more readable again.</p>

<p>I've not played with Arduino (yet) but there might already be macros for this sort of thing, I don't know.</p>
",,3270967,30334
1197221,2,1197111,2009-07-28T23:07:56.397,5,,113892,,2010-12-08T11:20:32.510,2010-12-08T11:20:32.510,4,,"<p>Depending on the compliance of the AVR-GCC compiler, which I'm unsure about, you can do something like this and keep things nice and clean.</p>

<pre><code>struct flags {
    unsigned int flag1 : 1;  //1 sets the length of the field in bits
    unsigned int flag2 : 4;
}; 

flags data;

data.flag1 = 0;
data.flag2 = 12;

if (data.flag1 == 1)
{
    data.flag1 = 0;
}
else
{
    data.flag1 = 1;
}
</code></pre>

<p>If you also want access to the entire flag int at once, then:</p>

<pre><code>union 
{
    struct {
        unsigned int flag1 : 1;  //1 sets the length of the field in bits
        unsigned int flag2 : 4;
    } bits;
    unsigned int val;
} flags;
</code></pre>

<p>You can then access a bit with 2 levels of indirection: <code>variable.bits.flag1</code>&lt;--returns single bit flag or with a single level to get the entire int worth of flags: <code>variable.val</code> &lt;--returns int</p>
",,3454853,11204
1198595,2,1197111,2009-07-29T07:37:04.907,1,,6610,,2009-07-29T07:37:04.907,,2,,"<p>If you're talking readability, bit-sets and C++, why don't I find anything on <code>std::bitset</code> in there?  I understand that the embedded programmer race is quite comfortable with bitmasks, and has evolved a blindness for its sheer uglyness (the masks, not the races:), but apart from masks and bitfields, the standard library has a quite elegant solution, too.</p>

<p>An example:</p>

<pre><code>#include &lt;bitset&gt;

enum tFlags { c_firstflag, c_secondflag, c_NumberOfFlags };

...

std::bitset&lt;c_NumberOfFlags&gt; bits;

bits.set( c_firstflag );
if( bits.test( c_secondflag ) ) {
  bits.clear();
}

// even has a pretty print function!
std::cout &lt;&lt; bits &lt;&lt; std::endl;// does a ""100101"" representation.
</code></pre>
",,3497717,16710
1787118,2,1787106,2009-11-24T00:50:17.337,9,,55637,,2009-11-24T00:56:55.127,2009-11-24T00:56:55.127,2,,"<p>The curly-brace syntax is valid for initial declaration of a variable, but not for assignment after the fact.</p>

<p>Also, you are returning a pointer to an automatic variable, which is no longer validly allocated once returned (and will be smashed by the next call, such as to <code>print</code>).  You need to do something like this:</p>

<pre><code>void formatTimeDigits(char strOut[3], int num)
{
  strOut[0] = '0' + (num / 10);
  strOut[1] = '0' + (num % 10);
  strOut[2] = '\0';
}

void serialOutput12()
{
  char strOut[3]; // the allocation is in this stack frame, not formatTimeDigits

  printWeekday(weekday); // picks the right word to print for the weekday

  Serial.print("", ""); // a comma after the weekday

  Serial.print(hour12, DEC); // the hour, sent to the screen in decimal format

  Serial.print("":""); // a colon between the hour and the minute

  formatTimeDigits(strOut, minute);
  Serial.print(strOut); // the minute

  Serial.print("":""); // a colon between the minute and the second

  formatTimeDigits(strOut, second);
  Serial.print(strOut); // the second
}
</code></pre>
",,3543461,11667
1787123,2,1787106,2009-11-24T00:52:44.587,1,,134633,,2009-11-24T01:10:20.047,2009-11-24T01:10:20.047,2,,"<p>In C, you can't directly set an array's contents with the <code>=</code> assignment operator (you can <em>initialise</em> an array, but that's a different thing, even though it looks similar).</p>

<p>Additionally:</p>

<ul>
<li>It doesn't sound like the Wiring <code>char(value)</code> function/operator does what you want; and</li>
<li>If you want to return a pointer to that <code>strOut</code> array, you will have to make it have static storage duration.</li>
</ul>

<p>The simple way to do what you want is <code>sprintf</code>:</p>

<pre><code>char * formatTimeDigits (int num)
{
  static char strOut[3];

  if (num &gt;= 0 &amp;&amp; num &lt; 100) {
    sprintf(strOut, ""%02d"", num);
  } else {
    strcpy(strOut, ""XX"");
  }

  return strOut;
}
</code></pre>
",,3687113,1242
1851406,2,1851393,2009-12-05T06:56:59.883,10,,73681,,2009-12-05T07:12:45.707,2009-12-05T07:12:45.707,1,,"<p>It would probably be easiest to not convert it to a string, but just use arithmetic to separate the digits, i.e.</p>

<pre><code>float speed = 17.812345;
int display_speed = speed * 10 + 0.5;     // round to nearest 0.1 == 178
int digits[4];
digits[3] = display_speed % 10;           // == 8
digits[2] = (display_speed / 10) % 10;    // == 7
digits[1] = (display_speed / 100) % 10;   // == 1
digits[0] = (display_speed / 1000) % 10;  // == 0
</code></pre>

<p>and, as pointed out in the comments, if you need the ASCII value for each digit:</p>

<pre><code>char ascii_digits[4];
ascii_digits[0] = digits[0] + '0';
ascii_digits[1] = digits[1] + '0';
ascii_digits[2] = digits[2] + '0';
ascii_digits[3] = digits[3] + '0';
</code></pre>
",,4188782,9047
1851473,2,1851393,2009-12-05T07:31:52.057,4,,40002,,2009-12-05T10:26:40.800,2009-12-05T10:26:40.800,2,,"<p>This a way you can do it in C++ without modulus math (either way seems fine to me):</p>

<pre><code>#include ""math.h""
#include &lt;stdio.h&gt;
#include &lt;iostream.h&gt;

int main( ) {

        float value = 3.1415;
        char buf[16]; 
        value = floor( value * 10.0f ) / 10.0f;
        sprintf( buf, ""%0.1f"", value );

        std::cout &lt;&lt; ""Value: "" &lt;&lt; value &lt;&lt; std::endl;

        return 0;
}
</code></pre>
",,4358975,13685
1851526,2,1851393,2009-12-05T07:54:43.377,3,,64918,,2009-12-05T08:06:38.817,2009-12-05T08:06:38.817,0,,"<p>If you actually want to be processing this stuff as strings, I would recommend looking into <code>stringstream</code>.  It can be used much the same as any other stream, such as <code>cin</code> and <code>cout</code>, except instead of sending all output to the console you get an actual <code>string</code> out of the deal.</p>

<p>This will work with standard C++.  Don't know much about Arduino, but some quick googling suggests it won't support stringstreams.</p>

<p>A quick example:</p>

<pre><code>#include &lt;sstream&gt; // include this for stringstreams
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std; // stringstream, like almost everything, is in std

string stringifyFloat(float f) {
  stringstream ss;
  ss.precision(1); // set decimal precision to one digit.
  ss &lt;&lt; fixed;     // use fixed rather than scientific notation.
  ss &lt;&lt; f;         // read in the value of f
  return ss.str(); // return the string associated with the stream.
}

int main() {
  cout &lt;&lt; stringifyFloat(17.812345) &lt;&lt; endl; // 17.8
  return 0;
}
</code></pre>
",,4369948,17615
1994885,2,1991628,2010-01-03T12:56:09.560,5,,99917,,2010-01-03T17:52:05.747,2010-01-03T17:52:05.747,0,,"<p>I don't know the reason but I had to modify the following <code>setup()</code> function to get the code working:</p>

<pre><code>void setup() {
  Ethernet.begin(mac, ip, gateway, mask);
  Serial.begin(9600);

  delay(1000);

  Serial.println(""connecting..."");

  for(int i = 0;i &lt;100 ; i++) {  
    if (client.connect()) {
      Serial.println(""connected"");        
      client.println(""GET /search?q=arduino HTTP/1.0"");
      client.println();
      break;
    } else {
      Serial.println(""connection failed"");
    }
  }
}
</code></pre>

<p>The code:</p>

<pre><code>client.connect()
</code></pre>

<p>does fail twice or thrice but eventually it connects to google web server as well as my local web server in the 3rd or 4th iteration of the 'for' loop.</p>

<p>If anyone knows the reason for such behavior, please reply.</p>
",,4523653,962
2018284,2,2018177,2010-01-07T04:55:12.170,4,,39975,,2010-01-07T04:55:12.170,,0,,"<blockquote>
  <p>How come? I dont even have a reference to setup in here!</p>
</blockquote>

<p>It's because you don't have a reference to <code>setup</code> that it's complaining.</p>

<p>Arduino code generates a <code>main</code> that (for the discussion here) basically looks like this:</p>

<pre><code>int main(int argc, char **argv) {
    setup();
    while(1) {
        loop();
    }
}
</code></pre>

<p>So, you should rename your <code>loop</code> function to <code>setup</code> and take this part:</p>

<pre><code>while (1) {
  sample_inputs();
  set_motor();
}
</code></pre>

<p>drop the <code>while</code> loop, and put those two function calls into a new function called <code>loop</code>.</p>
",,4674990,1439
16084181,2,2487911,2013-04-18T13:22:24.883,6,,682179,,2013-04-18T13:22:24.883,,0,,"<p>If you want to connect through a proxy, use the proxy server name as the adress you're connecting to, and include the server address as part of your GET request:</p>

<pre><code>// if you get a connection, report back via serial:
if (client.connect(""www.proxy.com"", 8080)) {  // This is connecting to the proxy
Serial.println(""connected"");

// Make a HTTP request through proxy:
client.println(""GET http://www.actualserver.com/search?q=arduino HTTP/1.0"");
client.println();
</code></pre>

<p>The original answer is <a href=""http://arduino.cc/forum/index.php/topic,158690.0.html"" rel=""noreferrer"">here</a>.  </p>
",,4705790,41310
2527455,2,2527437,2010-03-26T23:32:04.333,-1,,173397,,2010-03-26T23:32:04.333,,4,,"<pre><code> char command[MAX_COMMAND];
 void loop(){
     char *p = command;
    if(Serial.available() &gt; 0){
      int clinput = Serial.read();
    command[p++] = (char)clinput;
   }
  }
</code></pre>
",,4776231,140
2527458,2,2527437,2010-03-26T23:32:21.870,0,,136540,,2010-03-26T23:32:21.870,,0,,"<p>Use <a href=""http://www.cplusplus.com/reference/iostream/ostringstream/"" rel=""nofollow noreferrer"">std::ostringstream</a> with <a href=""http://www.sgi.com/tech/stl/basic_string.html"" rel=""nofollow noreferrer"">std::string</a>:</p>

<pre>
#include &lt;sstream&gt;
#include &lt;string&gt;

std::string loop()
{
    std::ostringstream oss;
    while ( Serial.available() &gt; 0 ){
        oss &lt;&lt; static_cast&lt;char&gt;(Serial.read());
    }
    return oss.str();
}
</pre>

<p>You can also concatenate multiple instances of std::string with operator+.</p>
",,5003548,4342
2527460,2,2527437,2010-03-26T23:33:31.397,0,,280730,,2010-03-27T00:08:49.373,2010-03-27T00:08:49.373,1,,"<p>Since its also tagged C,</p>

<pre><code>char *command = (char *)malloc(sizeof(char) * MAXLENGTH);
*command = '\0';

void loop(){
  char clinput[2] = {}; //for nullifying the array
  if(Serial.available() &gt; 0){
    clinput[0] = (char)Serial.read();
    strcat(command, clinput);
}
</code></pre>
",,5534290,20239
2527463,2,2527437,2010-03-26T23:34:05.267,3,,136452,,2010-03-26T23:34:05.267,,0,,"<p>You have to write character by character into an array.
For example like this:</p>

<pre><code>#define MAX_COMMAND_LENGTH 20

char Command[MAX_COMMAND_LENGTH];
int commandLength;    

void loop(){
  if(Serial.available() &gt; 0){
    int clinput = Serial.read();
    if (commandLength &lt; MAX_COMMAND_LENGTH) {
      Command[commandLength++] = (char)clinput;
    }
}
</code></pre>

<p>BTW: This is not complete. E.g. commandLength has to be initialized with 0.</p>
",,5612174,4605
2527556,2,2527437,2010-03-26T23:58:35.923,1,,234815,,2010-03-26T23:58:35.923,,0,,"<p>You need to allocate enough space in <code>command</code> hold the longest commmand 
and then write characters into it as the come in.  When you run out of characters,
you null terminate the command and then return.</p>

<pre><code>char Command[MAX_COMMAND_CHARS];

void loop() {
  int ix = 0; 
  // uncomment this to append to the Command buffer
  //ix = strlen(Command);

  while(ix &lt; MAX_COMMAND_CHARS-1 &amp;&amp; Serial.available() &gt; 0) {
     Command[ix] = Serial.read();
     ++ix;
  }

  Command[ix] = 0; // null terminate the command
}
</code></pre>
",,5615095,4119
2695372,2,2695358,2010-04-23T00:05:41.840,3,,182675,,2010-04-23T00:11:38.900,2010-04-23T00:11:38.900,0,,"<pre><code>void setup(void)
{
    ...

    byte* numbers[3] = {zero, one, two };
    size_t sizes[3] = {sizeof(zero), sizeof(one), sizeof(two)};

    function(numbers[1], sizes[1]);
}
</code></pre>
",,5635294,1234
2889754,2,2889722,2010-05-22T21:02:26.133,5,,265143,,2010-05-22T21:38:20.340,2010-05-22T21:38:20.340,0,,"<p>Behind the parameter type error there is a deeper issue: you lack the mapping between a char and the corresponding <code>int[]</code>.</p>

<p>Redefining <code>printLetter</code> as</p>

<pre><code>void printLetter(char letter)
</code></pre>

<p>satisfies the compiler, but doesn't solve your problem per se. Whether inside or outside <code>printLetter</code>, you need to get the corresponding <code>int[]</code> for a given <code>char</code>.</p>

<p>A simple brute-force way to achieve this would be to use a <code>switch</code>, but a better way is to use a second array, i.e. something like this:</p>

<pre><code>void printLetter(char letter) {
  static int* charToMatrix[] = { A, B, C, ... };
  int* matrixToPrint = charToMatrix[letter - 'A'];
  // print the matrix
}
</code></pre>

<p>Note that this is an example - I don't have access to a C compiler right now, so I can't guarantee it works straight away, but hopefully it illustrates the point well enough. It also lacks bounds checking, so it accesses memory in strange random places, possibly resulting in a crash, if you attempt to print an ""unknown"" character.</p>

<p>This solution is supposed to work for the uppercase letters; if you need to print lowercase letters or other characters as well, you might prefer going with an array of 256 elements, where only the elements at indexes corresponding to the ""known"" matrices are filled, and the rest is set to NULL.</p>
",,5731863,85390
2889764,2,2889722,2010-05-22T21:05:14.550,2,,29809,,2010-05-22T21:05:14.550,,0,,"<p>What you need to do is convert from a character to one of your arrays.  So when you have the letter 'A', you'll want to use array <code>A</code>.  The easiest way to do this is via lookup table.</p>

<pre><code>int *lookup[256];  // assuming ASCII
memset(lookup, 0, sizeof(lookup));

lookup['A'] = A;
lookup['B'] = B;
...
</code></pre>

<p>Then when you have a character, you can get the proper array:</p>

<pre><code>void printletter(char c);
{
    int *data = lookup((unsigned char)c);

    // In case you get a letter that you don't know how to display
    if (data != NULL)
    {
        // display with data
    }
}
</code></pre>

<p>Instead of building up your array at runtime, you can also build up your array at compile time although it will be a bit harder as you will need to manually put in NULL pointers.</p>

<pre><code>int *lookup[256] = {
    NULL,   // you need a total of 65 NULL's
    NULL,
    ...
    A,      // so this is at the correct position
    B,
    C,
    ...
};
</code></pre>
",,5752175,7032
3031433,2,3031413,2010-06-13T07:34:20.310,7,,29809,,2010-06-13T07:34:20.310,,3,,"<p>Write a function to abstract sending the data (I've gotten rid of your temporary variables because they don't add much value):</p>

<pre><code>void send16(int value)
{
    //send both bytes
    Serial.print(value &amp; 0xFF, BYTE);
    Serial.print((value &gt;&gt; 8) &amp; 0xFF, BYTE);
}
</code></pre>

<p>Now you can easily send any data you want:</p>

<pre><code>send16(analogRead(0));
send16(analogRead(1));
...
</code></pre>
",,5781559,2663
3032567,2,3031413,2010-06-13T14:32:47.173,0,,111432,,2010-06-13T14:32:47.173,,0,,"<pre><code>   int num = ( (unsigned char)bytesReadString[1] &lt;&lt; 8 | 
               (unsigned char)bytesReadString[0] );
</code></pre>

<p>That code will not do what you expect.</p>

<p>When you shift an 8-bit unsigned char, you lose the extra bits.</p>

<pre><code>11111111 &lt;&lt; 3 == 11111000

11111111 &lt;&lt; 8 == 00000000
</code></pre>

<p>i.e. any unsigned char, when shifted 8 bits, must be zero.</p>

<p>You need something more like this:</p>

<pre><code>typedef unsigned uint;
typedef unsigned char uchar;

uint num = (static_cast&lt;uint&gt;(static_cast&lt;uchar&gt;(bytesReadString[1])) &lt;&lt; 8 ) |
           static_cast&lt;uint&gt;(static_cast&lt;uchar&gt;(bytesReadString[0]));
</code></pre>

<p>You might get the same result from:</p>

<pre><code>typedef unsigned short ushort;
uint num = *reinterpret_cast&lt;ushort *&gt;(bytesReadString);
</code></pre>

<p>If the byte ordering is OK.  Should work on Little Endian (x86 or x64), but not on Big Endian (PPC, Sparc, Alpha, etc.)</p>
",,5827343,354
3032588,2,3031413,2010-06-13T14:38:15.013,0,,111432,,2010-06-13T14:38:15.013,,0,,"<p>To generalise the ""Send"" code a bit --</p>

<pre><code>void SendBuff(const void *pBuff, size_t nBytes)
{
    const char *p = reinterpret_cast&lt;const char *&gt;(pBuff);
    for (size_t i=0; i&lt;nBytes; i++)
        Serial.print(p[i], BYTE);
}

template &lt;typename T&gt;
void Send(const T &amp;t)
{
    SendBuff(&amp;t, sizeof(T));
}
</code></pre>
",,5863319,758
3069960,2,3069862,2010-06-18T13:26:24.330,5,,31945,,2010-06-18T13:26:24.330,,0,,"<p>Your code indicates a lack of understanding of the min, max and constrain functions. I suggest you read the documentation more carefully.</p>

<p>In the meantime, here is what I <em>think</em> you're after:</p>

<pre><code>sVal = analogRead(potPin);
sVal = sVal / 8 + 1; //scale value [0.. 1023] to [1.. 128]

itoa(sVal, res, 10);
println(res);
println("" "");
delay(150);
clearScreen();
</code></pre>
",,5931572,31689
13130289,2,3142038,2012-10-29T22:00:33.003,2,,1456861,,2012-10-29T23:08:52.097,2012-10-29T23:08:52.097,0,,"<p>I had a similar problem.</p>

<p>In my case QExtSerial would open the port, I'd see the RX/TX lights on the board flash, but no data would be received. If I opened the port with another terminal program first QExtSerial would work as expected.</p>

<p>What solved it for me was opening the port, configuring the port settings, and then making DTR and RTS high for a short period of time.</p>

<p>This was on Windows 7 w/ an ATMega32u4 (SFE Pro Micro).</p>

<hr>

<pre>
<code>

    bool serialController::openPort(QString portName) {
        QString selectPort = QString(""\\\\.\\%1"").arg(portName);
        this->port = new QextSerialPort(selectPort,QextSerialPort::EventDriven);
        if (port->open(QIODevice::ReadWrite | QIODevice::Unbuffered) == true) {
            port->setBaudRate(BAUD38400);
            port->setFlowControl(FLOW_OFF);
            port->setParity(PAR_NONE);
            port->setDataBits(DATA_8);
            port->setStopBits(STOP_1);
            port->setTimeout(500);

            port->setDtr(true);
            port->setRts(true);
            Sleep(100);
            port->setDtr(false);
            port->setRts(false);

            connect(port,SIGNAL(readyRead()), this, SLOT(onReadyRead()));

            return true;
        } else {
            // Device failed to open: port->errorString();
        }
        return false;
    }

</pre>

<p></code></p>
",,6056014,761
3198143,2,3198031,2010-07-07T19:28:08.483,0,,170443,,2010-07-07T19:28:08.483,,0,,"<p>In C++ only all last parameters are allowed to have a default value:</p>

<p>BAD rightjustify MUST have a default value:</p>

<pre><code>char * floatToString(char * outstr, float value, int places,
    int minwidth=0, bool rightjustify) {
</code></pre>

<p>OK: no default values, last or two last parameters have default values</p>

<pre><code>char * floatToString(char * outstr, float value, int places,
    int minwidth, bool rightjustify) {

char * floatToString(char * outstr, float value, int places,
    int minwidth, bool rightjustify=false) {

char * floatToString(char * outstr, float value, int places,
    int minwidth=0, bool rightjustify=false) {
</code></pre>

<p>Check your header, I guess the one you linked is not the one you currently use.</p>

<p>There is another pointer to an issue: ito is unknown to the compiler. It should be in <code>cstdlib</code>, so an <code>#include &lt;cstdlib&gt;</code> is missing, I would put it in the header, because it depends on it.</p>
",,6068655,1510
3270981,2,3270967,2010-07-17T09:49:14.427,10,,15955,,2010-07-17T09:49:14.427,,3,,"<p>hm. How about this:</p>

<pre><code>void send_float (float arg)
{
  // get access to the float as a byte-array:
  byte * data = (byte *) &amp;arg; 

  // write the data to the serial
  Serial.write (data, sizeof (arg));
}
</code></pre>
",,6342384,1411
3271018,2,3270967,2010-07-17T10:01:58.200,9,,371181,,2012-03-26T18:28:49.810,2012-03-26T18:28:49.810,0,,"<p>Yes, to send these numbers you have to first convert them to <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> strings. If you are working with C, <code>sprintf()</code> is, IMO, the handiest way to do this conversion:</p>

<p>[Added later: <b>AAAGHH!</b> I forgot that for <code>ints</code>/<code>longs</code>, the function's input argument wants to be unsigned. Likewise for the format string handed to <code>sprintf()</code>. So I changed it below. Sorry about my terrible oversight, which would have been a hard-to-find bug. Also, <code>ulong</code> makes it a little more general.]</p>

<pre><code>char *
int2str( unsigned long num ) {
    static char retnum[21];       // Enough for 20 digits plus NUL from a 64-bit uint.
    sprintf( retnum, ""%ul"", num );
    return retnum;
}
</code></pre>

<p>And similar for floats and doubles. The code doing the conversion has be known in advance. It has to be told - what kind of an entity it's converting, so you might end up with functions <code>char *float2str( float float_num)</code> and <code>char *dbl2str( double dblnum)</code>.</p>

<p>You'll get a NUL-terminated left-adjusted (no leading blanks or zeroes) character string out of the conversion.</p>

<p>You can do the conversion anywhere/anyhow you like; these functions are just illustrations.</p>
",,7100658,241
23242578,2,3270967,2014-04-23T11:13:36.513,0,,3564271,,2014-04-23T11:24:01.880,2014-04-23T11:24:01.880,0,,"<p>Perhaps that is best Way to convert Float to Byte and Byte to Float,-Hamid Reza.</p>

<pre><code>int breakDown(int index, unsigned char outbox[], float member)
{
  unsigned long d = *(unsigned long *)&amp;member;

  outbox[index] = d &amp; 0x00FF;
  index++;

  outbox[index] = (d &amp; 0xFF00) &gt;&gt; 8;
  index++;

  outbox[index] = (d &amp; 0xFF0000) &gt;&gt; 16;
  index++;

  outbox[index] = (d &amp; 0xFF000000) &gt;&gt; 24;
  index++;
  return index;
}


float buildUp(int index, unsigned char outbox[])
{
  unsigned long d;

  d =  (outbox[index+3] &lt;&lt; 24) | (outbox[index+2] &lt;&lt; 16)
    | (outbox[index+1] &lt;&lt; 8) | (outbox[index]);
  float member = *(float *)&amp;d;
  return member;
}
</code></pre>

<p>regards.
    `</p>
",,7104079,2444
3454897,2,3454853,2010-08-11T02:41:23.253,1,,214796,,2010-08-11T02:47:09.183,2010-08-11T02:47:09.183,2,,"<p>If I understand your question correctly, one way to avoid having to 'post-process' is to move the pointer passed to <code>ReadFile</code> to the end of the available data, so the <code>ReadFile</code> call is appending to the buffer, instead of overwriting. </p>

<p>Essentially, you would have two pointers. One to the buffer, the other to the end of the data in the buffer. So when your program starts, both pointers will be the same. Now, you read the first 2 bytes. You increment the end-of-data pointer by 2. You do another read, but instead of <code>szBuff</code>, you pass a pointer to the end of the previously read data. You read the next three bytes and you have the complete entry in <code>szBuff</code>.</p>

<p>If you need to wait until some delimiter to mark the end of an entry is received, you could just search the received data for it. If it's not there, you keep reading until you find it. If it is there, you can just return.</p>

<pre><code>// Fill the buffer with 0
char szBuff[256] = {0};
// We have no data in the buffer, so the end of data points to the beginning 
// of the buffer.
char* szEndOfData = szBuff; 
while (i &lt; maxSamples)
{
    WaitCommEvent (hSerial, &amp;dwCommStatus, 0);

    if (dwCommStatus &amp; EV_RXCHAR) 
    {
        // Append up to 4 bytes from the serial port to the buffer
        ReadFile(hSerial, LPVOID(szEndOfData), 4, &amp;dwBytesRead, NULL);
        // Increment the end of data pointer, so it points to the end of the
        // data available in the buffer.
        szEndOfData += dwBytesRead;

        cout&lt;&lt;szBuff;
        printf("" - %d - \n"", atoi(szBuff));
    }
    i++;     
}

// Output, assuming what you mentioned happens:
// - 88 -
// - 8889 -
</code></pre>

<p>If this approach is acceptable to you, it will require a bit more work. For example, you would have to ensure you don't overflow your buffer. When you remove data from the buffer, you'll have to move all of the data after the removed segment to the beginning, and fix the end of data pointer. Alternatively, you could use a circular buffer.</p>
",,7295234,1928
3463862,2,3454853,2010-08-12T00:24:01.777,1,,394384,,2010-08-12T01:27:35.447,2017-05-23T11:55:22.213,0,,"<p>As <a href=""https://stackoverflow.com/users/17034/hans-passant"">Hans Passant</a> and <a href=""https://stackoverflow.com/users/214796/dauphic"">dauphic</a> pointed, it doesn't seem to be a general solution for my question. I am writing, though, the code that I was trying to avoid, just in case somebody finds it useful or face the same problem that I had:</p>

<pre><code>int i = 0;  
DWORD dwBytesRead = 0;
DWORD dwCommStatus = 0;
char szBuff[2] = """";                
int maxRead = 20;   
int sizeNum = 1;    
int *num    = (int*)malloc(maxRead*sizeof(int)); 
char *currNum;
char *pastNum;

// Write something into the Serial Port to start receive 
// information from the Arduino
WriteFile(hSerial, (LPCVOID)""A\0"", 1, &amp;dwBytesRead, NULL);    
SetCommMask(hSerial, EV_RXCHAR);

// Start reading from the Serial Port
while ( i &lt; maxRead )
{
    WaitCommEvent (hSerial, &amp;dwCommStatus, 0);

    if (dwCommStatus &amp; EV_RXCHAR) // if a char is received in the serial port
    {
        ReadFile(hSerial, LPVOID(szBuff), 1, &amp;dwBytesRead, NULL);

        if ( szBuff[0] &gt; 47 &amp;&amp; szBuff[0] &lt; 58 )
        {
            sizeNum++;
            if (sizeNum ==2)
            {
                currNum = (char*)malloc(sizeNum*sizeof(char));
                strcpy(currNum, szBuff);
            } else
            {
                if (pastNum != NULL)
                    free(pastNum);
                pastNum = currNum;
                currNum = (char*)malloc(sizeNum*sizeof(char));
                strcpy(currNum, pastNum);
                strcpy(currNum+(sizeNum-2)*sizeof(char), szBuff);
            }

            cout &lt;&lt; szBuff&lt;&lt;endl;   
        } else if (szBuff[0] == '\n' &amp;&amp; sizeNum &gt; 1) // end of number
        {
            num[i] = atoi(currNum);
            i++;                    

            sizeNum = 1;
            if (currNum!=NULL)
                free(currNum);
        }
    }
}
</code></pre>
",,7353272,4117
3497735,2,3497717,2010-08-16T21:59:09.257,0,,393280,,2010-08-16T22:39:44.900,2010-08-16T22:39:44.900,5,,"<p>You need to change <code>combine</code> to handle a <code>char*</code> as well.</p>

<pre><code>//function to combine uri and key
void combine(char key[], char uri[], char long_s[]) {
  int i = 0;
  int x = 0;
  while(uri[i]) {
      long_s[i] = uri[i];
      ++i;
  }
  while(key[x]) {
      long_s[i] = key[x];
      ++i;
      ++x;
  }
  long_s[i] = '\0';
  //Serial.print(long_s);
}

char newURI = malloc(strlen(uri) + strlen(key) + 1);
combine(key, uri, newURI);
</code></pre>

<p>Then, you have to change the <code>lon</code> parameter to be a <code>char*</code>, too.</p>

<p>As pointed out by the comment, you actually have to do more than this, since long_s is a local variable.</p>

<p>You might have to change your function to take <code>lon</code> as a parameter and to intialize it outside of the function.</p>

<p>Again, this is quick code and you will have to tailor this to suit your needs (and do garbage collection).</p>
",,7455570,27176
3497740,2,3497717,2010-08-16T21:59:35.950,1,,106581,,2010-08-16T22:09:43.477,2010-08-16T22:09:43.477,0,,"<p>You say the function is returning a <code>char</code>, but yet you try to return a <code>char*</code> (the reference to the array).  So you either need to change the function to be a <code>char*</code>, or you need to return an actual <code>char</code>.  Also, you return a reference to memory that is no longer valid, you need to either malloc on the heap, or pass in the pointer to be filled with the function call.</p>

<p>Edit: Further clarification</p>

<p>All of these are pointers to arrays of type uint8 or char.</p>

<pre><code>char hostname[] = ""www.XXXXX.com"";
uint8 ipaddr[]  = {XXX,XXX,XXX,XXX};
char uri[]      = ""/api/Login/"";  
char key[] = API_KEY;  //3490324032-asdfasd-234234
</code></pre>

<p>This is regular data.</p>

<pre><code>const int port  = 80;

//function to combine uri and key
char combine(char key[], char uri[]) {
  int i = 0;
  int x = 0;
</code></pre>

<p>This next line declares a pointer to an array of chars that has 8 elements.  This probably isn't what you want.  The sizeof macro is evaluating to <code>4</code> because that is the size of a pointer (compile and run the program below).  Also you need to change this to <code>char * long_s = malloc(sizeof(uri) + sizeof(key));</code>  Dont forget to free it later.</p>

<pre><code>  char long_s[sizeof(uri) + sizeof(key)];
  while(uri[i]) {
      long_s[i] = uri[i];
      ++i;
  }
  while(key[x]) {
      long_s[i] = key[x];
      ++i;
      ++x;
  }
  long_s[i] = '\0';
  //Serial.print(long_s);
</code></pre>

<p>This returns the pointer to the array that you just filled, not an actual char.</p>

<pre><code>  return long_s;  //pointer?
} 
</code></pre>

<p>These next lines should just be <code>char * newURI = combine(key, uri);</code></p>

<pre><code>char lon = combine (key, uri);
char* newURI = &amp;lon;

// A get request
GETrequest getSession(ipaddr, port, hostname, newURI);
</code></pre>

<p>Edit: Try this out:</p>

<pre><code>#include &lt;stdio.h&gt;

void test(char k[])
{
    printf(""%d\n"", sizeof(k));
}

int main ()
{
    char* key[100];
    test(key);
    printf(""%d\n"", sizeof(key));
    return 0;
}
</code></pre>
",,7592848,3310
3497745,2,3497717,2010-08-16T22:00:12.963,0,,326900,,2010-08-16T22:00:12.963,,0,,"<p>If you are planning to return a pointer to char, your function should be declared as</p>

<pre><code>char *combine (char key[], char uri[])
{
    //...etc...
    return long_s;  //pointer?
} 
</code></pre>
",,7708553,1490
3497787,2,3497717,2010-08-16T22:04:51.087,2,,13005,,2010-08-16T22:27:00.630,2010-08-16T22:27:00.630,0,,"<p>You're not trying to return a <code>char</code>, you're trying to return a string.</p>

<p>A <code>char</code> in C is a character (or a byte). A string is a sequence of characters. Yes, you need some sort of memory location, either allocated in your <code>combine</code> function with <code>malloc</code>, or supplied by the caller as an extra parameter. Or more likely two extra parameters, a pointer and a length, to help ensure there's enough space to write the concatenated strings.</p>

<p>Everying in C is passed (and returned) by value[*]. So when you return a <code>char</code>, you're just returning one of the possible values a <code>char</code> can take. There's no way you can return a <code>char</code> from the beginning of a string, take a pointer to the return value, and get the rest of the string. By analogy if I tell you that I'm thinking of the letter ""a"", it doesn't make sense to ask whether I mean the ""a"" in ""ask"" or the ""a"" in ""mean"". I just mean a letter ""a"": no further context. You need pointers if you want to indicate <em>which</em> string that letter ""a"" belongs to.</p>

<p>Also, <code>sizeof</code> doesn't measure the length of a string. It gives you the size of the <em>type</em> or object which is its operand. Due to an unfortunate peculiarity of the syntax of C, your parameters <code>key</code> and <code>uri</code> are of type <code>char*</code> - they're pointers, so their size is the size of a pointer, not the length of the array that it points to (the first element of). So, your <code>long_s</code> buffer is only 8/16 bytes big (on a typical 32/64 bit architecture), and will be overflowed. This results in undefined behaviour, meaning that it might crash, it might appear to work, or it might allow an attacker to gain control of your machine.</p>

<p>Finally, there are standard functions <code>strlen</code>, <code>strcat</code> and <code>strncat</code> which you could look at to see how string handling works in C. Here's one way to do it:</p>

<pre><code>char *newURI = malloc(strlen(uri) + strlen(key) + 1);
if (newURL == 0) { /* indicate failure, somehow */ }
strcpy(newURI, uri);
strcat(newURI, key);
GETrequest session = getSession(ipaddr, port, hostname, newURI);
free(newURI); // avoids a memory leak
// do something with the session...
</code></pre>

<p>[*] even pointers are passed by value.</p>
",,7777131,348
3497863,2,3497717,2010-08-16T22:17:25.313,5,,134633,,2010-08-16T22:17:25.313,,0,,"<p>Your function return value is <code>char</code> - that means that it returns a <em>single</em> <code>char</code> (which can only represent one character).  A string is represented by an array of <code>char</code>s, which is usually referred to by a pointer (<code>char *</code>).</p>

<p>So you need to return a <code>char *</code> - but this leads to another problem.  The pointer must be pointing at an array that outlives the function call.  Your array <code>long_s</code> will be destroyed as soon as the function returns, so this is not suitable.  The usual alternative is to allow the caller to supply a buffer of sufficient size (note also that your loops can be replaced with the <code>strcpy()</code> and <code>strcat()</code> functions):</p>

<pre><code>char *combine(char result[], size_t result_sz, const char key[], const char uri[])
{
  /* Test to see if there is sufficient space */

  if (strlen(uri) + strlen(key) + 1 &gt; result_sz)
  {
    return NULL;
  }

  strcpy(result, uri);
  strcat(result, key);

  return result;
} 
</code></pre>

<p>Then your caller must use:</p>

<pre><code>char lon[1024];
char *newURI = combine (lon, sizeof lon, key, uri);

if (newURI == NULL)
{
    /* Error - URL too long */
}
else
{
    GETrequest getSession(ipaddr, port, hostname, newURI);
}
</code></pre>
",,7801478,2821
3497868,2,3497717,2010-08-16T22:17:43.757,1,,12711,,2010-08-16T22:17:43.757,2017-05-23T12:25:36.213,0,,"<p>You have a couple of problems:</p>

<ol>
<li><p>you're returning a pointer to a local variable. While you might be able to accidentally print reasonable looking output from that result, there's a bug here in that you're accessing data that's no longer valid.  The local variable the result is pointing to is no longer 'alive' once the function returns</p></li>
<li><p>you're sizing the result buffer incorrectly.  The <code>uri</code> and <code>key</code> parameters are really pointers (see <a href=""https://stackoverflow.com/questions/1328223/sizeof-array-passed-as-parameter"">Sizeof array passed as parameter</a>), so </p>

<pre><code>char long_s[sizeof(uri) + sizeof(key)];
</code></pre>

<p>actually gives you an array of characters large enough to hold 2 pointers, which isn't necessarily large enough to hold your strings.</p></li>
</ol>

<p>You need to decide how you want to manage the combined string.  There are a couple options:</p>

<ol>
<li><p>Have your callers pass in a buffer to use (along with the size so you can prevent overrun errors)</p></li>
<li><p>Have the function allocate the buffer and require the caller to free it when they no longer need it.</p></li>
</ol>

<p>An example using option 2:</p>

<pre><code>//function to combine uri and key
char* combine(char const* key, char const* uri) {
    int len = strlen(key) + strlen(uri) + 1; /* don't the '\0' terminator */

    char* pResult = malloc(len);

    if (pResult) {
        /* we got a buffer */
        strcpy( pResult, uri);
        strcat( pResult, key);
    }

    return pResult; /* will return NULL on failure */
                    /* caller is responsible for calling free() */
} 
</code></pre>
",,7845196,6619
3543533,2,3543461,2010-08-22T21:39:29.830,3,,82320,,2011-10-11T20:45:45.863,2011-10-11T20:45:45.863,3,,"<p>You can't really say there. The length of the uncompiled code has little to do with the length of the compiled code. For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

int main()
{
  std::vector&lt;std::string&gt; strings;
  strings.push_back(""Hello"");
  strings.push_back(""World"");
  std::sort(strings.begin(), strings.end());
  std::copy(strings.begin(), strings.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, """"));
}
</code></pre>

<p>vs</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

int main()
{
  std::vector&lt;std::string&gt; strings;
  strings.push_back(""Hello"");
  strings.push_back(""World"");
  for ( int idx = 0; idx &lt; strings.size(); idx++ )
    std::cout &lt;&lt; strings[idx];
}
</code></pre>

<p>Both are the exact same number of lines, and produce the same output, but the first example involves an instantiation of std::sort, which is probably an order of magnitude more code than the rest of the code here.</p>

<p>If you absolutely need to count number of bytes used in the program, use assembler.</p>
",,7923965,1284
3839812,2,3687113,2010-10-01T13:54:03.217,0,,5065,,2010-10-01T13:54:03.217,,0,,"<p>It sounds like you need to create a protocol for communicating between the 'bots and the PC. It could look something like this:</p>

<pre>
Byte   Value  Description
 1     0xAA   First sync byte
 2     0x55   Second sync byte
 3     seq    Message sequence number, increments for each new message transmitted
 4     1      Message type (1 = Wheel encoder report)
 5     5      Number of data bytes to follow
 6     ID     Bot ID
 7     FL     Front left wheel encoder
 8     FR     Front right wheel encoder
 9     RL     Rear left wheel encoder
 10    RR     Rear right wheel encoder
 11    CS     Checksum of bytes 1 - 10
</pre>

<p>Now if the messages are not sent in discrete packets (i.e. UDP), but asynchronously over a serial port, then the message bytes from different bots could become intermingled. The above protocol will at least verify the integrity of a received message, but the probability of receiving a valid message will decrease as the number of bots simultaneously transmitting to the PC increases.</p>

<p>A method for solving the asynchronous problem involves embedding the bot ID in each byte transmitted. If there are no more than 16 bots, then their ID could be placed in the upper nibble of the transmit byte and 4-bits of data in the lower nibble. It would then require two transmit bytes to send one data byte: 0x1F + 0x13 = 0x3F from bot #1. This would double the size of your messages and require code on the receiving side to parcel the incoming data into separate receive queues for each bot.</p>
",,8086281,720
4189094,2,4188782,2010-11-15T21:42:58.550,2,,214296,,2010-11-15T23:01:33.347,2010-11-15T23:01:33.347,2,,"<p>I was able to resolve the problem using <code>BuildCommDCB</code>:</p>

<pre><code>DCB dcb = {0};

if ( !::BuildCommDCB( _T(""baud=38400 parity=N data=8 stop=1""), &amp;dcb ) )
{
    TRACE(_T(""CSerialPort : Failed to build the DCB structure - Error: %d""), GetLastError());
    ThrowException();
}
</code></pre>
",,8123057,4354
50797798,2,4188782,2018-06-11T12:30:42.857,1,,4787818,,2018-06-11T14:13:20.063,2018-06-11T14:13:20.063,0,,"<p>This is my code and its working well.</p>

<pre><code>/* Try to open the port */
hCom = CreateFile(szPort, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);

if (hCom != INVALID_HANDLE_VALUE) {
    printf(""Handle success\n"");
}

    dcb = { 0 };
    dcb.DCBlength = sizeof(dcb);

    fSuccess = GetCommState(hCom, &amp;dcb);

    if (!fSuccess) {
        // Handle the error.
        printf(""GetCommState failed with error %d.\n"", GetLastError());
        CloseHandle(hCom);
        return APP_ERROR;
    }

    // Fill in DCB: 57,600 bps, 8 data bits, no parity, and 1 stop bit.
    dcb = { 0 };
    dcb.DCBlength = sizeof(dcb);

    dcb.BaudRate = CBR_115200;     // Set the baud rate
    dcb.ByteSize = 8;              // Data size, xmit, and rcv
    dcb.Parity = NOPARITY;         // No parity bit
    dcb.StopBits = ONESTOPBIT;     // One stop bit

    fSuccess = SetCommState(hCom, &amp;dcb);

    if (!fSuccess) {
        // Handle the error.
        printf(""SetCommState failed with error %d.\n"", GetLastError());
        CloseHandle(hCom);
        return APP_ERROR;
    }
}

printf(""Serial port successfully reconfigured.\n"");
</code></pre>
",,8234614,2114
4359018,2,4358975,2010-12-05T13:24:37.973,2,,298661,,2010-12-05T13:24:37.973,,3,,"<p>You should use a std::vector.</p>

<pre><code>class myCLass {
public:
    myClass(int size)
        : intarray(size) {
    for(int i = 0; i &lt; size; i++) intarray[i] = 0;
    }
private:
    std::vector&lt;int&gt; intarray;
};
</code></pre>
",,8263382,15019
4359039,2,4358975,2010-12-05T13:28:28.737,2,,81424,,2010-12-05T14:59:55.377,2010-12-05T14:59:55.377,0,,"<p>I'll try the following:</p>

<pre><code>class myClass
{
  public: 
    MyClass(int size);
    ~MyClass();
  private:
    int* _intArray;
};

MyClass::MyClass(int size) {
  _intArray = new int[size];
  for (int i=0; i&lt;size; ++i) _intArray[i] =0; // or use memset ...
}

MyClass::~MyClass() {
  delete[] _intArray;
}
</code></pre>

<p>Or, even better, use a STL <code>vector</code> instead ...</p>
",,8420304,2365
4359054,2,4358975,2010-12-05T13:33:05.470,2,,464581,,2010-12-05T13:33:05.470,,7,,"<p>Your code as I'm writing this:</p>

<pre><code>class myClass
{
  public: MyClass(int size);
  private:
    int _intArray[];
};
</code></pre>

<p>The declaration of <code>_intArray</code> is not valid C++: a raw array needs to have a size specified at compile time.</p>

<p>You can instead instead use a <code>std::vector</code>:</p>

<pre><code>class myClass
{
public:
    MyClass( int size )
        : intArray_( size )    // Vector of given size with zero-valued elements.
    {}

private:
    std::vector&lt;int&gt; intArray_;
};
</code></pre>

<p><em>Note 1</em>: some compilers may allow your original code as a language extension, in order to support the ""struct hack"" (that's a C technique that's not necessary in C++).</p>

<p><em>Note 2</em>: I've changed the name of your member. Generally underscores at the start of names can be problematic because they may conflict with names from the C++ implementation.</p>

<p>Cheers &amp; hth.,</p>
",,8464645,17780
4359061,2,4358975,2010-12-05T13:36:07.287,2,,418110,,2010-12-05T13:36:07.287,,0,,"<p>You should really use vectors as others have suggested. A work-around could be as shown (in case you do not want to use memcpy or a loop).</p>

<p>This would be useful if you have a really huge array. Note that it would add a level of indirection to access the array.</p>

<pre><code>class myClass 
{ 
public: 
   myClass(){
      mt = T();    // value initialize.
   }
private:
   struct T{
      int _intArray[10]; 
   } mt;
};

int main(){
   myClass m;
}
</code></pre>
",,8466554,1609
4370018,2,4369948,2010-12-06T19:11:07.240,4,,106671,,2010-12-06T19:11:07.240,,0,,"<pre><code>char lineOneC[8] = { 0, 1, 1, 0, 0, 0, 0, 1 };
unsigned char b = 0;

for ( int i = 7; i &gt;= 0; i-- ) {
    b |= lineOneC[i] &lt;&lt; ( 7 - i );
}
</code></pre>
",,8578756,28357
4370023,2,4369948,2010-12-06T19:11:48.263,5,,526383,,2010-12-06T19:11:48.263,,0,,"<p>Just shift 0 or 1 to its position in binary format. Like this</p>

<pre><code>char lineOneC[8] = {0,1,1,0,0,0,0,1}; 
char lineOneB = 0;
for(int i=0; i&lt;8;i++)
{
    lineOneB |= lineOneC[i] &lt;&lt; (7-i);
}
</code></pre>
",,8737642,1302
4370028,2,4369948,2010-12-06T19:12:52.490,6,,82320,,2010-12-06T19:12:52.490,,1,,"<p>I'm not sure about specific restrictions imposed by the Adruino platform,
but this should work on any standard compiler.</p>

<pre><code>char GetBitArrayAsByte(const char inputArray[8])
{
    char result = 0;
    for (int idx = 0; idx &lt; 8; ++idx)
    {
        result |= (inputArray[7-idx] &lt;&lt; idx);
    }
    return result;
}
</code></pre>

<p><a href=""http://codepad.org/eXxCJxll"" rel=""nofollow"">A test of this code is now on Codepad</a>, if that
helps.</p>
",,8819580,9058
4370032,2,4369948,2010-12-06T19:13:46.423,0,,529761,,2010-12-06T19:13:46.423,,0,,"<p>If you know that the values of your character array will always be either 1 or 0:</p>

<pre><code>char line[8] = { '0', '1', '1', '0', '0', '0', '0', '1'};

unsigned char linebyte = 0;
for (int i = 7, j = 0; j &lt; 8; --i, ++j)
{
    if (line[j] == '1')
    {
        linebyte |= (1 &lt;&lt; i);
    }
}
</code></pre>
",,8873998,4075
4370099,2,4369948,2010-12-06T19:22:15.693,0,,513660,,2010-12-07T03:14:49.833,2010-12-07T03:14:49.833,2,,"<p>If the result is supposed to be <code>B01100001</code>, then byte 0 is the MSB (most significant bit), not byte 7 ...</p>

<pre><code>char line[8] = { 0, 1, 1, 0, 0, 0, 0, 1 };
unsigned char b = 0;
for ( int ii = 0; ii &lt; 8; ii++ )
{
  b &lt;&lt;= 1;
  b |= line[ii];
}
</code></pre>

<p>The other answers I've seen, if I read them correctly, put the MSB on byte 7.</p>

<p>EDIT: Fixed quotes; miscopied it before.</p>
",,8941262,13688
4523700,2,4523653,2010-12-24T01:36:19.987,1,,177517,,2010-12-24T01:36:19.987,,3,,"<p>Uhm.. Probably I'm missing something here, but why don't you change that big switch to:</p>

<pre><code>
if(color != prev_color)
{
    shadowRam[addr][nChip-1] |= bitval;
    HT1632C::sendData(nChip, addr, shadowRam[addr][nChip-1]);
    shadowRam[addr+32][nChip-1] &= ~bitval;
    HT1632C::sendData(nChip, addr+32, shadowRam[addr+32][nChip-1]);
}
</code></pre>
",,9072320,64620
4524111,2,4523653,2010-12-24T04:00:05.350,2,,232593,,2010-12-24T06:19:05.803,2010-12-24T06:19:05.803,4,,"<p>This isn't a real answer, but I think it might be a step towards figuring this out.  Since there is so much code duplication and confusing conditional code, you should start with a refactor.  It will then be much easier to understand the algorithm.  I've taken a stab at it, though no promises that it will be bug free.</p>

<p>Get rid of getShadowRam, and modify plot to look like this:</p>

<pre><code>void HT1632C::plot (int x, int y, byte color)
{
  if (x &lt; 0 || x &gt; X_MAX || y &lt; 0 || y &gt; Y_MAX)
    return;

  if (color != BLACK &amp;&amp; color != GREEN &amp;&amp; color != RED &amp;&amp; color != ORANGE)
    return;

  // using local struct to allow local function definitions
  struct shadowRamAccessor {
    shadowRamAccessor(byte x, byte y) {
      nChip = (x &gt;= 32 ? 3 : 1)
        + x / 16
        + (y &gt; 7 ? 2 : 0);
      bitval = 8 &gt;&gt; (y &amp; 3);
      addr = ((x % 16) &lt;&lt; 1) + ((y % 8) &gt;&gt; 2);
      highAddr = addr + 32;
    }

    byte&amp; getShadowRam(byte addr) {
      return shadowRam[addr][nChip-1];
    }

    byte getPreviousColor() {
      byte greenComponent = getShadowRam(addr) &amp; bitval ? GREEN : BLACK;
      byte redComponent = getShadowRam(highAddr) &amp; bitval ? RED : BLACK;
      return greenComponent | redComponent;
    }

    void setValue(byte newColor) {
      byte prev_color = getPreviousColor();
      if(newColor != prev_color)
        setValue(newColor &amp; GREEN, newColor &amp; RED);
    }

    void setValue(bool greenBit, bool redBit)
    {
      HT1632C::sendData(nChip, addr,
        greenBit
          ? getShadowRam(addr) |= bitval
          : getShadowRam(addr) &amp;= !bitval
        );
      HT1632C::sendData(nChip, highAddr,
        redBit
          ? getShadowRam(highAddr) |= bitval
          : getShadowRam(highAddr) &amp;= ~bitval
        );
    }

    byte nChip, bitval, addr, highAddr;
  };

  shadowRamAccessor(x, y).setValue(color);
}
</code></pre>
",,9085028,1381
4729314,2,4674990,2011-01-18T21:35:06.723,1,,4304,,2011-01-19T05:38:35.933,2011-01-19T05:38:35.933,0,,"<blockquote>
  <p>Also, from what I read on the MSDN
  website, it looks like
  FileIOCompletionRoutine will get
  called asynchronously in its own
  thread. Is that correct?</p>
</blockquote>

<p>No, that is not correct. The completion routine gets called in the context of the thread in which it the ReadFileEx called is made. When it is ready to run, it is queued until the thread is in an ""alertable wait state"". That typically happens when you call one of the Wait* functions. Furthermore, from the MSDN for <a href=""http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx"" rel=""nofollow"">ReadFileEx</a>, it states:</p>

<blockquote>
  <p>The ReadFileEx function ignores the
  OVERLAPPED structure's hEvent member.
  An application is free to use that
  member for its own purposes in the
  context of a ReadFileEx call.
  ReadFileEx signals completion of its
  read operation by calling, or queuing
  a call to, the completion routine
  pointed to by lpCompletionRoutine, so
  it does not need an event handle.</p>
</blockquote>

<p>So the event you have created has no effect. Also, the reads will not be processed until ReadFileEx is called, so you have to reverse the order with your wait. What you should be doing in your reading loop is something like this (in Pseudocode):</p>

<pre><code>while(continue)
{
    ReadFileEx();
    WaitForSingleObject(s_hSerialPortRxThreadExitEvent);
    . . . etc . . .
}
</code></pre>
",,9110481,9328
4733385,2,4674990,2011-01-19T09:02:59.017,1,,286041,,2011-01-19T09:02:59.017,,1,,"<p>I don't know if I see your code wrong, but I see that you are setting up event, and waiting for the event without telling the O/S what are you waiting for, you should do ReadFileEx() first to tell O/S you are waiting for event when there's data in the buffer to read, then you do WFSO()/WFMO(), this what I do on my Serial port library (on receiver thread):</p>

<pre><code>do
{
    byteRead = 0;
    readBuffer = 0;
    if(!::ReadFile(this-&gt;commHandle,&amp;readBuffer,
                   1,NULL,&amp;this-&gt;readOverlapIO))
    {
         if(GetLastError() == ERROR_IO_PENDING)
         {
             if(::WaitForSingleObject(this-&gt;readOverlapIO.hEvent,INFINITE) == WAIT_OBJECT_0)
             {
                 if(!::GetOverlappedResult(this-&gt;commHandle,&amp;this-&gt;readOverlapIO,&amp;byteRead,FALSE))
                 {
                     byteRead = 0;
                 }
             }
         }
    }
    else
    {
         if(!::GetOverlappedResult(this-&gt;commHandle,&amp;this-&gt;readOverlapIO,&amp;byteRead,FALSE))
         {
              byteRead = 0;
         }
    }
    if(byteRead &gt; 0)
    {
          totalByteRead += this-&gt;ringBuffer.push(readBuffer,1);
    }
}while(byteRead);
</code></pre>

<p>I use completion event using event signal here, you can change it to completion function if you wanted to.</p>
",,9144794,1431
8115262,2,4705790,2011-11-13T22:28:46.023,8,,43839,,2011-11-15T21:42:17.023,2011-11-15T21:42:17.023,0,,"<p>I agree with you; this is an intolerable way to develop software: it requires every file that you need to be in the same directory as the main program!</p>

<p>To get around this, I use <code>make</code> to put together a single <code>.h</code> file from my <code>.h</code> and <code>.cpp</code> sources - you can see this used in <a href=""https://github.com/rec/swirly-avr/blob/master/Makefile"" rel=""noreferrer"">this Makefile</a>: </p>

<pre><code>PREPROCESS=gcc -E -C -x c -iquote ./src
# -E : Stop after preprocessing.
# -C : Don't discard comments.
# -x c : Treat the file as C code.
# -iquote ./src : Use ./src for the non-system include path.

TARGETS=sketches/morse/morse.h

all: $(TARGETS)

clean:
    rm $(TARGETS)

%.h: %.h.in
    $(PREPROCESS) $&lt; -o $@
</code></pre>

<p>Arduino is very picky about file endings - if you put a <code>.cpp</code> or <code>.cc</code> file in its directory it automatically uses it in the source, and you can't include anything that's not a <code>.cpp</code>, <code>.cc</code> or <code>.h</code> - so this is about the only way to do it.</p>

<p>I use a similar trick also to put together JavaScript files <a href=""https://github.com/rec/swirly/blob/master/Makefile"" rel=""noreferrer"">here</a>.</p>

<p>This requires that you run <code>make</code> after editing your files, but since I'm using an external editor (Emacs) anyway, this is zero hassle for me.</p>
",,9395579,495
45899264,2,4705790,2017-08-26T20:08:55.977,1,,1034133,,2017-08-26T20:08:55.977,,0,,"<p>What has worked for me is to create a dir, for example ""src"" under the sketch dir, and under that a dir for each personal library. </p>

<p>Example:</p>

<p>I have a project called ObstacleRobot, under that a folder for my sketch, named obstaclerobot (automatically created by the IDE) and there my sketch ""obstacleRobot.ino""</p>

<p>Up to now we have:</p>

<pre><code> /ObstacleRobot
    /obstaclerobot
       obstacleRobot.ino
</code></pre>

<p>Then I wanted to include a personal library that was fully related with this project and made no sense in including it in the IDE libraries, well in fact I want to do this for each part of the robot but I'm still working on it.</p>

<p>What in the end worked for me was:</p>

<pre><code> /ObstacleRobot
    /obstaclerobot
       obstacleRobot.ino
       /src
          /Sonar
             Sonar.h
             Sonar.cpp
</code></pre>

<p>Then what you have to do in the main sketch is to write the include as follows:</p>

<pre><code>#include ""src/Sonar/Sonar.h""
</code></pre>

<p>And thats all.</p>
",,9406601,230
4779066,2,4776231,2011-01-24T05:58:08.787,2,,557958,,2011-01-24T05:58:08.787,,1,,"<p>How about a function like this?</p>

<pre><code>int pixelAt(int index, int min, int max, int a, int b, int b_2)
{
    int pixel = -1;

    if (min &lt;= index &amp;&amp; index &lt;= max)
    {
        pixel = a * index + b;
        if (i % 2)
        {
            pixel += b_2;
        }
    }

    return pixel;
}
</code></pre>

<p>Then you would have:</p>

<pre><code>for (int i = 0; i &lt; numPixels; i++)
{
    // This assumes setColor(-1, x) does nothing
    setColor(pixelAt(i, 0, numPixels, 1, 0, 0), X);
    setColor(pixelAt(i, 0, 15, 1, 18, -5), Y);
    setColor(pixelAt(i, 0, 10, -3, numPixels, 0), Z);
}
</code></pre>

<p>Of course, the <code>pixelAt</code> function will get much more complicated if you add new requirements, such as changing the multiplication factor for even numbers, treating multiples of 3 differently, etc.  However, you could use functions similar to this one to reduce the number of functions you have to write.  One for simple patterns, one for even/odd patterns, one for multiples of threes, and so on.  Depends on how different the patterns are, and how much memory space you have for code.</p>
",,9662476,1826
28746343,2,5003548,2015-02-26T15:26:09.507,1,,4259832,,2015-02-27T18:26:30.573,2015-02-27T18:26:30.573,0,,"<p>You can get connected to the MATLAB interface by simply using the <code>serial</code> and <code>fopen</code> commands on MATLAB</p>

<p>eg: </p>

<pre><code>s=serial('COM2','Baudrate',9600,'Databits',8);

fopen(s);

count=0;

while count&lt;50

    a=fscanf(s);

    count=count+1;

end

fclose(s);
</code></pre>

<p>whereas on Arduino, use <code>Serial.print()</code> function.</p>

<p>Simple data can be sent using this. I never tried camera by using this technique. But by using a camera shield mounted on Ardunino, taking snapshots and later sending the data through Arduino to MATLAB as a matrix might work. Just an idea, might be possible.</p>

<p>Edit1:
I was looked up more into this, and found some potential hardwares for the same:
 1. ArduCam Shield for Arduino
 2. <a href=""https://www.sparkfun.com/products/11418"" rel=""nofollow"">https://www.sparkfun.com/products/11418</a></p>
",,9683869,2220
20505087,2,5534290,2013-12-10T21:00:02.330,0,,3088596,,2013-12-10T21:00:02.330,,0,,"<p>I found the easiest way to Serial print a single string composed of integers and your words (message):</p>

<p>in scketch :</p>

<pre><code>int w = 12;

Serial.Print (""my number is: "");

Serial.Print (w);

Serial.Println ("" - which is to be used in calculation!""
</code></pre>

<p>RESULT: </p>

<p>On serial monitor you will see (as a single LINE!!!!!!!!!!):</p>

<p>my number is: 12 - which is to be used in calculation!   </p>
",,9701895,3205
25867406,2,5534290,2014-09-16T11:19:35.140,0,,634355,,2014-09-16T13:09:53.407,2014-09-16T13:09:53.407,1,,"<p>The fastest and preferred way to do string concatenation under Arduino is,</p>

<ul>
<li>Use the String class.</li>
<li>If you really need the speed and/or simply want to avoid creating new in-memory strings with every concatenation operation, <strong>reserve the needed memory ahead of time with reserve()</strong>.</li>
<li>First, set the object to an empty string """".</li>
<li>Then, append the needed characters or strings by invoking concat() or the operator +=, <strong>using exactly one concat() or += operation per line of code</strong>. This is to avoid the creation of temporary Strings objects.</li>
<li>By executing reserve() in advance, the String object will be effectively acting as a line buffer.</li>
</ul>

<p>By applying the above guidelines, <strong>the concatenation operations will be done in place</strong>.</p>

<p>Note that reserve() should be called with the most appropriate value for the line buffer capacity, i.e.: maximum number of characters you need before String does a realloc(), not including the null-terminating character '\0'.</p>

<p>Three alternatives follow:</p>

<p>1) Here is the sample code,</p>

<pre><code>// Declaration, outside setup() and loop()
String line;

// Inside setup()
// Use the appropriate value for reserve(), depending on on your actual usage.
line.reserve(10);

// Inside loop()
line = """";
line += minutes;
line += "":"";
line += seconds;
line += "":"";
line += m;
Serial.println(line);
</code></pre>

<p>2) As an alternative to calling reserve() at setup(), you could declare and initialize the String with a ""template"" or dummy string which has the desired (maximum) length.</p>

<p>Here is the sample code for this alternative,</p>

<pre><code>// Declaration, outside setup() and loop()
String line = ""XXXX:YY:ZZ"";

// No need to use reserve() inside setup()

// Inside loop()
line = """";
line += minutes;
line += "":"";
line += seconds;
line += "":"";
line += m;
Serial.println(line);
</code></pre>

<p>The first approach allows you to use reserve() with a dynamically calculated maximum length value, while the second approach results in somewhat cleaner to read code when you have a ""template"" or known fixed length for the string you will be later composing.</p>

<p>3) <strong>If you only need to output the data to the output stream (usually Serial), this is the fastest and the most compact code, with no need of String or external libraries,</strong></p>

<pre><code>// No need to declare a String outside setup() and loop()
// No need to use reserve() inside setup()

// Inside loop()
Serial.print(minutes);
Serial.print("":"");
Serial.print(seconds);
Serial.print("":"");
Serial.println(m);
</code></pre>

<p>Note: the answer by John Y does exactly the same as my last piece of code, except for his ""simpler"" to read code (assuming you feel comfortable with the operator &lt;&lt;, used as C++ streaming syntactic sugar). In some cases, however, using the Streaming library will generate slightly larger/slower code.</p>
",,9729881,153
5612212,2,5612174,2011-04-10T13:57:08.887,6,,121747,,2011-04-10T13:57:08.887,,2,,"<p>Yes, you could easily use masking to get around that issue..</p>

<p>Every byte (unsigned char) will contain 8 boolean values, to get the i-th you can just use <code>values &amp; (1 &lt;&lt; i)</code> in if tests, and it will work since if the correct bit is set, then result will be != to 0.</p>

<p>To set instead a bit just shift it and or to the value:   <code>values | (1 &lt;&lt; i)</code> (in case of unset you have to AND it with 0).</p>

<p>Another solution could be to use a packed struct:</p>

<pre><code>struct Bools
{
  int b1 : 1;
  int b2 : 1;
  int b3 : 1;
  ... // up to b8
}
</code></pre>

<p>This should manage elements with direct access to the boolean value and allow you to define an union to manage them either as 8 single bit booleans value either as bytes.</p>
",,9805829,9715
5615232,2,5615095,2011-04-10T22:49:41.020,3,,72035,,2011-04-10T22:49:41.020,,0,,"<p>A hardware interrupt on the Arduino occurs when one of the interrupt pins receives a change of state. The function to use, if you have access to the Arduino library, is <a href=""http://www.arduino.cc/en/Reference/AttachInterrupt"" rel=""nofollow"">attachInterrupt</a>.</p>

<p>Example code to listen for an interrupt (derived from the documentation I linked to, I added comments to help explain):</p>

<pre><code>// The Arduino has an LED configured at pin 13
int pin = 13;
// Holds the current state of the LED to handle toggling
volatile int state = LOW;

void setup()
{
  pinMode(pin, OUTPUT);
  // First Parameter:
  // 0 references the interrupt number. On the Duemilanove, interrupt 0
  // corresponds to digital pin 2 and interrupt 1 corresponds to digital pin
  // 3. There are only two interrupt pins for the Duemilanove and I believe
  // the Uno too.
  // Second Parameter:
  // blink is the name of the function to call when an interrupt is detected
  // Third Parameter:
  // CHANGE is the event that occurs on that pin. CHANGE implies the pin
  // changed values. There is also LOW, RISING, and FALLING.
  attachInterrupt(0, blink, CHANGE);
}

void loop()
{
  // Turns the LED on or off depending on the state
  digitalWrite(pin, state);
}

void blink()
{
  // Toggles the state
  state = !state;
}
</code></pre>

<p>There is also a concept of Pin Change Interrupts that is supported on every pin. See the bottom part of <a href=""http://forums.trossenrobotics.com/tutorials/how-to-diy-128/an-introduction-to-interrupts-3248/"" rel=""nofollow"">introduction to interrupts</a> for more info.</p>

<p>However, sometimes a hardware interrupt can be avoided by refactoring your code. For example, keep your loop() running quickly --- mostly just reading inputs, limit the use of delay() --- and in the loop, call a function when the targeted inputted value is detected.</p>
",,9831119,703
5635333,2,5635294,2011-04-12T12:41:10.697,0,,243245,,2011-04-12T12:41:10.697,,1,,"<p>I can't 100% explain that behaviour - I'd expect you wouldn't get any characters printed as it'd be using Returner::test - but if you're overriding a function in C++ you need to declare it virtual in the base class:</p>

<pre><code>class Returner 
{
  public:   
    Returner(){}
    virtual char test()
    {    
    }
};
</code></pre>

<p>Without test being virtual, the line</p>

<pre><code>Serial.print( retrn.test() );
</code></pre>

<p>(don't you mean <code>retrn-&gt;test()</code>?) will just pick one implementation of <code>test</code> and use it always. As above I'd expect this to be the empty <code>Returner::test()</code>. You may also either need to make Returner::test abstract</p>

<pre><code>    virtual char test() = 0;
</code></pre>

<p>or return some value if you're leaving it with a function body.</p>
",,9901058,23824
5732390,2,5731863,2011-04-20T14:57:20.893,160,,226621,,2011-04-20T14:57:20.893,,7,,"<p>Let's forget the math and try to solve this intuitively.</p>

<p>First, if we want to map input numbers in the range [<code>0</code>, <code>x</code>] to output range [<code>0</code>, <code>y</code>], we just need to scale by an appropriate amount.  0 goes to 0, <code>x</code> goes to <code>y</code>, and a number <code>t</code> will go to <code>(y/x)*t</code>.</p>

<p>So, let's reduce your problem to the above simpler problem.</p>

<p>An input range of [<code>input_start</code>, <code>input_end</code>] has <code>input_end - input_start + 1</code> numbers.  So it's equivalent to a range of [<code>0</code>, <code>r</code>], where <code>r = input_end - input_start</code>.</p>

<p>Similarly, the output range is equivalent to [<code>0</code>, <code>R</code>], where <code>R = output_end - output_start</code>.</p>

<p>An input of <code>input</code> is equivalent to <code>x = input - input_start</code>.  This, from the first paragraph will translate to <code>y = (R/r)*x</code>.  Then, we can translate the <code>y</code> value back to the original output range by adding <code>output_start</code>: <code>output = output_start + y</code>.</p>

<p>This gives us:</p>

<pre><code>output = output_start + ((output_end - output_start) / (input_end - input_start)) * (input - input_start)
</code></pre>

<p>Or, another way:</p>

<pre><code>/* Note, ""slope"" below is a constant for given numbers, so if you are calculating
   a lot of output values, it makes sense to calculate it once.  It also makes
   understanding the code easier */
slope = (output_end - output_start) / (input_end - input_start)
output = output_start + slope * (input - input_start)
</code></pre>

<p>Now, this being C, and division in C truncates, you should try to get a more accurate answer by calculating things in floating-point:</p>

<pre><code>double slope = 1.0 * (output_end - output_start) / (input_end - input_start)
output = output_start + slope * (input - input_start)
</code></pre>

<p>If wanted to be even more correct, you would do a rounding instead of truncation in the final step.  You can do this by writing a simple <code>round</code> function:</p>

<pre><code>#include &lt;math.h&gt;
double round(double d)
{
    return floor(d + 0.5);
}
</code></pre>

<p>Then:</p>

<pre><code>output = output_start + round(slope * (input - input_start))
</code></pre>
",,9917307,6782
5735770,2,5731863,2011-04-20T19:45:56.467,26,,39975,,2011-04-20T19:45:56.467,,2,,"<p>Arduino has this built-in as <a href=""http://www.arduino.cc/en/Reference/Map"">map</a>.</p>

<p>Example:</p>

<pre><code>/* Map an analog value to 8 bits (0 to 255) */
void setup() {}

void loop()
{
  int val = analogRead(0);
  val = map(val, 0, 1023, 0, 255);
  analogWrite(9, val);
}
</code></pre>

<p>It also has the implementation on that page:</p>

<pre><code>long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
</code></pre>
",,9956145,1896
5752284,2,5752175,2011-04-22T04:27:42.107,0,,,user73774,2011-04-22T04:27:42.107,,0,,"<p>Char array in ""ch"", byte array as ""out""</p>

<pre><code>byte conv[23] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15};

// Loop over the byte array from 0 to 9, stepping by 2
int j = 0;
for (int i = 0; i &lt; 10; i += 2) {
  out[j] = conv[ch[i]-'0'] * 16 + conv[ch[i+1]-'0'];
  j++;
}
</code></pre>

<p>Untested.</p>

<p>The trick is in the array 'conv'. It's a fragment of an ASCII table, starting with the character for 0. The -1's are for the junk between '9' and 'A'.</p>

<p>Oh, this is also not a safe or defensive routine.  Bad input <em>will</em> result in crashes, glitches, etc.</p>
",,9986591,78906
6194320,2,5781559,2011-05-31T22:32:02.453,0,,4023,,2011-05-31T22:32:02.453,,0,,"<p>The following code works as intended using the Arduino software version 0022 and an Arduino Duemilanove w/ ATmega 328:</p>

<pre><code>#define ARG_DELIMITER ','

class SlaveTalkClass
{
  public:
    String join(const String strs[], const int len) {
      String result = """";
      for (int i = 0; i &lt; len; i++) {
        result += strs[i] + ARG_DELIMITER;
        Serial.println(result);
      }
      return result.substring(0, result.length() - 1);
    }
} SlaveTalk;

void setup()
{
  Serial.begin(9600);
}

void loop()
{
  const String args[3] = {""foo"", ""bar"", ""baz""};
  Serial.println(SlaveTalk.join(args, 3));
}
</code></pre>

<p>It repeatedly prints the following to the Serial Monitor:</p>

<pre><code>foo,
foo,bar,
foo,bar,baz,
foo,bar,baz
</code></pre>
",,10059823,1359
5827347,2,5827343,2011-04-29T02:53:14.717,3,,505088,,2011-04-29T02:58:33.560,2011-04-29T02:58:33.560,6,,"<p>You are returning a stack allocated variable, <code>time</code>, from <code>timecompare()</code>. This is illegal since stack allocated memory is only valid in the function in which the variable is declared.</p>

<p>Instead you need to return a heap allocated string.  Your compiler should be warning you of this.  You could write it like this:</p>

<pre><code>char* timecompare(){
    char* time = malloc(8);
    snprintf(time,8,""%i:%02i"",hour(),minute());
    return time;
}
</code></pre>

<p>Remember to <code>free()</code> the memory after you are finished with it.</p>
",,10079338,1504
5863563,2,5863319,2011-05-02T23:24:18.490,1,,592182,,2011-05-07T19:55:38.233,2011-05-07T19:55:38.233,0,,"<p>Although not very popular, you do have an alternative, in that you can use bit fields to perform the type of operation you're talking about. So, on <a href=""http://www.ideone.com/bOsoU"" rel=""nofollow"">ideone</a>, the following code would perform the action you've suggested.</p>

<pre><code>union combine {
    struct bits{
        int x: 1;
        int y: 1;
        int z: 1;
        int pad : 29;
    } bitvalues;
    int value;
};

int main() {
    union combine test;
    test.bitvalues.x = 1;
    test.bitvalues.y = 0;
    test.bitvalues.z = 1;
    test.bitvalues.pad = 0;
    printf(""result: %d\n"", test.value);
    return 0;
}
</code></pre>

<p>It's important to note however, that because you're using a combination of a bitfields and a union, <strong>this is not a portable solution</strong>.  It is dependent on the order that you define your bits in, matching the bit/byte order for integer on that machine.  So, there is a way to do it without bit shifting, but you're almost certainly better off going with the bit shifting solution.</p>
",,10149589,2105
5931655,2,5931572,2011-05-09T01:38:30.087,4,,530160,,2011-05-09T01:38:30.087,,13,,"<p>Arduino is C, except that this is inserted into every program:</p>

<pre><code>void main() {
  setup();
  for(;;) {
    loop();
  }
}
</code></pre>
",,10220673,1826
6056338,2,6056014,2011-05-19T09:14:03.113,1,,6909,,2011-05-19T09:14:03.113,,0,,"<p>Try this... you will probably need to do the code for exceptions (ex: if the response is bigger than 2024)</p>

<pre><code>bool SendModemATCommand(const string &amp;strCommand, int iModemPort, string &amp;strRetValue)
{
    bool bRetValue = false;

    strRetValue = """";
    char cBuffer[2024];

    HANDLE hCom = NULL;   
    char cComPort[64];
    sprintf_s(cComPort,""\\\\.\\COM%d"", iModemPort);


    hCom = CreateFile( cComPort,
                    GENERIC_READ | GENERIC_WRITE,
                    0,    // must be opened with exclusive-access
                    NULL, // no security attributes
                    OPEN_EXISTING, // must use OPEN_EXISTING
                    0,    // not overlapped I/O
                    NULL  // hTemplate must be NULL for comm devices
                    );

    if (hCom != INVALID_HANDLE_VALUE) 
    {
        COMMTIMEOUTS comTimeOuts;
        comTimeOuts.ReadIntervalTimeout = MAXDWORD;
        comTimeOuts.ReadTotalTimeoutMultiplier = MAXDWORD;
        comTimeOuts.ReadTotalTimeoutConstant = 0;//MAXDWORD;
        comTimeOuts.WriteTotalTimeoutMultiplier = 0;
        comTimeOuts.WriteTotalTimeoutConstant = 0;
        if(SetCommTimeouts(hCom, &amp;comTimeOuts))
        {
            DCB dcb;
            dcb.DCBlength = sizeof(DCB);
            if(GetCommState(hCom, &amp;dcb))
            {
                DWORD dwBytesWritten = 0;                  
                DWORD dwBytesRead = 0;
                DWORD dwBytesTotal = 0;

                if( WriteFile(hCom, strCommand.c_str(), (int)strCommand.size(), &amp;dwBytesWritten, NULL) )
                {
                    if(dwBytesWritten == strCommand.size())
                    {
                        dwBytesRead = 0;
                        DWORD tickStart = GetTickCount();
                        bool bTimeOut = false;                      
                        while(true)
                        {
                            while(ReadFile(hCom, cBuffer + dwBytesTotal, 1, &amp;dwBytesRead, NULL))
                            {       
                                if(dwBytesRead == 0 &amp;&amp; dwBytesTotal != dwBytesWritten)
                                    break;
                                dwBytesTotal += dwBytesRead;                                
                            }
                            if ( dwBytesTotal == 0 )
                            {
                                // timeout
                                if ( GetTickCount() - tickStart &gt; 10000) // 10 Seconds
                                {
                                    bTimeOut = true;
                                    break;                              
                                }
                            }
                            else
                                break;
                        }                   

                        cBuffer[dwBytesTotal] = '\0';
                        strRetValue = cBuffer;

                        if(bTimeOut)
                            strRetValue = ""Timed out:"" + strCommand;
                        else
                            bRetValue = true;
                    }
                }
            }
        }
        CloseHandle(hCom);
    }

    return bRetValue;
}
</code></pre>
",,10268572,355
6070835,2,6068655,2011-05-20T10:51:16.720,1,,748725,,2011-05-20T10:51:16.720,,0,,"<p>You might try setting all the DCB options and clearing port errors</p>

<pre><code>// Common settings
dcbSerialParams.DCBlength = sizeof( dcbSerialParams );
dcbSerialParams.ByteSize = 8;
dcbSerialParams.BaudRate = CBR_9600;
dcbSerialParams.fParity = FALSE;
dcbSerialParams.Parity = NOPARITY;
dcbSerialParams.StopBits = ONESTOPBIT;
dcbSerialParams.fDtrControl = 0;
dcbSerialParams.fRtsControl = 0;

// If you say so
dcbSerialParams.fOutX = TRUE;
dcbSerialParams.fInX = TRUE;

// Not so common settings
dcbSerialParams.fBinary = FALSE;
dcbSerialParams.fParity = FALSE;
dcbSerialParams.fOutxCtsFlow = FALSE;
dcbSerialParams.fOutxDsrFlow = FALSE;
dcbSerialParams.fDsrSensitivity = FALSE;
dcbSerialParams.fErrorChar = FALSE;
dcbSerialParams.fNull = FALSE;
dcbSerialParams.fAbortOnError = FALSE;

// Clear errors
unsigned long ulCommErr = 0;
ClearCommBreak( hSerial );
ClearCommError( hSerial, &amp;ulCommErr, NULL );
</code></pre>

<p>Probably unrelated, but I noticed I at some point added a security descriptor to CreateFile() in my serial code, I believe some configuration of Windows Server required it.</p>

<pre><code>// Allow access
SECURITY_ATTRIBUTES  sa, *pSa = NULL;
sa.nLength = sizeof( SECURITY_ATTRIBUTES );
sa.bInheritHandle = TRUE;
sa.lpSecurityDescriptor = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);
if ( sa.lpSecurityDescriptor
     &amp;&amp; InitializeSecurityDescriptor( (SECURITY_DESCRIPTOR*)sa.lpSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION )
     &amp;&amp; SetSecurityDescriptorDacl( (SECURITY_DESCRIPTOR*)sa.lpSecurityDescriptor, TRUE, (PACL)NULL, FALSE ) )
    pSa = &amp;sa;

// Open the port
hSerial = CreateFile(   x_pPort, 
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        pSa,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

if ( pSa )
    LocalFree( pSa-&gt;lpSecurityDescriptor );
</code></pre>
",,10307496,34671
6343413,2,6342384,2011-06-14T12:24:48.610,0,,782296,,2011-09-06T13:32:39.340,2011-09-06T13:32:39.340,0,,"<p>Try using a <code>while</code> loop instead of a <code>for</code> loop. Increment the value when there is no obstacle and break when you find an obstruction:</p>

<pre><code>{
    ......
    ......
    i = rand()%7;
    move( pos[i]);

    if (i&lt;5)
        break;
    else
        continue;
    .......
    .......
}
</code></pre>

<p>This will randomly choose the position until you get an obstacle and also there will be no need to reset it as the loop will automatically break on encountering an obstacle.</p>
",,10319655,3191
6369424,2,6342384,2011-06-16T09:05:26.483,1,,26639,,2011-06-16T09:05:26.483,,0,,"<p>If I understand your question correctly, you want the servo to make a sweeping movement from left to right and then back from right to left. Measuring the distance to an object that can be in front of the robot at each angle. If there is a free way ahead of the robot, the find method returns.</p>

<pre><code>int pos[] = {0, 45, 90, 135, 180, -1};

void find()
{
    int i = 0;
    int direction = 1;

    do {
        move(pos[i]);
        i += direction;
        if (pos[i+direction] == -1) direction = -1; 
        if (i==0) direction = 1;
    } while(measure_distance() &lt;= 5); 
}
</code></pre>

<p>Instead of recursion, there is a while loop that only exits when there is a distance greater then 5.</p>

<p>The 'pos' array has a sentinel at the end (-1). This is an invalid angle and can be used to find the end of the array. There is no need to calculate the number of elements.</p>

<p>The left-right, right-left movement comes from using the 'direction' variable. It is rather easy to detect either the beginning (i==0) or the end of the 'pos' array (pos[i+1] == -1), at which point we reverse the direction. </p>

<p>There is also no need to repeat the angles after 180 degrees. The sequence we get is:</p>

<blockquote>
  <p>0 45 90 135 180 135 90 45 0 45 90 ...</p>
</blockquote>

<p>We can even reduce the code with one line...</p>

<pre><code>...
if (pos[i+direction] == -1 || i == 0) direction *= -1; 
...
</code></pre>

<p>Cheers,
Johan</p>
",,10331866,19064
7100687,2,7100658,2011-08-17T23:18:47.850,12,,587884,,2011-08-25T15:47:26.617,2011-08-25T15:47:26.617,3,,"<p>Yes, you can. It's called recursion.</p>

<pre><code>void foo(){
   foo(); //This is legal.
}
</code></pre>

<p>Of course you need to return from it to avoid infinite recursive calls. Failing to return will cause a stack overflow. Here's a better example:</p>

<pre><code>void foo(int n){
    if (n == 0)
        return;
    foo(--n);
}
</code></pre>
",,10451128,21185
7100703,2,7100658,2011-08-17T23:21:59.093,5,,358892,,2011-08-25T15:39:32.000,2011-08-25T15:39:32.000,0,,"<p>See <em><a href=""http://en.wikipedia.org/wiki/Recursion_%28computer_science%29"" rel=""nofollow"">Recursion (computer science)</a></em> (Wikipedia).</p>

<p>An example of calling a function inside a function:</p>

<pre><code># include&lt;stdio.h&gt;

int factorial(unsigned int number)
{
    if (number &lt;= 1)
        return 1;
    return number * factorial(number - 1);
}

void main()
{
    int x = 5;
    printf(""factorial of %d is %d"",x,factorial(x));
}
</code></pre>
",,10494797,772
7100705,2,7100658,2011-08-17T23:22:29.850,1,,850286,,2011-08-25T15:44:57.693,2011-08-25T15:44:57.693,4,,"<p><strong>Update</strong></p>

<p>Okay, I thought this was about ""getting every function value"". As other posters said, this is called recursion. A few notes though:</p>

<p>Recursion is faster than iteration (I don't have benchmark results on hand, but I ran them one year ago on an <a href=""http://en.wikipedia.org/wiki/Intel_Core#Core_i5"" rel=""nofollow"">Intel Core i5</a>).</p>

<pre><code>//Iteration
function do_stuff(i)
{
    //BLABLAH
}

for (i = 0; i &lt;5; i++) {
    do_stuff();
}

//Recursion
function do_stuff(int i)
{
    //BLABLAH
    if (i &lt; 5) {
        do_stuff(i + 1);
    }
}
</code></pre>

<ul>
<li>You can recurse multiple times but you have to find a way to make the recursion stop or...</li>
<li>If your recursion goes down too far (think ""Inception"" times a million...), you run into the risk of overflowing your available stack memory just by entering the same function a millionth time.</li>
</ul>
",,10663705,209
7104803,2,7104079,2011-08-18T08:57:41.110,2,,898478,,2011-08-18T09:48:11.583,2011-08-18T09:48:11.583,3,,"<p>Maybe not best algorithm, but here's an implementation example (standard C):</p>

<pre><code>char* formatLong(long toBeFormatted)
{
    // Get the string representation as is
    char* buffer = (char*) malloc(sizeof(long));
    ltoa(toBeFormatted, buffer, 10);

    // Calculate how much commas there will be
    unsigned int buff_length = strlen(buffer);
    unsigned int num_commas = buff_length / 3;
    unsigned int digits_left = buff_length % 3;
    if (digits_left == 0)
    {
        num_commas--;
    }

    // Allocate space for final string representation
    unsigned int final_length = buff_length + num_commas + 1;
    char* final = (char*) malloc(final_length);
    memset(final, 0, final_length);

    // Parse strings from last to first to count positions
    int final_pos = final_length - 2;
    int buff_pos = buff_length - 1;
    int i = 0;
    while(final_pos &gt;= 0)
    {
        final[final_pos--] = buffer[buff_pos--];
        i++;
        if (i % 3 == 0)
        {
            final[final_pos--] = ',';
        }
    }

    // Free obsolete memory and return buffer
    free(buffer);
    return final;
}
</code></pre>
",,10681153,3816
7104875,2,7104079,2011-08-18T09:05:04.223,0,,818924,,2011-08-18T09:41:56.260,2011-08-18T09:41:56.260,0,,"<p>You could try the following:</p>

<pre><code>std::string formatLong(long l) {
    int power = 0;
    while (l / (pow(1000, power)) { power += 1; }

    power -= 1;

    std::stringstream s;
    while (power) {
         s &lt;&lt;  l / pow(1000, power);
         s &lt;&lt; "","";
         l % (pow(1000, power));
         power -= 1;
    }
    return s-&gt;str();
}
</code></pre>

<p>The code is a shot from the hip, but the idea should work.</p>
",,10687080,2493
7105916,2,7104079,2011-08-18T10:23:17.950,4,,12711,,2011-08-19T20:29:07.040,2011-08-19T20:29:07.040,3,,"<p>I'm not sure what toolset gets used on Arduino. Sometimes the library will support a non-standard 'thousands grouping' flag - the single-quote character is the typical extension:</p>

<pre><code>printf(""%'ld"",long_val);
</code></pre>

<p>If your library doesn't support this, something like the following might do:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

size_t strlcpy( char* dest, char const* src, size_t dest_size);

size_t format_long( long x, char* buf, size_t bufsize)
{
    // This code assumes 32-bit long, is that the
    // case on Arduino?  Modifying it to be able to
    // handle 64-bit longs (or to not care) should be
    // pretty straightforward if that's necessary.

    char scratch[sizeof(""-2,147,483,648"")];
    char* p = scratch + sizeof(scratch);    // Work from end of buffer
    int neg = (x &lt; 0);

    // Handle a couple special cases
    if (x == 0) {
        return strlcpy( buf, ""0"", bufsize);
    }
    if (x == INT_MIN) {
        // Lazy way of handling this special case
        return strlcpy( buf, ""-2,147,483,648"", bufsize);
    }

    // Work with positive values from here on
    if (x &lt; 0) x = -x;

    int group_counter = 3;
    *(--p) = 0; // Null terminate the scratch buffer

    while (x != 0) {
        int digit = x % 10;
        x = x / 10;

        assert( p != &amp;scratch[0]);
        *(--p) = ""0123456789""[digit];

        if ((x != 0) &amp;&amp; (--group_counter == 0)) {
            assert( p != &amp;scratch[0]);
            *(--p) = ',';
            group_counter = 3;
        }
    }

    if (neg) {
        assert( p != &amp;scratch[0]);
        *(--p) = '-';
    }
    return strlcpy(buf, p, bufsize);
}


/*
    A non-optimal strlcpy() implementation that helps copying string
    without danger of buffer overflow.

    This is provided just in case you don't have an implementation
    so the code above will actually compile and run.
*/
size_t strlcpy( char* dest, char const* src, size_t dest_size)
{
    size_t len = strlen(src);

    if (dest_size == 0) {
        // nothing to copy - just return how long the buffer should be
        //  (note that the return value doens't include the null terminator)
        return len;
    }

    size_t tocopy = (dest_size &lt;= len) ? dest_size-1 : len;

    memmove( dest, src, tocopy);
    dest[tocopy] = 0;

    return len;
}
</code></pre>
",,10824081,332
55427706,2,7104079,2019-03-30T02:50:11.833,0,,11280141,,2019-03-30T03:59:17.623,2019-03-30T03:59:17.623,0,,"<p>maybe can help you..
i use this sketch to make thousands separator on arduino LCD.</p>

<pre><code>//&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;
//TULISAN DENGAN SPARATOR BELI BBM
//&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;
    void TulisanDesimalBeli(char customKey, String DataStr)
{
  c=DataStr.length();
    if (c&lt;=7)
    {
      if (c&lt;4)
       {
       lcd.print(customKey);
       }  
       else if (c==4)
       {
        DataStr1=DataStr;
        DataStr.remove(c-3);
        DataStr1.remove(0,(c-3));
        DataStr+=""."" + DataStr1;
        lcd.setCursor(0,1);
        lcd.print(""Jml:Rp."");
        lcd.print(DataStr);
        }
        else if ((c&gt;4)&amp;&amp;(c&lt;=6))
        {
        DataStr1=DataStr;
        DataStr.remove(c-3);
        DataStr1.remove(0,(c-3));
        DataStr+=""."" + DataStr1;
        lcd.setCursor(0,1);
        lcd.print(""Jml:Rp."");
        lcd.print(DataStr);
        }
        else if (c&gt;6)
        {
        DataStr1=DataStr;
        DataStr.remove(c-3);
        DataStr1.remove(0,(c-3));
        DataStr+=""."" + DataStr1;

        DataStr1=DataStr;
        DataStr.remove((c-6));
        DataStr1.remove(0,(c-6));
        DataStr+=""."" + DataStr1;

        lcd.setCursor(0,1);
        lcd.print(""Jml:Rp."");
        lcd.print(DataStr);
        }
    }
    }
</code></pre>

<p>and this sketch thal called the subroutine (void TulisanDesimaBeli)</p>

<pre><code>if ((customKey&lt;='9')&amp;&amp;(customKey&gt;='0'))
    { 
      DataStr+=customKey;
      TulisanDesimalBeli(customKey,DataStr);
      a=(int)customKey&amp;0x0F;
      HarBel=HarBel*10;
      HarBel=HarBel+a;
     }
</code></pre>

<p>sorry, my english is worst, you can watch on <a href=""https://youtu.be/baYdiqqfr3c"" rel=""nofollow noreferrer"">https://youtu.be/baYdiqqfr3c</a> minutes 1.30</p>

<p>or visit my web on <a href=""http://www.radixrobotic.id/project/arduino-tiket-printer-epson-tm-u220/"" rel=""nofollow noreferrer"">http://www.radixrobotic.id/project/arduino-tiket-printer-epson-tm-u220/</a></p>

<p>regrad.</p>
",,10868718,11877
7295736,2,7295234,2011-09-03T20:33:09.663,4,,736937,,2011-09-03T21:14:15.573,2011-09-03T21:14:15.573,0,,"<p>I agree with the <code>peek()</code> -> <code>count()</code> error listed by vhallac.  But I'll also point out that you should consider averaging by powers of 2 unless there is a strong case to do otherwise.</p>

<p>The reason is that on microcontrollers, division is slow.  By averaging over a power of 2 (2,4,8,16,etc.) you can simply calculate the sum and then bitshift it.</p>

<p>To calculate the average of 2: <code>(v1 + v2) &gt;&gt; 1</code></p>

<p>To calculate the average of 4: <code>(v1 + v2 + v3 + v4) &gt;&gt; 2</code></p>

<p>To calculate the average of n values (where n is a power of 2) just right bitshift the sum  right by [log2(n)].</p>

<p>As long as the datatype for your sum variable is big enough and won't overflow, this is much easier and much faster.</p>

<p><strong>Note</strong>: this won't work for floats in general.  In fact, microcontrollers aren't optimized for floats.  You should consider converting from int (what I'm assuming you're ADC is reading) to float at the end <strong>after the averaging</strong> rather than before.</p>

<p>By converting from int to float and then averaging floats you are losing more precision than averaging ints than converting the int to a float.</p>

<p><strong>Other:</strong></p>

<p>You're using the <code>+=</code> operator without initializing the variables (<code>qu1</code>, <code>qu2</code>, etc.) -- it's good practice to initialize them if you're going to use <code>+=</code> but it looks as if <code>=</code> would work fine.</p>

<p>For floats, I'd have written the <code>average</code> function as:</p>

<pre><code>float average(QueueList&lt;float&gt; &amp; q, int n)
{
    float sum = 0;
    for(int i=0; i&lt;n; i++)
    {
        sum += q.pop();
    }

    return (sum / (float) n);
}
</code></pre>

<p>And called it: <code>average(queuea, 5);</code></p>

<p>You could use this to average any number of sensor readings and later use the same code to later average floats in a completely different QueueList.  Passing the number of readings to average as a parameter will really come in handy in the case that you need to tweak it.</p>

<p>TL;DR:</p>

<p>Here's how I would have done it:</p>

<pre><code>#include &lt;QueueList.h&gt;

const int ANALOG_SHARP=0;   // set pin data from sharp
const int AvgPower = 2;     // 1 for 2 readings, 2 for 4 readings, 3 for 8, etc.
const int AvgCount = pow(2,AvgPow);

QueueList &lt;int&gt; SensorReadings;


void setup(){
    Serial.begin(9600);
}

void loop()
{
    int reading = analogRead(ANALOG_SHARP);
    SensorReadings.push(reading);

    if(SensorReadings.count() &gt; AvgCount)
    {
        int avg = average2(SensorReadings, AvgPower);
        Serial.println(gpd12_to_cm(avg));
    }
}

float gp2d12_to_cm(int reading)
{
    if(reading &lt;= 3){ return -1; }

    return((6787.0 /((float)reading - 3.0)) - 4.0);
}

int average2(QueueList&lt;int&gt; &amp; q, int AvgPower)
{
    int AvgCount = pow(2, AvgPower);
    long sum = 0;
    for(int i=0; i&lt;AvgCount; i++)
    {
        sum += q.pop();
    }

    return (sum &gt;&gt; AvgPower);
}
</code></pre>
",,10903343,347
7303338,2,7295234,2011-09-05T02:11:25.437,0,,877375,,2011-09-05T02:11:25.437,,0,,"<p>Great improvement jedwards, however the first question I have is why use queuelist instead of an int array.</p>

<p>As an example I would do the following:</p>

<pre><code>int average(int analog_reading)
{
    #define NUM_OF_AVG 5
    static int readings[NUM_OF_AVG];
    static int next_position;
    static int sum;

    if (++next_position &gt;= NUM_OF_AVG)
    {
        next_position=0;
    }
    reading[next_position]=analog_reading;

    for(int i=0; i&lt;NUM_OF_AVG; i++)
    {
        sum += reading[i];
    }
    average = sum/NUM_OF_AVG
}
</code></pre>

<p>Now I compute a new rolling average with every reading and it eliminates all the issues   related to dynamic memory allocation (memory fragmentation, no available memory, memory leaks) in a embedded device.</p>

<p>I appreciate and understand the use of shifting for a division by 2,4 or 8, however I would stay away from that technique for two reasons.</p>

<p>I think readability and maintainability of the source code is more important then saving a little bit of time with a shift instead of a divide unless you can test and verify the divide is a bottleneck.</p>

<p>Second, I believe most current optimizing compilers will do a shift if possible, I know GCC does. </p>

<p>I will leave refactoring out the for loop for the next guy.</p>
",,11068450,73812
7353541,2,7353272,2011-09-08T19:41:07.117,7,,191596,,2011-09-09T06:53:16.040,2011-09-09T06:53:16.040,0,,"<p>I don't know the specific reason the author wrote it, and I am not familiar with the library's written style - so I am going to answer in general terms of C++ programs.</p>

<p>I assume the preference is given because modern C++ typically favors other idioms, many of which were designed to avoid or minimize the issues frequently introduced by preprocessor and raw pointers.</p>

<p><strong>Avoid Pointers</strong></p>

<p>Instead of a pointer, it is conventional in C++ to use a reference for an object or a container such as a vector for a collection of objects.</p>

<pre><code>//////// For an object
//// Using a pointer
bool getURL(t_url* const outUrl);
// In use:
bool result(obj.getURL(&amp;outUrl));

//// versus using a reference
bool getURL(t_url&amp; outUrl);
// In use:
bool result(obj.getURL(outUrl));

//////// For a collection
//// Using a pointer
bool apply(const double* const values, const size_t&amp; count);
// In use:
bool result(obj.apply(array, count));

//// versus using a container
bool apply(const std::vector&lt;double&gt;&amp; values);
// In use:
bool result(obj.apply(values));
</code></pre>

<p>Even pointers may be given object containers (auto pointer, smart pointer, shared pointer, weak pointer) because there can be a lot of complexity or ambiguity when dealing with with raw pointers, particularly in clients' code. It's quite rare that I write C++ programs that take or return raw pointers.</p>

<p><strong>Avoid Defines</strong></p>

<p>Preprocessor/defines are also not generally the preferred approach in C++ - you have inline functions, anonymous namespaces, templates, and enums.</p>

<p>The ubiquitous example of a macro that is problematic for many reasons is <code>#define max(a,b) ((a &gt; b) ? a : b)</code>, versus <code>std::max</code>.</p>

<p><strong>Conclusion</strong></p>

<p>If I see a C++ program which uses a considerable amount of either, I find myself wondering in what decade it was written, or if the author was was writing in the ""C with some more features"" dialect.</p>

<p>Another answerer said the ""advice is garbage"". I disagree. The advice in Arduino simply says 'avoid pointers' and 'avoid #defines`. Of course, there will be times when you need to use these facilities, but you can write a clearer program when you use the language and library facilities which were intended to replace them (in the common ways they were misused or problematic). To <em>avoid</em> using them means to use them sparingly and only when necessary, favoring more modern and idiomatic alternatives.</p>
",,11213536,4758
7455649,2,7455570,2011-09-17T14:59:14.200,27,,583044,,2011-09-19T13:37:33.267,2011-09-19T13:37:33.267,5,,"<p>You're mixing C++ references and pointers. It looks from that example snippet that you should be using pointers, so I have made my answer follow that style. References would probably be a better choice though.</p>

<p>Your code should look something like this:</p>

<p>myclass.h</p>

<pre><code>myClass(HardwareSerial *serial); // ctor
HardwareSerial * _HardSerial; // member within class
</code></pre>

<p>myclass.cpp</p>

<pre><code>// Constructor takes address of serial port
myClass::myClass(HardwareSerial *serial) {
 _HardSerial = serial;
...
}
</code></pre>

<p>calling code:</p>

<pre><code>// Gets the address of ""Serial1"" and passes that to the constructor
myClass(&amp;Serial1); 
</code></pre>

<p>If you wanted to do it as references it would look something like this:</p>

<p>myclass.h</p>

<pre><code>myClass(HardwareSerial&amp; serial); // ctor taking reference
HardwareSerial&amp; _HardSerial; // reference member within class
</code></pre>

<p>myclass.cpp</p>

<pre><code>// Constructor takes reference to a serial port object
myClass::myClass(HardwareSerial&amp; serial) :
    _HardSerial(serial) // Need to initialise references before body
{
    ...
}
</code></pre>

<p>calling code:</p>

<pre><code>myClass(Serial1); // Compiler automatically uses reference
</code></pre>
",,11295728,783
36132711,2,7455570,2016-03-21T13:45:34.283,1,,6093862,,2017-02-01T03:16:30.960,2017-02-01T03:16:30.960,0,,"<p>I have one improvement on Mr Murdoch's code (thanks a lot by the way, following your example on how to initialize a serial object made me a happier, less compiler frustrated individual).</p>

<p>His method will let you pass any hardware serial object to his class.
Mine by default will let you pass (and configure) a hardware object to the class, but will also let you switch in a software serial object later if you are interested.</p>

<p>Almost the exact same as his code, except I replace his instance of the HardwareSerial object in his class with the Stream object.</p>

<p>myclass.h</p>

<pre><code>myClass(HardwareSerial&amp; serial, int baud, int config); // Constructor taking reference
Stream&amp; _s; // reference member within class
</code></pre>

<p>myclass.cpp</p>

<pre><code>// Constructor takes reference to a serial port object
myClass::myClass(HardwareSerial&amp; serial = Serial, int baud = 9600, int config = SERIAL_8N1) :
_s(serial) // Need to initialise references before body
{
    serial.begin(baud, config);  //We guarantee a hardware interface at first
    this-&gt;_s = serial;           //The constructor uses the hardware serial class
                             //but we can replace it with a virtual hardware
                             //class if we have to thanks to stream
} 
</code></pre>
",,11375884,12799
7600647,2,7592848,2011-09-29T16:48:51.920,3,,947357,,2011-09-29T16:48:51.920,,0,,"<p>Arduino's original glue code looks like this:</p>

<pre><code>#include &lt;WProgram.h&gt;
int main(void)
{
    init();
    setup();
    for (;;)
        loop();
    return 0;
}
</code></pre>

<p>The <code>init()</code> stuff is missing in your code. <code>init()</code> is defined in <code>$ARDUINO_HOME/hardware/arduino/cores/arduino/wiring.c</code>, you can either link against it directly or just copy the code of <code>init()</code> into your code.</p>
",,11385915,3495
7708603,2,7708553,2011-10-10T04:40:57.913,4,,14860,,2011-10-10T05:00:46.950,2011-10-10T05:00:46.950,1,,"<p><code>i</code> is a global variable, meaning that it's initialised to 0 (explicitly) when your program starts, and then can be changed by any code that can see it.</p>

<p>So, if your question is:</p>

<blockquote>
  <p>Will it maintain its value between different calls to the <code>loop()</code> function?""</p>
</blockquote>

<p>(and it seems to be, based on the comments you left in the question) then the answer is yes.</p>

<p>In other words, when you enter <code>loop()</code> with <code>midiMessage</code> equal to 144, it will set <code>i</code> to <code>pinNumber</code> (<code>noteNumber - 60</code>).</p>

<p>Then the next time you enter <code>loop()</code> with <code>midiMessage</code> equal to 128, it will use the current <code>i</code> (whatever it was last set to).</p>

<p>Of course, if you enter <code>loop()</code> with <code>midiMessage</code> equal to 128 <em>before</em> you call it when <code>midiMessage</code> equals 144, the value of <code>i</code> will be zero.</p>

<hr>

<p>If that declaration of <code>i</code> was <em>inside</em> the <code>loop()</code> function, then it would be re-initialised each time the function was called, but that's not the case here.</p>

<p>Of course, good programming practice would suggest that you should put it inside the function <em>if that's the only place you use it</em> (this may not be the case).</p>

<p>This restricts its ""visibility"" <sup>(a)</sup> to that function so that there's no chance other code may use it inadvertently (this is <em>especially</em> a problem for a variable called <code>i</code> - you may want to think of a better name for it).</p>

<p>To restrict its visibility like that while still allowing it to exist between function calls, you would use something like:</p>

<pre><code>void loop (void) {
    static int persistentVar = 0;
    :
    :
}
</code></pre>

<p>This still initialises it once, at program startup (even though it's inside the function) and keeps its value in between different invocations of <code>loop()</code>. It also stops code from outside of that function from ""seeing"" the variable.</p>

<hr>

<p><sup>(a)</sup> Note that ""visibility"" as used here is not the term the ISO standard uses. I use that term for my introductory coding classes since ""visibility"" is easier understood than ""scope"".</p>
",,11410583,6595
7777152,2,7777131,2011-10-15T10:08:12.923,3,,311635,,2011-10-15T10:38:52.380,2011-10-15T10:38:52.380,8,,"<p>You are not evaluating the <code>exitStatus</code> variable, which might indicate it the read was successful.</p>

<p>Also you don't need to malloc memory if you want to read just one byte, you can simply pass the pointer to a local char variable.</p>

<p>And while I'm at it, the type for main is either <code>int main()</code> or <code>int main(int argc, char** argv)</code></p>

<pre><code>int main()
{   
    int exitStatus;
    unsigned int bytesToRead = 1;
    unsigned char buffer;
    Serial *connection = new Serial(""COM3"");

    if(connection-&gt;IsConnected()){
        exitStatus=connection-&gt;ReadData(&amp;buffer, 1);
        if((exitStatus == &lt;Insert the value for a correct read status&gt;) &amp;&amp; (buffer != '0'))
            &lt;statement I'm trying to hit&gt;
    }
    return 0;
}
</code></pre>

<p><strong>update</strong>
Changed the != 0 check to != '0', since I suspect that there is a '0' character (=0x30) comming from the serial interface.</p>
",,11422639,6758
7801489,2,7801478,2011-10-18T01:27:41.240,4,,59947,,2011-10-18T02:11:34.937,2011-10-18T02:11:34.937,3,,"<p>This looks like a homework assignment, so, rather than give you the outright answer, I'd rather just point you in the right direction...</p>

<p>use a nested loop (one inside the other).  One loop cycles 0-7, the other one 0 - 63.  Use the smaller one to populate your sliced averages. </p>

<p>or better yet use the % operator to see when you've gone through 8 elements and do an average of your total, then reset the total for the next set.  Then you'll have learned how to use the % operator too! :)</p>

<p>[EDIT]
ok, if not homework then something like this... I haven't written C in 5 years, so treat this as pseudo code:</p>

<pre><code>//assuming you have a fftArray[64] with data, as per your question
int i,sum,avCounter,total;
int averages[8]; 
for(i=0 , avCounter=0, total=0 ; i&lt;64; ){
    total += fftArray[i];
    if(++i % 8 == 0){   //%gives you the remainder which will be 0 every 8th cycle
      averages[avCounter++] = total / 8
      total = 0;  //reset for next cycle
    }
}
</code></pre>

<p>I think this will work better than a nested loop... but I'm not sure since % is division which is more processor heavy than addition... however... I doubt anyone would notice :)</p>
",,11441660,171
7801518,2,7801478,2011-10-18T01:32:41.820,2,,411022,,2011-10-18T01:32:41.820,,1,,"<pre><code>int i, j;
for (i = 0; i &lt; 8; i++) {
    int sum = 0;
    for (j = 0; j &lt; 8; j++) {
        sum += fftArray[ 8*i + j ];
    }
    frequencyBar[i] = sum / 8;
}
</code></pre>

<p>Bonus exercise: Optimize this code for speed on your chosen platform.</p>
",,11494827,137
7801541,2,7801478,2011-10-18T01:36:27.167,2,,69224,,2011-10-18T02:44:17.310,2011-10-18T02:44:17.310,0,,"<p>TF,</p>

<p><strong>DISCLAIMER:</strong> This code is just off the top of my head... it hasn't even been compiled, let alone tested.</p>

<pre><code>// returns the average of array[first..last] inclusive.
int average(int[] array, int first, int last) {
    int sum = 0; 
    for (i = first; i &lt;= last; i++)
        sum += array[i];
    return sum / (last - first + 1); // not sure about the +1
}
</code></pre>

<p>Then what you'd do is loop through the indexes of your <code>frequencyBar</code> array [0..7], setting <code>frequencyBar[i] = average(array, first, last);</code>... the tricky bit is calculating the <code>first</code> and <code>last</code> indexes... try <code>i*8</code> and <code>(i+1)*8</code> respectively... that may not be exactly right, but it'll be close ;-)</p>

<p>Cheers. Keith.</p>

<hr>

<p><strong>EDIT:</strong> Bored... waiting for my test results to come back. No news is good news, right? ;-)</p>

<p>It turns out that passing the <code>length</code> is a fair bit simpler than passing the <code>last</code> index.</p>

<pre><code>#include &lt;stdio.h&gt;

int sum(int array[], int first, int length) {
    int sum = 0;
    for (int i = first; i &lt; first+length; i++)
        sum += array[i];
    return sum;
} 

double average(int array[], int first, int length) {
    double total = sum(array, first, length);
#ifdef DEBUG
    printf(""DEBUG: [%2d..%2d] %d"", first, first+length-1, array[first]);
    for (int i = first+1; i &lt; first+length; i++)
        printf("" + %d"", array[i]);
    printf("" = %d / %d = %f\n"", (int)total, length, total/length);
#endif
    return total / length;
} 

int main(int argc, char* argv[]) {
    int array[] = {             // average
        1, 2, 3, 4, 5, 1, 2, 3, // 2.625 
        4, 5, 1, 2, 3, 4, 5, 1, // 3.125 
        2, 3, 4, 5, 1, 2, 3, 4, // 3
        5, 1, 2, 3, 4, 5, 1, 2, // 2.875
        3, 4, 5, 1, 2, 3, 4, 5, // 3.375
        1, 2, 3, 4, 5, 1, 2, 3, // 2.625
        4, 5, 1, 2, 3, 4, 5, 1, // 3.125
        2, 3, 4, 5, 1, 2, 3, 4  // 3
    };
    double frequency[8];
    for (int i = 0; i &lt; 8; i++)
        frequency[i] = average(array, i*8, 8);

    for (int i = 0; i &lt; 8; i++)
        printf(""%f "", frequency[i]);
    printf(""\n"");
}
</code></pre>
",,11517306,1352
7854912,2,7845196,2011-10-21T20:26:09.680,8,,72035,,2011-10-21T20:26:09.680,,0,,"<p>Mitch's links should point you in the right direction.</p>

<p>A common way of sending and receiving strings from the host computer to the Arduino and back is using the Arduino's Serial library. The Serial library reads and writes a byte at a time over the connection to the computer.</p>

<p>The below code forms a String by appending chars received over the Serial connection:</p>

<pre><code>// If you know the size of the String you're expecting, you could use a char[]
// instead.
String incomingString;

void setup() {
  // Initialize serial communication. This is the baud rate the Arduino
  // discusses over.
  Serial.begin(9600);

  // The incoming String built up one byte at a time.
  incomingString = """"
}

void loop() {
  // Check if there's incoming serial data.
  if (Serial.available() &gt; 0) {
    // Read a byte from the serial buffer.
    char incomingByte = (char)Serial.read();
    incomingString += incomingByte

    // Checks for null termination of the string.
    if (incomingByte == '\0') {
      // ...do something with String...
      incomingString = """"
    }
  }
}
</code></pre>

<p>To send the serial data --- and to print out the data the Arduino prints --- you can use the Serial Monitor in the Arduino IDE.</p>
",,11559829,660
10985896,2,7923965,2012-06-11T18:54:18.650,0,,1081821,,2012-06-11T18:54:18.650,,0,,"<p>add in your library header (the .h file)</p>

<pre><code>//add below these lines:
#ifndef x
#define x
//this
#include &lt;Arduino.h&gt;
</code></pre>
",,11610264,42614
8087366,2,8086281,2011-11-10T22:39:21.703,0,,1037662,,2011-11-10T23:34:56.853,2011-11-10T23:34:56.853,2,,"<p>You can use something like this:</p>

<pre><code>char alphabet[256][5] = {{B0000000,
                          B0000000,
                          B0000000,
                          B0000000,
                          B0000000},
                          ...
                          //hLetter
                         {B1111111,
                          B0001000,
                          B0001000,
                          B0001000,
                          B1111111},
                          ....
                        };
</code></pre>

<p>or</p>

<pre><code>char letter_H[5] = {B1111111,
                    B0001000,
                    B0001000,
                    B0001000,
                    B1111111}

char* translate_to_bitarray(char c)
{
  switch(c)
  {
  case 'H':
  case 'h':
   return letter_H;
  ...
  }
}
</code></pre>

<p>and then to make a function to translate a whole string...</p>

<p>Advice:
Use a ""framebuffer"" - an array of 10 x 5 chars or 10 structs.
Send to Arduino, normal, C strings.
Convert characters from string, as needed, and put them in the frame buffer. In this way you can create scroll effect, very easily. 
Use a struct to keep character information.</p>

<pre><code>struct character
{
  char _column1;
  char _column2;
  char _column3;
  char _column4;
  char _column5;
}
</code></pre>
",,11677639,29939
8087582,2,8086281,2011-11-10T22:59:35.647,0,,845092,,2011-11-10T22:59:35.647,,1,,"<p>If the question is how to make C++ parse binary, then use this macro:</p>

<pre><code>#define B(in) ( ((in&amp;(1&lt;&lt; 0))&gt;&gt; 0) \
               |((in&amp;(1&lt;&lt; 3))&gt;&gt; 2) \
               |((in&amp;(1&lt;&lt; 6))&gt;&gt; 4) \
               |((in&amp;(1&lt;&lt; 9))&gt;&gt; 6) \
               |((in&amp;(1&lt;&lt;12))&gt;&gt; 8) \
               |((in&amp;(1&lt;&lt;15))&gt;&gt;10) \
               |((in&amp;(1&lt;&lt;18))&gt;&gt;12) \
               |((in&amp;(1&lt;&lt;21))&gt;&gt;14) \
               |((in&amp;(1&lt;&lt;24))&gt;&gt;16) \
              )


#include &lt;iostream&gt;
int main() {
    int CurrentWordInt[] = {B(01111111), B(00001000), B(0001000), B(01111111), B(0000000)}; 
    std::cout &lt;&lt; CurrentWordInt[0] &lt;&lt; ' ';
    std::cout &lt;&lt; CurrentWordInt[1] &lt;&lt; ' ';
    std::cout &lt;&lt; CurrentWordInt[2] &lt;&lt; ' ';
    std::cout &lt;&lt; CurrentWordInt[3] &lt;&lt; ' ';
    std::cout &lt;&lt; CurrentWordInt[4] &lt;&lt; ' ';
}
</code></pre>

<p>Displays 127 8 8 127 0<br>
Note that this macro requires all inputs to be a zero followed by seven ones/zeros.</p>

<p>If that <em>isn't</em> your question, then I don't know what you're asking of us.</p>
",,11690647,4861
8087796,2,8086281,2011-11-10T23:20:09.263,0,,845092,,2011-11-10T23:20:09.263,2017-05-23T11:47:59.803,0,,"<pre><code>class bitbuffer {
    char buffer;
    char held_bits;
    char* input;
public:
    bitbuffer(char* in) :held_bits(0), buffer(0), input(in) {}
    unsigned long long read(unsigned char bits) { 
        unsigned long long result = 0;
        //if the buffer doesn't hold enough bits
        while (bits &gt; held_bits) {
            //grab the all bits in the buffer
            bits -= held_bits;
            result |= ((unsigned long long)buffer) &lt;&lt; bits;
            buffer = *(input++);
            held_bits = (char)std::cin.gcount() * CHAR_BIT;
        }
        //append the bits left to the end of the result
        result |= buffer &gt;&gt; (held_bits-bits);
        //remove those bits from the buffer
        held_bits -= bits;
        buffer &amp;= (1ull&lt;&lt;held_bits)-1;
        return result;
    };
};

int main() {
    char* CurrentWord = data from stream
    bitbuffer bitter(CurrentWord);
    int CurrentWordInt[10];
    for(int i=0; i&lt;10; ++i) {
        CurrentWordInt[i] = bitter.read(7); //reads next 7 bits
    }
}
</code></pre>

<p>Extrapolated from my answer at <a href=""https://stackoverflow.com/questions/8070106/how-to-read-bitn-integer-data-from-a-binary-file/8070356#comment9889841_8070356"">How to read bitN integer data from a binary file?</a>
Note this doesn't check boundries and will read past the end of the array given.</p>
",,11846288,931
8087862,2,8086281,2011-11-10T23:27:58.367,0,,971127,,2011-11-10T23:27:58.367,,0,,"<p>c++ version:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

using namespace std;

int binstrToInt(const char* str){
    int wk = 0;
    while(*str){
        wk = wk * 2 + (*str++ - '0');
    }
    return wk;
}

vector&lt;int&gt; binstrToVector(const char* str, const size_t size){
    vector&lt;int&gt; v;
    istringstream iss(str);

    while(iss){
        ostringstream oss;
        for(int i=0;i&lt;size;){
            char x;
            iss &gt;&gt; x;
            if(x == 'B' || x == 'b') continue;
            oss &lt;&lt; x;
            ++i;
        }
        v.push_back(binstrToInt(oss.str().c_str()));
    }
    return v;
}

int main(){
    const char* binstr = ""11111110001000000100011111110000000B00000001000001111111110000010000000"";
    vector&lt;int&gt; v = binstrToVector(binstr, 7);

    for(int i=0;i&lt;v.size();++i){
        cout &lt;&lt; v[i] &lt;&lt; endl;
    }
}
</code></pre>
",,11856409,3509
8124544,2,8123057,2011-11-14T16:18:21.723,4,,478687,,2011-11-14T16:18:21.723,,2,,"<p>I understood from your post that you need to send data using visual studio not to write a program to flash or any other stuff. Here is an example i made for you on my machine it works sending the text test.</p>

<pre><code>#include ""stdafx.h""
#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
    char test[] = ""Hello"";

    HANDLE hDevice = CreateFile(L""COM2"",GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,0);

    if (hDevice !=INVALID_HANDLE_VALUE)
    {
        printf(""Port opened! \n"");
        DCB lpTest;
        GetCommState(hDevice,&amp;lpTest);
        lpTest.BaudRate = CBR_9600;
        lpTest.ByteSize = 8;
        lpTest.Parity = NOPARITY;
        lpTest.StopBits = ONESTOPBIT;
        SetCommState(hDevice,&amp;lpTest);

        DWORD btsIO;

        WriteFile(hDevice,test,strlen(test),&amp;btsIO,NULL);

        CloseHandle(hDevice);
    }
    _getch();


    return 0;
}
</code></pre>
",,11871126,1175
8181166,2,8123057,2011-11-18T10:45:36.423,0,,813103,,2011-11-18T10:45:36.423,,0,,"<p>CPPWindows works but it is also in C++. 
For all of you who want to send serial data with OPENCV/ARTOOLKIT or something which is written in C (and not C++).
The code i posted is working now. It required some changes. The final code is:
(Not the change in the COM port)</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void main()
{
    FILE* port;
    system( ""MODE COM1: BAUD=9600 PARITY=n DATA=8 STOP=1"" ) ;
    port = fopen( ""COM1:"", ""wb"" ) ;
    printf(""s"");
    fprintf( port, ""s"" ) ;
    fclose( port ) ;
}
</code></pre>
",,11915914,14164
8235258,2,8234614,2011-11-22T23:14:40.653,1,,346446,,2011-11-22T23:14:40.653,,4,,"<p>I think CLR is not necessary. Sample class which You've provided should be sufficient, and problem You've pointed can be solved using casting, e.g.</p>

<pre><code>this-&gt;hSerial = CreateFileA( static_cast&lt;LPCSTR&gt;(portName),
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
</code></pre>

<p>There are two modifications: changed macro CreateFile to function CreateFileA, and static_cast the first param. If still in problem, try to add some more specific questions.</p>
",,12012277,7142
8263402,2,8263382,2011-11-24T23:22:01.410,1,,841108,,2011-11-24T23:22:01.410,,0,,"<pre><code> int i = 42;
 char buf[30];
 memset (buf, 0, sizeof(buf));
 snprintf(buf, sizeof(buf)-1, ""%d"", i);
 // now buf contains the ""42"" string.
</code></pre>
",,12076240,331
8263403,2,8263382,2011-11-24T23:22:11.930,0,,982091,,2011-11-24T23:22:11.930,,0,,"<p>Try this one:</p>

<pre><code>#include &lt;iostream&gt;

int GSM_BAUD_RATE; 
GSM_BAUD_RATE = 4800; 
char text[256];

sprintf(text, ""GSM Shield running at %d baud rate."", GSM_BAUD_RATE);

Serial.println(text);
</code></pre>
",,12104470,1656
8263407,2,8263382,2011-11-24T23:22:58.727,3,,204847,,2011-11-25T00:00:57.040,2011-11-25T00:00:57.040,3,,"<p>UPDATE: this answers the original question, before it was updated to mention Arduino. I'm leaving it, as it is the correct answer for non-embedded systems.</p>

<p>You can create a formatted string using a <code>stringstream</code>, and extract a <code>string</code> from that.</p>

<pre><code>#include &lt;sstream&gt;

std::ostringstream s;
s &lt;&lt; ""GSM Shield running at "" &lt;&lt; GSM_BAUD_RATE &lt;&lt; "" baud rate."";

Serial.println(s.str().c_str()); // assuming `println(char const *);`
</code></pre>
",,12127471,1079
8263426,2,8263382,2011-11-24T23:25:29.740,1,,640103,,2011-11-24T23:25:29.740,,0,,"<p>You could use a stringstream:</p>

<pre><code>int main()  
{
    int myInt = 12345;
    std::ostringstream ostr;
    ostr &lt;&lt; myInt;
    std::string myStr = ""The int was: "" + ostr.str();
    std::cout &lt;&lt; myStr &lt;&lt; std::endl;
}
</code></pre>
",,12250759,510
8263447,2,8263382,2011-11-24T23:27:06.963,6,,214671,,2011-11-24T23:27:06.963,,1,,"<p>If, as it seems, you are working on an Arduino project, you should simply let the <code>Serial</code> object deal with it:</p>

<pre><code>int GSM_BAUD_RATE;
GSM_BAUD_RATE = 4800;

Serial.print(""GSM Shield running at "");
Serial.print(GSM_BAUD_RATE);
Serial.println("" baud rate."");
</code></pre>

<p>since the <code>print</code> and <code>println</code> methods have overloads to handle several different types.</p>

<p>The other methods can be useful on ""normal"" machines, but stuff like <code>string</code> and <code>ostringstream</code> require heap allocation, which, on an Arduino board, should be avoided if possible due to the strict memory constraints.</p>
",,12256004,3979
8420367,2,8420304,2011-12-07T18:16:12.960,1,,440558,,2011-12-07T18:20:19.040,2011-12-07T18:20:19.040,2,,"<p>You can use an <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow""><code>ostringstream</code></a> for this:</p>

<pre><code>#include &lt;sstream&gt;

// ...

std::ostringstream os;
os &lt;&lt; ""twittermood.php?status=sendTweet&amp;setting1="" &lt;&lt; setting1;

GETrequest(addr, port, hostname, os.str().c_str());
</code></pre>
",,12328010,2933
8465925,2,8464645,2011-12-11T17:22:27.010,1,,411313,,2011-12-11T17:22:27.010,,1,,"<p>You can if you point the the whole array and NOT point to the first element like:</p>

<pre><code>int testInt[3];
int (*point)[3];
point = testInt;

printf( ""number elements: %lu"", (unsigned long)(sizeof*point/sizeof**point) );
printf( ""whole array size: %lu"", (unsigned long)(sizeof*point) );
</code></pre>
",,12336773,697
33570151,2,8464645,2015-11-06T15:28:37.633,4,,5534094,,2015-11-06T15:28:37.633,,1,,"<p>Also doing an Arduino project here...
Everybody on the internet seems to insist it's impossible to do this...
and yet the oldest trick in the book seems to work just fine with null terminated arrays...</p>

<p>example for char pointer:</p>

<pre><code>    int getSize(char* ch){
      int tmp=0;
      while (*ch) {
        *ch++;
        tmp++;
      }return tmp;}
</code></pre>

<p>magic...</p>
",,12464613,77
8466629,2,8466554,2011-12-11T19:07:17.980,2,,2666,,2011-12-12T14:54:44.213,2011-12-12T14:54:44.213,8,,"<p>No. You would need <code>i</code> to be a pointer and allocate the array in your <code>main</code>:</p>

<pre><code>int *i = NULL;

// etc.

int main(void) {

    i = (int*) malloc(sizeof(*i)*strLength());

    // etc.
}
</code></pre>
",,12495331,10656
8466665,2,8466554,2011-12-11T19:12:31.670,3,,406009,,2011-12-11T19:18:49.320,2011-12-11T19:18:49.320,5,,"<p>If you are using c++, the correct solution is a std::vector.
You will need to look at the docs for std::vector, but here is a conversion of your code to std::vector.</p>

<p>You then use std::vectors the same way you use regular arrays, with the ""[]"" operator.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;vector&gt;

String str = ""foo"";

int strLength() {  // Needs to come before the use of the function
  return str.length();
}

std::vector&lt;int&gt; i(strLength() ); //Start at strLength


int main(void) {
   ...
}
</code></pre>
",,12556096,990
8466892,2,8466554,2011-12-11T19:43:35.390,1,,28128,,2011-12-11T19:52:11.530,2011-12-11T19:52:11.530,0,,"<p>I know it's not what you were hoping for, but I would just do something inelegant like this:</p>

<pre><code>String str = ""foo"";
#define MAX_POSSIBLE_LENGTH_OF_STR 16

...

int i[MAX_POSSIBLE_LENGTH_OF_STR];
</code></pre>

<p>The idea is that you allocate more space for the array than you actually need, and just avoid using the extra parts of the array.</p>

<p>Alternatively, if you aren't going to be changing the definition of <code>str</code> in your source code very often, you could save some RAM by doing this:</p>

<pre><code>String str = ""foo"";
#define LENGTH_OF_STR 3

...

int i[LENGTH_OF_STR];
</code></pre>
",,12664826,5799
21361189,2,8578756,2014-01-26T08:11:10.047,0,,2192888,,2018-04-08T03:27:00.350,2018-04-08T03:27:00.350,0,,"<p>I realize this is an old question, but if you're trying to, say, compare a specific char, and not just one letter in a string, then what you want is <em>string</em>.charAt(n). For example, if you're doing serial programming and you need to check for STX (\02) than you can use the following code.</p>

<pre><code>char STX = '\02'

if (inputString.charAt(0) == STX) {
  doSomething();
}
</code></pre>
",,12679399,4790
8737814,2,8737642,2012-01-05T04:52:22.523,3,,68304,,2012-01-05T04:52:22.523,,2,,"<p>All of your functions should have <code>volatile</code> qualifier, just like <code>const</code> qualifier needed for constant objects. Here is an example:</p>

<pre><code>class A
{
public:
    A(unsigned int a)
    {
    }

    void init() volatile
    {
        cout &lt;&lt; ""A::init()"" &lt;&lt; endl;
    }
};
</code></pre>
",,12865622,878
8819664,2,8819580,2012-01-11T12:57:31.353,8,,440558,,2012-01-11T13:23:49.280,2012-01-11T13:23:49.280,7,,"<p>You can do this by making a <a href=""http://en.wikipedia.org/wiki/Functor_%28C%2B%2B%29"">functor</a> object, that acts as a proxy between the timer code and your code.</p>

<pre><code>class MyHaltStruct
{
public:
    MyHaltStruct(Robot &amp;robot)
        : m_robot(robot)
        { }

    void operator()()
        { robot.halt(); }

private:
    Robot &amp;m_robot;
}

// ...

timer.setTimer(time, MyHaltStruct(*this), 1);
</code></pre>

<h2>Edit</h2>

<p>If it can't be done via a functor object, you could global variables and functions instead, maybe in a namespace:</p>

<pre><code>namespace my_robot_halter
{
    Robot *robot = 0;

    void halt()
    {
        if (robot)
            robot-&gt;halt();
    }
}

// ...

my_robot_halter::robot = this;
timer.setTimer(time, my_robot_halter::halt, 1);
</code></pre>

<p>This only works if you have one robot instance though.</p>
",,12902041,2637
8820271,2,8819580,2012-01-11T13:42:28.513,3,,212858,,2012-01-11T14:10:38.980,2012-01-11T14:10:38.980,2,,"<p>Since the timer callback signature doesn't take any argument, you unfortunately need to use some global (or static) state:</p>

<pre><code>Robot *global_robot_for_timer;
void robot_halt_callback()
{
    global_robot_for_timer-&gt;halt();
}
</code></pre>

<p>you can at least wrap that lot into it's own file, but it isn't pretty. As Matthew Murdoch suggested, it might be better to edit the SimpleTimer itself.  A more conventional interface would be:</p>

<pre><code>typedef void (*timer_callback)(void *);

SimpleTimer::setTimer(long time, timer_callback f, void *data);

void robot_halt_callback(void *data)
{
    Robot *r = (Robot *)data;
    r-&gt;halt();
}
</code></pre>

<p>ie, when you call setTimer, you provide an argument which is passed back to the callback.</p>

<p>The smallest change to SimpleTimer would be something like:</p>

<h2>SimpleTimer.h</h2>

<pre><code>typedef void (*timer_function)(void *);
struct timer_callback {
    timer_function func;
    void *arg;
};
// ... every method taking a callback should look like this:
int SimpleTimer::setTimeout(long, timer_function, void *);
</code></pre>

<h2>SimpleTimer.cpp</h2>

<pre><code>// ... callbacks is now an array of structures
callbacks[i] = {0};

// ... findFirstFreeSlot
if (callbacks[i].func == 0) {

// ... SimpleTimer::setTimer can take the timer_callback structure, but
// that means it's callers have to construct it ...
int SimpleTimer::setTimeout(long d, timer_function func, void *arg) {
    timer_callback cb = {func, arg};
    return setTimer(d, cb, RUN_ONCE);
}
</code></pre>
",,12930978,29390
8881154,2,8873998,2012-01-16T14:08:20.220,4,,4023,,2012-01-16T21:22:18.937,2012-01-16T21:22:18.937,3,,"<p>I have come across memory handling issues in Arduino versions prior to 1.0 when testing the <code>String</code> class (<a href=""http://arduino.cc/pipermail/developers_arduino.cc/2011-June/005151.html"" rel=""nofollow"">see forum post here</a>).</p>

<p>The String constructor uses <code>realloc</code> internally and it's this (avr libc) dynamic memory handling that was causing the problems (due to the pointer to the top of the heap <code>__brkval</code> not being updated upon <code>free()</code>).</p>

<p>Run the following code to see these issues in versions 0023, 0022, etc. In Arduino 1.0 the code should show no memory leaks:</p>

<pre><code>#if (ARDUINO &gt;= 100)
#include &lt;Arduino.h&gt;
#else
#include &lt;WProgram.h&gt;
#endif
#include &lt;HardwareSerial.h&gt;
#include &lt;MemoryFree.h&gt;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  int freeBefore, freeAfter;

  freeBefore = freeMemory();

  void* buffer = malloc(10);
  if (buffer == 0) {
    Serial.println(""Failed to allocate memory"");
  }
  free(buffer);

  freeAfter = freeMemory();
  Serial.println(""Before "" + String(freeBefore)
    + "", After "" + String(freeAfter)
    + "", Diff "" + String(freeBefore - freeAfter));
}

void loop() {
}
</code></pre>

<p>In addition, the MemoryFree library you are using can give wrong results as it doesn't take into account the free list. Try this updated version of <code>MemoryFree.cpp</code>:</p>

<pre><code>extern unsigned int __heap_start;
extern void *__brkval;

/*
 * The free list structure as maintained by the 
 * avr-libc memory allocation routines.
 */
struct __freelist {
  size_t sz;
  struct __freelist *nx;
};

/* The head of the free list structure */
extern struct __freelist *__flp;

#include ""MemoryFree.h"";

/* Calculates the size of the free list */
int freeListSize() {
  struct __freelist* current;
  int total = 0;

  for (current = __flp; current; current = current-&gt;nx) {
    total += 2; /* Add two bytes for the memory block's header  */
    total += (int) current-&gt;sz;
  }

  return total;
}

int freeMemory() {
  int free_memory;

  if ((int)__brkval == 0) {
    free_memory = ((int)&amp;free_memory) - ((int)&amp;__heap_start);
  } else {
    free_memory = ((int)&amp;free_memory) - ((int)__brkval);
    free_memory += freeListSize();
  }
  return free_memory;
}
</code></pre>
",,12980256,2611
8941363,2,8941262,2012-01-20T12:17:54.580,9,,160206,,2012-01-20T12:17:54.580,,1,,"<p>Here a template-version, including a complete program to demonstrate the use (you should be able to copy and paste that):</p>

<pre><code>#include &lt;iostream&gt;

template&lt;class T&gt;
const T&amp; constrain(const T&amp; x, const T&amp; a, const T&amp; b) {
    if(x &lt; a) {
        return a;
    }
    else if(b &lt; x) {
        return b;
    }
    else
        return x;
}

int main() {
    int value = 10;
    std::cout &lt;&lt; constrain(value, 5, 20) &lt;&lt; ""\n""      // prints ""10""
              &lt;&lt; constrain(value, 15, 20) &lt;&lt; ""\n""     // prints ""15""
              &lt;&lt; constrain(value, 5, 9) &lt;&lt; std::endl; // prints ""9""
}
</code></pre>

<p>This can be used for any type that has an <code>operator&lt;</code> (this includes all built-in numeric types, such as <code>int</code> and <code>float</code>).</p>
",,12997317,1792
9523600,2,8941262,2012-03-01T20:33:33.090,1,,1243650,,2012-03-01T20:33:33.090,,1,,"<p>Looking at Wikipedia under <a href=""http://en.wikipedia.org/wiki/Clamping_%28graphics%29"" rel=""nofollow"">Clamping (graphics)</a>, it looks like you could have a type-independent template?</p>

<pre><code>template&lt;typename T&gt;
T clamp(T Value, T Min, T Max)
{
  return (Value &lt; Min)? Min : (Value &gt; Max)? Max : Value;
}
</code></pre>
",,13060699,6027
9072345,2,9072320,2012-01-30T23:27:41.267,0,,1159721,,2012-01-30T23:27:41.267,,2,,"<p>For dynamic allocation of memory, you will need to use malloc, ie:</p>

<pre><code>String returnvalue[splitcount];
for(int i=0; i&lt; splitcount; i++)
{
    String returnvalue[i] = malloc(maxsizeofstring * sizeof(char));
}
</code></pre>

<p>You will also need the maximum string length.</p>
",,13093927,6918
12989008,2,9072320,2012-10-20T13:42:21.880,0,,639259,,2012-10-20T13:42:21.880,,0,,"<p>I think your idea is a good start point. Here is a code that i use (to parse HTTP GET REST requests with an Ethernet shield).</p>

<p>The idea is to use a while loop and lastIndexOf of and store the strings into an array (but your could do something else).</p>

<p>""request"" is the string you want to parse (for me it was called request because.. it was).</p>

<pre><code>    int goOn = 1;
    int count = -1;
    int pos1;
    int pos2 = request.length();

    while( goOn == 1 ) {
        pos1 = request.lastIndexOf(""/"", pos2);
        pos2 = request.lastIndexOf(""/"", pos1 - 1);

        if( pos2 &lt;= 0 ) goOn = 0;

        String tmp = request.substring(pos2 + 1, pos1);

        count++;
        params[count] = tmp;

        // Serial.println( params[count] );

        if( goOn != 1) break;
    }
    // At the end you can know how many items the array will have: count + 1 !
</code></pre>

<p>I have used this code successfully, but i thing their is an encoding problem when i try to print params[x]... i'm alos a beginner so i don't master chars vs string...</p>

<p>Hope it helps.</p>
",,13148257,2390
14824108,2,9072320,2013-02-12T01:39:53.330,39,,490505,,2013-02-12T01:39:53.330,,5,,"<p>This is an old question, but i have created some piece of code that may help:</p>

<pre><code> String getValue(String data, char separator, int index)
{
  int found = 0;
  int strIndex[] = {0, -1};
  int maxIndex = data.length()-1;

  for(int i=0; i&lt;=maxIndex &amp;&amp; found&lt;=index; i++){
    if(data.charAt(i)==separator || i==maxIndex){
        found++;
        strIndex[0] = strIndex[1]+1;
        strIndex[1] = (i == maxIndex) ? i+1 : i;
    }
  }

  return found&gt;index ? data.substring(strIndex[0], strIndex[1]) : """";
}
</code></pre>

<p>This function returns a single string separated by a predefined character at a given index. For example:</p>

<pre><code>String split = ""hi this is a split test"";
String word3 = getValue(split, ' ', 2);
Serial.println(word3);
</code></pre>

<p>Should print 'is'. You also can try with index 0 returning 'hi' or safely trying index 5 returning 'test'.</p>

<p>Hope this help!</p>
",,13169714,6185
42806357,2,9072320,2017-03-15T09:58:52.903,8,,7714145,,2018-07-01T12:51:20.273,2018-07-01T12:51:20.273,2,,"<p>Implementation:</p>

<pre><code>int sa[4], r=0, t=0;
String oneLine = ""123;456;789;999;"";

for (int i=0; i &lt; oneLine.length(); i++)
{ 
 if(oneLine.charAt(i) == ';') 
  { 
    sa[t] = oneLine.substring(r, i).toInt(); 
    r=(i+1); 
    t++; 
  }
}
</code></pre>

<p>Result:</p>

<pre><code>    // sa[0] = 123  
    // sa[1] = 456  
    // sa[2] = 789  
    // sa[3] = 999
</code></pre>
",,13212199,181
9087553,2,9085028,2012-01-31T21:56:23.573,2,,1527,,2012-01-31T21:56:23.573,,0,,"<p>You appear to have a statement <code>randomSeed(analogRead(0));</code> floating in between your <code>setup()</code> and <code>loop()</code> function definitions.</p>

<p>Move it and any other IO operations to the end of the <code>setup()</code> function so you read <em>after</em> setting up the pin directions:</p>

<pre><code>   int i = 1;
   bool pushed; 
   bool val = 0;

   void setup() {
     pinMode(1,OUTPUT);
   [...]
     pinMode(13,INPUT);

     pushed = digitalRead(13);
     randomSeed(analogRead(0));
   }

   void loop() {
     if (pushed == 1) {
       for (i = 1; i &lt; 9; i++) {
         val = random(2);
         digitalWrite(i,val);
       }
     }
   }
</code></pre>

<p>That will reading the value of pin 13 into pushed only once ( e.g. you are holding a button when powering it on ); depending what you want it to do you may want to move the read to the start of <code>loop()</code> so writes random values whenever the button is pressed. </p>
",,13312869,4662
9094394,2,9085028,2012-02-01T10:39:19.857,1,,264802,,2012-02-01T10:44:40.790,2012-02-01T10:44:40.790,0,,"<pre><code>#define pinMode1 1
#define pinMode2 13

bool pushed;
bool val = 0;

void setup() {
  // Declare OUTPUT pin.
  pinMode(pinMode1, OUTPUT);

  // Declare INPUT pin.
  pinMode(pinMode2, INPUT);

  // Set digitalRead().
  pushed = digitalRead(pinMode2);

  // Initializes the pseudo-random number generator.
  randomSeed(analogRead(0));
}

void loop() {
  if (pushed == 1) {
    for (int i = 1; i &lt; 9; i++) {
      val = random(2);
      // Set i to HIGH or LOW.
      digitalWrite(i, val);
    }
  }
}
</code></pre>
",,13313994,288
18202785,2,9110481,2013-08-13T07:10:20.343,0,,2612271,,2013-08-13T07:10:20.343,,0,,"<p>You could use a time-slice design.  Let me just outline this in very general terms.
First code loop so that it always issues a delay(1) and set a mod 10 counter as:</p>

<pre><code> int stopWhen = -1;  // at startup
 // etc.
 x = (x+1)%10;       // every time loop execs
</code></pre>

<p>Then when buttonState == LOW</p>

<pre><code> if (stopwWhen = -1)
 {
    stopWhen = x;
    // beep etc.
 }
</code></pre>

<p>But on every loop:</p>

<pre><code> // always exec this:
 if (stopWhen == x)
 {
    stopWhen = -1;
    // stop beeping.
 }
</code></pre>
",,13357312,6512
9145024,2,9144794,2012-02-04T22:08:20.007,1,,1189830,,2012-02-04T22:08:20.007,,0,,"<p>What if you convert command to a character array and use strchr?</p>

<pre><code>char* separator = strchr(command, ';');
if (separator == NULL) return;

char* rfid = command + id_length;
char* periodid = separator + 1;

unsigned long rfid_long = strtoul(rfid, &amp;separator, 10);
unsigned long periodid_long = strtoul(periodid, NULL, 10);
</code></pre>
",,13361621,1549
9396190,2,9395579,2012-02-22T13:55:37.193,1,,1225607,,2012-02-22T13:55:37.193,,2,,"<p>I tend to avoid macros for this sort of things and use classes and static polymoprhism instead :</p>

<pre><code>// Define different types providing a stream interface
struct DebugStream
{
  template &lt;typename T&gt;
  std::ostream &amp; operator&lt;&lt; (const T &amp; x) const {
    return Serial &lt;&lt; ""debug "" &lt;&lt; x;
  }

  // This one is for stream manipulators
  std::ostream &amp; operator&lt;&lt; (std::ostream&amp; (*x) (std::ostream&amp;)) const {
    return Serial &lt;&lt; ""debug "" &lt;&lt; x;
  }
};


// This type also provides a stream-like interface but does nothing
struct NoStream
{
  template &lt;class T&gt;
  const NoStream &amp; operator&lt;&lt; (const T &amp; x) const { 
    return *this;
  }

  const NoStream &amp; operator&lt;&lt; (std::ostream&amp; (*x) (std::ostream&amp;)) const {
    return *this;
  }
};


// Instanciate a debug object having one of the previously defined types
// 
// Make sure to declare debug in a common .hxx file included everywhere else
// but to define it only once in a .cxx file.
#ifdef DEBUG
DebugStream debug;
#else
NoStream debug;
#endif 


// Use it like you would use the Serial iostream
debug &lt;&lt; ""value is "" &lt;&lt; 3 &lt;&lt; std::endl;
</code></pre>

<p>Since everything is inlined and exact types are known at compile-time, the compiler can optimize out all unnecessary operations on NoStream instances.</p>
",,13372585,1618
9406659,2,9406601,2012-02-23T03:18:50.207,3,,528724,,2012-02-23T03:18:50.207,,0,,"<p>You may run into issues, in this case.</p>

<pre><code>X foo() {

      char ar[10];
      strcpy(ar,""Hello"");

      X obj(ar);

      return obj;
} // ar is deallocated here.
</code></pre>

<p>But returned object's member variable <code>_name</code> still pointing the <code>ar</code> which was earlier on the stack. So, it is better to allocate memory and then free it when no longer needed.</p>
",,13471729,791
9662696,2,9662476,2012-03-12T06:37:17.477,2,,264148,,2012-03-12T07:28:23.940,2012-03-12T07:28:23.940,3,,"<p>That is a lot of code to read, where should I start.</p>

<p>In your <code>loop()</code> you are assigning <code>frequency</code> but printing <code>freq</code></p>

<pre><code>// get our current frequency reading  
   frequency = get_tsl_freq();  
-- snip --
Serial.println(freq);
</code></pre>

<p>in <code>get_tsl_freq()</code> you are creating a local <code>unsigned int freq</code> that hides the global <code>freq</code> and using that for calculation and returning the value, maybe that is also a source of confusion for you. I do not see a reason for <code>frequency</code> and <code>freq</code> to be globals in this code. The function also contains unreachable code, the control will leave the function on return, statements after the return will never be executed.</p>

<pre><code>unsigned long  get_tsl_freq() {  
    unsigned long freq = pulse_cnt * 100;  &lt;-- hides global variable freq  
    // re-set pulse counter  
    pulse_cnt = 0;   
    return(freq);           &lt;-- ( ) not needed
    Serial.println(""freq""); &lt;-- Unreachable
}
</code></pre>

<p>Reading a bit more I can suggest you pick up a C++ book and read a bit. While your code compiles it is not technically valid C++, you get away with it thanks to the Arduino software that does some mangling and what not to allow using functions before they are declared.</p>

<p>On constants you use in your calculations</p>

<pre><code>float w_m2 = (uw_cm2 / (float) 1000000) * (float) 100; 
</code></pre>

<p>could be written as</p>

<pre><code>float w_m2 = (uw_cm2 / 1000000.0f) * 100.0f; 
</code></pre>

<p>or even like this because <code>uw_cm2</code> is a float</p>

<pre><code>float w_m2 = (uw_cm2 / 1000000) * 100;
</code></pre>

<p>You also seem to take both approaches to waiting, you have code that calculates and only runs if it has been more than 1000 msec since it was last run, but then you also <code>delay(1000)</code> in the same code, this may not work as expected at all.</p>
",,13474923,7234
9684285,2,9683869,2012-03-13T12:53:08.963,3,,757293,,2012-03-13T12:53:08.963,,4,,"<p>I remember having had problems when intializing things in constructors for objects declared outside of setup(). I am not sure why, I admit not having investigated the problem. But I went with the idea that too many things were initialized before the program started.</p>

<p>I do not guarantee that it is the solution (and cannot really explain why), but I went around my problem by initializing things in init() methods for my objects instead of their constructors. Then I called the init() methods int my setup() after having set-up the Serial object. Something like that:</p>

<pre><code>#include ""Motor.h""
#include ""Driver.h""
#include ""Lichtsensor.h""
#include ""Eye.h""

Motor motor1; // I do not use any more my constructor
Motor motor2; // I do not use any more my constructor
Driver driver; // I do not use any more my constructor
Eye eye1; // I do not use any more my constructor

void setup(){
    pinMode(13, OUTPUT);
    digitalWrite(13, HIGH);
    Serial.begin(9600);
    Serial.println(""#################################################"");
    Serial.println(""# This sketch communicates with the arduino and #"");
    Serial.println(""# makes the robot drive, and react to a sensor. #"");
    Serial.println(""#################################################\n"");
    motor1.init(5, 4, true); // My object is initialized here
    motor2.init(6, 7, false); // My object is initialized here
    driver.init(motor1, motor2); // My object is initialized here
    eye1.init()
}
</code></pre>

<p>It is always a bit weird to construct an object in a method instead of the constructor. But as it is microcontroller programming and not a common computer program, I guess taking a more functionnal approach is sometimes the simplest.</p>

<p>If you do not have a better answer, you can still try that. Maybe it is enough to do that only for your Eye library as you told you had no problems with the Motor classes.</p>
",,13493723,1537
34694336,2,9683869,2016-01-09T13:57:31.323,0,,799674,,2016-01-09T13:57:31.323,,0,,"<p>I don't think there is wrong with many classes or too many things were initialized .In my case I have many classes defined by me ( more than 5 classes ) . My problem was with the way I defined the classes for example one mistake was when I defined function in the header file , in the cpp file was not prepended by the class name .In code language : </p>

<pre><code>void begin(); // this is a function defined in the header file
void begin(){//this is in the cpp file and this is wrong definition

} 
void NameOfTheClass::begin(){ // this is the correct way in the cpp file
   //code goes here 
}  
</code></pre>
",,13515884,2672
9702233,2,9701895,2012-03-14T12:44:35.567,2,,1268955,,2012-03-14T12:44:35.567,,4,,"<p>You do not very clearly state the ultimate purpose of this, but since you have tagged this embedded and pthreads I will assume you have a dedicated chip with a linux variant running. </p>

<p>In this case, I would suggest the best way to create PWM output is through your main program loop, since I assume the PWM is part of a greater control application. Most simple embedded applications (no UI) can run in a single thread with periodic updates of the GPIOs in your main thread.</p>

<p>For example:</p>

<pre><code>InitIOs();

while(1)
{
   // Do stuff
   UpdatePWM();
}  
</code></pre>

<p>That being said, check your chip specification, in most embedded devices there are dedicated PWM output pins (that can also act as GPIOs) and those can be configured simply in hardware by setting a duty cycle and updating that duty cycle as required. In this case, the hardware will do the work for you.</p>

<p>If you can clarify your situation a bit I can likely give you a more detailed answer.</p>
",,13520272,2962
9729891,2,9729881,2012-03-15T23:46:16.260,7,,560648,,2012-03-15T23:46:16.260,,5,,"<p><a href=""http://arduino.cc/hu/Reference/SoftwareSerial"" rel=""noreferrer""><code>SoftwareSerial</code></a> is a type. You're taking a pointer to a temporary, then dereferencing it after the temporary has died. This is <em>illegal</em>; I don't know why your compiler is accepting it, but I'm going to go out on a limb and suggest that this doesn't mean it's doing what you think it is. It's probably mangling something and causing odd behaviours that would be folly to attempt to rationalise about.</p>

<p>Instead:</p>

<pre><code>//Myclass.h
class Myclass {
private:
    SoftwareSerial ss;
public:
    Myclass();
    void test();
};


//Myclass.cpp

Myclass::Myclass() : ss(0,1) {};

void Myclass::test() {
    ss.begin(9600);
    ss.print(""Hello World"");
};
</code></pre>
",,13520625,200
9806073,2,9805829,2012-03-21T13:56:06.443,0,,774651,,2012-03-26T18:36:56.217,2012-03-26T18:36:56.217,5,,"<p>The destructor gets called when the variable goes out of scope or <code>delete</code>'d. This means, if you have no <code>delete</code> you can <em>only</em> create non-<a href=""http://en.wikipedia.org/wiki/Plain_old_data_structure"" rel=""nofollow"">POD</a> structures in <em>automatic</em> memory.</p>

<p>You <em>cannot</em> use <code>malloc</code> and <code>free</code>, because constructors and destructors <em>will not be called</em>.</p>

<p>But, you can try create your own <code>new</code> and <code>delete</code> like this:</p>

<pre><code>void* operator new(size_t size)
{
    void* mem = malloc(size);
    if (!mem) {
        throw std::bad_alloc();
    }
    return mem;
}

void operator delete(void* ptr)
{
    free(ptr);
}

void* operator new[] (size_t size)
{
    return (operator new)(size);
}

void operator delete[](void* ptr)
{
    return (operator delete)(ptr);
}
</code></pre>
",,13554570,5356
57455124,2,9805829,2019-08-12T02:42:42.787,0,,980442,,2019-08-12T02:58:59.600,2019-08-12T02:58:59.600,0,,"<p>The <strong>Destructor</strong> is something important!
&amp; Yes about <code>malloc</code> and <code>free</code>.</p>

<pre><code>class MyClass {
  private:
    char *_var;
  public:
    MyClass(int size) { // Constructor
      _var = (char *) malloc(sizeof(char) * size);
      ...
    }

  ~MyClass() { // Destructor
    free( _var );
  }
  ...
}
</code></pre>
",,13583419,5150
9831207,2,9831119,2012-03-22T21:59:21.853,3,,8747,,2012-03-22T21:59:21.853,,1,,"<pre><code>char** getCommands(){
  char* commands[10];
  …
  return commands;
}
</code></pre>

<p>The statement <code>return commands</code> doesn't return the <em>value</em> of the array, it returns the <em>address</em> of the array. Technically, the type of the expression <code>commands</code> decays from array-10-of-pointer-to-char to pointer-to-pointer-to-char in this context; the value of the expression is the address of the first element of the array.</p>

<p>As a result, you return the address of a local variable, which local variable ceases to exist after the return statement. Later, in <code>loop</code>, you dereference this pointer to a destroyed object, resulting in undefined behavior.</p>
",,13591776,410
10967575,2,9901058,2012-06-10T09:17:39.980,0,,976001,,2012-06-10T09:17:39.980,,0,,"<p>It exists delay when transferring data via UART. Have a try with Serial.timedRead() instead. The code is as below.</p>

<pre><code>void setup() {
    Serial.begin(9600);
    Serial.write(""Power On"");
}

void loop()
{
    while(!Serial.available());

    while (true) {
      int byte = Serial.timedRead();
      if(byte == -1)
         break;
      Serial.write(byte);
    }
    Serial.println();
}
</code></pre>
",,13612253,468
11680065,2,9901058,2012-07-27T00:48:03.707,11,,1092951,,2012-07-27T00:48:03.707,,0,,"<p>I figured it out.</p>

<p>When you open a Serial with 9600 baud (<code>Serial.begin(9600);</code>), it's reading/writing at 9600 bytes per second. That means at fastest it can get just under 10 bytes per millisecond. I don't know what the operating speed is, but it seems like the Arduino gets alerted of and reads the first byte before the second one arrives. So, you must add a <code>delay(1)</code> to ""wait"" for another byte in the ""same stream"" to arrive.</p>

<pre><code>String read() {
    while (!Serial.available()); //wait for user input
    //there is something in the buffer now
    String str = """";
    while (Serial.available()) {
        str += (char) Serial.read();
        delay(1); //wait for the next byte, if after this nothing has arrived it means the text was not part of the same stream entered by the user
    }
    return str;
}
</code></pre>

<p>You may ask, well since you're delaying how do you know if the user is just typing very fast? You can't avoid it here, since the Serial is essentially limited at a certain speed. However, the user must be typing virtually-impossibly-fast for two inputs to be confused as one.</p>
",,13663669,264
27049083,2,9901058,2014-11-20T20:36:55.717,1,,3270761,,2014-11-20T20:36:55.717,,0,,"<p>Even though this post is old, I'll post my answer in case someone googles their way here.</p>

<p>For reading strings from the serial you can use the following:</p>

<pre><code>String str;

while (Serial.available() &gt; 0) {
    str = Serial.readString();
}
</code></pre>

<p>Works like a charm!</p>
",,13684387,1055
28600613,2,9901058,2015-02-19T07:17:51.143,-3,,4582625,,2015-02-19T15:33:53.463,2015-02-19T15:33:53.463,0,,"<pre><code>String str;

void setup()
{
    Serial.begin(9600);
}

void loop ()
{
    while (Serial.available() &gt; 0){
        char c = Serial.read();
        str.concat(c);
        if (Serial.available() == 0)
        {
            Serial.print(str);
            str = """";
            break;
        }
    }
}
</code></pre>
",,13732217,167
9917599,2,9917307,2012-03-29T00:29:34.407,1,,350527,,2012-03-29T00:29:34.407,,1,,"<p>Using boost::asio</p>

<pre><code>#include &lt;string&gt;
#include &lt;boost/asio.hpp&gt;
using namespace::boost::asio;

serial_port_base::baud_rate BAUD(9600);
serial_port_base::parity PARITY(serial_port_base::parity::none);
serial_port_base::stop_bits STOP(serial_port_base::stop_bits::one);

void SendDataViaSerialPort(const std::string&amp; to_write)
{
        io_service io;
        serial_port port(io, ""COM29"");

        port.set_option(BAUD);
        port.set_option(PARITY);
        port.set_option(STOP);

        write(port, buffer(to_write,1));
}
</code></pre>
",,13743933,5753
9985273,2,9956145,2012-04-02T23:36:22.157,2,,1309240,,2012-04-02T23:36:22.157,,1,,"<p>I have also bought the shield and had trouble to start with. </p>

<p>If you have soldered the pins to the shield that should be fine but make sure you check they all have a connection and that they don't have solder running down the legs of the pins as this causes the shield to be temperamental.</p>

<p>Run the code below which is from the WiFly library (alpha 2 version) that can be found here:
<a href=""http://forum.sparkfun.com/viewtopic.php?f=32&amp;t=25216&amp;start=30"" rel=""nofollow"">http://forum.sparkfun.com/viewtopic.php?f=32&amp;t=25216&amp;start=30</a></p>

<p>Once you see that the shield has connected it will ask for an input, type $$$ and press enter... you have now entered the command line and CMD will be displayed.</p>

<p>If you do not know your network settings type scan and this will display them.
Then set your authentication by typing set wlan auth 3 (Mixed WPA1 &amp; WPA2-PSK) or set wlan auth 4 (WPA2-PSK) this depends on the type of authentication you ise so pick the write one for your network.</p>

<p>Then type set wlan phrase YourPharsePhrase (Change YourPharsePhrase to whatever your WPA key is)
Then type join YourSSIDName (Change YourSSIDName to whatever your network name is)</p>

<p>You see something like this: 
    join YourSSIDName
    Auto-Assoc YourSSIDName chan=1 mode=MIXED SCAN OK
    Joining YourSSIDName now..
    &lt;2.15> Associated!
    DHCP: Start
    DHCP in 1234ms, lease=86400s
    IF=UP
    DHCP=ON
    IP=10.0.0.116:2000
    NM=255.255.255.0
    GW=10.0.0.1
    Listen on 2000</p>

<p>you are now connected to your network.</p>

<p>Hopefully this will get you up and running.
<strong>N.B. REMEMBER TO CAREFULLY CHECK YOUR PINS! I had great trouble with mine because only a small amount of solder is needed but enough to get a good connection, the balance of this was minute but enough that it wouldn't work.  I used a magnifying to check mine in the end.</strong></p>

<pre><code>#include ""WiFly.h"" // We use this for the preinstantiated SpiSerial object.


void setup() {

  Serial.begin(9600);
  Serial.println(""SPI UART on WiFly Shield terminal tool"");
  Serial.println(""--------------------------------------"");  
  Serial.println();
  Serial.println(""This is a tool to help you troubleshoot problems with the WiFly shield."");
  Serial.println(""For consistent results unplug &amp; replug power to your Arduino and WiFly shield."");
  Serial.println(""(Ensure the serial monitor is not open when you remove power.)"");  
  Serial.println();

  Serial.println(""Attempting to connect to SPI UART..."");
  SpiSerial.begin();
  Serial.println(""Connected to SPI UART."");
  Serial.println();

  Serial.println("" * Use $$$ (with no line ending) to enter WiFly command mode. (\""CMD\"")"");
  Serial.println("" * Then send each command followed by a carriage return."");
  Serial.println();

  Serial.println(""Waiting for input."");
  Serial.println();    

}


void loop() {
  // Terminal routine

  // Always display a response uninterrupted by typing
  // but note that this makes the terminal unresponsive
  // while a response is being received.
  while(SpiSerial.available() &gt; 0) {
    Serial.write(SpiSerial.read());
  }

  if(Serial.available()) { // Outgoing data
    //SpiSerial.print(Serial.read(), BYTE);
    SpiSerial.write(Serial.read());
  }
}
</code></pre>
",,13775893,50934
54167315,2,9986591,2019-01-13T08:48:02.313,7,,10888308,,2020-04-02T17:00:07.597,2020-04-02T17:00:07.597,1,,"<p>You can write this LinkedList template class and simply call it wherever you want :</p>

<pre><code>#ifndef LinkedList_hpp
#define LinkedList_hpp


template &lt;class T&gt;
class ListNode {
  public:
    T element;
    ListNode* next;
    ListNode* prev;

    ListNode(T element, ListNode* prev, ListNode* next) : element(element)
    {
      this-&gt;next = next;
      this-&gt;prev = prev;
    };
};

template &lt;class T&gt;
class LinkedList  {
  private:
    int length;
    ListNode&lt;T&gt;* head;
    ListNode&lt;T&gt;* tail;
    ListNode&lt;T&gt;* curr;
  public:
    LinkedList();
    LinkedList(const LinkedList&lt;T&gt;&amp;);
    ~LinkedList();
    T&amp; getCurrent();
    T&amp; First() const;
    T&amp; Last() const;
    int getLength();
    void Append(T);
    void DeleteLast();
    void DeleteFirst();
    void DeleteCurrent();
    bool next();
    bool moveToStart();
    bool prev();
    void Delete(T&amp;);
    bool Search(T);
    void Clear();
    void PutFirstToLast();
    void Update(T elem);
    LinkedList&amp; operator = (const LinkedList&lt;T&gt;&amp;);
};

template &lt;class T&gt;
LinkedList&lt;T&gt;::LinkedList() {
    length = 0;
    head = nullptr;
    tail = nullptr;
    curr = nullptr;
}

template &lt;class T&gt;
LinkedList&lt;T&gt;::LinkedList(const LinkedList&lt;T&gt; &amp; list) {
    length = 0;
    head = nullptr;
    tail = nullptr;
    curr = nullptr;

    ListNode&lt;T&gt; * temp = list.head;

    while(temp != nullptr)
    {
        Append(temp-&gt;element);
        temp = temp-&gt;next;
    }
}

template &lt;class T&gt;
LinkedList&lt;T&gt; &amp; LinkedList&lt;T&gt;::operator=(const LinkedList&lt;T&gt; &amp; list)
{
    Clear();

    ListNode&lt;T&gt; * temp = list.head;

    while(temp != nullptr)
    {
        Append(temp-&gt;element);
        temp = temp-&gt;next;
    }

    return *this;
}

template &lt;class T&gt;
LinkedList&lt;T&gt;::~LinkedList() {
    Clear();
}

template&lt;class T&gt;
T&amp; LinkedList&lt;T&gt;::getCurrent()
{
  return curr-&gt;element;
}

template&lt;class T&gt;
T&amp; LinkedList&lt;T&gt;::First() const
{
  return head-&gt;element;
}

template&lt;class T&gt;
T&amp; LinkedList&lt;T&gt;::Last() const
{
  return tail-&gt;element;
}

template&lt;class T&gt;
int LinkedList&lt;T&gt;::getLength()
{
  return length;
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::Append(T element)
{
    ListNode&lt;T&gt; * node = new ListNode&lt;T&gt;(element, tail, nullptr);

    if(length == 0)
        curr = tail = head = node;
    else {
        tail-&gt;next = node;
        tail = node;
    }

    length++;

}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::DeleteLast()
{
    if(length == 0)
      return;
    curr = tail;
    DeleteCurrent();
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::DeleteFirst()
{
    if(length == 0)
      return;
    curr = head;
    DeleteCurrent();
}

template &lt;class T&gt;
bool LinkedList&lt;T&gt;::next()
{
    if(length == 0)
        return false;

    if(curr-&gt;next == nullptr)
        return false;

    curr = curr-&gt;next;
    return true;
}

template &lt;class T&gt;
bool LinkedList&lt;T&gt;::moveToStart()
{
    curr = head;
    return length != 0;
}

template&lt;class T&gt;
bool LinkedList&lt;T&gt;::prev()
{
    if(length == 0)
        return false;

    if(curr-&gt;prev != nullptr)
        return false;

    curr = curr-&gt;prev;
    return true;
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::Delete(T &amp; elem)
{
    if(Search(elem))
        DeleteCurrent();
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::DeleteCurrent()
{
    if(length == 0)
        return;
    length--;
    ListNode&lt;T&gt; * temp = curr;

    if(temp-&gt;prev != nullptr)
        temp-&gt;prev-&gt;next = temp-&gt;next;
    if(temp-&gt;next != nullptr)
        temp-&gt;next-&gt;prev = temp-&gt;prev;

    if(length == 0)
        head = curr = tail = nullptr;
    else if(curr == head)
        curr = head = head-&gt;next;
    else if(curr == tail)
        curr = tail = tail-&gt;prev;
    else
        curr = curr-&gt;prev;

     delete temp;
}

template &lt;class T&gt;
bool LinkedList&lt;T&gt;::Search(T elem)
{
    if(length == 0)
        return false;
    if(moveToStart())
        do {
            if(curr-&gt;element == elem)
                return true;
        } while (next());
    return false;
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::PutFirstToLast()
{
  if(length &lt; 2)
    return;
  ListNode&lt;T&gt;* temp = head-&gt;next;
  head-&gt;next-&gt;prev = nullptr;
  head-&gt;next = nullptr;
  head-&gt;prev = tail;
  tail-&gt;next = head;
  tail = head;
  head = temp;
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::Update(T elem)
{
    if(Search(elem))
        curr-&gt;element = elem;
}

template &lt;class T&gt;
void LinkedList&lt;T&gt;::Clear()
{
    if(length == 0)
        return;
    ListNode&lt;T&gt; * temp = head;

    while(temp != nullptr)
    {
        head = head-&gt;next;
        delete temp;
        temp = head;
    }

    head = curr = tail = nullptr;

    length = 0;

}


#endif
</code></pre>

<p>Use this class as follow:</p>

<pre><code>LinkedList&lt;int&gt; list;

list.Append(1);
list.Append(2);
list.Append(3);
list.Append(4);

int my_integer;

if(list.moveToStart())
    do{
        my_integer = list.getCurrent();
    }while(list.next());
</code></pre>
",,13781908,521
10059889,2,10059823,2012-04-08T02:15:33.310,3,,14860,,2012-04-08T02:51:28.113,2012-04-08T02:51:28.113,4,,"<p>In C, you would do something like:</p>

<pre><code>char buff[100]; // needs to be large enough.
int c = 33;
sprintf (buff, ""hello%d"", c); // may want a space after hello

// Now do something with buff.
</code></pre>

<p>C is a language where you need to manage some low-level details yourself. There's no automatically expanding string type in the base language/library although no doubt there are some good third-party ones around (<a href=""http://bstring.sourceforge.net/"" rel=""nofollow"">""better strings""</a>, for example, since it doesn't drag in a lot of other stuff you don't want, particularly important in the embedded space).</p>
",,13781915,139
10060236,2,10059823,2012-04-08T03:48:07.293,2,,102302,,2012-04-08T20:36:43.673,2012-04-08T20:36:43.673,0,,"<p>Arduino has the built-in <a href=""http://arduino.cc/en/Reference/StringObject"" rel=""nofollow"">String class</a>, and in that you can do:</p>

<pre><code>String stringOne = ""A long integer: "";
// using += to add a long variable to a string:
stringOne += 123456789;

// or

stringTwo.concat(123456789);
</code></pre>

<p>and if both cases you get <code>""A long integer: 123456789""</code>.</p>
",,13791326,107
10096792,2,10059823,2012-04-10T21:35:31.523,0,,4023,,2012-04-10T21:35:31.523,,0,,"<p>The equivalent of your JavaScript code as an Arduino sketch is:</p>

<pre><code>void setup() {
  Serial.begin(9600);
  int c = 33;                 // var c = 33;
  String myString = ""hello"";  // var myString = ""hello""
  myString += c;              //                        + c;
  Serial.println(myString);   // alert(myString); //---&gt; hello33
}

void loop() {
}
</code></pre>

<p>For string handling, the differences between the JavaScript and the Arduino (C++) code are:</p>

<ul>
<li>Variables are strongly typed. For example, you need to indicate if a variable is an integer (<code>int</code>) or a string (<code>String</code>) when you declare it.</li>
<li>Strings are not built-in 'primitive' types in C++ (and the Arduino version of C++ does not support the C++ standard library string either) so some simple manipulations cannot be performed as a single statement. For example, the assignment and concatenation requires two lines of Arduino code.</li>
</ul>

<p>Other important differences between your JavaScript and the Arduino (C++) code are:</p>

<ul>
<li>You need both a <code>setup</code> and <code>loop</code> function rather than a <code>main</code> function. <code>setup</code> runs only once when power is applied to the Arduino board and then <code>loop</code> is executed continually.</li>
<li>The nearest equivalent of JavaScript's <code>alert</code> in Arduino is to write to the serial port. To see this output you will need the Arduino board to be connected to a PC. Within the Arduino IDE, turning on the Serial Monitor will allow you to see the output.</li>
</ul>
",,13792302,6975
10079467,2,10079338,2012-04-09T20:32:17.287,1,,1047662,,2012-04-10T05:45:31.933,2012-04-10T05:45:31.933,6,,"<p>Your assembleFrame() function returns a local variable that will run out of scope when the function returns. You could do something like this:</p>

<pre><code> byte* assembleFrame() {
      byte* frame = new byte[5];
      frame[0] = 4;
      frame[1] = 'a';
      frame[2] = 'b';
      frame[3] = 'c';
      frame[4] = 'd';
      return frame;
 }
</code></pre>

<p><em>Note</em> that the memory returned by assembleFrame() then should be freed using:</p>

<pre><code>void loop() {
   byte* frame = assembleFrame();
   Serial.write( frame , frame[ 0 ] );
   // release the memory allocated by assembleFrame()
   delete [] frame;
   while ( 1 ) {
   }
}
</code></pre>
",,13792760,178
10079595,2,10079338,2012-04-09T20:42:52.060,3,,114986,,2012-04-09T22:13:55.963,2012-04-09T22:13:55.963,6,,"<p>+Krister's answer is a good one, I would improve on it by suggesting you pass the buffer into your assembly function, if at all possible.</p>

<pre><code>/* Takes in an array of bytes with at least the given size, returns
 * the number of bytes written into the frame.
 */
int assembleFrame(byte *frame, int frame_size) {
  frame[0] =  4;
  frame[1] = 'a';
  frame[2] = 'b';
  frame[3] = 'c';
  frame[4] = 'd';
  return 5; // only used five bytes in the frame
}

  /* then in loop() */
  byte frame[10];
  bytes_in_frame = assembleFrame(frame, 10);
  someDataSendingFunction(frame, bytes_in_frame); // assuming ptr + bytes to send
</code></pre>

<p>That way you don't create the possibility of a memory leak later on.</p>
",,13816590,631
10152977,2,10149589,2012-04-14T10:45:09.957,3,,528313,,2012-04-18T19:03:12.573,2012-04-18T19:03:12.573,11,,"<p>You can send the <code>float</code> in bytes and reconstruct the <code>float</code> at the receiver.</p>

<p>The following example may help you:</p>

<p>Sender side:</p>

<pre><code>float x = 1128.476;

char b[sizeof(x)];
memcpy(b, &amp;x, sizeof(x));

// Iterate over b and send bytes
// [...]
</code></pre>

<p>Receiver side:</p>

<pre><code>float y = 0;

char b[sizeof(x)];

// Store 4 bytes representing the float into b
// [...]

// Rebuild the float
memcpy(&amp;y, b, sizeof(y));
</code></pre>

<p>At the end, you have <code>float y</code> on the receiver side, which has the same representation of <code>float x</code> on the sender side.</p>
",,13904268,3037
10163061,2,10149589,2012-04-15T14:50:43.457,0,,344661,,2012-04-15T14:50:43.457,,0,,"<p>You can send all the binary data you want between two machines of an identical architecture, memory layout, byte-endianness, etc. by simply taking a byte-sized pointer <code>(char *)</code> on the ""sending"" side, and iterating over the referenced object for the number of bytes in that object.  On the ""receiving"" side, you allocate an object of the same size (float, long, struct foo), and receiving the bytes, one by one, into a byte-sized pointer which is post-incremented after each byte is received.</p>

<p>On the sending side --</p>

<pre><code>void sendObject(const void *object, size_t size) {
  char *outputCursor = (char *) object;

  for (;size &gt; 0;size--)
    yourSendAByteFunction(*outputCursor++);
}
</code></pre>

<p>On the receiving side, assuming yourReceiveAByteFunction() return 0..255 for a valid byte and -1 for a ""receiving error"", you can do this --</p>

<pre><code>int receiveObject(void *object, size_t size) {
  char *inputCursor = (char *) object;

  for (;size &gt; 0;size--) {
    int nextByte = yourReceiveAByteFunction();
    if (nextByte &lt; 0)
      return FALSE;

    *inputCursor++ = nextByte;
  }
  return TRUE;
}
</code></pre>

<p>You can do the same I/O error checking in the <code>sendObject()</code> function by declaring <code>yourSendAByteFunction()</code> so it returns <code>TRUE</code> or <code>FALSE</code> depending on whether or not an error occurred in the output.  It all depends on how much complexity you can stand, and whether or not you have a reliable transmission link.</p>

<p>You can also do a bit of data encapsulation if you have bytes you can't transmit by having a ""shift"" byte and set of byte values that are prefixed by the ""shift"" byte to represent some other byte.</p>
",,13909596,253
10168123,2,10149589,2012-04-16T02:38:45.903,0,,877375,,2012-04-16T02:38:45.903,,0,,"<p>Your original sender is sending an ASCII string that represents the float value.</p>

<p>In order to receive and display the value you need to modify the lines as shown below:</p>

<pre><code>(...appropriate setup...)
void loop() { 
  lcd.setCursor(0, 0);
  while (Serial.available() &gt; 0) {       //Changed Line
      incomingByte = Serial.read();      //Added Line
      lcd.print(incomingByte);
  }
  delay(1000);
}
</code></pre>

<p>Note: If would be better to terminate the serial output with a CR to synchronize the devices instead of the delay(1000); </p>
",,13925772,2266
10221040,2,10220673,2012-04-19T02:53:45.700,1,,10897,,2012-04-19T15:48:19.480,2012-04-19T15:48:19.480,2,,"<p>You asked it to print the reading and it is doing - it's printing each reading!</p>

<p>I suspect you either want it to only print if the value changes</p>

<pre><code>int sensorValue = 0;
int prevValue = 0;

void loop()
{    
    sensorValue = 0.004882812 * analogRead(sensorPin) + 1;
    if (sensorValue != prevValue) {
       lcd.print(sensorValue);
       prevValue == sensorValue;
    }
}
</code></pre>

<p>Alternatively you could print 'n' backspaces so the new value is printed over the top of the old one, if your display lcd.print supports that</p>
",,13953346,596
10231909,2,10220673,2012-04-19T15:51:10.307,0,,4023,,2012-04-19T15:51:10.307,,0,,"<p>It sounds like <code>print()</code> is clearing the screen of previous data every time it is called (although the relevant documentation and library code available <a href=""http://hmario.home.xs4all.nl/arduino/LiquidCrystal_I2C/"" rel=""nofollow"">here</a> and <a href=""http://www.arduino.cc/playground/Code/LCDAPI"" rel=""nofollow"">here</a> is unclear).</p>

<p>If this is the case you need to print the <code>Voltage=</code> string in the loop along with the sensor value. Try changing your code to:</p>

<pre><code>#include &lt;Wire.h&gt; 
#include &lt;LiquidCrystal_I2C.h&gt;

LiquidCrystal_I2C lcd(0x27,16,2);  
int sensorPin = A0;

void setup()
{
    lcd.init();                      
    lcd.backlight();
}

void loop()
{
    int sensorValue = 0.004882812 * analogRead(sensorPin) + 1;
    String display = ""Voltage="";
    display += sensorValue;
    lcd.print(display);
}
</code></pre>
",,13962636,285
10270382,2,10268572,2012-04-22T17:40:31.050,2,,1131467,,2012-04-22T17:40:31.050,,0,,"<p>I would say fastest way is:</p>

<pre><code>switch (int(input) /  500)
{
case 0: ... // 0..500
case 1: ... // 500..1000
case 2: ... // 1000..1500
etc
}
</code></pre>
",,13968217,1424
10270418,2,10268572,2012-04-22T17:44:06.697,2,,4023,,2012-04-22T17:44:06.697,,0,,"<p>It's not entirely clear from your code example what you are trying to achieve, but assuming that you want to evenly distribute your (0 to 7000) <code>input</code> to the (-7 to 7) <code>eps</code> values so that all intervals are equally represented you can't use multiples of 500. Using 500s will cause one of the extreme values (-7 or 7) to only result from a very small range of <code>input</code> values.</p>

<p>You could, for example, use the following function to calculate <code>eps</code> from <code>input</code>:</p>

<pre><code>int eps(double input) {
  return ((int)(input/500.0)) - 7;
}
</code></pre>

<p>However, using this function produces the following mapping which makes an <code>eps</code> value of 7 much rarer than all the others:</p>

<pre><code>         input         | eps
&gt;=    0.0 and &lt;  500.0 | -7
&gt;=  500.0 and &lt; 1000.0 | -6
&gt;= 1000.0 and &lt; 1500.0 | -5
&gt;= 1500.0 and &lt; 2000.0 | -4
&gt;= 2000.0 and &lt; 2500.0 | -3
&gt;= 2500.0 and &lt; 3000.0 | -2
&gt;= 3000.0 and &lt; 3500.0 | -1
&gt;= 3500.0 and &lt; 4000.0 |  0
&gt;= 4000.0 and &lt; 4500.0 |  1
&gt;= 4500.0 and &lt; 5000.0 |  2
&gt;= 5000.0 and &lt; 5500.0 |  3
&gt;= 5500.0 and &lt; 6000.0 |  4
&gt;= 6000.0 and &lt; 6500.0 |  5
&gt;= 6500.0 and &lt; 7000.0 |  6
&gt;= 7000.0              |  7
</code></pre>

<p>If instead you do want an even distribution, you will need to use the following code:</p>

<pre><code>int eps(double input) {
  return ((int)(input/466.733333))-7;
}
</code></pre>
",,14045105,3203
10310672,2,10307496,2012-04-25T06:48:56.307,9,,757293,,2012-04-26T18:35:01.917,2012-04-26T18:35:01.917,3,,"<p><em>(Edit: I missed the very useful link in Matt's answer while writing my own answer. So let's say that what is below is a non technical summary of the link).</em></p>

<p>Matt answered right. I would like to add additional information.</p>

<p>The key to understand Arduino programming is in the directory <code>Arduino-1.0\hardware\arduino\cores\arduino</code></p>

<p>You will find the <code>main.cpp</code> file containing:</p>

<pre><code>#include &lt;Arduino.h&gt;

int main(void)
{
    init();

    #if defined(USBCON)
        USB.attach();
    #endif

    setup();

    for (;;) {
        loop();
        if (serialEventRun) serialEventRun();
    }

    return 0;
}
</code></pre>

<p>Do ""setup()"" and ""loop()"" (and even ""serialEventRun() if you read the Arduino documentation) ring a bell? :-)</p>

<p>Arduino hides only that.</p>

<p>Arduino uses the C++ language. Of course, you can use C if you compile your code yourself with avr-gcc, but the way the Arduino IDE is configured, it is pure C++.</p>

<p>However, as microcontrollers are not really adapted to object-oriented development, some features are missing. I think about the ""new"" and ""delete"" operators. They do not exist, so out of the box, you should avoid using the heap when you develop with Arduino. It is why you should be careful if you want to use some standard C++ libraries. They may not be adapted for microcontroller programming (too many memory operations).</p>

<p>In the <code>Arduino-1.0\hardware\arduino\cores\arduino</code> directory, you can also see the implementation of the Arduino library. It allows watching which ""low-level"" microcontroller functions (from avr-libc) exist and how you can implement your own libraries and tools.</p>

<p>By the way, as you wanted to know how you could port Arduino code in C, avr-libc is a C library and not a C++ one. So you can see how Arduino wraps its C++ code over C code.</p>

<p>In the <code>File/Preferences</code> menu, you can check ""see verbose output"" to see which parameters and files are used to build the final Arduino binary (and where the temporary build directory is).</p>

<p>Finally, you must also know that Arduino boards have a bootloader embedded with your code. It eases the deployment from the Arduino IDE to the Arduino board. So the Arduino board actually contains more code than your own.</p>
",,14063588,2516
14879024,2,10319655,2013-02-14T16:07:35.620,0,,2072728,,2013-02-14T17:10:16.103,2013-02-14T17:10:16.103,0,,"<p>I had the same problem, but the issue was with <code>Timer1.initialize()</code>. Try this:</p>

<pre><code>  com.drone_is_init = com.init_drone();

  Serial.println(""One"");
  Serial.println(""Two"");
  Serial.println(""Three"");

  Timer1.initialize(COMWDG_INTERVAL_USEC);
  Timer1.attachInterrupt(watchdog_timer);
</code></pre>

<p>Open serial monitor and see... it will show until ""Two"", and then Arduino will hang.</p>

<p>The issue was I calling some functions of the LiquidCrystal_I2C library, that need interrupt routines. Check if your timer ISR is using some interrupts. If so, you should move this code to another place in your project.</p>
",,14073139,806
10332643,2,10331866,2012-04-26T11:39:20.480,20,,757293,,2019-10-18T07:54:34.123,2019-10-18T07:54:34.123,4,,"<p>A straightforward way is to use the <code><a href=""http://arduino.cc/en/Reference/Millis"" rel=""nofollow noreferrer"">millis()</a></code> or <code><a href=""http://arduino.cc/en/Reference/Micros"" rel=""nofollow noreferrer"">micros()</a></code> function in the Arduino library. You will have a finer grain result with <code><a href=""http://arduino.cc/en/Reference/Micros"" rel=""nofollow noreferrer"">micros()</a></code>.</p>

<p>For instance:­­­­­­</p>

<pre><code>unsigned long start = micros();
// Call to your function
myFunction();
// Compute the time it took
unsigned long end = micros();
unsigned long delta = end - start;
Serial.println(delta);
</code></pre>

<p>Read carefully the documentation of <code><a href=""http://arduino.cc/en/Reference/Micros"" rel=""nofollow noreferrer"">micros()</a></code>: there are some information about the time resolution.</p>
",,14077456,236
10816206,2,10451128,2012-05-30T12:22:52.127,1,,,user1176298,2012-05-30T12:22:52.127,,0,,"<pre><code>#define numberOfBytes 4
char command[numberOfBytes];

    void serialRX() {
      while (Serial.available() &gt; numberOfBytes) {
        if (Serial.read() == 0x00) { //send a 0 before your string as a start byte
          for (byte i=0; i&lt;numberOfBytes; i++)
            command[i] = Serial.read();
        }
      }
    }
</code></pre>
",,14091998,4208
12483533,2,10451128,2012-09-18T19:18:18.330,10,,1681274,,2012-09-18T23:00:06.850,2012-09-18T23:00:06.850,0,,"<pre><code>String txtMsg = """";  
char s;

void loop() {
    while (serial.available() &gt; 0) {
        s=(char)serial.read();
        if (s == '\n') {
            if(txtMsg==""HIGH"") {  digitalWrite(13, HIGH);  }
            if(txtMsg==""LOW"")  {  digitalWrite(13, LOW);   }
            // Serial.println(txtMsg); 
            txtMsg = """";  
        } else {  
            txtMsg +=s; 
        }
    }
}
</code></pre>
",,14146850,15073
26807673,2,10451128,2014-11-07T18:24:40.037,1,,2111754,,2014-11-07T18:30:56.043,2014-11-07T18:30:56.043,0,,"<p>It reads 'ÿ' because there is no char to read in the buffer. It takes some time for the others characters to unstack from the uart buffer. So, you cannot do a loop to read chars. You have to wait that another character is available before reading it. </p>

<p>Also, this way of waiting characters is not the best way because it blocks the main loop.</p>

<p>Here is what I do in my programs:</p>

<pre><code>String command;

void loop()
{
    if(readCommand())
    {
        parseCommand();
        Serial.println(command);
        command = """";
    }
}

void parseCommand()
{
  //Parse command here
}

int readCommand() {
    char c;
    if(Serial.available() &gt; 0)
    {
        c = Serial.read();
        if(c != '\n')
        {       
            command += c;
            return false;
        }
        else
            return true;

    }
} 
</code></pre>
",,14165995,471
10499130,2,10494797,2012-05-08T13:00:55.110,1,,4023,,2012-05-10T08:21:40.680,2017-05-23T10:08:57.170,4,,"<p>The compilation problem is due to the <code>printXxx()</code> functions available on the <code>client</code> object not supporting <code>printf</code> format specifiers. Whilst it's not obvious what the type of <code>client</code> is, it evidently subclasses the built-in Arduino <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/cores/arduino/Print.h"" rel=""nofollow noreferrer""><code>Print</code></a> class.</p>

<p>To use the format specifiers you have to do it in two steps, for example (note that a <code>byte</code> in Arduino is actually a <code>uint8_t</code> and <code>PRIu8</code> is the format specifier for this type):</p>

<pre><code>#define __STDC_LIMIT_MACROS 1
#include &lt;inttypes.h&gt;

// ...

char ifStatement[13];
sprintf(ifStatement, ""if (%"" PRIu8 "" == 1) {"", stat[0]);
client.println(ifStatement);

client.println(""// JavaScript code to execute if stat[0] == 1"");

client.println(""}"");
</code></pre>

<p>Also, note that this assumes that <code>stat[0]</code> is always a single digit. If it has two or more digits the <code>ifStatement</code> buffer will overflow, corrupting memory.</p>

<p>However, since (<a href=""https://stackoverflow.com/a/10495196/4023"">as unwind points out</a>) the JavaScript if statement is essentially constant from the perspective of the browser, it would perhaps be simpler to do this in the Arduino code:</p>

<pre><code>if (stat[0] == 1) {
    client.println(""// JavaScript code to execute if stat[0] == 1"");
}
</code></pre>
",,14179035,2034
10671827,2,10663705,2012-05-20T08:08:58.773,1,,168986,,2012-05-20T13:57:08.103,2012-05-20T13:57:08.103,0,,"<p>While you know that the <code>GSAttackDur</code> enum members are sequential numeric values, to rely upon <em>inside information</em> of a third-party library (or even your own library) to infer that a cast of an integer to an enum is valid or safe is not <em>best practice</em>.  </p>

<p>It may not always be true in the general case or under code maintenance that the values are sequential or even an arithmetic progression.  A better general solution is to use a look-up table to translate your random integer to a valid enum type value, thus requiring no knowledge of the actual enum literal values in either magnitude or order:</p>

<pre><code>GSAttackDur getRandomDuration()
{
    static const GSAttackDur lookup[]
    {
        AT_2MS, AT_8MS, AT_16MS, AT_24MS, AT_38MS, 
        AT_56MS, AT_68MS, AT_80MS, AT_100MS // add more as necessary
    } ;

    // Get random index into lookup - 0 to N-1 where N is the number 
    // of elements in lookup.
    int r = rand() / (RAND_MAX / (sizeof(lookup) / sizeof(*lookup)) ) ;

    // Return a random GSAttackDur value
    return lookup[r] ;
}
</code></pre>
",,14307087,1563
10681316,2,10681153,2012-05-21T07:49:38.000,3,,485561,,2012-05-21T07:49:38.000,,0,,"<p>It seems that you are trying to call the constructors of <code>sensor1</code> and <code>sensor2</code>, but at that point in the code they have already been constructed. Try using their <code>init</code> function instead:</p>

<pre><code>sensor1.init(
    (unsigned char[]){led1,led2,led3,led4,led5,led6,led7,led8},
    numSensors,
    timeout,
    emitterPin1);

sensor2.init(
    (unsigned char[]){led9,led10,led11,led12,led13,led14,led15,led16},
    numSensors,
    timeout,
    emitterPin2);
</code></pre>
",,14346650,369
10681470,2,10681153,2012-05-21T08:00:40.367,1,,440558,,2012-05-21T08:00:40.367,,1,,"<p>I assume the lines 47 and 48 are the following two:</p>

<pre><code>sensor1((unsigned char[]){led1,led2,led3,led4,led5,led6,led7,led8},numSensors,timeout,emitterPin1);
sensor2((unsigned char[]) {led9,led10,led11,led12,led13,led14,led15,led16},numSensors,timeout,emitterPin2);
</code></pre>

<p>The problem is that you try to call the <em>objects</em> as <em>functions</em>. The objects needs to be initialized in the constructor, like this:</p>

<pre><code>sedimentSensor::sedimentSensor() 
    : led1(24), led2(26), /* other variables needing initialization */
      sensor1(/*arguments*/), sensor2(/*arguments*/)
{
    /* .... */
}
</code></pre>

<p>For the above to work you need to change the order of the class member variable declarations, as the order member variables are initialized is the same as the order they are declared. In other words, you should put the declaration of <code>sensor1</code> and <code>sensor2</code> to be <em>after</em> the variables used to initialize them.</p>
",,14397064,935
10687971,2,10687080,2012-05-21T15:15:42.360,2,,900873,,2012-05-23T15:55:04.820,2012-05-23T15:55:04.820,3,,"<p>You have a redundant check causing an infinite loop.</p>

<pre><code>void sortNumbers()
{
  ...
  int check = 1;
  if( check != 0 )
  {
    ...
    sortNumbers();
  }
}
</code></pre>

<p>Now, since this is clearly homework, I'll just give some general advice. In general, you use recursion to make a problem of a particular size smaller. Figure out what part of the problem is getting smaller each iteration, and just make each iteration a recursive call instead of a loop (hint: this means you'll probably want to pass some value into the method to tell you the size and/or location of the current iteration). And remember to have a check either at the beginning of the method or before you recurse to check the size of the problem.</p>

<hr>

<pre><code>void loop()
{
  int topLevel = 0;
  int currentSort = 0;
  /* You never initialize this - what's supposed to be in it? */
  int numbers [49];
  int sizeOfArray = sizeof(numbers)/sizeof(int);
  /* Two things here: you're passing an array (numbers) in where the 
     sortNumbers() function has it declared as an int;
     and the return value is declared as an int, but you're storing it 
     into an array. */
  numbers = sortNumbers(topLevel,currentSort,sizeOfArray,numbers);
}

/* You're going to have to change this method signature - you're working 
   with arrays, not plain ints. You're changing numbers[] inline, so you 
   don't need to return anything. */
int sortNumbers(int p,int c,int l,int numbers)
{
 /* The first iteration has c = 0, so [c-1] is going to be out-of-bounds. 
    Also, when c = l, [c] will be out of bounds. */
 if( numbers[c-1] &gt; numbers[c] )
 {
   int temp = numbers[c-1];
   numbers[c-1] = numbers[c];
   numbers[c] = temp;
 }
 if( c == l )
 {
   c = 0;
   p++;
 }
 if( p == l+1 )
 {
   return numbers;
 }
 return sortNumbers(p,c+1,l, numbers);
}
</code></pre>

<p>This isn't how I was thinking of doing it, but I believe it should work once you fix the problems I've pointed out (and possibly some I missed).</p>
",,14411808,223
10824149,2,10824081,2012-05-30T20:57:27.090,1,,1364752,,2012-05-30T21:16:32.767,2012-05-30T21:16:32.767,9,,"<p><strong>WARNING:</strong> That was originally posted with a C++ tag. The template solution can not work with plain old C.</p>

<p>You can consider using a template this way:</p>

<pre><code>//Define a structure to store multistep sequences.
template&lt;int n&gt;
struct Command 
{
    // n = Number of steps in the seq
    int StepCount; //must be set to -1
    int Seq[n][NUMSERVOS + 1];
};
</code></pre>

<p>I'll assume you want this value to be useful just when you create the command since you're trying to use a static array. Then you'll be able to instantiate your structure this way:</p>

<pre><code>Command&lt;1&gt; Home = {-1, {90, 90, 90, 90, 90, 90, 1000}};
</code></pre>

<p>Now, if you still want to get Steps from there, you can still create a getter that way in your structure:</p>

<pre><code>int Steps() const
{
    return n;
}
</code></pre>

<p><strong>C solution</strong></p>

<p>Actually, if you compile your code just the way you gave it with a C99 or C11 compiler, it may work thanks to variable length arrays support. I can't ensure VLAs are accepted in structures though.</p>
",,14413372,1187
10947449,2,10868718,2012-06-08T10:51:08.310,0,,1081821,,2012-06-08T10:51:08.310,,0,,"<p>For serial communication use putty <br/>
it is a cross platform Serial and ssh client</p>

<p>for the left and right arrow commands:<br>
there are no ascii characters for arrow's: but there are utf-8; <br>
putty or an other client sends utf-8 characters for the basic ascii characters are utf-8 and ascii exactly the same;</p>

<p>and the arduino reads only ascii characters;</p>

<p>the arduino reads<br>
--> : 27, 91, 67<br>
&lt;-- : 27, 91, 68</p>

<p>so it is not that simple to read that.</p>

<p>you could use something like this</p>

<pre><code>int pos = 0;
Serial.flush(); // flush all received data
while(Serial.avaialble()&lt;3); // wait for the 3 ascii chars
if(Serial.read()==27){ // first char
  if(Serial.read()==91){ //second char
    switch (Serial.read()){
      case 67: // Right arrow
        myservo.write(++pos); // increment pos with 1 before write it
        break;
      case 68: // left arrow
        myservo.write(--pos); // derement pos with 1 before write it
        break;
      case 65: // up arrow
        myservo.write(++pos); // increment pos with 1 before write it
        break;
      case 66: // down arrow
        myservo.write(--pos); // decrement pos with 1 before write it
        break;
      case default:
        break;
    }
  }
}
</code></pre>

<p>but this is not a good solution
because of the arrow character is send in 3 bytes en when you flush it can flush the 27 so you read 91, 97, 27; and that is no valid so in doesn't work</p>

<p>you could write a algorithm to subtract the arrow command out of 5 ascii char's</p>

<p>or you can use 4 to move left and 6 to move right; which are ascii characters and in a numeric keypad are arrows drawn on those keys </p>
",,14416331,373
10903384,2,10903343,2012-06-05T19:10:03.170,6,,673730,,2012-06-05T19:10:03.170,,3,,"<p>Looks like you're looking for a combination of the <strong>Observer pattern</strong> combined with an <strong>Instance manager</strong> pattern.</p>

<p>Whenever you create a new instance of <code>Light</code>, add it to the manager. When you want the events to be triggered, iterate through the instances in the manager and call <code>update</code>.</p>

<p>Something like:</p>

<pre><code>class LightManager
{
    static std::vector&lt;Light&gt; lights;
    static void notify()
    {
       for ( size_t i = 0 ; i &lt; lights.size() ; i++ )
           lights[i].update();
    }
    static void add(const light&amp; l)
    {
       lights.push_back(l);
    }
};

class Light
{
    Light()
    {
       LightManager::add(*this);
    }
};
</code></pre>

<p>Then you update all lights with:</p>

<pre><code>LightManager::notify();
</code></pre>
",,14435589,320
11069389,2,11068450,2012-06-17T06:35:07.747,1,,1311325,,2012-06-17T06:35:07.747,,0,,"<p>I think you  want to do something like this to read in the data:</p>

<pre><code>String serialDataIn;
String data[3];
int counter;


int inbyte;

void setup(){
  Serial.begin(9600);
  counter = 0;
  serialDataIn = String("""");
}

void loop()
{
    if(serial.available){
        inbyte = Serial.read();
        if(inbyte &gt;= '0' &amp; inbyte &lt;= '9')
            serialDataIn += inbyte;
        if (inbyte == ','){  // Handle delimiter
            data[counter] = String(serialDataIn);
            serialDataIn = String("""");
            counter = counter + 1;
        }
        if(inbyte ==  '\r'){  // end of line
                handle end of line a do something with data
        }        
    }
}
</code></pre>

<p>Then use atoi() to convert the data to integers and use them.</p>
",,14442040,168
26822491,2,11068450,2014-11-08T21:53:17.180,1,,4231186,,2014-11-08T22:40:03.060,2014-11-08T22:40:03.060,0,,"<p>This is great! </p>

<p>The last comment about ""thirdvalue = 0"" is true from the code given in the most upvoted response by @dsnettleton. However, instead of using ""lastIndexOf(',');"" , the code should just add a ""+1"" to ""secondCommaIndex"" like @dsnettleton correctly did for commaIndex+1 (missing +1 is probably just a typo from the guy).  </p>

<p>Here is the updated piece of code</p>

<pre><code>int commaIndex = myString.indexOf(',');
int secondCommaIndex = myString.indexOf(',', commaIndex+1);
String firstValue = myString.substring(0, commaIndex);
String secondValue = myString.substring(commaIndex+1, secondCommaIndex);
String thirdValue = myString.substring(secondCommaIndex+1); //To the end of the string  
</code></pre>

<p>Example)</p>

<p>For a myString = ""1,2,3""</p>

<ul>
<li>commaIndex = 1  (Searches from index 0, the spot taken by the character 1, to the location of the first comma)</li>
<li>secondCommaIndex = 3  (Searches from index 2, the spot taken by the character 2, to the location of the next comma)</li>
<li>firstValue reads from index 0-1 = ""1""</li>
<li>secondValue reads from index 2-3 = ""2""</li>
<li>thirdvalue reads from index 4-4(the last index spot of the string) = ""3""</li>
</ul>

<p>Note: Don't confuse INDEX with the LENGTH of the string. The length of the string is 5. Since the String indexOf counts starting from 0, the last index is 4.  </p>

<p>The reason why just</p>

<pre><code>String thirdValue = myString.substring(secondCommaIndex);
</code></pre>

<p>returns 0 when using .toInt() is because thirdValue = "",3"" and not ""3"" which screws up toInt(). </p>

<p>ps. sorry to write all the instructions out but as a mech eng, even I sometimes would like someone to dumb down code for me especially having been in consulting for the past 7 years. Keep up the awesome posting! Helps people like me out a lot!</p>
",,14464713,2982
26878594,2,11068450,2014-11-12T03:10:00.793,2,,4151777,,2014-11-12T03:10:00.793,,0,,"<p>Simplest, I think, is using <code>parseInt()</code> to do this task:</p>

<pre><code>void loop(){
    if (Serial.available() &gt; 0){
        int r = Serial.parseInt();
        int g = Serial.parseInt();
        int b = Serial.parseInt();
    }
}
</code></pre>

<p>does the trick.</p>
",,14467568,11437
35168657,2,11068450,2016-02-03T04:41:27.120,9,,5871187,,2016-02-03T04:41:27.120,2017-05-23T11:54:10.047,1,,"<p>Use <code>sscanf</code>;</p>

<pre><code>const char *str = ""1,20,100""; // assume this string is result read from serial
int r, g, b;

if (sscanf(str, ""%d,%d,%d"", &amp;r, &amp;g, &amp;b) == 3) {
    // do something with r, g, b
}
</code></pre>

<p>Use my code here if you want to parse a stream of string ex: <code>255,255,255 0,0,0 1,20,100 90,200,3</code><a href=""https://stackoverflow.com/questions/35150262/parsing-function-for-comma-delimited-string/35153813#35153813"">Parsing function for comma-delimited string</a></p>
",,14529496,109
37315127,2,11068450,2016-05-19T06:09:13.700,-3,,6354483,,2016-05-19T06:14:53.217,2016-05-19T06:14:53.217,1,,"<pre><code>    String myString = ""dfsdfgsafhffgsdvbsdvdsvsdvsdsdfdfsdsff|date|recipt|weight|time|date|"";

    // the setup routine runs once when you press reset:
    void setup() {                
        Serial.begin(9600); 
    }


// the loop routine runs over and over again forever:
void loop() {
 int Index1 = myString.indexOf('|');
int Index2 = myString.indexOf('|', Index1+1);
int Index3 = myString.indexOf('|', Index2+1);
int Index4 = myString.indexOf('|', Index3+1);
int Index5 = myString.indexOf('|', Index4+1);
int Index6 = myString.indexOf('|', Index5+1);
String secondValue = myString.substring(Index1+1, Index2);
String thirdValue = myString.substring(Index2+1, Index3);  
String fourthValue = myString.substring(Index3+1, Index4); 
String fifthValue = myString.substring(Index4+1, Index5); 
String firstValue = myString.substring(Index5+1, Index6); 
//Serial.println(Index1);
//
Serial.println(secondValue);
Serial.println(thirdValue);
Serial.println(fourthValue);
Serial.println(fifthValue);
Serial.println(firstValue);
delay(14000);
    }
</code></pre>
",,14546947,1569
57215072,2,11068450,2019-07-26T07:25:51.637,0,,4384853,,2019-07-26T07:25:51.637,,0,,"<p>For n number delimited in string</p>

<pre><code>int end;
while((end=str.indexOf("",""))!=-1){
  String num = str.substring(0,end);
  str= asc.substring(end+1,str.length());
  Serial.println(num);  
}
</code></pre>
",,14564714,1907
11239701,2,11213536,2012-06-28T07:13:53.163,9,,566149,,2012-06-28T07:13:53.163,,3,,"<p>Spent a good 8 hours having the exact same problem. Seems like the Max3421e.cpp is faulty. Try replacing:</p>

<pre><code>boolean MAX3421E::reset()
{
  byte tmp = 0;
    regWr( rUSBCTL, bmCHIPRES );                        //Chip reset. This stops the oscillator
    regWr( rUSBCTL, 0x00 );                             //Remove the reset
    while(!(regRd( rUSBIRQ ) &amp; bmOSCOKIRQ )) {          //wait until the PLL is stable
        tmp++;                                          //timeout after 256 attempts
        if( tmp == 0 ) {
            return( false );
        }
    }
    return( true );
}
</code></pre>

<p>with</p>

<pre><code>boolean MAX3421E::reset()
{
    regWr( rUSBCTL, bmCHIPRES );                        //Chip reset. This stops the   oscillator
    regWr( rUSBCTL, 0x00 );                             //Remove the reset
    while(!(regRd(rUSBIRQ) &amp; bmOSCOKIRQ)) ;
}
</code></pre>

<p>In Max3421e.cpp located in the USB_Host_Shield library (in your Arduino IDE library folder).
Basically the change does not allow an exit until the PLL is really stabilized.</p>

<p>Worked for me at least, good luck
(Original hints and more about the fix here: <a href=""http://arduino.cc/forum/index.php?topic=68205.0"" rel=""noreferrer"">http://arduino.cc/forum/index.php?topic=68205.0</a>)</p>
",,14664511,3806
12739264,2,11213536,2012-10-05T03:57:35.527,1,,507120,,2012-10-05T03:57:35.527,,0,,"<p>Super simple for me (with the same issue), just add a delay before <code>acc.powerOn()</code></p>

<p>the example I saw added 100, but I decided boot up is fast enough for 500. i.e.</p>

<pre><code>void setup()
{
  // set communiation speed
  Serial.begin(9600);
  pinMode(LED_PIN, OUTPUT);
  delay(500);
  acc.powerOn();
}
</code></pre>
",,14676730,10524
11295756,2,11295728,2012-07-02T14:33:35.440,5,,554028,,2012-11-04T09:33:54.910,2012-11-04T09:33:54.910,11,,"<pre><code>byte b[4];  // Contains bytes
int x= 0;

x= (x &lt;&lt; 8) + b[3];
x= (x &lt;&lt; 8) + b[2];
x= (x &lt;&lt; 8) + b[1];
x= (x &lt;&lt; 8) + b[0];
</code></pre>

<p>I quickly wrote a sample. It's not tested, though.</p>

<pre><code>unsigned char b[35];

int sizeOfB = sizeof b / sizeof(unsigned char);

int sizeOfL = sizeOfB / 4;
if(sizeOfB % 4 != 0) ++sizeOfL;
    int lcount=0;

long* l = new long[sizeOfL];

for(int i = 0; i &lt; sizeOfB; i+=4){
    long currentLong = 0;

    if(i + 3 &lt; sizeOfB)
        currentLong = (currentLong &lt;&lt; 8) + b[i+3];
    if(i + 2 &lt; sizeOfB)
        currentLong = (currentLong &lt;&lt; 8) + b[i+2];
    if(i + 1 &lt; sizeOfB)
        currentLong = (currentLong &lt;&lt; 8) + b[i+1];

    currentLong = (currentLong &lt;&lt; 8) + b[i+0];

    l[lcount]=currentlong;
    lcount++;
}

// Use l...
delete l;
</code></pre>
",,14881145,1300
11376205,2,11375884,2012-07-07T15:22:17.113,1,,1229893,,2012-07-07T15:22:17.113,,2,,"<p>When reading a file in C, your position in the file changes as you read it. For example, if you were to open a file with the contents:</p>

<pre><code>First Line
Second Line
Third Line
</code></pre>

<p>and run this program:</p>

<pre><code>char buffer[1024];
while(fgets(buffer, sizeof(buffer), theFile))
{
    printf(""Buffer: %s"", buffer);
}
</code></pre>

<p>It would print: </p>

<pre><code>First Line
Second Line
Third Line
</code></pre>

<p>As you read each line, the position in the file changes to the next line. </p>

<p>In your program, after reading the value the first time, you are trying to read the empty space in the file, instead of the value you want. </p>

<p>The solution to your problem is to move <code>fopen</code> outside of the while loop, but call <code>fseek</code> to reset your position to the start of the file each time through the loop.  </p>

<p>To use <code>fseek</code>, you need to pass it a file pointer, byte offset and seek point. Here you call it on your file, with a 0 byte offset from the waypoint SEEK_SET, which indicates the start of the file. </p>

<pre><code>fseek(theFile, 0, SEEK_SET); 
</code></pre>
",,14883128,10060
11387696,2,11385915,2012-07-08T23:58:44.723,0,,1229893,,2012-07-08T23:58:44.723,,1,,"<p>I have not found that method to be too reliable for opening serial ports on the mac. I would suggest using ioctl, as it is much more robust and offers many advantages, mainly the use of any arbitrary baud rate. </p>

<pre><code>#import &lt;IOKit/serial/ioss.h&gt;
#import &lt;sys/ioctl.h&gt;

- (int)serialInit:(const char*)path baud:(int)baud;
{
    struct termios options;

    // open the serial like POSIX C
    int serialFileDescriptor = open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);

    // block non-root users from using this port
    ioctl(serialFileDescriptor, TIOCEXCL);

    // clear the O_NONBLOCK flag, so that read() will
    //   block and wait for data.
    fcntl(serialFileDescriptor, F_SETFL, 0);

    // grab the options for the serial port
    tcgetattr(serialFileDescriptor, &amp;options);

    // setting raw-mode allows the use of tcsetattr() and ioctl()
    cfmakeraw(&amp;options);

    // specify any arbitrary baud rate
    ioctl(serialFileDescriptor, IOSSIOSPEED, &amp;baud);

    return serialFileDescriptor;
}
</code></pre>
",,14886524,548
11396022,2,11385915,2012-07-09T13:28:36.813,3,,1510311,,2012-07-09T13:28:36.813,,2,,"<p>Well, I think I found it.</p>

<p>I was able to try an arduino Uno, and the result was the same. I then realised that for some obscure reason my arduino is reseting at <strong>each</strong> communication over the serial port, and not only at the first connection. As the result is the same under windows I guess it has something to do with my laptop (MBP 15"", early 2011, 10.7.4).</p>

<p>I then search a bit and found that there is actually a way to disable DTR (the signal that makes the board to reset) either with C or Python.</p>

<pre><code>import serial, time

#open the serial port
s = serial.Serial(port='/dev/tty.usbserial-A5006HGR', baudrate=9600)

#disable DTR
s.setDTR(level=False)

#wait for 2 seconds
time.sleep(2)

#send the data
s.write(""7"")
</code></pre>

<p>In C you need to to load the parameters from the serial port, disable DTR and then update the parameters, this is done using <code>ioctl</code> (from <a href=""http://www.easysw.com/~mike/serial/serial.html#5_1_2"" rel=""nofollow"">http://www.easysw.com/~mike/serial/serial.html#5_1_2</a>)</p>

<pre><code>//load status
int status;
ioctl(fd, TIOCMGET, &amp;status);

//disable DTR
status &amp;= ~TIOCM_DTR;

//update the status
ioctl(fd, TIOCMSET, &amp;status);
</code></pre>

<p>This can be placed in the code after the port has been opened. However the board will still reboot at the first connection, the first delay is then still necessary.</p>

<p>I hope this will help people in the same (unusual) situation.</p>
",,14894637,274
11410802,2,11410583,2012-07-10T09:56:51.337,6,,193903,,2012-07-10T09:56:51.337,,1,,"<p>You can do it like this</p>

<pre><code>for (int color = 0x000000; color &lt;= 0xFFFFFF; ++color)
</code></pre>

<p>But as it was mentioned in the comments, this will take a long time to display all the 16 million colors not to mention that the leds can be unable to display all these colors, so you will probably want something like this:</p>

<pre><code>const int step = 8; // Select this to be a power of two if you want the maximum brightness to be reachable
for( int red = 0x00; red &lt;= 0xFF; red += step ) {
    for( int green = 0x00; green &lt;= 0xFF; green += step ) {
        for( int blue = 0x00; blue &lt;= 0xFF; blue += step ) {
            const int color = blue &lt;&lt; 16 + green &lt;&lt; 8 + red;
            // Change the led settings here.
        }
    }
}  
</code></pre>
",,14903753,291
11411711,2,11410583,2012-07-10T10:49:43.860,4,,,user1312703,2012-07-10T13:21:04.073,2012-07-10T13:21:04.073,3,,"<p>I think you don't want to loop through All colors but through HUE channel in HSV(HSB) color model. If this is so, you may google for the implementation of the function that converts HSV value to RGB. And you code will look like this:</p>

<pre><code>for(int hue=0; hue&lt;360; hue++)
    setColorHSV(hue,1,1);
</code></pre>

<p>One of the possible implementations you can find <a href=""http://eduardofv.com/read_post/179-Arduino-RGB-LED-HSV-Color-Wheel-"" rel=""nofollow"">here</a>.</p>

<p>If you don't want to bother with this function you can use this dummy loops:</p>

<pre><code>unsigned int i;
for(i = 0; i &lt;= 0xFF; i++)
{
    rgb = 0xFF0000 | i&lt;&lt;8;  
    setLed(rgb);
}
while(--i &gt; 0)
{
    rgb = 0x00FF00 | i&lt;&lt;16; 
    setLed(rgb);
}
for(i = 0; i &lt;= 0xFF; i++)
{
    rgb = 0x00FF00 | i; 
    setLed(rgb);
}
while(--i &gt; 0)
{
    rgb = 0x0000FF | i&lt;&lt;8;  
    setLed(rgb);
}
for(i = 0; i &lt;= 0xFF; i++)
{
    rgb = 0x0000FF | i&lt;&lt;16; 
    setLed(rgb);
}
while(--i &gt; 0)
{
    rgb = 0xFF0000 | i;
    setLed(rgb);
}
</code></pre>

<p>Unfortunately, I can't test it, but I think it should work without problems. And of course you can optimize it as you want.</p>
",,14928473,2941
11422804,2,11422639,2012-07-10T22:11:16.870,5,,464709,,2013-09-07T09:45:04.037,2013-09-07T09:45:04.037,7,,"<p>The problem is that you're calling <code>open()</code> and <code>tcsetattr()</code> in sequence, then only check afterwards for an error condition with the file.</p>

<p>Consider <code>open()</code> fails for some reason. It will return <code>-1</code> and set <code>errno</code> to that reason. However, the code in your question proceeds into calling <code>tcsetattr()</code> nonetheless, which <em>will</em> fail since <code>serial_fd</code> will be <code>-1</code> in our case, and will overwrite <code>errno</code> with the reason why (<code>EBADF</code>, <code>-1</code> is not a valid file descriptor).</p>

<p>You should instead check for an error condition immediately after opening the file:</p>

<pre><code>serial_fd = open(""/dev/ttyUSB0"", O_RDWR);
if (serial_fd &lt; 0) {
    cout &lt;&lt; ""Error while opening device... "" &lt;&lt; ""errno = "" &lt;&lt; errno &lt;&lt; endl;
    perror(""Something went wrong with open()"");
    exit(1);
}
</code></pre>

<p>And only then, issue:</p>

<pre><code>tcsetattr(serial_fd, TCSANOW, &amp;tio);
</code></pre>
",,14982022,16314
11441715,2,11441660,2012-07-11T21:23:30.040,2,,164277,,2019-06-21T11:29:50.920,2019-06-21T11:29:50.920,10,,"<p>Remember where you were at the last iteration and compare to that to see if it has changed:</p>

<pre><code>int lastButton = 0;
...
void loop() {
    button = ...// Read button state
    ...
    if (button != lastButton) {
        ... // New keypress
        lastButton = button;
    }
}
</code></pre>

<p>Complete cleaned up code:</p>

<pre><code>enum ButtonState { Neutral=0, Left=1, Right=2, Up=3, Down=4 };

ButtonState lastButton = Neutral;

const int XPin = 4;
const int YPin = 5;

char* myStrings[]={""Neutral"", ""Left"",""Right"",""Up"",""Down""};

void setup() {
    Serial.begin(9600);
}

ButtonState readButtonState() {
    int xAxis=map(analogRead(XPin), 0, 1023, 0, 10);
    int yAxis=map(analogRead(YPin), 0, 1023, 0, 10);
    if (xAxis &lt; 4 ) return Left;
    if (xAxis &gt; 6 ) return Right;
    if (yAxis &lt; 4 ) return Down;
    if (yAxis &gt; 6 ) return Up;
    return Neutral;
}

void loop() {
    ButtonState button = readButtonState();
    if (button != lastButton) {
        Serial.println(myStrings[button]);
        lastButton = button;
    }
    delay(50);
}
</code></pre>
",,15017061,746
11442108,2,11441660,2012-07-11T21:57:17.073,0,,944687,,2012-07-11T21:57:17.073,,3,,"<p>It should be more like this:</p>

<pre><code>const int Left = 1;
const int Right = 2;
const int Up = 3;
const int Down = 4;

int xpin = 4;
int ypin = 5;

int xAxis;
int yAxis;
char* myStrings[]={""Left"",""Right"",""Up"",""Down""};
int button;


void setup() {
  Serial.begin(9600);
}
int lastButton = -1; // init lastButton to a never occurring value

void loop() {

   xAxis=map(analogRead(xpin), 0, 1023, 0, 10);
   yAxis=map(analogRead(ypin), 0, 1023, 0, 10);

   if (xAxis &lt; 4 ) { 
     button = Left; 
   }
   else if (xAxis &gt; 6 ) { 
     button = Right; 
   }

   if (yAxis &lt; 4 ) { 
     button = Down; 
   }
   else if (yAxis &gt; 6 ) { 
     button = Up;
   }

   if (button == lastButton){
       //Serial.println(0);
       //button = 0;
       delay(50); // wait more
   }else{
       lastButton = button;
       Serial.println(myStrings[button-1]);
       button = 0;
       delay(50);
   }
 }
</code></pre>
",,15049257,4103
11495241,2,11494827,2012-07-15T20:12:07.947,5,,166955,,2012-07-15T20:12:07.947,,1,,"<p>You should not make these variables static. A static global variable means the variable is local to the compilation unit (generally, the <code>.cpp</code> file that is being compiled) so if you have the static variable declared in a header file and include that header file in 3 different <code>.cpp</code> files that are compiled separately then you will have 3 independent versions of that variable, one for each <code>.cpp</code> file.</p>

<p>Instead, in the header file declare them as</p>

<pre><code>namespace Motor {
  extern unsigned char left_speed;
  extern unsigned char right_speed;

  void ChangeSpeed(unsigned char, unsigned char);
}
</code></pre>

<p>This tells the compiler that some file will provide a definition for these variables and to use that common shared definition.</p>

<p>Then, since the variables need to be defined exactly once (this is called the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""noreferrer"">one definition rule</a>) you should add the definition to <code>Motor.cpp</code>:</p>

<pre><code>unsigned char Motor::left_speed = 0;
unsigned char Motor::right_speed = 0;
</code></pre>

<p>I chose <code>Motor.cpp</code> to hold the definition since this is where the definition of the <code>ChangeSpeed</code> function is.</p>

<p>In C++, the <code>static</code> keyword works much differently than in C#. It might be somewhat similar when used inside a class definition, but that is where the similarities end.</p>
",,15051724,98
11517424,2,11517306,2012-07-17T06:57:31.313,2,,134633,,2012-07-17T06:57:31.313,,5,,"<p>The physical memory address <code>0x20200000</code> is being mapped into your process address space at an address stored in the variable <code>gpio</code>, so that's the address you should be examining in <code>gdb</code>.  Just print the contents of <code>gpio</code> after <code>gpio_init()</code> has been called and use that value.</p>

<p>As an aside the way the mapping is done is confused.  There is no need to allocate a memory block with <code>malloc</code> and then map over it, and it also fails to close the file descriptor.  That entire function could be better written as:</p>

<pre><code>int gpio_init (void)
{
  int      fd ;

  if ((fd = open (""/dev/mem"", O_RDWR) ) &lt; 0)
  {
    fprintf (stderr, ""gpio_init: unable to open /dev/mem: %s\n"", strerror (errno)) ;
    return -1 ;
  }

  gpio = mmap(NULL, BLOCK_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_BASE) ;

  if (gpio == MAP_FAILED)
  {
    fprintf (stderr, ""gpio_init: mmap failed: %s\n"", strerror (errno)) ;
    close(fd);
    return -1 ;
  }

  close(fd);
  return 0 ;
}
</code></pre>
",,15113128,6497
11561414,2,11559829,2012-07-19T12:59:11.713,1,,583044,,2012-07-19T12:59:11.713,,3,,"<p>There are at least two things to watch out for here, but this is based on my experience of languages other than Java so it might not behave in exactly the same way.</p>

<p>The first is that the event looks like it is being fired after a small number of characters, perhaps your Arduino does not send fast enough for it to all appear at once. This causes your Java code to repeat the output because you are printing <code>display</code> and then appending the new <code>chunk</code> to it. If you do not find an exclamation mark it never gets cleared out. You might be better off printing <code>chunk</code> to see exactly what you have received.</p>

<p>The second is that you might only receive events for new data, so if new data comes in between the event getting fired and you calling <code>input.read()</code> then another event is not fired. You are best to have a loop in your event handler that continues while there is still data available, e.g.:</p>

<pre><code>public synchronized void serialEvent(SerialPortEvent oEvent) {
    if (oEvent.getEventType() == SerialPortEvent.DATA_AVAILABLE) {
        try {
            int available = input.available();
            while (available &gt; 0)
            {
                byte chunk[] = new byte[available];
                input.read(chunk, 0, available);

                System.out.println(new String(chunk));

                // Perform your packet processing here

                // See if there is any more data that came in while we were
                // processing the event
                available = input.available();
            }

        } catch (Exception e) {
            System.err.println(e.toString());
        }
    }
    // Ignore all the other eventTypes, but you should consider the other ones.
}
</code></pre>
",,15126129,151
11645638,2,11610264,2012-07-25T08:30:15.197,19,,918935,,2012-07-25T08:30:15.197,,1,,"<p>Thanks for your help.  The solution was </p>

<pre><code>    char __dataFileName[sizeof(dataFileName)];
    dataFileName.toCharArray(__dataFileName, sizeof(__dataFileName));

    pinMode(SD_PIN,OUTPUT);
    dataFile = SD.open(__dataFileName,FILE_WRITE);
</code></pre>
",,15175358,2144
13714931,2,11677639,2012-12-05T01:28:58.483,3,,276193,,2012-12-05T01:28:58.483,,1,,"<p>I found a nice example by Jeff Gray of how to make a simple minicom type client using <code>boost::asio</code>. The original <a href=""http://boost.2283326.n4.nabble.com/Simple-serial-port-demonstration-with-boost-asio-asynchronous-I-O-td2582657.html"" rel=""nofollow"">code listing can be found on the boost user group</a>. This allows connection and communication with the Arduino like in the GNU Screen example mentioned in the original post.</p>

<p>The code example (below) needs to be linked with the following linker flags</p>

<blockquote>
  <p>-lboost_system-mt -lboost_thread-mt</p>
</blockquote>

<p>...but with a bit of tweaking, some of the dependence on boost can be replaced with new C++11 standard features. I'll post revised versions as and when I get around to it. For now, this compiles and is a solid basis.</p>

<pre><code>/* minicom.cpp 
        A simple demonstration minicom client with Boost asio 

        Parameters: 
                baud rate 
                serial port (eg /dev/ttyS0 or COM1) 

        To end the application, send Ctrl-C on standard input 
*/ 

#include &lt;deque&gt; 
#include &lt;iostream&gt; 
#include &lt;boost/bind.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/asio/serial_port.hpp&gt; 
#include &lt;boost/thread.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/date_time/posix_time/posix_time_types.hpp&gt; 

#ifdef POSIX 
#include &lt;termios.h&gt; 
#endif 

using namespace std; 

class minicom_client 
{ 
public: 
        minicom_client(boost::asio::io_service&amp; io_service, unsigned int baud, const string&amp; device) 
                : active_(true), 
                  io_service_(io_service), 
                  serialPort(io_service, device) 
        { 
                if (!serialPort.is_open()) 
                { 
                        cerr &lt;&lt; ""Failed to open serial port\n""; 
                        return; 
                } 
                boost::asio::serial_port_base::baud_rate baud_option(baud); 
                serialPort.set_option(baud_option); // set the baud rate after the port has been opened 
                read_start(); 
        } 

        void write(const char msg) // pass the write data to the do_write function via the io service in the other thread 
        { 
                io_service_.post(boost::bind(&amp;minicom_client::do_write, this, msg)); 
        } 

        void close() // call the do_close function via the io service in the other thread 
        { 
                io_service_.post(boost::bind(&amp;minicom_client::do_close, this, boost::system::error_code())); 
        } 

        bool active() // return true if the socket is still active 
        { 
                return active_; 
        } 

private: 

        static const int max_read_length = 512; // maximum amount of data to read in one operation 

        void read_start(void) 
        { // Start an asynchronous read and call read_complete when it completes or fails 
                serialPort.async_read_some(boost::asio::buffer(read_msg_, max_read_length), 
                        boost::bind(&amp;minicom_client::read_complete, 
                                this, 
                                boost::asio::placeholders::error, 
                                boost::asio::placeholders::bytes_transferred)); 
        } 

        void read_complete(const boost::system::error_code&amp; error, size_t bytes_transferred) 
        { // the asynchronous read operation has now completed or failed and returned an error 
                if (!error) 
                { // read completed, so process the data 
                        cout.write(read_msg_, bytes_transferred); // echo to standard output 
                        read_start(); // start waiting for another asynchronous read again 
                } 
                else 
                        do_close(error); 
        } 

        void do_write(const char msg) 
        { // callback to handle write call from outside this class 
                bool write_in_progress = !write_msgs_.empty(); // is there anything currently being written? 
                write_msgs_.push_back(msg); // store in write buffer 
                if (!write_in_progress) // if nothing is currently being written, then start 
                        write_start(); 
        } 

        void write_start(void) 
        { // Start an asynchronous write and call write_complete when it completes or fails 
                boost::asio::async_write(serialPort, 
                        boost::asio::buffer(&amp;write_msgs_.front(), 1), 
                        boost::bind(&amp;minicom_client::write_complete, 
                                this, 
                                boost::asio::placeholders::error)); 
        } 

        void write_complete(const boost::system::error_code&amp; error) 
        { // the asynchronous read operation has now completed or failed and returned an error 
                if (!error) 
                { // write completed, so send next write data 
                        write_msgs_.pop_front(); // remove the completed data 
                        if (!write_msgs_.empty()) // if there is anthing left to be written 
                                write_start(); // then start sending the next item in the buffer 
                } 
                else 
                        do_close(error); 
        } 

        void do_close(const boost::system::error_code&amp; error) 
        { // something has gone wrong, so close the socket &amp; make this object inactive 
                if (error == boost::asio::error::operation_aborted) // if this call is the result of a timer cancel() 
                        return; // ignore it because the connection cancelled the timer 
                if (error) 
                        cerr &lt;&lt; ""Error: "" &lt;&lt; error.message() &lt;&lt; endl; // show the error message 
                else 
                        cout &lt;&lt; ""Error: Connection did not succeed.\n""; 
                cout &lt;&lt; ""Press Enter to exit\n""; 
                serialPort.close(); 
                active_ = false; 
        } 

private: 
        bool active_; // remains true while this object is still operating 
        boost::asio::io_service&amp; io_service_; // the main IO service that runs this connection 
        boost::asio::serial_port serialPort; // the serial port this instance is connected to 
        char read_msg_[max_read_length]; // data read from the socket 
        deque&lt;char&gt; write_msgs_; // buffered write data 
}; 

int main(int argc, char* argv[]) 
{ 
// on Unix POSIX based systems, turn off line buffering of input, so cin.get() returns after every keypress 
// On other systems, you'll need to look for an equivalent 
#ifdef POSIX 
        termios stored_settings; 
        tcgetattr(0, &amp;stored_settings); 
        termios new_settings = stored_settings; 
        new_settings.c_lflag &amp;= (~ICANON); 
        new_settings.c_lflag &amp;= (~ISIG); // don't automatically handle control-C 
        tcsetattr(0, TCSANOW, &amp;new_settings); 
#endif 
        try 
        { 
                if (argc != 3) 
                { 
                        cerr &lt;&lt; ""Usage: minicom &lt;baud&gt; &lt;device&gt;\n""; 
                        return 1; 
                } 
                boost::asio::io_service io_service; 
                // define an instance of the main class of this program 
                minicom_client c(io_service, boost::lexical_cast&lt;unsigned int&gt;(argv[1]), argv[2]); 
                // run the IO service as a separate thread, so the main thread can block on standard input 
                boost::thread t(boost::bind(&amp;boost::asio::io_service::run, &amp;io_service)); 
                while (c.active()) // check the internal state of the connection to make sure it's still running 
                { 
                        char ch; 
                        cin.get(ch); // blocking wait for standard input 
                        if (ch == 3) // ctrl-C to end program 
                                break; 
                        c.write(ch); 
                } 
                c.close(); // close the minicom client connection 
                t.join(); // wait for the IO service thread to close 
        } 
        catch (exception&amp; e) 
        { 
                cerr &lt;&lt; ""Exception: "" &lt;&lt; e.what() &lt;&lt; ""\n""; 
        } 
#ifdef POSIX // restore default buffering of standard input 
        tcsetattr(0, TCSANOW, &amp;stored_settings); 
#endif 
        return 0; 
}
</code></pre>
",,15182491,711
11690707,2,11690647,2012-07-27T15:13:52.130,2,,215752,,2014-07-02T00:55:49.280,2014-07-02T00:55:49.280,6,,"<p>Ok, I read that code -- if you don't call close() for <strong>every</strong> case of an open you will have a leak -- there is only one file object (why I don't know).</p>

<p>Here is the interesting code:</p>

<pre><code>void File::close() {
  if (_file) {
    _file-&gt;close();
    free(_file); 
    _file = 0;

    /* for debugging file open/close leaks
    nfilecount--;
    Serial.print(""Deleted "");
    Serial.println(nfilecount, DEC);
    */
  }
}
</code></pre>

<p>They seem to have some nice code for finding leak right there... maybe you should try it.</p>

<p>Also just go and change the code at the end to look like this:</p>

<pre><code>        dataFile = SD.open(""datalog.txt"", FILE_WRITE);
        // if the file is available, write to it:
        if (SD.open(""datalog.txt"", FILE_WRITE)) 
        {
              dataFile.println(dataString);
              // print to the serial port too:
              Serial.println(""data logged to SD"");
        }
        // if the file isn't open, pop up an error:
        else
        {
              Serial.println(""File Error datalog.txt"");
        } 
        dataFile.close(); // always close after an open.
</code></pre>

<hr>

<p>Well you don't show us the code for the SD object so it is a mystery but I expect you need to call dispose on something... maybe dataFile?</p>
",,15183530,3607
11846374,2,11846288,2012-08-07T12:47:09.060,2,,182971,,2012-08-07T13:09:29.813,2012-08-07T13:09:29.813,2,,"<p>You can tokenize (split) the string on the comma using <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow"">strtok</a>, and then parse the numbers using <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow"">sscanf</a>.</p>

<p>Edit: C example:</p>

<pre><code>void main() {
    char * input = ""$ÇÐÇÇÁ,175341.458,3355.7870,Ó,01852.4251,Å,1,03,5.5,-32.8,Í,32.8,Í,,0000*57"";

    char * garbage = strtok(input, "","");
    char * firstNumber = strtok(NULL, "","");
    char * secondNumber = strtok(NULL, "","");
    double firstDouble;
    sscanf(firstNumber, ""%lf"", &amp;firstDouble);
    printf(""%f\n"", firstDouble);
}
</code></pre>
",,15183606,2981
11846796,2,11846288,2012-08-07T13:10:56.050,0,,1560833,,2012-08-07T13:10:56.050,,0,,"<p>If you have strange characters at the beginning of the string, then you should start parsing it from the end:</p>

<pre><code>char* input = get_input_from_gps();
// lets assume you dont need any error checking
int comma_pos = input.strrchr(',');
char* token_to_the_right = input + comma_pos;
input[comma_pos] = '\0';
// next strrchr will check from the end of the part to the left of extracted token
// next token will be delimited by \0, so you can safely run sscanf on it 
// to extract actual number
</code></pre>
",,15191768,2384
13604603,2,11856409,2012-11-28T12:01:19.307,0,,1853881,,2012-11-28T12:01:19.307,,0,,"<p>You havent indicated whether you are trying to scroll horizontally or vertically.  </p>

<p>Horizontal scrolling is native in the lcd library.  Use autoscroll or scrollDisplayLeft/Right</p>

<pre><code>// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

void setup() {
  // set up the LCD's number of columns and rows: 
  lcd.begin(16,2);
 }

void loop() {

// set the cursor to (16,1):
lcd.setCursor(16,1);
// set the display to automatically scroll:
lcd.autoscroll();
// print from 0 to 9:
for (int thisChar = 0; thisChar &lt; 10; thisChar++) {
 lcd.print(thisChar);
 delay(500);
}
// turn off automatic scrolling
lcd.noAutoscroll();

// clear screen for the next loop:
lcd.clear();
}
</code></pre>

<p>For vertical scrolling, you'll need to manually create an action to copy the text from line 2 to line 1 and populate line 2 with the new text.</p>
",,15304383,7290
11871268,2,11871126,2012-08-08T18:56:01.317,0,,440558,,2012-08-08T18:56:01.317,,2,,"<p>Short answer: Yes.</p>

<p>Instead of having a pointer you should use the structure directly:</p>

<pre><code>typedef struct s_PIN {
  char *name;
  uint8_t gpio;
  char *mux;
  uint8_t eeprom;
  PWM pwm;  /* Notice: not a pointer */
} PIN;
</code></pre>

<p>Also, you don't need to do the casting:</p>

<pre><code>#define P8_19 {""EHRPWM2A"", 22, ""gpmc_ad8"", 14, {4, ""EHRPWM2A"", ""ehrpwm.2:0""}}
</code></pre>
",,15315391,1775
11897237,2,11871126,2012-08-10T07:29:30.937,0,,961353,,2012-08-10T07:29:30.937,,2,,"<p>I would tackle this problem slightly differently; I would define the pin names in their own module, as follows.</p>

<p><code>gpio.h</code>:</p>

<pre><code>typedef struct s_PWM {
  uint8_t muxmode;
  char *name;
  char *path;
} PWM;

typedef struct s_PIN {
  char *name;
  uint8_t gpio;
  char *mux;
  uint8_t eeprom;
  PWM *pwm;
} PIN;

...
extern PIN * P8_19;
</code></pre>

<p><code>gpio.c</code>:</p>

<pre><code>PWM _P8_19_PWM = {4, ""EHRPWM2A"", ""ehrpwm.2:0""};
PIN _P8_19     = {""EHRPWM2A"", 22, ""gpmc_ad8"", 14, &amp;_P8_19_PWM};
PIN *P8_19     = &amp;_P8_19;
</code></pre>

<p>Then you can reference it in another file by including <code>gpio.h</code> and using P8_19 normally.</p>
",,15329824,925
11916093,2,11915914,2012-08-11T15:54:41.007,-1,,1587554,,2012-08-11T15:54:41.007,,0,,"<p>seems to work, could be buggy:</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(){
char string[]=""20,2000,5"";
int a,b,c;
sscanf(string,""%i,%i,%i"",&amp;a,&amp;b,&amp;c);
printf(""%i %i %i\n"",a,b,c);
a=b=c=0;
a=atoi(strtok(string,"",""));
b=atoi(strtok(0,"",""));
c=atoi(strtok(0,"",""));
printf(""%i %i %i\n"",a,b,c);

return 0;
}
</code></pre>
",,15353092,5176
11916125,2,11915914,2012-08-11T15:58:47.833,7,,275567,,2012-08-11T16:04:13.023,2012-08-11T16:04:13.023,1,,"<p>Since you're using the Arduino core <code>String</code> type, <code>strtok</code> and other <code>string.h</code> functions aren't appropriate. Note that you <strong>can</strong> change your code to use standard C null-terminated strings instead, but using Arduino <code>String</code> will let you do this without using pointers.</p>

<p>The <a href=""http://arduino.cc/en/Reference/StringObject"" rel=""noreferrer""><code>String</code></a> type gives you <a href=""http://arduino.cc/en/Reference/StringIndexOf"" rel=""noreferrer""><code>indexOf</code></a> and <a href=""http://arduino.cc/en/Reference/StringSubstring"" rel=""noreferrer""><code>substring</code></a>.</p>

<p>Assuming a String with the <code>@</code> and <code>!</code> stripped off, finding your command and arguments would look something like this:</p>

<pre><code>// given: String command
int data[MAX_ARGS];
int numArgs = 0;

int beginIdx = 0;
int idx = command.indexOf("","");

String arg;
char charBuffer[16];

while (idx != -1)
{
    arg = command.substring(beginIdx, idx);
    arg.toCharArray(charBuffer, 16);

    // add error handling for atoi:
    data[numArgs++] = atoi(charBuffer);
    beginIdx = idx + 1;
    idx = command.indexOf("","", beginIdx);
}

data[numArgs++] = command.substring(beginIdx);
</code></pre>

<p>This will give you your entire command in the <code>data</code> array, including the command number at <code>data[0]</code>, while you've specified that only the args should be in <code>data</code>. But the necessary changes are minor.</p>
",,15353140,2061
12012496,2,12012277,2012-08-17T20:04:24.290,0,,567292,,2012-08-17T20:04:24.290,,0,,"<p>Clearly the problem is that <code>WiFlyClient</code> is not assignable.  Consider containing it in a <code>std::unique_ptr</code> (in C++03, <code>std::auto_ptr</code>) so that you can at least assign items of that type.</p>

<pre><code>std::unique_ptr&lt;WiFlyClient&gt; m_client;

...

m_client = m_server.available();

...

// convert m_client.&lt;...&gt; to m_client-&gt;&lt;...&gt;

// change m_server.available() to return std::unique_ptr&lt;WiFlyClient&gt;
</code></pre>
",,15387028,16985
12012695,2,12012277,2012-08-17T20:23:07.603,5,,315052,,2012-08-17T20:23:07.603,,1,,"<p>The <code>WiFly</code> member of your <code>WiFlyClient</code> is making the class not assignable. The reason for that is that assignment cannot be used to change which object the reference is referring to. For example:</p>

<pre><code>int a = 1;
int b = 2;
int &amp;ar = a;
int &amp;br = b;
ar = br; // changes a's value to 2, does not change ar to reference b
</code></pre>

<p>Since all your <code>WiFlyClient</code>s are referencing the same <code>WiFlyDevice</code> instance, you can change <code>WiFlyClient</code> as the compiler suggests to use a static member:</p>

<pre><code>// WiFlyClient.h
class WiFlyClient : public Client {
 public:
  WiFlyClient();
  ...
private:
  static WiFlyDevice&amp; _WiFly;
  ...
};
</code></pre>

<p>Then, you do not initialize it in the constructor, but in a source file where you define it.</p>

<pre><code>WiFlyDevice &amp; WiFlyClient::_WiFly = WiFly;
</code></pre>
",,15393907,4557
12012727,2,12012277,2012-08-17T20:26:16.550,0,,355034,,2012-11-15T08:51:52.440,2012-11-15T08:51:52.440,1,,"<p>Try overriding <code>operator=</code>:</p>

<pre><code>WiFlyClient&amp; operator= (const WiFlyClient &amp; wi)
{
  /* make a copy here */ 
  return *this;
}
</code></pre>
",,15415839,33506
12076338,2,12076240,2012-08-22T15:19:06.713,0,,1428679,,2012-08-22T15:49:55.070,2012-08-22T15:49:55.070,2,,"<p>What you want to do can (almost) be accomplished by replacing</p>

<pre><code>Serial.print(printByte);
for(int i=0; i&lt;=sizeof(printByte);i++){
   printByte[i]=0;
}
</code></pre>

<p>with</p>

<pre><code>Serial.print(printByte);

for(int i=0; i&lt;=sizeof(printByte);i++){
   if (0 == printByte[i])
       break;
   printf(""%02x"", printByte[i]);
}
printf(""\n""); // Newline after output

if (0 == strpos(printByte, ""QUIT""))
{
    // The cycle ends.
}

for(int i=0; i&lt;=sizeof(printByte);i++){
   printByte[i]=0;
}
</code></pre>

<p><strong>UPDATE</strong>: The Serial.print() command is the one outputting 0xFF...: I had not understood that you wanted to modify the output <em>Arduino side</em>. That, I do not know how to implement, would require modifying the sources of the <code>Serial</code> package. There will be a ""0x%02x"" or ""0x02X"" in there somewhere from which the 0x has to be removed.</p>

<p>Regarding the end of a sequence of reads, you might output a double \n. Then, if the read byte is \n <em>and</em> pos is 0, this will mean that the Arduino has written an empty line and the sequence has stopped.</p>

<p>Or you might use almost any sequence as a terminator: in the code above I've added a check for the string ""QUIT"".</p>
",,15468219,505
12104494,2,12104470,2012-08-24T06:53:34.677,1,,637669,,2012-08-24T07:32:05.640,2012-08-24T07:32:05.640,4,,"<p>It seems you are compiling this code as C.</p>

<p>Instead of</p>

<pre><code>struct track_t {
  char code[4];
  gpsCoord_t bounds[4];
  gpsCoord_t points[4];
};
</code></pre>

<p>write</p>

<pre><code>typedef struct {
  char code[4];
  gpsCoord_t bounds[4];
  gpsCoord_t points[4];
} track_t;
</code></pre>
",,15523918,198
12127489,2,12127471,2012-08-26T03:55:07.860,5,,1053,,2012-08-26T03:57:51.307,2012-08-26T03:57:51.307,8,,"<p><code>p</code> is a pointer, not a struct, so it works like pointer arithmetic does on any type.  The pointer's value is an address.  So when, for example, you add <code>n</code> to a pointer, it's value changes and points to a new address <code>n * sizeof type</code> away. So...</p>

<pre><code>char *p = malloc(SOME_NUMBER * sizeof char);
p++;     // p = p + sizeof char
p += 4;  // p = p + sizeof char * 4
</code></pre>

<p>And if you have a struct...</p>

<pre><code>typedef struct {
    int a;
} foo;

/* ... */

foo *fp = malloc(SOME_NUMBER * sizeof foo);
fp++;    // fp = fp + sizeof foo;
fp += 4; // fp = fp + sizeof foo * 4;
</code></pre>
",,15580250,16274
12335043,2,12250759,2012-09-08T22:39:50.017,1,,1533961,,2012-09-09T13:08:24.527,2012-09-09T13:08:24.527,1,,"<p>The large code block is the code for the measure() function. Notice that it returns 0 at one point without performing a connReset(). This should be a way to detect a valid device such as ... </p>

<pre><code>bool hasHUMI;
if (hsensor2.measure(SHT21::HUMI))
{
  hasHUMI=true;
}
</code></pre>

<p>or</p>

<pre><code>if (hsensor2.measure(SHT21::HUMI) &amp;&amp; hsensor2.measure(SHT21::TEMP))
{
 hsensor2.calculate(h, t); 
 float hum2 = (h); 
 float temp2 = (t);    
}
</code></pre>

<p>or</p>

<p>Your code should be clearing h and t to 0 before making the read so that you can test for valid values. Like this...</p>

<pre><code>void loop() 
{ 
    h=0.00f;
    t=0.00f;
    // Get data from sensor soft I²C 
    hsensor2.measure(SHT21::HUMI); 
    hsensor2.measure(SHT21::TEMP); 
    hsensor2.calculate(h, t); 
    float hum2 = (h); 
    float temp2 = (t); 
    if (h&gt;0) {
    }
    if (t&gt;0) {
    }
} 
</code></pre>

<p>If not then you could make (copy) your own version of the <code>measure()</code> function that tests for valid return value in <code>meas[type]</code>. You would need to set <code>meas[type]</code> to a known invalid value before the read (such as <code>0</code>).</p>

<pre><code>uint8_t SHT21::measure(uint8_t type, void (*delayFun)()) {

    start();
    writeByte(type == TEMP? MEASURE_TEMP : MEASURE_HUMI)

    for (uint8_t i = 0; i &lt; 250; ++i) {
        if (!digiRead()) {
            meas[type] = readByte(1) &lt;&lt; 8;
            meas[type] |= readByte(1);
            uint8_t flipped = 0;

            for (uint8_t j = 0x80; j != 0; j &gt;&gt;= 1) {
                flipped &gt;&gt;= 1;
            }

            if (readByte(0) != flipped)
                break;

            return 0;
        }


        if (delayFun)
            delayFun();
        else
            delay(1);
    }

    connReset();
    return 1;
}
</code></pre>

<p>You probably know that if you add a method to a library cpp then you also need to add a corresponding prototype to the .h otherwise the arduino will fail to compile your code.</p>

<p>.cpp</p>

<pre><code>uint8_t SHT21::measureTest(uint8_t type, void (*delayFun)()) {

    }
</code></pre>

<p>.h</p>

<pre><code>uint8_t measureTest(uint8_t type, void (*delayFun)() =0);
</code></pre>
",,15599679,14283
12256116,2,12256004,2012-09-04T02:38:52.570,1,,777186,,2012-09-04T02:38:52.570,,1,,"<p>To be able to access functions from a user-defined library, best divide that library into a .h (or .hpp) and a .cpp file. I understand you have actually done this, but tried various options &ndash; among them the inclusion of the .cpp file &ndash; for the sake of finding a solution.</p>

<p>Still, to ensure things work as expected, the declarations of functions and classes should go into the .h file, best protected by something like</p>

<pre><code>#ifndef MY_H_FILE
#define MY_H_FILE

/* ..Declarations.. */

#endif
</code></pre>

<p>Then to include the .h file (I'll assume it's named <em>my.h</em>), either use</p>

<pre><code>#include ""my.h""    // path relative to build directory
</code></pre>

<p>or</p>

<pre><code>#include &lt;my.h&gt;    // path relative to any of the include paths
</code></pre>

<p>The latter only works if <em>my.h</em> is found on an <strong>include path</strong> previously known to the compiler (e.g. what is specified using the <code>-I</code> command line option in GCC). The former works if the path to the .h file given is <strong>relative to the directory</strong> your are building from.</p>

<p>Finally, do not use a file name that can be confused with a system library (such as ""math.h""), especially if you are using the <code>&lt;...&gt;</code> syntax, as the include path will definitely include the system library header files.</p>
",,15687784,1214
12328038,2,12328010,2012-09-08T04:33:48.517,1,,1578925,,2012-09-08T04:33:48.517,,0,,"<p>You should not use <code>pow()</code>. You can find information on <a href=""http://www.cplusplus.com/reference/clibrary/cmath/pow/"" rel=""nofollow""><code>pow()</code> at C++ Reference</a>.</p>

<p>However, essentially, there is no <code>pow()</code> signature for integers:</p>

<blockquote>
<pre><code>     double pow (      double base,      double exponent );
long double pow ( long double base, long double exponent );
      float pow (       float base,       float exponent );
     double pow (      double base,         int exponent );
long double pow ( long double base,         int exponent );
</code></pre>
</blockquote>

<p>That means that at run-time, it may not work, because it will round the result. It would need the floating point library (fully implemented in software on the AVR) - which is slow and takes up space.</p>

<p><code>PORTB = pow(2,0);</code> may work because it is a <code>constexpr</code>, so can be evaluated at compile time.</p>

<p>Instead, try use the left shift operator, eg:</p>

<pre><code>PORTB = 1 &lt;&lt; led;
</code></pre>
",,15709317,163
19641463,2,12328010,2013-10-28T17:39:28.013,0,,2036917,,2013-10-28T17:39:28.013,,0,,"<p>Your best approach would be to avoid pow completely. Instead of manipulation the ports go for the digitalWrite function.</p>

<pre><code>void setup() {
    for (uint8_t pin=0; pin&lt;20; ++pin) {
        pinMode(pin, OUTPUT);
    }
}

void blink(const uint8_t pos) {
    digitalWrite(pos, HIGH);
    delay(200);
    digitalWrite(pos, LOW);
}

void loop() {
    for (uint8_t pos=0; pos&lt;19; ++pos) {
        blink(pos);
    }
    for (uint8_t pos=19; pos&gt;0; --pos) {
        blink(pos);
    }
}
</code></pre>

<p>More sophisticated knight rider versions can be found in my blog <a href=""http://blog.blinkenlight.net/experiments/basic-effects/knight-rider/"" rel=""nofollow"">here</a> and <a href=""http://blog.blinkenlight.net/experiments/removing-flicker/knight-rider-no-flicker/"" rel=""nofollow"">here</a></p>
",,15734956,220
12337048,2,12336773,2012-09-09T06:33:31.587,1,,1519602,,2012-09-09T06:33:31.587,,0,,"<p>When declaring a static array, you must use a constant value, such as a literal or a constant variable.  You can use the <code>#define</code> keyword to assign a name to a literal, or declare and initialize a constant variable, if you simply want to make your code more readable and easier to manage:</p>

<pre><code>#define NUM_ARGS 5
/*...*/
byte arg_listB[NUM_ARGS];
</code></pre>

<p>However, in order to use an expression to set the size of an array, you will have to create a dynamic array using pointers.  How this is done depends on which language you are using.  In C, you could use the <code>calloc</code> function to create your array like so:</p>

<pre><code>#include &lt;stdlib.h&gt; //required for calloc
/*...*/
int num_args = 5;
byte* arg_listB = (byte*)calloc(2*num_args+10, sizeof(byte));
</code></pre>

<p>This will dynamically create a block of memory the size of your array and assign the address of the first byte to your pointer.  One thing to note is that <code>calloc</code> automatically initializes the elements in your array to 0, so that part is already done for you.  Of course, you will also want to remember to clean up the memory you allocated once you are done with your array like this:</p>

<pre><code>free(arg_listB);
</code></pre>

<p>Technically, you could use these functions in C++ if you include the <code>&lt;cstdlib&gt;</code> header.  However, C++ has its own special keywords for dynamic memory allocation:  <code>new</code> and <code>delete</code>.  These can be used like so:</p>

<pre><code>/*...*/
int num_args = 5;
byte* arg_listB = new byte[2*num_args+10];
//initialize your array

//free the memory when done with the array
delete[] arg_listB;
</code></pre>

<p>As noted in comments, you will need to initialize your array after you declare it, and do not forget to free the memory after you are done with it.  As there is much more to memory management and dynamic arrays than can be covered here, I would highly recommend looking into them.  Here are a few articles that might help:</p>

<p>C:
<a href=""http://www.exforsys.com/tutorials/c-language/c-arrays.html"" rel=""nofollow"">Arrays</a>,
<a href=""http://www.exforsys.com/tutorials/c-language/dynamic-memory-allocation-in-c.html"" rel=""nofollow"">Dynamic Memory</a></p>

<p>C++: <a href=""http://www.cplusplus.com/doc/tutorial/dynamic/"" rel=""nofollow"">Dynamic Memory</a></p>
",,15768554,3336
12469084,2,12464613,2012-09-18T01:05:01.373,1,,877375,,2012-09-18T01:10:33.397,2012-09-18T01:10:33.397,0,,"<p>Serial.read() only returns a single character, so the following:</p>

<pre><code>while (Serial.available() == 0);
firstLine[16] = Serial.read();
Serial.println(firstLine);
</code></pre>

<p>Needs to be change to something similar to:</p>

<pre><code>#define LEN   16
#define CR    13

int i=0;
char incoming;

while ((incoming!= CR) &amp; (i&lt;LEN-1))
{
   if (Serial.available())
   {
       incoming = Serial.read();
       firstline[i]=incoming;
       i++;
   }
}
firstline[i]=0;
Serial.println(firstLine);
</code></pre>
",,15776240,545
41225297,2,12495331,2016-12-19T14:55:55.273,1,,4074739,,2016-12-19T14:55:55.273,,1,,"<p>I'm not sure, but if you forget the endless loop at the end of your main function, the program stops, all interrupts will be disabled and the controllers enters an empty loop.</p>

<p>And without interrupts no PWM.</p>

<pre><code>int main(void){
....
while (1) {
}
return 0;
}
</code></pre>
",,15776390,2873
12556186,2,12556096,2012-09-23T20:56:27.620,2,,1600898,,2012-09-25T19:20:17.997,2012-09-25T19:20:17.997,6,,"<p>On Arduino, a <code>double</code> is <a href=""http://arduino.cc/en/Reference/Double"" rel=""nofollow"">the same as <code>float</code></a>, i.e. a little-endian <a href=""http://en.wikipedia.org/wiki/Single_precision_float"" rel=""nofollow"">single-precision floating-point number</a> that occupies 4 bytes of memory. This means that you should read exactly 5 bytes, use the little-endian variant of the <code>f</code> format to unpack it, and ignore the trailing newline with <code>x</code>:</p>

<pre><code>import struct
...

data = my_port.read(5)
num, = struct.unpack('&lt;fx', data)
</code></pre>

<p>Note that you don't want to use <code>readline</code> because any byte of the representation of the floating-point number can be <code>'\n'</code>.</p>

<p>As Nikklas B. pointed out, you don't even need to bother with the newline at all, just send the 4 bytes and read as many from Python. In that case the format string will be <code>'&lt;f'</code>.</p>
",,15803986,26511
12666409,2,12664826,2012-10-01T00:52:40.723,-1,,877375,,2012-10-01T01:33:10.330,2012-10-01T01:33:10.330,1,,"<p>I don't know Python, however, what is wrong with the Arduino sending the number like this:</p>

<pre><code>value= 1.234;
Serial.println(value);
</code></pre>

<p>For the Arduino to receive a float:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void loop() {
    char data[10], *end;
    char indata;
    int i=0;
    float value;

    while ((indata!=13) &amp; (i&lt;10)) {
        if (Serial.available() &gt; 0) {
            indata = Serial.read();
            data[i] = indata;
            i++;
        }
    }
    i-=1;
    data[i] = 0; // replace carriage return with 0
    value = strtof(data,&amp;end);           
}
</code></pre>

<p>Note this code is untested although very similar to code I have used in the past.</p>
",,15806552,7010
28719607,2,12664826,2015-02-25T12:55:40.157,0,,3157094,,2015-02-25T13:43:14.747,2017-05-23T12:02:24.553,0,,"<p>Because this question ranks highly on search engines I have put together a working solution.</p>

<p>WARNING: Unless you need to full floating point precision, convert to a string and send that (either using sprintf or dtostrf, or use <strong>Serial.print(value,NumberOfDecimalPlaces)</strong> <a href=""http://arduino.cc/en/Serial/print"" rel=""nofollow noreferrer"">(documentation)</a> ). This is because the following solution a) Wont work for machines of different endianess and b) some of the bytes may be misinterpreted as control characters.</p>

<p>Solution: Get the pointer for the floating point number and then pass it as a byte array to Serial.write().</p>

<p>e.g.</p>

<pre><code>/*
Code to test send_float function
Generates random numbers and sends them over serial

*/

void send_float (float arg)
{
  // get access to the float as a byte-array:
  byte * data = (byte *) &amp;arg; 

  // write the data to the serial
  Serial.write (data, sizeof (arg));
  Serial.println();
}


void setup(){
  randomSeed(analogRead(0));  //Generate random number seed from unconnected pin
  Serial.begin(9600); //Begin Serial
}

void loop()
{
  int v1 = random(300); //Generate two random ints
  int v2 = random(300);
  float test = ((float) v1)/((float) v2);  // Then generate a random float

  Serial.print(""m"");  // Print test variable as string
  Serial.print(test,11);
  Serial.println();

  //print test variable as float
  Serial.print(""d""); send_float(test);
  Serial.flush();
  //delay(1000);

}
</code></pre>

<p>Then to receive this in python I used your solution, and added a function to compare the the two outputs for verification purposes. </p>

<pre><code># Module to compare the two numbers and identify and error between sending via float and ASCII
import serial
import struct
ser = serial.Serial('/dev/ttyUSB0', 9600) // Change this line to your port (this is for linux ('COM7' or similar for windows))
while True:
    if(ser.inWaiting() &gt; 2):    
        command = ser.read(1) #read the first byte
        if (command == 'm'):
            vS = ser.readline()
            #
            ser.read(1)
            data = ser.read(4)
            ser.readline()
            vF, = struct.unpack('&lt;f',data)
            vSf = float(vS)
            diff = vF-vSf
            if (diff &lt; 0):
                diff = 0-diff
            if (diff &lt; 1e-11):
                diff = 0

            print ""Str:"", vSf, "" Fl: "", vF, "" Dif:"", diff 
</code></pre>

<p>References:
<a href=""https://arduino.stackexchange.com/questions/5090/sending-a-floating-point-number-from-python-to-arduino"">Sending a floating point number from python to arduino</a> and
<a href=""https://stackoverflow.com/questions/3270967/how-to-send-float-over-serial"">How to send float over serial</a></p>
",,15819298,1559
12679806,2,12679399,2012-10-01T19:33:15.210,1,,173967,,2012-10-07T03:49:19.420,2012-10-07T03:49:19.420,3,,"<p>These are my shots that <em>vector</em> is not included or you are missing namespace <code>std::</code>. The compiler explicitly points out that it does not know what vector is.</p>

<p>What is more, you don't initialize fields like this in <a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29"" rel=""nofollow"">C++</a>. You have to do it in the constructor:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

#define MEMORY_SIZE 10

class Clazz {
    std::vector&lt;int&gt; memory;

    public:
        Clazz() : memory(MEMORY_SIZE){}
        int memory_size() {return memory.size();}
};

int main() {
    Clazz c;
    std::cout &lt;&lt; c.memory_size() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",,15819640,1215
12866698,2,12865622,2012-10-12T20:34:57.077,2,,1069178,,2012-10-12T20:34:57.077,,0,,"<p>Thy this;</p>

<pre><code>const int a[3][4] = { {0, 0, 0, 0}, {0, 0, 0, 1}, {0, 0, 0, 0} };
const int b[3][4] = { {0, 0, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} };

int c[3][4];

const int* pa = &amp;a[0][0];
const int* pb = &amp;b[0][0];
int* pc = &amp;c[0][0];

for(int i = 0; i &lt; 3 * 4; ++i)
{
    *(pc + i) = *(pa + i) + *(pb + i);
}
</code></pre>
",,15830046,10392
12902964,2,12902041,2012-10-15T19:51:13.870,2,,224286,,2012-10-15T19:51:13.870,,2,,"<p>You're probably overrunning an array somewhere (Maybe not even in the code you posted). I'm not really sure what you're trying to do with the blocking either, but I guess you want to split your wave file into 600 sample chunks?</p>

<p>If so, I think you want something more like the following:</p>

<pre><code>std::vector&lt;std::vector&lt;double&gt;&gt;
SimpleWav::something(const std::vector&lt;double&gt;&amp; data, int N) {

    //How many blocks of size N can we get?
    int num_blocks = data.size() / N;

    //Create the vector with enough empty slots for num_blocks blocks
    std::vector&lt;std::vector&lt;double&gt;&gt; blocked(num_blocks);

    //Loop over all the blocks
    for(int i = 0; i &lt; num_blocks; i++) {
        //Resize the inner vector to fit this block            
        blocked[i].resize(N);

        //Pull each sample for this block
        for(int j = 0; j &lt; N; j++) {
            blocked[i][j] = data[i*N + j];
        }
    }

    return blocked;
}
</code></pre>
",,15931690,2149
12932012,2,12930978,2012-10-17T10:13:04.017,2,,1033896,,2012-10-17T10:13:04.017,,0,,"<p>Based on your comment, I <em>think</em> this is what you are asking for:</p>

<pre><code>const char* data_sets[][200] =
    {
        { ""00000"", ""11111"",         },
        { ""22222"", ""33333"", ""44444"" },
        { ""55555""                   },
    };
</code></pre>

<p>Each entry in <code>data_sets</code> is an array of 200 <code>const char*</code>. For accessing:</p>

<pre><code>for (size_t i = 0; i &lt; sizeof(data_sets) / sizeof(data_sets[0]); i++)
{
    const char** data_set = data_sets[i];
    printf(""data_set[%u]\n"", i);
    for (size_t j = 0; data_set[j]; j++)
    {
        printf(""  [%s]\n"", data_set[j]);
    }
}
</code></pre>

<p>See online demo at <a href=""http://ideone.com/6kq2M"" rel=""nofollow"">http://ideone.com/6kq2M</a>.</p>
",,15935885,230
12934347,2,12930978,2012-10-17T12:28:12.610,3,,1735865,,2012-10-17T23:53:27.987,2012-10-17T23:53:27.987,0,,"<p>Just use a two dimensional array. Like:</p>

<pre><code>char a[][]={
    ""0000000000"",
    ""0000000000"",
    ""0011111100"",
    ""0000100100"",
    ""0000100100"",
    ""0011111100"",
    ""0000000000"",
    ""0000000000"",
};
</code></pre>
",,15999272,79150
12980312,2,12980256,2012-10-19T18:30:12.603,6,,1466970,,2012-10-19T18:30:12.603,,0,,"<p>You have a semicolon after the for so the int i which has the for loop scoping only is not valid outside of the for loop.</p>

<p>You probably meant to do the following.</p>

<pre><code>  for (int i = 0; i&lt;=fieldIndex; i++)     // no semicolon
  {
     Serial.println(values[i]);
     values[i]= 0;
  }
</code></pre>
",,16067339,2227
12997370,2,12997317,2012-10-21T11:26:58.193,1,,36723,,2012-10-21T11:34:26.380,2012-10-21T11:34:26.380,2,,"<p>You would eventually overflow the stack if you were to reenter main from the interrupt handler multiple times recursively. Additionally, since you'll still be in the interrupt handler as far as the hardware is concerned, you'll have all kinds of weirdness - in particular, interrupts are blocked when you're already in an interrupt, which means <code>delay()</code> won't work and <code>millis()</code> won't count up, and various other things will be broken as well unless you figure out some way to manually re-enable interrupts.</p>

<p>A better way to solve this would be to make your 'expensive long function' instead be a state machine driven by a cheap, short function that is called very frequently. Your interrupt handler can then simply set a flag that is checked on entry into this function, at which point the current mode (ie, current state machine) is changed.</p>

<p>This approach also makes it easier to define new lighting modes. For example, you could define something like this:</p>

<pre><code>struct phase {
  unsigned char r, g, b, delay;
};

unsigned long t_nextPhase;
volatile struct phase *forceMode = NULL;
struct phase *mode = blinkAll;
int nextPhase = 0;

struct phase blinkAll[] = {
  { 255, 255, 255, 17 },
  { 0, 0, 0, 17 },
  { 0, 0, 0, 255 } // loop sentinel
};

void lighting_kernel() {
    noInterrupts(); // ensure we don't race with interrupts
    if (forceMode) {
        mode = forceMode;
        forceMode = NULL;
        t_nextPhase = millis();
        nextPhase = 0;
    }
    interrupts();

    if (t_nextPhase &gt; millis()) {
        return;
    }

    struct phase *cur_phase;
    do {
        cur_phase = mode[nextPhase++];
        if (cur_phase-&gt;delay == 255) {
            nextPhase = 0;
        }
    } while (cur_phase-&gt;delay == 255);

    analogWrite(red   , cur_phase-&gt;r);
    analogWrite(green , cur_phase-&gt;g);
    analogWrite(blue  , cur_phase-&gt;b);

    t_nextPhase = millis() + cur_phase-&gt;delay;    
}
</code></pre>

<p>Now to define a new lighting mode you just need a new array of colors and times, rather than writing new code. Adding things like color ramps and other such effects is left as an exercise to the reader.</p>
",,16080639,1409
13060855,2,13060699,2012-10-25T02:49:54.480,5,,241631,,2012-10-25T02:49:54.480,,2,,"<p>According to the error message you're including <code>shiftreg.h</code> on line 97 of <code>Lab9_step3.cpp</code>. What's on the 96 lines above that? The error probably lies somewhere in there.</p>

<p>If I had to guess, I'd say you're, either directly, or indirectly, including <code>shiftreg.h</code> twice (or more) in <code>Lab9_step3.cpp</code>, and the error's occurring because you don't have include guards in your header file.</p>

<p>Try adding the following to <code>shiftreg.h</code></p>

<pre><code>#ifndef SHIFTREG_H
#define SHIFTREG_H

class shiftreg
{
  // ...
};

#endif
</code></pre>
",,16124494,558
13094106,2,13093927,2012-10-26T20:39:19.257,3,,454406,,2012-10-26T20:39:19.257,,0,,"<p>Yes, there is an example on the Arduino web site. But I want to make you aware of a <a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34734"" rel=""nofollow"">compiler bug in GCC</a>, and the following work-around:</p>

<pre><code>/**
 * Alternative to PROGMEM storage class
 * 
 * Same effect as PROGMEM storage class, but avoiding erroneous warning by
 * GCC.
 * 
 * \see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34734
 */
#define PROGMEM_ __attribute__((section("".progmem.data"")))
</code></pre>
",,16178873,396
13182979,2,13148257,2012-11-01T18:06:35.420,0,,1663129,,2012-11-01T18:06:35.420,,0,,"<p>Solved.</p>

<p>Added </p>

<pre><code> #include &lt;SoftwareSerial.h&gt;
</code></pre>

<p>on the pde as well.</p>

<pre><code>#include &lt;SerialGSM.h&gt;
#include &lt;SoftwareSerial.h&gt;
SerialGSM cell(2,3);
void setup(){  
 cell.begin(9600);
}
</code></pre>
",,16221641,148
13170201,2,13169714,2012-11-01T02:39:53.750,5,,251860,,2012-11-01T17:49:38.690,2012-11-01T17:49:38.690,3,,"<p>What you need is to make your constructor do the initialization as follows:</p>

<pre><code>class MyLibrary{
public:
   MyLibrary(uint8_t, uint8_t);
   //...
private:
   SoftwareSerial _serial;
   //...
};

MyLibrary::MyLibrary(uint8_t in, uint8_t out)
   : _serial(in, out)
{
   //do initialization
}
</code></pre>

<p>This syntax might seem strange at first, but although it isn't quite as pretty, it clearly differentiates <em>initialization</em> of variables vs <em>operations</em> on variables, which is something that placing the initialization in the body of the constructor can make slightly fuzzy.  As a rule, UNLESS you use this syntax to initialize a member variable, C++ will call the default constructor, which will cause a compile error iff the member does not have a callable default constructor.</p>
",,16224740,4088
13212368,2,13212199,2012-11-03T18:52:25.907,2,,14065,,2012-11-03T18:52:25.907,,1,,"<p>It is an array initializer:</p>

<p>Example:</p>

<pre><code>int  val[] = {1, 2, 3, 4}; // initializes an array of ints.
</code></pre>

<p>If you have struct the same syntax works.</p>

<pre><code>struct X
{
    int x;
    int y;
};

X   valX[] = { {1,2}, {3,4}, {5,6}}; // initializes an array of X
                                     // first X is {1,2}
                                     // second X is {3,4}
                                     // etc
</code></pre>

<p>In your case the structure is a:</p>

<pre><code>ValueTitle&lt;VT_SHSPEED, VT_SHSPEED_TEXT_LEN&gt;
</code></pre>

<p>But the concept is the same;</p>
",,16224746,30367
13313889,2,13312869,2012-11-09T18:30:41.533,1,,999943,,2012-11-09T19:34:15.107,2020-06-20T09:12:55.060,5,,"<p>As mentioned in the comment by Hans, your communication protocol is off.</p>
<p>Your Arduino loop basically says:</p>
<blockquote>
<p>Read a value. If there is another available value, do something. Wait
0.2 seconds. Then repeat.</p>
</blockquote>
<p>Your PC loop says:</p>
<blockquote>
<p>Send a '2'. Then read an array of values. Then repeat.</p>
</blockquote>
<p>What you have going on, is your Arduino side of your communication is waiting for more values than are being sent.  On the Arduino, poll for <a href=""http://arduino.cc/en/Serial/Available"" rel=""nofollow noreferrer"">Serial.avaliable</a>, and then do the read.</p>
<p>On the PC, you probably don't need to change it.</p>
<p>When you disconnect and reconnect there is an extra bit that gets sent to initialize the baud connection, and that was tricking your protocol into working.</p>
<p>EDIT:
Be sure to check the settings that the Serial library is connecting with. Here are settings that I've used before to connect to an Arduino board before using the Qt QextSerialPort library.</p>
<pre><code>port-&gt;setFlowControl(FLOW_OFF);
port-&gt;setParity(PAR_NONE);
port-&gt;setDataBits(DATA_8);
port-&gt;setStopBits(STOP_1);
port-&gt;setTimeout(500);
</code></pre>
<p>Here are two links that maybe helpful:</p>
<p><a href=""http://www.webalice.it/fede.tft/serial_port/serial_port.html"" rel=""nofollow noreferrer"">http://www.webalice.it/fede.tft/serial_port/serial_port.html</a></p>
<p><a href=""https://www.google.com/search?q=arduino+and+boost%3A%3Aasio"" rel=""nofollow noreferrer"">https://www.google.com/search?q=arduino+and+boost%3A%3Aasio</a></p>
",,16242435,690
40803788,2,13313994,2016-11-25T11:17:43.773,2,,4350586,,2020-10-04T12:15:54.580,2020-10-04T12:15:54.580,0,,"<p>Tail call elimination is indeed supported and enabled by default in Arduino IDE. This is quite standard for micro-controller world where debug aids like proper stack frames are sacrificed for memory efficiency.</p>
<p>Here's a test:</p>
<pre><code>const int RAM_SIZE_IN_BYTES = 2048;

void f(int i) {
  Serial.println(i);
  if(i == 0) return;
  else f(i-1);
}

void setup() {
  Serial.begin(9600);
  f(RAM_SIZE_IN_BYTES);
}

void loop() {
}
</code></pre>
<p>This code prints numbers from 2048 to 0 to the console using a recursive function, which (without tail call optimization) requires more nested calls than available RAM bytes.</p>
",,16274451,15394
13357470,2,13357312,2012-11-13T08:22:26.623,2,,687514,,2012-11-13T08:22:26.623,,4,,"<p>Try this instead</p>

<pre><code>struct legtype {
    Servo hip;
    Servo shin;
    Servo foot;
};

typedef legtype leg;
</code></pre>

<p>Does that work?</p>

<p>Cheers,</p>
",,16306901,33924
13361698,2,13361621,2012-11-13T13:37:49.937,0,,440558,,2012-11-13T13:37:49.937,,3,,"<p>The function <code>USART0_PutNChar</code> (and the others) are <em>member functions</em> of another class. You need to create an instance of that class and call the functions through this object:</p>

<pre><code>USART0 usart0;

usart0.USART0_PutNChar(...);
</code></pre>

<p>However, it seems like the class <code>USART0</code> doesn't contain any state, which means you can either make the functions global (i.e. not in a class); Make the functions static, as in</p>

<pre><code>// Using `struct` as there is no private or protected data/functions
struct USART0
{
    static void USART0_PutNChar(...);
    ...
};
</code></pre>

<p>And the third alternative is to make <code>USART0</code> into a namespace:</p>

<pre><code>namespace USART0
{
    void USART0_PutNChar(...);
    ...
}
</code></pre>

<p>In these last two cases you call the functions like this:</p>

<pre><code>USART0::USART0_PutNChar(...);
</code></pre>
",,16343162,965
13372681,2,13372585,2012-11-14T03:41:07.453,1,,1817167,,2012-11-14T04:48:58.493,2012-11-14T04:48:58.493,3,,"<p>There are a few issues with this code:</p>

<ol>
<li>return type for <code>logo</code> is <code>unsigned char</code> while you are returning <code>char *</code></li>
<li>pgm_read_byte supposedly returns a byte, so you could simply do <code>buffer[i]=pgm_read_byte(...)</code></li>
<li><code>buffer</code> that you are trying to return is allocated on the stack and will not exist after function returns.</li>
</ol>

<p>You should probably be using <code>strlcpy_P</code> instead.</p>

<p><strong>Update:</strong> <br>
1. Assuming you have a fixed number of pages. Try creating a bitmap per page, like:</p>

<pre><code>static unsigned char __attribute__ ((progmem)) impostazioni_logo_page1[]={..}
</code></pre>

<p>2. return a pointer to each pages' logo:<br></p>

<pre><code>unsigned char* logo(int page)
{
  switch(page)
  {
    case 1:
       return impostazioni_logo_page1;
    break;
  }
  return NULL;
}
</code></pre>

<p>If you like to have all bitmaps in a single array, calculate an offset in the array and return that instead:</p>

<pre><code>int offset = page_num*page_size_in_chars;    
return &amp;impostazioni_logo_all_pages[offset];
</code></pre>

<p><strong>Update 2</strong>: Another option to manage pages:</p>

<pre><code>static unsigned char* pages[] = { impostazioni_logo_page1, impostazioni_logo_page2, ... }
...
glcd.drawbitmap(15,1, pages[page_index], 90,16);
</code></pre>
",,16358804,4705
13472066,2,13471729,2012-11-20T11:18:33.717,3,,1254352,,2013-03-18T10:27:09.540,2013-03-18T10:27:09.540,3,,"<p>First of all, you do not need the variable <code>startProject</code> - simply initialize the <code>firstProject</code> pointer with NULL and then write your condition like this:</p>

<pre><code>if (firstProject)
{
    // There is a project, so append the new one.
}
else
{
    // There is no project, so we need to create a new list.
}
</code></pre>

<p>The value <code>FALSE</code> is defined as 0, just as NULL. If <code>firstProject</code> is NULL the expression would look like <code>if (FALSE)</code> and continue execution inside the <code>else</code>-block.</p>

<p>So now your <code>reset</code>-Method needs to free the memory allocated for <b>all</b> projects, not only the last one and the second one, as your code does.</p>

<pre><code>delete ptrToLastProject; // Free last project
delete firstProject.nextProject; // Free the project following to the first one.
</code></pre>

<p>The problems in here are:</p>

<ul>
<li>what if <code>ptrToLastProject == firstProject.nextProject</code>? The second <code>delete</code>-statement would free already released memory.</li>
<li><code>firstProject</code> gets never released</li>
<li>the projects between the second and the last ones will never be released.</li>
</ul>

<p>The best way to free a singly linked list is something like this:</p>

<pre><code>Project* pProject = firstProject;
Project* pProjectToDelete;

while (pProject)  // As long as the pointer points to something (see the first comment)
{
    pProjectToDelete = pProject;
    pProject = firstProject-&gt;nextProject;
    delete pProjectToDelte;
}
</code></pre>

<p>In this implementation you are ""walking"" through the list, releasing the predecessing element, as long as there is an element following. If the next element is <code>NULL</code>, the last element has been released and the loop breaks.</p>

<p>Last but not least you need to reset the pointer to the first element (also called ""anchor"" in the terms of data structures):</p>

<pre><code>firstProject = NULL;
</code></pre>

<p>this ensures that <code>addProject</code> does not try to append an project to <code>NULL</code>.</p>
",,16362007,11420
13487590,2,13474923,2012-11-21T06:28:45.520,1,,266392,,2012-11-21T06:28:45.520,,0,,"<p>In my code, I only change <code>c_cflag</code>, as follows:</p>

<pre><code>// Enable the receiver and set local mode...
options.c_cflag |= (CLOCAL | CREAD);

// Set 8-bit mode
options.c_cflag &amp;= ~CSIZE;
options.c_cflag |= CS8;
</code></pre>

<p>I'll post more code tomorrow, but give that a shot (and don't modify <code>c_iflag</code>).</p>
",,16363042,508
13493930,2,13493723,2012-11-21T13:05:32.597,1,,687514,,2012-11-21T14:19:23.577,2012-11-21T14:19:23.577,0,,"<p>I'm thinking that the <code>getPressure()</code> method should be declared with the return type <code>float</code> as you implement it in <code>MPL3115A2.cpp</code>, so the <code>'h</code> file should have:</p>

<pre><code>...
class MPL3115A2 {
    public:
        float getPressure();
        // (and remember the constructor)
    private:    
        ...
}
</code></pre>

<p>Also, are you aware that the method doesn't actually <code>return</code> anything? If that is the idea, you could make it a <code>void getPressure()</code> and change the class definition accordingly.</p>

<p><strong>Added</strong>: For future readers, the answer is available in the error message, albeit well hidden in cryptic stuff: ""<em>...ISO C++ forbids <strong>declaration</strong> of 'getPressure' with <strong>no type</strong>...</em>""</p>

<p>Hope that helps.</p>
",,16488735,570
13493939,2,13493723,2012-11-21T13:06:01.913,2,,269211,,2012-11-22T14:29:43.093,2012-11-22T14:29:43.093,12,,"<p><code>getPressure()</code> has no return type!  According to the cpp you posted, your header file should <strong>declare</strong> the method as <code>float getPressure();</code> so change your header file to:</p>

<pre><code>#ifndef MPL3115A2_h
#define MPL3115A2_h

#include ""Arduino.h""

class MPL3115A2{
public:
  float getPressure(); // &lt;- only change here
private:
  int m_i2c_address;
  byte _p_msb, _p_csb, _plsb;
  byte _tempp, _tempa, _tempt, _decimalPress, _decimalAlt, _decimalTemp;
  unsigned long _ptot;
};

#endif 
</code></pre>

<p>to correspond with the <strong>definition</strong> which is</p>

<pre><code>float MPL3115A2::getPressure()
{
  // your processing code...
}
</code></pre>

<p>Also, keep in mind that you should review your <code>constructor</code> as it is not <strong>declared</strong> in your header. Also, doing something like</p>

<pre><code>p_msb = _p_msb;
p_csb = _p_csb;
p_lsb = _p_lsb;
tempp = _tempp;
tempa = _tempa;
tempt = _tempt;
decimalPress = _decimalPress;
decimalAlt = _decimalAlt;
decimalTemp = _decimalTemp;
ptot = _ptot;
</code></pre>

<p>is really weird. What are the variables on the left?  You are initializing them with your uninitialized members (those on the right, starting with <code>_</code>). You should consider giving an initial value to these members (like <code>0</code>?)</p>

<p>Changing your constructor to something like:</p>

<pre><code>MPL3115A2::MPL3115A2()
{
    _p_msb = 0;
    _p_csb = 0;
    _p_lsb = 0;
    _tempp = 0;
    _tempa = 0;
    _tempt = 0;
    _decimalPress = 0;
    _decimalAlt = 0;
    _decimalTemp = 0;
    _ptot = 0;
}
</code></pre>

<p>To make sure your member variables are initialized with a ""known"" value.</p>

<p>Also, most of these values seem temporary (you might not need them outside of a call to <code>getPressure()</code>. In this case, consider moving all these bytes to the scope of the function instead of inside the sensor class to avoid using unnecessary memory - there is not that much available on Arduinos.</p>

<p>You will also need to add <code>MPL3115A2();</code> in the <code>public</code> part of your <code>MPL3115A2</code> class, this is because you are defining a body for this constructor in the CPP file, therefore you need to declare it so that it's part of the object.</p>
",,16511340,2212
13516157,2,13515884,2012-11-22T15:48:01.623,3,,1835951,,2012-11-22T15:48:01.623,,0,,"<p>You're reading a byte (a <code>char</code> in C) from your serial port, but you try to compare it to a string:</p>

<p>If you want to read 4 <code>char</code> and compare it to <code>""send""</code> then you would have to do something like:</p>

<pre><code>#include &lt;LiquidCrystal.h&gt;
#include &lt;string.h&gt;
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

char serialinput [5] = {0};   // for incoming serial data
                              // 4 char + ending null char

void setup() {
    Serial.begin(9600);     // opens serial port, sets data rate to 9600 bps
}

void loop() {
    // send data only when you receive data:
    if (Serial.available() &gt; 0) {
        memmove (serialinput, &amp;serialinput[1], 3); // Move 3 previous char in the buffer
        serialinput [3] = Serial.read(); // read char at the end of input buffer

        if (0 == strcmp(serialinput, ""send"")) // Compare buffer content to ""send""
        {
            lcd.print(""received"");
        }
    }
}
</code></pre>

<p>Assuming that <code>&lt;string.h&gt;</code> header is valid within the Arduino SDK</p>

<p>PS : litteral strings in C code are written between <code>""</code> (double quotation marks). <code>'</code> is for characters.</p>
",,16532586,376
13522735,2,13520272,2012-11-23T03:31:35.097,4,,10431,,2012-11-27T19:06:41.863,2012-11-27T19:06:41.863,6,,"<p>I tend to do this kind of stuff, though, Id tend to have a separate serial port ""class"" ( struct + functions ) and a protocol class that lives over the top of serial port.  I used these all the time in my embedded systems.  This gives you the best of both worlds,  a blocking synchronous call and an async call so you can pseudo multitask.</p>

<pre><code>typedef struct serial_port_s serial_port;
typedef void (*serial_on_recived_proc)(serial_port* p);
typedef struct serial_port_s{
    bool timeoutFlag;
    bool receiveFlag;
    void* context;
    serial_on_recived_proc response_handler;
};

void send_serial(serial_port* p, char* message)
{
    //SendMsg?
}
void receive_serial(serial_port* p, char* response)
{
    //receiveMsg?
}

bool has_data(serial_port* p)
{
    return p-&gt;receiveFlag;
}

bool has_timed_out(serial_port* p)
{
    return p-&gt;timeoutFlag;
}
bool is_serial_finished(serial_port* p)
{
    return has_data(p) || has_timed_out(p); 
}

bool serial_check(serial_port* p)
{
    if(is_serial_finished(p) &amp;&amp; p-&gt;response_handler != NULL)
    {
       p-&gt;response_handler(p)
       p-&gt; response_handler = NULL;
       return true;
    }
    return false;
}

void send(serial_port* p, char* message, char* response)
{
    p-&gt;response_handler=NULL;
    send_serial(p, message);
    while(!is_serial_finished(p));
    receive_serial(p, response);
}

void sendAsync(serial_port* p, char* message, serial_on_recived_proc handler, void* context)
{
    p-&gt;response_handler = handler;
    p-&gt;context = context;
    send_serial(p, message);
}

void pow_response(serial_port* p)
{
    // could pass a pointer to a struct, or anything depending on what you want to do
    char* r = (char*)p-&gt;context;  
    receive_serial(p, r);
    // do stuff with the pow response
}

typedef struct
{
   char text[100];       
   int x;
   bool has_result;
} bang_t;

void bang_parse(bang_t* bang)
{
   bang-&gt;x = atoi(bang-&gt;text);
}

void bang_response(serial_port* p)
{
    bang_t* bang = (bang_t*)p-&gt;context;  
    receive_serial(p, bang-&gt;text);
    bang_parse(bang);
    bang-&gt;has_result=true;
}

void myFunc();
{
    char response[100];
    char pow[100];
    bang_t bang1;
    bang_t bang2;
    serial_port p; //
    int state = 1;
    // whatever you need to do to set the serial port

    // sends and blocks till a response/timeout
    send(&amp;p, ""Hello"", response);
    // do what you like with the response

    // alternately, lets do an async send...
    sendAsync(&amp;p, ""Pow"", pow_response, pow);       

    while(true)
    {
        // non block check, will process the response when it arrives               
        if(serial_check(p))
            {
              // it has responded to something, we can send something else...

              // using a very simple state machine, work out what to send next.
              // in practice I'd use enum for states, and functions for managing state
              // transitions, but for this example I'm just using an int which
              // I just increment to move to the next state
              switch(state)
              {
              case 1: 
                 // bang1 is the context, and will receive the data
                 sendAsync(&amp;p, ""Bang1"", bang_response, &amp;bang1);
                 state++; 
                 break;
              case 2:
                 // now bang2 is the context and will get the data...
                 sendAsync(&amp;p, ""Bang2"", bang_response, &amp;bang2);
                 state++; 
                 break;
              default:
                 //nothing more to send....
                 break;
              }
            }
        // do other stuff you want to do in parallel
    }
};
</code></pre>
",,16561418,1252
13528488,2,13520272,2012-11-23T11:46:04.697,0,,1266688,,2012-11-23T11:46:04.697,,0,,"<p>Take things simple. An ISR routine must be very fast so for me the best approch is to have a global RXBuffer like this:</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;

class RXBuffer {
public:
    friend class ISR;

    typedef std::deque&lt;uint8_t&gt;::const_iterator const_iterator;

    RXBuffer();
    size_t size() const { m_buffer.size(); }

    // read from the buffer in a container in the range [first, last)
    template &lt;typename Iterator&gt;
    void read(Iterator first, Iterator last, Iterator to)
    {
        // how many bytes do you want to read?
        size_t bytes_to_read = std::distance(first, last);

        if (bytes_to_read &gt;= size())
        {
            // read the whole buffer
            std::copy(begin(), end(), first);

            // empty the buffer
            m_buffer.clear();

            return size();
        }
        else
        {
            // copy the data
            copy(begin(), begin() + bytes_to_read, firt);

            // now enque the element
            m_buffer.erase(begin(), begon() + bytes_to_read);

            return bytes_to_read;
        }
    }

private:
    void put(uint8_t data)
    {
        // check buffer overflow
        m_buffer.push_back(data);
    }

    const_iterator begin() const { return m_buffer.begin(); }
    const_iterator end() const { return m_buffer.end(); }

private:
    std::deque&lt;uint8_t&gt; m_buffer;           // buffer where store data
    size_t m_size;                          // effective size of the container
};

class ISR {
public:
    ISR(RXBuffer&amp; buffer) : m_buffer(buffer) {}

    // ISR Routine
    void operator () (uint8_t data)
    {
        m_buffer.put(data);
    } 

private:
    RXBuffer&amp; m_buffer;
};
RXBuffer g_uart1_rx_buffer;
</code></pre>

<p>Now you have the ISR and a RXBuffer where search data, so you need something to wrap the UART functions. You can implement as follow:</p>

<pre><code>class UART {
public:
    UART(unsigned int uart_device, RXBuffer&amp; rx_buffer) :
        m_uart(uart_device), m_buffer(rx_buffer)
    {
    }

    unsigned int uart_device() const { return m_uart; }

    // set the timeout during a read operation
    void timeout(unsigned ms) { m_timer.countdown(ms); }

    template &lt;typename InputIterator&gt;
    void read(InputIterator first, InputIterator last)
    {
        // start the timer
        m_timer.start();

        size_t size = std::distance(first, last);
        size_t read_bytes = 0;

        while (read_bytes != size &amp;&amp; !m_timer.is_expired())
        {
            read_bytes += m_buffer.read(first + read_bytes, last);
        }

        if (read_bytes != size) throw std::exception(""timeout"");
    }

    template &lt;typename OutputIterator&gt;
    void send(OutputIterator first, OutputIterator last)
    {
        size_t size = std::distance(first, last);
        uart_send(m_uart, &amp;(*first), size);
    }

private:
    unsigned int m_uart;
    RXBuffer&amp; m_buffer;
    timer m_timer;
};
</code></pre>
",,16624399,1695
13520867,2,13520625,2012-11-22T22:33:47.873,1,,882003,,2012-11-22T22:33:47.873,,2,,"<p>Well here's a bug</p>

<pre><code>TermSet::TermSet(float a, float b, float step, int setsSize){
this-&gt;a = a;
this-&gt;b = b;
this-&gt;step = step;
this-&gt;last = -1;

this-&gt;setsSize = size;
</code></pre>

<p>At this point <code>size</code> is an uninitialised variable. Your compiler should have warned you about this. Pay attention to compiler warnings. I guess you meant</p>

<pre><code>this-&gt;setsSize = setsSize;
</code></pre>

<p>No idea if this is the cause of the problem you have, but you haven't given us much to go on.</p>
",,16633154,6220
13555347,2,13554570,2012-11-25T20:47:19.710,0,,269211,,2012-11-25T20:47:19.710,,5,,"<p>First thing would be to check the <code>Arduino</code> site, on the <code>SD</code> documentation (<a href=""http://arduino.cc/en/Reference/SD"" rel=""nofollow"">here</a>) there's a mention that the communication between the <code>microcontroller</code> and the <code>SD card</code> uses <code>SPI</code> (documentation <a href=""http://arduino.cc/en/Reference/SPI"" rel=""nofollow"">here</a>) which takes place on <code>digital pins</code> <code>11</code>, <code>12</code> and <code>13</code>. I wouldn't be surprised if this was the source of your problems with the <code>Serial</code> monitor.</p>

<p>Reading some comments in <code>Sd2Card.h</code>, it might be tricky to get your setup to work properly:</p>

<pre><code>/**
 * Define MEGA_SOFT_SPI non-zero to use software SPI on Mega Arduinos.
 * Pins used are SS 10, MOSI 11, MISO 12, and SCK 13.
 *
 * MEGA_SOFT_SPI allows an unmodified Adafruit GPS Shield to be used
 * on Mega Arduinos.  Software SPI works well with GPS Shield V1.1
 * but many SD cards will fail with GPS Shield V1.0.
 */
</code></pre>

<p>Even if you put <code>MEGA_SOFT_SPI</code> to a non 0 value, you'd probably still fail to pass the <code>(defined(__AVR_ATmega1280__)||defined(__AVR_ATmega2560__))</code> check.</p>

<p>I would suggest trying your same sketch without the <code>TinyGPS</code> to try to pinpoint the issue.</p>

<p>Also, check out <a href=""http://arduino.cc/forum/index.php?action=printpage;topic=120653.0"" rel=""nofollow"">this sketch</a> it seems to be doing something similar to what you're doing, maybe you can fix yours based on what's done here.</p>
",,16724214,7501
13585083,2,13583419,2012-11-27T13:16:56.200,5,,1418091,,2012-11-27T13:16:56.200,2017-04-13T12:32:45.230,2,,"<p>You are correct in most of your assumptions. The proper way to handle this is using an interrupt and it is not a good idea to have delays in your interrupt service routines (ISR). So what you want to do is set a flag in your ISR and check that flag in your main loop.</p>

<pre><code>// Flag needs to be volatile if used in an ISR
volatile int buttonFlag = 0; 

void loop()
{
    if (buttonFlag == 0)
    {
        heartbeat();                        //make led beat
    }
    else
    {
        analogWrite(greenPin, 255);         //button stays green once pushed
        functionA                           //has some delays in it
        functionB                           //has some other delays
        buttonFlag = 0;                     //clear flag after executing code
    }

}

// Interrupt Service Routine attached to INT0 vector
ISR(EXT_INT0_vect)
{
    buttonFlag = digitalRead(buttonPin);    //set flag to value of button
}
</code></pre>

<p>Since the interrupt will only trigger on a change in the state of the button, you don't need to check for that.</p>

<p>Make sure that your flag variable is global and is declared <a href=""http://tigcc.ticalc.org/doc/keywords.html#volatile"" rel=""nofollow noreferrer""><code>volatile</code></a> for use in the ISR. And make sure you are using the correct interrupt vector for use with the pin you are using.</p>

<p>Here is a <a href=""http://www.engblaze.com/we-interrupt-this-program-to-bring-you-a-tutorial-on-arduino-interrupts/"" rel=""nofollow noreferrer"">good tutorial</a> on Arduino interrupts. And here is another <a href=""http://gonium.net/md/2006/12/20/handling-external-interrupts-with-arduino/"" rel=""nofollow noreferrer"">good example</a> of what you're trying to do.</p>

<p>You may also want to look into <a href=""https://electronics.stackexchange.com/questions/41674/switch-debouncing-would-toggle-switch-still-bounce/41690#41690"">debouncing your switch</a> presses depending on what type of switch you're using. If instead of missing the first press, you're getting too many presses, you will need to implement some type of debouncing.</p>
",,16740087,2250
32375444,2,13583419,2015-09-03T12:19:26.663,2,,5296733,,2015-09-07T16:38:40.983,2015-09-07T16:38:40.983,1,,"<p>I'm a professional programmer, but I'm new to Arduino world. I noted that many Arduino owners don't know the fundamentals of programming, and cannot achieve good results in using this amazing piece of technology.</p>

<p>In particular, I want to suggest to not use Arduino interrupts if it's not necessary, because there are only two of them, and even if you can write a ""beautiful"" code for a single sensor, or actuator, when you have to implement a more complex project, you cannot use them. Surely you've been correct in using the interrupt to deal with a single button, but what if you have four buttons to manage? </p>

<p>For this reason I rewrote the ""heartbeat"" sketch using the technique of ""time slice"" or ""single step"". Using this technique, each time the loop function is executed, you run only a ""single step"" of your control functions, so you can insert as many as you need, and be equally quick and responsive to all the sensors you're using.
To do so, I use global counters for each control function I have to implement, and each time the loop function is executed, I execute a single step of each function.
This is the new sketch:</p>

<pre><code>// Interrupt.ino - this sketch demonstrates how to implement a ""virtual"" interrupt using
// the technique of ""single step"" to avoid heavy duty cycles within the loop function.

int maxPwm = 128;   // max pwm amount
int myPwm = 0;      // current pwm value
int phase = 1;      // current beat phase
int greenPin = 11;  // output led pin
int buttonPin = 9;  // input button pin
int buttonFlag = 1; // button flag for debounce

int myDir[] = {0,1,-1,1,-1}; // direction of heartbeat loop
int myDelay[] = {0,500,1000,500,3000}; // delay in microseconds of a single step

void setup()
{
   pinMode(buttonPin, INPUT); // enable button pin for input
   // it's not necessary to enable the analog output
}

void loop()
{
   if(phase&gt;0) heartbeat(); // if phase 1 to 4 beat, else steady
   buttonRead(); // test if button has been pressed
}

// heartbeat function - each time is executed, it advances only one step
// phase 1: the led is given more and more voltage till myPwm equals to maxPwm
// phase 2: the led is given less and less voltage till myPwm equals to zero
// phase 3: the led is given more and more voltage till myPwm equals to maxPwm
// phase 4: the led is given less and less voltage till myPwm equals to zero
void heartbeat() 
{
   myPwm += myDir[phase];
   analogWrite(greenPin, myPwm);
   delayMicroseconds(myDelay[phase]);
   if(myPwm==maxPwm||myPwm==0) phase = (phase%4)+1;
}

// buttonRead function - tests if the button is pressed; 
// if so, forces phase 0 (no beat) and enlightens the led to the maximum pwm
// and remains in ""inoperative"" state till the button is released
void buttonRead()
{
   if(digitalRead(buttonPin)!=buttonFlag)   // if button status changes (pressed os released)
   {
      buttonFlag = 1 - buttonFlag; // toggle button flag value
      if(buttonFlag) // if pressed, toggle between ""beat"" status and ""steady"" status
      {
         if(phase) myPwm = maxPwm; else myPwm = 0;
         phase = phase==0;
         analogWrite(greenPin, myPwm);
      }
   }
}
</code></pre>

<p>As you can see, the code is very compact and fast to execute. I divided the heartbeat loop into four ""phases"", regulated by the myDelay array, and whose direction of counting is regulated by the myDir array. If nothing happens, the voltage of the pwm led pin is incremented at each step until it reaches the maxPwm value, then the loop enters phase 2, in which the voltage is decremented until zero, and so on, implementing the original heartbeat.</p>

<p>If the button is pressed, the loop enters in phase zero (no heartbeat), and the led is alimented with maxPwm voltage. From now on, the loop maintains a steady led, until the button is released (this implements the ""debounce"" algorithm). If the button is pressed again, the buttonRead function restarts the heartbeat function, making it enter the phase 1 again, so the heartbeat is restored.</p>

<p>If you press the button again, the heartbeat stops, and so on. All without any exhitation or bouncing at all.</p>
",,16780376,1087
13592516,2,13591776,2012-11-27T20:31:13.897,2,,1163625,,2012-11-27T21:03:52.277,2012-11-27T21:03:52.277,2,,"<p>As @NikolaiNFetissov says, plot the periods you measured.  But plot several, one above the other, starting with the 1st interval after the 48 second break.  </p>

<p>So you will have:</p>

<pre><code>A (21C) _____|----------|_____|-----|_____|-----

B (24C) ______|---------|_____|-----------|__________

Clock   _____|-----|_____|-----|_____|-----|_____|-----

etc
</code></pre>

<p>I would measure several cycles with different conditions (eg different temperatures but the same wind/direction), plot them and then see if you can see which parts of the pattern change. It would help if you knew the sampling rate and plotted that too.  You say it is at the fastest possible, but I imagine there you are counting clock ticks or something - or how else are you determining the number of seconds? </p>

<p>Edit:</p>

<p>How to plot that? I was imagining a piece of squared-paper and a pencil :-)  As for a program, my only (brief) experience was with gnuplot. For that you'd have to create lists of coordinates from your intervals, so:</p>

<pre><code>1 0.006
0 0.002
1 0.005
0 0.001
</code></pre>

<p>might be turned into:</p>

<pre><code>x,     y
0.0,   1
0.006, 1
0.006, 0
0.008, 0
0.008, 1
0.013, 1
0.013, 0
0.014, 0

etc
</code></pre>

<p>My guess is that in the time it would take to install and learn to use gnuplot and to create the coordinates, you could plot the data on paper and figure out the code.  But to me, the clock rate is key... (sorry to go on about it ;-)</p>
",,16785854,1017
13612972,2,13612253,2012-11-28T19:33:32.260,2,,1782465,,2012-11-28T19:33:32.260,,2,,"<p>The logic is to only define the macros if none of them is defiend. However, I would certainly refactor it into:</p>

<pre><code>#if !defined(_PTRDIFF_T) &amp;&amp; !defined(_T_PTRDIFF_) &amp;&amp; //... well, you get the idea
  #define _PTRDIFF_T
  #define _T_PTRDIFF_
  //...
  #ifndef __PTRDIFF_TYPE__
    #define __PTRDIFF_TYPE__ long int
  #endif
  typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
</code></pre>

<p>As to the second question: you can define a macro without a replacement text (it would just expand to nothing if used). Such macros are often used for conditional inclusion of code based on <code>#ifdef</code> or <code>#ifndef</code>.</p>
",,16800908,3166
13663794,2,13663669,2012-12-01T21:13:08.383,3,,2509,,2012-12-01T21:22:48.880,2012-12-01T21:22:48.880,3,,"<p>If you need automatic storage to exist for only part of the execution of a function you can place them inside a scope block:</p>

<pre><code>void foo(void) {

   // some code where neither reading variable is occupying memory

   {
      int yreadings[4];
      int zreadings[4];

      // here these variable are taking up memory

   }

   // other code where neither reading variable is occupying memory
}
</code></pre>

<p>but of course you can only use them in that block.</p>

<hr>

<p>To expand on my comment there are three classes of memory use that have different durations</p>

<ul>
<li>Globals and variables declared <code>static</code> in function or method or class context exist for the entire life of the program</li>
<li>Automatic variables (those declared inside a function or method) exist for the lifetime of their scope including the life of any other subprograms called from that scope</li>
<li>Dynamic allocations are blocks of memory obtained from <code>new</code><sup>1</sup> or the <code>alloc</code> family of function (which will always be a bit larger than the size you request for bookkeeping reasons) which persist from the time you allocate them until you call <code>delete</code> or <code>free</code> (respectively).</li>
</ul>

<hr>

<p><sup>1</sup> If you override <code>new</code> this may or may not still apply, but if you do that it is your lookout to understand what you've done to yourself.</p>
",,16852695,2398
26085180,2,13684387,2014-09-28T13:12:20.370,0,,653513,,2014-09-28T13:12:20.370,,0,,"<p>This approach works:</p>

<pre><code>//exact address depends on IC model and &lt;A0:A2&gt; wiring
#define dip_addr       0x38 
...

byte rdata = 0xFF;

Wire.beginTransmission(dip_addr);
Wire.send((uint8_t)0);  
Wire.endTransmission();

Wire.requestFrom(dip_addr,1);

if (Wire.available()) rdata = Wire.receive();

Serial.println (""DIP: "" + String(rdata, DEC));
</code></pre>
",,16885398,10426
13732513,2,13732217,2012-12-05T21:10:41.730,5,,302916,,2012-12-05T22:48:56.943,2012-12-05T22:48:56.943,1,,"<p>I am <em>not</em> an arduino guy, but I did stay at a Holiday Inn last night with access to Google :) </p>

<p><a href=""http://arduino.cc/en/Serial/Read"" rel=""nofollow"">http://arduino.cc/en/Serial/Read</a></p>

<p><code>Serial.read()</code> returns a single byte (as an <code>int</code>). You're trying to assign that to a char array. </p>

<p>You can't do that. You can assign something to a specific element <em>in</em> an array: 
<code>line1[0] = 'c';</code> 
for example, but you can't assign to an array itself. </p>

<p>It <em>seems</em> like you're looking for <code>Serial.readBytes()</code></p>

<p><a href=""http://arduino.cc/en/Serial/ReadBytes"" rel=""nofollow"">http://arduino.cc/en/Serial/ReadBytes</a></p>

<p>Which would look like:</p>

<p><code>Serial.readBytes(line1, 5);</code></p>

<p>in your case where <code>5</code> is the length of your buffer (array). This would read (at most) 5 bytes into your <code>line1</code> buffer.  </p>

<p><strong>Edit to add:</strong> That being said, it appears arduino's ""C-Like"" language is very much like C in that it expects ""Strings"" (<code>char</code> arrays) to be <code>null</code> terminated when passing them to <code>Serial.print()</code>. The advice above doesn't do that and in fact would cause problems.</p>

<p>What you would need to do is read up to <em>one byte less than the length of your array</em>, and then <code>null</code> terminate the ""string"" using the number of bytes actually read which is what <code>bytesRead()</code> returns to you (arrays are zero indexed):</p>

<pre><code>int numBytesRead = 0;
...
numBytesRead = Serial.readBytes(line1, 4);
line1[numBytesRead] = '\0';  
Serial.print(line1);
</code></pre>

<p>Option B is to do as I originally mentioned, but loop and print one byte at a time from your <code>line1</code> array using the index:</p>

<pre><code>int numBytesRead = 0;
numBytesRead = Serial.readBytes(line1, 5);
int i;
for (i = 0; i &lt; numBytesRead; i++) {
    Serial.print(line1[i]);
}
</code></pre>

<p>According to the docs <code>Serial.print()</code> automagically knows to send a single byte/char when that's all that's passed to it.</p>
",,16909175,1809
13744074,2,13743933,2012-12-06T12:55:24.657,1,,440558,,2012-12-06T13:22:53.960,2012-12-06T13:22:53.960,5,,"<p>When the LCD is initialized, I'm guessing its default position would be 0,0 (i.e. first row and first column). Then for each character you read from the serial input, you print it to the LCD, and increase the column. If you get a newline in the input, then reset the LCD position to 1,0 (i.e. second row and first column). Continue reading and printing.</p>

<hr>

<p>Example pseudo-code:</p>

<pre><code>int current_line = 0;
int current_col = 0;

void loop(void)
{
    char ch = read_char_from_serial();

    if (ch == '\n')
    {
        current_line++;
        current_col = 0;
    }
    else
    {
        lcd_goto(current_line, current_col++);
        lcd_put_char(ch);
    }
}
</code></pre>
",,16917052,65
13775959,2,13775893,2012-12-08T08:53:26.803,1,,929981,,2012-12-08T08:53:26.803,,4,,"<pre><code>for(unsigned int i = 0; i&lt;sizeof(struct_data); i++){
    // +i has to be outside of the parentheses in order to increment the address
    // by the size of a char. Otherwise you would increment by the size of
    // struct_data. You also have to dereference the whole thing, or you will
    // assign an address to data[i]
    data[i] = *((char*)(&amp;struct_data) + i); 
}

AMG_ANGLES* tmp = (AMG_ANGLES*)data; //Re-Make the struct
//tmp is a pointer so you have to use -&gt; which is shorthand for (*tmp).yaw
cout &lt;&lt; tmp-&gt;yaw; 
}
</code></pre>
",,16977985,813
13775983,2,13775893,2012-12-08T08:56:52.963,39,,1411060,,2012-12-08T21:28:32.183,2012-12-08T21:28:32.183,2,,"<p>It seems I've solved my issue with the following code.</p>

<pre><code>struct AMG_ANGLES {
    float yaw;
    float pitch;
    float roll;
};

int main() {
    AMG_ANGLES struct_data;

    struct_data.yaw = 87.96;
    struct_data.pitch = -114.58;
    struct_data.roll = 100.50;

    //Sending Side
    char b[sizeof(struct_data)];
    memcpy(b, &amp;struct_data, sizeof(struct_data));

    //Receiving Side
    AMG_ANGLES tmp; //Re-make the struct
    memcpy(&amp;tmp, b, sizeof(tmp));
    cout &lt;&lt; tmp.yaw; //Display the yaw to see if it's correct
}
</code></pre>

<p>WARNING: This code will only work if sending and receiving are using the same <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""noreferrer"">endian</a> architecture.</p>
",,17107786,16434
37124468,2,13775893,2016-05-09T20:01:47.383,4,,6312161,,2016-05-10T04:22:43.990,2016-05-10T04:22:43.990,2,,"<p>Always utilize data structures to its fullest..</p>

<pre><code>union AMG_ANGLES {
  struct {
    float yaw;
    float pitch;
    float roll;
  }data;
  char  size8[3*8];
  int   size32[3*4];
  float size64[3*1];
};
</code></pre>
",,17108721,1768
13782366,2,13781908,2012-12-08T21:58:05.933,2,,1599004,,2012-12-08T22:46:44.300,2012-12-08T22:46:44.300,0,,"<p>A Linux device driver should have access to a set of functions provided by the arch's <em>gpio</em> module.  Since I am familiar with Atmel ARM code and not sure about the Broadcom SoC used by the RPI, here's some real <em>gpio</em> code.</p>

<p>I/O devices on ARM SoCs are typically memory mapped (i.e. there is no separate I/O address space).  These physical addresses can be mapped into kernel virtual address space. (The addresses of a peripheral's registers are often mapped by the individual device driver for its exclusive use.)<br>
Once mapped into virtual memory, registers that contain or control the state of a GPIO pin can simply be accessed by an ordinary read or write memory operation (while conforming to C language requirements).  Consult the <a href=""http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf"" rel=""nofollow"">Broadcom SoC hardware document</a> for the exact assignment/functionality of each bit in these device registers.</p>

<p>Prior to using a GPIO as either an input pin or an output pin, the GPIO pin must be configured.  Often the pin will have multiple uses (it's ""multiplexed""), so one of those specific functionalities has to be selected during <em>early board initilization</em>.  These assignments are performed by writing to device configuration registers (which are mapped to memory locations). </p>

<p>An Atmel function to write the value of a GPIO pin (from <a href=""http://lxr.free-electrons.com/source/arch/arm/mach-at91/gpio.c"" rel=""nofollow"">arch/arm/mach-at91/gpio.c</a>) :</p>

<pre><code>/*
 * assuming the pin is muxed as a gpio output, set its value.
 */
int at91_set_gpio_value(unsigned pin, int value)
{
        void __iomem    *pio = pin_to_controller(pin);
        unsigned        mask = pin_to_mask(pin);

        if (!pio)
                return -EINVAL;
        __raw_writel(mask, pio + (value ? PIO_SODR : PIO_CODR));
        return 0;
}
EXPORT_SYMBOL(at91_set_gpio_value);
</code></pre>

<p>An Atmel function to read the value of a GPIO pin:</p>

<pre><code>/*
 * read the pin's value (works even if it's not muxed as a gpio).
 */
int at91_get_gpio_value(unsigned pin)
{
        void __iomem    *pio = pin_to_controller(pin);
        unsigned        mask = pin_to_mask(pin);
        u32             pdsr;

        if (!pio)
                return -EINVAL;
        pdsr = __raw_readl(pio + PIO_PDSR);
        return (pdsr &amp; mask) != 0;
}
EXPORT_SYMBOL(at91_get_gpio_value);
</code></pre>

<p>Hopefully you can find similar code in the kernel that you use (e.g. <em>grep</em> the <code>System.map</code> symbol file for ""gpio"").</p>
",,17134761,186
13849480,2,13781915,2012-12-12T22:04:56.680,0,,670373,,2012-12-12T22:04:56.680,,0,,"<p>You probably wanted:</p>

<pre><code>void loop() {
    if (Serial.available()) {
        do {
            ch = Serial.read();
        } while (ch == 'y');
    }

    if (Serial.available()) {
        do {
            ch = Serial.read();
        } while (ch == 'x');
    }
}
</code></pre>

<p>here's a tip: Write your if statements backwards, like</p>

<pre><code>if(NULL == somevariable){
    //Do this
}
</code></pre>

<p>Compilers will complain noisily if you forget the second = (you can't set a constant!)</p>

<p>It's an easy mistake to make!</p>
",,17147153,18520
13791441,2,13791326,2012-12-09T20:25:00.273,1,,10431,,2012-12-11T18:52:55.923,2012-12-11T18:52:55.923,0,,"<p>You can't directly do it like that, but you can have all your arrays predefined, then <code>memcpy</code> them to <code>framebuffer</code>:</p>

<pre><code>// Put all your preconstructed items in some array.....
// You'd typically make this a global.

boolean glyphs[2][6][5] = {
    {
        {0,0,1,0,0},
        {0,0,0,1,0},
        {0,0,1,0,0},
        {0,1,0,0,0},
        {1,0,0,0,0},
        {1,1,1,1,1}
    },
    {
        {1,1,1,1,1},
        {1,0,0,1,1},
        {1,0,1,0,1},
        {1,1,0,0,1},
        {1,0,0,0,1},
        {1,1,1,1,1}
    }
};

// Then whereever you want to change the framebuffer in your code:
// copy the second into a framebuffer:
memcpy(framebuffer, glyphs[1], sizeof(boolean)*6*5);
</code></pre>
",,17172719,1001
13826267,2,13792302,2012-12-11T18:29:43.950,6,,63550,,2012-12-11T19:44:08.957,2020-06-20T09:12:55.060,0,,"<p>It must be your LCD print routine, and thus the casts you have used are correct.</p>
<p>I tried it out on an Arduino using <a href=""http://arduino.cc/en/Serial/Print"" rel=""nofollow noreferrer"">serial printing</a> instead of an LCD. The expected result appears in the serial monitor (started by menu <em>Tools</em> -&gt; <em>Serial Monitor</em>) for the complete code example below:</p>
<pre><code>Start...

5
15
0.33
0.33333334922790
</code></pre>
<p>The last result line confirms it is a <a href=""http://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">4 byte float</a> with 7-8 significant digits.</p>
<h3>Complete code example</h3>
<pre><code>/********************************************************************************
 * Test out for Stack Overflow question &quot;Divide two integers in Arduino&quot;,       *
 * &lt;http://stackoverflow.com/questions/13792302/divide-two-integers-in-arduino&gt; *
 *                                                                              *
 ********************************************************************************/

// The setup routine runs once when you press reset:
void setup() {
    // Initialize serial communication at 9600 bits per second:
    Serial.begin(9600);

    //The question part, modified for serial print instead of LCD.
    {
        int l1 = 5;
        int l2 = 15;
        float test = 0;
        test = (float)l1 / (float)l2;

        Serial.println(&quot;Start...&quot;);
        Serial.println(&quot;&quot;);
        Serial.println(l1);
        Serial.println(l2);
        Serial.println(test);
        Serial.println(test, 14);
    }

} //setup()

void loop()
{
}
</code></pre>
",,17208674,821
13811322,2,13792760,2012-12-10T23:50:15.293,0,,507120,,2012-12-10T23:50:15.293,,0,,"<p>You sure that's what you want to do? If you are trying to read a number and then move the cursor I think you need to read until the user presses enter('\r') then convert your byte from read() into a integer.</p>

<pre><code>char align[100];
while(Serial.available() &amp;&amp; i&lt; 99) {
  align[i++] = Serial.read();
}
align[i++]='\0';
lcd.setCursor(atoi(align),0);
</code></pre>

<p>If this isn't what you want maybe add some sudo code comments so people can follow your train of thought.</p>
",,17237173,2084
13872412,2,13816590,2012-12-14T03:53:53.867,0,,124563,,2012-12-14T03:53:53.867,,0,,"<p>This is the code that worked in the end, but it also could have just been inconsistent behavior of the code loading onto the BlackWidow. I started to switch pins - each time I switched to try a new pin, it would work once, but only once, until I started power cycling the arduino. Seems it likes a power down instead of only a reset or new code upload. Still a bit finicky, but a working example of polling a URL for a specific last character. If 1 set pin high for 5.5 seconds. If 0 do nothing.</p>

<pre><code>#include &lt;WiServer.h&gt;

// ---------------------------------------------------------------------------------
// Wireless configuration parameters
// ---------------------------------------------------------------------------------
unsigned char local_ip[]    = {192,168,1,10};   // IP address of WiShield 192.168.1.10
unsigned char gateway_ip[]  = {192,168,1,1};    // router or gateway IP address
unsigned char subnet_mask[] = {255,255,255,0};  // subnet mask for the local network
char ssid[]                 = {""monitored""};    // max 32 bytes

// 0 - open; 1 - WEP; 2 - WPA; 3 - WPA2
unsigned char security_type = 3;    

// WPA/WPA2 passphrase
const prog_char security_passphrase[] PROGMEM = {""password""};   // max 64 characters

// WEP 128-bit keys
prog_uchar wep_keys[] PROGMEM = { 
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,   // Key 0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // Key 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // Key 2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    // Key 3
};

// setup the wireless mode
// infrastructure - connect to AP
// adhoc - connect to another WiFi device
#define WIRELESS_MODE_INFRA 1
#define WIRELESS_MODE_ADHOC 2
unsigned char wireless_mode = WIRELESS_MODE_INFRA;
unsigned char ssid_len;
unsigned char security_passphrase_len;


// ---------------------------------------------------------------------------------
// GET REQUEST
// ---------------------------------------------------------------------------------

// IP Address for macpro.local
uint8 ip[] = {192,168,1,12};
// The request URL
GETrequest getStatus(ip, 80, ""macpro.local"", ""/open-says-me/index.html"");

const int relayPin    = 3;
int relayControlState = LOW;

// ---------------------------------------------------------------------------------
// Callback for WiServer's getStatus
// ---------------------------------------------------------------------------------
void setRelayControlState(char* data, int len) {

    Serial.print(""[setRelayControlState] last digit of data: "");
    Serial.println(data[len-1]);

    Serial.print(""[setRelayControlState] len: "");
    Serial.println(len);

    if(len &gt; 0 
        &amp;&amp; data[len-1] == '1') {

        relayControlState = HIGH;
        Serial.print(""\nSET HIGH FOR 5.5s\n"");

        digitalWrite(relayPin, HIGH);
        delay(5500);
        digitalWrite(relayPin, LOW);

    }

}

void setup() {

    pinMode(relayPin, OUTPUT);
    Serial.begin(57600);

    // Initialize WiServer (we'll pass NULL for the page serving function since we don't need to serve web pages) 
    WiServer.init(NULL);

    // Enable Serial output and ask WiServer to generate log messages (optional)

    WiServer.enableVerboseMode(true);

    // Have the processData function called when data is returned by the server
    getStatus.setReturnFunc(setRelayControlState);

}

// Time (in millis) when the data should be retrieved 
long updateTime = 0;
void loop(){

    // Check if it's time to get an update
    if (millis() &gt;= updateTime) {
        // Get another update 15s from now
        updateTime += 1000 * 15;
        getStatus.submit();
        Serial.print(""end update @ ms "");
        Serial.println(millis());
    }

    WiServer.server_task();
    delay(100);
}
</code></pre>
",,17271738,917
14078427,2,13904268,2012-12-29T03:24:03.530,2,,1291935,,2012-12-29T03:24:03.530,,1,,"<p>I was able to successfully resolve this problem by using AttachInterrupt().</p>

<p>Specifically I found a <a href=""http://arduino.cc/forum/index.php/topic,105232.0.html"" rel=""nofollow"">library for IR Remotes that is interrupt based</a> instead of polling based as I was previously trying to use.</p>

<p>In case anyone is interested the finished RFID IR remote control cat feeder code is:</p>

<pre><code>/*** Cord Slatton
 * date 12-28-2012 **/

//IR includes
//info: http://www.zbotic.com/index.php/download/
//download: http://www.zbotic.com/index.php/download_file/view/12/118/
#include ""PCInterrupt.h""
#include ""Device.h""
#include ""irController.h""

#define RFID_ENABLE 8 //to RFID ENABLE
#define CODE_LEN 10 //Max length of RFID tag
#define START_BYTE 0x0A
#define STOP_BYTE 0x0D
#define MOTOR_RUN_LENGTH 1000 //time, in ms, to run door motor

char tag[CODE_LEN];
int pwm_b = 11; //PWM control for motor outputs 3 and 4 is on digital pin 11
int dir_b = 13; //direction control for motor outputs 3 and 4 is on digital pin 13
int door_status = 1; // 1 == closed, 0 == open
int manual_mode = 1; // 1 == auto, 0 == manual
//PIR sensor
const int sensorPIR = A0;
//IR init
int manualModePin = 10; //led pin for indication of manual mode
IRController irController;

unsigned long rfidHitTime = 0; //when did we get last rfid hit?
unsigned long pirHitTime = 0; //when did we get last PIR hit?
unsigned long pirClose = 0;
unsigned long rfidClose = 0;

void setup() {
  Serial.begin(2400); //parallax rfid reader seems to only like serial 2400  
  Serial.println(""RoboFeeder Online"");
  //rfid
  pinMode(RFID_ENABLE,OUTPUT);
  //motor
  pinMode(pwm_b, OUTPUT);
  pinMode(dir_b, OUTPUT);
  //PIR
  pinMode(sensorPIR, INPUT);
  digitalWrite(sensorPIR, LOW);
  Serial.println(""Warming up PIR..."");
  delay(10000);
  Serial.println(""PIR ready"");
  //IR remote
  pinMode(manualModePin, OUTPUT);
  digitalWrite(manualModePin, LOW);
  int res = irController.begin(IR_PIN, OTHER_DEVICE);
  if (res != SUCCESS) {
    Serial.println(""error="");
    Serial.println(res);
  }
  Serial.println(""IR Remote enabled"");

  Serial.println(""RoboFeeder startup test: Door"");
  openDoor();
  delay(2500);
  closeDoor();
  Serial.println(""RoboFeeder door test complete"");
}

void loop() {
  delay(1500);
  enableRFID(); 
  getRFIDTag(); //waiting function, till gets any tag

  disableRFID();
  openDoor();
  sendCode();

  Serial.flush();
  clearCode();
}

/*** Clears out the memory space for the tag to 0s. */
void clearCode() {
  for(int i=0; i&lt;CODE_LEN; i++) {
    tag[i] = 0; 
  }
}

/*** Sends the tag to the computer. */
void sendCode() {
    Serial.print(""TAG:"");
    for(int i=0; i&lt;CODE_LEN; i++) {
      Serial.print(tag[i]); 
    }
    Serial.println(""\r""); 
}

/**************************************************************/
/********************   RFID Functions  ***********************/
/**************************************************************/

void enableRFID() {
   digitalWrite(RFID_ENABLE, LOW);    
}

void disableRFID() {
   digitalWrite(RFID_ENABLE, HIGH);  
}

/*** Blocking function, waits for and gets the RFID tag. */
void getRFIDTag() {
  byte next_byte; 
  while(Serial.available() &lt;= 0) {
    if(door_status == 0){ //open
      pirDetection(); 
      rfidClose = millis() - rfidHitTime;
      pirClose =  millis() - pirHitTime;
      Serial.print(""RFID Close: "");
      Serial.print(rfidClose);
      Serial.print("" - PIR Close: "");
      Serial.println(pirClose);
      //if door has been open for more than a certain amount of time with no rfid hit and PIR no hit for certain time
      if( (rfidClose &gt; 40000) &amp;&amp; (pirClose &gt; 15000) ){
        closeDoor();     
      }
    }    
    IRRemote(); 
    if(manual_mode == 0)
      manualMode();   
  }
  //PIR set to current loop time to keep it from freaking out
  pirHitTime = millis();

  if((next_byte = Serial.read()) == START_BYTE) {      
    byte bytesread = 0; 
    while(bytesread &lt; CODE_LEN) {
      if(Serial.available() &gt; 0) { //wait for the next byte
          if((next_byte = Serial.read()) == STOP_BYTE) break;       
          tag[bytesread++] = next_byte;         
      }
    }
    rfidHitTime = millis(); //keep track of when last rfid hit was    
  }
}

/**************************************************************/
/********************   Motor Functions  ***********************/
/**************************************************************/

void openDoor() {
  if(door_status == 1){      
    motorRun(150);
    digitalWrite(dir_b, HIGH);  //Set motor direction, 1 low, 2 high
    Serial.println(""Door opening"");
    delay(MOTOR_RUN_LENGTH);
    motorStop();
    door_status = 1 - door_status;
  }
}

void closeDoor() {
  if(door_status == 0){    
    motorRun(150);
    digitalWrite(dir_b, LOW);  //Reverse motor direction, 1 high, 2 low
    Serial.println(""Door closing"");
    delay(MOTOR_RUN_LENGTH);
    motorStop();
    door_status = 1 - door_status; 
  }     
}

void motorRun(int speed) {
  analogWrite(pwm_b, speed);  //set motor to run at speed variable value
}
void motorStop() {
  analogWrite(pwm_b, 0);  //set motor to run at 0
}

/**************************************************************/
/********************   PIR Functions  ***********************/
/**************************************************************/

boolean pirDetection() {
  //returns true if PIR analog reading has been rising for more than 10 cycles, 
  //false if has been falling
  int counter = 0;
  int pirSensorReading[10];
  int avgReading = 0;
  while(counter &lt; 10){
    pirSensorReading[counter] = analogRead(sensorPIR);
    avgReading += pirSensorReading[counter];  
    counter++;
    delay(300);
  }
  avgReading = avgReading/10;
  Serial.print(""Avg. PIR: "");
  Serial.print(avgReading);
  Serial.print("" - Last PIR: "");
  Serial.println( pirSensorReading[9] );

  if( (pirSensorReading[9] &gt; avgReading+1) || (analogRead(sensorPIR) &gt; 700) ){
    pirHitTime = millis(); //keep track of when last PIR hit was
    return true;
  }
  else if(pirSensorReading[9] &lt;= avgReading){
    return false;
  }
}

/**************************************************************/
/********************   IR Remote Functions  ***********************/
/**************************************************************/

void IRRemote(){ 
  int val = irController.read(); // Returns negative value if no new command rcvd  
  if (val &gt;=0){
    Serial.print(""Key: "");
    Serial.println(val);
    if(val == 100){
      manual_mode = 1 - manual_mode;
    }    
    else if( (val &gt;= 0) &amp;&amp; (manual_mode == 0) ){
      if(door_status == 1)
        openDoor();
      else
        closeDoor();
    }
  }
  delay(500); 
}

//blocking function that won't let you leave till you turn off manual mode
void manualMode(){
  disableRFID();
  Serial.println(""Manual Mode on"");
  digitalWrite(manualModePin, HIGH);
  while(manual_mode == 0){
    IRRemote();
  }
  Serial.println(""Manual Mode exiting"");
  digitalWrite(manualModePin, LOW);
  //set sensors to count from now, esentially zero them out
  pirHitTime = millis();
  rfidHitTime = millis();
  enableRFID();
}    
</code></pre>
",,17330991,416
14087493,2,13909596,2012-12-30T01:26:04.647,0,,1478875,,2012-12-30T01:26:04.647,,0,,"<p>FYI, seems OK if I use this linker script:</p>

<pre><code>STARTUP(crt0.o)

SECTIONS {
    .init 0x8000 : {
        *(.init)
    }

    .text 0x9000 : {
        *(.text)
        *(.rodata)
        *(COMMON)
    }

    .data : {
        *(.data)
    }

    .bss : {
        *(.bss)
    }

    /DISCARD/ : {
        *(*)
    }
}
</code></pre>

<p>Hope this helps someone else in future</p>
",,17352942,102
13925809,2,13925772,2012-12-18T03:25:47.777,7,,14860,,2012-12-18T03:47:42.660,2012-12-18T03:47:42.660,1,,"<p>You're correct that <code>%c</code> requires a character (which an empty <code>''</code> is <em>not,</em> by the way).</p>

<p>But, if you're after zero-padding, just use the format specifier <code>""%02d""</code>? That's how you normally get zero-padded numbers. In other words, use:</p>

<pre><code>sprintf (timeStr, ""%02d/%02d/%04d %02d:%02d:%02d"",
    monthDay, month, year, hour, minute, second);
</code></pre>

<p>Many embedded systems may exclude floating point specifiers (or may make them optional) in order to preserve space but zero-padding or space-padding integers is a fairly simple operation that they all should have.</p>

<p>If you find an implementation so deficient that it <em>doesn't</em> support them, you can use strings instead of characters, since the empty string <em>is</em> valid:</p>

<pre><code>sprintf (timeStr, ""%s%d/%s%d/%d %s%d:%s%d:%s%d"",
    (monthDay &lt; 10) ? ""0"" : """",
    monthDay,
    :
    and so on ...
</code></pre>

<p>But I'm pretty certain Arduino isn't <em>that</em> deficient.</p>
",,17356368,4879
13956060,2,13953346,2012-12-19T15:49:58.583,2,,584518,,2012-12-19T15:49:58.583,,4,,"<p>A common reason why callback functions change their behavior when seemingly unrelated code is altered, is optimizer-related bugs.</p>

<p>Many embedded compilers fail to understand that a callback function (or an interrupt service routine) will ever be called in the program. They see no explicit call to that function and then assumes it is never called.</p>

<p>When the compiler has made such an assumption, it will optimize variables that are changed by the callback function, because it fails to see that the variable is changed by the program, between the point of initialization and the point of access.</p>

<pre><code>// Bad practice example:

int x; 

void main (void)
{
  x=5;
  ...

  if(x == 0) /* this whole if statement will get optimized away, 
                the compiler assumes that x has never been changed. */
  {
    do_stuff();
  }
}

void callback (void)
{
  x = 0;
}
</code></pre>

<p>When this bug strikes, it is nearly impossible to find, it can cause any kind of weird symptoms.</p>

<p>The solution is to <em>always</em> declare all file scope (""global"") variables shared between main() and an interrupt/callback/thread as <code>volatile</code>. This makes it impossible for the compiler to make incorrect optimizer assumptions.</p>

<hr>

<p>(Please note that the <code>volatile</code> keyword  cannot be used to achieve synchronization nor does it guarantee any memory barriers. <em>This answer is not in the slightest related to such issues!</em>)</p>
",,17394147,86
13962685,2,13962636,2012-12-19T22:59:59.530,1,,,user529758,2012-12-19T22:59:59.530,,4,,"<p>the <code>loop()</code> function is executed within an infinite loop (if you check the main cpp file that ships with the Arduino IDE, you'll see something like this:</p>

<pre><code>int main()
{
    setup();
    for (;;) {
        loop();
    }
    return 0;
}
</code></pre>

<p>So either put the call to your <code>moveForward()</code> function to <code>setup()</code> and make <code>loop()</code> an empty function, or call <code>exit(0);</code> from within <code>loop()</code> after <code>moveForward()</code>. The first approach looks like this:</p>

<pre><code>void setup()
{
    frontServo.attach(2);
    rearServo.attach(3);

    moveForward(5);
}

void loop()
{
}
</code></pre>

<p>And the second one looks like this:</p>

<pre><code>void setup()
{
    frontServo.attach(2);
    rearServo.attach(3);
}

void loop()
{
    moveForward(5);
    exit(0);
}
</code></pre>
",,17400954,3640
13964177,2,13962636,2012-12-20T02:00:16.030,0,,840992,,2012-12-20T02:00:16.030,,0,,"<p>Since you probably will want to eventually do more than move the robot just 5 steps, I'd suggest using a variable flag to hold the robot state. It only executes the movement routine when the flag has been set to true. </p>

<p>If you are using serial, when a move command is received (and the number of steps, direction perhaps?) you set the flag to true and then issue the move command. If you are using sensors or buttons, the same logic applies. </p>

<p>You will need some logic to handle an incoming movement command while a movement is occurring (though with your tight movement loop you actually won't be able to respond to incoming commands unless you use interrupts - but you want to consider this sort of thing if you are planning to build out a full movement bit of firmware).</p>

<pre><code>boolean shouldMove;

void setup()
{
 shouldMove = true;//set the flag
}

void loop()
{
  if (shouldMove){
    moveForward(5);
  }
}


void moveForward(int steps)
{
 shouldMove = false; //clear the flag
  for (int x = steps; steps &gt; 0; steps--) {
   // tight loop controlling movement
  }
}
</code></pre>

<p>}</p>
",,17461623,2402
13975127,2,13968217,2012-12-20T15:13:10.583,10,,1163019,,2012-12-21T12:01:42.920,2012-12-21T12:01:42.920,0,,"<p>Floating point support on ARM Linux distributions is not trivial. Because of that you should use a toolchain matching your system that is operating system &amp; hardware and use the right compile switches.</p>

<p>First thing you need to understand ARM's calling convention which is about <strong>""how arguments are passed when you call a function?""</strong>. ARM being a RISC architecture, can only work on registers. There are no instructions manipulating memory directly. If you need to change a value in memory you first need to load it to a register, modify it, then you need to store it back on the memory.</p>

<p>When you call a function you may need to pass arguments to it, you can put arguments on stack (memory) but since ARM can only work with registers first thing your function would probably do will be loading them back to registers. To avoid this waste ARM calling convention uses registers to pass arguments. However since ARM has a limited number of registers, calling convention also dictates you to use only first four (r0-r3) registers for the first four arguments, remaining must still use stack to be passed.</p>

<p>Second thing is early ARM cores didn't have any floating point support, operations where implemented in software. <em>(This is what is still supported via gcc's <code>-mfloat-abi=soft</code>.)</em> </p>

<p>We can easily demonstrate what this means via following snippet.</p>

<pre><code>float pi2(float a) {
    return a * 3.14f;
}
</code></pre>

<p>Compiling this via <code>-c -O3 -mfloat-abi=soft</code> and <code>obdump</code>ing gives us</p>

<pre><code>00000000 &lt;pi2&gt;:
   0:   f24f 51c3   movw    r1, #62915  ; 0xf5c3
   4:   b508        push    {r3, lr}
   6:   f2c4 0148   movt    r1, #16456  ; 0x4048
   a:   f7ff fffe   bl  0 &lt;__aeabi_fmul&gt;
   e:   bd08        pop {r3, pc}
</code></pre>

<p>As you can see (actually it is not visible :) ) <code>pi2</code> gets its parameter in <code>r0</code>, populates <code>pi constant</code> on <code>r1</code> and uses <code>__aeabi_fmul</code> to multiply those and return result in <code>r0</code>. Since <code>__aeabi_fmul</code> also uses same calling convention, details about <code>r0</code> is not visible. All our function does to populate <code>r1</code> and delegate it to <code>__aeabi_fmul</code>.</p>

<p>When floating hardware support added to ARM (again because of architecture style), it came with its own set of registers <em>(s0, s1, ...)</em>. </p>

<p>If we compile same snippet with <code>-c -O3 -mfloat-abi=softfp</code> and dump we get</p>

<pre><code>00000000 &lt;pi2&gt;:
   0:   eddf 7a04   vldr    s15, [pc, #16]  ; 14 &lt;pi2+0x14&gt;
   4:   ee07 0a10   vmov    s14, r0
   8:   ee27 7a27   vmul.f32    s14, s14, s15
   c:   ee17 0a10   vmov    r0, s14
  10:   4770        bx  lr
  12:   bf00        nop
  14:   4048f5c3    .word   0x4048f5c3
</code></pre>

<p>As you can see now compiler doesn't create a call to <code>__aeabi_fmul</code> but instead it creates a <code>vmul.f32</code> instruction after it moves argument located in <code>r0</code> to <code>s14</code> and populates <code>3.14</code> on <code>s15</code>. After multiplication instruction it moves result available in <code>s14</code> back to <code>r0</code> <strong>since any caller of this function would expect it because of the calling convention</strong>.</p>

<p>Now if you think <code>pi2</code> as a library provided to you by some third party, you can understand that both soft and softfp implementations do the same thing for you and you can use them interchangeably. If system provides them for you, you wouldn't care if your app runs on a system with hardware floating point support or not. This was quite good to keep old software running on new hardware.</p>

<p>However while keeping compability this approach introduces the overhead of moving values between ARM registers and FP registers. This obviously effects performance and addressed by a new calling convention, called <code>hard</code> by <code>gcc</code>. This new convention states that if you have floating point arguments in your function you can utilize floating point registers interleaved with normal ones, as well as you can return floating point values in floating point register <code>s0</code>.</p>

<p>Again if we compile our snippet with <code>-c -O3 -mfloat-abi=hard</code> and dump we get</p>

<pre><code>00000000 &lt;pi2&gt;:
   0:   eddf 7a02   vldr    s15, [pc, #8]   ; c &lt;pi2+0xc&gt;
   4:   ee20 0a27   vmul.f32    s0, s0, s15
   8:   4770        bx  lr
   a:   bf00        nop
   c:   4048f5c3    .word   0x4048f5c3
</code></pre>

<p>You can see there is no registers getting moved around. Argument to <code>pi2</code> gets passed in <code>s0</code>, compiler created code to populate <code>3.14</code> in <code>s15</code> and uses <code>vmul.f32 s0, s0, s15</code> to get result we want in <code>s0</code>.</p>

<p>Big problem with this new convention is while you improve the code produced by compiler you completely kill compability. You can't expect an application built with <code>hard</code> convention to work with libraries built for <code>soft/softfp</code> and an application built for softfp won't work with libraries built for hard.</p>

<p>For more information on calling conventions you should check <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/index.html"" rel=""noreferrer"">ARM's website</a>.</p>
",,17537757,866
14045137,2,14045105,2012-12-26T19:19:11.193,4,,707111,,2012-12-26T19:35:33.800,2012-12-26T19:35:33.800,1,,"<p>Keep a variable that holds the last state:</p>

<pre><code>void setup() {
    // initialize serial communication at 9600 bits per second:
    Serial.begin(9600);
}

int wasLit = 0;

// the loop routine runs over and over again forever:
void loop() {
    // read the input on analog pin 0:
    int sensorValue = analogRead(A0);

    // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
    float voltage = sensorValue * (5.0 / 1023.0);

    // print out the value you read:
    if (!wasLit &amp;&amp; voltage &gt; 1.5) {
        wasLit = 1;
        Serial.print(""Light"");
        Serial.println();
        delay(5000);
    } else if(wasLit &amp;&amp; voltage &lt;= 1.5) {
        wasLit = 0;
        Serial.print(""No Light"");
        Serial.println();
        delay(50);
    }
}
</code></pre>
",,17552469,1458
14087683,2,14045105,2012-12-30T02:07:05.757,0,,1927972,,2012-12-30T02:07:05.757,,0,,"<p>This sort of test will benefit from use of hysterisis.  Especially if you have flourescent light, there will be some flicker.  That will cause the sensor reading to vary such that it may not change from &lt;1.5 to >=1.5 in a clean manner.</p>

<pre><code>boolean bLast = false;

const float vTrip = 1.5;
// you find a good value for this by looking at the noise in readings
// use a scratch program to just read in a loop  
// set this value to something much larger than any variation
const float vHyst = 0.1;

float getLight() {
    int sensorValue = analogRead(A0);
   // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
   float voltage = sensorValue * (5.0 / 1023.0);
   return voltage;
}

void setup() {
    // establish the initial state of the light
    float v = getLight();
    bLast = ( v &lt; (vTrip-vHyst) );
}

void loop() {
    float v = getLight();
    if( bLast ) {
        // light was on
        // when looking for decreasing light, test the low limit
        if( v &lt; (vTrip-vHyst) ) {
             bLast = false;
             Serial.print(""Dark"");
        }
    }
    else {
        // light was off
        // when looking for increasing light, test the high limit
        if( v &gt; (vTrip+vHyst) ) {
            bLast = true;
            Serial.print(""Light"");
        }
    }
}
</code></pre>
",,17646377,601
14073679,2,14063588,2012-12-28T17:58:36.740,1,,877375,,2012-12-28T19:02:46.913,2012-12-28T19:02:46.913,0,,"<p>I believe the problem is caused because your PC is looking for 4 chars and the Arduino is sending 3-6 chars per request.</p>

<p>I would recommend you receive chars into your buffer until you receive the carriage return (\r) sent by the Arduino. Then you can output the complete string. You will need to handle the control characters.</p>

<p>Untested example:</p>

<p>Replace </p>

<pre><code>oSerial.ReadData(buf0,4);
</code></pre>

<p>With</p>

<pre><code>int x=0;
int char_rev;

while(buf0[x]!='\r') {

    char_rev = oSerial.ReadData(buf0[x],1);
    if (char_rev==1) {
        x++;
    }
}
buf0[x]=0;
</code></pre>
",,17662518,28460
14074024,2,14073139,2012-12-28T18:27:26.957,2,,507519,,2012-12-28T18:27:26.957,,5,,"<p>I see two potential solutions to your problem, if you do not need sub-second accuracy in the measurement intervals:</p>

<ol>
<li><p>Wrap the contents of <code>main()</code> apart from the calibration in a loop and include a <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/sleep.html"" rel=""nofollow""><code>sleep()</code></a> call with an argument of 1800 seconds:</p>

<pre><code>int main(int argc, char **argv) {
    bmp085_Calibration();

   int count;

   for (count = 0; count &lt; 49; ++count) {
       temperature = bmp085_GetTemperature(bmp085_ReadUT());
       pressure = bmp085_GetPressure(bmp085_ReadUP());
       altitude = bmp085_Altitude(pressure);

       printf(""Temperature\t%0.1f *F\n"", ((double)temperature)/10 * 1.8 + 32);
       printf(""Pressure\t%0.2f hPa\n"", ((double)pressure)/100);
       printf(""Altitude\t%0.1f Feet\n"", ((double)altitude)*3.280839895);

       sleep(1800);
   }

   return 0;
}
</code></pre>

<p>You may need to reset a few things for a second measurement to happen within the same program. You may also want to check the return value of <code>sleep()</code> to catch a potential premature end to that function call...</p></li>
<li><p>Since you are using Linux as the OS in your device, you can use a wrapper script around your program:</p>

<pre><code>#!/bin/bash

while true; do
    /path/to/your/program &gt;&gt; measurements.log

    sleep 1800 
done
</code></pre>

<p>I will leave the termination after 48 hours as an exercise to the reader...</p></li>
</ol>
",,17675127,9998
14074065,2,14073139,2012-12-28T18:31:29.587,2,,1935103,,2012-12-28T18:54:18.413,2012-12-28T18:54:18.413,1,,"<p>Looks like you do not have any looping in your <code>MAIN()</code> routine. Since you want it to record the data every 30 minutes, you want MAIN to loop continuously, imo.</p>

<p>I don't know much/anything about Raspberry PI, I do know about Arduino however, and the main entry point routine is called automatically, which I presume is that same here, called <code>MAIN()</code>.</p>

<p>You could simple wrap the guts of <code>MAIN()</code> in a loop and use a sleep for 30 minutes. If you find that instead you wanted to do other activities while looping MAIN but still only want to record every 30 minutes, then you could store a variable <code>lastTimeDataStored</code> and compare that each time through loop; once its equal/greater than 30 minutes then store data and reset variable to current time.</p>

<pre><code>int main(int argc, char **argv)

{

   bmp085_Calibration();

   while (true) //loop indefinitely
   {
     temperature = bmp085_GetTemperature(bmp085_ReadUT());
     pressure = bmp085_GetPressure(bmp085_ReadUP());
     altitude = bmp085_Altitude(pressure);

     printf(""Temperature\t%0.1f *F\n"", ((double)temperature)/10 * 1.8 + 32);
     printf(""Pressure\t%0.2f hPa\n"", ((double)pressure)/100);
     printf(""Altitude\t%0.1f Feet\n"", ((double)altitude)*3.280839895);

     //either sleep for 30 minutes or check variable to see if 30 minutes has passed
     usleep((1000*60)*30); //sleep 30 minutes
   }

   return 0;
}
</code></pre>
",,17685947,341
14077548,2,14077456,2012-12-29T00:33:41.410,1,,298054,,2012-12-29T00:55:57.747,2012-12-29T00:55:57.747,0,,"<p>Looks like the <code>CapacitiveSensor</code> class does not define a default constructor, therefore the <code>Input</code> class doesn't know how to construct <code>upButton</code> and <code>downButton</code>.</p>

<p>An option is to initialise <code>upButton</code> and <code>downButton</code> in the <code>Input</code> constructor, passing the required arguments:</p>

<pre><code>class Input {
public:
    Input(byte sPin, byte rPin1, byte rPin2)
        : upButton(CapacitiveSensor(sPin, rPin1))
        , downButton(CapacitiveSensor(sPin, rPin2))
    {}
    CapacitiveSensor upButton;
    CapacitiveSensor downButton;
};
</code></pre>

<p>Another option is to transform those members in pointers, and use <code>new</code> to allocate them with the required arguments. Example:</p>

<pre><code>class Input {
public:
    Input() : upButton(NULL), downButton(NULL) {}
    void initializeMembers(byte sPin, byte rPin1, byte rPin2) {
        upButton = new CapacitiveSensor(sPin, rPin1);
        downbutton = new CapacitiveSensor(sPin, rPin2);
    }
    CapacitiveSensor *upButton;
    CapacitiveSensor *downButton;
};
</code></pre>

<p>Or ultimately, you could extend the <code>CapacitiveSensor</code> class, define a default constructor, and pass fixed arguments to the super constructor. I believe that is not what you want, but anyway:</p>

<pre><code>class CustomCapacitiveSensor : public CapacitiveSensor {
public:
    CustomCapacitiveSensor() {
        CapacitiveSensor(1, 2);
    }
};
</code></pre>
",,17751216,5077
14079716,2,14077456,2012-12-29T07:33:02.203,1,,1927972,,2012-12-29T07:33:02.203,,0,,"<p>To use the code you have shown, the CapacitiveSensor class would have to have both a default constructor that takes no parameters and an equals operator overload (assignment).  That is unlikely what you want as it is wasteful as it constructs a temporary object, then assigns it back to the class member.</p>

<p>To construct member objects you use this code:</p>

<pre><code>Input::Input(byte sPin, byte rPin1, byte rPin2) :
  upButton(sPin, rPin1), downButton(sPin, rPin2)
{
...
}
</code></pre>

<p>This will construct the two object instances directly.</p>
",,17758384,984
14092282,2,14091998,2012-12-30T16:15:36.460,1,,1288598,,2012-12-30T16:15:36.460,,0,,"<p>So while I have concerns about how the serial reading is mixed in with the display driving, here's how you might change the serial reading to read as string:</p>

<p>The serial reading part:</p>

<pre><code>if(Serial.available()) {    
...
}
</code></pre>

<p>Is just reading single characters. You need to store those in a buffer instead.</p>

<p>Change:</p>

<pre><code>char serIn; //var that will hold the bytes in read from the serialBuffer
</code></pre>

<p>To:</p>

<pre><code>char serIn[40]; //buffer that will hold the bytes in read from the serialBuffer
</code></pre>

<p>And then the serial loop:</p>

<pre><code>if(Serial.available()) {  
    int chars_in = 0;
    //keep reading and printing from serial untill there are bytes in the serial buffer
    while (Serial.available()&gt;0 &amp;&amp; chars_in&lt;39){
        serIn[chars_in] = Serial.read();    //read Serial   
        Serial.write( byte(serIn[chars_in]));
        chars_in++;
    }
    serIn[chars_in] = 0;
    //the serial buffer is over just go to the line (or pass your favorite stop char)               
    Serial.println();
}
</code></pre>
",,17789120,1755
26689577,2,14146850,2014-11-01T13:03:39.677,0,,4204454,,2014-11-01T13:03:39.677,,0,,"<p>I did this one:</p>

<pre><code>unsigned char buffer[32];

void setup() {
  serial.begin();
}

void loop() {
  if(serial.available()) {
    int size = serial.read(buffer);
    if (size!=0) {
      //serial.write((const uint8_t*)buffer, size);
      int bright = atoi((char *) buffer);

      //int final = ((unsigned int)buffer[0]);

      //int final = bright -'0';
      serial.write(bright);
      serial.write('\n');
    }
  }
  serial.poll();
}
</code></pre>

<p>and now i get an ascii char when i send a value from 0-255 through the usb.
I should find a way to convert the ascii char to int.</p>

<p>e.g i type 65 and it prints A</p>
",,17791876,24676
36096894,2,14146850,2016-03-19T01:43:11.577,0,,663416,,2016-03-19T01:43:11.577,,0,,"<p>I have some old code that might help if you want to avoid the printf entirely and simply need to print with a given number of digits before and after the decimal. This code compiles in C and works fine in the Arduino IDE as well. It could almost certainly be done in fewer lines of C++. The pow10 could be done programmatically, but powers weren't supported in the version of C I was working with:</p>

<pre><code>#include &lt;stdio.h&gt;

/*
Because lcd and serial don't support printf, and its very costly, and all we need
is simple formating with a certain number of digits and precision, this ftoa is enough.
If digits is negative, it will pad left.
*/
#define  BUF_LEN 20
char buf[BUF_LEN]; //need a buffer to hold formatted strings to send to LCD

int ftoa(char * str, float f, char digits, char precision) {
char i=0,k,l=0;
long a,c;
long pow10[10] = {1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
unsigned char b;
char decimal='.';

  if(digits&gt;=10) {return 0;};
  // check for negative float
  if(f&lt;0.0) {
    str[i++]='-';
    f*=-1;
    (0&lt;digits?digits--:digits++);
    }
  a=(int)f; // extracting whole number
  f-=a; // extracting decimal part
  k = digits;
  // number of digits in whole number
  while(k&gt;=0)   {
    c = pow10[k];
    c = a/c;
    if(c&gt;0) { break; }
    k--;
    } // number of digits in whole number are k+1
  if (0&lt;k &amp;&amp; digits==k &amp;&amp; c&gt;10) { //overflow
    decimal = 'e';
    }
/*
extracting most significant digit i.e. right most digit , and concatenating    to string
obtained as quotient by dividing number by 10^k where k = (number of digit -1)
*/
  for(l=abs(k);l&gt;=0;l--){
    c = pow10[l];
    b = a/c;
    str[i++]=(l&amp;&amp;!b?' ':b+48); //digit or pad
    a%=c;
    }
  if (precision) {str[i++] = decimal;};
/* extracting decimal digits till precision */
  if (0&gt;precision) {k=0; precision=abs(precision);}
  for(l=0;l&lt;precision;l++) {
    f*=10.0;
    b = (int)f; //math floor
    str[i++]=b+48; //48 is ASCII 0
    f-=(float)b;
    if (!k &amp;&amp; 0==f) { break; } //nothing left, save chars.
    //won't work if there are any floating point errors.
    }
  str[i]='\0';
  return i;
  }
</code></pre>

<p>You can play with it and see it run here:
<a href=""http://ideone.com/AtYxPQ"" rel=""nofollow"">http://ideone.com/AtYxPQ</a></p>
",,17796344,24663
14166964,2,14165995,2013-01-05T00:00:10.833,2,,116908,,2013-01-05T00:06:59.560,2013-01-05T00:06:59.560,4,,"<p>It's pretty easy if you just use base 2 as an intermediate.  You can convert from a string in any base to base 2 like this:</p>

<pre><code>int x = strtol(""12345"", NULL, 10); // convert from base 10 string to integer
int y = strtol(""12345"", NULL, 12); // convert from base 12 string to integer
</code></pre>

<p>Then to convert <em>to</em> base 10 is trivial:</p>

<pre><code>sprintf(buf, ""%d"", y); // convert from integer to base 10 string
</code></pre>

<p>To print out a number in base 12 is a bit tougher - there isn't a built-in function that already does it, so you need to write your own (with some helpers to keep things clean):</p>

<pre><code>void reverse(char *s)                // reverse a string in place
{
    char *e = s + strlen(s) - 1;     // find the end of the string
    char tmp;
    while (s &lt; e)                    // loop to swap characters and move pointers
    {                                // towards the middle of the string
        tmp = *e;
        *e-- = *s;
        *s++ = tmp;    
    }
}

char digit(int x)        // turn an integer into a single digit
{
    if (x &lt; 10)
        return '0' + x;       // 0-9
    else
        return 'a' + x - 10;  // a, b, c, d, e, f, g....
}

void tobase(char *s, int x, int base) // convert an integer into a string in
{                                     // the given base
    int r;
    char *p = s;
    while (x)
    {
        r = x % base;    // extract current digit
        x = x / base;    // divide to get lined up for next digit
        *p++ = digit(r); // convert current digit to character
    }
    *p = '\0';           // null terminate the string
    reverse(s);          // and reverse it, since we generated the digits 
}                        // backwards
</code></pre>

<p>You'd use it like:</p>

<pre><code>tobase(buf, x, 12); // convert from integer to base 12 string
</code></pre>

<p>You probably want to add better error handling than I have there - I was shooting for a short implementation for purposes of fitting it here cleanly.</p>
",,17837104,3953
14179224,2,14179035,2013-01-06T04:15:33.543,13,,1020072,,2013-01-06T04:38:13.577,2013-01-06T04:38:13.577,0,,"<p>Lets look at how MSVC compiles your code in debug mode, as you seem to be compiling it...</p>

<pre><code>unsigned int max = 1000000000L;
    011643BE  mov         dword ptr [max],3B9ACA00h  
for (unsigned int i=0; i&lt;max; i++)
    011643C5  mov         dword ptr [ebp-14h],0  
    011643CC  jmp         main+37h (011643D7h)  
    011643CE  mov         eax,dword ptr [ebp-14h]  
    011643D1  add         eax,1  
    011643D4  mov         dword ptr [ebp-14h],eax  
    011643D7  mov         eax,dword ptr [ebp-14h]  
    011643DA  cmp         eax,dword ptr [max]  
for (unsigned int i=0; i&lt;max; i++)
    011643DD  jae         main+4Eh (011643EEh)  
{
    n++;
    011643DF  mov         eax,dword ptr ds:[0116F218h]  
    011643E4  add         eax,1  
    011643E7  mov         dword ptr ds:[0116F218h],eax  
}
011643EC  jmp         main+2Eh (011643CEh)  
</code></pre>

<p>Ok, now lets see that in release mode...</p>

<pre><code>unsigned int max = 1000000000L;
for (unsigned int i=0; i&lt;max; i++)
    00FC1270  mov         eax,dword ptr ds:[00FC4430h]  
{
    n++;
}
std::cout &lt;&lt; n;
    00FC1275  mov         ecx,dword ptr ds:[0FC3030h]  
    00FC127B  add         eax,3B9ACA00h  
    00FC1280  push        eax  
    00FC1281  mov         dword ptr ds:[00FC4430h],eax  
    00FC1286  call        dword ptr ds:[0FC3038h] 
</code></pre>

<p>Notice the difference? The release mode has completely <strong>optimized out the loop</strong>.</p>

<p>Ok, now lets switch gears and see how Arduino does this. Get ready for some AVR asm...</p>

<pre><code>for(i=0; i&lt;1000000000; i++)
{
 n++;
}
Serial.println(n);
    d8: c8 01           movw    r24, r16
    da: 40 e0           ldi r20, 0x00   ; 0
    dc: 5a ec           ldi r21, 0xCA   ; 202
    de: 6a e9           ldi r22, 0x9A   ; 154
    e0: 7b e3           ldi r23, 0x3B   ; 59
    e2: 2a e0           ldi r18, 0x0A   ; 10
    e4: 30 e0           ldi r19, 0x00   ; 0
    e6: 0e 94 c4 04     call    0x988   ; 0x988 &lt;_ZN5Print7printlnEli&gt;
</code></pre>

<p>Whoa! It optimized the loop out as well! The compiler is a smart little bugger, innit?!?!</p>

<p>...And when you think about it, isn't .0007 seconds a little bit quick to perform that long of a loop? That's only enough time for about 43 clock cycles -- barely enough to call <code>Serial.println()</code>.</p>
",,17871338,64345
14307104,2,14307087,2013-01-13T19:11:55.903,1,,440558,,2013-01-13T19:11:55.903,,0,,"<p>You must place a declaration of the function <code>flash</code> before it's being used.</p>

<p>Either place a <em>prototype</em> of the function before the <code>loop</code> function, like this:</p>

<pre><code>void flash(int numFlashes, int d);

void loop
{
    /* .... */
}
</code></pre>

<p>Or you place the whole function definition before the <code>loop</code> function.</p>

<p>And by the way, you have a closing parenthesis to much in the function header. Which of these problems is the real culprit is hard to say without seeing the errors.</p>
",,17892688,3265
14346760,2,14346650,2013-01-15T20:55:41.150,1,,10631,,2013-01-15T21:01:36.637,2013-01-15T21:01:36.637,0,,"<p>It's been a while isnce I've done much C/C++ but I believe spawning a new process is done via popen. Eg:</p>

<pre><code>FILE* pOutput = popen(""/usr/bin/python myscript.py"", ""r"");
  while ( fgets(line, 199, pOutput) )
  {
    printf(""%5d: %s"", entry++, line);
  }
</code></pre>

<p>From another post on S/O it seems you can write to the FILE* returned by popen if you open the proc in write mode:</p>

<pre><code>FILE * file = popen(""/bin/cat"", ""w"");
fwrite(""hello"", 5, file);
pclose(file);
</code></pre>
",,17907783,144
14410224,2,14397064,2013-01-19T01:30:21.363,1,,1927972,,2013-01-19T04:58:05.283,2013-01-19T04:58:05.283,2,,"<p>You can't quite get what you want, but you can get what you need.  To provide array access to the set of objects, create an array of pointers</p>

<pre><code>Class MyClass {
public:
    MyClass(int par);
    SomeClass B0;
    SomeClass B1
    SomeClass* B[2];
</code></pre>

<p>Then initialize the pointers in your constructor:</p>

<pre><code>MyClass::MyClass(int par) :
  B0(123), B1(456)
{
    B[0] = &amp;B0;
    B[1] = &amp;B1;
}
</code></pre>

<p>This is clearly tedious for more than a small number of objects, but fine for anything you are likely to do on a microcontroller.
Now you have an array of object pointers that can be used as you need:</p>

<pre><code>for(i=0; i&lt;2; i++) {
    B[i]-&gt;foo();
}
</code></pre>

<p>Note that you are consuming additional memory for a pointer to each object.</p>
",,17910397,2000
14411826,2,14411808,2013-01-19T06:33:30.677,4,,964135,,2013-01-19T06:33:30.677,,1,,"<p>You wrote the initialization for a 4d array as RGB has 3 components. You probably want to do something like this:</p>

<pre><code>struct rgb {
  int r, g, b;
};

rgb gpsHoldArr[4][6][6] = {
  {
    {{255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}}
},
  {
    {{255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}}
},
  {
    {{255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}}
},
  {
    {{255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {0,0,0}},
    {{255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}, {255,0,0}}
},
};
</code></pre>

<p>Or, change your declaration to this:</p>

<pre><code>int gpsHoldArr[4][6][6][3]
</code></pre>
",,17932313,1281
14411891,2,14411808,2013-01-19T06:47:47.950,3,,1927972,,2013-01-19T06:47:47.950,,0,,"<p>Use a byte and cut the memory usage in half</p>

<pre><code>typedef struct rgb_t {
  byte r;
  byte g;
  byte b;
};

rgb_t gpsHoldArr[4][6][6] = {
</code></pre>
",,18007064,4158
14413836,2,14413372,2013-01-19T11:26:26.220,0,,790993,,2013-01-19T11:26:26.220,,0,,"<p>Actually I just get it to work, by looking into another library :P
instead of </p>

<pre><code> #include &lt;WProgram.h&gt;
</code></pre>

<p>We should use </p>

<pre><code>#if ARDUINO &gt;= 100
#include ""Arduino.h""
#else
#include ""WProgram.h""
#endif
</code></pre>

<p>Which is bad for backward compatibility as I think...</p>

<p>And it's <strong>not</strong> a problem regarding using libraries in sketch folder. There're some potential problems with sketch folder libraries however.</p>
",,18040393,4149
14416356,2,14416331,2013-01-19T16:29:48.337,1,,1520364,,2013-01-19T16:36:21.530,2013-01-19T16:36:21.530,3,,"<p>You are passing in a 2D array when your function exists a 1D array (decayed to a pointer).</p>

<p>Can I suggest eliminating array dimmensions by making structs/classes, it will make stuff much clearer. </p>

<p>for e.g</p>

<pre><code>struct Led{
    int r,g,b;
};

void toggleLights(Led lights[]){

Led gpsHoldArr[4][6][6] = 

set_color_led(i, lights[i].r, lights[i].g, lights[i].b);
</code></pre>

<p>That should be all the changes you need to make, the rest <em>should</em> work as-is.</p>

<p>You can go further and make an arm <code>struct</code> and a step <code>struct</code> as well.</p>
",,18133172,155
14416785,2,14416331,2013-01-19T17:17:43.963,1,,1991060,,2013-01-19T18:50:06.417,2013-01-19T18:50:06.417,3,,"<p>I don't think that <code>toggleLights()</code> is doing what you think it is doing. Its input is a 1-D array, but you are passing it a 2-D array of size [6][3]. When <code>toggleLights(gpsHoldArr[0][0]);</code> is called, the 1-D memory array that the function sees is <code>{255,0,0,0,0,0}</code>, i.e. the first six values in your array. Then, for each of these values you are calling <code>set_color_led();</code> and passing the same value for multiple arguments. Unrolling the loop in <code>toggleLights()</code>, this translates to</p>

<pre><code>// set_color_led(i, lights[i], lights[i], lights[i]) for i = {0, ..., 6}
set_color_led(0, 255, 255, 255);
set_color_led(1, 0, 0, 0);
set_color_led(2, 0, 0, 0);
set_color_led(3, 0, 0, 0);
set_color_led(4, 0, 0, 0);
set_color_led(5, 0, 0, 0);
set_color_led(6, 0, 0, 0); // bug here as noted by molbdnilo
</code></pre>

<p>This is probably not what you want. I would change the definition of <code>toggleLights()</code> to the following:</p>

<pre><code>void toggleLights(int lights[][3]){
  for(int i = 0; i &lt; 6; ++i)
  {
    set_color_led(i, lights[i][0], lights[i][1], lights[i][2]);
  } 
}
</code></pre>

<p>In this case when calling <code>toggleLights(gpsHoldArr[0][0]);</code>, the 2-D array that this function see is </p>

<pre><code>{{255,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}, {0,0,0}}
</code></pre>

<p>and unrolling the loop in <code>toggleLights()</code>, this translates to the following series of function calls:</p>

<pre><code>// set_color_led(i, lights[i][0], lights[i][1], lights[i][2]) for i = {0, ..., 5}
set_color_led(0, 255, 0, 0);
set_color_led(1, 0, 0, 0);
set_color_led(2, 0, 0, 0);
set_color_led(3, 0, 0, 0);
set_color_led(4, 0, 0, 0);
set_color_led(5, 0, 0, 0);
</code></pre>
",,18158136,8385
14417155,2,14416331,2013-01-19T17:59:35.797,2,,404970,,2013-01-19T17:59:35.797,,3,,"<p>I would probably go about it like this, removing some repetition along the way.<br>
(Macro trickery only because of Arduino - on a desktop I would use classes instead of arrays.)</p>

<pre><code>struct LED { int r, g, b; };

#define BLACK  {0, 0, 0}
#define RED    {255, 0, 0}

#define DEFAULT_LEDS \
  { {RED, BLACK, BLACK, BLACK, BLACK, BLACK},\
    {RED, RED,   BLACK, BLACK, BLACK, BLACK},\
    {RED, RED,   RED,   BLACK, BLACK, BLACK},\
    {RED, RED,   RED,   RED,   BLACK, BLACK},\
    {RED, RED,   RED,   RED,   RED,   BLACK},\
    {RED, RED,   RED,   RED,   RED,   RED}}

LED gpsHoldArr[4][6][6] = {
   DEFAULT_LEDS,
   DEFAULT_LEDS,
   DEFAULT_LEDS,
   DEFAULT_LEDS
};


void set_color_led(int index, const LED&amp; led){
   Serial.println(index); //Which LED (or ""pixel"") is it?
   Serial.println(led.r); //What is the red value?
   Serial.println(led.g); //What is the green value?
   Serial.println(led.b); //What is the blue value? 
}

void toggleLights(LED (&amp;leds)[6]){
  for(int i = 0; i &lt; 6; ++i)  // You had a '&lt;=' bug here.
  {
    set_color_led(i, leds[i]);
  } 
}

toggleLights(gpsHoldArr[0][0]); //Toggles lights on strip #1, step #1
</code></pre>
",,18160980,1094
14435647,2,14435589,2013-01-21T09:24:40.057,0,,1520364,,2013-01-21T09:39:56.220,2013-01-21T09:39:56.220,8,,"<p>Do you need to start moving definitions of functions into .cpp files? Looks like you are accessing the internals of interuptbutton before its defined.</p>

<p>Or since it is just 1 big .cpp file, you can <strong>define the <code>run</code> function just before main</strong> to fix your second set of errors.</p>

<p>First error is self explanatory, maybe you should make a <strong>Interrupt interface</strong> and keep pointers to it, instead of to <code>void*</code>? <code>reinterpret_cast</code>ing just makes everything so ugly.</p>

<pre><code>class IInterupt{
 // other stuff common to all interupt classes
    void pollInterupt() = 0; // pure virtual force all inheriting classes to implement.   
}

class interuptButton : public IInterupt{ //bla bla }

 class node{
        public:
            node *next;
            node *prev;
        public:
            IInterupt*interupt;
    };
</code></pre>
",,18175353,1993
14435682,2,14435589,2013-01-21T09:27:09.737,0,,440558,,2013-01-21T09:40:09.997,2013-01-21T09:40:09.997,7,,"<p>In the <code>node</code> structure, the <code>interrupt</code> pointer is a pointer to <code>void</code> which means that it can point to any type. However, the compiler doesn't know what it points to, so you have to tell the compiler what type it <em>really</em> points to by using typecasting:</p>

<pre><code>reinterpret_cast&lt;interuptButton*&gt;(current-&gt;interrupt)-&gt;pollInterrupt();
</code></pre>

<p>As for the other problem, you have a circular dependency. The class <code>interruptHandler</code> depends on the class <code>interruptButton</code> and the other way around. This you have to solve by separating the definition and the implementation of one or both classes. The simplest way would be to just put the <code>interruptButton</code> class definition above the <code>interruptHandler</code> definition, and place the implementation, i.e. the actual code, of <code>interruptButton</code> after the <code>interruptHandler</code> class definition.</p>

<hr>

<p>If you want to use multiple interruptable classes, not only the <code>interruptButton</code> class, you should use inheritance and abstract base classes with virtual functions. Then you won't need the <code>void</code> pointer or typecasting:</p>

<pre><code>struct baseIntertuptable
{
    virtual void pollInterrupt() = 0;
};

struct interruptHandler
{
private:
    struct node
    {
        // ...
        baseInterruptable* interrupt;
    };

public:
    void run()
    {
        // ...
        current-&gt;interrupt-&gt;pollInterrupt();
        // ...
    }
};

class interruptButton : public baseInterruptable
{
public:
    void pollInterrupt()
    {
        // ...
    }
};
</code></pre>

<p>This should also solve your problem with the circular dependencies of the class definitions, as the abstract base class <code>baseInterruptable</code> is now fully defined before it's used and the <code>interruptHandler</code> class only uses that one.</p>
",,18192691,712
14442650,2,14442040,2013-01-21T16:10:34.257,0,,284393,,2013-01-21T16:18:21.553,2013-01-21T16:18:21.553,0,,"<p>This should do:</p>

<pre><code>class ClassB {
public:
    void setUrl(char *url){strncpy(url_, url, 80);}
    char *getUrl(char *url){return url_;}
private:
    char[80] url_; 
};

class ClassA 
{ 
public:
   char *getUrl(){return classB.getUrl();}
private:
    ClassB classB; 
};

ClassA classA;

void setup()
{

}

void loop()
{
    char *url = classA.getUrl();
    Serial.println(url);
    delay(1000);
}
</code></pre>

<p>If this doesn't do the trick for you, please give us more detail of what you are trying to achieve that is not covered by this code example. Why a class in a class? Why use malloc? ...</p>
",,18198686,390
14457974,2,14442040,2013-01-22T11:55:30.970,0,,284393,,2013-01-22T12:02:00.377,2013-01-22T12:02:00.377,2,,"<p>Here it is:</p>

<pre><code> class ClassB
 {
 public:

    ClassB()
    {
        strcpy(_someString, ""my_url"");
    }

    void generateUrl(char *url)
    {
        strcpy(url, _someString);

        //char* someString = (char*) malloc(...);
        // something...
        //return someString;
    }
private:
    char _someString[80];
};

class ClassA{
public:
    void getMyUrl(char *url)
    {
        ClassB b;
        b.generateUrl(url);
        //return b.generateUrl();
    }
};

void developerMethod()
{
    ClassA a;
    //char* url = a.getMyUrl();
    char url[80];
    a.getMyUrl(url);
    print(url);
}
</code></pre>

<p>Essentially you have to understand that you need to use strcpy, to move the content of the char-pointer from the interior memory of your class to the developerMethod(). By doing so, you can then delete all other class references and their memory because you are now independent of that memory. That approach is already outlined in my first answer, but now you have it all the way to the ""top"" call. I'm happy to explain more, but I'm getting to the point where it becomes difficult to find more to explain.</p>
",,18246244,1226
14465322,2,14464713,2013-01-22T18:15:51.157,5,,547981,,2013-01-22T18:15:51.157,,0,,"<p>You should use the helper macros <code>_SFR_IO_ADDR()</code> and <code>_SFR_MEM_ADDR()</code> to access SFRs using i/o and memory instructions, respectively, because they have different addresses in the two namespaces. The default is apparently memory mapped, but don't count on it.</p>

<p>As such your code could look like:</p>

<pre class=""lang-none prettyprint-override""><code>#include ""avr/io.h""

.global main

main:
    ldi r24, 0xFF
    out _SFR_IO_ADDR(DDRB), r24
    out _SFR_IO_ADDR(PORTB), r24

 end:
    jmp end
</code></pre>

<p>Or, you can switch to memory mapped access:</p>

<pre class=""lang-none prettyprint-override""><code>#include ""avr/io.h""

.global main

main:
    ldi r24, 0xFF
    sts _SFR_MEM_ADDR(DDRB), r24
    sts _SFR_MEM_ADDR(PORTB), r24

 end:
    jmp end
</code></pre>
",,18272601,998
14467891,2,14467568,2013-01-22T20:59:58.883,12,,1904517,,2013-01-22T21:43:57.793,2013-01-22T21:43:57.793,1,,"<p><code>SD.open</code> expects a character array instead of a <code>String</code>, you need to convert it using the <a href=""http://arduino.cc/en/Reference/StringToCharArray"" rel=""noreferrer""><code>toCharArray</code></a> method first. Try</p>

<pre><code>  char filename[temp.length()+1];
  temp.toCharArray(filename, sizeof(filename));
  if(!SD.exists(filename)) { 
   ...
  }
</code></pre>

<p>Completed Code:</p>

<pre><code>for(int i=1;;i++)
{
   String temp = ""data"";
   temp.concat(i);
   temp.concat("".csv"");
   char filename[temp.length()+1];
   temp.toCharArray(filename, sizeof(filename));
   if(!SD.exists(filename))
   {
      datur = SD.open(filename,FILE_WRITE);
      break;
   }
}
</code></pre>

<p>You will find a number of functions take char arrays instead of strings.</p>
",,18389761,1532
14529595,2,14529496,2013-01-25T20:09:49.647,4,,1947008,,2013-01-25T20:24:15.723,2013-01-25T20:24:15.723,5,,"<pre><code>byte GetFreeCell(short x, short y)
{
    byte possibleMoves[4];
    byte index = 0;
    if (y - 2 &gt;= 0 &amp;&amp; _grid[y - 2][x] == 0)
        possibleMoves[index++] = 1;
    if (x + 2 &lt; WIDTH &amp;&amp; _grid[y][x + 2] == 0)
        possibleMoves[index++] = 2;
    if (y + 2 &lt; HEIGHT &amp;&amp; _grid[y + 2][x] == 0)
        possibleMoves[index++] = 3;
    if (x - 2 &gt;= 0 &amp;&amp; _grid[y][x - 2] == 0)
        possibleMoves[index++] = 4;

    return index ? possibleMoves[random(index)] : 0;
}
</code></pre>
",,18391489,522
14547761,2,14546947,2013-01-27T13:19:19.667,2,,2012498,,2013-01-27T21:59:03.593,2013-01-27T21:59:03.593,3,,"<p>Your code looks correct. The most likely problem is that it's being built incorrectly, but to address this we need to see your Makefile.</p>

<p>At the link below (wouldn't let me post the link so you have to copy/paste it yourself) is a post by someone who had a very similar problem to yours. It turned out that he was not running his compiled object file through the linker, with the result that some essential library was missing which caused the PIC to loop endlessly, trying to execute an invalid opcode (instruction).</p>

<p>efreedom dot com/Question/E-27081/Using-Avr-Gcc-Delay-Ms-Causes-Chip-Freeze</p>

<p>If this doesn't fix it, try posting your Makefile.</p>

<p>Also, there is no reason to call _delay_ms(10) 100 times, you can just call _delay_ms(1000) directly. It will use a lower resolution.</p>

<p><strong>Edit:</strong> After seeing your Makefile it looks like your clock speed might be set incorrectly. The CLOCK setting specifies what speed you are running your AVR at, if it's set to something way off (like 8MHz and your PIC is running at 1MHz), the delay loop will take 8 seconds when you expect it to take one - if that's the problem your LED's will appear frozen but if you wait long enough they will actually change. Try removing the -DF_CPU=$(CLOCK) statement and see if it makes a difference.</p>

<p>Apart from that your Makefile has a lot of unused/unnecessary stuff, and since I don't have a working avr-gcc setup at the moment, it's hard to follow, so it will help if you try simplifying the Makefile like the following, and see if it works - it will be close, please comment below if you get any problems!</p>

<pre><code>DEVICE     = attiny2313
CLOCK      = 8000000
OBJECTS    = main.o

# Tune the lines below only if you know what you are doing:

AVRDUDE = avrdude $(PROGRAMMER) -p $(DEVICE)
COMPILE = avr-gcc -Wall -Os -DF_CPU=$(CLOCK) -mmcu=$(DEVICE)

# symbolic targets:
all:    main.hex

flash:  all
    $(AVRDUDE) -U flash:w:main.hex:i

clean:
    rm -f main.hex main.elf $(OBJECTS)

main.elf: $(OBJECTS)
    $(COMPILE) -o main.elf $(OBJECTS)

main.hex: main.elf
    rm -f main.hex
    avr-objcopy -j .text -j .data -O ihex main.elf main.hex
    avr-size --format=avr --mcu=$(DEVICE) main.elf
</code></pre>
",,18414795,1508
14564868,2,14564714,2013-01-28T15:06:11.210,0,,28169,,2013-01-28T15:06:11.210,,1,,"<p>I think it's pretty hard to answer this in a conclusive manner, without being able to test it locally.</p>

<p>It does sound very suspicious though, that it breaks when the code size approaches the maximum. On the other hand, it seems to indicate a bug in the tools that it doesn't break ""hard"", if some limit was exceeded.</p>

<p>Some tips on how to reduce the code size:</p>

<ul>
<li>Don't use <code>float</code> since the CPU must emulate it. A fixed-point format should be fine for temperatures.</li>
<li>Factor out the function calls to <code>digitalWrite()</code> and <code>lcd.print()</code>, since function calls generate quite a lot of code.</li>
</ul>

<p>One way of factoring out those calls is doing something like this:</p>

<pre><code>uint8_t relay_pin = LOW;
const char *lcd_text = ""OFF"";
if(inside_temp &lt; target) {
    float limit = target + 1;
    if(outside_temp &gt; limit) {
    }
    else {
      relay_pin = HIGH;
      lcd_text = ""ON"";
    }
}
digitalWrite(RELAY_PIN, relay_pin);
lcd.print(lcd_text);
</code></pre>

<p>This uses the fact that we want to always update the LCD and relay, so we can always call the functions. Then we use variables to hold the desired values, since assignments are usually cheaper (in terms of code size, here) than function calls.</p>
",,18486175,77
14665427,2,14664511,2013-02-02T19:08:19.187,2,,1927972,,2013-02-02T19:08:19.187,,0,,"<p>Their is a key.  The headers end at a double CRLF:</p>

<pre><code>Response = Status-Line
    *(( general-header        
   | response-header        
   | entity-header ) CRLF)  
   CRLF
   [ message-body ]   
</code></pre>

<p>see <a href=""http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6"" rel=""nofollow"">W3 doc</a></p>
",,18581804,3780
27688344,2,14676730,2014-12-29T11:52:55.747,1,,867387,,2014-12-29T11:52:55.747,,0,,"<p>I was just investigating timing on Pi, with similar approach and similar problems. My thoughts are:</p>

<p>You don't have to use double. In fact you also don't need nano-seconds, as the clock on Pi has 1 microsecond accuracy anyway (it's the way the Broadcom did it). I suggest you to use gettimeofday() to get microsecs instead of nanosecs. Then computation is easy, it's just:</p>

<pre><code>number of seconds + (1000 * 1000 * number of micros) 
</code></pre>

<p>which you can simply calculate as unsigned int.</p>

<p>I've implemented the convenient API for this:</p>

<pre><code>typedef struct
{
    struct timeval startTimeVal;
} TIMER_usecCtx_t;

void TIMER_usecStart(TIMER_usecCtx_t* ctx)
{
    gettimeofday(&amp;ctx-&gt;startTimeVal, NULL);
}

unsigned int TIMER_usecElapsedUs(TIMER_usecCtx_t* ctx)
{
    unsigned int rv;

    /* get current time */
    struct timeval nowTimeVal;
    gettimeofday(&amp;nowTimeVal, NULL);

    /* compute diff */
    rv = 1000000 * (nowTimeVal.tv_sec - ctx-&gt;startTimeVal.tv_sec) + nowTimeVal.tv_usec - ctx-&gt;startTimeVal.tv_usec;

    return rv;
}
</code></pre>

<p>And the usage is:</p>

<pre><code>TIMER_usecCtx_t timer;
TIMER_usecStart(&amp;timer);

while (1)
{
    if (TIMER_usecElapsedUs(timer) &gt; yourDelayInMicroseconds)
    {
        doSomethingHere();
        TIMER_usecStart(&amp;timer);
    }
}
</code></pre>

<p>Also notice the gettime() calls on Pi take almost 1 [us] to complete. So, if you need to call gettime() a lot and need more accuracy, go for some more advanced methods of getting time... I've explained more about it in this <a href=""http://yosh.ke.mu/article/raspberry_pi_getting_time"" rel=""nofollow"">short article about Pi get-time calls</a> </p>
",,18583996,6251
14883650,2,14881145,2013-02-14T20:41:38.807,2,,1899801,,2013-02-14T20:41:38.807,,3,,"<p>I believe your problem is solvable by declaring the objects with the ""extern"" prefix or external. For example. I often use the SdFat library, in which it is included in both my main sketch and instanced in other libraries.</p>

<pre><code>/**
 * \file test.ino
 */
#include &lt;SdFat.h&gt;
#include &lt;foo.h&gt;
SdFat sd;
...
</code></pre>

<p>Where I also use the same object in other libraries, such as foo.h. </p>

<pre><code>/**
 * \file foo.h
 */
#include &lt;SdFat.h&gt;
extern SdFat sd;
...
</code></pre>

<p>If it was not for the prefix of ""extern"" it would error like yours, as ""sd"" can not exist twice. Where the extern prefix tells the linker don't make a new instantiation, rather link to the externally instance elsewhere.</p>
",,18596380,629
14883738,2,14883128,2013-02-14T20:46:42.493,0,,1342784,,2013-02-14T21:47:52.223,2013-02-14T21:47:52.223,1,,"<p>Your problem is that <code>children</code> is an array of type <code>Actor</code>.  The line <code>children[0] = marble</code> is taking a <code>Marble</code> object, converting it to an <code>Actor</code> object and copying the results to <code>children[0]</code>.  Since the call to <code>children[0].speak()</code> is on an <code>Actor</code>, you get the <code>Actor</code> version.</p>

<p>In order for this to work the way you want, you need to copy a pointer or reference to the object rather than the object itself.  That is, you want something like `Actor* children[2]':</p>

<pre><code>Marble marble;
Actor* children[2];
children[0] = &amp;marble;

children[0]-&gt;speak();
</code></pre>

<p>Of course if <code>children</code> has scope outside of <code>loop</code>, this will fail utterly and you'll need to use <code>new</code> to create your marbles.</p>

<p>Better yet, assuming Arduino has the STL, you should use <code>vector</code> and <code>shared_ptr</code> or something similar.</p>

<p>[Update] As Philip notes, this will also require that the <code>speak</code> method in <code>Actor</code> be declared virtual.</p>
",,18679274,126
14886666,2,14886524,2013-02-15T00:43:03.657,1,,951757,,2013-02-15T00:43:03.657,,0,,"<p>You need to make <code>Actor::speak</code> virtual,  the compiler uses dynamic binding for virtual methods.</p>

<pre><code>class Actor
{
  public:
    Actor();
    virtual void speak();  // virtual
  private:
};
</code></pre>
",,18790880,147
14894866,2,14894637,2013-02-15T12:35:29.123,0,,853665,,2013-02-15T12:40:54.737,2013-02-15T12:40:54.737,1,,"<p>You need to at least write a copy constructor and an assignment operator for class A.  The default copy will copy the pointer and not re-assign it to the new location.</p>

<p>e.g. </p>

<pre><code>A(A const&amp; rhs) 
: Base(rhs)
{
    memcpy(_data, rhs._data, sizeof(_data));
    setArray(_data);
}


A&amp; operator=(A const&amp; rhs) 
{
    if (this != &amp;rhs) {
        static_cast&lt;Base&amp;&gt;(*this) = rhs;
        memcpy(_data, rhs._data, sizeof(_data));
        setArray(_data);
    }
    return *this;
}
</code></pre>
",,18806141,3117
14918116,2,14903753,2013-02-17T04:55:58.570,1,,1927972,,2013-02-17T04:55:58.570,,2,,"<p>Something in your function cog() is stomping on the variable pwm.  Once the float variable is corrupt, Serial.print() will just show zero.  The sample below shows that with the float set to 0xffffff, the floating point math library stops making any operation on the variable.</p>

<p>Run the sample program below and you will see that one time pwm prints correctly.  After the first bad call, it prints zeros.  Also the memory occupied no longer changes.</p>

<pre><code>pwm=0.50 zpwm=0.50
pwm=0.00 zpwm=3.95 result=3.45
255-255-255-255
pwm=0.00 zpwm=4.45
pwm=0.00 zpwm=7.90 result=3.45
255-255-255-255
</code></pre>

<p>Sample program showing a function that writes to wrong memory location.
Looking at the memory map output by the linker, the variables are placed in memory in the order listed.  So writing past the end of var, will corrupt pwm.</p>

<pre><code>float zpwm = 0;
byte var = 0;
float pwm = 0;
float result = 0;


float badactor() {
  *((long*)(&amp;var+1)) = -1;
  return 3.45;
}

void setup() {
  Serial.begin(57600);
}

void loop() {

  zpwm += 0.5;
  pwm += 0.5;

  Serial.print(""pwm="");
  Serial.print(pwm);
  Serial.print("" zpwm="");
  Serial.println(zpwm);

  result = badactor();
  pwm += result;
  zpwm += result;

  Serial.print(""pwm="");
  Serial.print(pwm);
  Serial.print("" zpwm="");
  Serial.print(zpwm);
  Serial.print("" result="");
  Serial.println(result);

  uint8_t* ptr;
  ptr = (uint8_t*)&amp;pwm;
  Serial.print((int)*(ptr));
  Serial.print(""-"");
  Serial.print((int)*(ptr+1));
  Serial.print(""-"");
  Serial.print((int)*(ptr+2));
  Serial.print(""-"");
  Serial.println((int)*(ptr+3));

  delay(1000);
}
</code></pre>
",,18819535,4426
14933653,2,14928473,2013-02-18T10:02:15.877,1,,4023,,2013-02-18T10:02:15.877,,0,,"<p>The problem looks to be due to <code>getClass()</code>, <code>getSubClass()</code> and <code>getDataValue()</code> returning local variables (<code>returnStr</code>). As soon as the functions return these values will be lost.</p>

<p>A few ways to avoid this:</p>

<p>Return a <code>String</code> object (a local <code>String</code> will get copied on the way out of the functions):</p>

<pre><code>String getClass(String command) {
    String returnStr;
    for (int i = 0; i &lt; 3; i++) {
        returnStr += command[i+1];
    }

    return returnStr;
}
</code></pre>

<p>Dynamically allocate the <code>char*</code> within the functions (using <code>malloc()</code>) - if you do this you'll need to be careful to deallocate it afterwards (using <code>free()</code>):</p>

<pre><code>char* getClass(String command) {
    size_t length = 3;
    char* returnStr = (char*) malloc(length);
    for (int i = 0; i &lt; length; i++) {
        returnStr[i] = command[i+1];
    }

    return returnStr;
}

// Usage
char* classStr = getClass(UsartString);
Serial.println(classStr);
free(classStr);
</code></pre>

<p>Pass a pre-allocated <code>char</code> array into the functions - this can be a local variable in the calling function:</p>

<pre><code>void getClass(String command, char* returnStr) {
    for (int i = 0; i &lt; 3; i++) {
        returnStr[i] = command[i+1];
    }

    return returnStr;
}

// Usage
char returnStr[3];
getClass(UsartString, returnStr);
Serial.println(returnStr);
</code></pre>
",,18832285,2096
14985731,2,14982022,2013-02-20T17:08:20.097,-1,,1678764,,2015-02-27T21:00:28.720,2017-05-23T12:16:48.910,2,,"<p>Borrowing from <a href=""https://stackoverflow.com/questions/6504211/is-it-possible-to-include-a-library-from-another-library-using-the-arduino-ide"">this stack overflow question</a>, </p>

<blockquote>
  <p>The include path includes the sketch's directory, the target directory
  (/hardware/core//) and the avr include directory
  (/hardware/tools/avr/avr/include/), as well as any library directories
  (in /hardware/libraries/) which contain a header file which is
  included by the main sketch file.</p>
</blockquote>

<p>Try</p>

<pre><code>// in myProject.ino
#include &lt;arduinolib.h&gt;
#include ""MyLib.h""

// in Mylib.h
#include ""./extra/SomeNiceFunctions.h""
</code></pre>
",,18837573,478
48349682,2,14982022,2018-01-19T21:18:30.167,0,,268524,,2018-01-19T21:18:30.167,,0,,"<p>I had some an issue with this.  I just wanted a simple solution and while writing a library in CPP is the correct way - I took a sketch - say robo.ino file and added it to a simple library include - so that there was just one file in the library under a folder called Robot - robo.h</p>

<pre><code>├── sketchesfolder
├── libraries
│   ├── robot
│   │   ├── robot.h
├── robotsketch
│   ├── Move.ino
</code></pre>

<p>Now in the Move.ino - I just include the file </p>

<pre><code>#include &lt;robo.h&gt;
</code></pre>

<p>The only thing you need to add for simple functions is a prototype declaration - or make sure your functions are ordered by first use.</p>

<p>So for example - put Setup() at the bottom and a function like:</p>

<pre><code> void halt(int wait); 
</code></pre>

<p>as a prototype definition at the head of the robo.h file</p>

<p>It allows you to share a sketch as common code without converting it to a CPP lib.  But you should really do that of course.</p>
",,18840283,2440
15037134,2,15017061,2013-02-23T04:41:45.030,0,,1967396,,2013-02-23T04:41:45.030,,0,,"<p>Curious problem! Try the following code as a quick way to check your clock speed:</p>

<pre><code>boolean pinValue;

void setup() {
   Serial.begin(9600);
   pinMode(13, OUTPUT);
   digitalWrite(13, HIGH);
   pinValue = true;
}

void loop() {
    pinValue = !pinValue;
    digitalWrite(13, pinValue);
}
</code></pre>

<p>Your logic analyzer should show an approximately 50% duty cycle of the Arduino going ""as fast as it can"". Use this to confirm your boards are being clocked as you think.</p>

<p>This will help you figure out whether your Teensy 3.0 is slow because of the time to perform a basic instruction, or whether the instructions for performing math functions are somehow less optimal for the ARM than for the AVR. If it is slower even for this simple program I would strongly suspect you are not clocking it the way you think.</p>

<p>I would recommend that you confirm that your probes are wired the way you think they are... i.e. is the ""slow"" channel really wired to the ""fast"" board?</p>
",,18903528,561
15595574,2,15049257,2013-03-24T05:40:39.800,1,,2149548,,2013-03-24T05:40:39.800,,0,,"<p>How about: </p>

<ul>
<li>Try to open <code>/dev/ttyACM0</code></li>
<li>If that fails try to open <code>/dev/ttyACM0</code></li>
</ul>

<p>Something like this:</p>

<pre><code>#define SERIALIDX_MIN   0
#define SERIALIDX_MAX   1

int idxSerialPortIndex = SERIALIDX_MIN;
char strSerialPort[oxFF];

while (true) {
   sprintf(strSerialPort, ""/dev/ttyAMC%d"", idxSerialPortIndex);
   arduino = open(""/dev/ttyAMC0"", O_RDWR | O_NOCTTY | O_NDELAY);
   if(arduino != -1) {
       fcntl(_arduino, F_SETFL, 0);
       ...  // read serial port here
   }
   if (++idxSerialPortIndex &gt; SERIALIDX_MAX) 
       idxSerialPortIndex = SERIALIDX_MIN;
}
</code></pre>

<p>If you are worried that other devices will show up on <code>/dev/ttyACM0</code> and <code>/dev/ttyACM1</code> you can make your Arduino respond to simple command string. If it reads <code>ID</code> followed by LF (or CR/LF depending on your system), it can respond with some suitable string like <code>**I AM THE MOTHERBUSTING ARDUINO**</code>, whereupon your C/C++ program will know if it is indeed connected to an Arduino. If the expected response isn't received, the C/C++ program can open the next serial port.</p>
",,18966906,185
15051748,2,15051724,2013-02-24T12:31:44.337,3,,440558,,2013-02-24T12:31:44.337,,0,,"<p>You can not modify a string literal. String literals are constant.</p>

<p>You have to declare it as an array with enough space to add the number.</p>

<p>You also do some unnecessary steps, I suggest something like this:</p>

<pre><code>void function(int x)
{
    char response[64];

    sprintf(response, ""GET /postTEST.php?first=%d"", x);

    Serial.println(response);
}
</code></pre>
",,19018538,111
15126366,2,15113128,2013-02-28T02:20:52.710,6,,1899801,,2013-02-28T02:20:52.710,,0,,"<p>You are over thinking the goal. 
First results.value returns a uint32_t, not a string.
Second the ""String"" is different then an array of char's (aka ""string""). Notice the Capital S.</p>

<pre><code>stringAppleUp = String('77E150BC');
</code></pre>

<p>Then you could </p>

<pre><code>String Foo = String('bar');
if (Foo == stringAppleUp ) {
...
</code></pre>

<p>Where Foo is what you want to test. NOTE the test of ""=="" versus the assignment of ""=""</p>

<p>Alternatively </p>

<pre><code>char foo[] = ""12345678"";
if (strcmp(stringAppleUp, foo)) {
...
</code></pre>

<p>where you can find <a href=""http://www.nongnu.org/avr-libc/user-manual/group__avr__string.html#ga46f3cbd2de457c0fb340a1f379fc33ba"" rel=""noreferrer"">strcmp of arrays here</a></p>

<p>Finally, a HEX is not a string, but an integer. Just test the results.value. Against another integer. </p>

<pre><code>#include &lt;IRremote.h&gt;

int RECV_PIN = 11;
IRrecv irrecv(RECV_PIN);
decode_results results;

void setup()
{

  Serial.begin(9600);
  irrecv.enableIRIn(); // Start the receiver
}

void loop() {

  if (irrecv.decode(&amp;results)) {
    Serial.print(F(""result = 0x""));
    Serial.println(results.value, HEX);

    if (results.value == 0x77E150BC)  {
      Serial.println(""yes"");
    }
    else {
      Serial.println(""No"");
    }
    irrecv.resume(); // Receive the next value
  }
}
</code></pre>
",,19046263,2886
15126346,2,15126129,2013-02-28T02:18:52.030,1,,492901,,2013-02-28T02:29:29.657,2013-02-28T02:29:29.657,0,,"<blockquote>
  <p>[...] where gpio#, are all defined as integers [...]</p>
</blockquote>

<p>I assumed that you probably mean something like:</p>

<pre><code>const int gpio1 = 42;
const int gpio2 = 84;
const int gpio3 = 43;
// etc.
</code></pre>

<p>However, since <code>xx</code> is initialized in the global scope, it is allocated and initialized at compile-time. However, based on my assumption, <code>gpio1</code> and friends are allocated and initialized at run-time, so obviously the compiler tells you that it can't initialize <code>xx</code>.</p>

<p>You will need to use a constant expression (or a macro that will expand into a literal constant) for this to work. Per example, you'd do:</p>

<pre><code>enum {
    gpio1 = 42, 
    gpio2 = 84, 
    gpio3 = 43, 
    // etc.
};
</code></pre>

<p>...or:</p>

<pre><code>#define gpio1 42
#define gpio2 84
#define gpio3 43
// etc.
</code></pre>

<p>And before you ask, <code>label</code> decays into a pointer to a string literal in this context. That makes it a constant expression, so this one is allowed.</p>
",,19052584,1241
15175466,2,15175358,2013-03-02T14:13:46.373,-2,,2073232,,2013-03-02T14:13:46.373,,3,,"<p>The message is string, thus you have to convert from character to number. You're just lucky, you had correct checksum in at 50%.</p>

<pre><code>int charFromHex(char x)
{
   if ((x &gt;= '0') &amp;&amp; (x &lt;= '9'))
   {
     return x - '0';
   }
   else if ((x &gt;= 'A') &amp;&amp; (x &lt;= 'F'))
   {
      return x - 'A' + 10;
   }
   else
   {
     return 0; 
     //somehow handle error!
   }
{
</code></pre>
",,19072518,451
15182563,2,15182491,2013-03-03T04:51:26.527,1,,380757,,2013-03-03T04:57:52.420,2013-03-03T04:57:52.420,4,,"<p>1.The return type from <code>wiringPiI2CReadReg16()</code> is int. So use <code>int</code> as the datatype for variables MSB and LSB instead of byte.</p>

<pre><code>void getGyroValues (){
    int MSB, LSB;

    LSB = wiringPiI2CReadReg16(fd, 0x28);
    MSB = wiringPiI2CReadReg16(fd, 0x29);
    x = ((MSB &lt;&lt; 8) | LSB);

    MSB = wiringPiI2CReadReg16(fd, 0x2B);
    LSB = wiringPiI2CReadReg16(fd, 0x2A);
    y = ((MSB &lt;&lt; 8) | LSB);

    MSB = wiringPiI2CReadReg16(fd, 0x2D);
    LSB = wiringPiI2CReadReg16(fd, 0x2C);
    z = ((MSB &lt;&lt; 8) | LSB);
}
</code></pre>

<p>2.And either move the definition of <code>getGyroValues()</code> before the <code>loop()</code> function or define a prototype for this function before <code>loop()</code>.</p>
",,19093839,1678
15183634,2,15183530,2013-03-03T07:56:35.180,5,,380757,,2013-03-03T08:21:03.153,2013-03-03T08:21:03.153,1,,"<p><a href=""http://en.wikipedia.org/wiki/I%C2%B2C"" rel=""nofollow"">I2C</a> is a 2-wire protocol used to talk to low-speed peripherals.</p>

<p>Your sensor should be connected over the I2C bus to your CPU. And you're reading 3 values from the sensor - x, y and z. The values for these are accessible from the sensor as <code>6 x 8-bit</code> registers.</p>

<pre><code>x - Addresses 0x28, 0x29
y - Addresses 0x2A, 0x2B
z - Addresses 0x2C, 0x2D
</code></pre>

<p><code>ReadI2C()</code> as the function name implies, reads a byte of data from a given address from your sensor and returns the data being read. The code in <code>ReadI2C()</code> is dependent on how your device's I2C controller is setup.</p>

<p>A byte is 8-bits of data. The MSB (<code>Most-Significant-Byte</code>) and LSB(<code>Least-Significant-Byte</code>) denote 8-bits each read over <code>I2C</code>.
It looks like you're interested in a 16-bit data (for x, y and z). To construct the 16-bit data from the 2 pieces of 8-bit data, you shift the <code>MSB</code> by 8-bits to the left and then perform a logical-OR operation with the <code>LSB</code>.</p>

<p>For example:</p>

<blockquote>
  <p>Let us assume: MSB = 0x45 LSB = 0x89</p>
  
  <p>MSB &lt;&lt; 8 = 0x4500</p>
  
  <p>(MSB &lt;&lt; 8) | LSB = 0x4589</p>
</blockquote>

<p>Look at my comments inline as well:</p>

<pre><code>void getGyroValues () {
  byte MSB, LSB;

  MSB = readI2C(0x29);
  LSB = readI2C(0x28);
  // Shift the value in MSB left by 8 bits and OR with the 8-bits of LSB
  // And store this result in x
  x = ((MSB &lt;&lt; 8) | LSB);

  MSB = readI2C(0x2B);
  LSB = readI2C(0x2A);
  // Do the same as above, but store the value in y
  y = ((MSB &lt;&lt; 8) | LSB);

  MSB = readI2C(0x2D);
  LSB = readI2C(0x2C);
  // Do the same as above, but store the value in z
  z = ((MSB &lt;&lt; 8) | LSB);
}
</code></pre>
",,19113045,2424
15183617,2,15183606,2013-03-03T07:54:25.093,6,,,user529758,2013-03-03T11:00:54.123,2013-03-03T11:00:54.123,5,,"<p>You can (ab)use integer comparison and truncation:</p>

<pre><code>int is_equal_3decplaces(double a, double b) {
    long long ai = a * 1000;
    long long bi = b * 1000;
    return ai == bi;
}
</code></pre>

<p>As @DavidRF's benchmarks have shown it, this solution offers a slight (~40%) improvement in performance compared to calculating the absolute values.</p>
",,19134773,2095
15183652,2,15183606,2013-03-03T07:59:20.423,4,,1952500,,2013-03-03T08:05:14.110,2013-03-03T08:05:14.110,4,,"<p>You should actually check for the difference being less than a small delta which is pre-configurable, unless you always want it to be checked for three decimal places. For example:</p>

<pre><code>#define epsilon ((double)0.000999)
bool is_approximately_equal(double x, double y)
{
        return (abs(x - y) &lt; epsilon);
}
</code></pre>

<p>Note that abs on C++ has the version of abs for double. In C you'll have to do something with -ve values.</p>
",,19143196,737
15191834,2,15191768,2013-03-03T22:44:50.167,1,,968261,,2013-03-03T22:44:50.167,,0,,"<p>Here's how you could easily combine the most and the least significant bytes, representing the halves of a 2's complement 16-bit integer into an int:</p>

<pre><code>int Bytes2Short(unsigned char msb, unsigned char lsb)
{
  long t = msb * 0x100L + lsb;
  if (t &gt;= 32768)
    t -= 65536;
  return (int)t;
}
</code></pre>
",,19149441,3886
15193776,2,15191768,2013-03-04T02:44:49.693,1,,1256452,,2013-03-04T02:44:49.693,,0,,"<p>Use Alexey Frunze's method for clarity, but here's a version with no tests (which may compile to faster inline code in some situations).  This pattern works for other sizes of unsigned bit patterns as well—for instance, to handle 12-bit integers, use <code>0x0800</code>, for 17-bit integers use <code>0x10000</code>, and so on.</p>

<p>I bundled it with a little driver <code>main</code> to show the outputs.</p>

<pre><code>#include &lt;stdio.h&gt;

int comb(unsigned char msb, unsigned char lsb) {
        long t = ((long)msb &lt;&lt; 8) | lsb;
        if (t &gt;= 32768)
                t -= 65536;
        return t;
}

int comb2(unsigned char msb, unsigned char lsb) {
        unsigned long t = ((unsigned long)msb &lt;&lt; 8) | lsb;
        t ^= 0x8000UL;
        return (int)((long)t - (long)0x8000);
}

int main(void) {
        printf(""%6s %6s\n"", ""comb"", ""comb2"");
        printf(""%6d %6d\n"", comb(0, 0), comb2(0, 0));
        printf(""%6d %6d\n"", comb(127, 255), comb2(127, 255));
        printf(""%6d %6d\n"", comb(128, 0), comb2(128, 0));
        printf(""%6d %6d\n"", comb(255, 255), comb2(255, 255));
        return 0;
}
</code></pre>
",,19162072,142096
15305896,2,15304383,2013-03-09T00:57:40.367,3,,1899801,,2013-03-09T01:50:14.180,2013-03-09T01:50:14.180,3,,"<p>First change your </p>

<pre><code>#ifndef serialComms
#define serialComms
</code></pre>

<p>to </p>

<pre><code>#ifndef serialComms_h
#define serialComms_h
</code></pre>

<p>You can not have a macro with the same name as an instance.</p>

<p>Then check you capitalization e.g. readBytes vs testing.readbytes(); notice the B</p>

<hr>

<p>Make SURE you close out all your Arduino IDE's when making a NEW library directory and initial files with in it, for the first time. The IDE on startup caches a list of the files. They can subsequently change there insides. but new files will not be known until the next start.</p>

<hr>

<p>The following compiles fine for me. Once I corrected all the typo's:</p>

<p>definetest.ino</p>

<pre><code>#include &lt;serialComms.h&gt;
serialComms testing;

void setup() {
  Serial.begin(9600);
}

void loop() {
}

void serialEvent()
{
  testing.readBytes();
  testing.assignBytes();
}
</code></pre>

<p>serialComms.cpp</p>

<pre><code>#ifndef serialComms_h
#define serialComms_h

/* serialComms Class */
class serialComms
{
  public:
//       serialComms() {};
void init();
void readBytes(); // Will be used to create the array --&gt; two variables for now...
void assignBytes();
    };

#endif
</code></pre>

<p>serialComms.h</p>

<pre><code>#include &lt;Arduino.h&gt;
#include &lt;serialComms.h&gt;

void serialComms::init()
{
  // This is where the constructor would be...right now we are too stupid to have one
}

void serialComms::readBytes()  // Target Pin,Values
{
  digitalWrite(11,HIGH);
  delay(250);
  digitalWrite(11,LOW);
  assignBytes();
}

void serialComms::assignBytes()
{
  for(int t  = 0;t&lt;5;t++)
  {
    digitalWrite(10,HIGH);
    delay(250);
    digitalWrite(10,LOW);
  }   
}
</code></pre>
",,19195720,2984
15327236,2,15315391,2013-03-10T20:31:46.143,2,,2149548,,2013-03-10T20:31:46.143,,1,,"<p>OK, so what I would do first is create a separate header file to declare the structures you will use to communicate between the Arduino and the PC. So in a file like <code>comms.h</code></p>

<pre><code>#ifndef COMMS_H
#define COMMS_H
typedef struct commFrame_t commFrame_t {
    unsigned int wind, 
    signed int temperature;     
}
#endif COMMS_H
</code></pre>

<p>Then in your Arduino code you'll need to <code>#include ""comms.h""</code> and then send the data as follows:</p>

<pre><code>commFrame_t frame;
// Fill the frame with data
frame.wind = someWindValue;
frame.temperature = someTemperatureValue;
// Send the frame
Serial.write(&amp;frame, sizeof(frame));
</code></pre>

<p>On the PC side you'll also <code>#include ""comms.h""</code> and read the same frame:</p>

<pre><code>commFrame_t frame;

if (read(tty_fd,&amp;frame,sizeof(frame))){
    // Process a frame
}
</code></pre>

<p>This is not foolproof, as lost characters will cause the whole protocol to go out of whack, but might be OK as an initial prototype.  Unless you are passing the structure directly to some XBee device, I don't see why you need the delimiter for instance.</p>
",,19245318,6499
15329954,2,15329824,2013-03-11T01:39:54.140,2,,1919155,,2013-03-11T01:39:54.140,,1,,"<p>The code you have can EASILY be written in C++, like this:</p>

<pre><code> int bin[4] = {};

 bin[0] = !!(num &amp; 8);
 bin[1] = !!(num &amp; 4);
 bin[2] = !!(num &amp; 2);
 bin[3] = !!(num &amp; 1);
</code></pre>

<p>or:</p>

<pre><code>int bin[4];
int bit = 8;
for(int i = 0; i &lt; 4; i++)
{
    bin[i] = !!(num &amp; bit);
    bit &gt;&gt;= 1;
}
</code></pre>

<p>If you don't like <code>!!</code> (which makes ""take the next value and make it either 0 [if it's false] or 1 [if it's true]), you could replace it with:</p>

<pre><code>for(int i = 0; i &lt; 4; i++)
{
    bin[i] = (num &gt;&gt; 3 - i) &amp; 1;
}
</code></pre>

<p>I take it you intentionally want the highest bit in the lowest <code>bin</code> index, rather than the usual case of highest bit in the highest index. </p>
",,19256421,776
15362467,2,15353092,2013-03-12T13:22:35.080,1,,1899801,,2013-03-14T01:41:07.463,2013-03-14T01:41:07.463,5,,"<p>Example:</p>

<pre><code>    void setup()
{

  Serial.begin(9600);
  char string_array[] = ""hello"";
  char data_array[] = {1,2,3,4,5,6};
  unsigned char data_array_uchar[] = {21,22,23,24,25,26};
  uint8_t uint8_array[] = {11,12,13,14,15,16};
  char alpha_array[] = {0x41,0x42,0x43,0x44,0x45,0x46};
  // take note that sizeof() is a precompile command... number of places/size of each place.

  updateUserPrint(string_array);
  updateUserWrite(data_array, sizeof(string_array));
  updateUserWriteUchar(data_array_uchar, sizeof(data_array_uchar));
  updateUserWriteUchar(uint8_array, sizeof(uint8_array));
  updateUserWriteUint(uint8_array, sizeof(string_array));
  updateUserAlpha(alpha_array, sizeof(string_array));
}
void updateUserPrint(char *s)
{  //note a string aka array of char's is ended with a null.
  Serial.print(s); // this can detect.
  Serial.println();
}
void updateUserWrite(char *t, size_t len)
{  //note an array of int's is not ended with a null. so you need to know how long it is.
  for (int n = 0; n &lt; len ; n++) {
    Serial.print(t[n],DEC);
    Serial.print("","");
  }
  Serial.println();
}
void updateUserWriteUchar(unsigned char *t, size_t len)
{  //note an array of int's is not ended with a null. so you need to know how long it is.
  for (int n = 0; n &lt; len ; n++) {
    Serial.print(t[n],DEC);
    Serial.print("","");
  }
  Serial.println();
}
void updateUserWriteUint(uint8_t *t, size_t len)
{  //note an array of int's is not ended with a null. so you need to know how long it is.
  for (int n = 0; n &lt; len ; n++) {
    Serial.print(t[n],DEC);
    Serial.print("","");
  }
  Serial.println();
}
void updateUserAlpha(char *t, int len)
{  //note an array of int's is not ended with a null. so you need to know how long it is.
  for (int n = 0; n &lt; len ; n++) {
    Serial.write(t[n]);
  }
  Serial.println();
}  
</code></pre>

<p>produces the following:</p>

<pre><code>hello
1,2,3,4,5,6,
21,22,23,24,25,26,
11,12,13,14,15,16,
11,12,13,14,15,16,
ABCDEF
</code></pre>
",,19293824,16714
15353211,2,15353140,2013-03-12T04:15:52.640,2,,1177073,,2013-03-12T04:28:34.017,2013-03-12T04:28:34.017,5,,"<p>You have the code:</p>

<pre><code>RTC_Base RTC = RTC_DS1307();
DateTime dt = RTC.now(); //The above call just returns a blank DateTime();
</code></pre>

<p>That's <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""nofollow"">object slicing</a> (as @chris originally guessed). For <a href=""http://www.cplusplus.com/doc/tutorial/polymorphism/"" rel=""nofollow"">Polymorphism</a> to work, you'll have to pretend your derived class is a base class, by treating a <em>pointer or reference</em> as a Base, when it really is the address of a Derived. (Because the Derived actually contains the Base within it).</p>

<pre><code>Derived myDerived;
Base &amp;myBaseRef = myDerived;

myBaseRef.myVirtualFunction();
</code></pre>

<p>Otherwise, you are creating a Derived, and trying to force the bytes into a Base, and losing all the Derived's bytes. It's not good! =)</p>

<p>The point is, you shouldn't actually be <em>converting</em> the Derived to a Base, just accessing the Derived as if it were a Base. If you convert it to a Base, it <em>is</em> a base. And your Base class returns an empty DateTime.</p>

<p>To do so with dynamically allocated memory, you can do this:</p>

<pre><code>Base *myBase = nullptr; //Or 'NULL' if you aren't using C++11
myBase = new Derived;

myBase-&gt;myVirtualFunction(); //Dereference the myBase pointer and call the function.

delete myBase; //Free the memory when you are finished.
</code></pre>

<p>If you are using C++11, you can let <a href=""http://www.cplusplus.com/reference/memory/unique_ptr/?kw=unique_ptr"" rel=""nofollow"">std::unique_ptr</a> handle the lifetime of the object for you, so you don't have to remember to call 'delete':</p>

<pre><code>std::unique_ptr&lt;Base&gt; myBase;

//Later...
myBase = new Derived;
myBase-&gt;myVirtualFunction();

//Automatically freed when the myBase smart pointer goes out of scope...
</code></pre>
",,19311658,412
15387091,2,15387028,2013-03-13T13:44:05.497,3,,1987218,,2013-03-13T13:44:05.497,,6,,"<pre><code>double value = 30.8365146;
int left_part, right_part;
char buffer[50];
sprintf(buffer, ""%lf"", value);
sscanf(buffer, ""%d.%d"", &amp;left_part, &amp;right_part);
</code></pre>

<p>and you will get left/right parts separately stored in integers.</p>

<p>P.S. the other solution is to just multiply your number by some power of 10 and send as an integer.</p>
",,19349507,1709
15388979,2,15387028,2013-03-13T15:04:51.117,0,,1627348,,2013-03-13T15:14:53.643,2013-03-13T15:14:53.643,0,,"<p>As in the comments, you need to keep track of the decimal places. You can't do a direct conversion to integer. A bit of code that would do something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define PLACES 3

void extract(double x)
{
        char buf[PLACES+10];
        int a, b;

        sprintf(buf, ""%.*f"", PLACES, x);
        sscanf(buf, ""%d.%d"", &amp;a, &amp;b);

        int n = (int) pow(10, PLACES);

        printf(""Number           : %.*f\n"", PLACES, x);
        printf(""  Integer        : %d\n"", a);
        printf(""  Fractional part: %d over %d\n"", b, n);
}

int main()
{
        extract(1.1128);
        extract(20.0);
        extract(300.000512);
}
</code></pre>

<p>Produces:</p>

<pre><code>Number           : 1.113
  Integer        : 1
  Fractional part: 113 over 1000
Number           : 20.000
  Integer        : 20
  Fractional part: 0 over 1000
Number           : 300.001
  Integer        : 300
  Fractional part: 1 over 1000
</code></pre>
",,19455232,387
40738148,2,15387028,2016-11-22T09:30:42.357,1,,1379268,,2016-11-22T09:30:42.357,,0,,"<p>I did it for float, using double as temporary:</p>

<pre><code>int fract(float raw) {

    static int digits = std::numeric_limits&lt;double&gt;::digits10 - std::numeric_limits&lt;float&gt;::digits10 - 1;
    float intpart;
    double fract = static_cast&lt;double&gt;(modf(raw, &amp;intpart));
    fract = fract*pow(10, digits - 1);
    return floor(fract);
}
</code></pre>

<p>I imagine that you could use quadruple-precision floating-point format to achieve the same for double: <a href=""https://gcc.gnu.org/onlinedocs/libquadmath/Typedef-and-constants.html#Typedef-and-constants"" rel=""nofollow noreferrer"">libquadmath</a>. </p>
",,19458619,52562
15394297,2,15393907,2013-03-13T19:08:29.880,0,,1627348,,2013-03-13T20:02:53.947,2013-03-13T20:02:53.947,12,,"<p>I posted this to another question you asked on this -- you need a set number of decimal places. A simple function will sort it out.</p>

<pre><code>#define PLACES 3

void extract(double x, int *a, int *b, int *n)
{
    char buf[PLACES+10];

    sprintf(buf, ""%.*f"", PLACES, x);
    sscanf(buf, ""%d.%d"", a, b);

    *n = (int) pow(10, PLACES);

    // integer part is a, fractional part b / n
}
</code></pre>

<p>e.g.</p>

<pre><code>    extract(30.2334567, &amp;a, &amp;b, &amp;n);
    printf(""%d, %d, %d\n"", a, b, n);

    -&gt; 30, 233, 1000
</code></pre>

<p>You could take <code>PLACES</code> as an integer parameter if you wanted to vary the precision.</p>
",,19483004,1112
15394557,2,15393907,2013-03-13T19:21:39.210,0,,1333675,,2013-03-13T19:21:39.210,,6,,"<p>Since this problem may involve rounding error, as suggested by the other answers, I would recommend doing the muliplication of your floating point values first, then subtracting.  For instance, this code prooduced the output you are looking for:  </p>

<pre><code>int main() {
    double num = 30.233;
    int a,b;
    a = floor(num);
    b = num * pow(10,3) - a * pow(10,3);
    printf(""%d"",b);

    num = 30.2334567;
    a = floor(num);
    b = num * pow(10,7) - a * pow(10,7);
    printf(""%d"", b);

    return 0;
}  
</code></pre>

<p>output: 233 and 2334567</p>
",,19501139,1661
15415876,2,15415839,2013-03-14T17:15:14.613,4,,,user1944441,2013-03-14T17:15:14.613,,1,,"<p>You can't return two times at once.</p>

<p>You could pass b to your function by reference.</p>

<pre><code>yourfunction( long a , long* b )
{    
    *b = a + 10;
    //more code

return a;
}

a = yourfunction(a , &amp;b );
</code></pre>
",,19507317,1591
15415896,2,15415839,2013-03-14T17:16:14.590,3,,1413845,,2016-02-04T21:14:15.773,2016-02-04T21:14:15.773,8,,"<p><strong>You can't return more than one value from a function in C.</strong> Either return a <code>struct</code>, or pass by reference and modify in the function.</p>

<p>Example 1: <code>struct</code></p>

<pre><code>struct ab {
  long a;
  long b;
}

struct ab Conv(double num) {
  struct ab ab_instance;

  ab_instance.a = floor(num);
  ab_instance.b = num * pow(10,6) - a * pow(10,6);

  return ab_instance;
}
</code></pre>

<p>Example 2: <code>pass b by reference</code></p>

<pre><code>long Conv(double num, long&amp; b) {
  long a;
  a = floor(num);
  b = num * pow(10,6) - a * pow(10,6);

  return a;
}
</code></pre>
",,19593790,56
15415924,2,15415839,2013-03-14T17:17:16.863,1,,1015286,,2013-03-14T17:17:16.863,,4,,"<p>Armin kind of answered it, but here is some sample code:</p>

<pre><code>int get_both(int* b) {
    a = 0;
    *b = 1;
    return a;
}
</code></pre>
",,19596564,224
15522215,2,15468219,2013-03-20T11:26:04.487,1,,2095650,,2013-03-20T12:25:25.780,2013-03-20T12:25:25.780,5,,"<p>Not having the exact code:</p>

<p>Pretty sure you're having this problem b/c something between the malloc and free is throwing (and you're probably catching it already so you don't exit the loop).  Depending on if this is happening in C (or objective-C) or C++ code, you have slightly different methods of resolution.</p>

<p>In C++, wrap the malloc/free in the RAII pattern so that when the stack is unwound the free is called.</p>

<pre><code>class MyData {
public:
    A(size_t numShorts) : dataPtr(0) { dataPtr = malloc(numShorts * sizeof(short)); }
    ~A() { free(dataPtr); }
    operator short*() { return dataPtr; }
private:
    short* dataPtr;
}

MyData data(numShorts);
// do your stuff, you can still use data as you were before due the 'operator short*'
// allow the dtor to be called when you go out of scope
</code></pre>

<p>In Objective-C you need to use a finally block:</p>

<pre><code>void* myPtr = 0;
@try { myPtr = malloc(...); }
@catch {}
@finally { free(myPtr); }
</code></pre>
",,19604737,3428
15524630,2,15523918,2013-03-20T13:15:21.540,1,,440558,,2013-03-20T13:15:21.540,,0,,"<p>In C++, if you have a C++11 capable compiler and you use <code>std::vector</code> instead of raw arrays, you could use <a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Initializer_lists"" rel=""nofollow"">initializer lists</a>:</p>

<pre><code> void kilos(const std::vector&lt;int&gt; percentage,
            const std::vector&lt;std::string&gt; liquid);

// ...

kilos({40, 60}, {""water"", ""milk""});
</code></pre>
",,19624460,1392
15580332,2,15580250,2013-03-22T21:43:09.267,7,,1761845,,2013-03-22T21:43:09.267,,2,,"<p>To compare the dataRX string to ""HELLO"", use:</p>

<pre><code>if (strcmp (dataRx,""HELLO"") == 0) {

    // matches HELLO

}
</code></pre>
",,19635007,12826
15599707,2,15599679,2013-03-24T14:31:33.653,6,,1932150,,2014-05-05T16:08:54.660,2014-05-05T16:08:54.660,0,,"<p>If the function is not <code>static</code>, you cannot pass it in input to a function that accepts a non-member function pointer. </p>

<p>Consider that a non-<code>static</code> member function has an implicit pointer to <code>ClassName</code> as its first parameter, which points to the object on which the member function is being invoked.</p>

<pre><code>struct X
{
    static void foo() { } // Does not have an implicit ""this"" pointer argument
    void bar() { } // Has an implicit ""this"" pointer argument
};

int main()
{
    void (*f)() = &amp;X::foo; // OK: foo is static
    void (*g)() = &amp;X::bar; // ERROR! bar is non-static
}
</code></pre>

<p>Here, not even <code>std::bind()</code> will work, because the result is not convertible to a function pointer. Lambdas are convertible to function pointers, but only if they are non-capturing (and a lambda here would need to capture the object to invoke the member function on).</p>

<p>Therefore, the only (ugly) workaround is to have a global adapter function which invokes the member function on an object which is available through a global pointer variable. The global pointer variable is set prior to calling the function:</p>

<pre><code>struct X
{
    void bar() { }
};

void function_taking_a_function_pointer(void (*f)())
{
    // Do something...
    f();
}

X* pX = nullptr;
void bar_adapter()
{
    pX-&gt;bar();
}

int main()
{
    X x; // Some object I want to invoke the member function bar() on...

    pX = &amp;x; // Set the global pointer and invoke the function...
    function_taking_a_function_pointer(bar_adapter);
}
</code></pre>

<p>If you want, you can make this slightly more flexible by turning <code>bar_adapter</code> into a function <em>template</em>, and passing the pointer-to-member-function as a template argument:</p>

<pre><code>template&lt;typename T, void (T::*mf)()&gt;
void adapter()
{
    (pX-&gt;*mf)();
}
</code></pre>

<p>Here is how you would use it:</p>

<pre><code>#include &lt;iostream&gt;

struct X
{
    void foo() { std::cout &lt;&lt; ""X::foo()"" &lt;&lt; std::endl; }
    void bar() { std::cout &lt;&lt; ""X::bar()"" &lt;&lt; std::endl; }
};

void function_taking_a_function_pointer(void (*f)())
{
    // Do something...
    f();
}

X* pX = nullptr;

template&lt;typename T, void (T::*mf)()&gt;
void adapter()
{
    (pX-&gt;*mf)();
}

int main()
{
    X x; // Some object I want to invoke the member function bar() on...

    pX = &amp;x; // Set the global pointer and invoke the function(s)...

    function_taking_a_function_pointer(adapter&lt;X, &amp;X::foo&gt;);
    function_taking_a_function_pointer(adapter&lt;X, &amp;X::bar&gt;);
}
</code></pre>

<p>Finally, here is a <a href=""http://liveworkspace.org/code/41HfPq%2438"" rel=""nofollow"">live example</a>.</p>
",,19657850,8735
15599741,2,15599679,2013-03-24T14:35:33.320,0,,1141471,,2013-07-24T17:53:50.597,2013-07-24T17:53:50.597,2,,"<p>You can use <code>boost::function&lt;&gt;</code> or <code>boost::bind&lt;&gt;</code> to point to a class member function:</p>

<pre><code># include &lt;boost/function.hpp&gt;
# include &lt;boost/bind.hpp&gt;
class FunctionClass {
    private:
       double a_;
    public:
       FunctionClass (const double &amp; a): a_(a ){}
       double multWithA (const double &amp; x) const { return a_*x;}
       double operator ()(const double &amp; x) const { return a_*x;}
};

FunctionClass myClass (2.0);
double x = 12.0;
boost :: function &lt;double (FunctionClass *, double)&gt; funcPtr , funcPtr1;
funcPtr =&amp; FunctionClass :: multWithA;
funcPtr1 =&amp; FunctionClass :: operator ();

std :: cout &lt;&lt; myClass . multWithA (x) &lt;&lt; std :: endl;
std :: cout &lt;&lt; funcPtr (&amp; myClass ,x) &lt;&lt; std :: endl;
std :: cout &lt;&lt; funcPtr1 (&amp; myClass ,x) &lt;&lt; std :: endl;

// Bind the function with the class instance
boost :: function &lt;double (double)&gt; funcPtrNew ;
funcPtrNew = boost :: bind (funcPtr ,&amp; myClass ,_1);
std :: cout &lt;&lt; funcPtrNew (x) &lt;&lt; std :: endl;
</code></pre>
",,19799576,735
15876481,2,15687784,2013-04-08T10:10:26.560,0,,2220627,,2013-04-08T10:15:31.517,2013-04-08T10:15:31.517,1,,"<p>I did not find a solution, but I found a workaround. Select can be used to block until there is a monitor event. After this udev_monitor_receie_device(mon) will return with a prober pointer to a device.</p>

<p>I can be done like this:</p>

<pre><code>    mon = udev_monitor_new_from_netlink(udev, ""udev"");
    if(mon==NULL) {
        wprinterr(""Could not create udev monitor!\n"");
        exit(EXIT_FAILURE);
    }
    if(udev_monitor_filter_add_match_subsystem_devtype(mon, ""block"", NULL) != 0) {
        wprinterr(""Could not add subsystem match to udev monitor\n"");
        exit(EXIT_FAILURE);
    }
    if(udev_monitor_enable_receiving(mon) != 0) {
        wprinterr(""Could not enable udev monitor receiving\n"");
        exit(EXIT_FAILURE);
    }    
    fd = udev_monitor_get_fd(mon);
    while (1) {
        /*
         * this will block until there is a monitor event
         */
        fd_set fds;
        int ret;
        FD_ZERO(&amp;fds);
        FD_SET(fd, &amp;fds);
        ret = select(fd+1, &amp;fds, NULL, NULL, NULL);

        /* Check if our file descriptor has received data. */
        if (ret &gt; 0 &amp;&amp; FD_ISSET(fd, &amp;fds)) {
            dev = udev_monitor_receive_device(mon);
            if (dev) {
</code></pre>
",,19823770,169
15709397,2,15709317,2013-03-29T18:38:55.100,1,,1126268,,2013-03-29T18:38:55.100,,1,,"<p>If your <code>enum</code> looks something like:</p>

<pre><code>enum /* ... */
{
  V1,
  V2,
  /* ... */ 
  VN
};
</code></pre>

<p>You can use the condition:</p>

<pre><code>if (v &lt; V1 || v &gt; VN)
{
  /* invalid */
}
</code></pre>

<p>However, if you give specific values, you have to check against every value. Macros can help you a bit.</p>

<p>There is also an aspect on the standard on this point, which says that, in:</p>

<pre><code>enum /* ... */
{
  V1 = 0,
  V2 = 2,
};
</code></pre>

<p><code>1</code> is a valid value for an <code>enum /*...*/</code> type. Therefore you have to elaborate a bit more what ""enumeration type check"" means for you.</p>
",,19846612,346
15734984,2,15734956,2013-03-31T21:54:18.617,6,,2089006,,2013-03-31T21:54:18.617,,3,,"<p>#define macro names are unique, these are not function definitions, so your second #define is overwriting the first. you may want to do something like </p>

<pre><code>#if defined(DEBUG)
    inline void debug(const char *s) { Serial.println(s); }
    inline void debug(const char *s, char *t) { Serial.print(s);Serial.println(t); }
#else
    inline void debug(const char *s) {  }
    inline void debug(const char *s, const char *t) { }
#endif
</code></pre>
",,19868156,37419
15769625,2,15768554,2013-04-02T16:43:11.953,0,,2149548,,2013-04-02T17:18:57.167,2013-04-02T17:18:57.167,2,,"<p>I think this should work, though, honestly, I have not tested it:</p>

<pre><code>String debinaryStringify(String source) {
    String result = """";
    int idxStart = 0;
    do {
        char val = 0;
        for (int i=0; i&lt;8; i++) {
            val += ((source.charAt(idxStart+i) == '1') &lt;&lt; (7-i)); // Trick: Assignment of an evaluation result
        }
        result.concat(val);
        idxStart = source.indexOf(' ') + 1;
    } while ( (idxStart &gt; 0) &amp;&amp; (idxStart &lt; source.length() - 7) );
    return result;
}
</code></pre>
",,19887409,2705
15784414,2,15776240,2013-04-03T10:05:32.957,0,,325697,,2013-04-03T10:05:32.957,,0,,"<p>Like @angelatlarge says, your code is doing exactly as what you ask it to (see his response for why).</p>

<p>Your first step should probably be to implement @angelatlarge's proposal: store the <em>state</em> of the button, and only send the character if it is not previously pressed and it is now. For one button, it would look something like this*:</p>

<pre><code>const int buttonA = 2;
boolean wasAPressed = false;
boolean isAPressed  = false;

// ...

loop() {

    isAPressed = (digitalRead(buttonA) == LOW);
    if(!wasAPressed &amp;&amp; isAPressed) {
        wasAPressed = true;
        Serial.write('A');
    } else if(wasPressed &amp;&amp; !isAPressed){
        wasAPressed = false;
    }

    // ...
}
</code></pre>

<p>The logic is basically simple. We have two boolean variables, giving you four possible options. If the button wasn't pressed and it is now, save the state (<code>wasAPressed = true</code>) and send the character. If it was previously pressed, but it isn't now, save the state (<code>wasAPressed = false</code>). In the remaining two cases, don't change anything.</p>

<p>Note however, that this will simply send a single 'A' every time you press button A. If you want to simulate a long press, you have to add additional logic on both sides. Here for example, I've established that 'Ad' means that the <strong>A</strong> button was pushed (<strong>d**own), while 'Au' means the *<em>A</strong> button was released (</em>*u**p).</p>

<pre><code>// ...

isAPressed = (digitalRead(buttonA) == LOW);
if(!wasAPressed &amp;&amp; isAPressed) {
    wasAPressed = true;
    Serial.write('Ad');
} else if(wasAPressed &amp;&amp; !isAPressed){
    wasAPressed = false;
    Serial.write('Au');
}

// ...
</code></pre>

<p>Your receiving code on your computer will then read the first character to know who we're talking about, and the second to know if it is a press or a release action. Finally, you must find the code required to simulate a key press and a key release individually.</p>
",,19888714,7118
16753637,2,15776390,2013-05-25T20:31:35.230,3,,700204,,2013-05-25T20:31:35.230,,3,,"<p>You can manipulate the amplitude of a PCM audio stream by applying a multiplier to each sample.  You can do this just prior to passing each buffer (sample set) to PortAudio.  It is as simple as:</p>

<pre><code>float buffer[SAMPLES_PER_BUFFER];
const float volumeMultiplier = 0.2f;
for(int i = 0; i &lt; SAMPLES_PER_BUFFER; ++i)
{
   buffer[i] *= volumeMultiplier;
}
</code></pre>

<p>However, the trick is in how you calculate your multiplier.  Generally you won't notice much change in the signal level until you cut the overall signal level in half <code>volumeMultiplier = 0.5f</code>.  As you may be aware the human ear does not perceive changes in volume level linearly, but logarithmically.  The following links may help explain this concept:</p>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Decibel#Acoustics"" rel=""nofollow"">http://en.wikipedia.org/wiki/Decibel#Acoustics</a></li>
<li><a href=""http://en.wikipedia.org/wiki/Sound_pressure"" rel=""nofollow"">http://en.wikipedia.org/wiki/Sound_pressure</a></li>
<li><a href=""http://www.sengpielaudio.com/calculator-levelchange.htm"" rel=""nofollow"">http://www.sengpielaudio.com/calculator-levelchange.htm</a></li>
</ul>

<p>Using this information one might change the code above as such:</p>

<pre><code>float buffer[SAMPLES_PER_BUFFER];
//volume in dB 0db = unity gain, no attenuation, full amplitude signal
//           -20db = 10x attenuation, significantly more quiet
float volumeLevelDb = -6.f; //cut amplitude in half; same as 0.5 above
const float VOLUME_REFERENCE = 1.f;
const float volumeMultiplier = (VOLUME_REFERENCE * pow(10, (volumeLevelDb / 20.f);
for(int i = 0; i &lt; SAMPLES_PER_BUFFER; ++i)
{
   buffer[i] *= volumeMultiplier;
}
</code></pre>

<p>For your purposes this may not be important, but if you were to attach the value of volumeLevelDb or volumeMultiplier to a user interface like a slider widget, the difference would be apparent.</p>

<p>You can apply this algorithm to any data type.</p>
",,19894323,2000
15805315,2,15803986,2013-04-04T07:44:59.690,1,,2216000,,2018-07-19T23:01:40.403,2018-07-19T23:01:40.403,2,,"<p>You can simplify your code by using a struct for your color.</p>

<pre><code>struct Color
{
    unsigned char r;
    unsigned char g;
    unsigned char b;
};
</code></pre>

<p>Then, it is easy to have a fading function</p>

<pre><code>// the old color will be modified, hence it is not given as reference
void fade(Color old, const Color&amp; newColor)
{
    // get the direction of increment first (count up or down)
    // each of the inc_x will be either 1 or -1
    char inc_r = (newColor.r - old.r)/abs(newColor.r-old.r); // note, that the right hand side will be sign extended to int according to the standard.
    char inc_g = (newColor.g - old.g)/abs(newColor.g-old.g);
    char inc_b = (newColor.g - old.g)/abs(newColor.g-old.g);

    fadeOneColor(old.r, newColor.r, inc_r, old);
    fadeOneColor(old.g, newColor.g, inc_g, old);
    fadeOneColor(old.b, newColor.b, inc_b, old);
}

void fadeOneColor( unsigned char&amp; col_old, 
                   const unsigned char&amp; col_new, 
                   const char inc, 
                   Color&amp; col)
{
    while(col_old != col_new)
    {
        col_old += inc;
        SetColor(col); 
        delay(20);
    }        
}
</code></pre>
",,20019618,247
15816597,2,15803986,2013-04-04T16:24:54.933,13,,2149548,,2013-04-05T17:32:10.333,2013-04-05T17:32:10.333,5,,"<p>What the other answers omit about this topic is the fact that that human perception of light intensity is <a href=""http://www.youtube.com/watch?v=FfdsXqpnCEs"" rel=""noreferrer"">logarithmic, not linear</a>. The <code>analogWrite()</code> routines are setting the output pin's <a href=""http://en.wikipedia.org/wiki/Pulse-width_modulation"" rel=""noreferrer"">PWM</a> duty cycle, and are linear. So by taking the minimum duty cycle (say <code>0</code>) and maximum duty cycle (say, for the sake of easy math this is <code>10</code>) and dividing it into equal chunks, you will be controlling the intensitiy <em>linearly</em> which will not give satisfying results.</p>

<p>What you need to do instead is set your intensity exponentially. Let's say your maximum intensity is <code>255</code>. You can generate this result by treating your intensity as a power to raise some number to. In our case, given that we are dealing with computers that like binary, powers of two are convenient. So, </p>

<pre><code>2^0 =1
2^8=256
</code></pre>

<p>so we can have 8 intensity levels. Actually, note that out minimum is now not fully off (it is <code>1</code> not <code>0</code>) and our maximum is out of range (<code>256</code> not <code>255</code>). So we modify the formula to be </p>

<blockquote>
<pre><code>output = 2 ^ intensity - 1
</code></pre>
</blockquote>

<p>Or in code</p>

<pre><code>int output = 1&lt;&lt;intensity - 1;
</code></pre>

<p>This yields values from 0 to 255 for intensity levels from <code>0</code> to <code>8</code> (inclusive), so we actually get nine levels of intensity.  If you wanted smoother transitions (i.e. more levels of intensity), and still use logarithmic intensity you'll need floating-point math.</p>

<p>If you apply this method of calculating intensity to each channel (R, G, B) then your perception will be in accord with what your code says it should be.  </p>

<hr>

<p>As fars as how to smoothly transition between various colors, the answer depends on how you want to navigate the color space. The simplest thing to do is to think about your color space as a triangle, with R, G, and B, as the verteces:</p>

<p><img src=""https://i.stack.imgur.com/EojvP.jpg"" alt=""enter image description here""></p>

<p>The question then is how to navigate this triangle: you could go along the sides, from R, to G, to B. This way you will never see white (all channels fully on) or ""black"" (all fully off). You could think of your color space as a hexagon, with additional purple (R+B), yellow (G+B), and brown (R+G) colors, and also navigate the perimeter (again, no white or black). There are as many fading possibilities as there are ways of navigating insides these, and other figures we might think of.</p>

<p>When I built fading programs like this the color space and the traversal I liked was as follows: think of each channel as a binary bit, so now you have three (R, G, and B). If you think of each color as having some combination of these channels being fully on, you get 7 total colors (excluding black, but including white). Take the first of these colors, fade to it from black and back to black, and then go to the next color. Here's some code that does something like that:</p>

<pre><code>int targetColor = 1;
int nIntensity = 0;
int nDirection = 1;         // When direction is 1 we fade towards the color (fade IN)
                            // when 0 we fade towards black (fade OUT)
#define MAX_INTENSITY 8
#define MIN_INTENSITY 0
#define MAX_TARGETCOLOR 7

void loop() {
    for (;;) {

        // Update the intensity value
        if (nDirection) {
            // Direction is positive, fading towards the color
            if (++nIntensity &gt;= MAX_INTENSITY) {
                // Maximum intensity reached
                nIntensity = MAX_INTENSITY;  // Just in case
                nDirection = 0;             // Now going to fade OUT
            } // else : nothing to do
        } else {
            if (--nIntensity &lt;= MIN_INTENSITY) {
                nIntensity = MIN_INTENSITY; // Just in case
                // When we get back to black, find the next target color
                if (++targetColor&gt;MAX_TARGETCOLOR) 
                    targetColor=1;          // We'll skip fading in and out of black
                nDirection = 1;             // Now going to fade IN
            } // else: nothing to do
        }

        // Compute the colors
        int colors[3];
        for (int i=0;i&lt;3;i++) {
            // If the corresponding bit in targetColor is set, it's part of the target color
            colors[i] = (targetColor &amp; (1&lt;&lt;i)) ? (1&lt;&lt;nIntensity) -1 : 0;
        }

        // Set the color
        setColor(colors[0], colors[1], colors[2]);

        // Wait
        delay(100);     
    }
}
</code></pre>
",,20081286,25362
21181842,2,15803986,2014-01-17T09:10:18.533,9,,2082884,,2014-01-17T12:45:57.747,2014-01-17T12:45:57.747,0,,"<p>It is indeed possible to fade between different colors. What I'm also usually missing in Arduino books and code on the web is, that it is possible to write C++ classes in Arduino IDE. Therefore, I'm going to show an example that fades between colors using C++ classes.</p>

<p>An issue that should be addressed is on which pins the analogWrite should be done to, because not all pins are capable of Pulse Width Modulation (<a href=""http://en.wikipedia.org/wiki/Pulse-width_modulation"" rel=""noreferrer"">PWM</a>). On a Arduino device the pins that support PWM are denoted with a tilde '~'. The Arduino UNO has digital pins ~3, ~5, ~6, ~9, ~10 and ~11. And most Arduino use those pins for PWM, but check your device to be sure. You can create PWM on regular digital pins by switching your led on for 1ms and of for 1 ms this mimics 50% power on the LED. Or turn it on 3 ms and of 1 ms this mimics 75% power.</p>

<p>In order to fade a LED you would have to reduce/increase the PWM value and wait a bit. Youl'll have to wait a little while, because otherwise the arduino tries to fade/dim leds thousands of times per second and you won't see a fade effect, although it probably there. So you are looking for a method to gradually reduce/increase the second parameter to <code>analogWrite( )</code> for three LEDs; For a more thorough explanation see for example chapter 7 of <a href=""http://shop.oreilly.com/product/0636920022244.do"" rel=""noreferrer"">Arduino Cookbook</a>. That book is a good read for Arduino fans anyway!</p>

<p>So I adapted the code from the OP to contain a 'rgb_color' class that is more or less just a container for red, green and blue values. But more importantly is the fader class. When an instance of fader is constructed the proper pins should be in the constructor red, green and blue respectively. Than the fader contains a member function <code>void fade( const rgb_color&amp; const rgb_color&amp;)</code> which will do the fading between the in and out color. By default the function will take 256 steps of 10ms from the input color to the output color. (note here due to integer divisions this doesn't really mean that each step 1/256 th, but perceputally you won't notice it).</p>

<pre><code>/*
 * LedBrightness sketch
 * controls the brightness of LEDs on ""analog"" (PWM) output ports.
 */

class rgb_color {

  private:
    int my_r;
    int my_g;
    int my_b;
  public:
    rgb_color (int red, int green, int blue)
      :
        my_r(red),
        my_g(green),
        my_b(blue)
    {
    }

    int r() const {return my_r;}
    int b() const {return my_b;}
    int g() const {return my_g;}
};

/*instances of fader can fade between two colors*/
class fader {

  private:
    int r_pin;
    int g_pin;
    int b_pin;

  public:
    /* construct the fader for the pins to manipulate.
     * make sure these are pins that support Pulse
     * width modulation (PWM), these are the digital pins
     * denoted with a tilde(~) common are ~3, ~5, ~6, ~9, ~10 
     * and ~11 but check this on your type of arduino. 
     */ 
    fader( int red_pin, int green_pin, int blue_pin)
      :
        r_pin(red_pin),
        g_pin(green_pin),
        b_pin(blue_pin)
    {
    }

    /*fade from rgb_in to rgb_out*/
    void fade( const rgb_color&amp; in,
               const rgb_color&amp; out,
               unsigned n_steps = 256,  //default take 256 steps
               unsigned time    = 10)   //wait 10 ms per step
    {
      int red_diff   = out.r() - in.r();
      int green_diff = out.g() - in.g();
      int blue_diff  = out.b() - in.b();
      for ( unsigned i = 0; i &lt; n_steps; ++i){
        /* output is the color that is actually written to the pins
         * and output nicely fades from in to out.
         */
        rgb_color output ( in.r() + i * red_diff / n_steps,
                           in.g() + i * green_diff / n_steps,
                           in.b() + i * blue_diff/ n_steps);
        /*put the analog pins to the proper output.*/
        analogWrite( r_pin, output.r() );
        analogWrite( g_pin, output.g() );
        analogWrite( b_pin, output.b() );
        delay(time);
      }
    }

};

void setup()
{
  //pins driven by analogWrite do not need to be declared as outputs
}

void loop()
{
  fader f (3, 5, 6); //note OP uses 9 10 and 11
  /*colors*/
  rgb_color yellow( 250, 105,   0 );
  rgb_color orange( 250,  40,   0 );
  rgb_color red   ( 255,   0,   0 );
  rgb_color blue  (  10,  10, 255 );
  rgb_color pink  ( 255,   0, 100 );
  rgb_color purple( 200,   0, 255 );
  rgb_color green (   0, 255,   0 );
  rgb_color white ( 255, 255, 255 );

  /*fade colors*/
  f.fade( white, yellow);
  f.fade( yellow, orange);
  f.fade( orange, red);
  f.fade( red, blue);
  f.fade( blue, pink);
  f.fade( pink, purple);
  f.fade( purple, green);
  f.fade( green, white);
}
</code></pre>
",,20131002,837
34161044,2,15803986,2015-12-08T16:29:15.107,0,,794283,,2015-12-08T16:29:15.107,,0,,"<p>Here's a fast linear fade between two RGB values stored in <code>uint32_t</code> as <code>0x00RRGGBB</code> as is used in many addressable RGB pixel strips such as in NeoPixel (and is inspired by some of the code in the NeoPixel Arduino library).</p>

<p>It doesn't take colour space into consideration but still looks nice and smooth in practice.</p>

<pre><code>uint32_t fadeColor(uint32_t const x, uint32_t const y, uint8_t const fade)
{
  // boundary cases don't work with bitwise stuff below
  if (fade == 0)
  {
    return x;
  }
  else if (fade == 255)
  {
    return y;
  }

  uint16_t const invFadeMod = (255 - fade) + 1;
  uint16_t const fadeMod = fade + 1;
  // overflows below to give right result in significant byte
  uint8_t const xx[3] // r g b
  {
    static_cast&lt;uint8_t&gt;((uint8_t(x &gt;&gt; 16) * invFadeMod) &gt;&gt; 8),
    static_cast&lt;uint8_t&gt;((uint8_t(x &gt;&gt; 8) * invFadeMod) &gt;&gt; 8),
    static_cast&lt;uint8_t&gt;((uint8_t(x &gt;&gt; 0) * invFadeMod) &gt;&gt; 8),
  };
  uint8_t const yy[3] // r g b
  {
    static_cast&lt;uint8_t&gt;((uint8_t(y &gt;&gt; 16) * fadeMod) &gt;&gt; 8),
    static_cast&lt;uint8_t&gt;((uint8_t(y &gt;&gt; 8)* fadeMod) &gt;&gt; 8),
    static_cast&lt;uint8_t&gt;((uint8_t(y &gt;&gt; 0)* fadeMod) &gt;&gt; 8),
  };
  return ((uint32_t)(xx[0] + yy[0]) &lt;&lt; 16) | ((uint32_t)(xx[1] + yy[1]) &lt;&lt;  8) | (xx[2] + yy[2]);
}
</code></pre>
",,20204391,113
39083653,2,15803986,2016-08-22T15:41:48.833,5,,6744018,,2016-08-22T16:09:16.170,2016-08-22T16:09:16.170,0,,"<p>This is probably what you are looking for. Whenever we want to shift color over the spectrum and trasition the colors in a circular and smooth motion, what we are really doing is shifting light using HUE in the HSI/HSV (Hue, Saturation, Intensity/Value) color space.</p>

<p>Take if you will this figure:</p>

<p><a href=""https://i.stack.imgur.com/leqbL.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/leqbL.jpg"" alt=""enter image description here""></a></p>

<p>We will attach a value from 0-360 for hue because hue has 360 degrees of color.
A value of 0.00 - 1.00 for saturation, and a value of 0.00 -1.00 for intensity/value</p>

<p>Here is my circuit on the MEGA 2560:
<a href=""https://i.stack.imgur.com/3DZ6W.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3DZ6W.jpg"" alt=""enter image description here""></a></p>

<p>Here is video of this code running:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/gGG-GndSKi0"" frameborder=""0"" allowfullscreen&gt;&lt;/iframe&gt;</code></pre>
</div>
</div>
</p>

<p>So lets build  a function that we can pass the hue value and a for loop inside our loop function to call that value 360 times to shift over the full rainbow of color.</p>

<pre><code>//Define the pins we will use with our rgb led
int redPin = 9;
int greenPin = 10;
int bluePin = 11;

//define that we are using common anode leds
#define COMMON_ANODE

void setup()
{
  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);
}

int rgb[3];
//Arduino has no prebuilt function for hsi to rgb so we make one:
void hsi_to_rgb(float H, float S, float I) {
  int r, g, b;
  if (H &gt; 360) {
    H = H - 360;
  }
  // Serial.println(""H: ""+String(H));
  H = fmod(H, 360); // cycle H around to 0-360 degrees
  H = 3.14159 * H / (float)180; // Convert to radians.
  S = S &gt; 0 ? (S &lt; 1 ? S : 1) : 0; // clamp S and I to interval [0,1]
  I = I &gt; 0 ? (I &lt; 1 ? I : 1) : 0;
  if (H &lt; 2.09439) {
    r = 255 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    g = 255 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    b = 255 * I / 3 * (1 - S);
  } else if (H &lt; 4.188787) {
    H = H - 2.09439;
    g = 255 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    b = 255 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    r = 255 * I / 3 * (1 - S);
  } else {
    H = H - 4.188787;
    b = 255 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    r = 255 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    g = 255 * I / 3 * (1 - S);
  }
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;

}
void setColor(int red, int green, int blue)
{
  #ifdef COMMON_ANODE
    red = 255 - red;
    green = 255 - green;
    blue = 255 - blue;
  #endif
  analogWrite(redPin, red);
  analogWrite(greenPin, green);
  analogWrite(bluePin, blue);
}


///here we have our main loop and the for loop to shift color
void loop()
{
//the for loop counts to 360 and because its in our control loop it will run forever
// We will use int i to increment the actual desired color 
for (int i=0; i&lt;=360;i++){
  hsi_to_rgb(i,1,1);
  setColor(rgb[0],rgb[1],rgb[2]);
  //Changing the delay() value in milliseconds will change how fast the
  //the light moves over the hue values 
  delay(5);
  }


}
</code></pre>
",,20209975,444
15806907,2,15806552,2013-04-04T09:07:28.103,6,,,user529758,2013-04-04T09:17:07.007,2013-04-04T09:17:07.007,4,,"<p>Definitely. And using exactly the same method: serial communication. Since I'm not a great Windows expert, I can't write you a complete Windows example, but here are some snippets that may get you started on a Unix (Linux, OS X, etc.):</p>

<p>Code on the Arduino:</p>

<pre><code>#define POT_PIN 1

void setup()
{
    Serial.begin(9600); // 9600 baud is more than enough
}

void loop()
{
    int pot = analogRead(POT_PIN);
    unsigned char byte = (pot + 2) &gt;&gt; 2; // round and divide by 4
    Serial.write(pot);
    delay(100); // or do something useful
}
</code></pre>

<p>Code on the computer:</p>

<pre><code>#include &lt;termios.h&gt;

struct termios tio;
memset(&amp;tio, 0, sizeof(tio));

// Open serial port in mode `8N1', non-blocking
tio.c_cflag = CS8 | CREAD | CLOCAL;
tio.c_cc[VMIN] = 1;
tio.c_cc[VTIME] = 5;

int fd = open(device, O_RDONLY);

cfsetospeed(&amp;tio, B9600);
cfsetispeed(&amp;tio, B9600);
tcsetattr(fd, TCSANOW, &amp;tio);

while (1) {
    unsigned char byte;
    read(fd, &amp;byte, 1);
    use_some_library_to_set_volume(byte);
}
</code></pre>
",,20233454,7561
15884894,2,15819298,2013-04-08T17:04:35.203,1,,1419911,,2013-04-08T17:04:35.203,,0,,"<p>Ok, so this works on my raspberry Pi.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int inc(int x){ //increments x

    uint32_t *ret = mmap(NULL,
            2 * sizeof(uint32_t),  // Space for 16 instructions. (More than enough.)
            PROT_READ | PROT_WRITE | PROT_EXEC,
            MAP_PRIVATE | MAP_ANONYMOUS,
            -1,0);
    if (ret == MAP_FAILED) {
        printf(""Could not mmap a memory buffer with the proper permissions.\n"");
        return -1;
    }

    *(ret + 0) = 0xE2800001; //add r0 r0 #1 := r0 += 1
    *(ret + 1) = 0xE12FFF1E; //bx lr        := jump back to inc()

    __clear_cache((char*) ret, (char*) (ret+2));

    int(*f)(int) = (int (*)(int)) ret;
    return (*f)(x);
}

int main(){
    printf(""%d\n"",inc(6)); //expect '7' to be printed
exit(0);}
</code></pre>
",,20237657,1502
15836575,2,15819640,2013-04-05T14:31:40.593,0,,25639,,2013-08-14T17:52:48.933,2013-08-14T17:52:48.933,0,,"<blockquote>
  <p>Is the return always signed?</p>
</blockquote>

<p>Technically, yes. Wire.read() returns a signed int. However, the actual value should 0-255 (like an unsigned byte) or, as Grijesh says, if the read fails it returns a -1.</p>

<blockquote>
  <p>If the register I read with Wire.read() has values (signed) that are saved with the two's complement method, how can Wire.read() understand it?</p>
</blockquote>

<p>My understanding is that the I²C protocol sends 8-bit bytes. It doesn't have any concept of signed or unsigned. If the device you are communicating with sends two's complement signed values, it may be as simple as casting the results of the read to a <code>char</code> type.</p>

<p>For example,</p>

<pre><code>int r;
char c;
r = Wire.read();
if (r != -1) {
    c = char(r);
}
</code></pre>

<p>Note that you need to check if the return value is -1 before casting to char. Otherwise you can't tell if there was an error or if the byte read was actually -1.</p>
",,20257486,1167
15830385,2,15830046,2013-04-05T09:30:18.723,2,,2247801,,2013-04-05T09:30:18.723,,1,,"<pre><code>#include &lt;header.h&gt; // which contatining some delay function
void blink(int pin)
{ 
    //Program the pin (which GPIO) to  high
    //delay function
    //Program the pin (which GPIO) to low
    //delay
    return 0;
}
main()
{
// to use Raspberry Pi board pin numbers  
GPIO.setmode(GPIO.BOARD)  //check this fun def and find out what it is doing and code it accordingly

// set up GPIO 11 as output channel  

// blink GPIO11 50 times  
for(i=0;i&lt;50;i++)  
        blink(11);

GPIO.cleanup() ////check this fun def and find out what it is doing and code it
</code></pre>
",,20305267,2145
15931804,2,15931690,2013-04-10T16:48:01.437,2,,1524450,,2013-04-10T16:56:38.320,2013-04-10T16:56:38.320,1,,"<p>You could use <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow"">sprintf</a>:</p>

<pre><code>char str[64];  // Or whatever length you need to fit the resulting string
sprintf(str, ""%s:%s,"", name, data);
</code></pre>

<p>Or <a href=""http://www.cplusplus.com/reference/cstring/strcat/"" rel=""nofollow"">strcpy/strcat</a>:</p>

<pre><code>char str[64];
strcpy(str, name);
strcat(str, "":"");
strcat(str, data);
strcat(str, "","");
</code></pre>

<p><br>Or just use C++'s <a href=""http://www.cplusplus.com/reference/string/string/operator+/"" rel=""nofollow"">std::string</a>.</p>
",,20313178,75
15935984,2,15935885,2013-04-10T20:42:27.117,1,,2248845,,2013-04-12T09:50:53.853,2013-04-12T09:50:53.853,0,,"<p>Using a namespace you can solve this problem:</p>

<pre><code>namespace foo
{
    int val =1;
}

namespace bar
{
    int val =3;
}

using namespace foo;

int x = val; //Now x will be assigned with 1
</code></pre>
",,20319607,1374
15936045,2,15935885,2013-04-10T20:46:41.277,0,,1141471,,2013-04-12T09:51:11.420,2013-04-12T09:51:11.420,0,,"<p>A namespace is what you need:</p>

<pre><code>namespace foo
{
    int v =100;
}

namespace bar
{
    int v =500;
}
</code></pre>
",,20339456,1551
16003763,2,15999272,2013-04-14T20:05:51.500,0,,1593860,,2016-10-05T16:32:33.940,2016-10-05T16:32:33.940,0,,"<pre><code>#include &lt;iostream&gt;

char mychar = 'k';
int ASCIItranslate(char ch) {
    return ch;
}

int main() {
    std::cout &lt;&lt; ASCIItranslage(mychar);
    return 0;
}
</code></pre>

<p>That's your original code with the various syntax errors fixed. Assuming you're using a compiler that uses ASCII (which is pretty much every one these days), it works. Why do you think it's wrong?</p>
",,20359770,1236
16067425,2,16067339,2013-04-17T18:27:34.320,0,,527574,,2013-04-17T18:27:34.320,,0,,"<p>In C, I do not believe it is possible to access a bitfield as an array.  One idea would be to pass in a enumerated type or constant and switch off its value into 8 different set functions.  Not the cleanest way, but I believe it would work.</p>

<pre><code>
#define PTAD5  5
...

void setbit(PTADSTR byte, int bit)
{
    switch(bit)
    {
        ...
        case PTAD5  : byte.PTAD5 = 1; break;
        default: ASSERT_ALWAYS(); break;
    }
}
</code></pre>
",,20383780,1951
39534708,2,16067339,2016-09-16T15:05:07.297,0,,1549060,,2016-09-16T15:05:07.297,,0,,"<p>How about this?
Using the static const qualifier should make sure the memory overhead is about zero</p>

<pre><code>typedef struct
{
    uint8_t* reg;
    uint8_t bitnum;
}bit;

void setbit(bit b)
{
    *b.reg |= (1 &lt;&lt; b.bitnum);
}

void clrbit(bit b)
{
    *b.reg &amp;= ~(1 &lt;&lt; b.bitnum);
}

static const bit PTAD_PTAD0 = {&amp;PTAD, 0};
static const bit PTAD_PTAD1 = {&amp;PTAD, 1};
static const bit PTAD_PTAD2 = {&amp;PTAD, 2};
static const bit PTAD_PTAD3 = {&amp;PTAD, 3};
static const bit PTAD_PTAD4 = {&amp;PTAD, 4};
static const bit PTAD_PTAD5 = {&amp;PTAD, 5};
static const bit PTAD_PTAD6 = {&amp;PTAD, 6};
static const bit PTAD_PTAD7 = {&amp;PTAD, 7};

int main()
{
    printf(""PTAD: %02X\n"", PTAD);
    setbit(PTAD_PTAD0);
    printf(""PTAD: %02X\n"", PTAD);
    clrbit(PTAD_PTAD0);
    printf(""PTAD: %02X\n"", PTAD);

}
</code></pre>
",,20417043,1921
16081049,2,16080639,2013-04-18T10:56:08.817,2,,28169,,2013-04-18T10:56:08.817,,0,,"<p>It uses the <a href=""http://www.khronos.org/egl/"" rel=""nofollow"">EGL</a> native platform interface.</p>

<p>Here's some code from the <a href=""https://github.com/huceke/omxplayer/blob/master/SubtitleRenderer.cpp"" rel=""nofollow"">SubtitleRenderer</a> class:</p>

<pre><code>void SubtitleRenderer::initialize_vg() {
  // get an EGL display connection
  display_ = eglGetDisplay(EGL_DEFAULT_DISPLAY);
  ENFORCE(display_);

  // initialize the EGL display connection
  ENFORCE(eglInitialize(display_, NULL, NULL));

  // get an appropriate EGL frame buffer configuration
  static const EGLint attribute_list[] = {
    EGL_RED_SIZE, 8,
    EGL_GREEN_SIZE, 8,
    EGL_BLUE_SIZE, 8,
    EGL_ALPHA_SIZE, 8,
    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
    EGL_NONE
  };
  EGLConfig config{};
  EGLint num_config{};

  ENFORCE(eglChooseConfig(display_, attribute_list, &amp;config, 1, &amp;num_config));
</code></pre>
",,20434064,67
16124571,2,16124494,2013-04-20T20:00:05.037,1,,,user529758,2013-04-20T20:00:05.037,,4,,"<p>You can't. But you can count to 33:</p>

<pre><code>static int cnt = 0;

if (brightness2 == 0 || brightness2 == 255) {
    fadeAmount2 = -fadeAmount2 ; 
}

delay(30);
cnt = (cnt + 1) % 33;
if (cnt == 0) {
    Serial.println((byte)tempC);
}
</code></pre>

<p>This will make the fading work as fast as before, <strong>and</strong> the printing will fire every once in 990 milliseconds.</p>
",,20453473,2573
16179807,2,16178873,2013-04-23T21:51:14.717,0,,717998,,2013-04-23T22:03:38.247,2013-04-23T22:03:38.247,2,,"<p>There is a lack of documentation on this at the moment, one needs to look at the source code to find out. These error codes are defined in <a href=""https://github.com/amcewen/HttpClient/blob/master/HttpClient.h"" rel=""nofollow""><code>HttpClient.h</code></a> as below:</p>

<pre><code>// The end of the headers has been reached.  This consumes the '\n'
static const int HTTP_SUCCESS =0;
// Could not connect to the server
static const int HTTP_ERROR_CONNECTION_FAILED =-1;
// This call was made when the HttpClient class wasn't expecting it
// to be called.  Usually indicates your code is using the class
// incorrectly
static const int HTTP_ERROR_API =-2;
// Spent too long waiting for a reply
static const int HTTP_ERROR_TIMED_OUT =-3;
// The response from the server is invalid, is it definitely an HTTP
// server?
static const int HTTP_ERROR_INVALID_RESPONSE =-4;
</code></pre>
",,20461691,2163
16221708,2,16221641,2013-04-25T18:07:55.487,4,,1935008,,2013-04-25T18:13:51.197,2013-04-25T18:13:51.197,3,,"<p>the simplest would be to use atoi:
<a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/atoi/</a></p>

<pre><code>#include &lt;cstdlib&gt;  
int getNumber(char* pMsg){
    //assuming format is always R#
    return std::atoi((char*)(pMsg+1));
}
</code></pre>

<p>Or, you can use atoi directly instead of getNumber...</p>
",,20481777,2838
16221839,2,16221641,2013-04-25T18:16:18.507,2,,410112,,2013-04-25T18:26:20.547,2013-04-25T18:26:20.547,1,,"<p>Function specifies return type of int so we must return an integer. 
Using sscanf() allows you to parse/format other data types in one function call.</p>

<p>In C++: using sscanf()</p>

<pre><code>    /* sscanf example */
    #include &lt;cstdlib&gt;

    int getNumber(char* pMsg){
        int result;
        ...
        sscanf (pMsg,""R%d"",&amp;result);  
        return result;
    }
</code></pre>
",,20534259,71
16224741,2,16224740,2013-04-16T00:47:14.147,3,,1512962,Annonomus Person,2013-04-16T00:47:14.147,2020-06-20T09:12:55.060,0,,"<p><strong>It just, like you said, a type of variable (such as <code>int</code> (integer)) that can store a IP address.</strong> Using integers, you cannot add the <code>.</code>s needed in the IP address. Also, the library only accepts integers, because with strings, things &quot;can get messy.&quot; For example, if you have <code>1</code> in a string, you cannot add that with another number. However, if you have the integer variable type with the value of <code>1</code>, it would add easily.</p>
<hr />
<p><strong>How can I use this?:</strong></p>
<p>On <a href=""http://arduino.cc/en/Reference/EthernetIPAddress"" rel=""nofollow noreferrer"">Arduino's EthernetIpAdress page</a>, there is this code:</p>
<pre><code> #include &lt;Ethernet.h&gt;
 
 // network configuration.  gateway and subnet are optional.
 
  // the media access control (ethernet hardware) address for the shield:
 byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };  
 // the router's gateway address:
 byte gateway[] = { 10, 0, 0, 1 };
 // the subnet:
 byte subnet[] = { 255, 255, 0, 0 };
 
 EthernetServer server = EthernetServer(23);
 
 //the IP address is dependent on your network
 IPAddress ip(192,168,1,1);
 void setup()
 {
   // initialize the ethernet device
   Ethernet.begin(mac, ip, gateway, subnet);
 
   // start listening for clients
   server.begin();
 }
 void loop()
 {
   //print out the IP address
   Serial.println(myIPaddress);
 }
</code></pre>
<hr />
<p>On the line <code>IPAddress ip(192,168,1,1);</code>, it creates a variable that holds the IP address. In the line <code>Ethernet.begin(mac, ip, gateway, subnet);</code> the variable is looked up and given to the <code>Ethernet</code> library. I don't know what the advantage would be, besides trying to prevent people from using the integer type and making it look cleaner. It could look up the automatically issued IP address and then store it for later so if it goes into an &quot;idle mode,&quot; it can ask for the same IP address so it is almost like a dynamic IP that wouldn't interfere with other devices and would reset when the reset button is pushed. I'm sure that there is some use for it, but I cannot think of one. I just wanted to tell you what it is and how to use it. I would think though that it would be easier just to use <code>#define IPadress 192.168.1.1</code> or a similar thing if you wanted it to easily be changed or to be more user readable.</p>
",,20551976,9400
21505275,2,16224746,2014-02-01T23:53:46.983,1,,586057,,2021-02-14T23:41:14.693,2021-02-14T23:41:14.693,2,,"<p>Please, note, that there is no easy way to specify additional flags from Arduino IDE or use other IDE (<a href=""https://en.wikipedia.org/wiki/Eclipse_%28software%29"" rel=""nofollow noreferrer"">Eclipse</a>, <a href=""https://en.wikipedia.org/wiki/Code::Blocks"" rel=""nofollow noreferrer"">Code::Blocks</a>, etc.) or command line.</p>
<p>As a hack, you can use a small proxy program (should be cross-platform):</p>
<pre><code>//============================================================================
// Name        : gcc-proxy.cpp
// Copyright   : Use as you want
// Description : Based on http://stackoverflow.com/questions/5846934/how-to-pass-a-vector-to-execvp
//============================================================================

#include &lt;unistd.h&gt;

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
using namespace std;

int main(int argc, char *argv[]) {
    vector&lt;string&gt; arguments;
    vector&lt;const char*&gt; aptrs;

    // Additional options, one per line
    ifstream cfg((string(argv[0]) + &quot;.ini&quot;).c_str());
    if (cfg.bad())
        cerr &lt;&lt; &quot;Could not open ini file (you're using proxy for some reason, er?)&quot; &lt;&lt; endl;

    string arg;
    while (cfg) {
        getline(cfg, arg);
        if(arg == &quot;\r&quot; || arg == &quot;\n&quot;)
            continue;
        arguments.push_back(arg);
    }

    for (const string&amp; arg : arguments)
        aptrs.push_back(arg.c_str());

    for (int i = 1; i &lt; argc; ++i)
        aptrs.push_back(argv[i]);

    // Add null pointer at the end, execvp expects NULL as last element
    aptrs.push_back(nullptr);

    // Pass the vector's internal array to execvp
    const char **command = &amp;aptrs[0];

    return execvp(command[0], command);
}
</code></pre>
<ol>
<li>Compile the program.</li>
<li>Rename the original avr-g++.exe to avr-g++.orig.exe (or any other name).</li>
<li>Create avr-g++.ini file where the first line is FULL path to the original program (e.g. D:\Arduino\hardware\tools\avr\bin\avr-g++.orig.exe) and add additional parameters, one per line, as desired.</li>
</ol>
<p>You're done!</p>
<p>Example <em>avr-g++.ini</em>:</p>
<pre><code>D:\Arduino\hardware\tools\avr\bin\avr-g++.orig.exe
-std=c++0x
</code></pre>
",,20561328,3366
16242561,2,16242435,2013-04-26T18:01:46.840,2,,593382,,2013-04-26T18:12:03.817,2013-04-26T18:12:03.817,6,,"<p>yeah that is not great... I would do something like..</p>

<pre><code>typedef struct{ //maybe stick this in a union, depending on what the compiler does to it.
    unsigned char r:2;
    unsigned char g:2;
    unsigned char b:2;
}color;
const int numOfColors = 3;
color colors[numOfColors] = {
    {2,0,0},//r
    {1,1,0},//o
    {0,2,0}//g
};

for(int i = 0 ; 1 ; i++)
{
    color c = colors[i%numOfColors];
    //set color
    //update
    //wait
}
</code></pre>
",,20587308,554
16242814,2,16242435,2013-04-26T18:19:33.027,2,,121747,,2013-04-26T18:25:21.093,2013-04-26T18:25:21.093,3,,"<p>With a simple drawing of the situation you are able to find a formula that applies the intensity directly to the single component according to a global counter that you increment on every tick, the code is the following (I wrote it just now and haven't tested but should be enough for you to understand how it works):</p>

<pre><code>int counter = 0; // counter you should increment on each tick
int phases = 6; // total phases in a cycles
int cycleLength = max_steps * phases; // total ticks in a cycle

int currentStepOfCycle = counter % cycleLength;
int currentPhase = currentStepOfCycle / max_steps;
int currentStepOfPhase = currentStepOfCycle % max_steps;

// this is how much phase shifts are performed for each primary color to have the raising line in phase 0
int phase_shifts[3] = {2, 0, 4}; 

// for each color component
for (int i = 0; i &lt; 3; ++i) {
  // shift the phase so that you have / at phase 0
  int shiftedPhase = (currentPhase+phase_shifts[i])%phases;

  if (shiftedPhase == 1 || shiftedPhase == 2)
    intensity[i] = MAX;
  else if (shiftedPhase == 0)
    intensity[i] = currentStepOfPhase;
  else if (shiftedPhase == 3)
    intensity[i] = MAX - currentStepOfPhase;
  else
    intensity[i] = 0;
}
</code></pre>

<p>The idea follows from this:</p>

<p><img src=""https://i.stack.imgur.com/Q0Zq6.jpg"" alt=""enter image description here""></p>

<p>The shift is needed because by adding an increment to the current phase for a different color component it is possible to consider always phase 0, 1, 2 and 3 to understand is intensity should be raising, dropping or set to max for each component.</p>

<p>This should be adaptable to whatever step of intensity you want to apply easily.</p>
",,20625307,1430
16274498,2,16274451,2013-04-29T08:42:07.043,1,,596781,,2013-04-29T08:42:07.043,,5,,"<p>Just because the platform doesn't predefine <code>operator new()</code> doesn't mean that <em>you</em> can't define it. In your code, presumably someone will have written a definition for the allocation function, so all is well.</p>

<p>(I assume you're familiar with the difference between the <code>new</code> expression and the allocation function, which is confusingly called <code>operator new()</code>.)</p>

<hr>

<p>Here's a baby example definition that should get a short program going:</p>

<pre><code>char buf[1024];
char * cur = buf;

void * operator new(std::size_t n)
{
    char * res = cur;
    std::size_t inc = (n + 15) / 16 * 16;

    if (std::distance(cur, buf + sizeof(buf)) &lt; inc)
        throw std::bad_alloc();

    cur += inc;

    return res;
}

void operator delete(void * p) noexcept
{
}
</code></pre>

<p>This will obviously run out of memory very fast.</p>
",,20636528,78
16274855,2,16274451,2013-04-29T09:04:59.363,14,,2149548,,2013-04-29T09:04:59.363,,0,,"<p><code>new</code> and <code>delete</code> is defined as part of the Arduino distribution:
<code>/usr/share/arduino/hardware/arduino/cores/arduino/new.h</code>:</p>

<pre><code>/* Header to define new/delete operators as they aren't provided by avr-gcc by default
   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=59453 
 */
#ifndef NEW_H
#define NEW_H

#include &lt;stdlib.h&gt;

void * operator new(size_t size);
void operator delete(void * ptr); 

__extension__ typedef int __guard __attribute__((mode (__DI__)));

extern ""C"" int __cxa_guard_acquire(__guard *);
extern ""C"" void __cxa_guard_release (__guard *);
extern ""C"" void __cxa_guard_abort (__guard *); 

extern ""C"" void __cxa_pure_virtual(void);

#endif
</code></pre>

<p>The <code>new.h</code> is included in <code>Printable.h</code> so you are getting it in your Arduino basic includes.  These operators are not defined in AVR Libc though. My interpretation of these design choices: the Libc people thought it was a bad idea, whereas Arduino people are all about ease of use: if you want <code>new</code> and <code>delete</code>, please have them.</p>
",,20721606,2278
16306972,2,16306901,2013-04-30T18:51:18.167,2,,,user529758,2013-04-30T19:17:45.783,2013-04-30T19:17:45.783,3,,"<p>Your logic is correct and this would work if buttons were perfect. But they aren't. You have to <strong>debounce</strong> the signal of the button. Two methods to achieve that (works best when combined):</p>

<p>I. Add a capacitor between the two pins of the button (or try <a href=""http://www.labbookpages.co.uk/electronics/files/debounce/debounceCircuit.png"" rel=""nofollow"">an even more sophisticated button debouncer circuitry</a>), and/or</p>

<p>II. use software debouncing (pseudo-C):</p>

<pre><code>while (1) {
    while (!button_pressed)
        ;

    printf(""Button pressed!\n"");


    while (elapsed_time &lt; offset)
        ;
}
</code></pre>

<p>etc.</p>

<p>Edit: as @jerry pointed out, the above doesn't work ""correctly"" when the button is held. Here are a couple of <a href=""http://hackaday.com/2010/11/09/debounce-code-one-post-to-rule-them-all/"" rel=""nofollow"">more professional code snippets</a> you can use to meet all the requirements.</p>
",,20773758,226
16307572,2,16306901,2013-04-30T19:31:05.370,1,,168986,,2013-05-01T19:08:25.460,2013-05-01T19:08:25.460,1,,"<p>The following function polls the button at nominally 1 millisecond intervals and required that the state remain ""releases"" to 20 consecutive polls.  That will typically be sufficient to <em>debounce</em> most switches while retaining responsiveness.</p>

<p>Replace your <code>while(bcm2835_gpio_lev(PIN)){}</code> loop with a call to <code>waitButtonRelease()</code>.</p>

<pre><code>#include &lt;unistd.h&gt;
#define DEBOUNCE_MILLISEC 20

void waitButtonRelease()
{
    int debounce = 0 ;

    while( debounce &lt; DEBOUNCE_MILLISEC )
    {
        usleep(1000) ;

        if( bcm2835_gpio_lev(PIN) )
        {
            debounce = 0 ;
        }
        else
        {
            debounce++ ; 
        }
    }
}
</code></pre>

<p>You may find it necessary also to debounce button presses as well as releases. That is done in the same way, but counting the opposite state:</p>

<pre><code>void waitButtonPress()
{
    int debounce = 0 ;

    while( debounce &lt; DEBOUNCE_MILLISEC )
    {
        usleep(1000) ;

        if( !bcm2835_gpio_lev(PIN) )
        {
            debounce = 0 ;
        }
        else
        {
            debounce++ ; 
        }
    }
}
</code></pre>

<p>Or perhaps a single function to debounce either state:</p>

<pre><code>#include &lt;stdbool.h&gt;

void waitButton( bool state )
{
    int debounce = 0 ;

    while( debounce &lt; DEBOUNCE_MILLISEC )
    {
        usleep(1000) ;

        if( bcm2835_gpio_lev(PIN) == state )
        {
            debounce++ ;
        }
        else
        {
            debounce = 0 ; 
        }
    }
}
</code></pre>

<p>Given this last function, your main while loop might look like:</p>

<pre><code>    while(1)
    {
        waitButton( true )
        printf(""The button has been pressed\n"");

        waitButton( false ) ;
    }
</code></pre>

<p>If you have access to a digital storage oscilloscope, you might probe the switch signal directly to see exactly what the <em>switch bounce</em> looks like.  It may help you understand the problem and also to tailor the debounce to the characteristics of your particular switch.</p>
",,20779079,178
16307803,2,16306901,2013-04-30T19:44:49.500,1,,1270168,,2013-04-30T19:50:34.663,2013-04-30T19:50:34.663,7,,"<p>For a simple program like this, using busy loops like you've done is fine. However, I'd suggest getting out of the habit because it's often unacceptable in anything more than a toy project.</p>

<p>There are as many ways to debounce a button as there are people writing code. Doing it in hardware may be the way to go in some cases, but it's not without its drawbacks. In any case, since this is a programming site, let's assume you can't (or don't want to) change the hardware.</p>

<p>A quick and dirty modification is to periodically check the button in the main loop and only act if it has changed. Since you're new to C and and embedded programming, I'll avoid timers and interrupts, but know that you can make the code more understandable and maintainable once you learn about them.</p>

<pre><code>#include &lt;bcm2835.h&gt;
#include &lt;stdio.h&gt;
#define PIN RPI_GPIO_P1_11

// A decent value for the number of checks varies with how ""clean"" your button is, how 
// responsive you need the system to be, and how often you call the helper function. That
// last one depends on how fast your CPU is and how much other stuff is going on in your
// loop. Don't pick a value above UINT_MAX (in limits.h)
#define BUTTON_DEBOUNCE_CHECKS 100

int ButtonPress()
{
    static unsigned int buttonState = 0;
    static char buttonPressEnabled = 1;

    if(bcm2835_gpio_lev(PIN))
    {
        if(buttonState &lt; BUTTON_DEBOUNCE_CHECKS)
        {
            buttonState++;
        }
        else if(buttonPressEnabled)
        {
            buttonPressEnabled = 0;
            return 1;
        }
    }
    else if(buttonState &gt; 0 )
    {
        buttonState--;
        // alternatively you can set buttonState to 0 here, but I prefer this way
    }
    else
    {
        buttonPressEnabled = 1;
    }

    return 0;
}

int main()
{
    if(!bcm2835_init())
        return 1;

    bcm2835_gpio_fsel(PIN, BCM2835_GPIO_FSEL_INPT);

    while(1)
    {
        if(ButtonPress())
        {
            printf(""The button has been pressed\n"");
        }

        // the rest of your main loop code
    }

    bcm2835_close();
    return 0;
}
</code></pre>
",,20802752,1523
16343425,2,16343162,2013-05-02T16:44:50.030,1,,649665,,2013-05-02T16:44:50.030,,0,,"<p>The obvious answer is: don't write <code>#include &lt;Helper.h&gt;</code>.  Your
files aren't part of the implementation, and should be included
using <code>#include ""Helper.h""</code>.  If you do this, the first place
the compiler will look for the include file is in the directory
containing the file which is including it: if you include it 
from <code>Foo/Foo.h</code>, the compiler will pick up <code>Foo/Helper.h</code>; if you include
it from <code>Bar/Bar.h</code>, the compiler will pick up <code>Bar/Helper'</code> and
so on.</p>

<p>Client code should only set the include path to the root, and do
things like <code>#include ""Foo/Foo.h""</code>; if necessary, they can also
do <code>#include ""Foo/Helper.h""</code>.</p>

<p>The one thing you do have to do with this strategy is to ensure
the uniqueness of all of the header guards.  If this is an
application, it will usually be sufficient to mangle the path
into the include guard, e.g. use <code>Foo_Helper_h</code>, instead of just
<code>Foo_h</code>.  Alternatively (and I would use this for any library
which third parties should use), generate some random string for
the include guard.  (If I open a file named <code>abc.h</code> which
doesn't exist, my editor automatically generates the following
boilerplate:</p>

<pre><code>/********************************************************/
/*      File:       abc.h                               */
/*      Author:     J. Kanze                            */
/*      Date:       02/05/2013                          */
/* ---------------------------------------------------- */

#ifndef abc_h_20130502O481MBxFZeAzz4dgIb7iC4Q9
#define abc_h_20130502O481MBxFZeAzz4dgIb7iC4Q9

#endif
</code></pre>

<p>It's a safe bet that the include guard here will never conflict
with any other.  (And you have to do something along these lines
anyway, in order to get your copyright message in the file.)</p>
",,20828758,667
16343548,2,16343162,2013-05-02T16:51:22.263,0,,790993,,2013-05-02T16:51:22.263,,0,,"<p>Just figured out a way that seemingly solves the problem:</p>

<pre><code>libraries   
  +Foo
    -Foo.h
    +extra
      -Helper.h   
  +Bar
    -Bar.h
    +extra
      -Helper.h   
  +Helper
    -Helper.h
</code></pre>

<p>In this way, <code>Helper.h</code> in <code>Foo</code> and <code>Bar</code> would be invisible to clients, and I can write <code>#include ""extra/Helper.h""</code> in <code>Foo</code> and <code>Bar</code> respectively to include the desired files.</p>
",,20865973,947
16359086,2,16358804,2013-05-03T12:35:15.260,2,,1593860,,2013-05-03T15:05:29.717,2013-05-03T15:05:29.717,2,,"<p>This is a basic configuration problem that library vendors face constantly. For small projects, just <code>#define</code> <code>USE_BASIC</code>, when appropriate, in the <code>foo.h</code> header. For larger projects with lots of configuration options you might want to go to a configuration file that gets <code>#include</code>d in every library header and define appropriate things there. In that case, I'd do all of the selection in the configuration header:</p>

<pre><code>// uncomment to use `Basic` throughout:
// #define USE_BASIC
#ifdef USE_BASIC
typedef Basic FooBase;
#else
typedef Advanced FooBase;
#endif
</code></pre>
",,20868853,1468
16359087,2,16358804,2013-05-03T12:35:16.443,1,,1318110,,2013-05-03T12:42:43.283,2013-05-03T12:42:43.283,0,,"<p>Some people suggested the pattern strategy. 
If your choice is during compile-time, you should better use Policy-based design: 
<a href=""http://en.wikipedia.org/wiki/Policy-based_design"" rel=""nofollow"">http://en.wikipedia.org/wiki/Policy-based_design</a></p>

<p>This is roughly the same design as yours, but you use templates:</p>

<pre><code>template &lt;class Base&gt; class YourClass : public base {
    ...
};
</code></pre>

<p>At use:</p>

<pre><code>#ifdef BASIC
typedef YourFinalClass Yourclass&lt;Basic&gt;;
#else
typedef YourFinalClass Yourclass&lt;Advanced&gt;;
#endif
</code></pre>
",,20891146,717
16359147,2,16358804,2013-05-03T12:38:26.247,23,,415784,,2013-05-03T12:44:53.670,2013-05-03T12:44:53.670,5,,"<p>A much more clean solution would be using template : let the compiler choose the base class depending on a template argument. </p>

<p>Here is one example:</p>

<pre><code> #include &lt;type_traits&gt; //for std::conditional


 //here you go with your own class
 template&lt;bool UseAdvanced&gt;
 class Foo : public std::conditional&lt;UseAdvanced, Advanced, Basic&gt;::type
 {
      //your code
 };
</code></pre>

<p>And here is how you would be using this class:</p>

<pre><code>Foo&lt;true&gt;   fooWithAdvanced; //it uses Advanced as base class
Foo&lt;false&gt;  fooWithBasic;    //it uses Basic as base class!
</code></pre>

<p>Well that is one way to do that. But there are better ways. In particular, I would design the class template in the following way, in which the template argument would act as <em>base</em> class. This would be more flexible design.</p>

<pre><code> template&lt;typename Base&gt;
 class Foo : public Base
 {
      //your code
 };
</code></pre>

<p>So you can use <code>Basic</code>, <code>Advanced</code> or <em>any other class as base class</em>, as long as it supports the functionalities as required by <code>Foo</code> and its usage:</p>

<pre><code> Foo&lt;Advanced&gt;  fooWithAdvanced;
 Foo&lt;Basic&gt;     fooWithBasic;
 Foo&lt;OtherBase&gt; fooWithOtherBase;
</code></pre>

<p>Hope that helps.</p>
",,20934357,1227
16363688,2,16362007,2013-05-03T16:34:07.580,1,,2278186,,2013-05-04T14:49:15.207,2013-05-04T14:49:15.207,4,,"<ol>
<li>When using the semi-colon syntax, the size of the struct will be the sum of all its fields.</li>
<li><p>I think its possible using this syntax: (<a href=""http://www.arduino.cc/en/Reference/PROGMEM"" rel=""nofollow"">http://www.arduino.cc/en/Reference/PROGMEM</a>)</p>

<blockquote>
<pre><code>LED leds PROGMEM;
</code></pre>
</blockquote></li>
<li><p>Yes they are, the syntax is as you wrote in your question.</p></li>
<li><p>Yes you may:</p>

<blockquote>
  <p>typedef struct {
     struct otherStruct; };</p>
</blockquote></li>
<li><p>Yes you can do that using masks. For example:</p>

<blockquote>
<pre><code>for (int i = 0, byte cur = s1 &amp; 1; ; i &lt; numOfFieldsInStruct; i++, cur = (s1&lt;&lt;i)&amp;1) {
    ....
}
</code></pre>
</blockquote></li>
</ol>

<p>Regarding your last comment to this answer, let me propose the following solution:</p>

<p>Organize the leds in a way that addressing them won't take up memory (like in the question - the LED struct takes memory for addressing). Instead, you can address the leds using their position in an array and in the struct like this:</p>

<pre><code>typedef struct {
    byte LED1 : 1;
    byte LED2 : 1;
    byte LED3 : 1;
    byte LED4 : 1;
    byte LED5 : 1;
    byte LED6 : 1;
    byte LED7 : 1;
    byte LED8 : 1;
} LED_ROW;

LED_ROW leds[256];

leds[0].LED1 = 1; // turn led at row 0, col 0 to 1
leds[0].LED5 = 1; // turn led at row 4, col 0 to 1
led[100].LED3 = 1; // turn led at row 2, col 100 to 1
...
// and so on
</code></pre>

<p>You may consider arranging the array differently, with 256 items in the struct and 8 items in the array so the rows will be refered to by [] and the cols after the dot, like so:</p>

<pre><code>leds[0].LED3 = 1; // turn on led at row 0, col 2 to 1
</code></pre>
",,21030349,186
16363788,2,16363042,2013-05-03T16:39:53.820,0,,2228302,,2013-05-03T16:39:53.820,,0,,"<p>The messy part is the LedBar function... I would suggest to write it like this:</p>

<pre><code>void LedBar()
{
  if(on == 1)
  {
    if (potValue &lt; M2) {
      //digitalWrite all leds 0;
    }
    else if (potValue &gt; M2 &amp;&amp; potValue &lt; M3) {
      //digitalWrite first led 1;
      //digitalWrite all the others 0;
    }
    else if (potValue &gt; M3 &amp;&amp; potValue &lt; M4) {
      //digitalWrite first and second led 1;
      //digitalWrite all others 0;
    }
    //and so on...
  }


  else
   {
    digitalWrite(2, LOW);
    digitalWrite(3, LOW);
    digitalWrite(4, LOW);
    digitalWrite(5, LOW);
    digitalWrite(6, LOW);
    digitalWrite(7, LOW);
    digitalWrite(8, LOW);
    digitalWrite(9, LOW);
    digitalWrite(10, LOW);
    }
  }
</code></pre>
",,21033366,81
16378017,2,16363042,2013-05-04T19:16:12.793,2,,596985,,2013-05-04T19:16:12.793,,0,,"<p>Short answer: learn how to use loops (for and while) and arrays.</p>

<p>A longer one:</p>

<p>define M like this:</p>

<pre><code>int M[] = {40,75,...,250};
</code></pre>

<p>(replace ... with rest of the values)</p>

<p>and change the LedBar function to:</p>

<pre><code>void LedBar()
{
    int potValue = analogRead(potPin) /4;
    if(on == 1)
        for (int i=0;i&lt;=8;i++)
            if (potValue &gt; M[i])
               digitalWrite(i+2, HIGH);
    else
        for (int i=0;i&lt;=8;i++)
            digitalWrite(M[i+2], LOW);
}
</code></pre>

<p>also, in setup, instead of <code>pinMode (L.., OUTPUT);</code> lines you can write:</p>

<pre><code>for (int i=2;i&lt;=10;i++)
    pinMode (i, OUTPUT);
</code></pre>
",,21042881,343
16488793,2,16488735,2013-05-10T18:39:34.557,0,,1335035,,2013-05-10T18:39:34.557,,5,,"<p>Shouldn't be too hard.  I love working with char arrays, because really, it isn't difficult at all.  To concat two char arrays though, you'll have to know their sizes, and you'll have to make a 3rd buffer that is the size of the first char array + second char array.  The only problem with this is finding the size.  This can be done with a simple struct:</p>

<pre><code> typedef struct String{
    int size;
    char * chararray;

 }String;
</code></pre>

<p>Then you'll have to malloc the chararray with the size and populate the integer value.  </p>

<p>The rest is pretty simple after that. </p>
",,21049912,1211
16524882,2,16511340,2013-05-13T14:46:06.910,1,,1899801,,2013-05-13T14:46:06.910,,0,,"<p>I recommend you look at my example <a href=""https://github.com/mpflaga/Sparkfun-MP3-Player-Shield-Arduino-Library/blob/master/SFEMP3Shield/Examples/FilePlayer/FilePlayer.ino"" rel=""nofollow"">MP3 File Player</a> and the <a href=""https://github.com/mpflaga/Sparkfun-MP3-Player-Shield-Arduino-Library/blob/master/SFEMP3Shield/Examples/WebPlayer/WebPlayer.ino"" rel=""nofollow"">Web Player</a>.</p>

<p>There are TWO issues: </p>

<p>1) You need to approach this from the point of view appreciating the Arduino does not have enough resources (SRAM) to hold a list of entire SdFAT's directories. Hence my approach was to use the users console for retaining the list. It dumps the directories contents to the console, along with a corresponding number. From which the user could select the number they wish to enter. Similarly the <a href=""https://github.com/mpflaga/Sparkfun-MP3-Player-Shield-Arduino-Library/blob/master/SFEMP3Shield/Examples/WebPlayer/WebPlayer.ino"" rel=""nofollow"">Web Player</a> does the same thing, but when generating the HTML, it generates a link pointing to the corresponding listed item. Hence the list is stored on the console being either the Browser or Serial Monitor.</p>

<p>2) The default provided SD library is not sufficient to do what you want. Recently Arduino incorporated <a href=""http://code.google.com/p/sdfatlib/"" rel=""nofollow"">Bill Greiman’s SdFatLib</a> as the under the hood class. But limited it. Where using Bill’s native SdFat library allows you the use of additional methods to access individual objects, such as <code>getFilename()</code>, not available in SD. This is necessary when going through the directory. The <code>sd.ls(LS_DATE | LS_SIZE)</code> will only dump directly to serial. Where you need to use access the individual files themselves. As show below or <a href=""https://github.com/mpflaga/Sparkfun-MP3-Player-Shield-Arduino-Library/blob/master/SFEMP3Shield/Examples/FilePlayer/FilePlayer.ino#L380"" rel=""nofollow"">in actual code </a></p>

<pre><code>SdFile file;
char filename[13];
sd.chdir(""/"",true);
uint16_t count = 1;
while (file.openNext(sd.vwd(),O_READ))
{
  file.getFilename(filename);
  Serial.print(count);
  Serial.print(F("": ""));
  Serial.println(filename);
  count++;
}
file.close();
</code></pre>

<p>Additionally there are buried public methods accessible by references as show in <a href=""https://github.com/mpflaga/Sparkfun-MP3-Player-Shield-Arduino-Library/blob/master/SFEMP3Shield/Examples/WebPlayer/WebPlayer.ino#L110"" rel=""nofollow"">WebPlayer’s ListFiles()</a> function, to get more discrete handling of the files.</p>
",,21055234,965
16533002,2,16532586,2013-05-13T23:55:36.803,0,,2070391,,2013-05-13T23:55:36.803,,0,,"<p>Perhaps something like the '<strong>blink without delay</strong>' example in the <strong>IDE</strong>. You check the time and decide to when and how to change the LED/Digital out. </p>

<pre><code>// Variables will change:
int ledState = LOW;             // ledState used to set the LED
long previousMillis = 0;        // will store last time LED was updated

// the follow variables is a long because the time, measured in miliseconds,
// will quickly become a bigger number than can be stored in an int.
long interval = 1000;           // interval at which to blink (milliseconds)

void setup(){
    // Your stuff here
}


void loop()
{
 // Your stuff here.

 // check to see if it's time to blink the LED; that is, if the 
 // difference between the current time and last time you blinked 
 // the LED is bigger than the interval at which you want to 
 // blink the LED.
 unsigned long currentMillis = millis();

if(currentMillis - previousMillis &gt; interval) {
  // save the last time you blinked the LED 
  previousMillis = currentMillis;   

  // if the LED is off turn it on and vice-versa:
  if (ledState == LOW)
    ledState = HIGH;
  else
    ledState = LOW;

  // set the LED with the ledState of the variable:
  digitalWrite(ledPin, ledState);
}
}
</code></pre>
",,21070078,692
16534034,2,16532586,2013-05-14T02:07:03.733,0,,840992,,2013-05-14T02:07:03.733,,1,,"<p>A state machine (at it's simplest - it can be lots more complicated) can be just a set of conditional statements (if/else or switch/case) where you do certain behaviors based on the state of a variable, and also change that variable state. So it can be thought of as a way of handling or progressing through a series of conditions.</p>

<p>So you have the state of your LED/valve - it is either blinking (open) or not blinking (closed). In pseudo code here:</p>

<pre><code>boolean LED_state = false;  //init to false/closed

void loop(){

 if (checkForCorrectCommand() == true){ //

   if (LED_State == false){
     open_valve();
     LED_State = true;

   } else {
     close_valve();
     LED_State = false;
   }
 }
}
</code></pre>

<p>The blinking LED part should be easy to implement if you get the gist of the code above. The <code>checkForCorrectCommand()</code> bit is a function you write for checking whatever your input is - key, serial, button, etc. It should return a boolean.</p>
",,21071489,1753
16537096,2,16532586,2013-05-14T07:09:02.950,1,,1541012,,2013-05-14T07:09:02.950,,0,,"<p>To blink a Led without blocking the program, i suggest you use Timer (and the <a href=""http://playground.arduino.cc/code/timer1"" rel=""nofollow"">TimerOne library</a>). I make a quick sample code :  </p>

<pre><code>#include ""TimerOne.h"" //Include the librart, follow the previous link to download and install.

int LED = 4;
const int RELAY_A = A0;  
boolean ledOn;

void setup()
{
    pinMode(LED, OUTPUT)
    Timer1.initialise(500000) // Initialise timer1 with a 1/2 second (500000µs) period
    ledOn = false;
}

void blinkCallback() // Callback function call every 1/2 second when attached to the timer
{
    if(ledOn){
        digitalWrite(LED,LOW);
        ledOn = false;
    }
    else{
        digitalWrite(LED,HIGH);     
        ledOn = true;
    }
}

void open_valve() {

  digitalWrite(RELAY_A, HIGH); // turn RELAY_A on

}

void close_valve() {

  digitalWrite(RELAY_A, LOW); // turn RELAY_A off
}

void serialEvent() {
  while(Serial.available()) {
    char inChar = (char)Serial.read();
    inputString += inChar;
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
}

void loop()
{
    // print the string when newline arrives:
  if (stringComplete) {
    Serial.println(inputString);
    // clear the string:
    inputString = """";
    stringComplete = false;
  }


  if (inputString == ""{blink_Flow_A}"") {
    Timer1.attachInterupt(blinkCallback); //Start blinking
  }
  if (inputString == ""{stop}"") {
    Timer1.detachInterrupt(); //Stop blinking
  }
  if (inputString == ""{open_valve}"") {
    open_valve();
  }
  if (inputString == ""{close_valve}"") {
    close_valve();
  }
}  
</code></pre>

<p><em>Note :</em><br>
Consider putting the tag 'c' or 'java' to have syntax highlighting on the code.</p>
",,21105965,346
19893013,2,16532586,2013-11-10T17:53:58.743,0,,2907920,,2013-11-10T17:53:58.743,,0,,"<p>Let me offer a suggested sketch with a few changes. Bastyen's idea of using a timer is quite good and makes the code much easier. The approach I would suggest is to have the timer pop forever at a fixed interval (100 milliseconds in my sketch). If the LED should not be blinking it stays off. If the LED should be blinking, it switches from off to on or vice versa each time the timer goes off.</p>

<pre><code>#include ""TimerOne.h""
/*
 * kegboard-serial-simple-blink07
 * This code is public domain
 *
 * This sketch sends a receives a multibyte String from the iPhone
 * and performs functions on it.
 *
 * Examples:
 * http://arduino.cc/en/Tutorial/SerialEvent
 * http://arduino.cc/en/Serial/read
 */

 // global variables should be identified with _

 // flow_A LED
 int led = 4;
 // relay_A
 const int RELAY_A = A0;

 // variables from sketch example
 String  inputString = """"; // a string to hold incoming data
 boolean stringComplete = false; // whether the string is complete

 boolean shouldBeBlinking = false;
 boolean ledOn = false;

void setup() {
   Serial.begin(9600); // open serial port, sets data rate to 2400bps
   Serial.println(""Power on test"");
   inputString.reserve(200);
   pinMode(RELAY_A, OUTPUT);
   pinMode(led, OUTPUT);
   digitalWrite(led, LOW);
   Timer1.initialize(100000);
   Timer1.attachInterrupt(timer1Callback);
}

void loop() {  
  if (!stringComplete)
    return;
  if (inputString == ""{blink_Flow_A}"") 
    flow_A_blink_start();    
  if (inputString == ""{blink_Flow_B}"") 
    flow_A_blink_stop();
  inputString = """";
  stringComplete = false;
}

void timer1Callback() {
  /* If we are not in blinking mode, just make sure the LED is off */  
  if (!shouldBeBlinking) {
    digitalWrite(led, LOW);
    ledOn = false;
    return;
  }
  /* Since we are in blinking mode, check the state of the LED. Turn
     it off if it is on and vice versa. */
  ledOn = (ledOn) ? false : true; 
  digitalWrite(led, ledOn);
}  

void flow_A_blink_start() {
  shouldBeBlinking = true;
  open_valve();
}

void flow_A_blink_stop() {
  shouldBeBlinking = false;
  close_valve();  
}

void close_valve() {
  digitalWrite(RELAY_A, LOW); // turn RELAY_A off
}

void open_valve() {
  digitalWrite(RELAY_A, HIGH); // turn RELAY_A on
}


//SerialEvent occurs whenever a new data comes in the
//hardware serial RX.  This routine is run between each
//time loop() runs, so using delay inside loop can delay
//response.  Multiple bytes of data may be available.

void serialEvent() {
  if (stringComplete)
    return;  
  while(Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString unless it is a newline
    if (inChar != '\n')
      inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    else {
      stringComplete = true;
    }
  }
}
</code></pre>

<p>A few notes:</p>

<ol>
<li><p>The setup function establishes the timer with a 100 millisecond interval and attaches the callback routine. Based on my testing, this only needs to be done once.</p></li>
<li><p>The main loop just ignores everything unless an input string is complete. If an input string is ready, then the input string is checked for two known values and the appropriate steps are taken. The input string is then discarded.</p></li>
<li><p>The timer callback routine forces the LED off, if we are not in blinking mode. Otherwise, it just toggles the state of the LED.</p></li>
<li><p>The flow on and flow off routines set the blinking state as need be and control the valve</p></li>
<li><p>The serial event routine has two changes. First, input is ignored (and kept in the buffer) if an input string is already complete. This will preserve commands that are being sent to the Arduino while the current command is being processed. Second, the newline character is not added to the input string. This makes checking the input string slightly easier.</p></li>
</ol>
",,21108444,170
16568582,2,16561418,2013-05-15T15:02:50.483,1,,261122,,2013-05-15T15:02:50.483,,0,,"<p>Well, for one thing, you're overflowing your string buffers.</p>

<p>You've assigned 15 bytes for <code>cc</code></p>

<pre><code>char cc[15];
</code></pre>

<p>But you have code:</p>

<pre><code>strncat(cc,o,20);  
strncat(cc,""|"",20);
strncat(cc,m,20);  
strncat(cc,""|"",20);
strncat(cc,n,20);
</code></pre>

<p>That could put up to 62 bytes in there. The same is true for most of your other buffers.</p>

<p>In addition, you're using multiple 3rd party libraries. Any one of those could contain a memory leak.</p>
",,21116241,2779
16624531,2,16624399,2013-05-18T12:58:32.607,0,,502837,,2013-05-19T08:34:51.420,2013-05-19T08:34:51.420,11,,"<p>Your problem is because you are defining an array of chars, not an array of <em>arrays</em> of chars (i.e. strings).</p>

<p><strong>However:</strong></p>

<p>Don't use <code>char*</code>. Use <code>String</code>. It is much easier to manipulate, and you don't have to worry about pointers/raw values.</p>

<p>E.g.:</p>

<pre><code>String myStrings[3] = {""a"", ""b"", ""c""};

for (int i = 0; i &lt; 3; i++) {
    Serial.print(myStrings[i]);
}
</code></pre>

<p>Output:</p>

<pre><code>abc
</code></pre>
",,21117744,1452
18725479,2,16633154,2013-09-10T17:38:08.403,10,,1677912,,2015-10-26T16:01:41.980,2015-10-26T16:01:41.980,0,,"<p>Is it a requirement that a google form be in the middle of this? If it is enough to be able to post your data to a spreadsheet, here's a Google-Apps-Script for one side of the problem: a simple web service that will accept form data as a query string, and write that to your spreadsheet.</p>

<p>This examples assumes a very simple spreadsheet, with three columns, ""Timestamp"", ""col1"" and ""col2"". Edit the code to suit your situation.</p>

<p><s>You can see the spreadsheet <a href=""https://docs.google.com/spreadsheet/ccc?key=asdf&amp;usp=sharing"" rel=""nofollow"">here</a>, and even <a href=""https://script.google.com/macros/s/asdf/exec?col1=Testing&amp;col2=%27StackOverflow%27"" rel=""nofollow"">make a test post</a>.</s></p>

<pre><code>/**
 * doGet() function to add data to a spreadsheet.
 *
 * Spreadsheet data is provided as a querystring, e.g. ?col1=1&amp;col2='pizza'
 *
 * From: http://stackoverflow.com/a/18725479/1677912
 *
 * @param {event} e Event passed to doGet, with querystring
 * @returns {String/html} Html to be served
 *
 * Test URLs (adjust ID as needed):
 *   https://script.google.com/macros/s/--DEV-SCRIPT-ID--/dev?col1=1&amp;col2='pizza'
 *   https://script.google.com/macros/s/--PUB-SCRIPT-ID--/exec?col1=1&amp;col2='pizza'
 */
function doGet(e) {  
  Logger.log( JSON.stringify(e) );  // view parameters

  var result = 'Ok'; // assume success

  if (e.parameter == undefined) {
    result = 'No Parameters';
  }
  else {
    var id = '--SHEET-ID---'; // Spreadsheet id for responses
    var sheet = SpreadsheetApp.openById(id).getActiveSheet();
    var newRow = sheet.getLastRow() + 1;
    var rowData = [];
    rowData[0] = new Date(); // Timestamp
    for (var param in e.parameter) {
      Logger.log('In for loop, param='+param);
      var value = stripQuotes(e.parameter[param]);
      //Logger.log(param + ':' + e.parameter[param]);
      switch (param) {
        case 'col1': 
          rowData[1] = value;
          break;
        case 'col2':
          rowData[2] = value;
          break;
        default:
          result = ""unsupported parameter"";
      }
    }
    Logger.log(JSON.stringify(rowData));

    // Write new row to spreadsheet
    var newRange = sheet.getRange(newRow, 1, 1, rowData.length);
    newRange.setValues([rowData]);
  }

  // Return result of operation
  return ContentService.createTextOutput(result);
}

/**
 * Remove leading and trailing single or double quotes
 */
function stripQuotes( value ) {
  return value.replace(/^[""']|['""]$/g, """");
}
</code></pre>
",,21147838,2223
16725027,2,16724214,2013-05-23T22:38:01.530,2,,307293,,2013-05-23T22:38:01.530,,6,,"<p>I take zero credit for this code as I pulled it from a thread on the Arduino forums (<a href=""http://forum.arduino.cc/index.php?topic=112733.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=112733.0</a>).  It writes a .bmp file to an SD card.  </p>

<p>Another discussion indicated that because of the compression algorithms associated with JPG and PNG files, the amount of code to make those work would be more difficult to fit on an Arduino, which makes sense in my head (<a href=""http://forum.arduino.cc/index.php?topic=76376.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=76376.0</a>).  </p>

<p>Hope this helps.  Definitely not an expert with Arduino - just tinkered a bit.</p>

<pre><code>#include &lt;SdFat.h&gt;
#include &lt;SdFatUtil.h&gt;

/*
 WRITE BMP TO SD CARD
 Jeff Thompson
 Summer 2012

 TO USE MEGA:
 The SdFat library must be edited slightly to use a Mega - in line 87
 of SdFatConfig.h, change to:

   #define MEGA_SOFT_SPI 1

 (this uses pins 10-13 for writing to the card)

 Writes pixel data to an SD card, saved as a BMP file.  Lots of code
 via the following...

 BMP header and pixel format:
   http://stackoverflow.com/a/2654860

 SD save:
   http://arduino.cc/forum/index.php?topic=112733 (lots of thanks!)
 ... and the SdFat example files too

 www.jeffreythompson.org
 */

char name[] = ""9px_0000.bmp"";       // filename convention (will auto-increment)
const int w = 16;                   // image width in pixels
const int h = 9;                    // "" height
const boolean debugPrint = true;    // print details of process over serial?

const int imgSize = w*h;
int px[w*h];                        // actual pixel data (grayscale - added programatically below)

SdFat sd;
SdFile file;
const uint8_t cardPin = 8;          // pin that the SD is connected to (d8 for SparkFun MicroSD shield)

void setup() {

  // iteratively create pixel data
  int increment = 256/(w*h);        // divide color range (0-255) by total # of px
  for (int i=0; i&lt;imgSize; i++) {
    px[i] = i * increment;          // creates a gradient across pixels for testing
  }

  // SD setup
  Serial.begin(9600);
  if (!sd.init(SPI_FULL_SPEED, cardPin)) {
    sd.initErrorHalt();
    Serial.println(""---"");
  }

  // if name exists, create new filename
  for (int i=0; i&lt;10000; i++) {
    name[4] = (i/1000)%10 + '0';    // thousands place
    name[5] = (i/100)%10 + '0';     // hundreds
    name[6] = (i/10)%10 + '0';      // tens
    name[7] = i%10 + '0';           // ones
    if (file.open(name, O_CREAT | O_EXCL | O_WRITE)) {
      break;
    }
  }

  // set fileSize (used in bmp header)
  int rowSize = 4 * ((3*w + 3)/4);      // how many bytes in the row (used to create padding)
  int fileSize = 54 + h*rowSize;        // headers (54 bytes) + pixel data

  // create image data; heavily modified version via:
  // http://stackoverflow.com/a/2654860
  unsigned char *img = NULL;            // image data
  if (img) {                            // if there's already data in the array, clear it
    free(img);
  }
  img = (unsigned char *)malloc(3*imgSize);

  for (int y=0; y&lt;h; y++) {
    for (int x=0; x&lt;w; x++) {
      int colorVal = px[y*w + x];                        // classic formula for px listed in line
      img[(y*w + x)*3+0] = (unsigned char)(colorVal);    // R
      img[(y*w + x)*3+1] = (unsigned char)(colorVal);    // G
      img[(y*w + x)*3+2] = (unsigned char)(colorVal);    // B
      // padding (the 4th byte) will be added later as needed...
    }
  }

  // print px and img data for debugging
  if (debugPrint) {
    Serial.print(""\nWriting \"""");
    Serial.print(name);
    Serial.print(""\"" to file...\n"");
    for (int i=0; i&lt;imgSize; i++) {
      Serial.print(px[i]);
      Serial.print(""  "");
    }
  }

  // create padding (based on the number of pixels in a row
  unsigned char bmpPad[rowSize - 3*w];
  for (int i=0; i&lt;sizeof(bmpPad); i++) {         // fill with 0s
    bmpPad[i] = 0;
  }

  // create file headers (also taken from StackOverflow example)
  unsigned char bmpFileHeader[14] = {            // file header (always starts with BM!)
    'B','M', 0,0,0,0, 0,0, 0,0, 54,0,0,0   };
  unsigned char bmpInfoHeader[40] = {            // info about the file (size, etc)
    40,0,0,0, 0,0,0,0, 0,0,0,0, 1,0, 24,0   };

  bmpFileHeader[ 2] = (unsigned char)(fileSize      );
  bmpFileHeader[ 3] = (unsigned char)(fileSize &gt;&gt;  8);
  bmpFileHeader[ 4] = (unsigned char)(fileSize &gt;&gt; 16);
  bmpFileHeader[ 5] = (unsigned char)(fileSize &gt;&gt; 24);

  bmpInfoHeader[ 4] = (unsigned char)(       w      );
  bmpInfoHeader[ 5] = (unsigned char)(       w &gt;&gt;  8);
  bmpInfoHeader[ 6] = (unsigned char)(       w &gt;&gt; 16);
  bmpInfoHeader[ 7] = (unsigned char)(       w &gt;&gt; 24);
  bmpInfoHeader[ 8] = (unsigned char)(       h      );
  bmpInfoHeader[ 9] = (unsigned char)(       h &gt;&gt;  8);
  bmpInfoHeader[10] = (unsigned char)(       h &gt;&gt; 16);
  bmpInfoHeader[11] = (unsigned char)(       h &gt;&gt; 24);

  // write the file (thanks forum!)
  file.write(bmpFileHeader, sizeof(bmpFileHeader));    // write file header
  file.write(bmpInfoHeader, sizeof(bmpInfoHeader));    // "" info header

  for (int i=0; i&lt;h; i++) {                            // iterate image array
    file.write(img+(w*(h-i-1)*3), 3*w);                // write px data
    file.write(bmpPad, (4-(w*3)%4)%4);                 // and padding as needed
  }
  file.close();                                        // close file when done writing

  if (debugPrint) {
    Serial.print(""\n\n---\n"");
  }
}

void loop() { }
</code></pre>
",,21155255,756
16740685,2,16740087,2013-05-24T17:38:36.510,3,,477878,,2013-05-24T17:49:29.973,2017-05-23T11:50:58.750,3,,"<p>When linking to functions from a <code>.c</code> file in a C++ project (which seems to be what you have), <a href=""https://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c"">you need to declare the function as <code>extern ""C""</code>.</a></p>

<p>Try changing the header files';</p>

<pre><code>SUBSYS_OPENSTAT LED_open( void );
</code></pre>

<p>to </p>

<pre><code>extern ""C"" {
    SUBSYS_OPENSTAT LED_open( void );
}
</code></pre>

<p>EDIT: Seems more than one file is confused about C++, try putting all your <code>C</code> includes inside <code>extern ""C""</code> in your cpp file instead;</p>

<pre><code>extern ""C"" {
  #include ""Arduino.h""
}

void setup();
void loop();

void setup()
{
     LED_open();
}

void loop()
{

}
</code></pre>
",,21161118,1457
16781286,2,16780376,2013-05-27T22:24:21.617,3,,1899801,,2013-11-21T19:58:02.083,2013-11-21T19:58:02.083,0,,"<p>You can share the SPI as you like, between the two chip selects, each with its own mode. I do this. Simply write a help function to be used in place of the digitalwrite for each chip select that specifies the complete configuration of the SPI.</p>

<pre><code>void cs1_low() {
    SPI.setDataMode(SPI_MODE0);
    SPI.setClockDivider(spiRate);
    digitalWrite(MP3_XCS, LOW);
}

void cs2_low() {
    SPI.setDataMode(SPI_MODE1);
    SPI.setClockDivider(spiRate/2)
    digitalWrite(MP3_XCS, LOW);
}
</code></pre>

<p>...</p>

<pre><code>cs1_low();
foo = SPI.transfer(bar);
cs1_high(); //Deselect Control

...blah blah...

cs2_low();
foo = SPI.transfer(bar);
cs2_high(); //Deselect Control
</code></pre>

<p>In some cases, it you may need to account for settling. I use this between <a href=""http://en.wikipedia.org/wiki/Secure_Digital"" rel=""nofollow"">SD cards</a> and other chips that are not the same.</p>

<p>It is best practice to not assume the SPI is in the mode you want, as different library or interrupt may have changed it. I have seen plenty of times where the mode is the same, but the speed between the SD card and others are different. Leading to ""well it started, but I get junk later"".</p>
",,21161855,423
16804761,2,16785854,2013-05-29T02:59:39.973,0,,2427327,,2013-05-29T02:59:39.973,,0,,"<p>Ohh, I've got the answer by myself..
I'm just forget to add the SPI. At the setup, just add SPI.begin() and now my LCD and RFID can work together.</p>

<p>Here's the setup :</p>

<pre><code>void setup()
{
     Serial.begin(9600);
     SPI.begin();
     rfid.init();
     analogWrite(10, 50); // set brightness on pin 10 to 0-255
     lcd.begin(16, 2);              // start the library
}
</code></pre>
",,21188389,210
16801897,2,16800908,2013-05-28T21:36:26.190,2,,134633,,2013-05-29T01:33:09.697,2013-05-29T01:33:09.697,7,,"<p>Just listening on the port isn't enough - you need to join the multicast group if you want to see datagrams sent to that group.</p>

<p>The ""Invalid Argument"" error from your <code>setsockopt()</code> call probably means that your <code>mreq</code> argument was bad.  For the multicast address you've given, you should be doing:</p>

<pre><code>struct ip_mreqn mreq;

inet_aton(""225.0.0.37"", &amp;mreq.imr_multiaddr);
mreq.imr_address.s_addr = htonl(INADDR_ANY);
mreq.imr_ifindex = 0;
</code></pre>
",,21238223,12575
16890513,2,16852695,2013-06-03T05:31:02.710,0,,2446653,,2013-06-03T05:31:02.710,,0,,"<p>That's the hard way, and makes the code hard to read. Use the map statement. Here's an example from the Arduino reference:</p>

<p>Example</p>

<pre><code>/* Map an analog value to 8 bits (0 to 255) */
void setup() {}

void loop()
{
  int val = analogRead(0);
  val = map(val, 0, 1023, 0, 255);
  analogWrite(9, val);
}
</code></pre>
",,21277499,3867
16885447,2,16885398,2013-06-02T17:36:32.667,5,,212795,,2013-06-02T18:13:37.683,2013-06-02T18:13:37.683,2,,"<p>You will have to use a cascade of if's (also/especially if your value is a floating point number)</p>

<pre><code>int value= ...; 

if (value&gt;=0 &amp;&amp; value&lt;=250 {
    // some code 0..250
}
else 
if (value&gt;250 &amp;&amp; value&lt;=500) {
    // some code 251..500
}
else 
if (value&gt;500 &amp;&amp; value&lt;=1000) {
    // etc.
}
else {
    // all other values (less than zero or 1001...)
} 
</code></pre>
",,21294613,1548
17153799,2,16885398,2013-06-17T17:59:15.333,4,,1972627,,2015-08-08T02:37:40.297,2015-08-08T02:37:40.297,0,,"<pre><code>switch(val)
{
    case 0 ... 250:
        inRange(val);
        break;

    default:
        outOfRange();
        break;
}
</code></pre>

<p>While the code in the previous answer is valid, I would just stick with the switch statement as it is very applicable for the problem to solve.</p>

<p>Please note that using ranges ('...') is not conforming with the <a href=""http://en.wikipedia.org/wiki/ANSI_C"" rel=""nofollow"">ANSI C</a> standard, but it works fine in the Arduino environment.</p>
",,21309919,1837
16917815,2,16909175,2013-06-04T12:26:31.153,0,,2381671,,2013-06-04T12:39:33.380,2013-06-04T12:39:33.380,1,,"<p>Tout is ""Thermostat output. Active when temperature exceeds TH; will reset when 
temperature falls below TL.""</p>

<p>So you must set TL and TH. The control byte must be sent for the value is send</p>

<p>[A1h] [value for TH]
[A2h] [value for TL]</p>

<p>Luckily for us 25 degrees is a value they gave as 0x19 or 00011001
so my code would look like this</p>

<pre><code> Wire.begin();
 Wire.beginTransmission(DEV_ID);           //I am talking to you
 Wire.send(0xA1);                          //I want to change TH
 Wire.send(0x19);                          //Value of 25
 Wire.endTransmission();

 Wire.beginTransmission(DEV_ID);           //I am talking to you
 wire.send(0xA2);                          //I want to change TL
 Wire.send(0x19);                          //value of 25                      
 Wire.endTransmission();
</code></pre>

<p>You have add/keep the rest of you code, but see if that does the trick.</p>

<p>Here is the data sheet <a href=""http://pdfserv.maximintegrated.com/en/ds/DS1621.pdf"" rel=""nofollow"">http://pdfserv.maximintegrated.com/en/ds/DS1621.pdf</a></p>
",,21345350,8451
16917978,2,16917052,2013-06-04T12:33:23.167,-1,,960650,,2013-06-05T06:52:19.753,2013-06-05T06:52:19.753,2,,"<p>I found my error:</p>

<pre><code>    // Allocate the command
    char * fullCommand = (char *) malloc(len * sizeof(char));

    // Build the command
    strcat(fullCommand, commandPre);
</code></pre>

<p>There is no guarantee that fullCommand is empty after a malloc. strcat places the second argument's first character in the place of the first arguments terminator. However, the terminator might or might not appear on the first location of the allocated array since the data in the memory after a malloc is random. Fixed it by doing:</p>

<pre><code>// Allocate the command
char * fullCommand = calloc(len, sizeof(char));
</code></pre>

<p>Alternatively, I could have done:</p>

<pre><code>// Allocate the command
char * fullCommand = malloc(len * sizeof(char));
fullCommand[0] = '\0';
</code></pre>

<p>Or als Alk pointed out in the comments, start with a strcpy:</p>

<pre><code>// Allocate the command
char * fullCommand = malloc(len * sizeof(char));

// Build the command
strcpy(fullCommand, commandPre);
</code></pre>
",,21353019,66
16978220,2,16977985,2013-06-07T07:07:25.917,1,,1071623,,2013-06-07T11:53:39.773,2013-06-07T11:53:39.773,8,,"<p>You're just reading blocks of 300 characters, so there is no string termination <code>\0</code>.</p>

<p>You'll have to look at <code>n</code> to see how much data you have read and then process the data before printing it i.e. look for the <code>^J^M</code> and terminate the line,then continue reading the rest of the data.  </p>

<p>FYI <code>^J^M</code> is Windows line termination (it's just <code>^J</code> form linux)</p>

<p>The following should read multiple messages and convert ^ and J to \n and ignore ^M.</p>

<p>Note this uses STDIN, not a serial port.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char** argv)
{
    int fd=STDIN_FILENO;
    int i,n;
    int c=0;

    char buff[300];
    memset(buff, 0, sizeof(buff));
    for (;;)
    {
        n=read(fd,buff,sizeof(buff));
        for (i=0; i&lt;n; i++) 
        {
            switch(buff[i])
            {
            case '^':
                if(c) 
                {
                    // ^^ so output first ^
                    putchar('^');
                }
                else
                {
                    // Possible ^M or ^J
                    c++;
                }
                break;

            case 'M':
                if (c)
                {
                    // ignore ^M
                    c=0;
                }
                else
                {
                    // just M 
                    putchar(buff[i]);
                }
                break;

            case 'J':
                if (c)
                {
                    // ^J is \n
                    putchar('\n');
                    c=0;
                }
                else 
                {
                    // just J
                    putchar(buff[i]);
                }
                break;

            default:
                if (c)
                {
                    // ^ followed by other than J or M
                    putchar('^');
                    c=0;
                }

                putchar(buff[i]);
            }
        }

    }
    return 0;
}
</code></pre>
",,21409042,73132
16978714,2,16977985,2013-06-07T07:38:54.533,0,,1411918,,2013-06-07T07:47:53.280,2013-06-07T07:47:53.280,0,,"<p>Just execute the command ""sed -e 's/\^\M$//g' filename""</p>

<p>or I got this from the website.</p>

<pre><code>#!/usr/bin/python
while True:
  file = raw_input('Input file name:(input ""q"" to quit)')
  if file == 'q':
      break
  file_ = open(file).read()
  list_ = list(file_)
  new_file = ''
  for x in list_:
      if x != '^' and x != 'M':
          new_file = new_file + x
  file_ = open(file,'w')
  file_.write(new_file)
  file_.close()
</code></pre>
",,21418036,3145
17107858,2,17107786,2013-06-14T11:51:38.667,1,,661519,,2013-06-14T11:57:02.990,2013-06-14T11:57:02.990,0,,"<p>You define the function in the header, so you should use the <code>inline</code> keyword:</p>

<pre><code>inline int AAA(){return 0;}
//               ^^^^^^^^^^ definition
</code></pre>

<p>Alternatively, place only the declaration in the header, and the definition in an implementation <code>.cpp</code> file, to be compiled.</p>

<p>Foo.h</p>

<pre><code>#ifndef Foo_H
#define Foo_H

int AAA();

#endif
</code></pre>

<p>Foo.cpp</p>

<pre><code>#include ""Foo.h""

int AAA(){return 0;}
</code></pre>
",,21464214,3424
17108005,2,17107786,2013-06-14T12:00:05.223,6,,2485914,,2013-06-14T12:00:05.223,,0,,"<p>Well, the distribution of stuff in your files is more than unusual to say the least. </p>

<p>Here is how it is commonly done:</p>

<p>Foo.h</p>

<pre><code>#ifndef Foo_H
#define Foo_H

int AAA(void);  // Just the prototype, not the function body

#endif
</code></pre>

<p>Foo.cpp</p>

<pre><code>#include ""Foo.h""   // include the h file, although not strictly neecessary

// make the function and body
int AAA(void)
{
    return 0; 
}
</code></pre>

<p>Sketch.cpp</p>

<pre><code>#include &lt;Foo.h&gt;  // include prototype, so the AAA function becomes known

void setup()
{
     ...
     AAA();   // call AAA somewhere
}

void loop(){

}
</code></pre>
",,21500110,249
42697360,2,17107786,2017-03-09T14:01:17.543,0,,3137068,,2017-03-09T14:01:17.543,,0,,"<p>It is a little more complicated than Bbrado's answer if the structure of your program is a little more complicated. You need to #include <code>&lt;Arduino.h&gt;</code> and #include the help file as shown here:</p>

<p>testCall.ino</p>

<pre><code>#include ""testCall.h""
void setup() {
  AAA();
}
void loop() {
}
</code></pre>

<p>testCall.cpp</p>

<pre><code>#include ""testCall.h""
beeHive AAA(void){
    beeHive a;
    a.bee = (byte)1;
    a.hive = (byte) 2;
    return a;
}
</code></pre>

<p>testCall.h</p>

<pre><code>#include &lt;Arduino.h&gt;
struct beeHive {
  byte bee;
  byte hive;
};
beeHive AAA (void); //  prototype only
</code></pre>
",,21503139,163
17133329,2,17108721,2013-06-16T12:28:29.267,1,,1641938,,2013-06-16T12:28:29.267,,0,,"<pre><code> WebServer &amp;operator &lt;&lt;(WebServer &amp;server,const prog_uchar *str)
 { server.printP(str); return server;}

 template&lt;class T&gt;
 inline WebServer &amp;operator &lt;&lt;(WebServer &amp;obj, T arg)
 { obj.print(arg); return obj; }
</code></pre>

<p>The overload didnt return a type and to resolve ambiguity from the template it was changed to the subclass</p>
",,21504290,487
17161433,2,17134761,2013-06-18T05:52:35.497,1,,1927972,,2013-06-18T07:21:59.460,2013-06-18T07:21:59.460,3,,"<p>You are facing a fundamental problem:  an ISR is called with no data.  In other words, the ISR function is not provided any data that indicates its source of the interrupt. </p>

<p>The basic approach is that the person writing the code provides the linkage between input and action by hardcoding a function.  The tricky approach you are looking for is a method by which the ISR can figure out what the source was.</p>

<p>So you want to have N motors with 2N inputs from quadrature encoders.  A single interrupt handler is attached to all the input pins on a CHANGE condition.  The same handler gets called for all N motors.  It can figure out which Motor to update by comparing the input pins to the values the last time it was called.  If the input pins changed, then call that motor.  Here is a psuedo code</p>

<pre><code>Motor motor1;
Motor motor2;

onSomethingChanged() {
  static int in1aprev, in1bprev;
  static int in2aprev, in2bprev;
  int in1a, in1b;
  int in2a, in2b;
  in1a = digitalRead(....
  same for other in's

  if( (in1a!=in1alast) || (in1b!=in1blast)) {
    motor1.encoderInput(in1a,in1b);
    in1alast = in1a;
    in1blast = in1b;
  }

  if( (in2a!=in2alast) || (in2b!=in1blast)) {
    motor2.encoderInput(in2a,in2b);
    in1a2ast = in2a;
    in1b2ast = in2b;
  }

  return;
} 
</code></pre>

<p>Not so long ago this type of function would be handled in an entire chip  (see <a href=""http://en.wikipedia.org/wiki/Intel_8259"" rel=""nofollow"">programmable interrupt controller</a> ).  The chip implements all the logic to trigger and capture the source of the interrupt.  The main CPU just gets a trigger ""something happened"".  The handler polls the chip to ask ""what happened"".</p>

<p>Having offered this method, I'm not sure I would recommend.  You cannot <strong>hide</strong> what is going on with your code.  The motor must be physically wired to the correct pins.  You have consumed a scarce resource -- you have to tell people.</p>
",,21531898,131
17150705,2,17147153,2013-06-17T15:01:10.230,6,,2493903,,2013-06-17T15:01:10.230,,5,,"<p>From architectural point of view you should define some communication rules (message flow) between your server and client first.</p>

<p>Then just read(write) from(to) instance of QTCPSocket according to defined flow.</p>

<p>You can, for instance, read data on server side, check what you should answer and write response to the same socket from which you have read. For line oriented messages (and only for them) code could look like:</p>

<pre><code>    void Server::on_readyRead()
    {
        // ""while"" loop would block until at least one whole line arrived
        // I would use ""if"" instead
        if(socket-&gt;canReadLine()) 
        {
            QByteArray ba = socket-&gt;readLine();

            QByteArray response;

            // some code which parses arrived message
            // and prepares response

            socket-&gt;write(response);
        }
        //else just wait for more data
    }
</code></pre>

<p>Personally, I would move parsing and sending responses out from on_readyRead() slot to avoid blocking event loop for too long time, but since you are a beginner in network programming I just wanted to clarify what could be done to implement two way communication.</p>

<p>For more details you can see <a href=""http://qt-project.org/doc/qt-4.8/qtnetwork.html"" rel=""noreferrer"">http://qt-project.org/doc/qt-4.8/qtnetwork.html</a></p>

<p>Remember about checking if whole message has arrived on both client and server side. If you use your own protocol (not HTTP, FTP nor other standarized) you can add message length on the beginning of message.</p>
",,21564242,156
17173109,2,17172719,2013-06-18T15:38:26.830,1,,1290438,,2013-06-18T16:01:36.697,2013-06-18T16:01:36.697,3,,"<p>When you do <code>ComPort-&gt;WriteString(""b"");</code> You're sending the character array <code>b\0</code>.
On the arduino side, it seems (as you don't show how you read the input and what is the switch condition), that you're reading a character.</p>

<p>So basically what you do is:</p>

<pre><code>Ard                Host
 | &lt;---['a','\0']--- |
 |                   |
 | ----['2']-------&gt; |
 | &lt;---['b','\0']--- |
</code></pre>

<p>There, your host is sending first <code>a</code>, matching the switch case condition, and at next read it will read <code>\0</code> matching none of the switch case conditions.</p>

<p>I don't know about <code>ComPort</code> arguments, but you should look at some method that would be like <code>ComPort-&gt;WriteChar(char)</code> instead of <code>ComPort-&gt;WriteString(string)</code>, so you'd exchange only characters:</p>

<pre><code>Ard                Host
 | &lt;---['a']-------- |
 |                   |
 | ----['2']-------&gt; |
 | &lt;---['b']-------- |
</code></pre>

<p>UPDATE (cf first comment):</p>

<p>As I found no public documentation of <code>ComPort</code>, I can't exactly help you there, but to make your C++ code wait for an input from the arduino, you shall do something that would look like what follows:</p>

<pre><code>// blocks while there is no input on the serial line
while (!ComPort-&gt;available());
</code></pre>

<p>if you don't have the arduino-like method <code>available()</code> in comport, you can always do something like</p>

<pre><code>char input = '\0';
while ((c = ComPort-&gt;ReadChar()) == ERROR);
</code></pre>

<p>where <code>ERROR</code> is the value returned on timeout, or if it does not you can check against <code>!= '2'</code>.</p>

<p>HTH</p>
",,21606412,127
17214217,2,17208674,2013-06-20T12:55:53.220,0,,1290438,,2013-06-20T12:55:53.220,,1,,"<ul>
<li>Unused index:</li>
</ul>

<p>Everywhere you loop over three values, whereas you only use two items in the array. So you'd better change all your sizes to 2 instead of 3, or you can define a <code>NB_INPUT</code> constant at the top of your source code, that you can change easily for more flexibility:</p>

<pre><code>#define NB_INPUT 2
...

for (int i = 0; i&lt;NB_INPUT; ++i) {
...
</code></pre>

<ul>
<li><code>RXOK</code> in <code>setup()</code>:</li>
</ul>

<p>your comment about arrays is justified, the first bug I can see in your code is that you read from the <code>RXOK</code> array, whereas you did not put any values in it. If you're sure that <code>RXSG</code> gets only zeroes from <code>pulseIn()</code> on the first pass of the <code>Read RX values</code> loop it can be ok, but I doubt it is. e.g.:</p>

<pre><code>for (int i=0; i&lt;3; ++i)
    RXOK[i] = 0;
</code></pre>

<p>So you should put values in <code>RXOK</code> values in <code>setup()</code>.</p>

<ul>
<li>constant indexes in a for loop:</li>
</ul>

<p>Then you <code>map()</code> the values from 1000->2000 to -255->255 for <code>RXSG[0]</code> and <code>RXSG[1]</code> inside the for loop, which will be done for the three iterations. I'm not sure what you want there, but if you want to do it for constant indexes, you'd better do it <em>outside</em> of the loop. But as you're checking a constraint on the -255->255 domain for each value of the iteration loop, I think you may want to do it on relative values:</p>

<pre><code>PWMSG[i] = map(RXSG[i], 1000, 2000, -255, 255);
</code></pre>

<p>but it seems the domain is dependent on the index, so you may want to make a couple of defines at the top of your source code:</p>

<pre><code>#define THROTTLE_IDX 0
#define STEERING_IDX 1
</code></pre>

<p>and put your <code>map()</code> in a if statement:</p>

<pre><code>if (i == THROTTLE_IDX)
    PWMSG[i] = map(RXSG[i], 1000, 2000, -255, 255);
elif (i == STEERING_IDX)
    PWMSG[i] = map(RXSG[i], 1000, 2000, 24, 169);
# add a else statement if you need to do a map for the other values of the array
constrain(PWMSG[i], -255, 255)
</code></pre>

<ul>
<li>general algorithm</li>
</ul>

<p>I'm not sure you really need an array for your use case. You'd better keep a few variables around and have a better use of functions for your code to be readable and less bugprone:</p>

<pre><code>#define THROTTLE_PIN 6
#define STEERING_PIN 7
#define WHEEL_PIN    8
#define MFORWARD_PIN 13
#define MBACKWARD_PIN 10

Servo wheel;

// sets up the arduino
void setup() {
    Serial.begin(115200);
    wheel.attach(WHEEL_PIN);
    pinMode(THROTTLE_PIN, INPUT);
    pinMode(STEERING_PIN, INPUT);
}

// input data handling
int read_throttle() {
    int throttle = pulseIn(THROTTLE_PIN, HIGH, 20000);
    return map(throttle, 1000, 2000, -255, 255);
}

int read_steering() {
    int steering = pulseIn(STEERING_PIN, HIGH, 20000);
    return map(throttle, 1000, 2000, 24, 169);
}

// output actions handling
void move_forward(int val) {
    analogWrite(MFORWARD_PIN, val);
    digitalWrite(MBACKWARD_PIN, LOW);
    // Serial.print...
}

void move_backward(int val) {
    analogWrite(MFORWARD_PIN, val);
    digitalWrite(MBACKWARD_PIN, LOW);
    // Serial.print...
}

void stop_motor() {
    digitalWrite(MFORWARD_PIN, LOW);
    digitalWrite(MBACKWARD_PIN, LOW);
}

void handle_throttle(int throttle) {
    if (throttle &gt; 40)
        move_forward(throttle);
    elif (throttle &lt; -40)
        move_backward(throttle);
    else
        stop_motor();
}

// general algorithm
void loop() {
    int throttle = read_throttle();
    delay(5);
    handle_throttle(throttle);
}
</code></pre>

<p>There are more code duplication, but sometimes it is better to duplicate code than to make a code almost unreadable, and hard to debug while not offering any kind of flexibility/modularity. And here are a few other things I found in your code that should be corrected:</p>

<ul>
<li><p><strong>Naming convention</strong>: try to use good names for your functions (two letters variables, or dutch variables are not a good idea, I'm not english native and I always avoid to use my own language based names in code even for code I don't share, you never know who will read your code in 2 days, 2 months, or 2 years).</p></li>
<li><p><strong>globals</strong>: Try to avoid using global variables as much as possible. Declare only constant in the global scope : <code>const int foo = 1;</code> or preprocessor defines <code>#define foo 1</code>, so that you do not spend too much of the little RAM space you have on your arduino. The only exception to that rule, which is very specific to arduino development, are objects (like <code>Servo</code> in your code) that you need to declare globally so you can set them up in the <code>setup()</code> function, and use them in the <code>loop()</code> function.</p></li>
</ul>

<p>If I extrapolate on what you've written, you may want to add a <code>handle_steering()</code> function such as:</p>

<pre><code>void handle_steering(int steering) {
    if (steering &gt; NN)
        turn_left(steering);
    elif (steering &lt; NN)
        turn_right(steering);
    else
        keep_straight();
}
</code></pre>

<p>and change the loop() to :</p>

<pre><code>void loop() {
    int throttle = read_throttle();
    int steering = read_steering();
    delay(5);
    handle_throttle(throttle);
    handle_steering(steering);
}
</code></pre>

<p>To make it a more general case of handling dynamically and flexibly a number of features, you could keep a few arrays:</p>

<ul>
<li><code>PIN[]</code>: containing the pins,</li>
<li><code>DOM_MIN[]</code>: containing the minimum of the features' domain (for the map),</li>
<li><code>DOM_MAX[]</code>: containing the maximum of the features' domain (for the map),</li>
<li><code>BOUND_MIN[]</code>: containing the minimum boundaries (for the handle_steering condition),</li>
<li><code>BOUND_MAX[]</code>: containing the maximum boundaries (for the handle_steering condition),</li>
<li><code>ACTION[]</code>: containing the pointers to functions.</li>
</ul>

<p>and then your algorithm would <em>look</em> like:</p>

<pre><code>int read_input(int i) {
    int value = pulseIn(PIN[i], HIGH, 20000);
    return map(value, 1000, 2000, DOM_MIN[i], DOM_MAX[i]);
}

int handle_action(int i, int value) {
    if (value &gt; BOUND_MIN[i])
        *(ACTION[i])(value);
    elif (value &lt; BOUND_MAX[i])
        *(ACTION[i])(value);
    else
        *(ACTION[i])(-1);
}

void loop() {
    for (int i=0; i&lt;NB_INPUTS; ++i) {
        int value = read_input(i);
        delay(5);
        handle_action(i, value);
    }
}
</code></pre>

<p>but as you're still not comfortable with arrays (and I assume pointers as well), I would not recommend going further that way for the time being. First do it simple and make it work and then you could try to factorize it following the idea I'm exposing here. But you're making a software that is embedded, where the RAM is rare and the processing power is low, while your code space is cheap. So it's one of the few occasions where you'd better want to make a more redundant code that will stay in program space, whereas you want to manipulate as little symbols in the RAM. That's why I'm not showing you how the arrays are being declared/defined, and how to handle function pointers, because I don't think that solution (where you were heading) is the right way to do what you want.</p>

<p>Always remember, simpler is better!</p>

<p>HTH</p>
",,21639725,4717
17247966,2,17237173,2013-06-22T06:25:29.783,7,,168986,,2013-11-10T15:31:22.593,2013-11-10T15:31:22.593,2,,"<p>Your speed calculation timer and your PID loop timer should be the same thing - not separate.</p>

<p>Do not waste time and resolution converting pulse count to speed in RPM; if the timer is accurately periodic - and it needs to be for a stable PID - then the pulse count is directly <em>proportional</em> to speed, and the PID does not care about the units - that can be adjusted for by the value of the coefficients.  If you want your set-point speed to be in real-world units, convert <em>that</em> to the equivalent number of pulses-per-PID-period instead of the other way around.</p>

<p>Your loop should look like this ;</p>

<pre><code>for(;;)
{
    WaitTimer() ;
    pulses = pulse_count - previous_pulse_count ;
    previous_pulse_count = pulse_count ;
    control = pid( pulses ) ;
    motor( control ) ;
}
</code></pre>

<p>You then need only an interrupt to count pulses - it need not perform any calculation, just increment a counter - and perhaps an interrupt for the timer, depending on the implementation of WaitTimer() and whether this is multi-threaded.</p>

<p>Note also that if the shared variable pulse_count is not atomic, you will need to disable interrupts while it is read (best wrapped in a function), and it will need to be declared <code>volatile</code>.</p>
",,21642134,1123
17283124,2,17271738,2013-06-24T19:06:08.513,0,,2381671,,2013-06-25T15:09:17.367,2013-06-25T15:09:17.367,1,,"<pre><code>vibeCS.capacitiveSensor(  ) 
</code></pre>

<p>returns a long (4 bytes) not an int (2 bytes). However it must be over loaded b/c it lets you compile. </p>

<p><a href=""http://playground.arduino.cc//Main/CapacitiveSensor?from=Main.CapSense"" rel=""nofollow"">http://playground.arduino.cc//Main/CapacitiveSensor?from=Main.CapSense</a></p>

<p>2
you might have to check your processor to see if it is big ended or little ended.</p>

<p>Edit :
I suspect the code below does not do what you want it to do.</p>

<pre><code>    int i;
    for(i = 0; i &lt; sizeof(receive_buffer); i++) {
         i = 
         printf(""%i"", (int)receive_buffer[i]);
    }
</code></pre>

<p>For example lets say there is one int in the buff. The int has a value of 4242;
the value of 4242 in hex is [00 00 10 92]</p>

<p>so 
buf[0] = 0x92 = 147 ,</p>

<p>buf[1] = 0x10 = 16 ,</p>

<p>buf[2] = 0x0 = 0, </p>

<p>buf[3] = 0x0 = 0;</p>

<p>So your code would print 1471600 for the value that is 4242. the code below show what I am talking about.</p>

<pre><code>1 #include &lt;stdio.h&gt;
2 #include &lt;stdlib.h&gt;
3 
4 int main()
5 {
6         unsigned char buf[4];
7         unsigned int *fill = buf;
8         *fill = 4242;
9 
10         int i;
11         for(i = 0; i &lt; sizeof(buf); i++) {
12             printf(""%i"", (unsigned int)buf[i]);
13         }
14 
15 }

printed value is [1461600]
</code></pre>

<p>now for something useful. The code below might fix all your problems.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void) {

    // open a stream with popen with the (working) command    
    FILE *stream = popen(""minicom -b 9600 -o -D /dev/ttyACM0"", ""r"");

    while (!feof(stream) &amp;&amp; !ferror(stream)) {

        // declare a buffer, read the stream
        char buf[4];
        int bytesRead = fread(buf, 1, 4, stream);

        // print stuff to see what has been read
        int *i = buf;
        printf(""%i"", *i);
        //for(i = 0; i &lt; sizeof(buf); i++) {
        //   printf(""%i"", (int)buf[i]);
        //}

        printf(""\n"");
    }

    pclose(stream);
    return 0;
}
</code></pre>
",,21664672,204
17331530,2,17330991,2013-06-26T22:26:23.260,1,,787655,,2013-06-26T22:26:23.260,,0,,"<p>It looks like you're checking to see that <code>Serial.available()</code> is not zero and then reading a bunch of data.  It could be that you are not done recieving the data when you begin your <code>receiveMsg</code> function.  You should:</p>

<ol>
<li>Check to make sure that the bytes you need are available Wait if</li>
<li>They are not available, but you expect them to be coming soon</li>
</ol>

<p>Just as an example:</p>

<pre><code>void receiveMsg(MESSAGE_STRUCT* message)
{
  // receive bytes and put them back as integers
  intByte code_word, checksum;

  // receive byte by byte, wait for it if need be
  while( Serial.available() &lt; 1 ) {delay(10);}
  message-&gt;start_byte = Serial.read();
  while( Serial.available() &lt; 1 ) {delay(10);}
  message-&gt;length = Serial.read();
</code></pre>

<p>There are better, more robust ways to do it, but this is pretty simple and easily implemented for a test to see if the input buffer is not getting filled.</p>
",,21678099,4030
17353561,2,17352942,2013-06-27T21:30:54.470,0,,92546,,2013-06-27T21:30:54.470,,0,,"<p>How about a single loop forever:</p>

<pre><code>fade = 0;
step = 1;
while(1)
   {
   step = fade == 0 ? 1 : (fade == 255 ? -1 : step);
   fade += step;
   analogWrite(redPin, fade);
   delay(30);
   analogWrite(greenPin, fade );
   delay(30);
   analogWrite(bluePin, fade);
   delay(30);
   }
</code></pre>
",,21690360,2177
17356420,2,17356368,2013-06-28T02:44:18.407,2,,2514521,,2013-06-28T02:44:18.407,,2,,"<p>Something like:</p>

<pre><code>int timekeeper=0;
while (1) 
{
    do_fade(timekeeper);
    if (timekeeper%100==0) {
      do_blink_off();
    }
    if (timekeeper%100==50) {
      do_blink_on();
    }
    delay(10);
    timekeeper++;
}
</code></pre>

<p>This is done from memory, so your mileage may vary.
I've passed timekeeper to do_fade(), so you can figure out how far along the fade you are. do_fade() would update the fade, then immediately return. do_blink_on() and do_blink_off() would be similar - change what you need to change, then return. In this example, do_fade() would be called every 10 milliseconds, do_blink_off() once per second, with do_blink_on() 1/2 a second after (so on, 1/2 second, off, 1/2 second, on, 1/2 second...)</p>
",,21710744,1524
17394825,2,17394147,2013-06-30T21:02:32.780,0,,1290438,,2013-06-30T23:30:05.660,2013-06-30T23:30:05.660,2,,"<p>instead of doing the following:</p>

<pre><code>const prog_char error_1000[] PROGMEM = ""No data provided."";
const prog_char error_1001[] PROGMEM = ""device not activated"";
const prog_char error_2000[] PROGMEM = ""Machine ID invalid"";
const prog_char error_3000[] PROGMEM = ""Insufficient Balance"";
</code></pre>

<p>I'd advise you to index the error category (<code>1000</code>s, <code>2000</code>s etc..) as first index of a matrix, and the actual error as second index of the array:</p>

<p>Here's the idea:</p>

<pre><code>const prog_char error_code[1][0] PROGMEM = ""No data provided."";
const prog_char error_code[1][1] PROGMEM = ""device not activated"";
const prog_char error_code[2][0] PROGMEM = ""Machine ID invalid"";
const prog_char error_code[3][0] PROGMEM = ""Insufficient Balance"";
</code></pre>

<p><em>(edit)</em> Here's a valid syntax:</p>

<pre><code>const prog_char* error_code[][3] PROGMEM = {{""ERROR 1000"", ""ERROR 1001"", ""ERROR 1002""},
                                            {""ERROR 2000"", ""ERROR 2001"", ""ERROR 2002""},
                                            {""ERROR 3000"", ""ERROR 3001"", ""ERROR 3002""}};
</code></pre>

<p>the only drawback will be that you shall specify the length of the inner array, and thus need to have the same number of string in each inner array.</p>

<p>And then you could code a function that does status code conversion:</p>

<pre><code>const prog_char* fmt_error(int code) {
    return error_code[code/1000][code%1000];
}

void loop()
{
   int result = device.GetStatus();
   Serial.println(fmt_error(result));
}
</code></pre>

<p>That solution does not use more memory than using one array (just one more pointer). The only downside of that is if you need status code that are not contiguous, like <code>1000</code>, <code>1010</code>, <code>1042</code> and <code>1300</code>. Then there is no cool solution I can think of, except using a good old switch/case:</p>

<pre><code>const prog_char* fmt_error(int code) {
    switch (code) {
        case (1000): return F(""Error XXX"");
        case (1042): return F(""Error which code is not contiguous"");
        case (2042): return F(""Another error"");
    }
}
</code></pre>

<p><em>(edit)</em> I had a third idea on how to deal with your problem:</p>

<pre><code>typedef struct
{
    int code;
    prog_char* message;
} error_code;

const error_type error_codes[] =
{
    {0000, F(""Unknown error code"")},
    {1000, F(""Error foo"")},
    {1001, F(""Error bar"")},
    {2000, F(""Error foobar"")}
    ...
};

const prog_char* fmt_error(int code) {
    for (int i=0; i&lt;sizeof(error_codes);++i)
        if (error_codes[i].code == code)
            return error_codes[i].message;
    return error_codes[0];
}
</code></pre>

<p>But I think the solution that uses the less memory of all three solution is the second one using use cases. Because everything is done in program memory, and all the strings are in the flash thanks to the <code>F()</code> macro. To save a few extra bytes, you could even make the <code>fmt_error()</code> function inline, so it does not add to the function call stack.</p>

<p>HTH</p>
",,21820336,360
17410904,2,17400954,2013-07-01T18:10:36.100,4,,1475978,,2013-07-03T20:35:53.970,2013-07-03T20:35:53.970,7,,"<p>The <a href=""http://man7.org/linux/man-pages/man2/execve.2.html"" rel=""nofollow""><code>execve()</code></a> call supplies a new environment to the executed program. For the program to be able to access the X display, you need to retain certain environment variables -- <code>DISPLAY</code> at minimum. Have you inadvertently omitted <code>DISPLAY</code> from the new environment?</p>

<p>For OMXPlayer to work without X, it has to have access to the video device itself (<code>/dev/video</code>, in this case; see <a href=""http://omxplayer.sconde.net/"" rel=""nofollow"">OMXPlayer builds</a> page for details). It's usually configured so that all members of the <code>video</code> group are allowed to access it.</p>

<p>You can use <code>popen(""id -Gn"", ""r"")</code> in your program, to run the <code>id -Gn</code> command which lists the current group memberships. (Read the list as a string from the file handle, then close it using <code>pclose()</code>.) If the list does not contain <code>video</code>, then the problem is that the privileges of the user that is running the original program do not include access to the video device. The fix is simple: adding <code>video</code> to the groups that user is a member of.</p>

<hr>

<p>Here is an example program, <code>run.c</code>, to illustrate basic use of <code>execvp()</code>:</p>

<pre><code>#include &lt;unistd.h&gt;

/* For the example main(): */
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

/* Try executing a command in a child process.
 * Returns the PID of the child process,
 * but does not tell whether the execution was
 * successful or not.
 * Returns (pid_t)-1 with errno set if fork() fails.
*/
pid_t run(char *const command[])
{
    pid_t   child;

    child = fork();
    if (child == (pid_t)-1)
        return (pid_t)-1;

    if (!child) {
        execvp(command[0], command);
        _exit(127);
    }

    return child;
}

int main(int argc, char *argv[])
{
    pid_t child, p;
    int   status;

    if (argc &lt; 2 || !strcmp(argv[1], ""-h"") || !strcmp(argv[1], ""--help"")) {
        fprintf(stderr, ""\n"");
        fprintf(stderr, ""Usage: %s [ -h | --help ]\n"", argv[0]);
        fprintf(stderr, ""       %s COMMAND [ ARGUMENTS .. ]\n"", argv[0]);
        fprintf(stderr, ""\n"");
        return 1;
    }

    child = run(argv + 1);
    if (child == (pid_t)-1) {
        fprintf(stderr, ""%s: %s.\n"", argv[1], strerror(errno));
        return 1;
    }

    fprintf(stderr, ""(%s: PID %d)\n"", argv[1], (int)child);
    fflush(stderr);

    do {
        p = waitpid(child, &amp;status, 0);
        if (p == (pid_t)-1 &amp;&amp; errno == EINTR)
            continue;
    } while (p != child &amp;&amp; p != (pid_t)-1);
    if (p == (pid_t)-1) {
        fprintf(stderr, ""(%s: %s.)\n"", argv[1], strerror(errno));
        return 1;
    }

    if (WIFEXITED(status)) {
        if (WEXITSTATUS(status) == 127)
            fprintf(stderr, ""(%s: Could not execute command.)\n"", argv[1]);
        else
        if (WEXITSTATUS(status) == 0)
            fprintf(stderr, ""(%s: Exited successfully.)\n"", argv[1]);
        else
            fprintf(stderr, ""(%s: Exited with error %d.)\n"", argv[1], WEXITSTATUS(status));
    } else
    if (WIFSIGNALED(status))
        fprintf(stderr, ""(%s: Killed by %s.)\n"", argv[1], strsignal(WTERMSIG(status)));
    else
        fprintf(stderr, ""(%s: Died from unknown causes.)\n"", argv[1]);

    return status;
}
</code></pre>

<p>You can compile and test it using e.g.</p>

<pre><code>gcc -W -Wall -O3 run.c -o run
./run date --utc
</code></pre>

<p>Note that the <code>run()</code> function does not attempt to check whether the command was actually executed or not; it just returns the child process PID, or <code>(pid_t)-1</code> if <code>fork()</code> fails.</p>

<p>Many implementations, including GNU C library <code>popen()</code>, use the 127 exit status as an indication that the execution failed. That is, it is not returned by the command that should have been executed, but by the child process, because the command execution failed. The above <code>run()</code> does so too.</p>

<hr>

<p>You can use a close-on-exec pipe between the parent and child processes in the <code>run()</code> function, to let the parent process know whether the child process successfully started the desired command or not, and if not, why not. The parent process can then also immediately reap the defunct child process. This leaves very little extra effort to the caller in case of errors, so I personally highly recommend this approach. Here is an example implementation:</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

/* Helper function: Close file descriptor, without modifying errno.
 * Returns 0 if successful, otherwise the errno reported by close().
*/
static int closefd(const int fd)
{
    int saved_errno, result;

    /* Invalid descriptor? */
    if (fd == -1)
        return EINVAL;

    /* Save errno. It's thread-local, so as long as we restore
     * it before returning, no-one will notice any change in it. */
    saved_errno = errno;

    /* Close descriptor, and save errno (or 0) in result. */
    do {
        result = close(fd);
    } while (result == -1 &amp;&amp; errno == EINTR);
    if (result == -1)
        result = errno;
    else
        result = 0;

    /* Restore errno. Done. */
    errno = saved_errno;

    return result;
}

/* Helper function: Create a close-on-exec pipe.
 * Return 0 if success, errno otherwise.
*/
int close_on_exec_pipe(int fds[2])
{
    int result;

    result = pipe(fds);
    if (result == -1) {
        fds[0] = -1;
        fds[1] = -1;
        return errno;
    }

    do {

        do {
            result = fcntl(fds[0], F_SETFD, FD_CLOEXEC);
        } while (result == -1 &amp;&amp; errno == EINTR);
        if (result == -1)
            break;

        do {
            result = fcntl(fds[1], F_SETFD, FD_CLOEXEC);
        } while (result == -1 &amp;&amp; errno == EINTR);
        if (result == -1)
            break;

        /* Success. */
        return 0;

    } while (0);

    /* Failed. */
    closefd(fds[0]);
    closefd(fds[1]);
    fds[0] = -1;
    fds[1] = -1;

    return errno;
}

/* Run an external command in a child process.
 * command[0] is the path or name of the command,
 * and the array must be terminated with a NULL.
 *
 * If successful, this function will return the PID
 * of the child process. Otherwise, it will return
 * (pid_t)-1, with errno indicating the error.
*/
pid_t run(char *const command[])
{
    pid_t   child, p;
    int     commfd[2], errcode;

    /* Create a close-on-exec pipe between the parent and child. */
    if (close_on_exec_pipe(commfd))
        return (pid_t)-1;

    /* Fork the new child process. */
    child = fork();
    if (child == (pid_t)-1) {
        closefd(commfd[0]);
        closefd(commfd[1]);
        return (pid_t)-1;
    }

    if (!child) {
        /* Child process: */

        /* Close the read/parent end of the pipe. */
        closefd(commfd[0]);

        /* In case of C library bugs, prepare errno. */
        errno = EINVAL;

        /* Execute the desired command. */
        execvp(command[0], command);

        /* Failed. errno describes why. */
        errcode = errno;

        /* Send it to the parent via the pipe. */
        {
            const char       *p = (char *)&amp;errcode;
            const char *const q = (char *)&amp;errcode + sizeof errcode;
            ssize_t           n;

            while (p &lt; q) {
                n = write(commfd[1], p, (size_t)(q - p));
                if (n &gt; (ssize_t)0)
                    p += n;
                else
                if (n != (ssize_t)-1)
                    break;
                else
                if (errno != EINTR)
                    break;
            }
        }

        /* Close write/child end of the pipe. */
        closefd(commfd[1]);

        /* Exit with a failure (127). */
        _exit(127);
    }

    /* Parent: */

    /* Close the write/child end of the pipe. */
    closefd(commfd[1]);

    /* Try to read the execution error. */
    {
        char       *p = (char *)&amp;errcode;
        char *const q = (char *)&amp;errcode + sizeof errcode;
        ssize_t     n;

        errcode = 0;

        while (p &lt; q) {
            n = read(commfd[0], p, (size_t)(q - p));
            if (n &gt; (ssize_t)0)
                p += n;
            else
            if (n != (ssize_t)-1)
                break; /* n == 0 is pipe closed */
            else
            if (errno != EINTR)
                break;
        }

        /* Close the read/parent end of the pipe. */
        closefd(commfd[0]);

        /* Pipe closed (on exec), no data read? */
        if (n == (ssize_t)0 &amp;&amp; p == (char *)&amp;errcode) {
            /* Yes, success! */
            errno = 0;
            return child;
        }

        /* Execution failed.
         * If we didn't get the reason, use EINVAL. */
        if (!errcode || p != q)
            errcode = EINVAL;
    }

    /* Reap the child process. */
    do {
        p = waitpid(child, NULL, 0);
        if (p == (pid_t)-1) {
            if (errno == EINTR)
                continue;
            else
                break;
        }
    } while (p != child);

    /* Return with failure. */
    errno = errcode;
    return (pid_t)-1;
}
</code></pre>

<p>The only downside to this approach, in my opinion, is the extra two descriptors used in the parent process, albeit only temporarily. In almost all cases this is irrelevant, but if you have a server-type application that uses a lot of file descriptors, this is something you should be aware of.</p>

<hr>

<p>The Phidgets library uses threads. The thread that executes the callbacks is different than the one that say, waits for the keypress in the RFID Phidgets example. One option would be to use <code>posix_spawn()</code> to execute the player (from a non-main thread).</p>

<p>However, in general, it is better to have the main thread monitor both the player using <a href=""http://man7.org/linux/man-pages/man2/waitpid.2.html"" rel=""nofollow""><code>waitpid(child, &amp;status, WNOHANG)</code></a> to check if the player has exited, and to handle any new RFID events, launching the player as needed (killing an existing instance if new RFID), and even killing the player if the RFID is moved outside the reader range.</p>

<p>This requires a simple threaded event queue:</p>

<pre><code>#define  _POSIX_C_SOURCE 200809L
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

/* RFID tag event types: tag read, tag lost.
*/
typedef enum {
    RFID_TAG_LOST = 0,
    RFID_TAG_READ
} rfid_event_type_t;

/* Structure describing all possible RFID tag events.
*/
typedef struct rfid_event_st  rfid_event_t;
struct rfid_event_st {
    struct rfid_event_st     *next;
    rfid_event_type_t         type;
    CPhidgetRFIDHandle        rfid;
    CPhidgetRFID_Protocol     protocol;
    void                     *userptr;
    char                      tag[];
};

static pthread_mutex_t  event_lock = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t   event_wait = PTHREAD_COND_INITIALIZER;
static rfid_event_t    *event_queue = NULL;

/* Add event to event queue.
*/
static int add_event(const CPhidgetRFIDHandle rfid,
                     const CPhidgetRFID_Protocol protocol,
                     const rfid_event_type_t type,
                     const char *const tag,
                     void *const userptr)
{
    const size_t  taglen = (tag) ? strlen(tag) : 0;
    rfid_event_t *ev;

    /* Allocate memory for a new event. */
    ev = malloc(sizeof (rfid_event_t) + taglen + 1);
    if (!ev)
        return errno = ENOMEM;

    /* Fill in the fields. */
    ev-&gt;next = NULL;
    ev-&gt;type = type;
    ev-&gt;rfid = rfid;
    ev-&gt;protocol = protocol;
    ev-&gt;userptr = userptr;
    if (taglen &gt; 0)
        memcpy(ev-&gt;tag, tag, taglen);
    ev-&gt;tag[taglen] = '\0';

    /* Lock event queue. */
    pthread_mutex_lock(&amp;event_lock);

    /* Append to the event queue. */
    if (event_queue) {
        rfid_event_t *prev = event_queue;
        while (prev-&gt;next)
            prev = prev-&gt;next;
        prev-&gt;next = ev;
    } else
        event_queue = ev;

    /* Signal and unlock. */
    pthread_cond_signal(&amp;event_wait);
    pthread_mutex_unlock(&amp;event_lock);

    return 0;
}

/* Get next event, waiting at most 'maxwait' seconds.
*/
static rfid_event_t *get_event(const long maxwait)
{
    struct timespec until;
    rfid_event_t   *ev;

    pthread_mutex_lock(&amp;event_lock);

    /* Event already in the queue? */
    if (event_queue) {
        ev = event_queue;
        event_queue = ev-&gt;next;
        ev-&gt;next = NULL;
        pthread_mutex_unlock(&amp;event_lock);
        return ev;
    }

    /* No waiting requested? */
    if (maxwait &lt;= 0L) {
        pthread_mutex_unlock(&amp;event_lock);
        return NULL;
    }

    /* Get current wall clock time, */
    clock_gettime(CLOCK_REALTIME, &amp;until);
    /* and add maxwait seconds. */
    until.tv_sec += maxwait;

    /* Wait for a signal. */
    pthread_cond_timedwait(&amp;event_wait, &amp;event_lock, &amp;until);

    /* Event arrived in the queue? */
    if (event_queue) {
        ev = event_queue;
        event_queue = ev-&gt;next;
        ev-&gt;next = NULL;
        pthread_mutex_unlock(&amp;event_lock);
        return ev;
    }

    /* No event; timed out. */
    pthread_mutex_unlock(&amp;event_lock);
    return NULL;
}
</code></pre>

<p>As per the Phidgets RFID example, the tag and tag lost handlers are</p>

<pre><code>int CCONV TagHandler(CPhidgetRFIDHandle RFID, void *usrptr, char *TagVal, CPhidgetRFID_Protocol proto)
{
    return add_event(RFID, proto, RFID_TAG_READ, TagVal, usrptr);
}

int CCONV TagLostHandler(CPhidgetRFIDHandle RFID, void *usrptr, char *TagVal, CPhidgetRFID_Protocol proto)
{
    return add_event(RFID, proto, RFID_TAG_LOST, TagVal, usrptr);
}
</code></pre>

<p>Instead of waiting for a keypress after everything has been set up, you create a loop, something like</p>

<pre><code>    pid_t         child = (pid_t)-1; /* Not running */
    pid_t         p;
    rfid_event_t *event;

    /* Infinite loop */
    while (1) {

        /* Do we have a player child process? */
        if (child != (pid_t)-1) {

            /* Yes. Has it exited yet? */
            p = waitpid(child, NULL, WNOHANG);
            if (p == child) {
                /* Yes. No more player. */
                child == (pid_t)-1;
            }
        }

        /* Check for a new event.
         * If we have a child, only wait one second only
         * for the event; otherwise, wait up to 30 secs.
        */
        if (child == (pid_t)-1)
            event = get_event(30L);
        else
            event = get_event(1L);

        /* If no event yet, start at the beginning of the loop. */
        if (!event)
            continue;

        /*
         * TODO: Handle the event.
         *       You can stop the existing player via e.g.
         *       if (child != (pid_t)-1)
         *           kill(child, SIGKILL);
         *       and then start a new one.
        */

        /* Discard the event. It's dynamically allocated. */
        free(event);
    }
</code></pre>

<p>If you start the player, the above loop detects it is not playing within a second. If there is no player running, then it's okay for the loop to wait for an RFID signal for as long as it wants -- I used 30 seconds.</p>
",,21855114,2472
17461923,2,17461623,2013-07-04T04:32:55.170,3,,845568,,2013-07-04T04:32:55.170,,0,,"<p>Since the endianess of the CPU's involved are different you will need to reverse the order of bytes before you send them or after your receive them. In this case I would recommend reversing them before you send them just to save CPU cycles on the Arduino. The simplest way using the C++ Standard Library is with <a href=""http://en.cppreference.com/w/cpp/algorithm/reverse"" rel=""nofollow""><code>std::reverse</code></a> as shown in the following example</p>

<pre><code>#include &lt;cstdint&gt;  // uint64_t (example only)
#include &lt;iostream&gt; // cout (example only)
#include &lt;algorithm&gt;  // std::reverse

int main()
{
    uint64_t value = 0x1122334455667788;

    std::cout &lt;&lt; ""Before: "" &lt;&lt; std::hex &lt;&lt; value &lt;&lt; std::endl;

    // swap the bytes
    std::reverse(
        reinterpret_cast&lt;char*&gt;(&amp;value),
        reinterpret_cast&lt;char*&gt;(&amp;value) + sizeof(value));

    std::cout &lt;&lt; ""After: "" &lt;&lt; std::hex &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>

<p>This outputs the following:</p>

<blockquote>
  <p>Before: 1122334455667788<br>
  After: 8877665544332211</p>
</blockquote>
",,21891437,12723
17538370,2,17537757,2013-07-09T01:06:23.497,0,,1927972,,2013-07-10T05:39:05.100,2013-07-10T05:39:05.100,3,,"<p>Your code should not compile as pasted here.  The checkForCorrectCommand function does not have a return value for both the match and unmatch.  Your code shows you intend to empty the inputString buffer for both the match and non matched case.  If the string match is not true, you want to leave the input buffer unchanged so that the following test cases can run.</p>

<pre><code>bool checkForCorrectCommand(String cmd) {  

  if(inputString == cmd) { 
    // for match case, the string is consumed from the buffer
    inputString = """";
    stringComplete = false;
    return true;
  } 
  else {
    // for the non-match case, leave the buffer for further Rx or further tests
    return false;
  } 
</code></pre>
",,21918715,84
17685736,2,17537757,2013-07-16T19:51:24.480,0,,708807,,2013-07-16T19:51:24.480,,0,,"<p>So I modified my sketch with the following code, and now it seems to processing the serial commands the way I want it too.</p>

<pre><code> // flow_A LED
 int led = 4;

 // relay_A
 const int RELAY_A = A0;

 // variables from sketch example
 String inputString = """"; // a string to hold incoming data
 boolean stringComplete = false; // whether the string is complete

 // variables from SO thread
 boolean LED_state = false;
 boolean vavle_open = false;

// flowmeter shit
unsigned long totalCount = 0;
unsigned long previousCount = 0;
int pin = 2;
unsigned long duration;

// storage variable for the timer
unsigned long previousMillis=0;
int interval=1000; //in milliseconds

// counters for each flowmeter
unsigned long countA = 0;

void setup() {
   // initialize serial
   Serial.begin(9600); // open serial port, sets data rate to 115200bps
   // Serial.println(""Power on test - println"");
   // line below is for iPhone testing
   // Serial.write(""Power on test - write"");
   inputString.reserve(200);

   pinMode(RELAY_A, OUTPUT);

   // flowmeter shit
   pinMode(pin, INPUT);

}

void open_valve() {

  digitalWrite(RELAY_A, HIGH); // turn RELAY_A on
  // Serial.println(""Valve Open"");
  Serial.write(""{valve_open}"");
}

void close_valve() {
  digitalWrite(RELAY_A, LOW); // turn RELAY_A off
  // Serial.println(""Vavle Closed"");
  Serial.write(""{valve_close}"");
}

void flow_A_blink() {

  digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)
  delay(1000);              // wait for one second
  digitalWrite(led, LOW);   // turn the LED off by making the voltage LOW
  delay(1000);              // wait for a second
}

void flow_A_blink_stop() {

  digitalWrite(led, LOW);
}

void getFlow() {

  duration = pulseIn(pin, HIGH);
  Serial.print(duration);
  Serial.println("""");
  delay(200);
}

/*
 * Main program loop, runs over and over repeatedly
 */

void loop() {

 //print the string when a newline arrives:
 if(stringComplete) {
//    Serial.println(inputString);

    if(inputString.equals(""{open_valve}\n"")) {
//       Serial.println(""opening valve."");
       open_valve();
    }

    if(inputString.equals(""{open_valve}"")) {
//       Serial.println(""opening valve."");
       open_valve();
    }

    if(inputString.equals(""{close_valve}\n"")) {
//      Serial.println(""close vavle."");
      close_valve();
    }

    if(inputString.equals(""{close_valve}"")) {
//      Serial.println(""close vavle."");
      close_valve();
    }

  // clear the string:
  inputString = """";
  stringComplete = false;
  }
}

/*
 SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
*/

void serialEvent() {
  while(Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
    // Serial.println(inputString.length());
  }
}
</code></pre>
",,21924865,107
19891587,2,17537757,2013-11-10T15:37:33.310,0,,2907920,,2013-11-10T15:37:33.310,,0,,"<p>The note from jdr5ca is quite correct. The checkForCorrectCommand routine needed an else clause with a separate return statement. The solution devised by Chris is good. It is clearly better to only process the contents of inputString if it is complete and discard it (the contents of inputString) after checking for the valid commands. I would like to offer a minor change to serialEvent. </p>

<p>The serialEvent routine should not keep adding characters to a string that is already complete. Instead it should leave them in the buffer to help form the next command. See the code below. </p>

<pre><code>void serialEvent() {
  if (stringComplete)
    return;
  while(Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
} 
</code></pre>
",,21946585,7933
17552715,2,17552469,2013-07-09T15:51:52.980,1,,1919155,,2013-07-09T16:07:42.873,2013-07-09T16:07:42.873,6,,"<p>You will need to use <code>long</code> to store values over 32767 (or in an unsigned, over 65535). </p>

<p>I'll be back with a simpler piece of code - I think your code is more complex than it needs to be. </p>

<p>This code uses no standard functions except <code>isdigit</code>, and just walks through the number. No limitiation on the size of the number (obviosusly, if you go over the limit for a <code>double</code>, then  it will fail). Error handling may need a bit of improvement. I have given it some mild testing... </p>

<pre><code>double str_to_double(const char *data, size_t len)
{
    double d = 0.0;
    bool neg = false;
    int index = 0;

    if (data[index] == '-')
    {
    index++;
    neg = true;
    }

    while(data[index] != '.' &amp;&amp; index &lt; len)
    {
    if (isdigit(data[index]))
    {
        d = d * 10 + (data[index] - '0');
        index ++;
    }
    else 
    {
        // Handle ""bad input"" ... 
        return -1;
    }
    }
    if (data[index] == '.')
    {
    index ++;
    double div = 10.0;
    while(index &lt; len)
    {
        if (isdigit(data[index]))
        {
        d += (data[index] - '0') / div;
        div *= 10;
        index++;
        }
        else
        {
        // Handle bad input
        return -1;
        }
    }
    }
    // Flip sign if need be. 
    if (neg)
    {
    d = -d;
    }
    return d;
}
</code></pre>
",,21946796,739
17552974,2,17552469,2013-07-09T16:04:12.690,0,,2381671,,2013-07-10T13:32:33.393,2013-07-10T13:32:33.393,2,,"<p>I would try to save the result in a float. The code below is what I would try.</p>

<pre><code>float result = 0;
float scale = 10;
bool pastDecPoint = false;
while(buff != '\n') {
    if(isdigit(buff){
          if(pastDecPoint) 
          {
             result = result + (buff / scale);
             scale = scale * 10;

           }
           else
           {
             result = (result * 10.0) + atoi(buff);
           } 
    } else if (buff == '.') {

        pastDecPoint = true;
    }
    buff = theSettings.read();
};
Serial.println(result);

}
</code></pre>

<p>I also want to see what petersson comes back with. Which is very similar to Petersson</p>
",,21962467,251
17646504,2,17646377,2013-07-15T03:51:52.563,2,,1927972,,2013-07-15T03:51:52.563,,1,,"<p>You are working on a microcontroller with just a little bit of RAM.  You need to carefully evaluate if ""unknown length"" also implies unbounded length.  You cannot deal with unbounded length.  Your best approach for reliable operation is to use fixed buffers setup for the maximum size.</p>

<p>A common pattern for this type of action is to pass the buffer to the function, and return what has been used.  Your function would then look much like many of the C character string functions:</p>

<pre><code>const size_t HEX_PARSER_MAX_DATA_SIZE = 20;
byte data[HEX_PARSER_MAX_DATA_SIZE];

n = oHexP.getParsedData(data, HEX_PARSER_MAX_DATA_SIZE);

int HEXParser::getParsedData(byte* data, size_t sizeData)
{
  int dataIndex = 0;

  // fetch data, do stuff
  // etc, etc...

  data[dataIndex] = incomingByte;
  dataIndex++;
  if (dataIndex &gt;= sizeData) {
     // stop
  }

  // At the very end of the method I know that all the bytes I need to return
  // are stored in data, and the data size is dataIndex - 1

  return dataIndex;
}
</code></pre>
",,21980076,339
17665591,2,17662518,2013-07-15T23:25:31.167,5,,2357837,,2013-07-18T08:21:48.227,2013-07-18T08:21:48.227,9,,"<p>In the first block of code, <code>img1</code> and <code>img2</code> are declared and contain two gray valid images (since you do <code>imread</code>). Note that these <code>img1</code> and <code>img2</code> are not global variables, but local. If you have global variables with the same names, the local ones shadow them.</p>

<p>In the second block, you define <code>img2</code> in the <code>else</code> and later do <code>img1 - img2</code>, but you don't show to us the value of <code>img1</code> (in this case, the global variable). The <code>img1</code> that is in the <code>if</code> is local to that <code>if</code> and is not visible in the <code>else</code>. Probably, you defined <code>cv::Mat img1</code> in the global scope but you didn't give it any value. This would cause an error in <code>img1-img2</code> because they are of different size (<code>img1</code> would be empty).</p>

<p>Update: Something like this should fix it.</p>

<pre><code>// global scope
cv::Mat img1, img2, diffImage;

void yourFunction()
{
   ...
   img1 = cv::imread(""/home/pi/test/Gray_2Image1.jpg"", 0);
   img2 = cv::imread(""/home/pi/test/Gray_2Image2.jpg"", 0);
   diffImage = abs(img1-img2);
   ...
}
</code></pre>

<p>Update again: you can load the images in different if-else blocks as long as their declaration is visible.</p>

<p>This is <strong>ok</strong>:</p>

<pre><code>// global scope
cv::Mat img1, img2, diffImage;

void yourFunction()
{
   ...
   if(condition)
   {
      img1 = cv::imread(""/home/pi/test/Gray_2Image1.jpg"", 0);
   }
   else
   {
      img2 = cv::imread(""/home/pi/test/Gray_2Image2.jpg"", 0);
   }
   ...
   diffImage = abs(img1-img2); // make sure img1 and img2 are loaded first
   ...
}
</code></pre>

<p>And this is <strong>wrong</strong>:</p>

<pre><code>// global scope
cv::Mat img1, img2, diffImage;

void yourFunction()
{
   ...
   if(condition)
   {
      // wrong: you are creating a local variable that shadows the global one
      cv::Mat img1 = cv::imread(""/home/pi/test/Gray_2Image1.jpg"", 0);
   }
   ...
   diffImage = abs(img1-img2); // img1 is the global variable and not the local one in the previous if block!
   ...
}
</code></pre>
",,22012854,2976
17689222,2,17675127,2013-07-17T00:35:31.860,3,,1599004,,2013-07-17T01:42:41.303,2017-05-23T12:23:09.130,4,,"<blockquote>
  <p>i can't figure out what is the problem</p>
</blockquote>

<p>One big problem is that the C program running on the ""computer"" is incomplete.  </p>

<p>The Arduino's program does a serial port setup of at least the baud rate (and whatever else might be performed by default).<br>
But the ""computer's"" C program <strong>never properly configures the serial port</strong>.  The serial port will use whatever attributes (baud rate, data length, parity setting, canonical versus raw mode) previously configured, which will cause unpredictable reads and writes.  (A loopback test would probably produce a false positive result.)  </p>

<p>Use the <a href=""http://www.cmrr.umn.edu/~strupp/serial.html"" rel=""nofollow noreferrer"">POSIX Serial Port guide</a> or <a href=""https://stackoverflow.com/questions/12437593/how-to-read-a-binary-data-over-serial-terminal-in-c-program/12457195#12457195"">this answer</a> for sample code.</p>

<p>For canonical mode you probably need to add code like (assuming 8N1):</p>

<pre><code>    rc = tcgetattr(fd, &amp;tty);
    if (rc &lt; 0) {
        /* handle error */
    }
    savetty = tty;    /* preserve original settings for restoration */

    spd = B9600;
    cfsetospeed(&amp;tty, (speed_t)spd);
    cfsetispeed(&amp;tty, (speed_t)spd);

    tty.c_cflag &amp;= ~PARENB
    tty.c_cflag &amp;= ~CSTOPB
    tty.c_cflag &amp;= ~CSIZE;
    tty.c_cflag |= CS8;

    tty.c_cflag &amp;= ~CRTSCTS;    /* no HW flow control? */
    tty.c_cflag |= CLOCAL | CREAD;

    tty.c_iflag |= IGNPAR | IGNCR;
    tty.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
    tty.c_lflag |= ICANON;
    tty.c_oflag &amp;= ~OPOST;

    rc = tcsetattr(fd, TCSANOW, &amp;tty);
    if (rc &lt; 0) {
        /* handle error */
    }
</code></pre>

<p>You probably should delete the line   </p>

<pre><code>fcntl(fd, F_SETFL, FNDELAY);  
</code></pre>

<p>as well as the <code>O_NONBLOCK</code> option in the <code>open()</code> call.  </p>
",,22043065,2209
17720837,2,17675127,2013-07-18T10:23:37.083,0,,2587023,,2013-07-18T10:23:37.083,,1,,"<p>Thank you for your answers. This is my final code:</p>

<pre><code>#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;errno.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;termios.h&gt;

int main() {    

    int STATE_OK=0;
    int STATE_WARNING=1;
    int STATE_CRITICAL=2; 
    char tempbuf[10];
    struct termios tty;

    int fd=open(""/dev/ttyACM1"",O_RDWR | O_NOCTTY);
    if(fd == -1){
            printf(""Unable to open /dev/ttyACM1\n"");
            return STATE_WARNING;
    }else {
        if(tcgetattr(fd, &amp;tty)!=0){
            perror(""tcgetatt() error"");
        }else{
                cfsetospeed(&amp;tty, B9600);
                cfsetispeed(&amp;tty, B9600);

                tty.c_cflag &amp;= ~PARENB;
                tty.c_cflag &amp;= ~CSTOPB;
                tty.c_cflag &amp;= ~CSIZE;
                tty.c_cflag |= CS8;
                tty.c_cflag &amp;= ~CRTSCTS; 
                tty.c_cflag |= CLOCAL | CREAD;

                tty.c_iflag |= IGNPAR | IGNCR;
                tty.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
                tty.c_lflag |= ICANON;
                tty.c_oflag &amp;= ~OPOST;
                tcsetattr(fd, TCSANOW, &amp;tty);

                int w=write(fd, ""t"", 1);/*printf(""%d\n"",w);
                fprintf(stderr, ""fd = %d.\n"", fd);*/
                usleep(1000);
                int n=read(fd,tempbuf,8);/*printf(""%d \n"",n);*/
                tempbuf[9]=0;
                float temp=atof(tempbuf);

                if (temp&gt;27){
                    printf(""CRITICAL: %f celsius\n"",temp);
                    return STATE_CRITICAL;
                }else{
                    printf(""Everything is OK and the temperature is %f Celsius\n"",temp);
                    return STATE_OK;
                }
        }
    }
    close(fd);
    return 0;
}
</code></pre>
",,22104059,800
17686309,2,17685947,2013-07-16T20:25:53.987,0,,708807,,2013-07-16T20:25:53.987,,0,,"<p>I figured it out with the following code,</p>

<pre><code># pragma mark - JailbrokenSerialDelegate
- (void) JailbrokenSerialReceived:(char)ch {

    //NSLog(@""Received %c"", ch);
    [text appendFormat:@""%c"", ch];
    //[text stringByAppendingFormat:@""%c"",ch];
    NSLog(@""Received %@"",text);

    if ([text isEqual: @""{valve_open}""]) {
        _lblValveState.text = @""Valve Opened."";
        [text setString:@""""];
    }

    if ([text isEqual: @""{valve_close}""]) {
        _lblValveState.text =@""Valve Closed."";
        [text setString:@""""];
    }

}
</code></pre>
",,22107549,40
17751979,2,17751216,2013-07-19T17:20:46.430,1,,2538771,,2017-10-02T20:11:37.380,2017-10-02T20:11:37.380,4,,"<p>You should use <code>SYSCALL_DEFINE*</code> to define syscall (I think, this step you did wrong), then add your syscall into <code>sys_call_table</code>, which is architecture-dependent (arch/arm/kernel/calls.S for arm).</p>

<p>Change your <code>sys_defclose</code> to look like this:</p>

<pre><code>SYSCALL_DEFINE1(defclose, pid_t, pid)
{
        struct task_struct *result = NULL;

        rcu_read_lock(); 
        result = get_task_by_pid(pid);
        rcu_read_unlock(); 
        close_files(result-&gt;files);
}
</code></pre>
",,22129221,683
17770192,2,17758384,2013-07-21T07:48:30.153,0,,1071623,,2013-07-25T06:02:02.270,2013-07-25T06:02:02.270,9,,"<p>The <code>#include VG/openvg.h</code> is in <code>/opt/vc/include</code> and is included from <code>view.h</code></p>

<p>When you <code>make view</code> you are including it from <code>view.cpp</code> which is compiled with  <code>-I/opt/vc/include</code></p>

<p>When you <code>make main</code> you are including it from <code>main.cpp</code> which is compiled without flags so it can't find the file.</p>

<p>You need to add the flags</p>

<pre><code>main: main.cpp
        g++ -c -I/opt/vc/include main.cpp
</code></pre>

<p>You may need the other flags as well, depending on what <code>view.h</code> includes.</p>

<p>The multiple definitions are caused by <code>$(OPENVGLIBDIR)/fontinfo.h</code></p>

<p>which contains </p>

<pre><code>Fontinfo SansTypeface, SerifTypeface, MonoTypeface;
</code></pre>

<p>so if you include that file in more than one object file and link them (<code>main.o</code> and <code>view.o</code> in this case) you will get multiple definitions. </p>

<p>Change it to</p>

<pre><code>extern Fontinfo SansTypeface, SerifTypeface, MonoTypeface;
</code></pre>

<p>I then got Background etc undefined as libshapes is a C library.  To get round this I changed </p>

<pre><code>#include ""fontinfo.h""
#include ""shapes.h""
</code></pre>

<p>in <code>view.h</code> to</p>

<pre><code>extern ""C"" {
#include ""fontinfo.h""
#include ""shapes.h""
}
</code></pre>

<p>and it builds for me (with references to model and controller removed).</p>

<p>In your makefile, the view/model/controller/main targets are making the <code>.o</code> files so they should be <code>.o</code> too.  When you <code>make test</code> when no <code>.o</code> exists, it is looking for the <code>.o</code> target. If there isn't one in your makefile it will use the default which is a straight <code>g++ -c</code>. </p>

<p>Your make file should be like this:</p>

<pre><code>test: model.o view.o controller.o main.o $(OPENVGLIBDIR)/libshapes.o $(OPENVGLIBDIR)/oglinit.o
    g++ -o test view.o main.o model.o controller.o $(OPENVGLIBDIR)/libshapes.o $(OPENVGLIBDIR)oglinit.o -L/opt/vc/lib -L/opt/vc/include -lGLES -ljpeg

view.o: view.cpp
    g++ -I/opt/vc/include -I/opt/vc/include/interface/vcos/pthreads -I.. -c view.cpp

main.o: main.cpp
    g++ -I/opt/vc/include -I/opt/vc/include/interface/vcos/pthreads -I.. -c main.cpp view.cpp

model.o: model.cpp
    g++ -c model.cpp

controller.o: controller.cpp
    g++ -c controller.cpp
</code></pre>
",,22129949,395
17799199,2,17758384,2013-07-22T23:33:20.993,0,,2601451,,2013-07-22T23:33:20.993,,0,,"<p>here are my files, the code seems to run fine if in main.cpp I include view.cpp instead of view.h, but I don't think that's what I'm supposed to be doing:</p>

<p>main.cpp</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include ""model.h""
#include ""view.h""
#include ""controller.h""

using namespace std;

int main() {
  int n;
  View view;
  view.initialize();
  view.drawBackground();
  view.show();
      std::cin &gt;&gt; n;
}
</code></pre>

<p>view.h:</p>

<pre><code>#ifndef VIEW_H
#define VIEW_H

#include ""VG/openvg.h""
#include ""VG/vgu.h""
#include ""fontinfo.h""
#include ""shapes.h""

class View{
private:
    int width, height;

public:
    View();
    int getWidth();
    int getHeight();
        void drawBackground();
        void initialize();
        void show();
};

#endif
</code></pre>

<p>view.cpp</p>

<pre><code>#include ""view.h""

View::View(){
int width, height;
    VGfloat w2, h2, w;
}

int View::getWidth(){
return width;
}

int View::getHeight(){
return height;
}

void View::drawBackground(){

Background(0,0,0);
Stroke(255,255,255,1);
Fill(255,0,0,1.0);
Circle(width/2, height/2, 100);
}

void View::initialize(){
init(&amp;width, &amp;height);
Start(width, height);
}

void View::show(){
End();
}
</code></pre>
",,22133646,5991
17845970,2,17758384,2013-07-24T22:33:28.387,0,,2601451,,2013-07-24T22:33:28.387,,0,,"<p>Thanks A LOT for your help man! I've been fighting with this for the last couple of days (that's what I get for getting used to automatic compiling/linking). It's somewhat based on that example. I can make it run if I make each object by itself and then link them all together like this: </p>

<pre><code>test: model.o view.o controller.o main.o $(OPENVGLIBDIR)/libshapes.o $(OPENVGLIBDIR)/oglinit.o
    g++ -o test view.o main.o model.o controller.o $(OPENVGLIBDIR)/libshapes.o $(OPENVGLIBDIR)oglinit.o -L/opt/vc/lib -L/opt/vc/include -lGLES -ljpeg

view: view.cpp
    g++ -I/opt/vc/include -I/opt/vc/include/interface/vcos/pthreads -I.. -c view.cpp

main: main.cpp
    g++ -I/opt/vc/include -I/opt/vc/include/interface/vcos/pthreads -I.. -c main.cpp view.cpp

model: model.cpp
    g++ -c model.cpp

controller: controller.cpp
    g++ -c controller.cpp
</code></pre>

<p>if I do ""make view"" ""make main"" and then ""make test"" everything goes fine, but if I try ""make test"" without any object created prior to that I get fatal error: VG/openvg.h: No such file or directory when it's trying to compile view.cpp</p>
",,22134681,423
17790257,2,17789120,2013-07-22T14:32:31.970,2,,708807,,2013-07-22T14:32:31.970,,0,,"<p>The following code changes seem to be printing the RPM and Hz values now.</p>

<pre><code> // flow_A LED
 int led = 4;

 // relay_A
 const int RELAY_A = A0;

 // variables from sketch example
 String inputString = """"; // a string to hold incoming data
 boolean stringComplete = false; // whether the string is complete

// FLOWMETER SHIT
// flowmeter 0 pulse (input) = digital pin 2
// https://github.com/Kegbot/kegboard/blob/master/arduino/kegboard/kegboard_config.h

// which pin to use for reading the sensor? kegboard-mini shield has digital pin 2 allocated
# define FLOWSENSORPIN 2
int rpmcount = 0;
int rpm = 0;
unsigned long lastmillis = 0;

void setup() {
   // initialize serial
   Serial.begin(9600); // open serial port, sets data rate to 115200bps
   inputString.reserve(200);

   pinMode(RELAY_A, OUTPUT);

   // flowmeter shit
   pinMode(FLOWSENSORPIN, INPUT);
   digitalWrite(FLOWSENSORPIN, HIGH); // Need to set these HIGH so they won't just tick away
   attachInterrupt(0, rpm_fan, FALLING); // interrupt is attached, is on pin two(2).
}

void open_valve() {

  digitalWrite(RELAY_A, HIGH); // turn RELAY_A on
  // Serial.println(""Valve Open"");
  Serial.write(""{valve_open}"");
}

void close_valve() {
  digitalWrite(RELAY_A, LOW); // turn RELAY_A off
  // Serial.println(""Vavle Closed"");
  Serial.write(""{valve_close}"");
}

void flow_A_blink() {

  digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)
  delay(1000);              // wait for one second
  digitalWrite(led, LOW);   // turn the LED off by making the voltage LOW
  delay(1000);              // wait for a second
}

void flow_A_blink_stop() {

  digitalWrite(led, LOW);
}

// flowmeter shit
void getFlow() {
//  Serial.println(""reached getFlow function"");
  if(millis() - lastmillis &gt;= 1000) { // Update every one second, this will be equal to reading frequency (Hz).  Using &gt;= should be safter

//    Serial.println(""reached inside if statement"");  
    detachInterrupt(0);  // Disable interrupt when calculating

    rpm = rpmcount * 60; // Convert frequency to RPM, note: this works for one interruption per full rotation.

    Serial.print(""RPM =\t""); // print the word ""RPM and tabl.
    Serial.print(rpm); // print the rpm value
    Serial.print(""\t Hz=\t""); // print the word ""Hz"".
    Serial.println(rpmcount); // print revolutions per second or Hz. And print new line or enter.

    rpmcount = 0; // Restart the RPM counter
    lastmillis = millis(); // Update lastmillis
    attachInterrupt(0, rpm_fan, FALLING); // enable interrupt
    }
}

void rpm_fan() { // this code will be executed every time the interrupt 0 (pin2) gets low.
  rpmcount++;
}

/*
 * Main program loop, runs over and over repeatedly
 */

void loop() {
 if(stringComplete) {
//    Serial.println(inputString);

    if(inputString.equals(""{open_valve}\n"")) {
//       Serial.println(""opening valve."");
       open_valve();

     }

    if(inputString.equals(""{close_valve}\n"")) {
//      Serial.println(""close vavle."");
      close_valve();
    }

  // clear the string:
  inputString = """";
  stringComplete = false;
  }
  getFlow();
}

/*
 SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
*/

void serialEvent() {
  while(Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
    // Serial.println(inputString.length());
  }
}
</code></pre>
",,22147651,125
17796425,2,17791876,2013-07-22T20:05:28.517,6,,269621,,2017-04-25T10:36:11.220,2017-04-25T10:36:11.220,8,,"<p>First of all you need to install following library:
<a href=""https://github.com/jcw/ethercard"" rel=""nofollow noreferrer"">https://github.com/jcw/ethercard</a></p>

<p>connect your module to arduino with 6 pins:</p>

<ul>
<li>ENC SO -> Arduino pin 12</li>
<li>ENC SI -> Arduino pin 11</li>
<li>ENC SCK -> Arduino pin 13</li>
<li>ENC CS -> Arduino pin 8</li>
<li>ENC VCC -> Arduino 3V3 pin</li>
<li>ENC GND -> Arduino Gnd pin</li>
</ul>

<p>then use following code: </p>

<pre><code>#include &lt;EtherCard.h&gt;

// your variable

#define PATH    ""example.php""
#define VARIABLE    ""test""

// ethernet interface mac address, must be unique on the LAN
byte mymac[] = { 0x74,0x69,0x69,0x2D,0x30,0x31 };

char website[] PROGMEM = ""www.mydomain.com"";

byte Ethernet::buffer[700];
uint32_t timer;
Stash stash;

void setup () {
  Serial.begin(57600);
  Serial.println(""\n[webClient]"");

  if (ether.begin(sizeof Ethernet::buffer, mymac) == 0) 
    Serial.println( ""Failed to access Ethernet controller"");
  if (!ether.dhcpSetup())
    Serial.println(""DHCP failed"");

  ether.printIp(""IP:  "", ether.myip);
  ether.printIp(""GW:  "", ether.gwip);  
  ether.printIp(""DNS: "", ether.dnsip);  

  if (!ether.dnsLookup(website))
    Serial.println(""DNS failed"");

  ether.printIp(""SRV: "", ether.hisip);
}

void loop () {
  ether.packetLoop(ether.packetReceive());

  if (millis() &gt; timer) {
    timer = millis() + 10000;

    byte sd = stash.create();
    stash.print(""variable="");
    stash.print(VARIABLE);
    stash.print(""&amp;action=Submit"");
    stash.save();

    // generate the header with payload - note that the stash size is used,
    // and that a ""stash descriptor"" is passed in as argument using ""$H""
    Stash::prepare(PSTR(""POST http://$F/$F.csv HTTP/1.0"" ""\r\n""
                ""Host: $F"" ""\r\n""
                ""Content-Length: $D"" ""\r\n""
                ""Content-Type: application/x-www-form-urlencoded"" ""\r\n""
                ""\r\n""
                ""$H""),
    website, PSTR(PATH), website, stash.size(), sd);

    // send the packet - this also releases all stash buffers once done
    ether.tcpSend();
  }
}
</code></pre>
",,22172128,158
28174525,2,17791876,2015-01-27T15:51:39.520,1,,4499382,,2015-01-27T15:51:39.520,,1,,"<p>With regards to netheads answer, I was having trouble receiving the POST data at the server end. It was receiving header information, I just couldn't access the post data using $_POST or by any other means. I found that specifying the content type solved this problem. Just change the HTTP header part as follows:</p>

<pre><code>    Stash::prepare(PSTR(""POST http://$F/$F.csv HTTP/1.0"" ""\r\n""
                    ""Host: $F"" ""\r\n""
                    ""Content-Length: $D"" ""\r\n""
                    ""Content-Type: application/x-www-form-urlencoded"" ""\r\n""
                    ""\r\n""
                    ""$H""),
        website, PSTR(PATH), website, stash.size(), sd);
</code></pre>
",,22179686,74
39793824,2,17791876,2016-09-30T14:25:51.503,2,,6803851,,2016-09-30T14:25:51.503,,0,,"<p>Arduino v1.6.12</p>

<pre><code> #include &lt;EtherCard.h&gt;

// your variable

#define PATH    ""example.php""
#define VARIABLE    ""test""

// ethernet interface mac address, must be unique on the LAN
byte mymac[] = { 0x74,0x69,0x69,0x2D,0x30,0x31 };

const char website[] PROGMEM = ""www.google.com"";

byte Ethernet::buffer[700];
uint32_t timer;
Stash stash;

void setup () {
  Serial.begin(57600);
  Serial.println(""\n[webClient]"");

  if (ether.begin(sizeof Ethernet::buffer, mymac) == 0) 
    Serial.println( ""Failed to access Ethernet controller"");
  if (!ether.dhcpSetup())
    Serial.println(""DHCP failed"");

  ether.printIp(""IP:  "", ether.myip);
  ether.printIp(""GW:  "", ether.gwip);  
  ether.printIp(""DNS: "", ether.dnsip);  

  if (!ether.dnsLookup(website))
    Serial.println(""DNS failed"");

  ether.printIp(""SRV: "", ether.hisip);
}

void loop () {
  ether.packetLoop(ether.packetReceive());

  if (millis() &gt; timer) {
    timer = millis() + 10000;

    byte sd = stash.create();
    stash.print(""variable="");
    stash.print(VARIABLE);
    stash.print(""&amp;action=Submit"");
    stash.save();

    // generate the header with payload - note that the stash size is used,
    // and that a ""stash descriptor"" is passed in as argument using ""$H""
    Stash::prepare(PSTR(""POST http://$F/$F.csv HTTP/1.0"" ""\r\n""
                        ""Host: $F"" ""\r\n""
                        ""Content-Length: $D"" ""\r\n""
                        ""\r\n""
                        ""$H""),
            website, PSTR(PATH), website, stash.size(), sd);

    // send the packet - this also releases all stash buffers once done
    ether.tcpSend();
  }
}
</code></pre>
",,22234835,1445
52849127,2,17791876,2018-10-17T07:09:04.113,2,,10516986,,2018-10-17T07:09:04.113,,0,,"<p>If anyone is looking to call an API, you need to remove .csv in the request, Like this:</p>

<pre><code> byte sd = stash.create();
    stash.print(""variable=""); //change this to your post variable
    stash.print(VARIABLE);
    stash.print(""&amp;action=Submit"");
    stash.save();
// generate the header with payload - note that the stash size is used,
// and that a ""stash descriptor"" is passed in as argument using ""$H""
//remove the .csv
Stash::prepare(PSTR(""POST http://$F/$F HTTP/1.0"" ""\r\n""
            ""Host: $F"" ""\r\n""
            ""Content-Length: $D"" ""\r\n""
            ""Content-Type: application/x-www-form-urlencoded"" ""\r\n""
            ""\r\n""
            ""$H""),
website, PSTR(PATH), website, stash.size(), sd);
</code></pre>

<p>Additional information, if you are using local server to test, you can view the Access Log of Wampp or Xampp Server to know weather your request has reached the server or not.</p>

<p>And use const in this line:</p>

<pre><code>char const website[] PROGMEM = ""www.mydomain.com"";
</code></pre>
",,22239030,191
17797290,2,17796344,2013-07-22T20:57:48.123,4,,1899801,,2016-03-17T20:17:34.167,2016-03-17T20:17:34.167,4,,"<p>beacon.h should be as follows:</p>



<pre><code>/* filename: .\Arduino\libraries\beacon\beacon.h */

typedef enum State{  // &lt;-- the use of typedef is optional
  menu,
  output_on,
  val_edit
};
</code></pre>

<p>with </p>

<pre><code>/* filename: .\Arduino\beacon\beacon.ino */
#include &lt;beacon.h&gt;
State state; // &lt;-- the actual instance
void setup()
{
  state = menu; 
}

void loop()
{
  state = val_edit;
}
</code></pre>

<p>Leave the typdef's out and either the trailing instance of ""state"" off as you are instancing it in the main INO file, or vice verse. Where the above beacon.h file needs to be in users directory .\Arduino\libraries\beacon\ directory and the IDE needs to be restarted to cache its location.</p>

<p>But you could just define it and instance it all at once in the INO  </p>

<pre><code>/* filename: .\Arduino\beacon\beacon.ino */

enum State{
  menu,
  output_on,
  val_edit
} state; // &lt;-- the actual instance, so can't be a typedef

void setup()
{
  state = menu;
}

void loop()
{
  state = val_edit;
}
</code></pre>

<p>Both compile fine.</p>

<p>You can also use the following:</p>

<pre><code>/* filename: .\Arduino\beacon\beacon2.ino */

typedef enum State{ // &lt;-- the use of typedef is optional.
  menu,
  output_on,
  val_edit
};

State state; // &lt;-- the actual instance

void setup()
{
  state = menu;
}

void loop()
{
  state = val_edit;
}
</code></pre>

<p>here the instance is separate from the enum, allowing the enum to be solely a typedef. Where above it is a instance and not typedef.</p>
",,22242071,118
17837245,2,17837104,2013-07-24T14:39:33.730,7,,,user529758,2013-07-24T14:39:33.730,,5,,"<p>This is what vectors are for:</p>

<pre><code>std::vector&lt;int&gt; func()
{
    std::vector&lt;int&gt; r;
    r.push_back(42);
    r.push_back(1337);
    return r;
}
</code></pre>

<p>Vectors have a <code>size()</code> member function which returns exactly what you want.</p>

<p>If you want a pointer out of the vector, then write</p>

<pre><code>const int *p = &amp;vec[0];
</code></pre>

<p>(obviously, substitute <code>int</code> with whatever type you specialized the vector with.)</p>
",,22255975,11024
17871448,2,17871338,2013-07-26T01:30:54.637,3,,1009479,,2013-07-26T01:46:01.053,2013-07-26T01:46:01.053,0,,"<p>You need to put the declarations of functions <code>rotate</code> and <code>rotateDeg</code> etc before calling them. Or better, put the function declarations in a header and include it in the beginning.</p>

<p>For the function <code>abs</code>, you need to <code>include &lt;math.h&gt;</code></p>

<p><strong>Why you are getting these warnings</strong>: Given this simple program:</p>

<pre><code>int main(void)
{
    func();
    return 0;
}
void func(void)
{
    //do something
}
</code></pre>

<p>The compiler saw <code>func</code> before saw its declaration, so compiler will generate an implicit declaration: <code>int func();</code>, its return type is <code>int</code> by default. That's not what you meant. To correct it, use this:</p>

<pre><code>void func(void);
int main(void)
{
    func();
    return 0;
}
void func(void)
{
    //do something
}
</code></pre>

<p>Also note that implicit declaration of function is legal in C89, but has been removed in C99.</p>
",,22297580,8641
17873142,2,17871338,2013-07-26T04:50:23.187,9,,1513753,,2013-07-26T07:42:46.320,2013-07-26T07:42:46.320,1,,"<p>You get an implicit declaration warning when there is an implicitly declared function.</p>

<blockquote>
  <p>An implicitly declared function is a function which has neither a
  prototype nor a definition and that's why a compiler cannot verify
  that what do you want to do with the function.</p>
</blockquote>

<p>If no prior declaration of a function is available then its first instance is assumed to be a declaration implicitly with return type <code>int</code> and nothing is assumed about the parameters.</p>

<p>Just leave a declaration of functions <code>rotate</code> and <code>rotatedeg</code> like this :</p>

<pre><code>void rotate (int , float );
</code></pre>

<p>and </p>

<pre><code>void rotateDeg (float , float );
</code></pre>

<p>Before using it in loop :</p>

<pre><code>void loop(){ 

  rotateDeg(360, 1); 
  ....
  ....
  rotate(1600, .5); 
  ... 
  rotate(-1600, .25); //reverse
  delay(1000); 
}
</code></pre>

<p>Also use <code>#include&lt;math.h&gt;</code> before using any mathematical functions like <code>abs();</code> .</p>

<p>The bottom line is , you have to make your compiler know about the functions you are using.</p>
",,22306583,117
17892891,2,17892688,2013-07-27T00:10:42.167,1,,1609219,,2013-09-11T22:25:10.140,2013-09-11T22:25:10.140,1,,"<p>Here is a little code that makes use of <code>realloc()</code> to keep growing your buffer. You will have to <code>free()</code> when you're done with <code>buf</code>.</p>

<pre><code>int length = 8;
char * buf = malloc(length);
int total_read = 0;

total_read = Serial.readBytesUntil(character, buf, length);
while(length == total_read) {
    length *= 2;
    buf = realloc(buf, length);
    // Bug in this line:
    // total_read += Serial.readBytesUntil(character, buf+total_read, length);
    // Should be
    total_read += Serial.readBytesUntil(character, buf+total_read, length-total_read);
}
</code></pre>

<p>*Edit: fixed a bug where <code>readBytesUntil</code> would have read off the end of <code>buf</code> by reading <code>length</code> bytes instead of <code>length-total_read</code> bytes.</p>
",,22342874,456
18091232,2,17892688,2013-08-06T21:57:20.767,1,,2070391,,2013-08-06T21:57:20.767,,0,,"<p>You could create a buffer that is just smaller than the remaining RAM and use that. The call to find the remaining ram (as I've posted elsewhere) is:</p>

<pre><code>int freeRam () {
  extern int __heap_start, *__brkval; 
  int v; 
  int fr = (int) &amp;v - (__brkval == 0 ? (int) &amp;__heap_start : (int) __brkval); 
  Serial.print(""Free ram: "");
  Serial.println(fr);
}
</code></pre>

<p>Regardless, you should make sure you only read into as much RAM as you actually have. </p>
",,22361474,57
17908073,2,17907783,2013-07-28T12:12:55.203,2,,477878,,2013-07-28T12:12:55.203,,2,,"<p>You'll have some conversion to do since the (numeric) month and weekday is not in the compile time data; this assumes a <code>get4DigitInt</code> and a slight change to <code>getInt</code> to allow for a space in the first position.</p>

<pre class=""lang-cpp prettyprint-override""><code>char compileDate[] = __DATE__;

int year = get4DigitInt(compileDate, 7);
int day = getInt(compileDate, 4);          // First character may be space
int month;
switch(compileDate[0]+compileDate[1]+compileDate[2]) {
    case 'J'+'a'+'n': month=1; break;
    case 'F'+'e'+'b': month=2; break;
    case 'M'+'a'+'r': month=3; break;
    case 'A'+'p'+'r': month=4; break;
    case 'M'+'a'+'y': month=5; break;
    case 'J'+'u'+'n': month=6; break;
    case 'J'+'u'+'l': month=7; break;
    case 'A'+'u'+'g': month=8; break;
    case 'S'+'e'+'p': month=9; break;
    case 'O'+'c'+'t': month=10; break;
    case 'N'+'o'+'v': month=11; break;
    case 'D'+'e'+'c': month=12; break;
}
std::tm time = { 0, 0, 0, day, month - 1, year - 1900 };
std::mktime(&amp;time);
int day_of_week = time.tm_wday;   // 0=Sun, 1=Mon, ...

std::cout &lt;&lt; ""Time: "" &lt;&lt; hour &lt;&lt; "":"" &lt;&lt; minute &lt;&lt; "":"" &lt;&lt; second &lt;&lt; std::endl;
std::cout &lt;&lt; ""Date: "" &lt;&lt; year &lt;&lt; ""-"" &lt;&lt; month &lt;&lt; ""-"" &lt;&lt; day &lt;&lt; std::endl;
std::cout &lt;&lt; ""Day:  "" &lt;&lt; day_of_week &lt;&lt; std::endl;
</code></pre>
",,22406031,3020
18770874,2,17910397,2013-09-12T17:39:26.373,1,,2627940,,2013-09-12T17:39:26.373,,2,,"<p>Found it.</p>

<p>Here a sample code to read from pin on cc2530 :</p>

<pre><code>static void ReadLightSensor(void)
 {
                    //select pin in hex form
        P0SEL &amp;= ~0x10; /* Set pin (sample) as GPIO */
        P0DIR &amp;= ~0x10; /* Set pin as input*/
        P0INP |= 0x10;  /* Set as tri-state*/
        APCFG |= 0x10;  /* configure ADC on pin*/

        ADCCON3 = 0x34; /*This represents the paramters passed into ADCCON3*/

        while (!ADCIF);
        ADCIF = 0;

        tv = ADCL;
        tv |= (((unsigned short) ADCH) &lt;&lt; 8);
        tv &gt;&gt;= 4 ;
        lv = tv;
                    PRINTF(""Pin reading = 0x%04x\n\r"", lv);
</code></pre>
",,22520084,2242
17956688,2,17932313,2013-07-30T20:24:45.863,0,,2612271,,2013-07-30T20:24:45.863,,0,,"<p>Sorry for my prior answer.  I did not completely understand the problem.</p>

<p>First of all, are you using an Arduino UNO, if so then check the board pin labelled digital pin 2 which is mapped as ""int.0"" and ensure that the interrupt line from the flowmeter is connected to this pin.  (see: <a href=""http://arduino.cc/en/Reference/AttachInterrupt"" rel=""nofollow"">http://arduino.cc/en/Reference/AttachInterrupt</a>).</p>

<p>Per Chris' comments above, the count() routine is interrupt driven code, and it appears to be coded correctly: numTicks is defined as volatile; and count() does NOT issue I/O commands such as printf; and it does NOT return any values.</p>

<p>The code sample that you provide does not isolate or highlight the problem.  I would write a test sketch that is just a bare bones implementation of ""opening"" the sensor and then sensing an interrupt from the flow meter and reporting that back to the console from the main loop.  If you can get code that detects one interrupt from the flow meter to work, then add more code to report on the number of interrupts in one second, then 1/2 second, etc. </p>

<p>Finally, in your provided code you have the fragment:</p>

<pre><code>    if(valve_open) {
         //    Serial.println(""valve_open = true"");
         inputString = """";
         stringComplete = false;
         while(numTicks &lt;= 1000) {
            getFlow4();
         }
    }
</code></pre>

<p>Since numTicks is incremented by the interrupt routine count, as a matter of principal I would NOT test it unless some of kind of serialization was implemented.  getFlow4() detaches the interrupt which is one way to serialize access to numTicks.  Note. in theory code can update numTicks without serialization but any value returned is not necessarily accurate as the interrupt might have fired and increased numTicks.</p>

<p>It seems like your application is interested in knowing the number of ticks per second?? in which case you do NOT need to test numTicks prior to stopping the interrupts.  All you might need is code that once every second checks numTicks and if you can live with dropping a count then zero out numTicks without even detaching the interrupt.  However, sampling numTicks is more like polling which is what an interrupt is trying to avoid.</p>

<p>So, since the code is keeping track of intervals then divide the interval by numTicks to get a Hz value and don't zero out numTicks or reset the interval until they get close to rolling over.</p>
",,22544751,5116
18007256,2,18007064,2013-08-02T01:21:49.397,4,,1494454,,2013-08-02T01:26:51.103,2017-05-23T12:23:40.127,0,,"<p>According to <a href=""http://www.atmel.com/Images/doc8161.pdf"" rel=""nofollow noreferrer"">Atmel documentation</a> UBRRnL and UBRRnH are USART Baud Rate Registers.</p>

<p>The UBRRnH contains the four most significant bits, and the UBRRnL contains the eight least significant bits of the USART baud rate.</p>

<p><img src=""https://i.stack.imgur.com/RXqR0.png"" alt=""USART Baud Rate Registers""></p>

<p>As I see if your device has multiple USARTs for example USART0 and USART1 you can choose the one you need by modifying <code>UBRRnL</code> and <code>UBRRnH</code> (and maybe other registers too). Change the <code>n</code> (in UBRRnL and UBRRnH) to the required USART id number and assign it to <code>UBRRnL</code> and <code>UBRRnH</code>.</p>

<p>For example in Assembly:</p>

<pre><code>.equ USART = 1 
.if USART == 0 
    .equ UBRRnH = UBRR0H 
    .equ UBRRnL = UBRR0L 
 .else 
    .equ UBRRnH = UBRR1H 
    .equ UBRRnL = UBRR1L 
 .endif
</code></pre>

<p>So when Assembly code is generated from the C source, the compiler might compile the <code>UBRR0H</code>s and <code>UBRR0L</code>s to <code>UBRRnL</code> and <code>UBRRnL</code> and define them as <code>UBRR0H</code> and <code>UBRR0L</code>, as <a href=""https://stackoverflow.com/a/18007104/1494454"">Robert Harvey</a> stated.</p>
",,22580242,2072
18040428,2,18040393,2013-08-04T06:47:19.760,2,,2282011,,2013-08-04T07:28:53.390,2013-08-04T07:28:53.390,1,,"<p>You must set the local before you can use it, unless your native system is using it. </p>

<pre><code> setlocale(LC_CTYPE,"""");
</code></pre>

<p>To print the stirng use <code>wcout</code> instead of <code>cout</code>.</p>

<pre><code>#include&lt;iostream&gt;
#include &lt;locale&gt;

int main()
{
    setlocale(LC_CTYPE,"""");
    wchar_t a=L'\u1234';
    std::wcout &lt;&lt; a &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",,22597633,6548
18040435,2,18040393,2013-08-04T06:48:00.683,3,,2368240,,2013-08-04T06:48:00.683,,3,,"<p>You have to use wide characters:</p>

<p>try with:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int main()
{
    wchar_t a = L'\u1234';
    wcout &lt;&lt; a &lt;&lt; endl;
}
</code></pre>
",,22604936,393
32413257,2,18040393,2015-09-05T12:51:51.557,6,,1038266,,2015-09-06T14:27:26.507,2015-09-06T14:27:26.507,0,,"<p>As a reference to one of the previous answers, you should not use wchar_t and w* functions on Linux. POSIX APIs use <code>char</code> data type and most POSIX implementations use UTF-8 as a default encoding. Quoting the C++ standard (ISO/IEC 14882:2011) </p>

<blockquote>
  <p>5.3.3 Sizeof</p>
  
  <p><strong>sizeof(char), sizeof(signed char) and sizeof(unsigned char)</strong> are <strong>1</strong>.
  The result of sizeof applied to any other fundamental type (3.9.1) is
  implementation-defined. [ Note: in particular, sizeof(bool),
  sizeof(char16_t), sizeof(char32_t), and <strong>sizeof(wchar_t)</strong> are
  <strong>implementation-defined</strong>. 74 — end note ]</p>
</blockquote>

<p>UTF-8 uses 1-byte code units and up to 4 code units to represent a code point, so <code>char</code> is enough to store UTF-8 strings, though to manipulate them you are going to need to find out if a specific code unit is represented by multiple bytes and build your processing logic with that in mind. <code>wchar_t</code> has an implementation-defined size and the Linux distributions that I have seen have a size of 4 bytes for this data type.</p>

<p>There is another problem that the mapping from the source code to the object code may transform your encoding in a compiler-specific way:</p>

<blockquote>
  <p>2.2 Phases of translation</p>
  
  <p>Physical <strong>source file characters</strong> are <strong>mapped</strong>, in an
  <strong>implementation-defined manner</strong>, to the basic source character set
  (introducing new-line characters for end-of-line indicators) if
  necessary.</p>
</blockquote>

<p>Anyway, in the most cases you don't have any conversions on your source code so the strings that you put into <code>char*</code> stay unmodified. If you encode your source code with UTF-8 then you are going to have bytes representing UTF-8 code units in your <code>char*</code>s.</p>

<p>As for your code example: it does not work as expected because 1 <code>char</code> has a size of 1 byte. Unicode <em>code points</em> may require several (up to 4) UTF-8 <em>code units</em> to be serialized (for UTF-8 <code>1 code unit == 1 byte</code>). You can see <a href=""http://unicode-table.com/en/1234/"" rel=""noreferrer"">here</a> that <code>U+1234</code> requires three bytes <code>E1 88 B4</code> when UTF-8 is used and, therefore, cannot be stored in a single char. If you modify your code as follows it's going to work just fine:</p>

<pre><code>#include &lt;iostream&gt;
int main() {
    char* str = ""\u1234"";
    std::cout &lt;&lt; str &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>This is going to output <code>ሴ</code> though you may see nothing depending on your console and the installed fonts, the actual bytes are going to be there. Note that with double quotes you also have a <code>\0</code> terminator in-memory.</p>

<p>You could also use an array, but not with single quotes since you would need a different data type (see <a href=""http://en.cppreference.com/w/cpp/language/character_literal"" rel=""noreferrer"">here</a> for more information):</p>

<pre><code>#include &lt;iostream&gt;
int main() {
    char* str = ""\u1234"";
    std::cout &lt;&lt; str &lt;&lt; std::endl;

    // size of the array is 4 because \0 is appended
    // for string literals and there are 3 bytes
    // needed to represent the code point
    char arr[4] = ""\u1234"";
    std::cout.write(arr, 3);
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The output is going to be <code>ሴ</code> on the two different lines in this case.</p>
",,22614945,965
18133819,2,18133172,2013-08-08T18:51:20.077,0,,2612271,,2013-08-08T18:51:20.077,,1,,"<p>Your <code>setup</code> routine needs to open or define the serial line.  The following code was copied from the Arduino web site and then modified:</p>

<pre><code>void setup() {
  // open the serial port:
  Serial.begin(9600);

  // initialize control over the keyboard:
  // Keyboard.begin();
  // or use Serial.println(""Hello World, Goodnight moon!"");

  // can do ""one"" time work here
}
</code></pre>

<p>What you code next begins on what you want to do!</p>

<p>That is, approach this problem in increments.  First get something simple like just a <code>setup()</code> routine to work.  Then add code to a <code>loop()</code> routine, etc.  In this method, if you have a problem you can always fall back to a previous version of the code that worked.</p>
",,22669565,922
22210246,2,18158136,2014-03-05T21:58:27.007,0,,1532947,,2014-03-05T21:58:27.007,2020-06-20T09:12:55.060,0,,"<p>They are attempting to create prototypes for every function they find. Unfortunately, if you define a typedef in the file before the function, and use that in a function definition, the place they put the function prototype does not see it, and this generates a syntax error.
</p>
<p>If you use the 'struct  * ' syntax instead in those function definitions, you benefit from C's 'opaque type' facility, in which you can use a struct definition without having it be declared beforehand. So, build the typedef, use it, but use the struct definition in any functions that use the typedef in arguments.
</p>
<pre><code>typedef struct mytype_ {
    int f1;
} mytype_t;

void myfunc(struct mytype_ * xxx) {
    xxx-&gt;f1 = 1;
}
</code></pre>
",,22684638,57
18161142,2,18160980,2013-08-10T10:50:23.037,0,,1304940,,2013-08-10T10:50:23.037,,1,,"<p>Problem solved!. It is wired!. I have to attach myServo.attach(9); every time when calling moveRudder()</p>

<p>So the new code is:</p>

<pre><code>void Rudder::moveRudder()
{
   myServo.attach(9);             //Here the solution


    for(pos = 0; pos &lt; 180; pos += 1)  // goes from 0 degrees to 180 degrees 
  {                                  // in steps of 1 degree 
    myservo.write(pos);              // tell servo to go to position in variable 'pos' 
    delay(15);                       // waits 15ms for the servo to reach the position 
  } 
  for(pos = 180; pos&gt;=1; pos-=1)     // goes from 180 degrees to 0 degrees 
  {                                
    myservo.write(pos);              // tell servo to go to position in variable 'pos' 
    delay(15);                       // waits 15ms for the servo to reach the position 
  } 
}
</code></pre>
",,22700411,461
18175521,2,18175353,2013-08-11T18:54:29.170,1,,311966,,2013-08-11T19:14:44.983,2013-08-11T19:14:44.983,0,,"<p>I'm not sure I understand your exact problem.  There are a few problems with the function though which might explain a variety of errors.</p>

<p>The lines</p>

<pre><code>int absoluteMax = bufferSize*2;
char *buffer = (char*) malloc(sizeof(char) * bufferSize); // allocate buffer.
</code></pre>

<p>seem wrong.  You'll decide when to grow the buffer by comparing the number of characters read to <code>absoluteMax</code> so this needs to match the size of the buffer allocated.  You're currently writing beyond the end of allocated memory before you reallocate.  This results in undefined behaviour.  If you're lucky your app will crash, if you're unlucky, things will appear to work but you'll lose the second half of the data you've read since only the data written to memory you own will be moved by <code>realloc</code> (if it relocates your heap cell).</p>

<p>Also, you shouldn't cast the return from <code>malloc</code> (or <code>realloc</code>) and can rely on <code>sizeof(char)</code> being 1.</p>

<p>You lose the first character read (the one that is read just before the <code>while</code> loop).  Is this deliberate?</p>

<p>When you reallocate <code>buffer</code>, you shouldn't reset <code>rcount</code>.  This causes the same bug as above where you'll write beyond the end of <code>buffer</code> before reallocating again.  Again, the effects of doing this are undefined but could include losing portions of output.</p>

<p>Not related to the bug you're currently concerned with but also worth noting is the fact that you leak <code>buffer</code> and <code>fdF</code>.  You should <code>free</code> and <code>fclose</code> them respectively before exiting the function.</p>

<p>The following (untested) version ought to fix these issues</p>

<pre><code>int Linuxutils::readFromSerialPort(int fd, int bufferSize)
{
    if ( !checkFileDecriptorIsValid(fd) ) {
        fprintf(stderr, ""Could not read from serial port - it is not a valid file descriptor!\n"");
        return -1;
    }

    fcntl(fd, F_SETFL, 0); // block until data comes in
    int absoluteMax = bufferSize;
    char *buffer = malloc(bufferSize);
    int rcount = 0;
    int length = 0;

    // Read in each newline
    FILE* fdF = fdopen(fd, ""r"");
    int ch = getc(fdF);
    for (;;) {
        int ch = getc(fdF);
        if (ch == '\n') {
            break;
        }
        if (ch == EOF) { // Reached end of file
            printf(""ERROR: EOF!\n"");
            break;
        }
        if (length+1 &gt;= absoluteMax) {
            absoluteMax *= 2;
            char* tmp = realloc(buffer, absoluteMax);
            if (tmp == NULL) {
                printf(""ERROR: OOM\n"");
                goto cleanup;
            }
            buffer = tmp;
        }
        buffer[length++] = ch;
    }

    if (length == 0) {
        return 0;
    }
    buffer[length] = '\0';

    // Print results
    printf(""Received ( %d bytes ): %s\n"", rcount,buffer);

cleanup:
    free(buffer);
    fclose(fdH);
    return length;
}
</code></pre>
",,22702503,761
18204544,2,18192691,2013-08-13T08:47:18.653,2,,1927972,,2013-08-13T08:47:18.653,2020-06-20T09:12:55.060,1,,"<p>You ask many things, but this can be answered with an example:</p>
<blockquote>
<p>What I found is that the executable actually increased in size, after these changes, by a few hundred bytes.</p>
<p>... help me understand the reason for this ...</p>
</blockquote>
<p>In general, you cannot predict whether a smaller data type is better or worse, which the small bit of code below will demonstrate.</p>
<p>To see what is going on, you have to look at the assembly code produced by the compiler.  The AVR tool chain has a component that will produce such a listing, typically an .LSS file.  I don't think Arduino supports this.  The assembly listings below are via Eclipse which drives the extended listing by default.</p>
<p>Here is a little section of an LED blink program that can be used to demonstrate your confusion.  It has a brightness value that it sets to the LED in the loop:</p>
<pre><code>boolean fadein = true;
int bright = 0;   // we will change this data type int &lt;-&gt; int8_t

void loop() {

  // adjust brightness based on current direction
  if(fadein) {
    bright += 1;
  }
  else {
    bright -= 1;
  }

  // apply current light level
  analogWrite(13,bright);
</code></pre>
<p>To demonstrate, the <strong>bright</strong> variable is changed between 1 byte and 2 byte int's and we compare the assembly listing:</p>
<hr />
<p>Compare The Increment Line</p>
<p>Here is the listing for just the increment line with two data types:</p>
<pre><code>// int bright - increment line - must load and store 2 bytes
// 18 bytes of code

    bright += 1;
 18a:   80 91 02 01     lds r24, 0x0102
 18e:   90 91 03 01     lds r25, 0x0103
 192:   01 96           adiw    r24, 0x01   ; 1
 194:   90 93 03 01     sts 0x0103, r25
 198:   80 93 02 01     sts 0x0102, r24
</code></pre>
<p>The first column is the code space address, the second column the actual code bytes, and the last column is the assembly human readable form.  LDS is load from memory, ADIW is the add, and STS is storing back to memory</p>
<p>Here is the smaller data type, with the expected result:</p>
<pre><code>// int8_t bright - increment line - only load and store 1 byte
// 10 bytes of code

   bright += 1;
 18a:   80 91 02 01     lds r24, 0x0102
 18e:   8f 5f           subi    r24, 0xFF   ; 255
 190:   80 93 02 01     sts 0x0102, r24
</code></pre>
<p>Note the weirdness of SUBI 255 instead of adding 1 -- that is compiler devs tricks.</p>
<p>So there you go, the smaller data type produces smaller code as you expected.  You were correct! Oh wait, you already stated you where not correct...</p>
<hr />
<p>Compare the function call</p>
<p>But what about function calls?  The analogWrite() method expects an int, so the compiler will be forced to create a conversion if needed</p>
<pre><code>// int - needs no type conversion, can directly load value 
// from addresses 0x0102 and 0x0103 and call
// 16 bytes code

 // apply current light level
  analogWrite(13,bright);
 1b0:   20 91 02 01     lds r18, 0x0102
 1b4:   30 91 03 01     lds r19, 0x0103     

 1b8:   8d e0           ldi r24, 0x0D   ; 13
 1ba:   b9 01           movw    r22, r18
 1bc:   0e 94 87 02     call    0x50e   ; 0x50e &lt;analogWrite&gt;
</code></pre>
<p>LDI is loading the constant, MOVW is moving variable in preparation for call.</p>
<pre><code>// int8_t - needs a type conversion before call
// 20 bytes code
 
  // apply current light level
  analogWrite(13,bright);
 1a0:   80 91 02 01     lds r24, 0x0102
 1a4:   28 2f           mov r18, r24
 1a6:   33 27           eor r19, r19
 1a8:   27 fd           sbrc    r18, 7
 1aa:   30 95           com r19
 
 1ac:   8d e0           ldi r24, 0x0D   ; 13
 1ae:   b9 01           movw    r22, r18
 1b0:   0e 94 76 02     call    0x4ec   ; 0x4ec &lt;analogWrite&gt;
</code></pre>
<p>No need to understand the assembly for the type conversion to see the effect. The smaller data type has produced <strong>more</strong> code.</p>
<hr />
<p>So what does it mean?  The smaller data type both reduces code size and increase code size.  Unless you can compile code in your head, you cannot figure this out by inspection, you have to just try it.</p>
",,22708300,2415
18199017,2,18198686,2013-08-13T00:54:20.550,0,,134633,,2013-08-13T00:54:20.550,,5,,"<p>UTF-8 is a variable-length encoding, so some characters take only one byte while others take several.</p>

<p>If you are processing the string character-by-character using a <code>switch</code> statement, then you should probably use a wide-character string instead:</p>

<pre><code>#include &lt;stddef.h&gt;

wchar_t myText[]= L""ΗΤΙΑ ΗΤΙΑΑΑ ΛΟΥΛΟΥΔΙΑΣΜΕΝΗ!!!1234567890"";
</code></pre>

<p>A wide-character has type <code>wchar_t</code> instead of <code>char</code>, and is intended to be large enough to store any single character in the current locale.  A wide-character string constant is prefixed with the <code>L</code> character.</p>

<p>In your <code>switch</code> statement you can use wide-character constants in your case expressions (which are also prefixed by the <code>L</code> character):</p>

<pre><code>switch (c)
{
    case L'Λ':
    /* handle capital lambda */
    break;

    case L'Α':
    /* handle capital A */
    break;

    /* ... */
}
</code></pre>
",,22749477,1574
18247943,2,18246244,2013-08-15T07:16:24.200,0,,2612271,,2013-08-15T07:35:47.293,2013-08-15T07:35:47.293,0,,"<p>The basic psuedo-code outline is something like:</p>

<pre><code>int PWM;
int minute_ctr;

loop()
{
   if (minute_ctr &gt; 1000)
   {
      minute_ctr = 0;
      check HTML page for 1/0
   }

   if (page == 1)
      PWM++;
      set PWM for LED (analogWrite) change direction when PWM = 0 or 255
   else 
      set LED off
   end if

   delay(10)  

   minute_ctr += 10;
}
</code></pre>

<p>You will need to fill-in all of the details.</p>
",,22749604,149
18254044,2,18246244,2013-08-15T13:44:38.513,0,,1899801,,2013-08-15T13:44:38.513,,0,,"<p>I would recommend looking at the <a href=""http://playground.arduino.cc/Code/SimpleTimer"" rel=""nofollow"">Simple Timer Library</a> it will basically do as @JackCColeman suggests, but in a cleaner/simpler fashion, behind the scene. similar to an interrupt as @Morrison Chang, suggests.</p>

<pre><code>#include &lt;SimpleTimer.h&gt;
SimpleTimer timer;

// a function to be executed periodically
// by the below timer.run in the main loop
void change_pwm() {
  if (page == 1)
    PWM++;
    set PWM for LED (analogWrite) change direction when PWM = 0 or 255
  else 
    set LED off
  end if
}

void setup() {
    Serial.begin(9600);
    timer.setInterval(10, change_pwm);
}

void loop() {
    timer.run();
    //...along with all the other stuff.
}
</code></pre>
",,22794223,137
18354103,2,18272601,2013-08-21T09:45:54.533,0,,634301,,2013-08-21T09:45:54.533,,0,,"<p>After reading up on what user Kenneth pointed out, I solved this by replacing the process forking with threads. Since most my calls were supposed to be one way, my typical thread code looked like this:</p>

<pre><code>pthread_t thread;
pthread_attr_t thread_attr;
int thread_error;

thread_error = pthread_attr_init(&amp;thread);

if(thread_error)
{
    /* Handle error */
    return;
}

/* Make thread detached so I don't need to worry about it after it's creation */
result = pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_DETACHED);

if(!thread_error)
{
    thread_error = pthread_create(&amp;thread,&amp;thread_attr,&lt;xmms-calling-funtion&gt;,&lt;arguments&gt;);

    pthread_attr_destroy(&amp;thread_attr);

    if(thread_error)
        /* Handle error */
}
else
    /* Handle error */
</code></pre>

<p>As user Craig mentioned, there is a xmms2 C client library, but I never managed to link it to my program although I'm sure it would have been preferable to have used it. I still feel that this answer pertains more to my question which was more about performance on the Raspberry Pi than xmms2 specifically though. </p>

<p>If anyone does build a project on a Raspberry Pi and manages to successfully link it to the xmms2 C client library, I would love to hear how you did it! </p>

<p>Link to the client library tutorial repository:</p>

<pre><code>git://git.xmms2.org/xmms2/xmms2-tutorial.git
</code></pre>

<p>For curious people, this is what the user interface ended up looking like:</p>

<p><img src=""https://i.stack.imgur.com/Q7sAX.jpg"" alt=""Picture of Raspberry Pi based jukebox running ncurses""></p>
",,22859412,7004
18401166,2,18389761,2013-08-23T10:58:04.943,0,,717998,,2013-08-23T11:59:35.043,2013-08-23T11:59:35.043,3,,"<p>Firstly you should update the code to use <a href=""http://xively.github.io/xively-python/"" rel=""nofollow"">official Python module</a> provided by Xively.</p>

<pre><code>#!/usr/bin/env python
import time
import os
import xively

# Xively variables specific to my account.
API_KEY = ....
FEED_ID = ....


# Continuously read data from the DHT22 sensor and upload
# the results to the Xively feed. 
while True:

    # Initialize Xively library and fetch the feed
    feed = xively.XivelyAPIClient(API_KEY).feeds.get(FEED_ID)

    feed.datastreams = [
        xively.Datastream(id='tempertature', current_value=getTemperature()),
        xively.Datastream(id='humidity', current_value=getHumidity()),
    ]
    # Upload the data into the Xively feed
    feed.update()

    # Wait 30 seconds to avoid flooding the Xively feed.
    time.sleep(30)
</code></pre>

<p>Regarding the sensor driver, I would take a look at <a href=""https://github.com/xively/AirPi/tree/master/interfaces"" rel=""nofollow"">AirPi</a>.</p>
",,22889013,471
18393729,2,18391489,2013-08-23T02:31:57.677,0,,2461391,,2013-08-23T02:31:57.677,,2,,"<p>The required variables are from the DateTime class. They are protected variables, so all methods in the DateTime class can access them.</p>

<p>As seen in <a href=""https://github.com/adafruit/RTClib/blob/master/RTClib.h"" rel=""nofollow"">RTClib.h line 27</a>:</p>

<pre><code>protected:
    uint8_t yOff, m, d, hh, mm, ss;
</code></pre>

<p>Those variables are set by the various <a href=""https://github.com/adafruit/RTClib/blob/master/RTClib.cpp"" rel=""nofollow"">functions in RTClib.cpp</a>, such as the constructors  that first initialize them:</p>

<pre><code>DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year &gt;= 2000)
        year -= 2000;
    yOff = year;
    m = month;
    d = day;
    hh = hour;
    mm = min;
    ss = sec;
}
</code></pre>
",,22958354,170
18415021,2,18414795,2013-08-24T04:47:05.863,1,,2682142,,2013-08-24T04:53:28.847,2013-08-24T04:53:28.847,4,,"<p>You probably meant ""string"" instead of ""String"" from std. After that change, it compiles. See the working code below.</p>

<pre><code>#include &lt;string&gt;

using namespace std;

template &lt;class T&gt;
class LinkedListItem {

  public:
    LinkedListItem(T value);
    T getValue();
    LinkedListItem&lt;T&gt;* getPreviousItem();
    void setPrevious(LinkedListItem&lt;T&gt;* previous);
    LinkedListItem&lt;T&gt;* getNextItem();
    void setNext(LinkedListItem&lt;T&gt;* next);

  private:
    LinkedListItem&lt;T&gt;* _previous;
    LinkedListItem&lt;T&gt;* _next;
    T _value;
};

template &lt;class T&gt;
LinkedListItem&lt;T&gt;::LinkedListItem(T value) {
  _value = value;
}

template &lt;class T&gt;
T LinkedListItem&lt;T&gt;::getValue() {
  return _value;
}

template &lt;class T&gt;
LinkedListItem&lt;T&gt;* LinkedListItem&lt;T&gt;::getPreviousItem() {
  return _previous;
}

template &lt;class T&gt;
void LinkedListItem&lt;T&gt;::setPrevious(LinkedListItem&lt;T&gt;* previous) {
  _previous = previous;
}

template &lt;class T&gt;
LinkedListItem&lt;T&gt;* LinkedListItem&lt;T&gt;::getNextItem() {
  return _next;
}

template &lt;class T&gt;
void LinkedListItem&lt;T&gt;::setNext(LinkedListItem&lt;T&gt;* next) {
  _next = next;
}

int main()
{
    LinkedListItem&lt;string&gt;* _list;
    return 0;
}
</code></pre>

<p>Also, this is not a typical to implement linked list. Besides, you could just use the corresponding linked list from std unless you have a specific requirement you have not yet mentioned.</p>
",,22995125,1815
18486295,2,18486175,2013-08-28T11:13:34.337,4,,906773,,2013-08-28T11:13:34.337,,4,,"<p>You are returning a pointer to a local variable on the stack. The memory the pointer is pointing at is no longer valid and accessing that memory invokes undefined behavior. The reason why you are seeing such strange behavior is because anything can happen when you invoke undefined behavior.</p>

<p>The solution to your problem would be to code in C++ and use std::string.</p>

<pre><code>std::string t;
t.push_back((hours/10) + '0');
...

return t;
</code></pre>
",,23035250,1791
18486557,2,18486175,2013-08-28T11:25:54.863,0,,204847,,2013-08-28T11:32:40.750,2013-08-28T11:32:40.750,0,,"<p>You're returning a pointer to a local array. It is destroyed before the caller can access it, giving undefined behaviour; in practice it may or may not be overwritten with someone else's data.</p>

<p>The usual solution would be to return a dynamic array (such as <code>std::string</code>); but since you say you have extreme memory restrictions that would be a bad idea here.</p>

<p>I would modify the function so that the caller supplies the buffer:</p>

<pre><code>void getAlarmTime(char t[6]) {
  int hours = g_alarmHours;
  int minutes = g_alarmMinutes;
  t[0] = (hours/10) + '0';
  t[1] = (hours%10) + '0';
  t[2] = ':';
  t[3] = (minutes/10) + '0';
  t[4] = (minutes%10) + '0';
  t[5] = 0;
}
</code></pre>

<p>Beware that the caller is now responsible for making sure the buffer is large enough. Even though I declared the parameter as <code>char[6]</code>, that serves only as documentation; to the compiler it's the same as <code>char*</code>.</p>

<p>Another possibility is to make the local buffer static; but beware that the function will no longer be reentrant or thread-safe, which could lead to weird bugs.</p>

<blockquote>
  <p>Why is using those global variables causing the output of getAlarmTime() to go so wonky?</p>
</blockquote>

<p>My guess would be that, when you initialise the local variables with constants, the compiler eliminates them and uses the constants instead. This moves the array to somewhere else in the stack, where it happens not to be overwritten before you examine it. But this is all in the realms of undefined behaviour, so the exact details aren't of any practical interest.</p>
",,23083131,448
18583451,2,18581804,2013-09-03T03:01:55.140,1,,2612271,,2013-09-03T03:01:55.140,,2,,"<p>The question seems to be the routine:</p>

<pre><code>  void udpSerialPrint(word port, byte ip[4], const char *data, word len) {//etc.
</code></pre>

<p>Gets called-back  And specifically from this code:</p>

<pre><code>void loop()
{
   //this must be called for ethercard functions to work.
   ether.packetLoop(ether.packetReceive());
}
</code></pre>

<p>And it displays at the PC text messages, so we know it is getting invoked.  But the line:</p>

<pre><code>ether.sendUdp(msg, sizeof msg, portMy, ipDestination, portDestination);
</code></pre>

<p>Does <strong>not</strong> appear to be working.</p>

<p>The prototype for sendUdp is:</p>

<pre><code>void EtherCard::sendUdp (char *data, byte datalen ,word sport, byte *dip, word dport)
</code></pre>

<p>The second parameter is defined as a byte?, but what does the <code>sizeof msg</code>, statement in the actual code code generate?  K&amp;R says it is implementation defined.</p>

<p>So, initially as a test I would try:</p>

<pre><code>   ether.sendUdp(msg, 12, portMy, ipDestination, portDestination);
</code></pre>

<p>Also, another change to try is to modify <code>msg</code> so that it has the correct headers used for html pages.  This message is going to an ip on the local machine, which would then attempt to display it in a browser?? if so, then expand msg to make it conform, and increase the message length.</p>
",,23094401,69
29958194,2,18581804,2015-04-30T02:52:51.273,-1,,4848867,,2015-04-30T03:21:46.307,2015-04-30T03:21:46.307,0,,"<p>I have the same problem, I can send but I cannot receive. </p>

<p>I think your code above is fine.</p>

<pre><code>ether.sendUdp(msg, sizeof msg, portMy, ipDestination, portDestination);
</code></pre>

<p>the solution is :</p>

<ol>
<li>to test it, use cross UTP cable pear to pear, between computer (IP:192, 168, 0, 9)  &amp; Arduino (IP:192,168,0,201 )</li>
<li>make it same arduino IP Gateway and Computer IP destination</li>
<li>ether.staticSetup(myip, gwip);  ""change to""  ether.staticSetup(myip, ipDestination);</li>
</ol>

<p>So the IP configuration like this</p>

<p><strong>Computer PC:</strong></p>

<pre><code>IP       : 192, 168, 0, 9  

Gateway  : (none)           

DNS      : (none)           

Port open:8888               
</code></pre>

<p><strong>Arduino:</strong></p>

<pre><code>IP       : 192,168,0,201

Gateway  : 192, 168, 0, 9              

DNS      : (none)     

Port open:8888               
</code></pre>
",,23096366,184351
18584432,2,18583996,2013-09-03T05:04:45.647,0,,472858,,2013-09-03T05:04:45.647,,2,,"<p>It's better to write make file like this:</p>

<pre><code>CC  = $(CROSS_COMPILE)gcc
LD  = $(CROSS_COMPILE)ld
LDFLAGS = 
CFLAGS  = -g -Wall

TARGETS = main
#     

main:main.o
    $(LD) $(LDFLAGS) -o $@ $&lt;

main.o:main.c
    $(CC) $(CFLAGS) -o $@ $&lt;

clean:
    rm -rf $(TARGETS)
    rm -rf *.o
</code></pre>

<p>When you work with cross toolchains, you can just do this:</p>

<pre><code>make CROSS_COMPILE=your toolchains's prifix
</code></pre>

<p>then you can get the binary you want. </p>
",,23167105,128
18596490,2,18596380,2013-09-03T15:50:08.600,1,,445221,,2013-09-03T16:00:33.037,2013-09-03T16:00:33.037,1,,"<p>I'm not really sure how popen works but try. Perhaps it just doesn't work with pipes.</p>

<pre><code>rf_line = popen(""grep wlan0 /proc/net/wireless"", ""r"");
</code></pre>

<p>Another is to add absolute path like:</p>

<pre><code>rf_line = popen(""/bin/grep wlan0 /proc/net/wireless"", ""r"");
</code></pre>

<p>Or</p>

<pre><code>rf_line = popen(""/usr/bin/grep wlan0 /proc/net/wireless"", ""r"");
</code></pre>

<p><strong>UPDATE</strong></p>

<p>This one worked for me.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
    char line[200];
    line[0] = '\0';
    FILE* rf_line = popen(""grep wlan0 /proc/net/wireless"", ""r"");
    fgets(line, 200, rf_line);
    printf(""%s"", line);  /* You can remove this */
    pclose(rf_line);
}
</code></pre>
",,23194080,1176
18680760,2,18679274,2013-09-08T05:36:53.487,1,,1609219,,2013-09-08T05:36:53.487,,3,,"<p>The problem was that your code looking for '>' always looked at character 0 and you were appending to your string, so after getting a first non '>' character you could never get to a condition in which you would print.</p>

<pre><code>String txtMsg = """"; // a string for incoming text

void setup() {
    Serial.begin(9600);
    while (!Serial); // wait for serial port to connect. Needed for Leonardo only
}

void loop() {
    // add any incoming characters to the String:
    int got_start = 0;
    while (Serial.available() &gt; 0) {
        char inChar = Serial.read();
        if (inChar == '&gt;' &amp;&amp; !got_start) {
            got_start = 1;
        }
        if (got_start) {
            txtMsg += inChar;
        }   
        if (inChar == '&lt;' &amp;&amp; got_start) {
            got_start = 0; 
            Serial.println(txtMsg);
            txtMsg = """";    
        }   
    }   
}   
</code></pre>
",,23232223,969
18803984,2,18790880,2013-09-14T16:39:35.300,0,,2408504,,2013-09-14T16:39:35.300,,0,,"<p>I've solved the problem by combining all kinds of answer you all gived me and some advice of my teacher.</p>

<p>I've made two unsigned chars. One for a if statement to determine if we are going up or down, the other one for telling which led is on. Then I've made some if statements in my loop. You can see it below.</p>

<p>I am doing this in my for loop:</p>

<p>1) If we are going up (updown is 1), set light up 1 higher. If the light is bigger than or 7, set updown to 0.</p>

<p>2) Else set light up 1 down. If the light is 0, set updown to 1.</p>

<p>3) Do the bitshift.</p>

<p>4) Do a little delay.</p>

<pre><code>#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;

int main()
{
    UCSR0B = 0;
    DDRD = 0b11111111;

    unsigned char upDown=1; // start going with the ports up
    unsigned char cylon=0;  // says which LED is on

    for(;;)
    {
        if(upDown==1){
            cylon++;
            if(cylon&gt;=7) upDown=0;      // Reached the last LED
        }
        else {
            cylon--;
            if(cylon==0) upDown=1;      // Reached min LED
        }
            PORTD = 1 &lt;&lt; cylon;
            _delay_ms(100);             // a little wait
    }
}
</code></pre>
",,23261572,999
18809116,2,18806141,2013-09-15T05:07:38.333,12,,1927972,,2013-09-15T05:18:58.007,2013-09-15T05:18:58.007,1,,"<p>Your first error ""no matching.. "" is because you have no default constructor.  You can make that approach function.</p>

<p>Add a no parameter, AKA default constructor, to the class, like this:</p>

<pre><code>class LedControl {
  LedControl();
  LedControl(uint8_t pin1, uint8_t pin2, uint8_t pin3);

private:
  uint8_t pin1;
  uint8_t pin2;
  uint8_t pin3;
};

LedControl::LedControl() : pin1(0), pin2(0), pin3(0) {
  // this constructor leaves the class unusable
}

LedControl::Ledcontrol(uint8_t p1, uint8_t p2, uint8_t p3) 
  : pin1(p1), pin2(p2), pin3(p3)
{
  // this object is ready to use    
}
</code></pre>

<p>With this class, your approach will work, but is not the optimal method.  This line does too much work:</p>

<pre><code>void setup() {
  lc = LedControl(11, 13, 12);// data, clock, latch;
}
</code></pre>

<p>This line of code involves the compiler creating some code for you:</p>

<ul>
<li>First another instance of the class is constructed on the stack using the parameters 11,13,12.</li>
<li>Then it applies the <strong>= operator</strong> copying the data from the stack object to your global object.</li>
<li>When setup() exits, the stack object is flushed.  </li>
</ul>

<p>Because the temporary object is on the stack, your program didn't use too much memory, but your code size is larger because it involves extra operations to construct the temporary then copy from the temporary to the permanent.</p>

<p>Note that the compiler is creating an <strong>= operator</strong> for you, to fill the function of the line</p>

<pre><code>  lc = LedControl(11, 13, 12);
</code></pre>

<p>This may or may not work depending on what is in your constructor.  The compiler can only presume that you needed a simple <strong>= operator</strong>.  All the basic assignment operator will do is copy all the data members from the instance on the right side of the = to the instance on the left side.  The compiler constructed = will not contain any code.  </p>

<p>If your constructor does anything significant (other than save the parameters) then the compiler constructed(guessed) assignment operator may not work as you expected.  For your case the constructor probably sets the pin modes, something like this:</p>

<pre><code>LedControl::LedControl(uint8_t p1, uint8_t p2, uint8_t p3) 
  : pin1(p1), pin2(p2), pin3(p3)
{
  pinMode(pin1, INPUT);
  pinMode(pin2, OUTPUT);
  pinMode(pin3, OUTPUT);
  return;
}
</code></pre>

<p>This happens to function, but only by chance.  The pinMode() calls are made when the temporary object is constructed and called from that object, not from the global <em>lc</em>.  Because pinMode()'s are global this case will achieve the correct goal, but maybe not in the way expected.  For more complex operations such as registering interrupt handlers, you will need to create your own assignment operator:</p>

<pre><code>LedControl&amp; operator= (const LedControl &amp; other);
</code></pre>

<p>In that method, you could ensure that the state of the global <em>lc</em> is what you need.  An easier/safer approach is to not deal with that at all.  </p>

<p>A simple and efficient approach, you may have seen in other libraries is to add a method to the class that assigns the pins:</p>

<pre><code>class LedControl {
  void attach(uint8_t pin1, uint8_t pin2, uint8_t pin3);
};

void LedControl::attach(uint8_t pin1, uint8_t pin2, uint8_t pin3) {
  this.pin1 = pin1;
  this.pin2 = pin2;
  this.pin3 = pin3;
  // do other setup type operations
  return;
}
</code></pre>

<p>Now your program, constructs the blank object, and assigns pins during setup():</p>

<pre><code>LedControl lc; // not ready to use until attach pins

void setup() {
  lc.attach(11, 13, 12);// data, clock, latch;
  ...
}
</code></pre>

<p>This involves no temporary object construction, and no assignment operator.  With respect to design, some people might fairly comment that the user might forget to call attach() and leave the global lc object unusable.  For a desktop application, you might add some code to prevent that failure case.  For an embedded application, that is a risk you accept which is balanced by the gains in code size or memory savings.</p>
",,23271765,444
47990474,2,18806141,2017-12-27T10:26:02.613,4,,3252716,,2017-12-27T10:26:02.613,,0,,"<p>I just stumbled over the same problem. I wanted to create a global debug port object, but I couldn't create it as global instance, as the port won't work after setup() was called. I have the same assumptions that the arduino code does some setup stuff after my constructor (of the global object) and before setup().</p>

<p>I found it the easiest solution, to declare my object as a pointer and init it in setup. In your situation it would be:</p>

<pre><code>LedControl* lc;

void setup() 
{ 
   lc = new LedControl(11, 13, 12);// data, clock, latch;
}

void loop()
{
   lc-&gt;doSomething();
}
</code></pre>

<p>So there's no need for additional constructors or operators.
As the object is used until power down, theres is no delete needed in this case.</p>
",,23281584,96
18819571,2,18819535,2013-09-16T02:20:14.523,1,,951757,,2013-09-16T02:20:14.523,,1,,"<p>You only declared static members in header file, you need define them in .cpp file.</p>

<pre><code>char SystemLogging::logBuff[BUF_LENGTH] = {};
char SystemLogging::logname[9] = {};
uint32_t SystemLogging::length = 0;
int SystemLogging::lineCount = 0;
int SystemLogging::data = 0;
</code></pre>

<p>In practice, <code>SystemLogging</code> only contains static members and member functions, better use namespace. And I would choose <code>std::string</code> over <code>char array</code>.</p>
",,23286308,204
18819580,2,18819535,2013-09-16T02:21:09.343,4,,1120273,,2013-09-16T02:21:09.343,,1,,"<p>The declarations for <code>static</code> members in the class are, well, just declarations, not definitions. If you actually use any of the <code>static</code> members in a substantial way, you need to also define them. It seems you didn't provide definitions:</p>

<pre><code>// in your .cpp file add:
char     SystemLogging::logBuff[BUF_LENGTH];
char     SystemLogging::logname[9];
uint32_t SystemLogging::length;
int      SystemLogging::lineCount;
int      SystemLogging::data;
</code></pre>

<p>You should probably also initialize the variables as the value zero they get is probably not quite the value you want.</p>

<p>BTW, the name <code>_SYSTEMLOGGING_h</code> is reserved for use by the compiler and its standard library: you are not allowed to use any name starting with an underscore followed by a capital character in any context unless they are explicitly allowed to be used (like, e.g., <code>__FILE__</code>).</p>
",,23287936,34
19112659,2,18832285,2013-10-01T09:31:19.363,4,,265521,,2013-10-01T13:08:28.363,2020-06-20T09:12:55.060,0,,"<p><strong>Update: See bottom of this answer for the answer.</strong> TL;DR: You have so set the baud rate (and presumably all the other settings) <em>after</em> you open the port.</p>
<p>I believe this is a bug in the Windows implementation of QSerialPort. I haven't been able to narrow down the cause yet but I have the following symptoms:</p>
<ol>
<li><p>Load the Arduino (Uno in my case; Leonardo may behave very differently) with the ASCII demo. Unplug and replug the Arduino. Note that the TX light doesn't come on.</p>
</li>
<li><p>Connect to it with Putty or the Arduino serial port monitor. This resets the Arduino and then prints the ASCII table. The TX light is on continuously as expected.</p>
</li>
<li><p>Unplug/replug the Arduino and this time connect to it with a QSerialPort program. This time despite the port being opened ok the TX light never comes on and <code>readyRead()</code> is never triggered. Also note that the Arduino is not reset because by default QSerialPort does not change DTR. If you do <code>QSerialPort::setDataTerminalReady(false);</code> then pause for 10ms then set it <code>true</code> it <em>will</em> reset the Arduino as expected but it still doesn't transmit.</p>
</li>
<li><p>Note that if you have an Arduino program that transmits data continuously (ASCII example stops), if you open the port with putty so that it starts transmitting and <em>then</em> open it with QSerialPort without unplugging the cable it will work! However as soon as you unplug/plug the cable it stops working again.</p>
</li>
</ol>
<p>This makes me suspect that putty is setting some serial port option that is required by the arduino and reset when you replug the cable. QSerialPort obviously doesn't change this value.</p>
<p>Here are the settings used by Putty as far as I can tell:</p>
<pre><code>dcb.fBinary = TRUE;
dcb.fDtrControl = DTR_CONTROL_ENABLE;
dcb.fDsrSensitivity = FALSE;
dcb.fTXContinueOnXoff = FALSE;
dcb.fOutX = FALSE;
dcb.fInX = FALSE;
dcb.fErrorChar = FALSE;
dcb.fNull = FALSE;
dcb.fRtsControl = RTS_CONTROL_ENABLE;
dcb.fAbortOnError = FALSE;
dcb.fOutxCtsFlow = FALSE;
dcb.fOutxDsrFlow = FALSE;
dcb.Parity = NOPARITY;
dcb.StopBits = ONESTOPBIT;
dcb.BaudRate = ...;
dcb.ByteSize = ...;
</code></pre>
<p>And by <a href=""https://qt.gitorious.org/qt/qtserialport/source/e08753474802607611532590b58816f0eee30b5f:src/serialport/qserialport_win.cpp#L248-271"" rel=""nofollow noreferrer"">QSerialPort</a>:</p>
<pre><code>dcb.fBinary = TRUE;
dcb.fDtrControl = unchanged!
dcb.fDsrSensitivity = unchanged!
dcb.fTXContinueOnXoff = unchanged!
dcb.fOutX = FALSE;
dcb.fInX = FALSE;
dcb.fErrorChar = FALSE;
dcb.fNull = FALSE;
dcb.fRtsControl = RTS_CONTROL_DISABLE;
dcb.fAbortOnError = FALSE;
dcb.fOutxCtsFlow = FALSE;
dcb.fOutxDsrFlow = unchanged!
dcb.Parity = NOPARITY;
dcb.StopBits = ONESTOPBIT;
dcb.BaudRate = ...;
dcb.ByteSize = ...;
</code></pre>
<p>So I think it must be one of those unchanged values which makes the Arduino think that it isn't connected. From the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx"" rel=""nofollow noreferrer"">DCB documentation</a> I suspect <code>fTxContinueOnXoff</code>.</p>
<p>Ok I am going to write a little program to read these settings and see what changes.</p>
<h1>Update 1</h1>
<p>Ok I wrote my program and made the following discovery. The differences after running putty and just my Qt program were:</p>
<ul>
<li>BaudRate: THIS WASN'T SET BY QT!!!!!!! <strong>It turns out you can only set the baud rate <em>after</em> you open the port.</strong>. Otherwise it is left at the previous value which is 0 when you first plug in the cable.</li>
<li>fDtrControl: Set to 1 by Putty, left at 0 by Qt.</li>
<li>fOutX and fInX: Both also set to 1 by Putty and left at 0 by Qt.</li>
</ul>
<p>After moving all my <code>set...()</code> function calls after the open it worked perfectly. I didn't have to fiddle with DtrControl or Out/InX. (Although I have also set DTR high manually.)</p>
<h1>Update 2</h1>
<p>While setting all the parameters I thought it would be a good idea to set the error policy to 'skip'. DON'T DO THIS! LEAVE IT ON IGNORE! Otherwise it fucks everything up and adds weird delays to all your communications.</p>
",,23312619,1032
22141161,2,18832285,2014-03-03T07:39:29.133,4,,2682142,,2014-12-24T04:23:41.087,2014-12-24T04:23:41.087,1,,"<p>Setting the ports before open is not quite possible before Qt 5.2. The reason is that the original design was a bit too low-level for the class rather properly object oriented. I had been considered for a long-time whether to change it and in the end I actually decided to do so.</p>

<p>I have just submitted a change that is now under code review that will make your original concept work, too.</p>

<p>Here you can find the details:</p>

<p><a href=""https://codereview.qt-project.org/79656"" rel=""nofollow"">Make it possible to set the port values before opening</a></p>

<p>The summary can be read here for the change:</p>

<blockquote>
  <p>Make it possible to set the port values before opening</p>
  
  <p>This patch also changes the behavior of the open method. We do not use port
  detection anymore for good. It has been a broken concept, and it is very
  unlikely that anyone has ever relied on it. If anyone had done that, they would
  be in trouble anyway, getting noisy warnings needlessly and all that.</p>
  
  <p>The other option was also considered to keep this behavior optionally as the
  default, but that would complicate the API too much without not much gain.</p>
  
  <p>The default port settings are now also the sane 9600,8,N,1, and no flow control.
  Also please note that the serial port is closed automatically in the open method
  if any of the settings fails.</p>
</blockquote>

<p>Please update your Qt version (at least to Qt 5.2) or you can backport the change yourself. Then, it is possible to write this code and actually it is even recommended:</p>

<pre><code>QSerialPort arduPort(""COM5"");
arduPort.setBaudRate(QSerialPort::Baud9600);
arduPort.setDataBits(QSerialPort::Data8);
arduPort.setParity(QSerialPort::NoParity);
arduPort.setStopBits(QSerialPort::OneStop);
arduPort.setFlowControl(QSerialPort::NoFlowControl);
arduPort.open(QSerialPort::ReadWrite);
</code></pre>
",,23314794,311
18837732,2,18837573,2013-09-16T21:36:40.420,4,,882003,,2013-09-18T08:52:52.510,2013-09-18T08:52:52.510,3,,"<p>What you are doing wrong is not allocating any memory for your strings.</p>

<p>Here's one way to do this</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;

std::vector&lt;std::string&gt; myFiles;
std::string file;
bool done = false;
char character;
while (!done)
{
  if (Serial.available())
  {
    character = Serial.read();
    if ((character == '\n') || (character == '\r'))
    {
      done = true;
    }
    else if (character == ',')
    {
      myfiles.push_back(file);
      file = """";
    }
    else
    {
      file += character;
    }
  }
}

Serial.println(myFiles[0].c_str());
</code></pre>

<p>Since you are programming in C++ you should learn how to use <code>std::vector</code> and <code>std::string</code>, they will save you a lot of grief.</p>

<p>If <code>std::vector</code> and <code>std::string</code> are not available to you (apparently so on Arduino) then the quick hack would be to preallocate a fixed amount of memory for your strings by replacing</p>

<pre><code>char* myFiles[20];
</code></pre>

<p>with</p>

<pre><code>char myFiles[20][100];
</code></pre>
",,23315017,45
18840444,2,18840283,2013-09-17T02:39:05.183,0,,2612271,,2013-09-17T02:39:05.183,,0,,"<p>First of all, conditions is a 6 by 20 matrix of pointers to strings.  Some of the rows, such as cloudy only has one pointer (out of the 20) assigned.  So the loop needs to test for a null ptr and go to the next row.</p>

<p>I'm <strong>not</strong> going to write your code, but in psuedo-code it should be something like:</p>

<pre><code> memfill(conditions, 0, 6*20*sizeof(char *));
 for (i = 0 to 5)

   for (j = 0 to 20)

       if (conditions[i][j] == NULL) {break;}

       print(""%s/n"", conditions[i][j]);
       // test/compare strings, i is the enum value if a match
       // return i;

   end for j

end for i
</code></pre>
",,23330002,1476
18903665,2,18903528,2013-09-19T19:48:58.503,1,,2073232,,2013-09-19T19:59:22.677,2013-09-19T19:59:22.677,0,,"<p>You should pass the pointer, but you'll have to change all usages to dereferenced pointer like this:</p>

<pre><code>boolean check(int key, boolean *prev_key_high, char c){

    ...
    if (*prev_key_high)
    ...
    *prev_key_high = true;
    ...
</code></pre>
",,23331917,124
18903670,2,18903528,2013-09-19T19:49:20.923,0,,1935434,,2013-09-19T19:49:20.923,,3,,"<p>Thanks Simon. 
Here is the new code:</p>

<pre><code>  check(key_a, &amp;prev_key_a_high, 'a');

boolean check(int key, boolean *prev_key_high, char c){

 if (key == LOW) {
    if ( *prev_key_high){
      *prev_key_high = false;
      Serial.println(c);
      return true;
    }
  }

  else {
    *prev_key_high = true;
    return false;
  }



}
</code></pre>
",,23344878,373
18903774,2,18903528,2013-09-19T19:54:45.137,0,,2114936,,2013-09-19T19:54:45.137,,0,,"<p>The change in the global boolean value is not persisting because it is being passed by value. When an argument is passed by value to a function, the function creates a local copy of the variable and makes changes to the local copy. This local variable goes out of memory once the program is out of the scope of the function. 
Using pointers should solve the issue. Try the following..</p>

<pre><code>boolean check(int key, boolean* prev_key_high, char c){
  if (key == LOW) {
    if ( *prev_key_high){
      *prev_key_high = false;
      Serial.println(c);
    return true;
    }
   }

    else {
      *prev_key_high = true;
      return false;
    }
  }
</code></pre>

<p>and when you call the function :</p>

<pre><code>check(4, &amp;some_global_boolean, 'a');
</code></pre>
",,23387848,5640
18903798,2,18903528,2013-09-19T19:56:12.110,2,,2774165,,2013-09-19T19:56:12.110,,0,,"<p>Additionally, if your variable is in <strong>global</strong> scope, you could just remove it from your argument list and access it directly, that way it would never appear in local scope. For example:</p>

<pre><code>int globalInt;

void incGlobal() {
    globalInt++;
}

int main() {
    globalInt = 0;
    printf(""%d\n"", globalInt);
    incGlobal();
    printf(""%d\n"", globalInt);
    incGlobal();
    printf(""%d\n"", globalInt);
    incGlobal();
}
</code></pre>

<p>prints</p>

<pre><code>0
1
2
</code></pre>
",,23391125,909
18904177,2,18903528,2013-09-19T20:20:10.403,0,,1988509,,2013-09-19T20:20:10.403,,0,,"<p>First you need to learn how scope works in C, and how are variables passed to functions.
Local Scope > Global Scope, for example, if you have a global variable named ""variable"", and a function with a variable also named ""variable"", you'll be working on the local copy of it.</p>

<p>Now, with that in mind, think of this, when you pass an argument to a function, you actually make a copy of the variable, with local scope. So in your function:</p>

<p>check(4, some_global_boolean, 'a');</p>

<p>When you defined the function you gave each argument a name right? so when you call a function, and you instantiate each argument into a variable(of the defined type) according to the function signature. Kinda this:
argument1 = value1, argument2 = value 2,..., argumenn = valuen</p>

<p>Now, lets take this to your function:
boolean check(int key, boolean prev_key_high, char c) => key = 4, prev_key_high = some_global_boolean, c = 'a'</p>

<p>Each of this variables has a local scope, and it has the same values as the arguments/variables/values you used in the call, but the variable is in a completely different position in memory. </p>

<p>Now, there are different ways to deal with this, personally I discourage people into using global variables:</p>

<p>1.Instantiate a variable in your main function (static or dynamic as you wish), and work with pointers to that specific variable:</p>

<pre><code>    int main(int argc, char const *argv[])
    {
       boolean some_global_boolean = true; //or false or w/e or initialize it as you wish
       check(4, &amp;some_global_boolean, 'a');
       return 0;
    }

    boolean check(int key, boolean * prev_key_high, char c){

    if (key == LOW) {
        if ( *prev_key_high){
          *prev_key_high = false;
          Serial.println(c);
          return true;
        }
    }

    else {
        *prev_key_high = true;
        return false;
      }
    }
</code></pre>

<p>2.If you insist in using a global variable, use it directly, or in combination with previous comment. I encourage you into learning about pointers and working with them.</p>

<pre><code>boolean check(int key, char c){

    if (key == LOW) {
        if ( some_global_boolean){
            some_global_boolean = false;
            Serial.println(c);
            return true;
        }
    }

    else{
          some_global_boolean = true;
          return false;
        }
    }
}
</code></pre>
",,23415242,174
18966983,2,18966906,2013-09-23T19:13:11.673,1,,1153165,,2013-09-26T05:48:50.557,2013-09-26T05:48:50.557,8,,"<p>Yes, you are re-defining the array several times.</p>

<p>In C++, you may want to use <code>bitset</code>, check this link</p>

<p><a href=""http://en.cppreference.com/w/cpp/utility/bitset"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/bitset</a></p>

<p>You can try vector (which can dynamically change its size) too, like this</p>

<pre><code>    #include&lt;iostream&gt;
    #include&lt;vector&gt;
    using namespace std;

    enum trigger_status {ON, OFF, NON_STICKY};

    int main(){
       vector&lt;trigger_status&gt; sticky_triggers(251, trigger_status::OFF); // you can add element to it dynamically, default all to off

       sticky_triggers[0] = trigger_status::ON;
       sticky_triggers[9] = trigger_status::ON;

       sticky_triggers.push_back(trigger_status::ON); // sticky_triggers[251] = true, now u have 252 elements
    }
</code></pre>
",,23449197,1151
18966998,2,18966906,2013-09-23T19:13:52.387,1,,1758762,,2013-09-23T19:37:45.860,2013-09-23T19:37:45.860,4,,"<p>Try this:</p>

<pre><code>#define ARRAY_SIZE 10
#define BOOL unsigned int
#define TRUE 1
#define FALSE 0

int main()
{
  BOOL stickyTriggers[ARRAY_SIZE] = { FALSE };

  stickyTriggers[1] = TRUE ;
  stickyTriggers[9] = TRUE ;

  return 0;

}
</code></pre>
",,23502412,216
18967156,2,18966906,2013-09-23T19:23:02.150,1,,1166638,,2013-09-23T19:24:09.260,2013-09-23T19:24:09.260,1,,"<p>I think you need somethig like this </p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
   bool b[5] = {true, false, true, false, true};
   cout &lt;&lt; ""Hello World"" &lt;&lt; endl; 

   for (int i=0; i &lt; 5; i++) {
       if (b[i]) {
           cout&lt;&lt; ""Index "" &lt;&lt; i &lt;&lt; "" is true"" &lt;&lt;endl;
       } else {
           cout&lt;&lt; ""Index "" &lt;&lt; i &lt;&lt; "" is false""&lt;&lt;endl;
       }
   }

   return 0;
}
</code></pre>
",,23519892,399
18968125,2,18966906,2013-09-23T20:21:41.557,0,,974028,,2013-09-23T20:21:41.557,,0,,"<p>Maybe I should have left out the C++ tag, to only invite Arduino-specific solutions.
But here's what I found, which solves my problem:</p>

<p>Alexander Brevig's HashMap Library:
<a href=""http://playground.arduino.cc/Code/HashMap"" rel=""nofollow"">http://playground.arduino.cc/Code/HashMap</a></p>

<p>As discussed here: <a href=""http://forum.arduino.cc/index.php?PHPSESSID=q7rt05n43aa4enp6hepri50pi1&amp;topic=42114.msg305435#msg305435"" rel=""nofollow"">http://forum.arduino.cc/index.php?PHPSESSID=q7rt05n43aa4enp6hepri50pi1&amp;topic=42114.msg305435#msg305435</a></p>

<pre><code>#include &lt;HashMap.h&gt;

const byte HASH_SIZE = 5; 
HashType&lt;int,boolean&gt; hashRawArray[HASH_SIZE]; 
HashMap&lt;int,boolean&gt; hashMap = HashMap&lt;int,boolean&gt;(hashRawArray, HASH_SIZE); 

void setup() {

    Serial.begin(9600);                                 

    hashMap[0](1,true);
    hashMap[1](2,false);
    hashMap[2](3,false);
    hashMap[3](4,false);
    hashMap[4](9,true);

    Serial.println(hashMap.getValueOf(1));
    Serial.println(hashMap.getValueOf(2));
    Serial.println(hashMap.getValueOf(9));

}
</code></pre>

<p>I can add a quick wrapper to add items to the hashMap without having to hard-code the index, but this gives me an easy way to set up an associative array of booleans, using arbitrary integers as the keys.</p>

<p>Thanks for trying everyone, sorry none of the answers worked on Arduino.</p>
",,23571460,64
18985845,2,18966906,2013-09-24T15:29:17.070,0,,10240,,2013-09-24T15:29:17.070,,0,,"<p>You might be able to use this it does not quite fulfil your desire to have no references to non-sticky triggers but it is fast and only uses 64 bytes of memory to map out 256 triggers.</p>

<p>I already had it in single boolean mode so I adapted it to make two maps and renamed it to suit your question..</p>

<p>Basically it is a bitmap.</p>

<p>Compiles and tests run OK for Arduino Duo.</p>

<pre><code>// bitmapped booleans
const int IntBits = 16;
const int NumTriggers = 256;
const int idxSticky = 0;
const int idxDown = 1;
unsigned int TriggerMap[NumTriggers/IntBits][2];

void setup() {
  Serial.begin(9600);
  clearTriggerMap; // set all to not sticky and not down
  // tests
  setStickyTrigger(1, true, true);
  setStickyTrigger(2, true, false);
  setStickyTrigger(3, true, false);
  setStickyTrigger(9, true, true);
  setStickyTrigger(30, true, true);
  setStickyTrigger(128, true, true);
  setStickyTrigger(255, true, true);
}

void loop() {
  // tests
  Test(0);
  Test(1);
  Test(2);
  Test(3);
  Test(9);
  Test(30);
  Test(128);
  Test(255);
  delay(5000);
}
void Test( int ATrigger) {
  // testing
  if (IsStickyTrigger(ATrigger)) {
    Serial.print( ""Trigger "");
    Serial.print(ATrigger);
    Serial.print("" is sticky"");
    if (IsStickyTriggerDown(ATrigger)) {
      Serial.print("" and it is down"");
    }
    }
  Serial.println();
}


void clearTriggerMap() {
  for (int i = 0; i &lt; NumTriggers/IntBits; i++) {
    for (int j = 0; j &lt; 2; j++){
      TriggerMap[i][j] = 0;
    }
  }
}

void setStickyTrigger(int AIndex, boolean ASticky, boolean IsDown) {
  unsigned int o;
  unsigned int b = 1;
  o = AIndex / IntBits;
  b = b &lt;&lt; (AIndex % IntBits);
 if (ASticky) {
    TriggerMap[o][idxSticky] = TriggerMap[o][idxSticky] | b;
  } else {
    b = ~b;
    TriggerMap[o][idxSticky] = TriggerMap[o][idxSticky] &amp; b;
  }
  if (IsDown) {
    TriggerMap[o][idxDown] = TriggerMap[o][idxDown] | b;
  } else {
    b = ~b;
    TriggerMap[o][idxDown] = TriggerMap[o][idxDown] &amp; b;
  }

}

boolean IsStickyTrigger(int AIndex) {
  unsigned int b = 1;
  b = b &lt;&lt; (AIndex % IntBits);
  return (TriggerMap[AIndex / IntBits][idxSticky] &amp; b) != 0;
}

boolean IsStickyTriggerDown(int AIndex) {
  unsigned int b = 1;
  b = b &lt;&lt; (AIndex % IntBits);
  return (TriggerMap[AIndex / IntBits][idxDown] &amp; b) != 0;
}
</code></pre>
",,23576827,26857
24742081,2,19018538,2014-07-14T17:14:59.927,0,,3498491,,2014-07-14T17:14:59.927,,0,,"<p>this should fix it</p>

<pre><code>void setup()
{
  int index;

  for(index = 0; index &lt;= 9; index++)
  {
    pinMode(ledPins[index],OUTPUT);
    // ledPins[index] is replaced by the value in the array.
    // For example, ledPins[0] is 2
  }
  pinMode(switchPin, INPUT);    // Set the switch pin as input
  buttonState = digitalRead(switchPin);   // read the initial state
  /* RGB */
  pinMode(RED_PIN, OUTPUT);
  pinMode(GREEN_PIN, OUTPUT);
  pinMode(BLUE_PIN, OUTPUT);
  /* RGB */
  for ( int i = 0; i &lt; PIN_COUNT; i++ ) {
    pinMode(ledPins[i], OUTPUT);
    states[i] = 0;
  }
}
</code></pre>
",,23579507,730
19046833,2,19046263,2013-09-27T09:04:22.353,0,,2803140,,2013-09-28T09:51:45.753,2013-09-28T09:51:45.753,1,,"<p>you have to use the strcmp() that check the diff between 2 char *</p>

<pre><code>char n[20];
char *adminName[] = {""Jane"", ""Joe"", ""James""};
int  i;

i = 0;
while (admminName[i])
 {
    if (strcmp(n, adminName[i]) == 0)
      return (true); 
    i++;
 }
return (false);
</code></pre>
",,23584726,4635
19062979,2,19052584,2013-09-28T03:40:51.887,0,,818432,,2013-09-28T03:40:51.887,,0,,"<p>Assuming your barcode reader sends the characters via keyboard input and does indeed put a CR after the barcode, I should think something like this would work.  Compile w/gcc:</p>

<p>gcc -o runcurl runcurl.c</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc,char *argv[])

    {
    while (1)
        {
        char buf[256],syscmd[512];
        int i;

        /* Get next barcode */
        printf(""Waiting for bar code [q=quit]:  "");
        if (fgets(buf,255,stdin)==NULL)
            break;

        /* Clean CR/LF off of string */
        for (i=0;buf[i]!='\0' &amp;&amp; buf[i]!='\r' &amp;&amp; buf[i]!='\n';i++);
        buf[i]='\0';

        /* q = quit */
        if (!strcmp(buf,""q""))
            break;

        /* Build into curl command */
        sprintf(syscmd,""curl \""http://www.xyz.com/test/order/complete?barcode=%s\"""",buf);

        /* Execute--this will wait for command to complete before continuing. */
        system(syscmd);
        }
    return(0);
    }
</code></pre>
",,23590999,71
19074172,2,19072518,2013-09-29T03:43:03.033,0,,2410359,,2013-09-29T04:07:05.183,2013-09-29T04:07:05.183,0,,"<p>Suggest OP is mis-interpreting the data - it looks fairly good.</p>

<p>Recommend re-write inner loop</p>

<pre><code>// for(loop=0; loop&lt;30; loop++)
for(loop=0; loop&lt;rx_length; loop++)
</code></pre>

<p>After doing this, the result should appear much better.  The trick is that the <code>read()</code> sample occurs asynchronously to the arriving data such that only <em>portion</em> of the message are read.  <code>read()</code> does not know when the packet ended.  It returns when its full, error or when there is a no more available data <em>at that moment</em>.  There is <em>no</em> synchronization between the <code>read()</code> and the arrival of the packet end.  Re-integration of the message is needed.</p>

<p>Synchronization pseudo code</p>

<pre><code>i = 0;
length = 0;
forever() {   
  do {
    i += length;
    length = read(&amp;buffer[i])
    if (length means bad read) handle error;
    search buffer from i to (i+length) for End-of-packet
  } while (end-of-packet not found and buffer not too full)
  Use buffer from start to end-of-packet.
  length = i+length-end-of-packet-index
  memmove(&amp;buffer[0], &amp;buffer[end-of-packet-index+1], length);
  i = 0;
}
</code></pre>

<p>You could check into other <code>read()</code>-like functions that read until a timeout.  (Maybe a different <code>open()</code> option too?</p>

<p>Other minor points</p>

<ol>
<li><p>More comments in the <code>options.c_cflag</code> to explain options.</p></li>
<li><p>""rx_length"" vs ""rx_lentgh"".</p></li>
<li><p><code>rx_buffer[loop] == NULL</code> is bad form.  <code>rx_buffer[loop]</code> is a <code>char</code>.  <code>NULL</code> is a pointer.  Use <code>rx_buffer[loop] == '\0'</code>.</p></li>
<li><p>For debug purposes, consider</p></li>
</ol>

<p>.</p>

<pre><code>// printf(""%c"", rx_buffer[loop]);
if (isprint(rx_buffer[loop])) {
   printf(""%c"", rx_buffer[loop]);
}
else {
   printf(""(%02hhX)"", rx_buffer[loop]);
}
</code></pre>
",,23616751,94
19095354,2,19093839,2013-09-30T13:20:38.210,0,,694576,,2013-10-01T12:13:21.573,2013-10-01T12:13:21.573,1,,"<p>Referring your second issues on how to quit the hanging program:</p>

<p>Adding tests for the return value to all system calls is a good idea in general!</p>

<p>Be aware that <code>read()</code>/<code>write()</code> do not necessarily read in/write out as much data as the were told to.</p>

<p>Also <code>read()</code>/<code>write()</code> return if the process received a signal.</p>

<p>Here in particular add testing the result to the calls that might block (<code>write()</code>):</p>

<pre><code>ssize_t writen(int fd, char * buffer, size_t size)
{
  ssize_t written_total = 0;
  ssize_t written = 0;

  while  (outputLength &gt; written_total)
  {
    written = write(fd, buffer + written_total, size - written_total);
    if (-1 == written)
    {
      if (EINTR == errno)
      {
        /* interupted by signal -&gt; break and leave */
        break;
      }
      elseif ((EAGAIN == errno) || (EWOULDBLOCK == errno))
      {
        continue; /* try again */
      }

      /* another error occured -&gt; log, break and leave */

      break;
    }

    written_total += written;
  }

  if (outputLength &gt; written_total)
  {
    if (-1 = written)
    {
      /* handle error */
    }
    else
    {
      /* notify of interruption */
    }
  }
  else
  {
    /* log succesfully transmission of all data */
  }

  return written_total;
}

int main()
{
  ...

  do
  {
    if (outputLength != writen(fd, outputString, outputLength))
    {
      fprintf(stderr, ""writen(fd, outputString, outputLength) failed"");
      break;
    }

    if (1 != writen(fd, "","", 1))
    {
      fprintf(stderr, ""writen(fd, "","", 1)) failed"");
      break;
    }

    if (1 != writen(fd, ""0"", 1))
    {
      fprintf(stderr, ""writen(fd, ""0"", 1)) failed"");
      break;
    }

    if (1 != writen(fd, ""\n"", 1))
    {
      fprintf(stderr, ""writen(fd, ""\n"", 1)) failed"");
      break;
    }
  } while (0);

  if (-1 == close(fd))
  {
    perror(""close() failed"");
  }

  ...
}
</code></pre>

<p>Note that the program also needs to have a signal handler registered (for <code>SIGUSR1</code> for example) that does nothing, but ""eating"" the signal.</p>

<p>Then from the command line you could easily un-block the program by doing:</p>

<pre><code>$ kill &lt;program-pid&gt; -SIGUSR1
</code></pre>
",,23634291,180
19113093,2,19113045,2013-10-01T09:50:56.447,2,,335858,,2013-10-01T09:50:56.447,,6,,"<p>One way to do it is as follows:</p>

<pre><code>struct set {
  char variable1[10];
  char variable2[10];
  char variable3[10];
} mySet = {{'\0'}, {'\0'}, {'\0'}};
</code></pre>

<p>Of course in C++ you can use <code>0</code> instead of <code>'\0'</code>, so you can write it in a more readable way:</p>

<pre><code>struct set {
  char variable1[10];
  char variable2[10];
  char variable3[10];
} mySet = {{0}, {0}, {0}};
</code></pre>

<p>Finally, since this is C++, there's no reason not to give your <code>struct</code> a constructor, so if you plan to initialize many such structures, you can use the default constructor:</p>

<pre><code>set()
: variable1({0})
, variable2({0})
, variable3({0}) {
}
</code></pre>
",,23654582,82
19113589,2,19113045,2013-10-01T10:14:43.550,1,,649665,,2013-10-01T10:14:43.550,,0,,"<p>The simplest would be simply:</p>

<pre><code>set mySet = {};
</code></pre>

<p>.  Alternatively, you might want to define a constructor for
<code>set</code>, which ensures that you cannot not initialize it: </p>

<pre><code>struct set
{
    //  ...
    set() { /* ... */ }
};
</code></pre>

<p>Note, however, that if you do this, you can no longer use
aggregate initialization; i.e.</p>

<pre><code>set mySet = { ""abc"", ""xyz"", ""123"" };
</code></pre>

<p>will no longer be legal.</p>

<p>(And of course, you don't want to use the name <code>set</code>, because
someone will come along later and do <code>using namespace std;</code>, and
expect to get <code>std::set</code>.  Avoid the names in the standard
library if you can.)</p>
",,23679215,453
19135170,2,19134773,2013-10-02T10:46:25.253,0,,1810087,,2013-12-23T14:51:13.603,2017-05-23T10:27:17.430,7,,"<p>as joachim Pileborg already mentioned, if you have a c++11 compatible compiler it is possible to pass an literal array to a function, and the function (Ethernet.begin) has a <code>begin(std::initializer_list)</code> variant.</p>

<p>however, your example is close to a solution. make <code>mac</code> <em>global</em> (<strong>const</strong> if possible) and remove the define:</p>

<pre><code>uint8_t const mac[] = { 0x43, 0xA3, 0xDA, 0x0D, 0xF5, 0xA5 };
   //^^^^^ -&gt; if begin isn't able to handle const, remove the const here.

void setup() {
  if (Ethernet.begin(mac) == 0) {
    ...
  }
}
</code></pre>

<p>this will instatiate mac only once and reuse it (no memory issue).</p>

<p>there are some possibilities, depending on the code:</p>

<ol>
<li><p><code>Ethernet.begin</code> is defined with a reference/pointer as parameter. this would mean your are passing just a reference which is ussaly smaller then 6 byte (sizeof(mac)). and mac is just once stored in memory.</p></li>
<li><p>here mac have to be declared <strong>const</strong>. so the compiler could optimize it and incorporating the value directly into the machines instruction opcodes. therefore you have to compile with optimization-flags on. see <a href=""https://stackoverflow.com/a/212693/1810087"">here</a></p></li>
<li><p>if both are not a case, then it is still ok, because mac is instantinated still once and will be passed by value (copy) over stack memory.</p></li>
</ol>

<p>the best is both... <code>byte const mac</code> and <code>begin(byte const*)</code>, so the compiler would decide the best way to spare memory and time.</p>

<hr>

<p>there is no disadvantage to make it global. a define will result in translated opcode, also maybe global const will (see above case 2) if optimized. but a const will result in one instance also one opcoder (while initializing mac) and the rest in references/aliases to this instance (addressing the value). the behaviour is defined by the implementation of your <code>Ethernet</code>.</p>
",,23720330,445
19144311,2,19143196,2013-10-02T18:39:44.987,2,,1045741,,2013-10-02T18:39:44.987,,1,,"<p>You should just be able to write a wrapper library with a C interface, that calls the C++ library.</p>

<p>The key here is using <code>extern ""C""</code> when building as C++ to ensure the C++ parts call the C functions as C and not C++.</p>

<p>The SD header is more complicated to wrap than, for example, <em>Serial.h</em> as you need to return and wrap the <em>File</em> objects as well. This can be done using a struct declaration in the header, with the real type defined in the .cpp . By working only with pointers to this type in the header, you don't need to define the struct at this point. You could alternatively use <code>void*</code> pointers, but I would avoid this as you loose type safety.</p>

<p><strong>SD_c_iface.h</strong></p>

<pre><code>#ifndef SD_C_IFACE_H
#define SD_C_IFACE_H

#include &lt;Arduino.h&gt;

#ifdef __cplusplus
extern ""C"" {
#endif

/* Wrapper around File type */

typedef struct _SD_File SD_File;

size_t SD_File_write(SD_File* file, const uint8_t *buf, size_t size);

/* TODO Wrap all required File functions */

/* Wrapper around SD type */

boolean SD_begin(uint8_t csPin);

void SD_open(const char *filename, uint8_t mode, SD_File** file);

/* TODO Wrap all required SD functions */

#ifdef __cplusplus
}
#endif
#endif
</code></pre>

<p><strong>SD_c_iface.cpp</strong></p>

<pre><code>#include ""SD_c_iface.h""

#include ""SD.h""

struct _SD_File
{
  File f;
};

size_t SD_File_write(SD_File* file, const uint8_t *buf, size_t size)
{
  return (file) ? file-&gt;f.write(buf, size) : 0;
}

boolean SD_begin(uint8_t csPin)
{
  SD.begin(csPin);
}

void SD_open(const char *filename, uint8_t mode, SD_File** file)
{
  if (!file)
    return;
  *file = new _SD_File();
  (*file)-&gt;f = SD.open(filename, mode);
}

// TODO Add more function wrappers
</code></pre>

<p>The method above is the generic way to wrap things, in your case you could, for example simplify things and only allow a single file to be opened at once, as the SD.h library only allows one open at once.</p>
",,23720504,1376
35185502,2,19149441,2016-02-03T19:03:36.037,2,,2128327,,2016-02-03T19:03:36.037,,0,,"<p>I don't have a working example, but I have an API walkthrough. <em>Sort of..</em></p>

<p><a href=""http://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/sys/external/bsd/vchiq/dist/interface/vchiq_arm/vchiq_shim.c"" rel=""nofollow"">Link to the full source code</a></p>

<p>I found the following function that demonstrate how you can call <code>vchiq_bulk_transmit</code></p>

<pre><code>int32_t vchi_bulk_queue_transmit(VCHI_SERVICE_HANDLE_T handle,
    void *data_src,
    uint32_t data_size,
    VCHI_FLAGS_T flags,
    void *bulk_handle)
{
    SHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;
    ..
    status = vchiq_bulk_transmit(service-&gt;handle, data_src,
        data_size, bulk_handle, mode);
    ..
    return vchiq_status_to_vchi(status);
}
EXPORT_SYMBOL(vchi_bulk_queue_transmit);
</code></pre>

<p>There is a function to create <code>VCHI_SERVICE_HANDLE_T</code></p>

<pre><code>int32_t vchi_service_create(VCHI_INSTANCE_T instance_handle,
    SERVICE_CREATION_T *setup,
    VCHI_SERVICE_HANDLE_T *handle)
{
    VCHIQ_INSTANCE_T instance = (VCHIQ_INSTANCE_T)instance_handle;
    SHIM_SERVICE_T *service = service_alloc(instance, setup);

    *handle = (VCHI_SERVICE_HANDLE_T)service;
    ..
    return (service != NULL) ? 0 : -1;
}
EXPORT_SYMBOL(vchi_service_create);
</code></pre>

<p>But you need a <code>VCHI_INSTANCE_T</code> which can be initialized here</p>

<pre><code>int32_t vchi_initialise(VCHI_INSTANCE_T *instance_handle)
{
    VCHIQ_INSTANCE_T instance;
    VCHIQ_STATUS_T status;

    status = vchiq_initialise(&amp;instance);

    *instance_handle = (VCHI_INSTANCE_T)instance;

    return vchiq_status_to_vchi(status);
}
EXPORT_SYMBOL(vchi_initialise);
</code></pre>
",,23725365,943
19269715,2,19162072,2013-10-09T10:38:51.127,239,,2862292,,2020-12-21T22:28:47.260,2020-12-21T22:28:47.260,15,,"<p>I'm gonna try to write this as a tutorial for you so it becomes easy to follow.</p>
<p><strong>NOTE:
This tutorial only works for older raspbian images. For the newer Raspbian based on Debian Buster see the following how-to in this thread: <a href=""https://stackoverflow.com/a/58559140/869402"">https://stackoverflow.com/a/58559140/869402</a></strong></p>
<h2>Pre-requirements</h2>
<p>Before you start you need to make sure the following is installed:</p>
<pre><code>apt-get install git rsync cmake libc6-i386 lib32z1 lib32stdc++6
</code></pre>
<h2>Let's cross compile a Pie!</h2>
<p>Start with making a folder in your home directory called <code>raspberrypi</code>.</p>
<p>Go in to this folder and pull down the ENTIRE tools folder you mentioned above:</p>
<pre><code>git clone git://github.com/raspberrypi/tools.git
</code></pre>
<p>You wanted to use the following of the 3 ones, <code>gcc-linaro-arm-linux-gnueabihf-raspbian</code>, if I did not read wrong.</p>
<p>Go into your home directory and add:</p>
<pre><code>export PATH=$PATH:$HOME/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin
</code></pre>
<p>to the end of the file named <code>~/.bashrc</code></p>
<p>Now you can either log out and log back in (i.e. restart your terminal session), or run <code>. ~/.bashrc</code> in your terminal to pick up the <code>PATH</code> addition in your current terminal session.</p>
<p>Now, verify that you can access the compiler <code>arm-linux-gnueabihf-gcc -v</code>. You should get something like this:</p>
<pre><code>Using built-in specs.
COLLECT_GCC=arm-linux-gnueabihf-gcc
COLLECT_LTO_WRAPPER=/home/tudhalyas/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/../libexec/gcc/arm-linux-gnueabihf/4.7.2/lto-wrapper
Target: arm-linux-gnueabihf
Configured with: /cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf-raspbian-linux/.b
 uild/src/gcc-linaro-4.7-2012.08/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-
 linux-gnu --target=arm-linux-gnueabihf --prefix=/cbuild/slaves/oort61/crosstool-ng/builds/arm-l
 inux-gnueabihf-raspbian-linux/install --with-sysroot=/cbuild/slaves/oort61/crosstool-ng/builds/
 arm-linux-gnueabihf-raspbian-linux/install/arm-linux-gnueabihf/libc --enable-languages=c,c++,fo
 rtran --disable-multilib --with-arch=armv6 --with-tune=arm1176jz-s --with-fpu=vfp --with-float=
 hard --with-pkgversion='crosstool-NG linaro-1.13.1+bzr2458 - Linaro GCC 2012.08' --with-bugurl=
 https://bugs.launchpad.net/gcc-linaro --enable-__cxa_atexit --enable-libmudflap --enable-libgom
 p --enable-libssp --with-gmp=/cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf-rasp
 bian-linux/.build/arm-linux-gnueabihf/build/static --with-mpfr=/cbuild/slaves/oort61/crosstool-
 ng/builds/arm-linux-gnueabihf-raspbian-linux/.build/arm-linux-gnueabihf/build/static --with-mpc
 =/cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf-raspbian-linux/.build/arm-linux-
 gnueabihf/build/static --with-ppl=/cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf
 -raspbian-linux/.build/arm-linux-gnueabihf/build/static --with-cloog=/cbuild/slaves/oort61/cros
 stool-ng/builds/arm-linux-gnueabihf-raspbian-linux/.build/arm-linux-gnueabihf/build/static --wi
 th-libelf=/cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf-raspbian-linux/.build/a
 rm-linux-gnueabihf/build/static --with-host-libstdcxx='-L/cbuild/slaves/oort61/crosstool-ng/bui
 lds/arm-linux-gnueabihf-raspbian-linux/.build/arm-linux-gnueabihf/build/static/lib -lpwl' --ena
 ble-threads=posix --disable-libstdcxx-pch --enable-linker-build-id --enable-plugin --enable-gol
 d --with-local-prefix=/cbuild/slaves/oort61/crosstool-ng/builds/arm-linux-gnueabihf-raspbian-li
 nux/install/arm-linux-gnueabihf/libc --enable-c99 --enable-long-long
Thread model: posix
gcc version 4.7.2 20120731 (prerelease) (crosstool-NG linaro-1.13.1+bzr2458 - Linaro GCC 2012.08
 )
</code></pre>
<h2>But hey! I did that and the libs still don't work!</h2>
<p>We're not done yet! So far, we've only done the basics.</p>
<p>In your <code>raspberrypi</code> folder, make a folder called <code>rootfs</code>.</p>
<p>Now you need to copy the entire <code>/lib</code>and <code>/usr</code> directory to this newly created folder. I usually bring the rpi image up and copy it via rsync:</p>
<pre><code>rsync -rl --delete-after --safe-links pi@192.168.1.PI:/{lib,usr} $HOME/raspberrypi/rootfs
</code></pre>
<p>where <code>192.168.1.PI</code> is replaced by the IP of your Raspberry Pi.</p>
<p>Now, we need to write a <code>cmake</code> config file. Open <code>~/home/raspberrypi/pi.cmake</code> in your favorite editor and insert the following:</p>
<pre><code>SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_VERSION 1)
SET(CMAKE_C_COMPILER $ENV{HOME}/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-gcc)
SET(CMAKE_CXX_COMPILER $ENV{HOME}/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++)
SET(CMAKE_FIND_ROOT_PATH $ENV{HOME}/raspberrypi/rootfs)
SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
</code></pre>
<p>Now you should be able to compile your <code>cmake</code> programs simply by adding this extra flag: <code>-D CMAKE_TOOLCHAIN_FILE=$HOME/raspberrypi/pi.cmake</code>.</p>
<p>Using a <a href=""https://github.com/jameskbride/cmake-hello-world"" rel=""nofollow noreferrer"">cmake hello world</a> example:</p>
<pre><code>git clone https://github.com/jameskbride/cmake-hello-world.git 
cd cmake-hello-world
mkdir build
cd build
cmake -D CMAKE_TOOLCHAIN_FILE=$HOME/raspberrypi/pi.cmake ../
make
scp CMakeHelloWorld pi@192.168.1.PI:/home/pi/
ssh pi@192.168.1.PI ./CMakeHelloWorld
</code></pre>
",,23729744,142
53597174,2,19162072,2018-12-03T15:46:19.020,4,,5160481,,2018-12-04T08:54:50.987,2018-12-04T08:54:50.987,0,,"<p>You may use <a href=""https://clang.llvm.org"" rel=""nofollow noreferrer"">clang</a> as well. It used to be faster than GCC, and now it is quite a stable thing. It is much easier to build clang from sources (<em>you can really drink cup of coffee during build process</em>).</p>

<p>In short:</p>

<ol>
<li>Get clang binaries (sudo apt-get install clang).. or download and
build (<a href=""https://clang.llvm.org"" rel=""nofollow noreferrer"">read instructions here</a>)</li>
<li>Mount your raspberry rootfs (it
may be the real rootfs mounted via sshfs, or an image).</li>
<li><p>Compile your code:</p>

<pre><code>path/to/clang --target=arm-linux-gnueabihf --sysroot=/some/path/arm-linux-gnueabihf/sysroot my-happy-program.c -fuse-ld=lld
</code></pre></li>
</ol>

<p>Optionally you may use legacy arm-linux-gnueabihf binutils. Then you may remove ""-fuse-ld=lld"" flag at the end.</p>

<p>Below is my cmake toolchain file.</p>

<p><strong><em>toolchain.cmake</em></strong></p>

<pre><code>set(CMAKE_SYSTEM_VERSION 1)
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

# Custom toolchain-specific definitions for your project
set(PLATFORM_ARM ""1"")
set(PLATFORM_COMPILE_DEFS ""COMPILE_GLES"")

# There we go!
# Below, we specify toolchain itself!

set(TARGET_TRIPLE arm-linux-gnueabihf)

# Specify your target rootfs mount point on your compiler host machine
set(TARGET_ROOTFS /Volumes/rootfs-${TARGET_TRIPLE})

# Specify clang paths
set(LLVM_DIR /Users/stepan/projects/shared/toolchains/llvm-7.0.darwin-release-x86_64/install)
set(CLANG ${LLVM_DIR}/bin/clang)
set(CLANGXX ${LLVM_DIR}/bin/clang++)

# Specify compiler (which is clang)
set(CMAKE_C_COMPILER   ${CLANG})
set(CMAKE_CXX_COMPILER ${CLANGXX})

# Specify binutils

set (CMAKE_AR      ""${LLVM_DIR}/bin/llvm-ar"" CACHE FILEPATH ""Archiver"")
set (CMAKE_LINKER  ""${LLVM_DIR}/bin/llvm-ld"" CACHE FILEPATH ""Linker"")
set (CMAKE_NM      ""${LLVM_DIR}/bin/llvm-nm"" CACHE FILEPATH ""NM"")
set (CMAKE_OBJDUMP ""${LLVM_DIR}/bin/llvm-objdump"" CACHE FILEPATH ""Objdump"")
set (CMAKE_RANLIB  ""${LLVM_DIR}/bin/llvm-ranlib"" CACHE FILEPATH ""ranlib"")

# You may use legacy binutils though.
#set(BINUTILS /usr/local/Cellar/arm-linux-gnueabihf-binutils/2.31.1)
#set (CMAKE_AR      ""${BINUTILS}/bin/${TARGET_TRIPLE}-ar"" CACHE FILEPATH ""Archiver"")
#set (CMAKE_LINKER  ""${BINUTILS}/bin/${TARGET_TRIPLE}-ld"" CACHE FILEPATH ""Linker"")
#set (CMAKE_NM      ""${BINUTILS}/bin/${TARGET_TRIPLE}-nm"" CACHE FILEPATH ""NM"")
#set (CMAKE_OBJDUMP ""${BINUTILS}/bin/${TARGET_TRIPLE}-objdump"" CACHE FILEPATH ""Objdump"")
#set (CMAKE_RANLIB  ""${BINUTILS}/bin/${TARGET_TRIPLE}-ranlib"" CACHE FILEPATH ""ranlib"")

# Specify sysroot (almost same as rootfs)
set(CMAKE_SYSROOT ${TARGET_ROOTFS})
set(CMAKE_FIND_ROOT_PATH ${TARGET_ROOTFS})

# Specify lookup methods for cmake
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Sometimes you also need this:
# set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

# Specify raspberry triple
set(CROSS_FLAGS ""--target=${TARGET_TRIPLE}"")

# Specify other raspberry related flags
set(RASP_FLAGS ""-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS"")

# Gather and distribute flags specified at prev steps.
set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} ${CROSS_FLAGS} ${RASP_FLAGS}"")
set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${CROSS_FLAGS} ${RASP_FLAGS}"")

# Use clang linker. Why?
# Well, you may install custom arm-linux-gnueabihf binutils,
# but then, you also need to recompile clang, with customized triple;
# otherwise clang will try to use host 'ld' for linking,
# so... use clang linker.
set(CMAKE_EXE_LINKER_FLAGS ${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=lld)
</code></pre>
",,23757857,10823
19195767,2,19195720,2013-10-05T08:43:35.877,1,,241013,,2013-10-10T10:38:17.597,2013-10-10T10:38:17.597,0,,"<p>You pass a pointer to the function but the function is a class member. Likely the call will be invalid because the <code>this</code> pointer will be garbage(may compile fine but will throw strange errors at runtime).</p>

<p>You need to define a plain vanilla function, outside of any class, and use that.
If you don't have a very complex project you can get away with having a global pointer to the class instance you should use and just delegate the call in your new function.
If you want to do thing the right way you need some mechanism to get the instance pointer I talked about above. Usually this involves either a singleton or some factory pattern.</p>

<p>Example:</p>

<pre><code>class Foo {
  void method() {
    x = 5;
  }
  int x;
}
</code></pre>

<p>Having a callback on method will crash because you have an invalid pointer for <code>this</code> so <code>x=5</code> will write 5 somewhere randomly in memory.
What you need is somehting like:</p>

<pre><code>static Foo* foo_instance;  // Initialized somewhere else.
void method_delegator() {
  foo_instance-&gt;method();
}
</code></pre>

<p>Now you can pass <code>method_delegator</code> to the function. It will work because you now also pass <code>foo_instance</code> for <code>this</code> pointer.</p>
",,23797480,157
19195789,2,19195720,2013-10-05T08:46:54.450,3,,1922748,,2013-10-05T09:30:31.347,2013-10-05T09:30:31.347,0,,"<p>You cannot pass a method to a function which expects a function, unless you define it static.</p>

<p>write it static :</p>

<pre><code>static void velocity::functionISR_name() 
</code></pre>

<p>and </p>

<pre><code>attachInterrupt(&amp;velocity::functionISR_name);
</code></pre>

<p>Unfortunately the static method is not bound to a specific instance any more. You should use it only together with a singleton. On Arduino you should write the class like shown below in the code snipped:</p>

<pre><code>class velocity
{
    static velocity *pThisSingelton;
 public:
    velocity()
    {
      pThisSingelton=this;
    }

    static void functionISR_name()
    {
      pThisSingelton-&gt;CallWhatEverMethodYouNeeded();
      // Do whatever needed.
    }

   // … Your methods
};

velocity *velocity::pThisSingelton;
velocity YourOneAndOnlyInstanceOfThisClass;

void setup()
{
  attachInterrupt(&amp;velocity::functionISR_name);

  // …other stuff…
}
</code></pre>

<p>This looks ugly, but in my opinion it is totally okay with Arduino as the opportunities are very limited on such a system.</p>

<p>Thinking again over it, I would personal go for the approach Sorin mentioned in his answer above. That would be more like that:</p>

<pre><code>class velocity
{
 public:
    velocity()
    {
    }

    static void functionISR_name()
    {
      // Do whatever needed.
    }

   // … Your methods
};

velocity YourOneAndOnlyInstanceOfThisClass;

void functionISR_name_delegation()
{
  YourOneAndOnlyInstanceOfThisClass.functionISR_name();
}

void setup()
{
  attachInterrupt(functionISR_name_delegation);

  // …other stuff…
}
</code></pre>

<p>It would also save you some bytes for the pointer you need in the first example.</p>

<p>As a site note: For the future, please post the exact code (for e.g. attachInterrupt needs more parameter) and copy&amp;paste the error messages. Usually error are exact at a place you do not suspect. This question was an exception. Normally I and other would ask for better specification. </p>
",,23836565,7119
19245401,2,19245318,2013-10-08T10:36:19.707,1,,1164966,,2013-10-08T10:42:39.230,2013-10-08T10:42:39.230,8,,"<p>When using the equality operator <code>==</code>, you're comparing the pointers.</p>

<p>In your case, you can to compare the content, using <code>strcmp()</code> for ""String Compare"".</p>

<pre><code>if ( !strcmp(packetBuffer, ""command1"") ) { 

else if ( !strcmp(packetBuffer, ""command2"") ) { 

} else {

}
</code></pre>

<p>Note that <code>strcmp()</code> returns <code>0</code> when the strings match, and <code>-1</code> or <code>+1</code> otherwise (depending on alphabetical order).</p>
",,23840550,205
19265861,2,19256421,2013-10-09T07:37:46.260,0,,2205264,,2013-10-09T09:09:44.097,2013-10-09T09:09:44.097,6,,"<p>what I would do is:</p>

<ol>
<li>from the computer, send a header byte to the Arduino to know that
useful information is coming next.</li>
<li>from the computer send the number
of data packets that are coming next</li>
<li>on the Arduino, loop through
the number of data with each time a serial read to <code>buffer[i]</code>.</li>
</ol>

<p>so the code would look like that (might need improvement):</p>

<pre><code>uint8_t dataHeader = 0xff;
uint8_t numberOfData;
uint8_t rgb[3];
uint8_t redPin, greenPin, bluePin;

void setup(){

    Serial.begin(9600);

    // INITIALIZE YOUR PINS AS YOU NEED
    //
    //


}

void loop(){

    if (Serial.available() &gt; 1) {

        uint8_t recievedByte = Serial.read();

        if (recievedByte  == dataHeader) { // read first byte and check if it is the beginning of the stream

            delay(10);
            numberOfData = Serial.read(); // get the number of data to be received.

            for (int i = 0 ; i &lt; numberOfData ; i++) {
                delay(10);
                rgb[i] = Serial.read();
            }

        }

    }

    analogWrite (redPin, rgb[0]);
    analogWrite (greenPin, rgb[1]);
    analogWrite (bluePin, rgb[2]);

}
</code></pre>

<p>Hope it helps!</p>
",,23848934,4711
19293964,2,19293824,2013-10-10T11:00:11.487,8,,28169,,2013-10-10T13:09:28.903,2013-10-10T13:09:28.903,3,,"<p>If you're sending binary data over a serial line, you really shouldn't confuse everything by using a text-style linefeed separator.</p>

<p>On the other hand, it's kind of hard (for the other end) to know which byte is which, without some kind of synchronization help.</p>

<p>But, since you only have 10 bits of payload, but send 16 bits of data, you can ""do a UTF-8"" and use a free bit to signal ""start of value"". This will require using only 7 bits of each 8-bit byte for your payload, but that's fine since 7 + 7 = 14 which is way more than 10. We can let the 8th bit mean ""this is the high byte of a new pair of bytes"":</p>

<pre><code>const int a = 600;
const unsigned char high = ((a &gt;&gt; 7) &amp; 0x7f) | 0x80;
const unsigned char low  = (a &amp; 0x7f);

Serial.print(high);
Serial.print(low);
</code></pre>

<p>In the above, the two bytes transmitted will be:</p>

<pre><code>high == ((600 &gt;&gt; 7) &amp; 0x7f) | 0x80 == 4 | 0x80 == 0x84
low  == (600 &amp; 0x7f)               == 88       == 0x58
</code></pre>

<p>The receiver will have to do the above in reverse:</p>

<pre><code>const int value = ((high &amp; 0x7f) &lt;&lt; 7) | low;
</code></pre>

<p>This should work, and uses the most-significant bit of the high byte, which is sent first, to signify that that is indeed the high byte. The low byte will never have the MSB set.</p>
",,23874911,2870
19312323,2,19311658,2013-10-11T07:15:03.247,3,,2205264,,2013-10-11T08:14:02.973,2013-10-11T08:14:02.973,5,,"<p>I assume the Arduino is receiving data from USB.</p>

<p>What is the <code>if (data available &lt;= 0)</code> doing? If you want want to read data from the serial port while it is avalaible, you should better do <code>if (Serial.avalaible() &gt; 1)</code> and then <code>Serial.read()</code> inside the <code>{}</code>.</p>

<p>If you initialize a <code>const</code> you won't be able to change its value over time...</p>

<p>What is <code>readString</code> and how is it initialized?</p>

<p>Have you tried to <code>Serial.print(c)</code> to see what's inside?</p>

<p>Once again, it would be easier for us if you could give us more context on why and when this piece of code is running.</p>

<p><strong>EDIT</strong>:</p>

<pre><code>#define HEADER_1 0xFA // here you define your headers, etc. You can also use variables.

uint8_t readByte[4]; // your packet is 4 bytes long. each byte is stored in this array.

void setup() {
    Serial.begin(9600);
}

void loop() {

    while (Serial.avalaible() &gt; 1) { // when there is data avalaible on the serial port

        readByte[0] = Serial.read(); // we store the first incomming byte.
        delay(10);

        if (readByte[0] == HEADER_1) { // and check if that byte is equal to HEADER_1

            for (uint8_t i = 1 ; i &lt; 4 ; i++) { // if so we store the 3 last bytes into the array
                readByte[i] = Serial.read();
                delay(10);
            }

        }

    }

    //then you can do what you want with readByte[]... i.e. check if readByte[1] is equal  to HEADER_2 and so on :)

}
</code></pre>
",,23875135,1238
19349558,2,19349507,2013-10-13T19:51:06.840,2,,1895207,,2013-10-13T20:04:41.447,2013-10-13T20:04:41.447,6,,"<p>Disclaimer: I don't know that much about any arduino SDK, so this is just a possible very generic way of doing it in plain C under all the assumptions I could make from your question. There's probably a better way using some kind of arduino SDK.</p>

<p>Also, as has been pointed out, modem.write does either take a char, or a byte array and a size_t parameter, so I'm leaving this answer here for people to learn something which doesn't necessarily provide the best answer for this question, but still is correct in it's own (under the stated assumptions)</p>

<hr>

<p>Assuming modem.write(...) really takes a <code>\0</code> terminated char array, and not a c++ string, this would be a possible way to do it in c:</p>

<pre><code>char *c = malloc(sizeof(long) + 1);

if (!c) {
  // handle ENOMEM
}

strncpy(c, (const char *)&amp;GMT, 4);

c[sizeof(long)] = '\0';
</code></pre>
",,23978691,942
19349580,2,19349507,2013-10-13T19:54:53.313,2,,,user529758,2013-10-13T21:04:44.577,2013-10-13T21:04:44.577,18,,"<p>So on request (and if my assumption is correct...):</p>

<p>Since <code>char</code> is a special type regarding the strict aliasing rule, you can just grab a pointer to the first byte of the <code>long</code> and use the <code>const uint8_t *, size_t</code> overload of <code>SoftModem::write</code> like this:</p>

<pre><code>modem.write((const uint8_t *)&amp;GMT, sizeof GMT);
</code></pre>

<p>If you want to send a formatted, decimal <strong>string,</strong> then you have to convert your number accordingly first:</p>

<pre><code>char buf[0x100];
int n = snprintf(buf, sizeof buf, ""%ld"", GMT);
if (n &gt; 0) {
    modem.write((const uint8_t *)buf, n)
}
</code></pre>

<p><sub>(This works because AVR-libc, which the Arduino libraries are based on, typedefs <code>uint8_t</code> to <code>unsigned char</code>, <a href=""http://svn.savannah.nongnu.org/viewvc/trunk/avr-libc/include/stdint.h?root=avr-libc&amp;view=markup"" rel=""nofollow"">as seen here</a>. If <code>uint8_t</code> wasn't a (signed or unsigned) character type, then this would violate the strict aliasing rule.)</sub></p>
",,23986447,778
19457099,2,19455232,2013-10-18T18:55:20.113,0,,25639,,2013-10-18T18:55:20.113,,2,,"<p>Don't declare <code>ServerObject</code> as a pointer and then create the instance using an initializer list.</p>

<p>This is what your constructor will look like:</p>

<pre><code>CommunicationModuleTCPIP::CommunicationModuleTCPIP(/*...*/)
    :ServerObject(5000)
{
   /* code */
}
</code></pre>

<p><a href=""http://www.cplusplus.com/forum/articles/17820/"" rel=""nofollow"">This page</a> has some information about initializers.</p>

<p>Be aware that C++ on the arduino is limited. In particular you do not have the STL and <code>new</code> and <code>delete</code> <a href=""http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_cplusplus"" rel=""nofollow"">are not implemented</a>.</p>
",,24087030,1441
19458835,2,19458619,2013-10-18T20:50:50.493,0,,2076365,,2013-10-18T20:50:50.493,,1,,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void)
{

int cardNum, int firstCard, int secondCard; 
int highLow;
int score;

score = 0;   
srand(time(NULL));

printf(""The current card is a %d\n"", firstCard(2,14));
printf(""\n Will the next card be higher(1) or lower(2)? (press 0 to quit)"");
scanf(""%d"" ,highLow);

if (cardNum &gt; 1 &amp;&amp; cardNum &lt; 11)
{        
     printf (""The card is: %d ,secondCard."");
}        
else if (cardNum == 11)
{
    printf (""The card is: Jack""); 
}       
else if (cardNum == 12)
{
    printf (""The card is: Queen""); 
}       
else if (cardNum == 13)
{
    printf (""The card is: King""); 
}       
else if cardNum == 14)
{
    printf (""The card is: Ace""); 
}       
{
if ((highLow == 1 &amp;&amp; secondCard &gt; firstCard) || (highLow == 2 &amp;&amp; secondCard &lt; firstCard))
    {   
        score = score + 1; 
        printf (""\n You have guessed correctly."");
        printf (""\n Your current score is %d ,score!\n"");
        printf(""The current card is a (""%d"" ,cardOne). \n Will the next card be higher(1) or lower(2)? (press 0 to quit)"");
    }    
else if ((highLow == 1 &amp;&amp; secondCard &lt; firstCard) || (highLow == 2 &amp;&amp; secondCard &gt; firstCard))  
    {
        score = score - 1;
        printf (""The card is: %d ,secondCard."");
        printf (""\n You have guessed incorrectly."");
        printf (""\n Your current score is %d ,score!\n"");
        printf (""The current card is a %d ,cardOne.""); 
        printf (""\n Will the next card be higher(1) or lower(2)? (press 0 to quit)"");
    }
else if (secondCard == firstCard)
    {
        printf (""\n Matching cards, no change in score"");
    }
else if (highLow == 0)
    {
        printf (""\n Thanks for playing! Your final score is %d, score."");
    }
else
    {
        printf (""\n Incorrect input. Please enter 0, 1 or 2"");      
    }
}    
return(0);
}
</code></pre>
",,24130212,207
19483101,2,19483004,2013-10-20T21:31:18.633,1,,1454143,,2013-10-20T21:31:18.633,,2,,"<p>You read your button state outside of your while loop, so your button1state and button2state are never updated, that is why you enter in an infinite loop just do that little change:</p>

<pre><code>void loop() {
    do  {
        button1state = digitalRead(button1pin);
        button2state = digitalRead(button2pin);

        if (button1state != lastButton1state) {
            if (button1state == HIGH) {
               button1counter++;
               Serial.print(""number of button 1 pushes: "");
               Serial.println(button1counter);
            }
            lastButton1state = button1state;
        }
   } while(button2state == LOW);

  Serial.println(""done"");


}
</code></pre>
",,24141486,2198
19552294,2,19501139,2013-10-23T21:07:33.727,2,,2036917,,2013-10-23T21:12:35.757,2013-10-23T21:12:35.757,1,,"<p>This is a bug in the IDE that happens in connection with the prototype generation. Change the IDE settings to verbose compiler output. If you look into the build directory and search for the generated .cpp file you will see the following:</p>

<pre><code>//#define NO_PROBLEM
#ifdef NO_PROBLEM
  #include ""Arduino.h""
void setup();
void loop();
char charBuf[16];
  unsigned int numBuf;
#endif

void setup() {
}
void loop() {
}
</code></pre>

<p>vs.</p>

<pre><code>#define NO_PROBLEM
#ifdef NO_PROBLEM
  #include ""Arduino.h""
void setup();
void loop();
char charBuf[16];
  unsigned int numBuf;
#endif

void setup() {
}
void loop() {
}
</code></pre>

<p>This explains why the compiler will not compile with the comment.</p>

<p>A workaround is to ensure that there is something that the IDE can pick up before the macro definition which will be optimized away by the compiler. For example</p>

<pre><code>namespace trick17 {};
//#define NO_PROBLEM
#ifdef NO_PROBLEM
  char charBuf[16];
  unsigned int numBuf;
#endif

void setup() {
}
void loop() {
}
</code></pre>

<p>Now the generated .cpp file becomes</p>

<pre><code>#include ""Arduino.h""
void setup();
void loop();
namespace trick17 {};
//#define NO_PROBLEM
#ifdef NO_PROBLEM
  char charBuf[16];
  unsigned int numBuf;
#endif

void setup() {
}
void loop() {
}
</code></pre>

<p>And this compiles OK.</p>
",,24152743,1726
19507493,2,19507317,2013-10-22T01:21:29.880,1,,2900943,,2013-10-22T01:21:29.880,,6,,"<p>Your call to get_pixelcolor isn't in a function.</p>

<p>You seem to be lacking a main function altogether, unless I'm missing something completely.  You're calling functions OUTSIDE of a program block.  In C, that formatting is reserved for prototyping.  Your compiler is expecting a prototype (Prototyping is describing a function roughly, ""takes these arguments, returns this"" , before you actually describe the implementation of it. If you're unfamiliar with the terminology.) , when you're feeding it a function.</p>

<p>At the very least you're looking at:</p>

<pre><code>int main(){
    XColor c;
    get_pixel_color(display, 30, 40, &amp;c);
    printf (""%d %d %d\n"", c.red, c.green, c.blue);
    return 0;
}
</code></pre>

<p>Give that a try, and see if it works.</p>

<p>If this is part of a larger program which already has a main, just call the function something different and call it from main.</p>
",,24175481,76
19507504,2,19507317,2013-10-22T01:22:37.323,1,,2113226,,2013-10-22T01:22:37.323,,1,,"<p>Is this your actual .c file, or just a snippet?  If it your actual file (judging by the line numbers, it is), then you will need to put the last three lines in a <a href=""http://en.wikipedia.org/wiki/Main_function"" rel=""nofollow"">main() function</a>:</p>

<pre><code>int main (int argc, char **argv) {
    XColor c;
    get_pixel_color(display, 30, 40, &amp;c);
    printf (""%d %d %d\n"", c.red, c.green, c.blue);
    return 0;
}
</code></pre>
",,24194961,134302
19594980,2,19593790,2013-10-25T16:26:15.110,1,,2205264,,2013-10-25T16:26:15.110,,0,,"<p>You may also want to add some delay because sometimes you can miss the first <code>Serial.println();</code>.</p>

<p>Something like that:</p>

<pre><code>int i = 1;

void setup() {
  Serial.begin(9600);
  delay(1000); //wait for one second
}
</code></pre>

<p>Hope it helps!</p>
",,24204876,700
19597168,2,19596564,2013-10-25T18:37:32.023,0,,645128,,2013-10-31T23:43:33.997,2013-10-31T23:43:33.997,4,,"<p>I think the key problem is that you are attempting to put
large numbers into a small space.  That is, without first
scaling the original numbers down to a size that will fit
comfortably into <code>char</code> storage, you are truncating some
of the information in the int data resulting in large 
negative values being interpreted as zeros.  By the way, if 
any of your negative values were > -128, I think the expression:<br>
    <code>(char) ( (unsigned)dif       &amp; 0xff)</code>  would have returned the negative value.  </p>

<p>I am still not sure what exactly you are doing with that 
expression in the first place, i.e. if you already have
a scaled data value from your normalization function
(assuming it works), then would you not just put it into your
file?  </p>

<p>In any case, as best I can tell, you are trying to accomplish 
two things, normalize (and here, I am assuming you mean scale, let me know if I am wrong)<br>
a set of positive and negative data such
that it can be stored in <code>char</code>, then write that data using
<code>putc()</code> into a file.  If we solve the scaling problem,<br>
then writing positive and negative results into a file will 
follow with no issue.</p>

<p>To scale the inputs ranging from +/- 32768 
down to something a char would hold, i.e. 127 to -128, 
you could multiply each value in your data by 
a ratio of those two values.  Something like:</p>

<pre><code>char ScaleToChar(int x); //prototype

char ScaleToChar(int x)
{
    int a = x;
    float ratio;
    //bound a:  -32768 to 32768
    if (abs(x) &gt; 32768)
    {
        a = (x &gt;= 0) ? (32768) : (-32768);
    }
    //scale x: -128 to 127
    ratio = (a &lt;= 0) ? (128.0/32768.0) : (127.0/32768);

    return (char)(a * ratio);
}
</code></pre>

<p>Using this, your lines:  </p>

<pre><code>  putc((char) ( (unsigned)dif       &amp; 0xff),ausgabe);
  putc((char) (((unsigned)dif &gt;&gt; 8) &amp; 0xff),ausgabe);  
</code></pre>

<p>Would become </p>

<pre><code>  putc(ScaleToChar(dif),ausgabe);
</code></pre>

<p>(I do not know what you are doing with the second call, but if needed, you could do the shift and &amp; op, then call <code>ScaleToChar()</code>)   </p>

<p><em><strong>[EDIT]</em></strong>   </p>

<p>Rather than the scaling approach I originally suggested, I think what you are going to have to do is filter the waveform.  That is, increment through your array of data, and when the waveform approaches the limit (either negative or positive limit) use some history from, say, the last 10 to 15 array values, to determine how you should trend the potentially errant values in such a way that they never violate the limit.  This way, the bulk of your data will never have to be touched.  This will allow fidelity to be be maintained (unlike the scaling approach), at the same time, changes to any modified data will be limited to those data falling within some pre-determined, region extending around the center of the violating section of waveform, and the modification would be limited to values approximating values in the surrounding neighborhood of non-errant values.</p>

<p>A FIR filter approach comes to mind, but something as simple as a running average would also work.  The values of your data not in danger of violating the limits would never have to be touched by the filter.  In concept, this approach does not sound too complicated.  However, as I began to think how I would solve it, I realized that you could get pretty complicated (eg. applying <strong><em><a href=""http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf"" rel=""nofollow"">Kalman filter</a></em></strong> for predictive analysis).  With that said, it can also be kept pretty simple, i.e. such as the simple running average.    </p>
",,24214583,925
19604812,2,19604737,2013-10-26T08:58:00.303,2,,2885815,,2013-10-26T11:48:21.523,2013-10-26T11:48:21.523,11,,"<p>Member function is a member function and that is for a reason. You are calling <code>SendBuffer()</code> as if it was ordinary function defined in a global scope, which it is not. You can call member function in two ways.</p>

<p>First: You create a instance of a class and then you call the method:</p>

<pre><code>CommunicationModuleUSB cm();
cm.SendBuffer(data, sizeof(data));
</code></pre>

<p>Second: You make the method <code>static</code> so the signature is as follows:</p>

<pre><code>static void CommunicationModuleUSB::SendBuffer(uint8_t * Buffer, int Size);
</code></pre>

<p>So declaration would look like so:</p>

<pre><code>class CommunicationModuleUSB
{
    //Other stuff
    static void SendBuffer(uint8_t * Buffer, int Size);
    //Other stuff
}
</code></pre>

<p>and your definition of the function:</p>

<pre><code>void CommunicationModuleUSB::SendBuffer(uint8_t * Buffer, int Size)
{
    //Your code
}
</code></pre>

<p>Now you can call it like this: </p>

<pre><code>CommunicationModuleUSB::SendBuffer(data, sizeof(data));
</code></pre>

<p>BUT this has more implications. Making the method static allows it to access only static member variables of the class as it does not belong to any particular object. This, however, makes sense as calling a method that belongs to a particular object is just the same as calling <code>eat()</code> method of <code>Carrot</code> that doesn't yet exist.</p>
",,24228095,865
35208109,2,19624460,2016-02-04T17:51:04.870,0,,1340478,,2016-02-04T17:51:04.870,,0,,"<p>By my pratice, </p>

<pre><code>INCLUDE_DIRECTORIES(/opt/rpi-rootfs/usr/include)
LINK_DIRECTORIES(
    /opt/rpi-rootfs/usr/lib
    /opt/rpi-rootfs/lib
)
</code></pre>

<p>will work</p>
",,24252372,83
21276414,2,19635007,2014-01-22T07:09:21.960,28,,1804181,,2014-01-22T07:09:21.960,,0,,"<p>I have been researching this for hours today, making and testing various sketches, and have found (as you've already found) changing them to <code>.cpp</code> is a workaround, but if you want to specifically create a c file, you must wrap the prototypes in the header to get it to compile. There are a few good posts about it, but the crux of the issue, in your <code>.h</code> file put:</p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif

void readArms(void);

#ifdef __cplusplus
}
#endif
</code></pre>
",,24254130,145
19659398,2,19657850,2013-10-29T13:20:33.947,6,,2624511,,2013-10-29T13:20:33.947,,4,,"<p>Well, I guess you're okay with all port B and C pins being outputs. Also, you shouldn't need to do anything in assembly on AVR. The assembly-only stuff is available as macros in avr-libc.</p>

<h1>Setup</h1>

<p>First off, you're setting up TCCR0 wrong. You have to set all the bits at once, or you have to use a read-modify-write operation (usually <code>TCCR0 |= _BV(bit_num);</code> to set a bit or <code>TCCR0 &amp;= ~_BV(bit_num);</code> to clear it). (<code>_BV(N)</code> is an avr-libc macro that's more legible than the <code>(1&lt;&lt;N)</code> stuff you're using, but does the same thing.) Also, you're missing the polarity of your PWM output, set by the COM00 and COM01 bits. Right now you have them (implicitly) disabled PWM output (OC0 disconnected).</p>

<p>So I'm going to assume you want a positive-going PWM, i.e. larger PWM input values result in larger high-output duty cycles. This means <code>COM01</code> needs to be set and <code>COM00</code> needs to be cleared. (See pp. 80-81 of the ATmega32(L) data sheet.) This results in the setup line:</p>

<pre><code>TCCR0 = _BV(WGM01) | _BV(WGM00) // PWM mode: Fast PWM.
      | _BV(COM01)              // PWM polarity: active high
      | _BV(CS02) | _BV(CS00);  // PWM clock: CPU_Clock / 1024
</code></pre>

<h1>Duty Cycle</h1>

<p>Now we get to the actual duty cycle generation. Timer 0 is pretty stupid, and hard wires its BOTTOM to <code>0</code> and TOP to <code>0xFF</code>. This means that each PWM period is <code>PWM_Clock / 256</code>, and since you set <code>PWM_Clock</code> to <code>CPU_Clock / 1024</code>, the period is <code>CPU_Clock / 262144</code>, which is about 33 ms for an 8 MHz CPU clock. So each PWM clock, this counter counts up from 0 to 255, then loops back to 0 and repeats.</p>

<p>The actual PWM is generated by the OC circuit per Table 40. For the <code>COM0*</code> setting we have, it says:</p>

<blockquote>
  <p>Clear OC0 on compare match, set OC0 at BOTTOM</p>
</blockquote>

<p>What this means is that each time the counter counts up, it compares the count value to the <code>OCR0</code> register, and if they match it drives the <code>OC0</code> output pin to GND. When the counter wraps around to 0, it drives the pin to VCC.</p>

<p>So to set the duty cycle, you just write a value corresponding to that duty cycle into <code>OCR0</code>:</p>

<pre><code>OCR0 = 0;   // 0% duty cycle: always GND.
OCR0 = 64;  // 25% duty cycle
OCR0 = 128; // 50% duty cycle
OCR0 = 172; // 67% duty cycle
OCR0 = 255; // 100% duty cycle; always VCC. See below.
</code></pre>

<p>That last case is there to resolve a common problem with PWM: the number of possible duty cycle settings is always one more than the number of count steps. In this case, there are 256 steps, and if the output could be VCC for 0, 1, 2, … 256 of those steps, that gives 257 options. So rather than prevent either the 0% or 100% case, they make the one-shy-of-100% case disappear. Note 1 on Table 40 says:</p>

<blockquote>
  <p>A special case occurs when OCR0 equals TOP and COM01 is set. In this case, the compare match is ignored, but the set or clear is done at BOTTOM.</p>
</blockquote>

<p>One more thing: if you write to <code>OCR0</code> in the middle of a PWM cycle, it just waits until the next cycle.</p>

<h1>Simulating Acceleration</h1>

<p>Now to get the ""constant acceleration"" you want, you need to have some kind of standard time base. The <code>TOV0</code> (timer 0 overflow) interrupt might work, or you could use another of the timers or some kind of external reference. You'll use this standard time base to know when to update <code>OCR0</code>.</p>

<p>Constant acceleration just means that the speed changes linearly with time. Taking this a step further, it means that for each update event, you need to change the speed by a constant amount. This is probably nothing more than <a href=""http://en.wikipedia.org/wiki/Saturation_arithmetic"">saturation arithmetic</a>:</p>

<pre><code>#define kAccelStep 4
void accelerate_step() {
    uint8_t x = OCR0;
    if(x &lt; (255 - kAccelStep))
        OCR0 = x + kAccelStep;
    else
        OCR0 = 255;
}
</code></pre>

<p>Just do something like this for each time step and you'll get constant acceleration. A similar algorithm can be used for deceleration, and you could even use fancier algorithms to simulate nonlinear functions or to compensate for the fact that the motor does not instantly go to the PWM-specified speed.</p>
",,24283277,1148
19800016,2,19799576,2013-11-05T22:07:45.183,1,,222421,,2014-01-05T16:48:26.307,2014-01-05T16:48:26.307,0,,"<pre><code>// you will pass two arguments the pot you want to read and the servo you want to write to
void moveServo( potPin, servo ) 
{
    val = analogRead(potPin);
    val = map(val, 0, 1023, 0, 179);
    servo.write(val);
} 

// calling the function

moveServo( potpin1, indexF );
</code></pre>
",,24336285,147
19800206,2,19799576,2013-11-05T22:20:14.440,0,,1478482,,2013-11-05T22:20:14.440,,0,,"<p>I hope that my comments will help you understand the changes.</p>

<p>I'd like to introduce you to two nice rules:
1. Avoid magic numbers - the make the code less readeable and harder to change, because sometimes you have to remember about many places where you use a value
2. classes and structures should be passed by pointer (const pointer if they are not supposed to be changed) or reference (which is much better, for example because you don't have to deal with NULL cases). </p>

<pre><code>/* 

What does this program do:
Allows for a user to control a robotic arm
The current version uses multiple potentiometers to control the hand.

*/

#include &lt;Servo.h&gt; // Library that allows us to use inputs to a 179 degree servo

//Avoid magic numbers
#define MIN_POTENTIOMETER_VAL 0
#define MAX_POTENTIOMETER_VAL 1023

#define MIN_ANGLE 0
#define MAX_ANGLE 179

#define DELAY 27

Servo indexF;  // create servo object to control a servo
Servo middleF;
Servo ringF;
Servo pinkyF;
Servo thumb;
Servo wrist;
Servo forearmBicep;

// first define all of ur pots and servos
const int potpin1 = 0;  // analog pin used to connect the potentiometer
const int potpin2 = 1;  // analog pin used to connect the potentiometer
const int potpin3 = 2;  // analog pin used to connect the potentiometer
const int potpin4 = 3;
const int potpin5 = 4;

//Servo pins
const int indexFPin = 11;
const int middleFPin = 10;
const int ringFPin = 9;
const int pinkyFPin = 6;
const int thumbFPin = 5;


//Function for moving your servo
//servo is a pointer to the Servo struct. It's cheaper and faster to pass pointers, be be aware that you modify original object by that. You can avoid it by adding ""const""
//pin is potpin you want to use, simple variables like int we pass by value, it means they are copied and you can do whatever you want to them, without losing original data
void moveServo(Servo* servo, int pin)
{
  int potentiometerVal = analogRead(pin);
  int mapped = map(potentiometerVal, MIN_POTENTIOMETER_VAL, MAX_POTENTIOMETER_VAL, MIN_ANGLE, MAX_ANGLE);
  if (NULL != servo)
  {
    servo-&gt;write(mapped);
  }
}

void setup() 
{ 
  indexF.attach(indexFPin);  // attaches the servo on pin 9 to the servo object 
  middleF.attach(middleFPin); // Same thing ^^
  ringF.attach(ringFPin);
  pinkyF.attach(pinkyFPin);
  thumb.attach(thumbFPin);
} 

void loop() 
{ 
   //Note ""&amp;"" at the beginning of argument - it means that we pass an address, not the data itself
  moveServo(&amp;indexF, potpin1);
  moveServo(&amp;middleF, potpin2);
  moveServo(&amp;ringF, potpin3);
  moveServo(&amp;pinkyF, potpin4);
  moveServo(&amp;thumb, potpin5);

  delay(DELAY);  // waits for the servo to get there  

} 
</code></pre>

<p>Further reading: Julian Bayle, ""C programming for Arduino"". Awesome book for beginners.</p>
",,24349209,278
19834829,2,19823770,2013-11-07T11:32:44.487,0,,2545784,,2013-11-08T08:10:05.620,2013-11-08T08:10:05.620,0,,"<p>If you want memory reuse - and this is a dangerous place, has you must take really good care about allocation/deallocation responsibility, you should use pointer to string, ie:</p>

<pre><code>#define STATIC_STRING ""Hi there""

void testfunc(char**outStr){
    *outStr=STATIC_STRING;
}

int main(){
   char*myStr;
   testfunc(&amp;myStr);
   //From now on, myStr is a string using preallocated memory.
}
</code></pre>
",,24415243,12710
19873839,2,19846612,2013-11-09T08:10:29.077,-1,,2956363,,2013-11-09T08:10:29.077,,0,,"<p>You Spouse To Have A Threshold When The Sensor is ideling/Static State 
Or litle Naturle Head Movment 
Mmm you Can Try This Code I Think It Will Work For You:</p>

<pre><code>void loop()
{
    int CurrentState = analogRead(AccPin);
     if(CurrentState &gt; ThresHold || CurrentState &lt; ThresHold)
     {boolean IsNoding = CheckForNoding();} 
     if(IsNoding)
     {
         //Do Whatever You Want
     }
     else
     delay(TimeInterVal); 
}

boolean CheckForNoding()
{ 
  Count = 0;
  boolean State = false;
  while(Count&lt;MinToConsiderNode) // Your Case 100?!
  {
      int CurrentState = analogRead(AccPin);
      if(CurrentState &gt; ThresHold || CurrentState &lt; ThresHold)
      {
          int Count ++;
          delay(TimeInterval) // What you Think Should Be The Time Period Between each =&gt; Head Going Up or Down
          State = true;
      }
      else 
        {
            State = false;
            break;
        }
  }

    return State;
}
</code></pre>
",,24420246,64523
19868780,2,19868156,2013-11-08T21:26:27.277,0,,645128,,2013-11-08T23:22:02.907,2013-11-08T23:22:02.907,5,,"<p>Offering this as a suggestion in support of what you are doing...</p>

<p>Would it not be useful to replace all of the nested <code>if()</code>s in your loop with something like:   </p>

<p><em><strong>EDIT</em></strong> added global string to copy myString into once captured  </p>

<pre><code>char globalString[100];//declare a global sufficiently large to hold you results


void loop() 
{
    int chars = mySerial.available();
    int i;
    char *myString;
    if (chars&gt;0)
    {
        myString = calloc(chars+1, sizeof(char));
        for(i=0;i&lt;chars;i++)
        {
            myString[i] = mySerial.read();
            //test for EOF
            if((myString[i] == '\n') ||(myString[i] == '\r'))
            {
                //pick this...
                myString[i]=0;//strip carriage - return line feed(or skip)
                //OR pick this... (one or the other. i.e.,I do not know the requirements for your string)
                if(i&lt;chars)
                {
                    myString[i+1] = mySerial.read() //get remaining '\r' or '\n'
                    myString[i+2]=0;//add null term if necessary
                }

                break;
            }
        }
        if(strstr(myString, ""GPGGA"") == NULL)
          {
               Serial.println(""Not a GPGGA string"");   
               //EDIT
               strcpy(globalString, """");//if failed, do not want globalString populated
          }
          else
          {    //EDIT
               strcpy(globalString, myString);
          }

    }
    //free(myString) //somewhere when you are done with it
}
</code></pre>

<p>Now, <strong><em>the return value</em></strong> from <code>mySerial.available()</code> tells you <strong><em>exactly</em></strong> how many bytes to read, you can read the entire buffer, and test for validity all in one.</p>
",,24427320,109
22084490,2,19868156,2014-02-28T01:38:51.817,0,,3362981,,2014-03-01T01:22:43.730,2014-03-01T01:22:43.730,0,,"<p>I have a project that will need to pull the same information out of the same sentence. 
I got this out of a log file</p>

<pre><code>import serial
import time
ser = serial.Serial(1)

ser.read(1)
read_val = (""nothing"")

gpsfile=""gpscord.dat""
l=0

megabuffer=''
def buffThis(s):
        global megabuffer
        megabuffer +=s
def buffLines():
        global megabuffer
        megalist=megabuffer.splitlines()
        megabuffer=megalist.pop()
        return megalist

def readcom():
        ser.write(""ati"")
        time.sleep(3)
        read_val = ser.read(size=500)
        lines=read_val.split('\n')
        for l in lines:
                if l.startswith(""$GPGGA""):
                        if l[:len(l)-3].endswith(""*""):
                                outfile=open('gps.dat','w')
                                outfile.write(l.rstrip())
                                outfile.close()

readcom()

while 1==1:
    readcom()

answer=raw_input('not looping , CTRL+C to abort')
</code></pre>

<p>The result is this:
gps.dat</p>

<pre><code>$GPGGA,225714.656,5021.0474,N,00412.4420,W,0,00,50.0,0.0,M,18.0,M,0.0,0000*5B
</code></pre>
",,24502466,728
39084933,2,19887409,2016-08-22T16:57:28.703,1,,6744018,,2016-08-22T17:34:44.147,2016-08-22T17:34:44.147,0,,"<p>I have designed a sketch for driving 10 (or more) RGB LEDs with the TLC5940 on my Arduino uno. This may also work on the nano. I am drive 10 common anode rgb leds on 30 channels with two TLC5940's daisy chained together. We can achieve more so long as you configure how many TLC5940 chips you are using. This works with the 12 bit duty cycle control (0 - 4095).</p>

<ol>
<li><p>In arduino IDE you must import the TLC5940 Library by Paul Stoffregen from here:  <a href=""https://github.com/PaulStoffregen/Tlc5940"" rel=""nofollow noreferrer"">https://github.com/PaulStoffregen/Tlc5940</a>.</p></li>
<li><p>Edit the tlc_config.h file where NUM_TLCs should equal 2 (by default it is 1):</p>

<p>""#define NUM_TLCS   2""</p></li>
<li><p>Now we can take a look at the sketch to run the thing</p></li>
</ol>

<p>Here is the Wiring for the sketch:
<a href=""https://i.stack.imgur.com/asg0A.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/asg0A.png"" alt=""enter image description here""></a></p>

<p>Although this depicts single color leds I will map my rgb pins 0-2, 3-5, 6-8, 9-11...Etc. </p>

<p>CODE:</p>

<pre><code>#include ""Tlc5940.h""

int rgbChannels = 30;//total channels used one the TLC5940's
int rgb[30]; ///should be the same as the number of channels
int rgbLights = 10;/// this is the number of rgb leds possible on 2 TLC5940's but you could always daisy chain more...
int colorArray[10];//this sets the number of colors to use (one per rgb led)

void setup() {
  // put your setup code here, to run once
  Tlc.init(0); // Initiates the TLC5940 and set all channels off
  Serial.begin(250000);
  Serial.println(""Total Channels: "" + String(rgbChannels) + ""  Total
RGB Ligts: "" + String(rgbLights));
  float divisor = 360 / (rgbChannels / 3); //degrees of color to
display divided by the number of rgb lights
  Serial.println(""Divisor: "" + String(divisor) );
  float Step = divisor;
  for (int i = 0; i &lt; rgbLights; i++) {
    colorArray[i] = Step;
    Serial.println(""colorArray["" + String(i) + ""]: "" + String(colorArray[i]));
    Step = Step + divisor;
  }
}

void ledColor(int channel, int red, int green, int blue)
{
  Tlc.set(channel, red);
  Tlc.set(channel + 1, green);
  Tlc.set(channel + 2, blue);
}

///convert hsi color to rgb
void hsi_to_rgb(int startChannel, float H, float S, float I) {
  int r, g, b;
  if (H &gt; 360) {
    H = H - 360;
  }
  // Serial.println(""H: ""+String(H));
  H = fmod(H, 360); // cycle H around to 0-360 degrees
  H = 3.14159 * H / (float)180; // Convert to radians.
  S = S &gt; 0 ? (S &lt; 1 ? S : 1) : 0; // clamp S and I to interval [0,1]
  I = I &gt; 0 ? (I &lt; 1 ? I : 1) : 0;
  if (H &lt; 2.09439) {
    r = 4095 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    g = 4095 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    b = 4095 * I / 3 * (1 - S);
  } else if (H &lt; 4.188787) {
    H = H - 2.09439;
    g = 4095 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    b = 4095 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    r = 4095 * I / 3 * (1 - S);
  } else {
    H = H - 4.188787;
    b = 4095 * I / 3 * (1 + S * cos(H) / cos(1.047196667 - H));
    r = 4095 * I / 3 * (1 + S * (1 - cos(H) / cos(1.047196667 - H)));
    g = 4095 * I / 3 * (1 - S);
  }
  rgb[0 + startChannel] = r;
  rgb[1 + startChannel] = g;
  rgb[2 + startChannel] = b;

}


void rainbowShift() {
  float brightness = .4;
  float saturation = 1;
  for (int n = 0; n &lt;= 360; n++) {
    for (int i = 0, j = 0; i &lt; rgbLights; i++) {
      hsi_to_rgb(j, colorArray[i] + n, saturation, brightness);
      //Serial.println(""rgb""+String(i)+"":""+String(rgb[j])+"",""+String(rgb[j+1])+"",""+String(rgb[j+2]));
      ledColor(j, rgb[j], rgb[j + 1], rgb[j + 2]);
      j = j + 3;
    }
    Tlc.update();
    Tlc.clear();
    delayMicroseconds(500);
  }
}



void loop() {
  // put your main code here, to run repeatedly:
rainbowShift();////perform the function a few times

}
</code></pre>

<p>When all is done you should end up with a shifting rainbow of color over your RGB LEDs</p>

<p>Check out this video:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/CWdL9i8U8U0"" frameborder=""0"" allowfullscreen&gt;&lt;/iframe&gt;</code></pre>
</div>
</div>
</p>

<p>Here is an Image of the result:
<a href=""https://i.stack.imgur.com/CEvGQ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CEvGQ.jpg"" alt=""enter image description here""></a></p>
",,24509288,240
19889148,2,19888714,2013-11-10T11:27:29.683,2,,2896321,,2013-11-10T13:17:09.543,2013-11-10T13:17:09.543,4,,"<p>Before answering your questions, let's look at what's going wrong with solutions 1 and 2.</p>

<p>The problem with solutions 1 and 2 is that you're using an initialiser ( i.e. the `{} syntax ), where your compiler is expecting an assignment expression. </p>

<p>Initialisation syntax can only be used at the point where the variable is declared. Roughly speaking, initialisation should be understood as giving a value to a variable as soon as it is constructed. Assignment should be understood as giving a value to a variable that has already been constructed somewhere else.</p>

<p>So when you do: </p>

<pre><code>unsigned char** codes = new unsigned char*[NR_OF_CODES];
</code></pre>

<p>You are doing initialisation. You are initialising the variable <code>codes</code> to a freshly allocated array of pointers to <code>unsigned char</code>.</p>

<p>On the next line, you are then telling the compiler you are doing an assignment. You're using the <code>=</code> sign and assigning to <code>codes</code>, which was declared on the previous line - compiler sees this as assignment.</p>

<pre><code>codes[RADIO_ONOFF] = new unsigned char[CODE_LENGTH] ... 
</code></pre>

<p>But then, immediately afterwards, you attempt to use initialisation syntax. </p>

<p>Your compiler is complaining because it's read this:</p>

<pre><code>codes[RADIO_ONOFF] = new unsigned char[CODE_LENGTH] ... 
</code></pre>

<p>as a complete expression. It read that as you're allocating an array of CODE_LENGTH bytes and assigning it to the <code>RADIO_ONOFF</code> th member of <code>codes</code>.</p>

<p>And it expected you to stop there, with a semi colon but you continued and added the initalisation syntax <code>{}</code>. It doesn't understand, because you are mixing assignment and initialisation together - which are two separate things.  That's why you're getting the ""I expect a semi colon"" type error from the compiler.</p>

<p>To answer your questions, both solution 3 and 4 are taking the long way round. There are quicker ways of initialising a 2D array in C++. I also agree with previous answer about using <code>uint8_t</code>.</p>

<p>Would something like this be more suitable?</p>

<pre><code>uint8_t codes[CODE_LENGTH][NR_OF_CODES] = 
                              {{0, 1, 2, 3, 4, 5, 6, 7}, 
                              {0, 1, 2, 3, 4, 5, 6, 7}, 
                              {0, 1, 2, 3, 4, 5, 6, 7}, 
                              {0, 1, 2, 3, 4, 5, 6, 7} };
</code></pre>

<p>A good way to read array syntax is to take the final (rightmost) value in the square brackets <code>[]</code> as the size of some array, and then work backwards.</p>

<p>So <code>uint8_t codes[CODE_LENGTH][NR_OF_CODES]</code> will decode out to an array of size <code>NR_OF_CODES</code> of  <em>something</em>. And to get that <em>something</em> go left, and we see <code>uint8_t codes[CODE_LENGTH]</code> - so it's an array of length <code>NR_OF_CODES</code> of arrays of <code>uint8_t</code>, each of length <code>CODE_LENGTH</code>.</p>

<p>I hope that helps.</p>

<p>NB. In answer to your comment about needing to index the array with named indices - there's nothing stopping you from referring to the individual members of <code>codes</code> via an index.
What you can do is initialise the whole thing via {0} - shorthand for initialising all members to 0.</p>

<p>And you can assign members of the <code>RADIO_ONOFF</code> array (or any array for that matter) individually e.g.</p>

<pre><code>codes[RADIO_ONOFF][3] = 255;
</code></pre>

<p>Try this example - and note the output:</p>

<pre><code>  #include &lt;iostream&gt;

  const int NR_OF_CODES = 4;
  const int RADIO_ONOFF = 0;
  const int CODE_LENGTH = 11;

  const unsigned char RADIO_ONOFF_ARR[] = { 180,99,33,11,22,33,55, 22,22,33, 10};

  int main()
  {
    unsigned char codes[CODE_LENGTH][NR_OF_CODES] = {
                                                   {0},
                                                  };
    std::cout &lt;&lt; ""Before:\n"";

    for(int x = 0; x &lt; CODE_LENGTH; x++)
    {
      std::cout &lt;&lt; static_cast&lt;int&gt;(codes[RADIO_ONOFF][x]) &lt;&lt; "", "";
    }

    codes[RADIO_ONOFF][3] = 3;

    std::cout &lt;&lt; ""\nAfter:\n"";

    for(int x = 0; x &lt; CODE_LENGTH; x++)
    {
      std::cout &lt;&lt; static_cast&lt;int&gt;(codes[RADIO_ONOFF][x]) &lt;&lt; "", "";
    }

    // or try memcpy 
    memcpy(codes[RADIO_ONOFF], RADIO_ONOFF_ARR, sizeof RADIO_ONOFF_ARR);

    std::cout &lt;&lt; ""\nAfter Memcpy:\n"";

    for(int x = 0; x &lt; CODE_LENGTH; x++)
    {
      std::cout &lt;&lt; static_cast&lt;int&gt;(codes[RADIO_ONOFF][x]) &lt;&lt; "", "";
    }

    char c;
    std::cin &gt;&gt; c;
    return 0;
  }
</code></pre>
",,24589235,3004
19894433,2,19894323,2013-11-10T20:00:33.897,2,,2354107,,2013-11-10T20:39:05.603,2013-11-10T20:39:05.603,8,,"<p>I think this is your error:</p>

<pre><code>string SerialComm::read_data() {
    int state = 1;
    int receivedbyte = 0;  // never used!

    while (true) {
        state = read(fd, buffer, BUFFER_SIZE);
        if (state &gt; 0) 
        {
            return string( buffer );
        }
    }
    buffer[receivedbyte + 1] = '\0';  // never reached!  And ""off-by-one"" if it were...
}
</code></pre>

<p>This might work better:</p>

<pre><code>string SerialComm::read_data() {
    int receivedbyte = 0;

    while (true) {
        receivedbyte = read(fd, buffer, BUFFER_SIZE - 1);
        if (receivedbyte &gt; 0) 
        {
            buffer[receivedbyte] = '\0';
            return string( buffer );
        }
    }
}
</code></pre>

<p>That should eliminate any garbage that you were seeing due to unterminated strings.  That said, to get nice newline-terminated strings, you probably need an outer loop to look for those boundaries and divide the stream properly that way.</p>

<p>One way to do that might be this:  Declare a <code>string received</code> in your class to hold all buffered input that hasn't yet been returned to the caller.  Then, rewrite read_data() as follows:</p>

<pre><code>string SerialComm::read_data()
{
    while (true)
    {
        size_t pos = received.find_first_of('\n', 0);
        if (pos != string::npos)
        {
            string result = received.substr(0, pos);
            received.erase(0, pos);
            return result;
        }

        int receivedbytes;
        do
        {
            receivedbytes = read(fd, buffer, BUFFER_SIZE - 1);
        } while (receivedbytes == 0);

        if (receivedbytes &lt; 0)
            abort();  // error... you might want to handle it more cleanly, though

        buffer[receivedbytes] = 0;
        received += string( buffer );
    }
}            
</code></pre>

<p>If you'd like a version that returns an empty string when there no complete line to see, as opposed to waiting forever for data, you can use this version of code.  Note:  If there's buffered data with no terminating newline, it will hold onto it until it does see the terminating newline.  You might want to add a separate <code>flush</code> method to make that data visible.</p>

<pre><code>string SerialComm::read_data()
{
    while (true)
    {
        size_t pos = received.find_first_of('\n', 0);
        if (pos != string::npos)
        {
            string result = received.substr(0, pos);
            received.erase(0, pos);
            return result;
        }

        int receivedbytes = read(fd, buffer, BUFFER_SIZE - 1);

        if (receivedbytes &lt; 0)
            abort();  // error... you might want to handle it more cleanly, though

        if (receivedbytes == 0)
            return string();  // nothing to see yet

        // Add received data to buffer and loop to see if we have a newline yet.           
        buffer[receivedbytes] = 0;
        received += string( buffer );
    }
}            
</code></pre>
",,24597929,16046
20196833,2,20019618,2013-11-25T15:29:07.723,0,,1496472,,2013-11-25T15:29:07.723,,0,,"<p>for a more general approach...</p>

<pre><code>if (rxChardata == ':') {
    // Consume the ':'
    rxCharData = TinyWireS.receive();
    int n = 0;
    while (isdigit(rxCharData)) {
        n = n * 10 + (rxCharData - '0');
        rcCharData = TinyWireS.receive();
    }
    Serial.println(n);
}
</code></pre>

<p>But you will need to check what happens when you call TinyWireS.receive() and there are no more digits... does it return '\0'? In which case the above will work.</p>
",,24605439,3535
26957528,2,20081286,2014-11-16T13:33:01.490,0,,181944,,2014-11-16T13:33:01.490,,0,,"<p>I got wiringPi to do it through software bit-banging. I might have tried RPIO but my particular application requires that the audio output works, and I understand that RPIO's DMA makes audio go away.  I might have also tried wiringPi's softPwm or even softServo, but I also require to run a DC motor through PWM, and I don't want to bring the whole system down to 50Hz just for the servo.</p>

<p>This program worked as a demonstration, has no jitter (because it doesn't continuously drive the positioning pulses), and lands on its target each time with a visibly indistinguishable error. Granted the Pi isn't doing much else at the time to interfere with the program's timing (except running an X server through SSH, gedit, terminal session, everything in <code>top</code>, etc.).</p>

<pre><code>// Servo trial 11/15/14 by SLC

#include &lt;wiringPi.h&gt;

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    wiringPiSetup();
    pinMode( 6, OUTPUT );
    digitalWrite( 6,  HIGH );

    int idx = 0, tries = 0;
    while ( tries++ &lt; 30 )
    {
        int i;
        const int period[] = { 500, 1500, 2500 };

        printf( ""Setting period to %i ms\n"", period[idx] );
        for ( i = 0; i &lt; 20; ++i )
        {
            // Output going through an inverter (to convert 3.3V to 5V)
            digitalWrite( 6, LOW );
            usleep( period[idx] );
            digitalWrite( 6,  HIGH );
            usleep( 20 * 1000 );
        }
        ++idx;
        idx %= 3;

        sleep( 2 );
    }
}
</code></pre>

<p>My servo is a Radio Shack Micro Servo, which appears identical to the other ""micro"" servos out there. I also found I could ditch the inverter and just drive the signal using the 3.3V GPIO.</p>
",,24605718,1671
27750179,2,20081286,2015-01-02T23:50:20.640,6,,1606576,,2015-01-02T23:50:20.640,,2,,"<pre><code>if (wiringPiSetup () == -1) //using wPi pin numbering
 exit (1) ;

pinMode(1, PWM_OUTPUT);
pwmSetMode(PWM_MODE_MS); 
pwmSetClock(384); //clock at 50kHz (20us tick)
pwmSetRange(1000); //range at 1000 ticks (20ms)
pwmWrite(1, 75);  //theretically 50 (1ms) to 100 (2ms) on my servo 30-130 works ok
return 0 ;
</code></pre>

<p>Make sure you are using correct gpio pins! </p>

<p>Models A and B have one hardware PWM on pin 18 BCM (1 wPi). </p>

<p>Models A+ and B+ can output second hardware pwm on pins 13 and 19 BCM (23, 24 wPi)</p>
",,24654293,145
20136713,2,20131002,2013-11-22T03:53:25.127,1,,1858683,,2013-11-22T03:53:25.127,,0,,"<p>So there were two bugs in my code. First, I upped the counter to interrupt at 250KHz (4us). Secondly, the way I was setting my BAM levels (near the end of the ISR) was incorrect. I forgot that I have a common anode LED, which means that in order to turn on a color, I have to set the corresponding pin LOW, not HIGH as shown in my example. The fixed segments are located below. Thank you all who looked at this.</p>

<pre><code>void InitTimer(){
    TCCR1A = 0;
    TCCR1B = 0;
    TCNT1  = 0;

    TCCR1A = B00000000;
    TCCR1B = B00001011;
    OCR1A=30;
    TIMSK1 = B00000010;
}

ISR(...){
 ........
if(green &amp; (1&lt;&lt;BAM_pos))
    PORTD &amp;= ~(1&lt;&lt;PORTD4);
else 
   PORTD |= (1&lt;&lt;PORTD4);

if(blue &amp; (1&lt;&lt;BAM_pos))
    PORTB &amp;= ~(1&lt;&lt;PORTB0);
else 
    PORTB |= (1&lt;&lt;PORTB0);
}
</code></pre>
",,24715359,391
20205673,2,20204391,2013-11-25T23:31:37.187,5,,2354107,,2013-11-25T23:31:37.187,,7,,"<p>If the Arduino toolchain supports GCC extensions (and some quick searching suggests it does), then you can use <code>__attribute__((noinline))</code> to disable inlining on these functions like so:</p>

<pre><code>bool getDispPixel(uint8_t x, uint8_t y, uint8_t num) __attribute__((noinline));
bool getDispPixel(uint8_t x, uint8_t y, uint8_t num)
{
    // body of the function here
}

void setDispPixel(uint8_t x, uint8_t y, uint8_t num, bool state) __attribute((noinline));
void setDispPixel(uint8_t x, uint8_t y, uint8_t num, bool state)
{
    // body of the function here
}
</code></pre>

<p>The extra line looks redundant, but isn't.  It's how the syntax for the extension works.</p>
",,24741765,980
20226964,2,20209975,2013-11-26T20:09:30.913,0,,868707,,2013-11-26T20:09:30.913,,0,,"<p>Here's how I fixed my problem.</p>

<p>First I built the APDU properly on the Android side. My original response APDU was simply a byte array of the hash without the required SW1 and SW2 bytes.</p>

<p>Then on the Arduino side of things, here's how I got the hash back out of it:</p>

<pre><code>        uint8_t response[64];

        uint8_t responseLength = sizeof(response);

        if (nfc.inDataExchange(message, sizeof(message), response, &amp;responseLength)) {

            String respBuffer;

            for (int i = 0; i &lt; 16; i++) {
                if (response[i] &lt; 0x10) respBuffer = respBuffer + ""0"";
                respBuffer = respBuffer + String(response[i], HEX);                        
            }

            Serial.println(respBuffer);

        }
</code></pre>

<p>Hope this helps someone.</p>
",,24757939,1094
20233455,2,20233454,2013-11-27T03:40:43.843,4,,1700270,,2013-11-27T03:40:43.843,,3,,"<p>Ah, you juvenile fool, Ryan! Have you no understanding of data types!? </p>

<p><a href=""http://arduino.cc/en/Reference/Pow"" rel=""nofollow"">The Arduino pow() reference</a> explicitly states that these values must be passed as floats and returned as doubles! So let's use some brain cells and at least try returning a double!</p>

<p>Here's some code to highlight the craziness that's going on:</p>

<pre><code>for (int n=0;n&lt;5;n++)
{
    double x = pow(2,n);
    Serial.print(n); 
    Serial.print("" "");
    Serial.print(x);
    Serial.print("" "");
    Serial.println((int)x); // cast as int here
}
</code></pre>

<p>And here's your output:</p>

<pre><code>0 1.00 1
1 2.00 2
2 4.00 3
3 8.00 7
4 16.00 15
</code></pre>

<p>Anyway, that will solve your problem. Casting the number as an int shows that it gets rounded down.</p>

<hr>

<p>Now, why does this happen? Not exactly sure.</p>
",,24800937,1708
47531206,2,20233454,2017-11-28T12:04:53.097,1,,463687,,2017-11-28T12:04:53.097,,0,,"<p>Just as a complement to Ignacio Vazquez-Abrams' answer (which is the
right answer), I wrote the following program to test for the accuracy of
<code>pow(2, i)</code> for positive integer values of <code>i</code>:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;inttypes.h&gt;

int main(void)
{
    printf(""  i          2^i     correct   pow(2, i)         error  ulps\n"");
    printf(""------------------------------------------------------------\n"");
    union { float f; uint32_t i; } x, y;
    x.f = 1;                    // 2^i, correct value
    float ulp_r = FLT_EPSILON;  // ULP to the right of x
    for (int i = 0; i &lt; 128; i++, x.f *= 2, ulp_r *= 2) {
        y.f = pow(2, i);
        float error = y.f - x.f;
        float ulp = error &lt; 0 ? ulp_r/2 : ulp_r;  // ULP(x - error)
        printf(""%3d  %11.6g  0x%08""PRIx32""  0x%08""PRIx32""  %12.6g  %4g\n"",
                i, x.f, x.i, y.i, error, error/ulp);
    }
    return 0;
}
</code></pre>

<p>On my PC (gcc 5.4.0 / Ubuntu 16.04), this program reports zero errors.
Running the same program (with proper stdio setup) on an Arduino Uno
(avr-gcc 4.9.2 / avr-libc 1.8.0), I get errors as big as
90&nbsp;<a href=""https://en.wikipedia.org/wiki/Unit_in_the_last_place"" rel=""nofollow noreferrer"">ULPs</a>! Here is the output from the Uno:</p>

<pre class=""lang-none prettyprint-override""><code>  i          2^i     correct   pow(2, i)         error  ulps
------------------------------------------------------------
  0            1  0x3f800000  0x3f800000             0     0
  1            2  0x40000000  0x40000000             0     0
  2            4  0x40800000  0x407ffffe  -4.76837e-07    -2
  3            8  0x41000000  0x40fffffc  -1.90735e-06    -4
  4           16  0x41800000  0x417ffffc   -3.8147e-06    -4
  5           32  0x42000000  0x41fffffa  -1.14441e-05    -6
  6           64  0x42800000  0x427ffffa  -2.28882e-05    -6
  7          128  0x43000000  0x42fffffa  -4.57764e-05    -6
  8          256  0x43800000  0x437ffffa  -9.15527e-05    -6
  9          512  0x44000000  0x43fffff4  -0.000366211   -12
 10         1024  0x44800000  0x447ffff4  -0.000732422   -12
 11         2048  0x45000000  0x44fffff4   -0.00146484   -12
 12         4096  0x45800000  0x457ffff4   -0.00292969   -12
 13         8192  0x46000000  0x46000000             0     0
 14        16384  0x46800000  0x467ffff4    -0.0117188   -12
 15        32768  0x47000000  0x46fffff4    -0.0234375   -12
 16        65536  0x47800000  0x477ffff4     -0.046875   -12
 17       131072  0x48000000  0x48000000             0     0
 18       262144  0x48800000  0x487fffea      -0.34375   -22
 19       524288  0x49000000  0x48ffffea       -0.6875   -22
 20  1.04858e+06  0x49800000  0x497fffea        -1.375   -22
 21  2.09715e+06  0x4a000000  0x4a000000             0     0
 22   4.1943e+06  0x4a800000  0x4a7fffea          -5.5   -22
 23  8.38861e+06  0x4b000000  0x4affffea           -11   -22
 24  1.67772e+07  0x4b800000  0x4b7fffea           -22   -22
 25  3.35544e+07  0x4c000000  0x4c000000             0     0
 26  6.71089e+07  0x4c800000  0x4c800000             0     0
 27  1.34218e+08  0x4d000000  0x4cffffea          -176   -22
 28  2.68435e+08  0x4d800000  0x4d7fffea          -352   -22
 29  5.36871e+08  0x4e000000  0x4e000000             0     0
 30  1.07374e+09  0x4e800000  0x4e7fffea         -1408   -22
 31  2.14748e+09  0x4f000000  0x4effffea         -2816   -22
 32  4.29497e+09  0x4f800000  0x4f7fffea         -5632   -22
 33  8.58993e+09  0x50000000  0x50000000             0     0
 34  1.71799e+10  0x50800000  0x50800000             0     0
 35  3.43597e+10  0x51000000  0x50ffffd2        -94208   -46
 36  6.87195e+10  0x51800000  0x517fffd2       -188416   -46
 37  1.37439e+11  0x52000000  0x52000000             0     0
 38  2.74878e+11  0x52800000  0x527fffd2       -753664   -46
 39  5.49756e+11  0x53000000  0x52ffffd2  -1.50733e+06   -46
 40  1.09951e+12  0x53800000  0x537fffd2  -3.01466e+06   -46
 41  2.19902e+12  0x54000000  0x54000000             0     0
 42  4.39805e+12  0x54800000  0x54800000             0     0
 43  8.79609e+12  0x55000000  0x54ffffd2  -2.41172e+07   -46
 44  1.75922e+13  0x55800000  0x557fffd2  -4.82345e+07   -46
 45  3.51844e+13  0x56000000  0x56000000             0     0
 46  7.03687e+13  0x56800000  0x567fffd2  -1.92938e+08   -46
 47  1.40737e+14  0x57000000  0x57000000             0     0
 48  2.81475e+14  0x57800000  0x577fffd2  -7.71752e+08   -46
 49   5.6295e+14  0x58000000  0x57ffffd2   -1.5435e+09   -46
 50   1.1259e+15  0x58800000  0x58800000             0     0
 51   2.2518e+15  0x59000000  0x58ffffd2  -6.17402e+09   -46
 52   4.5036e+15  0x59800000  0x59800000             0     0
 53   9.0072e+15  0x5a000000  0x5a000000             0     0
 54  1.80144e+16  0x5a800000  0x5a7fffd2  -4.93921e+10   -46
 55  3.60288e+16  0x5b000000  0x5b000000             0     0
 56  7.20576e+16  0x5b800000  0x5b7fffd2  -1.97568e+11   -46
 57  1.44115e+17  0x5c000000  0x5bffffd2  -3.95137e+11   -46
 58   2.8823e+17  0x5c800000  0x5c800000             0     0
 59  5.76461e+17  0x5d000000  0x5cffffd2  -1.58055e+12   -46
 60  1.15292e+18  0x5d800000  0x5d7fffd2   -3.1611e+12   -46
 61  2.30584e+18  0x5e000000  0x5e000000             0     0
 62  4.61169e+18  0x5e800000  0x5e7fffd2  -1.26444e+13   -46
 63  9.22337e+18  0x5f000000  0x5f000000             0     0
 64  1.84467e+19  0x5f800000  0x5f7fffd2  -5.05775e+13   -46
 65  3.68935e+19  0x60000000  0x5fffffa6  -1.97912e+14   -90
 66   7.3787e+19  0x60800000  0x60800000             0     0
 67  1.47574e+20  0x61000000  0x60ffffa6  -7.91648e+14   -90
 68  2.95148e+20  0x61800000  0x61800000             0     0
 69  5.90296e+20  0x62000000  0x61ffffa6  -3.16659e+15   -90
 70  1.18059e+21  0x62800000  0x627fffa6  -6.33319e+15   -90
 71  2.36118e+21  0x63000000  0x63000000             0     0
 72  4.72237e+21  0x63800000  0x637fffa6  -2.53327e+16   -90
 73  9.44473e+21  0x64000000  0x63ffffa6  -5.06655e+16   -90
 74  1.88895e+22  0x64800000  0x64800000             0     0
 75  3.77789e+22  0x65000000  0x64ffffa6  -2.02662e+17   -90
 76  7.55579e+22  0x65800000  0x657fffa6  -4.05324e+17   -90
 77  1.51116e+23  0x66000000  0x65ffffa6  -8.10648e+17   -90
 78  3.02231e+23  0x66800000  0x667fffa6   -1.6213e+18   -90
 79  6.04463e+23  0x67000000  0x67000000             0     0
 80  1.20893e+24  0x67800000  0x677fffa6  -6.48518e+18   -90
 81  2.41785e+24  0x68000000  0x67ffffa6  -1.29704e+19   -90
 82   4.8357e+24  0x68800000  0x68800000             0     0
 83  9.67141e+24  0x69000000  0x68ffffa6  -5.18815e+19   -90
 84  1.93428e+25  0x69800000  0x69800000             0     0
 85  3.86856e+25  0x6a000000  0x69ffffa6  -2.07526e+20   -90
 86  7.73713e+25  0x6a800000  0x6a7fffa6  -4.15052e+20   -90
 87  1.54743e+26  0x6b000000  0x6b000000             0     0
 88  3.09485e+26  0x6b800000  0x6b7fffa6  -1.66021e+21   -90
 89   6.1897e+26  0x6c000000  0x6bffffa6  -3.32041e+21   -90
 90  1.23794e+27  0x6c800000  0x6c800000             0     0
 91  2.47588e+27  0x6d000000  0x6cffffa6  -1.32817e+22   -90
 92  4.95176e+27  0x6d800000  0x6d7fffa6  -2.65633e+22   -90
 93  9.90352e+27  0x6e000000  0x6dffffa6  -5.31266e+22   -90
 94   1.9807e+28  0x6e800000  0x6e800000             0     0
 95  3.96141e+28  0x6f000000  0x6f000000             0     0
 96  7.92282e+28  0x6f800000  0x6f7fffa6  -4.25013e+23   -90
 97  1.58456e+29  0x70000000  0x6fffffa6  -8.50026e+23   -90
 98  3.16913e+29  0x70800000  0x707fffa6  -1.70005e+24   -90
 99  6.33825e+29  0x71000000  0x71000000             0     0
100  1.26765e+30  0x71800000  0x71800000             0     0
101   2.5353e+30  0x72000000  0x71ffffa6  -1.36004e+25   -90
102   5.0706e+30  0x72800000  0x727fffa6  -2.72008e+25   -90
103  1.01412e+31  0x73000000  0x72ffffa6  -5.44017e+25   -90
104  2.02824e+31  0x73800000  0x73800000             0     0
105  4.05648e+31  0x74000000  0x74000000             0     0
106  8.11296e+31  0x74800000  0x74800000             0     0
107  1.62259e+32  0x75000000  0x74ffffa6  -8.70427e+26   -90
108  3.24519e+32  0x75800000  0x757fffa6  -1.74085e+27   -90
109  6.49037e+32  0x76000000  0x75ffffa6  -3.48171e+27   -90
110  1.29807e+33  0x76800000  0x76800000             0     0
111  2.59615e+33  0x77000000  0x77000000             0     0
112   5.1923e+33  0x77800000  0x777fffa6  -2.78537e+28   -90
113  1.03846e+34  0x78000000  0x77ffffa6  -5.57073e+28   -90
114  2.07692e+34  0x78800000  0x787fffa6  -1.11415e+29   -90
115  4.15384e+34  0x79000000  0x79000000             0     0
116  8.30767e+34  0x79800000  0x79800000             0     0
117  1.66153e+35  0x7a000000  0x79ffffa6  -8.91317e+29   -90
118  3.32307e+35  0x7a800000  0x7a7fffa6  -1.78263e+30   -90
119  6.64614e+35  0x7b000000  0x7affffa6  -3.56527e+30   -90
120  1.32923e+36  0x7b800000  0x7b7fffa6  -7.13053e+30   -90
121  2.65846e+36  0x7c000000  0x7c000000             0     0
122  5.31691e+36  0x7c800000  0x7c800000             0     0
123  1.06338e+37  0x7d000000  0x7cffffa6  -5.70443e+31   -90
124  2.12676e+37  0x7d800000  0x7d7fffa6  -1.14089e+32   -90
125  4.25353e+37  0x7e000000  0x7dffffa6  -2.28177e+32   -90
126  8.50706e+37  0x7e800000  0x7e800000             0     0
127  1.70141e+38  0x7f000000  0x7f000000             0     0
</code></pre>

<p>A few points worth noting:</p>

<ul>
<li>every power of two between <code>FLT_MIN</code> and <code>FLT_MAX</code> is exactly
representable as a <code>float</code></li>
<li>the IEEE-754 standard requires the operations +, −, ×, ÷ and √ to be
correctly rounded, which implies that computing 2<sup>i</sup> by
iteratively multiplying by 2 is guaranteed to give the exact result</li>
<li>the same standard does <em>not</em> require <code>pow</code> to be correctly rounded.</li>
</ul>
",,24812235,195
20246645,2,20237657,2013-11-27T15:36:48.843,0,,63743,,2013-11-27T15:36:48.843,,1,,"<p>These are the include paths your compiler is looking at.  Is Poco/Net in there somewhere?</p>

<pre><code>-I/usr/local/qt5pi/mkspecs/devices/linux-rasp-pi-g++ 
-I../../../BeatQtPlayer/src/pocowebserverplugin 
-I../../../BeatQtPlayer/src 
-I/home/jon/tmp/BeatQtPlayer/src/pocowebserverplugin/../../external_tools/poco-1.4.6p2/lib_raspberrypi/include 
-I/mnt/rasp-pi-rootfs/usr/local/qt5pi/include 
-I/mnt/rasp-pi-rootfs/usr/local/qt5pi/include/QtNetwork 
-I/mnt/rasp-pi-rootfs/usr/local/qt5pi/include/QtCore 
-I. 
-I. 
</code></pre>
",,24849124,506
20258361,2,20257486,2013-11-28T05:27:41.593,1,,1967396,,2013-11-28T05:27:41.593,,0,,"<p>I suppose you could do this ""the old fashioned (uphill both ways) way"":</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void){
    int *x[3][3];
    int y[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
    x[0][0] = &amp;y[0];
    x[0][1] = &amp;y[2];
    x[1][0] = &amp;y[4];
    x[2][0] = &amp;y[6];
    x[2][1] = &amp;y[8];
    x[2][2] = &amp;y[10];
    // testing:
    printf(""x[0][0][0] = %d\n"", x[0][0][0]);
    printf(""x[0][0][1] = %d\n"", x[0][0][1]);
    printf(""x[0][1][0] = %d\n"", x[0][1][0]);
    printf(""x[0][1][1] = %d\n"", x[0][1][1]);
    printf(""x[1][0][0] = %d\n"", x[1][0][0]);
    printf(""x[1][0][1] = %d\n"", x[1][0][1]);
    printf(""x[2][0][0] = %d\n"", x[2][0][0]);
    printf(""x[2][0][1] = %d\n"", x[2][0][1]);
    printf(""x[2][1][0] = %d\n"", x[2][1][0]);
    printf(""x[2][1][1] = %d\n"", x[2][1][1]);
    printf(""x[2][2][1] = %d\n"", x[2][2][0]);
    printf(""x[2][2][1] = %d\n"", x[2][2][1]);
  return 0;
}
</code></pre>

<p>Basically, the array <code>x</code> is a little bit too big (3x3) and it points to the ""right place"" in the array <code>y</code> that contains your data (I am using the digits 1…12 because it's easier to see it is doing the right thing). For a small example like this, you end up with an array of 9 pointers in <code>x</code> (72 bytes), plus the 12 integers in y (48 bytes).</p>

<p>If you filled an <code>int</code> array with zeros where you didn't need values (or <code>-1</code> if you wanted to indicate ""invalid"") you would end up with 18x4 = 72 bytes. So the above method is less efficient - because this array is not ""very sparse"". As you change the degree of raggedness, this gets better. If you really wanted to be efficient you would have an array of pointers-of-pointers, followed by n arrays of pointers - but this gets very messy very quickly.</p>

<p>Very often the right approach is a tradeoff between speed and memory size (which is always at a premium on the Arduino).</p>

<p>By the way - the above code does indeed produce the output</p>

<pre><code>x[0][0][0] = 1
x[0][0][1] = 2
x[0][1][0] = 3
x[0][1][1] = 4
x[1][0][0] = 5
x[1][0][1] = 6
x[2][0][0] = 7
x[2][0][1] = 8
x[2][1][0] = 9
x[2][1][1] = 10
x[2][2][1] = 11
x[2][2][1] = 12
</code></pre>

<p>Of course it doesn't stop you from accessing an invalid array element - and doing so will generate a seg fault (since the unused elements in <code>x</code> are probably invalid pointers).</p>
",,24856173,90
20305347,2,20305267,2013-11-30T20:36:05.107,0,,1561971,,2013-11-30T20:36:05.107,,0,,"<p>This will work for any input string:</p>

<pre><code>char * item = strtok (stringToParse, delim);
while (item != NULL)
{
  Serial.println(item);
  item = strtok (NULL, delim);
}
</code></pre>
",,24871420,401
20324420,2,20305267,2013-12-02T09:06:11.970,0,,2545784,,2013-12-02T09:06:11.970,,0,,"<p>To read a string, you can allocate memory for it and then add bytes from Serial:</p>

<pre><code>#define MAX_STR_CHARS 100
char stringToParse[MAX_STR_SIZE+1]="""";
//...
void loop() {
    char b;
    int s;
    if (Serial.isAvailable()) {
        b=Serial.read();
        switch (b) {
        //Some possible string delimiters:
        case 0x0a: //LF
        case 0x0d: //CR
        case 0:    //NULL
            Serial.print(""Received string is: "");
            Serial.println(stringToParse);
            //do you thing with string...
            *stringToParse=0; //reset string to next use
            break;
        default: //Add characters:
            s=strlen(stringToParse);
            if (s&lt;MAX_STR_CHARS) { //Ensure is not writing after allocated buffer
                stringToParse[s]=b;
                stringToParse[s+1]=0;
            }
        }
    }
}
</code></pre>
",,24878529,518
20313257,2,20313178,2013-12-01T14:36:00.200,2,,2877241,,2013-12-01T14:36:00.200,,1,,"<p>You may not define one function inside another function. It is what you are trying to do in the following code snippet</p>

<pre><code>void setup() {
  // initialize the pushbutton pins as an input:
  pinMode(foodPin, INPUT); 
  pinMode(painPin, INPUT);
  pinMode(ucsPin, INPUT);
  pinMode(csPin, INPUT);
  pinMode(lightPin, INPUT);
  Serial.begin(9600);
  int ix=0;

  // define behavioral methods
  void mody (int ix, int brain[], int stimulus[])
</code></pre>

<p>You are trying to define function mody inside function setup.</p>
",,24883961,12487
24267993,2,20319607,2014-06-17T15:40:05.623,0,,416782,,2014-06-17T15:40:05.623,2020-06-20T09:12:55.060,0,,"<p>I stumbled around on this for hours. <em>The first answer works well, but leaves a bit to be desired, if you are wanting to compile your libraries as you build them.</em></p>
<h1>My Setup (For your information)</h1>
<ul>
<li><p>I'm not using Arduino's libraries folder, but instead referencing like so:</p>
<p><code>#include &quot;../includes/MyClassName/src/MyClassName.h&quot;</code></p>
</li>
<li><p>Sublime Text 3 beta with Stino plugin (HIGHLY RECOMMENDED - I enjoy it a lot!)</p>
</li>
<li><p>Arduino IDE version: 1.5.6 beta</p>
</li>
</ul>
<p>Ok, now on to the code. Here is MyClassName.h:</p>
<pre><code>#ifndef MyClassName_h //If MyClassName_h &quot;Not&quot; DEFined
#define MyClassName_h //Then define MyClassName_h
class MyClassName{
  public:
    void get_computer_msg(boolean echo_cmd = false);
    String computer_msg;
    char first_char;
};
#endif //End if

#include &quot;MyClassName.cpp&quot; //Same as first answer recommends
</code></pre>
<p>Here is MyClassName.cpp</p>
<pre><code>#ifndef MyClassName_cpp //the _cpp is just to delineate between the two files  
#define MyClassName_cpp
#include &quot;MyClassName.h&quot;
void MyClassName::get_computer_msg(boolean echo_cmd) { //Receive message from computer
  int index = 0;
  String msg = &quot;&quot;;
  String echo_msg = &quot;&quot;;
  if(Serial.available()) {
    while(Serial.available()) {
      char cChar = Serial.read();
      msg += cChar;
      echo_msg += cChar;
      index++;
    }
    if(echo_cmd) Serial.println(&quot;Computer sent &quot; + echo_msg + &quot;+CRLF&quot;);
    first_char = msg.charAt(0);
    computer_msg = msg;
  }
}
#endif
</code></pre>
<p>The benefit of doing it this way is that you can load up MyClassName.cpp, modify it, and then compile right then and there. If you have any errors, you'll know about it. Also, you won't have to update anything in MyClassName.h as MyClassName.cpp is included and the #ifndef's keep from double declarations.</p>
<p>The only thing I'm not sure about using this method is that compile time may still be hampered by the inclusion of MyClassName.cpp in the .h file. That is the main reason for having separate files in the first place. Perhaps an expert in C++ could comment on this?</p>
",,24991358,5366
20348200,2,20339456,2013-12-03T10:11:58.070,0,,2545784,,2013-12-03T10:11:58.070,,6,,"<p>What are you attempting with</p>

<pre><code>    read(port, buffer, 12);       
    printf(""%.2f %.2f %.2f\n"", buffer[3*i], buffer[3*i+1], buffer[3*i+2]);
</code></pre>

<p>??? <code>buffer</code> will contain string data, like following (not floating points):</p>

<pre><code>{'2', ' ', '4', '0', ' ', '-', '4', '1', 0x0D, 0x0A, '4', ' ', '8'}
//0    1    2    2    3    4    5    6     7     8    9    10   11
</code></pre>

<p>Your first mistake is reading exactly 12 bytes - each line may have different number of bytes. Second mistake is trying to format a <code>char</code> as a <code>float</code>. Even <code>printf</code> may get invalid data as it expects 3 floats and you are supllying 3 chars.</p>

<p>So, you need to parse your input data! Some direction:</p>

<pre><code>#include &lt;stdio.h&gt;

float input[3];

int main(int argc, const char* argv[]) {
    FILE *port;
    port=fopen(""/dev/tty.usbmodem1411"", ""r""); //fopen instead, in order to use formatted I/O functions
    if (port==NULL) {
        printf(""Unable to open serial port."");
        return 1; //MUST terminate execution here!
    }
    for (int i = 0; i &lt; 10; i++) {
        fscanf(, ""%f %f %f"", &amp;input[0], &amp;input[1], &amp;input[2]);
        printf(""%.2f %.2f %.2f\n"", input[0], input[1], input[2]);
    }
    fclose(port);
    return 0;

}
</code></pre>
",,24994433,3162
20361137,2,20359770,2013-12-03T20:35:17.563,0,,257645,,2013-12-03T23:12:50.767,2013-12-03T23:12:50.767,4,,"<p>Unless what you actually, really want to learn is low-level berkeley socket manipulation, I'd suggest you look at <a href=""http://libevent.org/"" rel=""nofollow"">libevent</a> or a similar library.</p>

<p>The structure of your main loop is a little unusual. You can clearly only handle one connection at a time, and you don't cope well with any connection attempts that happened while you were servicing a previous connection.</p>

<pre><code>bind(mysocket, (struct sockaddr *)&amp;serv, sizeof(struct sockaddr));
</code></pre>

<p>bind can fail, e.g. if another process has recently had the socket open and the OS hasn't finished cleaning up use of the port. You can change this behavior, but you should still check, from <a href=""http://linux.die.net/man/2/bind"" rel=""nofollow"">die.net's bind manpage</a></p>

<pre><code>Return Value
  On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</code></pre>

<p>so</p>

<pre><code>if(bind(mysocket, (struct sockaddr *)&amp;serv, sizeof(struct sockaddr))) {
    perror(""bind failed"");
    exit(1);
}
</code></pre>

<p>listen() only needs to be called once, but also needs to be checked</p>

<pre><code>if(listen(mysocket, 2)) {
    perror(""listen failed"");
    exit(1);
}
</code></pre>

<p>after this, if you are content to do the single-service approach, then you can do the following:</p>

<pre><code>mysocket = socket(AF_INET, SOCK_STREAM, 0);
if(mysocket &lt; 0) {
    perror(""socket failed"");
    exit(1);
}

if(bind(mysocket, (struct sockaddr *)&amp;serv, sizeof(struct sockaddr))) {
    perror(""bind failed"");
    exit(1);
}

if(listen(mysocket, 2)) {
    perror(""listen failed"");
    exit(1);
}

for (;;) {
    consocket = accept(mysocket, (struct sockaddr *)&amp;dest, &amp;socksize);
    if(consocket &lt; 0) // might return if the connection has already gone away.
        continue;
    if (!sendGreeting(consocket)) {
        // sendGreeting should return -1 if it was unable to send, 0 if successful
        while (!readLoop(consocket, recvBuf, MAXRCVLEN))
            ;
    }
    close(consocket);
}
</code></pre>

<p>readLoop would then be something like:</p>

<pre><code>int readLoop(int socket, char* buffer, size_t bufSize) {
    int len = recv(socket, buffer, bufSize);
    if (len &gt; 0)
        return processBuffer(socket, buffer, len);
    if (len &lt; 0 &amp;&amp; (errno == EINTR || errno == EAGAIN))
        return 0; // do-over
    return -1;
}
</code></pre>

<p>make sure that processBuffer also returns 0 or -1 accordingly.</p>

<p>As I mentioned above, there are still problems with this approach, but it's not my intent here to teach you everything you need to know about sockets in one pass :) If you want to further develop your socket knowledge, your next stop should be learning about <a href=""http://linux.die.net/man/2/select"" rel=""nofollow"">select</a> or <a href=""http://linux.die.net/man/2/poll"" rel=""nofollow"">poll</a> with non-blocking sockets so that you can host multiple sockets and service them as they become active.</p>
",,24997433,270
20390805,2,20383780,2013-12-05T03:25:44.327,0,,3055752,,2013-12-05T03:25:44.327,,4,,"<p>For Chris Stratton:</p>

<pre><code>if (fgets(temp, sizeof(temp), file) != NULL) 
{ 
     sscanf(temp, ""%d %d %d\n"", &amp;buffer[3*i], &amp;buffer[3*i+1], &amp;buffer[3*i+2]); 
     printf(""%d %d %d\n"", buffer[3*i], buffer[3*i+1], buffer[3*i+2]); 
}
</code></pre>

<p>However, going back to my original question, even if I'm using fscanf and printf, I obtain data, and then I only read zeros indefinitely. I'm thinking this might be more of a serial port communication issue? </p>
",,25012460,4554
20423122,2,20417043,2013-12-06T11:48:07.307,0,,1690199,,2013-12-06T11:48:07.307,,0,,"<p>Maybe this?</p>

<pre><code> String inString = ""08000AE23BDB "";

  if (inString != null) {
    inString = trim(inString);

    String[] data = split(inString, "","");

    if (data.length &gt;=1) 
    {
      //direction1 = data[0];
    }
    println(unhex(data[0]));
  }
</code></pre>
",,25015459,1010
20434191,2,20434064,2013-12-06T21:49:40.773,-1,,3075187,,2013-12-06T21:49:40.773,,2,,"<p>You have to declare your class</p>

<pre><code>class MenuMgr
{
private:
   buffer _buf;
public:
   void set_displaybuff(buffer &amp;buffer)
  {
     _buf= buffer;     
  }
};
</code></pre>

<p>This is just the simplest example imaginable. But you have to implement Constructor and Destructor and add the included´s needed. </p>
",,25031731,231
20520892,2,20453473,2013-12-11T13:49:36.413,0,,2862231,,2013-12-11T13:49:36.413,,0,,"<p>Hey have you tried <code>x=Serial.parseInt();</code> this read the next data if the an Integer it will find for exampel ""fahijah123234fjrkaljf"" come in in x will be 123234 same to next integer value</p>

<pre><code>//incommeing: jsj123456asklfj654321faskl
int x,y;
x=Serial.parseInt();
y=Serial.parseInt();

Serial.println(x);//123456
Serial.println(y);//654321
</code></pre>

<p>to merege them use <code>strcat</code> or <code>sprintf</code></p>

<p><a href=""http://arduino.cc/en/Serial/ParseInt"" rel=""nofollow"">http://arduino.cc/en/Serial/ParseInt</a>, 
<a href=""http://arduino.cc/en/Serial/ParseFloat"" rel=""nofollow"">http://arduino.cc/en/Serial/ParseFloat</a></p>
",,25033308,776
20480708,2,20461691,2013-12-09T21:02:21.290,0,,2031763,,2013-12-09T21:16:03.847,2013-12-09T21:16:03.847,2,,"<p>It's impossible to fade to pink beacuse you are starting from red and ending with green.</p>

<p>To avoid this kind of mistake I suggest you to write an object oriented code.</p>

<p>If you don't want to write the classes to handle a 3D vectonr you can use the <a href=""https://github.com/Nicola17/ArduinoTinkerLibrary"" rel=""nofollow"">Arduino Tinker Library</a> </p>

<p>I wrote this example for you:</p>

<pre><code>#include &lt;Vect3d.h&gt;
#include &lt;SerialLog.h&gt;

Tinker::Vect3d&lt;float&gt; red(255,0,0);
Tinker::Vect3d&lt;float&gt; green(0,255,0);
Tinker::SerialLog serialLog;

void setup(){
  Serial.begin(9600);
  serialLog.display(""Fade color example"");  
  serialLog.endline();
}

void loop(){
  //fade factor computation
  const uint32_t t   = millis()%10000;
  const float cosArg = t/10000.*3.1415*2;
  const float fade   = abs(cos(cosArg));

  //Here's the color computation... as you can see is very easy to do!! :)
  Tinker::Vect3d&lt;uint8_t&gt; finalColor(red*fade + green*(1-fade));

  //We print the vect3d on the arduino serial port
  Tinker::LOG::displayVect3d(finalColor,&amp;serialLog);
  serialLog.endline();
  delay(500);
}
</code></pre>

<p>Which prints the following output on the serial port   </p>

<pre><code>Fade color example
V[255;0;0]
V[242;12;0]
V[206;48;0]
V[149;105;0]
V[78;176;0]
V[0;254;0]
V[79;175;0]
V[150;104;0]
V[206;48;0]
V[242;12;0]
V[254;0;0]
V[242;12;0]
V[205;49;0]
V[148;106;0]
V[77;177;0]
V[1;253;0]
V[80;174;0]
V[151;103;0]
</code></pre>

<p>hope that this helps :)</p>
",,25072586,5509
20481846,2,20481777,2013-12-09T22:06:32.873,0,,2300597,,2013-12-09T22:15:46.193,2013-12-09T22:15:46.193,3,,"<p>1) Try calling writeBytes(String s) on the DataOutputStream.</p>

<p>2) Try calling flush on the DataOutputStream 
(even though close should be calling flush anyway).</p>

<p>3) Try using PrintWriter to send the String</p>

<p>See </p>

<p><a href=""http://docs.oracle.com/javase/6/docs/api/java/io/PrintWriter.html#PrintWriter%28java.io.OutputStream,%20boolean%29"" rel=""nofollow"">http://docs.oracle.com/javase/6/docs/api/java/io/PrintWriter.html#PrintWriter%28java.io.OutputStream,%20boolean%29</a></p>

<p>and this method in particular</p>

<p><a href=""http://docs.oracle.com/javase/6/docs/api/java/io/PrintWriter.html#write%28java.lang.String%29"" rel=""nofollow"">http://docs.oracle.com/javase/6/docs/api/java/io/PrintWriter.html#write%28java.lang.String%29</a></p>

<p>4) Also, I think you should swap these two</p>

<pre><code>            if(socket != null) {
                socket.close();
            }
            if(dataOutputStream != null) {
                dataOutputStream.close();
            }
</code></pre>
",,25092986,564
20540917,2,20534259,2013-12-12T10:27:52.337,0,,2545784,,2013-12-12T10:27:52.337,,0,,"<p>Your failure is initializing <code>currentlargestindex</code>.</p>

<p>As you did <code>hottest = temperaturearray[0];</code> you should also do <code>currentlargestindex=0;</code>.</p>

<p>However, your code can be much more improved:</p>

<pre><code>float highestTemperature(float temperaturearray[]) {
  int arraylength = 5; //knows how large the array is
  int currentlargestindex = 0; //Assume first item is hottest one
  for(int i = 1; i &lt; arraylength; i++) {//Don't need to check 0 again, check just 1, ...!
    if(temperaturearray[i] &gt; temperaturearray[currentlargestindex]) {
      currentlargestindex = i; 
      //hottest=temperaturearray[i]; //Not needed, same as temperaturearray[currentlargestindex]
    }
  }
  //This is a float returning function, so return it!
  return temperaturearray[currentlargestindex];
}
</code></pre>
",,25100957,1231
20552124,2,20551976,2013-12-12T19:09:01.920,3,,2927205,,2013-12-12T21:01:01.183,2013-12-12T21:01:01.183,2,,"<p>Try this, it is a working Example:</p>

<pre><code>char text = 'World';

char buffer[25];
sprintf(buffer, ""Hello  %c"", text);
CvFont font;
cvInitFont(&amp;font, CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5);
cvPutText(image, buffer, cvPoint(2, 2), &amp;font, cvScalar(255));
</code></pre>
",,25109415,984
20562217,2,20561328,2013-12-13T08:36:47.497,1,,2065121,,2013-12-13T08:36:47.497,,2,,"<p>You might try reworking that loop:</p>

<pre><code>while (1) 
{ 
    ClearCommError(hPort,&amp;dwErrors,&amp;commStatus); 
    if (commStatus.cbInQue != 0) break; 
    Sleep(10); 
} 
ReadFile(hPort,&amp;data,1,&amp;dwBytesRead,NULL);
</code></pre>

<p>The sleep will give a little time for the system to respond to more data - you may be spinning too fast. </p>
",,25153153,3602
20587470,2,20587308,2013-12-14T19:45:00.703,1,,1120273,,2013-12-14T19:45:00.703,,1,,"<p>You certainly <em>can not</em> assign <code>WLAN_SSID</code> to a <code>char*</code> because string literals are of type <code>char const[N]</code> (with a suitable <code>N</code>) which happily decay into <code>char const*</code>s but refuse to be assigned to <code>char*</code>s. If you really need to deal with a <code>char*</code>, you'll need to allocate sufficient space and copy the value into this memory. Of course, when changing it you'll also need to release the memory appropriately. For example</p>

<pre><code>char* make_ssid(char const* value) {
    static std::unique_ptr&lt;char[]&gt; memory;
    std::size_t n = strlen(value);
    memory.reset(new char[n + 1]);
    strncpy(memory.get(), value, n + 1);
    return memory.get();
}
char* ssid = make_ssid(WLAN_SSID);
</code></pre>
",,25164002,4136
20630550,2,20625307,2013-12-17T09:36:06.417,3,,2545784,,2013-12-17T09:36:06.417,,0,,"<p>It would be easier if you draw a I/O map:</p>

<pre><code>switchL switchR |  lR   lG   mB   rG   rR
   0       0    |  1    0    0    0    1
   0       1    |  1    0    0    1    0
   1       0    |  0    1    0    0    1
   1       1    |  0    0    1    0    0
</code></pre>

<p>and just write outputs as function of inputs:</p>

<pre><code>digitalWrite(3, !switchL            );
digitalWrite(4,  switchL &amp;&amp; !switchR);
digitalWrite(5,  switchL &amp;&amp;  switchR);
digitalWrite(6, !switchL &amp;&amp;  switchR);
digitalWrite(7,             !switchR);
</code></pre>

<p>If you prefer keep using nested <code>IF</code>s, you must always keep in mind that each output is a function of <strong>both</strong> inputs.</p>
",,25170821,260
20690921,2,20625307,2013-12-19T20:20:21.403,0,,2440997,,2013-12-19T20:20:21.403,,0,,"<p>I have a dim understanding of the functions you were using, however it was your answer that lead me to solve my issue. All I needed to was add another conditional in two of my <code>ifs</code>. </p>

<pre><code>    if (switchL == HIGH &amp;&amp; switchR == LOW) { //When the left button is pressed but the right button is not
  digitalWrite(4, HIGH);
  digitalWrite(3, LOW);
} else {
  digitalWrite(4, LOW);
  digitalWrite(3, HIGH); 
}
 if (switchR == HIGH &amp;&amp; switchL == LOW) { //When the right button is pressed but the left button is not
  digitalWrite(6, HIGH);
  digitalWrite(7, LOW);       
} else {
  digitalWrite(6, LOW);
  digitalWrite(7, HIGH); 
}
</code></pre>
",,25184611,648
22094486,2,20625307,2014-02-28T11:54:08.707,0,,1804181,,2014-02-28T11:54:08.707,,0,,"<p>You tried to overthink it. First off, in your 2nd last <code>if</code> test, you're setting <code>D5</code> <code>HIGH</code> and then immediately testing if it's <code>HIGH</code>. It can't be anything else, therefore the <code>else</code> in the final <code>if</code> will never be actioned. </p>

<p>All I would do is move your tricky bit (the double button test) to the top of your code, and then test each of the other buttons within the <code>else</code> of that above test. Now that reads harder than it has to. Here's the code:</p>

<pre><code>void loop() {
  switchL = digitalRead(2);
  switchR = digitalRead(8);

    // first test if both buttons are pressed
    if (switchL == HIGH &amp;&amp; switchR == HIGH){
      digitalWrite(5, HIGH);
      digitalWrite(3, LOW);
      digitalWrite(4, LOW);
      digitalWrite(6, LOW);
      digitalWrite(7, LOW);
    } else {
          // now that's out the way, we test for everything else as a whole here
          // first test switchL
        if (switchL == HIGH) {
          digitalWrite(4, HIGH);
          digitalWrite(3, LOW);
        } else {
          digitalWrite(4, LOW);
          digitalWrite(3, HIGH); 
        } // end if switchL
          // then test switchR
        if (switchR == HIGH) {
          digitalWrite(6, HIGH);
          digitalWrite(7, LOW);       
        } else {
          digitalWrite(6, LOW);
          digitalWrite(7, HIGH); 
        } //end if switchR
    }     //end else of both high
} 
</code></pre>
",,25213457,352
20636573,2,20636528,2013-12-17T14:20:22.123,1,,2354107,,2013-12-17T14:20:22.123,,1,,"<p>This is incorrect:</p>

<pre><code>ADS1X15::ADS1X15() {
    uint8_t     m_i2cAddress;
    uint8_t     m_test = 99;
}
</code></pre>

<p>It declares two local variables to the constructor that match the names of your class members.  You have a similar error in <code>ADS1X15::begin</code>.  If you had warnings enabled, you should have gotten a warning about a local variable shadowing a member variable, or similar.</p>

<p>Rewrite those without the type declarations, and they'll update your class instead of updating local variables to the methods.  </p>

<pre><code>ADS1X15::ADS1X15() {
    m_test = 99;
}

void ADS1X15::begin(uint8_t i2cAddress) {
    m_i2cAddress = i2cAddress;
}
</code></pre>
",,25219647,47
20636579,2,20636528,2013-12-17T14:20:42.490,1,,2545784,,2013-12-17T14:20:42.490,,0,,"<p>In your cpp:</p>

<pre><code>ADS1X15::ADS1X15() {
    uint8_t     m_i2cAddress;
    uint8_t     m_test = 99;
</code></pre>

<p>you are redeclaring public members, so when you refer then inside constructor, you are acessing private copy instead of public class members.</p>

<p>Just use:</p>

<pre><code>ADS1X15::ADS1X15() {
    m_test = 99;
}

void ADS1X15::begin(uint8_t i2cAddress) {
    m_i2cAddress = i2cAddress;
}
</code></pre>
",,25263989,655
20727090,2,20721606,2013-12-22T07:06:04.590,4,,2682142,,2013-12-22T08:12:30.827,2013-12-22T08:12:30.827,9,,"<blockquote>
  <p>A few friends suggested programming the control code as a kernel module but I am not quite sure I wish to jump into that.</p>
</blockquote>

<p>I am almost certain if it is not closely hardware related it would be rejected in the Linux kernel. The purpose of the userspace syscall and sysfs access to put your custom logic into a Linux on top of the hardware abstraction (OSI model).</p>

<p>What you would need to do is first check if the Linux kernel provides all the hardware support for your devices. Then you could take my middleware class for controling the GPIO in a C++ manner. Finally, you could write a small main application to test the kernel and C++ class. That application would do just something simple like instantiating the GPIO class, export a GPIO, and then write values.</p>

<p>(How this is related to your PWM question is unclear, but you seem to mix up two different kernel driver areas)</p>

<p>You could do something like the code below through <a href=""https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt"" rel=""nofollow"">sysfs</a> as per the <a href=""http://lxr.free-electrons.com/source/Documentation/gpio.txt"" rel=""nofollow"">Linux kernel gpio documentation</a>. You will of course need to make sure that your hardware gpio is supported by the Linux kernel.</p>

<h3>gpio.h</h3>

<pre><code>#ifndef FOOBAR_GENERALPURPOSEIO_H
#define FOOBAR_GENERALPURPOSEIO_H

namespace Foobar
{
   class FOOBAR_EXPORT GeneralPurposeIO
   {
       public:

           enum Direction {
               Input,
               Output
           };

           explicit GeneralPurposeIO(quint32 gpioNumber = 0);
           ~GeneralPurposeIO();

           int gpioExport();
           int gpioUnexport();
           bool isGpioExported();

           quint32 gpioNumber() const;
           void setGpioNumber(quint32 gpioNumber);

           Direction direction() const;
           int setDirection(Direction direction);

           qint32 value() const;
           int setValue(qint32 value);

       private:

           class Private;
           Private *const d;
   };
}

#endif // FOOBAR_GENERALPURPOSEIO_H
</code></pre>

<h3>gpio.cpp</h3>

<pre><code>#include ""generalpurposeio.h""

#include &lt;QtCore/QDebug&gt;
#include &lt;QtCore/QFile&gt;

using namespace Foobar;

class GeneralPurposeIO::Private
{
   public:
       Private()
       {
       }

       ~Private()
       {
       }

       static const QString gpioExportFilePath;
       static const QString gpioUnexportFilePath;
       static const QString gpioDirectionFilePath;
       static const QString gpioValueFilePath;
       static const QString gpioFilePath;

       quint32 gpioNumber;
};

const QString GeneralPurposeIO::Private::gpioExportFilePath = ""/sys/class/gpio/export"";
const QString GeneralPurposeIO::Private::gpioUnexportFilePath = ""/sys/class/gpio/unexport"";
const QString GeneralPurposeIO::Private::gpioDirectionFilePath = ""/sys/class/gpio/gpio%1/direction"";
const QString GeneralPurposeIO::Private::gpioValueFilePath = ""/sys/class/gpio/gpio%1/value"";
const QString GeneralPurposeIO::Private::gpioFilePath = ""/sys/class/gpio/gpio%1"";

GeneralPurposeIO::GeneralPurposeIO(quint32 gpioNumber)
   : d(new Private)
{
   d-&gt;gpioNumber = gpioNumber;
}

GeneralPurposeIO::~GeneralPurposeIO()
{
}

/*
* Exports the desired gpio number.
*
* Note: Unfortunately, it is not possible to just call this method ""export""
* since that is a reserved keyword in C++. Systematically the unexport method
* cannot be called ""unexport"" either for consistency.
*/

int GeneralPurposeIO::gpioExport()
{
   if (isGpioExported()) {
       // TODO: Proper error mutator mechanism for storing different error
       // enumeration values internally that can be requested by the API user

       qDebug() &lt;&lt; ""Cannot export the gpio pin since it is already exported:"" &lt;&lt; d-&gt;gpioNumber;
       return -1;
   }

   QFile gpioExportFile(d-&gt;gpioExportFilePath);
   if (!gpioExportFile.open(QIODevice::Append)) {
       qDebug() &lt;&lt; ""Cannot open the gpio export file:"" &lt;&lt; d-&gt;gpioExportFilePath;
       return -1;
   }

   /*
    * Seek to begining of the file
    */

   gpioExportFile.seek(0);

   /*
    * Write our value of ""gpioPinNumber"" to the file
    */

   if (gpioExportFile.write(QByteArray::number(d-&gt;gpioNumber)) == -1) {
       qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; ""Error while writing the file:"" &lt;&lt; d-&gt;gpioExportFilePath;
       gpioExportFile.close();

       return -1;
   }

   gpioExportFile.close();

   return 0;
}

int GeneralPurposeIO::gpioUnexport()
{
   if (!isGpioExported()) {
       // TODO: Proper error mutator mechanism for storing different error
       // enumeration values internally that can be requested by the API user

       qDebug() &lt;&lt; ""Cannot unexport the gpio pin since it is not exported yet:"" &lt;&lt; d-&gt;gpioNumber;
       return -1;
   }

   QFile gpioUnexportFile(d-&gt;gpioUnexportFilePath);
   if (!gpioUnexportFile.open(QIODevice::Append)) {
       qDebug() &lt;&lt; ""Cannot open the gpio export file:"" &lt;&lt; d-&gt;gpioUnexportFilePath;
       return -1;
   }

   /*
    * Seek to begining of the file
    */

   gpioUnexportFile.seek(0);

   /*
    * Write our value of ""gpioPinNumber"" to the file
    */

   if (gpioUnexportFile.write(QByteArray::number(d-&gt;gpioNumber)) == -1) {
       qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; ""Error while writing the file:"" &lt;&lt; d-&gt;gpioUnexportFilePath;
       gpioUnexportFile.close();

       return -1;
   }

   gpioUnexportFile.close();

   return 0;
}

bool GeneralPurposeIO::isGpioExported()
{
   if (!QFile(d-&gt;gpioFilePath.arg(d-&gt;gpioNumber)).exists()) {
       return false;
   }

   return true;
}

quint32 GeneralPurposeIO::gpioNumber() const
{
   return d-&gt;gpioNumber;
}

void GeneralPurposeIO::setGpioNumber(quint32 gpioNumber)
{
   d-&gt;gpioNumber = gpioNumber;
}

GeneralPurposeIO::Direction GeneralPurposeIO::direction() const
{
   // TODO: Implement me

   return GeneralPurposeIO::Output;
}

int GeneralPurposeIO::setDirection(Direction direction)
{
   if (!isGpioExported()) {
       if (gpioExport() == -1) {
           return -1;
       }
   }

   /*
    * Set the direction
    */

   QFile gpioDirectionFile(d-&gt;gpioDirectionFilePath.arg(d-&gt;gpioNumber));

   if (!gpioDirectionFile.open(QIODevice::ReadWrite)) {
       qDebug() &lt;&lt; ""Cannot open the relevant gpio direction file:"" &lt;&lt; d-&gt;gpioDirectionFilePath;
       return -1;
   }

   int retval = 0;

   /*
    * Seek to begining of the file
    */

   gpioDirectionFile.seek(0);

   switch (direction) {

   case Output:
       if (gpioDirectionFile.write(""high"") == -1) {
           qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; ""Error while writing the file:"" &lt;&lt; d-&gt;gpioDirectionFilePath;
           retval = -1;
       }

       break;

   case Input:
       if (gpioDirectionFile.write(""low"") == -1) {
           qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; ""Error while writing the file:"" &lt;&lt; d-&gt;gpioDirectionFilePath;
           retval = -1;
       }

       break;

   default:

       break;

   }

   gpioDirectionFile.close();

   return retval;
}

qint32 GeneralPurposeIO::value() const
{
   // TODO: Implement me

   return 0;
}

int GeneralPurposeIO::setValue(qint32 value)
{
   if (direction() != GeneralPurposeIO::Output) {
       qDebug() &lt;&lt; ""Cannot set the value for an input gpio pin:"" &lt;&lt; d-&gt;gpioNumber;
       return -1;
   }

   /*
    * Set the value
    */

   QFile gpioValueFile(d-&gt;gpioValueFilePath.arg(d-&gt;gpioNumber));
   if (!gpioValueFile.open(QIODevice::ReadWrite)) {
       qDebug() &lt;&lt; ""Cannot open the relevant gpio value file:"" &lt;&lt; d-&gt;gpioValueFilePath.arg(d-&gt;gpioNumber);
       gpioValueFile.close();
       return -1;
   }

   /*
    * Seek to begining of the file
    */

   gpioValueFile.seek(0);

   if (gpioValueFile.write(QByteArray::number(value)) == -1) {
       qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; ""Error while writing the file:"" &lt;&lt; d-&gt;gpioValueFilePath.arg(d-&gt;gpioNumber);
       gpioValueFile.close();
       return -1;
   }

   gpioValueFile.close();

   return 0;
}
</code></pre>
",,25316654,37
20776660,2,20773758,2013-12-25T20:51:15.513,0,,752720,,2013-12-25T20:59:12.030,2013-12-25T20:59:12.030,0,,"<p>There are a lot of problems here. You should approach problems like this by testing each step of the solution at a time, so you don't end up with a big mess. First, you need to make sure you're reading the string in properly.</p>

<p>That part of the code is not working correctly because the <code>{}</code> surrounding the <code>while(Serial.available())</code> loop are not in the right spot. Also, you're appending the new character twice by using both <code>+=</code> and <code>concat</code>. Here's a simple fix to get the string correctly. The delay is to allow for the next byte to be available so it doesn't exit the loop prematurely.</p>

<pre><code>  content="""";
  while (Serial.available() &lt; 1) {}
  while (Serial.available()) 
  {
    character = Serial.read();
    content += character;
    delay(10);
  }

  Serial.print(""content = ""); Serial.println (content);
</code></pre>

<p>Next you need to parse the values for x and y out of the string. There are a couple problems here as well. I don't think you want to use integers for x and y, so you need a way to interpret the string as a float. Here is how you can parse the values into floats.</p>

<pre><code>  End=content.length();
  yindex= content.indexOf(""y"");

  x=content.substring(1,yindex);
  y=content.substring(yindex+1, End);

  Serial.print(""x = ""); Serial.println (x);
  Serial.print(""y = ""); Serial.println (y);

  char xbuf[10] = """";
  x.toCharArray(xbuf, 10);
  xt = atof(xbuf);
  Serial.print(""xt = ""); Serial.println(xt);

  char ybuf[10] = """";
  y.toCharArray(ybuf, 10);
  yt = atof(ybuf);
  Serial.print(""yt = ""); Serial.println(yt);
</code></pre>

<p>That should be enough help to get you moving along. There are some problems in your math later in the code, but that should be easier to work out after you have working print statements. Note - the format this code is expecting from the serial monitor are of the format <code>x0.34y0.678</code> where <code>0.34</code> is the value of <code>x</code> and <code>0.678</code> is the value of <code>y</code>.</p>
",,25318312,3532
20779191,2,20779079,2013-12-26T04:36:16.580,3,,,user1814023,2013-12-26T06:04:38.093,2013-12-26T06:04:38.093,1,,"<p>You are checking the each bit of x (0 to 7) in the code by doing </p>

<pre><code>b = (x &amp; (1 &lt;&lt; i)) &gt;&gt; i;
</code></pre>

<p>Say for example: You want to display <code>0</code> on the led. the seven segment code for displaying <code>0</code> on led is <code>0X3F</code> (The variable x has the value <code>0X3F</code>). (For more on seven segment <a href=""http://en.wikipedia.org/wiki/Seven-segment_display"" rel=""nofollow"">display</a>).</p>

<p>You are checking the each bit of the <code>0X3F</code> and the variable <code>'b'</code> has the value whether the bit <code>i</code> is <code>0</code> or <code>1</code>.</p>

<pre><code>`0X3F` is 
0 1 1 1 1 1 1 1 
    3      F
</code></pre>

<p>For example:</p>

<pre><code>int main()
{
    int i, x, b;
    x = 0x3F;
    for(i = 0; i&lt; 7; i++)
    {
        b = (x &amp; (1 &lt;&lt; i)) &gt;&gt; i;
        printf(""%d "", b); // I am printing the value of b here
    }
    getchar();
    return 0;
}
</code></pre>

<p>Will print </p>

<pre><code>1 1 1 1 1 1 0
</code></pre>

<p>when you say </p>

<pre><code>    b = (yaw &amp; (1 &lt;&lt; i)) &gt;&gt; i;
    if (b &gt; 0) sendOne(); else sendZero();
</code></pre>

<p>the variable <code>yaw</code> is having the seven segment code for the number you want to display on LED and you are checking each bit of <code>yaw</code>. If the bit is 1 you are calling <code>sendOne()</code> function, which might be sending a high voltage to the <code>LED</code> and <code>which will light up the corresponding LED in the 7 segment display</code>. If the bit is 0, you are calling <code>sendZero()</code> to send a low voltage. </p>

<p>Here you can notice that you are trying to light up the individual LEDs in the 7 Segment. The above program will be so fast that, you will see all the LEDs (who's bits are 1 as per the 7 segment code)lighted up. </p>
",,25320790,808
20779270,2,20779079,2013-12-26T04:46:57.150,0,,1899801,,2013-12-26T04:56:47.403,2013-12-26T04:56:47.403,1,,"<p>To expand. each x &amp; (1 &lt;&lt; i) is creating a mask of the desired bit and testing it against x</p>

<pre><code>x &amp; 00000001
x &amp; 00000010
etc..
x &amp; 01000000
x &amp; 10000000
</code></pre>

<p>and then shifting the bit of interest down to the LSB so that it can be tested with  b = (result of mask and input) >> i; as to transmit either a one or zero. Where the for loop walks the desired bit across the byte. </p>

<p>Note: this later part is not really needed as it will be greater then zero, regardless of it being shifted to the 1's bit.</p>

<hr>

<p>since you are looking at helicopter code. I would like to point out mine, as I have decoded several common 3.5ch.
<a href=""https://github.com/mpflaga/Arduino-IRremote/blob/master/IRremote.cpp#L324"" rel=""nofollow"">Library</a>
and <a href=""https://github.com/mpflaga/Arduino-IRremote/blob/master/examples/IRsendDemoHelicopter/IRsendDemoHelicopter.ino#L294"" rel=""nofollow"">Demo INO</a>
it is a bit cleaner in that bit structures assemble the message and a union shifts it all out, regardless of the different formats.</p>
",,25324817,86
20805706,2,20802752,2013-12-27T18:16:26.347,1,,1609219,,2013-12-27T18:16:26.347,,2,,"<p>I'm not sure what is required to output sinus-signal, but here's my take on a solution. First, what I understand you have:</p>

<pre><code>void loop() {
    update_pwm_output();
    delay(1000/50); // 50 Hz
}
</code></pre>

<p>A possible solution:</p>

<pre><code>int last_update = 0;
void loop() {
    int mill = millis();
    if (mill-last_update &gt; (1000/50)) {
        last_update = mill;
        update_pwm_output();
    }
}
</code></pre>

<p>This solution would allow you to execute other code in between updates to your PWM signal.</p>

<p>There are a couple ways to keep a PWM updated while running other code. A library I've used, <a href=""http://playground.arduino.cc/ComponentLib/Servo"" rel=""nofollow"">SoftwareServo</a>, allows you to call its <code>refresh()</code> method periodically and it'll update, where as the <a href=""http://arduino.cc/en/reference/servo"" rel=""nofollow"">Servo</a> library takes up a timer and uses an interrupt to do its updates.</p>
",,25344250,242
20829837,2,20828758,2013-12-29T20:40:04.527,0,,2555022,,2013-12-29T20:40:04.527,,0,,"<p>so i figured it out. i need to make another process for <code>digitalwrite</code>. In that case the newly created process stops but the rest of the program can continue working.</p>

<pre><code>import wiringpi2 as pi
from multiprocessing import Process

def process(choice):
        if choice == ""1"":
                pi.digitalWrite(17, 1)
        else:
                pi.digitalWrite(17, 0)

if __name__ == '__main__':
        pi.wiringPiSetupSys()
        choice = raw_input(""&gt;"")
        p = Process(target=process, args=(choice,))
        p.start()
        p.join()

print('just printing something to see if gets to end')
</code></pre>
",,25578490,151
20928942,2,20865973,2014-01-05T01:26:25.943,1,,368264,,2014-01-05T01:26:25.943,,2,,"<p>The issue was complex (consisted with a few smaller issues). Dumping request and response frames from both ends as @tomlogic suggested was quite helpful.</p>

<p>To resolve these issues I first ensured that hardware part works.</p>

<p>XBee explorer has 4 LEDs. One is power and should always glow red when powered. And 3 others, depending on what explorer you have, may be called <code>rx, tx, rssi</code> or <code>din, dout, rssi</code>.</p>

<p>When transmitting code runs, we first need to make sure that <code>rx</code> and <code>tx</code> are blinking simultaneously every second. I.e. signal is sent each second.</p>

<p>When receiving code runs and calls <code>readPacketUntilAvailable</code>, LEDs on receiving XBee explorer should glow as follows: <code>rssi</code> glows constantly, <code>tx</code> or <code>dout</code> should blink.</p>

<p>Now that when we know hardware is fine, we can debug software part.</p>

<p>My issue was with receiving code. When we are setting up receiving XBee, we need to make sure we do two things. First, we call <code>xbee.begin(baudRate)</code>. And second, we should reset module.</p>

<pre><code>reset = 0;
wait_ms(100);
reset = 1;
wait_ms(100);
</code></pre>

<p>And last, but not least thing, <code>readPacketUntilAvailable</code> method will <strong>not</strong> reset response. We call this function in a loop. Whatever first response we get will be repeated, no matter what other data is sent by transmitter.</p>

<p>First response that receiver got in my case was <code>MODEM_STATUS_RESPONSE</code> (<strong>0x8A</strong> in HEX). And subsequent packets were not read. <code>readPacket</code> must be called instead, since that method will reset previous response.</p>

<p>My receiving code now looks like this:</p>

<pre class=""lang-java prettyprint-override""><code>XBee xbee(p28, p27);
DigitalOut reset(p11);
DigitalOut mbed_led1(LED1);

int main() {
    Serial terminal(USBTX, USBRX);
    while(!terminal.readable()) {
        wait_ms(10);
    }
    terminal.getc();
    mbed_led1 = 1;
    xbee.begin(9600);
    reset = 0;
    wait_ms(100);
    reset = 1;
    wait_ms(100);

    while(1) {
        terminal.puts(""Reading packet...\r\n"");
        xbee.readPacket(500);
        XBeeResponse response = xbee.getResponse();
        if (response.isAvailable()) {
            terminal.puts(""Packet available\r\n"");
            XBeeResponse response = xbee.getResponse();

            char tmp[20];
            sprintf(tmp, ""0x%02X"", response.getApiId());
            terminal.puts(""Response available at API: "");
            terminal.puts(tmp);
            terminal.puts(""\r\n"");
            uint8_t api = response.getApiId();
            if (api == RX_16_RESPONSE) {
                Rx16Response rx16 = Rx16Response();
                response.getRx16Response(rx16);
                uint8_t len = rx16.getDataLength();
                char l[20];
                sprintf(l, ""%d"", len);

                terminal.puts(""We have data of length "");
                terminal.puts(l);
                terminal.puts(""\r\n"");
            }
        }

        wait(1);
    }
}
</code></pre>
",,25579757,480
20870461,2,20868853,2014-01-01T16:08:16.807,0,,1899801,,2014-01-01T16:08:16.807,,2,,"<p>The Arduino way would be to make a custom PLATFORM for your board with that of the new F_CPU speed. The core libraries should carry this F_CPU through. </p>

<p>This is easy enough, by making a boards.txt file with your differences. Where the location of the file (same between the two) is different between the two current IDE's. In the case of Arduino IDE 1.0.5:</p>

<blockquote>
  <p>C:\Users\mflaga\Documents\Arduino\hardware\myArduino11MgHz\boards.txt</p>
</blockquote>

<p>and in the case of 1.5.5:</p>

<blockquote>
  <p>C:\Users\mflaga\Documents\Arduino\hardware\myArduino11MgHz\avr\boards.txt</p>
</blockquote>

<p>Where in your case the sketch directory would be different.</p>

<pre><code># See: http://code.google.com/p/arduino/wiki/Platforms

##############################################################

myArduino11MgHz.name=Arduino 11MgHz

myArduino11MgHz.vid.0=0x2341
myArduino11MgHz.pid.0=0x0043
myArduino11MgHz.vid.1=0x2341
myArduino11MgHz.pid.1=0x0001

myArduino11MgHz.upload.tool=avrdude
myArduino11MgHz.upload.protocol=arduino
myArduino11MgHz.upload.maximum_size=32256
myArduino11MgHz.upload.maximum_data_size=2048
myArduino11MgHz.upload.speed=115200

myArduino11MgHz.bootloader.tool=avrdude
myArduino11MgHz.bootloader.low_fuses=0xFF
myArduino11MgHz.bootloader.high_fuses=0xDE
myArduino11MgHz.bootloader.extended_fuses=0x05
myArduino11MgHz.bootloader.unlock_bits=0x3F
myArduino11MgHz.bootloader.lock_bits=0x0F
myArduino11MgHz.bootloader.file=optiboot/optiboot_atmega328.hex

myArduino11MgHz.build.mcu=atmega328p
myArduino11MgHz.build.f_cpu=11059200L
myArduino11MgHz.build.board=AVR_myArduino11MgHz
myArduino11MgHz.build.core=arduino:arduino
myArduino11MgHz.build.variant=arduino:standard

##############################################################
</code></pre>

<p>Here is a <a href=""http://sourceforge.net/projects/arduinobdeditor/"" rel=""nofollow"">3rd party GUI Editor</a> of the board.txt.</p>

<p>Disclaimer. The above does compile and should work fine. Where I have not actually tested and loaded into a unit.</p>

<hr>

<p>That said, I would expect the bootloader's F_CPU not to match. There are three possible solutions to this.</p>

<p><strong>First</strong>; the optiboot loader should have a corresponding target with the below deviation:</p>

<blockquote>
  <p>\arduino-1.5.5\hardware\arduino\avr\bootloaders\optiboot\Makefile</p>
</blockquote>

<pre><code>myArduino11MgHz: AVR_FREQ = 11059200L
</code></pre>

<p><strong>Second</strong>; Change the boards.txt upload speed to match the change of =115200*(11059200/16000000).</p>

<pre><code>myArduino11MgHz.upload.speed=79626
</code></pre>

<p>This being a non typical baud rate, either avrdude or the serial port may support it. </p>

<p><strong>Third</strong>; Don't use the bootload, by uploading via the ISP programmer.</p>

<hr>

<p>I have likewise planned to make a board with a different F_CPU, but only actually made custom boards, with the same speed. I would be curious to know if the above actually works, in your case.</p>
",,25588292,14924
20891722,2,20891146,2014-01-02T20:57:25.807,0,,3154555,,2014-01-02T20:57:25.807,,0,,"<p>Input data can arrive in several chunks, so you need to slightly rework approach to read data, please check the following code for reference:</p>

<pre><code>int bytesToRead = 0;
int currBytePtr = 0;

int RGB[9];
while (9 &gt; currBytePtr) { // we need 9 bytes of data
    if (0 &lt; (bytesToRead = Serial.available())) { // have something to read
        for (int i = 0; i &lt; bytesToRead; ++i ) {
            RGB[currBytePtr++] = Serial.read();
            if (9 == currBytePtr) { // we have enough data
                break;
            }
        }
    } else {
        delay(1000); // sleep a bit
    }
} // while

// process data received
...
</code></pre>
",,25596640,507
20929375,2,20891146,2014-01-05T02:38:09.697,0,,1778551,,2014-01-05T02:38:09.697,,0,,"<p>why not just read the data till you have 9 bytes then process.</p>

<pre><code>char buffer[10];
int index=0;
while (Serial.available()){
    buffer[index++]=Serial.read();
    if (index&gt;8) {
        ProcessData(buffer);
        index=0;
    }
}
</code></pre>
",,25601716,1278
20935605,2,20934357,2014-01-05T15:52:46.967,1,,2036917,,2015-02-13T11:45:14.453,2015-02-13T11:45:14.453,4,,"<p>Always declare them inside the function. This improves readability as it shows the intent behind the declaration. Also it lowers the chance for mistakes.</p>

<p>Wherever possible as ""const"", e.g.</p>

<pre><code>uint16_t sample_it() {
    const uint16_t sample = analogRead(...);
    const uint16_t result = do_somehting(sample);
    return result;
}
</code></pre>

<p>Almost for the same reasons but this also gives the compiler more optimization options.</p>

<p>If and how variables are allocated is up to the compiler and its optimizer. Unless you have <strong><em>very</em></strong> tight performance constraints chances are that the compiler will optimize much better than you would. Actually using global variables instead will sometimes slow down your code. Of course you might avoid allocation. However you will pay by additional storage instructions. On the other hand the ""allocation"" might get optimized away and then your global variables code becomes slower than the local variables code.</p>
",,25641314,83
21030478,2,21030349,2014-01-09T20:30:18.407,2,,845568,,2014-01-09T20:30:18.407,,0,,"<p>The <code>int()</code> conversion is likely not doing what you think it does. It does not convert the value from a numerical string to a binary value. Instead you probably want to check to see if the values in the string are ascii digits.</p>

<pre><code>if(myStr[i - 2] == '1')
//                 ^^^ single quotes to specify character value.
{
    digitalWrite(int(i), HIGH);
}
else
{
    Serial.println(myStr[i - 2]);
}
</code></pre>
",,25754886,1149
21035211,2,21033366,2014-01-10T02:33:21.180,0,,1899801,,2014-01-10T02:33:21.180,,0,,"<p>With the below edition of the above sketch, you can simply add to the end of beat[] and notes[]. Note that number characters in notes[] should equal number of elements in beat[]. As I see in the </p>

<pre><code>int sensorPin = 0;
const int buzzerPin = 2;
const int sensorValue = analogRead(sensorPin);
//const int songLength = 16; // used sizeof() function below
//const int numNotes= 8;     // dido
const int tempo = 100;
const int off = LOW;
const int on = HIGH;

char names[] =     {'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C'};
const int freq[] = {262, 294, 330, 349, 392, 440, 494, 523};

const int beat[] = {1,1,1,1,1,1,4,4,2,1,1,1,1,1,1,4,4,2};
char notes[] = ""cd fda ag cdf dg gf ""; // Note length of notes[] should equal length of beat[]

void setup()
{  
  pinMode(buzzerPin, OUTPUT);
  pinMode(13, INPUT);
  pinMode(12, INPUT);
  pinMode(11, INPUT);
  pinMode(10, INPUT);
  pinMode(9, INPUT);
  pinMode(8, INPUT);
  pinMode(6, INPUT);
  pinMode(5, INPUT);
  pinMode(4, INPUT);
  pinMode(0, INPUT);
}

void loop() 
{  
  int i, duration;
  for (i = 0; i &lt; sizeof(beat); i++) 
  {
    duration = beat[i] * tempo;                                 
    if (notes[i] == ' ')          
    {
      delay(duration);           
    }
    else                          
    {
      tone(buzzerPin, frequency(notes[i]), duration);
      delay(duration);            
    } 


    delay(tempo/10);      
  }
  while(true){
  }
}
int frequency(char note) 
{
  int i;   


  for (i = 0; i &lt; sizeof(notes); i++)  
  {
    if (names[i] == note)         
    {
      return(freq[i]);     
    }
  }

}
</code></pre>
",,25758753,111
21043400,2,21042881,2014-01-10T11:39:43.443,1,,1457118,,2014-01-10T19:46:58.030,2014-01-10T19:46:58.030,0,,"<p>You can pass it as you would with any other flag.</p>

<pre><code>#makefile

CC=gcc
CFLAGS= -g -c -Wall 
MYLIB= -lbcm2835
program:   dependencies 
 &lt;  TAB IT!&gt;${CC} ${CFLAGS} ${MYLIB} -o Obj dependencies
</code></pre>
",,25790633,23224
21061262,2,21049912,2014-01-11T10:39:58.073,1,,1504523,,2014-01-11T17:04:25.970,2014-01-11T17:04:25.970,3,,"<p>Try </p>

<pre><code>memset(packetBuffer, 0, NTP_PACKET_SIZE);
packetBuffer[0] = 0b00011011; //  (0x1B) for NTPv3 
// or
// packetBuffer[0] = 0b00100011;` (0x23) for NTPv4 
</code></pre>

<p>and don't modify the rest of the request structure to start with. NTP will respond to clients with this minimum request setup.</p>

<p><strong>Edit:</strong> </p>

<p><code>localPort = 2390</code> should this be the ""ntp-port"" (123)? or
even 8888 as described here: ""<a href=""http://arduino.cc/en/Tutorial.UdpNtpClient"" rel=""nofollow"">Network Time Protocol (NTP) Client</a>"". <strong>Note:</strong> The link
looks very much the same as your link but it is NOT the same. The port is specified differently.</p>

<p>Does the code ever go beyond <code>setup()</code>.</p>

<pre><code>...
// check for the presence of the shield:
if (WiFi.status() == WL_NO_SHIELD) {
  Serial.println(""WiFi shield not present"");
  // don't continue:
  while(true);
}
...
</code></pre>

<p>looks weird to me. ""Don't continue"" is implemented as a busy ""stay here"".</p>
",,25827193,63
21056276,2,21055234,2014-01-10T23:18:48.603,3,,1880339,,2014-01-10T23:18:48.603,,3,,"<p>You have several <em>unnamed</em> items.  This happens with <code>typedef</code>s.  You could try,</p>

<pre><code>union sig_union
{
    struct
    {
        unsigned unit   :2;
        unsigned channel:2;
        unsigned status :1;
        unsigned group  :1;
        unsigned remote :26;
    } d;                       /* Note the name here. */
    unsigned long data;
} signal;
typedef union sig_union Signal;
</code></pre>

<p>Then in your code you need,</p>

<pre><code>void testPassingStruct(Signal *variable)
{
    variable-&gt;d.status = 1;
}
</code></pre>

<p>You can also use defines for masks and bit fields.  Often it makes control of what bit is where clearer and the compiler will generate similar code in both cases.  For instance,</p>

<pre><code>#define SIG_UNIT(d)    (d&amp;0x3)
#define SIG_CHANNEL(d) (d&amp;0xc&gt;&gt;2)
#define SIG_STATUS(d)  (d&amp;0x10)
/* etc. */
</code></pre>

<p>Especially with system programming where the bits matter, this is better as I don't believe that the 'C' bit fields specify how they are placed.  Most of all, I am sure it will compile.</p>
",,25829174,3647
21056551,2,21055234,2014-01-10T23:45:25.200,3,,2041317,,2014-01-10T23:45:25.200,,2,,"<p>It is basically the union and the lack of a the name for the structure member (I've called it parts in the code below).  Try this</p>

<pre><code>union Signal
{
    struct
    {
        unsigned unit   :2;
        unsigned channel:2;
        unsigned status :1;
        unsigned group  :1;
        unsigned remote :26;
    } parts;
    unsigned long data;
};

union Signal signal;

void testPassingStruct(union Signal *variable)
{
    variable-&gt;parts.status = 1;
}

void setup()
{
    signal.parts.status = 1;
    testPassingStruct(&amp;signal);
}

void loop()
{
}
</code></pre>
",,25838378,1670
21070153,2,21070078,2014-01-12T01:21:55.460,0,,840992,,2014-01-13T15:12:51.870,2014-01-13T15:12:51.870,5,,"<p>Think about it: once you enter one of your ""mode"" loops you never check the status of the switch (pot) again. Make sense? The <code>finite state machine</code> suggestion is good but to keep it simple, just break out the code where you are checking the switch and setting the mode into its own function, then call it within each mode loop.</p>

<pre><code>void mode0() {
  while(mode == 0){
  digitalWrite(rPin, LOW);
  digitalWrite(yPin, LOW);
  digitalWrite(gPin, LOW);

  checkSwitch(); // this will potentially change the 'mode' so the while loop with exit if the mode has changed.
  }
}
</code></pre>

<hr>

<p><strong>Update: Delay hack</strong></p>

<p>Not really recommended but I suppose one way to use the <code>delay</code> approach and not lock out all interaction would be to break the delay down to a minimum and check for input in a for loop - something like:</p>

<pre><code>void uglyDelayHack(int delayAmount, int lastMode){

 for (int i = 0; i &lt; delayAmount; i++){

   delay(1); // 1 millisecond delay

   // call to a function that checks for input and changes mode 
   checkForInput(); 

   // get out of the fake delay if mode has changed
   // assumes ""mode"" is a global variable
   if (lastMode != mode) return;
 }
}
</code></pre>
",,25877510,942
21071625,2,21071489,2014-01-12T05:26:52.923,0,,1163660,,2014-01-12T05:26:52.923,,0,,"<p>There is no need to call getpid() to fetch pid. The function fork() returns child's pid in parent's process and 0 in child's process. So, you may directly send a SIGKILL to a child process.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;

int main()
{
    pid_t pid;
    pid = fork();
    if (pid == 0) {
        system(""cat /dev/cu.usbmodem1a21 - 9600 &gt;&gt; num.txt"");
    } else {
        /* ops */
        kill(pid, SIGKILL);
    }
    return 0;
}
</code></pre>
",,25936002,2720
21106212,2,21105965,2014-01-14T04:39:58.910,0,,2419694,,2014-01-14T04:39:58.910,,1,,"<p>Have you tried to do it like this?:</p>

<pre><code>FILE *fp;
char results[50]

/* check if file could be opened */
if((fp=fopen(""test.txt"", ""w"")) == NULL) { // or use ""a"" instead of ""w"" to create the file if it doesn't exist
    printf(""Cannot open file.\n"");
    exit(1);
}
/* put your results into results[] */
 ....
/* afterwards writing to file */
fprintf(fp, ""%s"", results); 
fclose(fp); 
</code></pre>
",,25940073,2602
21108519,2,21108444,2014-01-14T08:02:57.490,4,,1673391,,2014-01-14T08:09:17.987,2014-01-14T08:09:17.987,3,,"<p>Add <code>else</code> as follows: </p>

<pre><code>    if(mode == MODE_PRESSURE)  
       mode = MODE_ALT; 
    else if(mode == MODE_ALT) # although not need but keep if here also
       mode = MODE_PRESSURE; 
</code></pre>

<p>You could <em>also</em> use nested-switch: </p>

<pre><code>switch(mode){
     case MODE_PRESSURE: mode = MODE_ALT; 
             break; 

     case MODE_ALT: mode = MODE_PRESSURE; 
             break;
}
</code></pre>
",,25948196,153
21108825,2,21108444,2014-01-14T08:25:21.423,1,,2679080,,2014-01-14T08:25:21.423,,0,,"<p>The reason is you are assigning the mode to ALT when mode equals to PRESSURE. But you are not using any break statement so it will again set the mode to PRESSURE in the second if condition.</p>

<p>Here is the Sample Solution to your code : </p>

<pre><code>#include &lt;stdio.h&gt;

const int BTN_MODE = 0;
const int MODE_PRESSURE = 1;    // display pressure and temp
const int MODE_ALT = 2; // display altitude relative to sea level
int mode;   // stores the current mode

void setup()
{
    mode = MODE_PRESSURE;
}

void loop()
{

    // Read mode button and set mode accordingly
    // int buttonPressed = readButtons();
    int buttonPressed = BTN_MODE;

    switch (buttonPressed)
    {
        case 0:
            if (mode == MODE_PRESSURE)
            {
                mode = MODE_ALT;
                break;
            }
            if (mode == MODE_ALT)
            {
                mode = MODE_PRESSURE;
                break;
            }
            //Serial.println(mode); // &lt;&lt;-- always prints 1 ?!
            break;
    }
    printf("" The mode value is : %d\n"", mode);
}

void main()
{
    setup();
    loop();
}
</code></pre>
",,25964731,2944
21123493,2,21116241,2014-01-14T20:37:14.623,1,,704596,,2014-01-14T20:37:14.623,,6,,"<p>This uses a <code>struct</code> to mange a pot and the data associated with it (the pin it's on, the last reading, threshold, etc). Then, the <code>rePot()</code> function is changed to take one of those structs as input, instead of just the pin number.</p>

<pre><code>struct Pot {
    byte pin;
    int threshold;
    int lastReading;
    int currentReading;
};

// defining an array of 2 Pots, one with pin A0 and threshold 2, the
// other with pin A2 and threshold 3. Everything else is automatically
// initialized to 0 (i.e. lastReading, currentReading). The order that
// the fields are entered determines which variable they initialize, so
// {A1, 4, 5} would be pin = A1, threshold = 4 and lastReading = 5
struct Pot pots[] = { {A0, 2}, {A2, 3} };

void rePot(struct Pot * pot) {
    int reading = map(analogRead(pot-&gt;pin), 0, 664, 0, 200);

    if(abs(reading - pot-&gt;lastReading) &gt;= pot-&gt;threshold) {
        pot-&gt;currentReading = (reading/2);
        Serial.println(pot-&gt;currentReading);
        pot-&gt;lastReading = reading;
    }
}

void setup(){
    Serial.begin(9600);
}

void loop() {
    rePot(&amp;pots[0]);
    rePot(&amp;pots[1]);
    delay(10);
}
</code></pre>

<p>A slightly different take on this is to change <code>rePot()</code> into a function that takes the whole array as input, and then just updates the whole thing. Like this:</p>

<pre><code>void readAllThePots(struct Pot * pot, int potCount) {
    for(int i = 0; i &lt; potCount; i++) {
        int reading = map(analogRead(pot[i].pin), 0, 664, 0, 200);

        if(abs(reading - pot[i].lastReading) &gt;= pot[i].threshold) {
            pot[i].currentReading = (reading/2);
            Serial.println(pot[i].currentReading);
            pot[i].lastReading = reading;
        }
    }
}

void loop() {
    readAllThePots(pots, 2);
    delay(10);
}
</code></pre>
",,25982525,3923
21143500,2,21117744,2014-01-15T16:54:30.083,0,,2824483,,2014-01-15T17:00:32.887,2014-01-15T17:00:32.887,0,,"<p><strong>A correct use of BCM2835</strong> <br>
Here's problably can work better:</p>

<pre><code>#include &lt;bcm2835.h&gt;
// Led on RPi Plug P1 pin 11 (which is GPIO pin 17)
#define PIN RPI_GPIO_P1_11
uint8_t status = LOW;
int SetLed()
{
    // Inizialize the library
    if (!bcm2835_init())
        return 1;
    // Set the pin to be an output
    bcm2835_gpio_fsel(PIN, BCM2835_GPIO_FSEL_OUTP);
    // Set the Led:
    bcm2835_gpio_write(PIN, status);
    status=!status;
    /*
    I fetched a flip-flop variable, problably does not work without integer variable, so replace the up line with
    if (status == HIGH)
       status = LOW;
    else
       status = HIGH;
    */
    //Clean-up and return success.
    bcm2835_close();
    return 0;
}
</code></pre>

<p>I'm not an expert, the code can be wrong, but the part important are the function <a href=""http://www.airspayce.com/mikem/bcm2835/group__init.html#ga9351fa3ec8eeff4e9d998d3d5d912a4f"" rel=""nofollow"">bcm2835_init()</a>,<a href=""http://www.airspayce.com/mikem/bcm2835/group__gpio.html#gaf866b136c0a9fd4cca4065ce51eb4495"" rel=""nofollow"">bcm2835_gpio_fsel()</a> and <code>bcm2835_close()</code> that must be called almost one time!</p>
",,25985510,253
21149578,2,21147838,2014-01-15T22:25:44.993,1,,1899801,,2014-01-15T22:25:44.993,,1,,"<p>Unfortunately you will need to loop through each of the filenames individually. </p>

<p>please look at an example of my code that does just this. Similar to the above comment by ""A Person"". </p>

<p>Here are links to my actual use <a href=""http://mpflaga.github.io/Sparkfun-MP3-Player-Shield-Arduino-Library/_file_player_8ino_source.html#l00383"" rel=""nofollow"">WHERE I use it</a> and <a href=""http://mpflaga.github.io/Sparkfun-MP3-Player-Shield-Arduino-Library/_s_f_e_m_p3_shield_8cpp_source.html#l02024"" rel=""nofollow"">THE filter function</a></p>

<p>Note that my above use is using the SdFatLib, a more advanced version that SD (the IDE provided) library. Below I have adapted the same function for SD. Should work as it merely inspects the pointed char arrary's last 4 characters. </p>

<p>FYI - Note that the SD and SdFatLib only support 8.3 format. </p>

<pre><code>void printDirectory(File dir, int numTabs) {
  while(true) {
    File entry =  dir.openNextFile();
    if (! entry) {
      // no more files
      break;
    }
    for (uint8_t i=0; i&lt;numTabs; i++) {
      Serial.print('\t');
    }

    if ( isFnMusic(entry.name()) ) { // Here is the magic
      Serial.print(entry.name());
    }

    if (entry.isDirectory()) { // Dir's will print regardless, you may want to exclude these
      Serial.print(entry.name());
      Serial.println(""/"");
      printDirectory(entry, numTabs+1);
    } else {
      // files have sizes, directories do not
      Serial.print(""\t\t"");
      Serial.println(entry.size(), DEC);
    }
    entry.close();
  }
}

bool isFnMusic(char* filename) {
  int8_t len = strlen(filename);
  bool result;
  if (  strstr(strlwr(filename + (len - 4)), "".mp3"")
     || strstr(strlwr(filename + (len - 4)), "".aac"")
     || strstr(strlwr(filename + (len - 4)), "".wma"")
     || strstr(strlwr(filename + (len - 4)), "".wav"")
     || strstr(strlwr(filename + (len - 4)), "".fla"")
     || strstr(strlwr(filename + (len - 4)), "".mid"")
     // and anything else you want
    ) {
    result = true;
  } else {
    result = false;
  }
  return result;
}
</code></pre>
",,26006250,3595
21199851,2,21155255,2014-01-18T04:03:06.643,0,,2083216,,2014-01-18T04:03:06.643,,0,,"<p>Dynamic allocations are a bad idea on AVR not because it is an 8bit MCU, but because of potential stack-heap collisions. The problem above is that you have a global char*, and being global, it gets initialized to <code>NULL</code> [this is part of the C standard, you have no control over this, it is done by the <code>__do_clear_bss</code> section of the final executable]. The moment you do <code>strcpy()</code> on this <code>NULL</code> pointer, you start writing at address 0. Now, if this was an x86 machine and you were working at an application level, the software would crash with a segmentation fault. There is no memory protection in AVR, so <code>strcpy()</code> will happily start copying the string to address 0 in RAM. This falls right into the register file if using absolute addresses, meaning that any variables that were cached on these registers are now trashed. Consider this test case:</p>

<pre><code>#include &lt;string.h&gt;
int main(void) {
    char p[] = ""hello"";
    strcpy(0, p);
    while(1);
}
</code></pre>

<p>which compiles to:</p>

<pre><code>-- snip --
00000096 &lt;main&gt;:
-- snip --
  a0:   cd b7           in  r28, 0x3d   ; 61
  a2:   de b7           in  r29, 0x3e   ; 62
  a4:   86 e0           ldi r24, 0x06   ; 6
  a6:   e0 e0           ldi r30, 0x00   ; 0
  a8:   f1 e0           ldi r31, 0x01   ; 1
  aa:   de 01           movw    r26, r28
  ac:   11 96           adiw    r26, 0x01   ; 1
  ae:   01 90           ld  r0, Z+
  b0:   0d 92           st  X+, r0
  b2:   8a 95           dec r24
  b4:   e1 f7           brne    .-8         ; 0xae &lt;main+0x18&gt;
  b6:   be 01           movw    r22, r28
  b8:   6f 5f           subi    r22, 0xFF   ; 255
  ba:   7f 4f           sbci    r23, 0xFF   ; 255
  bc:   80 e0           ldi r24, 0x00   ; 0
  be:   90 e0           ldi r25, 0x00   ; 0
  c0:   0e 94 63 00     call    0xc6    ; 0xc6 &lt;strcpy&gt;
-- snip --
000000c6 &lt;strcpy&gt;:
  c6:   fb 01           movw    r30, r22
  c8:   dc 01           movw    r26, r24
  ca:   01 90           ld  r0, Z+
  cc:   0d 92           st  X+, r0
  ce:   00 20           and r0, r0
  d0:   e1 f7           brne    .-8         ; 0xca &lt;strcpy+0x4&gt;
  d2:   08 95           ret
</code></pre>

<p>if done with avr-gcc version 4.8.2 and invoking the compiler with <code>avr-gcc -O3 -mmcu=atmega168 -o avr.elf avr.c</code></p>

<p>From the AVR instruction set manual, the st instruction says:
""Stores one byte indirect with or without displacement from a register to data space. For parts with SRAM, the data space consists of the Register File, I/O memory and internal SRAM (and external SRAM if applicable). For parts without SRAM, the data space consists of the Register File only.""</p>

<p>which corroborates the above. Obviously, the compiler doesn't really know you trashed the registers, and will happily use them for other things, trashing them even further. Reading from them after the strcpy() will yield problems as well. You can fix the issue by making a buffer, if you want it global, as <code>char message[8];</code>. Since it is a global variable, all elements get automatically initialized to 0. As to why your data is getting trashed, I would have to see more of your code to determine why. Most likely though, due to memory corruption.</p>

<p>Cheers.</p>
",,26048539,1523
21173379,2,21161118,2014-01-16T21:35:17.397,2,,11654,,2014-01-17T13:12:25.667,2014-01-17T13:12:25.667,1,,"<p>To send some events at a specific time:</p>

<ul>
<li>open the sequencer;</li>
<li>create your own (source) port;</li>
<li>construct and send some events.</li>
</ul>

<p>To open the sequencer, call <code>snd_seq_open</code>.
(You can get your client number with <code>snd_seq_client_id</code>.)</p>

<pre><code>    snd_seq_t seq;
    snd_seq_open(&amp;seq, ""default"", SND_SEQ_OPEN_DUPLEX, 0);
</code></pre>

<p>To create a port, allocate a port info object with
<code>snd_seq_port_info_alloca</code>, set port parameters with
<code>snd_seq_port_info_set_</code>xxx, and <code>call snd_seq_create_port</code>.
Or simply call <code>snd_seq_create_simple_port</code>.</p>

<pre><code>    int port;
    port = snd_seq_create_simple_port(seq, ""my port"",
            SND_SEQ_PORT_CAP_READ | SND_SEQ_POR_CAP_WRITE,
            SND_SEQ_PORT_TYPE_APPLICATION);
</code></pre>

<p>To send an event, allocate an event structure (just
for a change, you can use a local <code>snd_seq_event_t</code> variable),
and call various <code>snd_seq_ev_</code>xxx functions to set its properties.
Then call <code>snd_seq_event_output</code>, and <code>snd_seq_drain_output</code> after you've sent all
events.</p>

<pre><code>    snd_seq_event_t ev;
    snd_seq_ev_clear(&amp;ev);
    snd_seq_ev_set_direct(&amp;ev);

    /* either */
    snd_seq_ev_set_dest(&amp;ev, 64, 0); /* send to 64:0 */
    /* or */
    snd_seq_ev_set_subs(&amp;ev);        /* send to subscribers of source port */

    snd_seq_ev_set_noteon(&amp;ev, 0, 60, 127);
    snd_seq_event_output(seq, &amp;ev);

    snd_seq_ev_set_noteon(&amp;ev, 0, 67, 127);
    snd_seq_event_output(seq, &amp;ev);

    snd_seq_drain_output(seq);
</code></pre>
",,26085416,159
21162255,2,21161855,2014-01-16T12:48:29.690,0,,749284,,2014-01-16T12:48:29.690,,2,,"<p>It's not clear why you don't simply <code>open()</code> a new path and <code>write()</code> to that instead of writing to stdout. If that's not an option (it appears to be an option, the best one, in your example code), you can perform run-time redirection using this pseudo code.</p>

<pre><code>#include &lt;unistd.h&gt;

// first open the new output path
int new_out = open(""/path/to/output"", flags_as_needed);

// next, move the standard output path
int save_out = dup(STDOUT_FILENO);
close(STDOUT_FILENO);

// now copy the new output path to the standard output position
dup2(STDOUT_FILENO, new_out);
</code></pre>
",,26108643,3495
21162321,2,21161855,2014-01-16T12:51:09.187,0,,2667005,,2014-01-16T12:51:09.187,,0,,"<p>just open a file and use its file descriptor:<br></p>

<pre><code>#include &lt;unistd.h&gt; 
#include &lt;sys/stat.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;stdlib.h&gt; 

int main() 
{ 
  char block[1024]; //buffer of data
  int out; //file deccriptor
  int nread; //size of data
  out = open(""file.out"", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR); 
  write(out,block,nread); 
  exit(0); 
}
</code></pre>
",,26110581,1524
21194888,2,21188389,2014-01-17T20:05:32.693,0,,1899801,,2014-01-17T20:05:32.693,,0,,"<p>First:</p>

<p>You only update ulForceSensorConductance when iForceSensorVoltage is not zero. Granted I would expect it hard to get a perfect zero.</p>

<pre><code>  if (iForceSensorVoltage == 0){
    Serial.println(""No pressure at index finger"");  
  } 
  else{
  ulForceSensorConductance = conductanceFunction(ulForceSensorResistance,         iForceSensorVoltage);
  delay(30);
  } 
</code></pre>

<p>2nd:</p>

<p>I see that ulForceSensorResistance is only initialized and never actually used assigned any value, but is passed into conductanceFunction as the first argument. Where x inside conductanceFunction is immediately over-written with</p>

<pre><code>unsigned long ulForceSensorResistance1;
...
ulForceSensorConductance1 = conductanceFunction(ulForceSensorResistance1, iForceSensorVoltage1);
...
int conductanceFunction(long x, long y)
{long result;
 x = 5000 - y; // fsrVoltage is in millivolts so 5V = 5000mV
</code></pre>
",,26156076,462
21238307,2,21238223,2014-01-20T15:50:26.830,2,,3159253,,2014-03-28T09:48:16.530,2014-03-28T09:48:16.530,0,,"<p>Smth like:</p>

<pre>
FLAGS = 'pkg-config --cflags opencv --libs opencv'
CC = g++
HOME = /home/pi
LDFLAGS_CAMCV = -L$(HOME)/git/robidouille/raspicam_cv -lraspicamcv
LDFLAGS_USER =-L$(HOME)/git/raspberrypi/userland/build/lib -lmmal_core -lmmal -$
LDFLAGS_FACE = -l$(HOME)/git/emobot/libfacere0.04
LDFLAGS = $(LDFLAGS_CAMCV) $(LDFLAGS_USER)  $(LDFLAGS_FACE)
INCLUDE = -I$(HOME)/git/robidouille/raspicam_cv

all: emobot_test

emobot_test:
<kbd>tab</kbd>$(CC) -o emobot_test.exe  main.cpp $(INCLUDE) $(LDFLAGS)
</pre>

<p><strike>&lt;tab> is a literal keypress, donna how to insert it in the answer field.</strike></p>

<p>Explanation:<br>
<code>$(CC) -o emobot_test...</code> is a command which should be executed upon a target invocation.</p>

<p><code>all</code> is the default target which is executed when you simply run <code>make</code> without parameters.</p>

<p><code>all</code> depends on <code>emobot_test</code> target
<code>emobot_test</code> doesn't depend on any target but always runs <code>$(CC) -o emobot_test...</code> for completion</p>
",,26211084,109
21277576,2,21277499,2014-01-22T08:18:52.353,2,,440558,,2014-01-22T08:26:08.317,2014-01-22T08:26:08.317,0,,"<p>The error tells you exactly what wrong, there is no <code>Wave::Wave()</code> method. You need a default constructor for the <code>Wave</code> class to be able to create an array of it. You might also want to create a copy-assignment operator if the <code>Wave</code> class contains non-trivial data.</p>

<p>The problem is that the array is constructed <em>before</em> the body of the <code>LEDLamps</code> constructor runs, so when inside the <code>LEDLamps</code> constructor body the array is fully constructed, and what you are doing is assignment (using the automatically generated copy-assignment operator).</p>

<hr>

<p>Unfortunately the default Arduino C++ library it quite limited, at least when it comes to ""standard"" C++ features. There are <a href=""https://github.com/maniacbug/StandardCplusplus/blob/master/README.md"" rel=""nofollow"">libraries that helps</a>, and if it's possible to use such a library you could have used an <code>std::vector</code> instead, which would allow you to construct the vector in the constructor initializer-list:</p>

<pre><code>class LEDLamps
{
    ...
    std::vector&lt;Wave&gt; waveVector;
};

...

LedLamps::LEDLamps(...)
    : waveVector(numberOfWaves, Wave(10,2,25,150,100))
{
}
</code></pre>
",,26238307,1312
21294807,2,21294613,2014-01-22T21:54:57.893,2,,1413395,,2014-01-23T02:39:15.213,2014-01-23T02:39:15.213,2,,"<p>String concatenation in <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> is <strong>easy</strong>, just use the <code>+</code> operator :</p>

<pre><code>std::string s1(""Hello"");
std::string s2(""World"");
std::string concat = s1 + s2; // concat will contain ""HelloWorld""
</code></pre>

<p>If you need advanced formatting features or numeric formatting, you can use the <code>std::ostringstream</code> class:</p>

<pre><code>std::ostringstream oss;
oss &lt;&lt; 1 &lt;&lt; "","" &lt;&lt; 2 &lt;&lt; "","" &lt;&lt; 3 &lt;&lt; "", Hello World!"";
std::string result = oss.str(); // result will contain ""1,2,3, Hello World!""
</code></pre>

<p>So, for your situation, you can use this:</p>

<pre><code>int sensorValue = analogRead(A0);
float voltage = sensorValue * (5.0 / 421.0);
std::ostringstream oss;
oss &lt;&lt; std::fixed &lt;&lt; std::setw(6) &lt;&lt; std::setprecision(2) &lt;&lt; voltage;
std::string v = oss.str();
std::string _outbuffer = ""VL"" + v;
Serial.println(v.c_str());
Serial.println(_outbuffer.c_str());
</code></pre>

<p><strong>Note:</strong><br>
To use iostream manipulator functions (as the mentioned <code>std::setw()</code>, etc.) you'll need to <a href=""http://en.cppreference.com/w/cpp/io/manip"" rel=""nofollow""><code>#include &lt;iomanip&gt;</code></a> besides <code>#include &lt;ostringstream&gt;</code>.</p>
",,26247353,1950
21300696,2,21294613,2014-01-23T06:10:46.057,0,,2041317,,2014-01-23T06:10:46.057,,0,,"<p>Try strcat</p>

<pre><code>char v[15 + 1];
v[15] = 0;
dtostrf(voltage, 6, 2, v);
strcpy(_outbuffer, ""VL"");
strcat(_outbuffer, v);
</code></pre>

<p>Alternatively, as suspectus suggested, use sprintf.</p>
",,26248334,2088
21310212,2,21309919,2014-01-23T13:56:39.700,3,,1708042,,2014-01-23T13:59:12.690,2014-01-23T13:59:12.690,0,,"<p>add </p>

<pre><code>#include &lt;limits.h&gt;
</code></pre>

<p>on top and later you can do something like:    </p>

<pre><code>int i, iMax;
int maxValue=INT_MIN;
for(i=0;i&lt;16;i++) {
  if(x[i] &gt; maxValue) {
    maxValue = x[i];
    iMax = i;
  }  
}
</code></pre>
",,26294738,512
21615417,2,21345350,2014-02-06T22:26:44.537,0,,3203571,,2014-02-06T23:03:04.967,2014-02-06T23:03:04.967,0,,"<p>delete:
<code>detachInterrupt(0);</code></p>

<p>If you can change interrupt from CHANGE to HIGH/LOW and add something like 'debouncing'. My version here (HIGH state interrupts):</p>

<pre><code>void interruptfunction() { 

      //your interrupt code here

  while(1){
    if (digitalRead(2)==LOW){
      delay(50);
      if (digitalRead(2)==LOW) break;
    }
  }
}
</code></pre>

<p>Or this: (not tested)</p>

<pre><code>void interruptfunction() { 

      //your interrupt code here

  if (digitalRead(2)==HIGH) state=true;
  else state=false;

  while(1){
    if (digitalRead(2)!=state){
      delay(50);
      if (digitalRead(2)!=state) break;
    }
  }
}
</code></pre>

<p>If you have to react on CHANGE try leaving <code>detachInterrupt(0);</code> but reattach it somewhere in your main loop.</p>
",,26369649,410
21354681,2,21353019,2014-01-25T18:43:09.220,0,,1290438,,2014-01-26T11:45:08.510,2014-01-26T11:45:08.510,2,,"<p>well…</p>

<p>when I first read your answer, I thought wtf does he want global variables? 
But then I read your code (and reformatted it so it was clear that this code is non-sense)… And then I though <em>OMFG!</em></p>

<p>I can't emphasize more the comment of @laune:</p>

<blockquote>
  <p>You can't start programming without learning the fundamentals such as these.</p>
</blockquote>

<p>So what you wrote makes no sense for C or C++. My first advice to you would be to read <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow"">that book</a> (you can find it as ebook easily) and maybe a good book on C++ in your language.</p>

<ul>
<li>global variables are bad and should be avoided as much as possible</li>
</ul>

<p>Usually only exceptions to that rule is often <a href=""http://en.wikipedia.org/wiki/Singleton_pattern"" rel=""nofollow""><em>singletons</em></a> that are often used in Arduino codes mostly because of the design choice to have split the <code>main()</code> function entry point in two functions <code>setup()</code> and <code>loop()</code>.</p>

<ul>
<li>the way you use the <code>extern</code> keyword is just plain non-sense</li>
</ul>

<p>I don't know where to begin with that situation, except maybe giving you links to documentation to read on the topic:</p>

<ul>
<li><a href=""http://zanasi.chem.unisa.it/download/C.pdf"" rel=""nofollow"">The K&amp;R Book</a> page 31</li>
<li><a href=""http://en.wikipedia.org/wiki/External_variable"" rel=""nofollow"">http://en.wikipedia.org/wiki/External_variable</a></li>
<li><p><a href=""http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"" rel=""nofollow"">http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/</a></p>

<ul>
<li>when you do a <code>return</code> the function execution thread ends… </li>
</ul></li>
</ul>

<p>So there's no point in having multiple returns in one execution thread, all the following will never be executed and is considered as dead code.</p>

<p>But apart from this teaching lesson, what you want to do is quite simple, and you can achieve this by using preprocessor macros (which is the usual way for your use case):</p>

<pre><code>#define LED_RED_PIN 12
#define LED_GREEN_PIN 11
#define LED_BLUE_PIN 10

void setup_leds() {
    pinMode(LED_RED_PIN, OUTPUT);
    pinMode(LED_GREEN_PIN, OUTPUT);
    pinMode(LED_BLUE_PIN, OUTPUT)
}

void rgb_mixer(uint8_t r, uint8_t g, uint8_t b) {
    analogWrite(LED_RED_PIN, redvalue);
    analogWrite(LED_GREEN_PIN, greenvalue);
    analogWrite(LED_BLUE_PIN, bluevalue);
}

void setup() {
    setup_leds();
}

void loop() {
    rgb_mixer(128, 128, 128);
}
</code></pre>

<p>You may want to be smart about defining the three led at once, and there are ways to do it. You can create a class that contains the data about the three LEDs, you can write a macro that sets up the three LEDs in one elegant line… </p>

<p>But I'm won't give you any hint like that, because before trying to be smart, you need to <strong>learn</strong>, <strong>experiment</strong> and <strong>fail</strong>. Once you've been through that process, you'll have learned the basics of programming and the C language, and what's the object oriented programing, and what's C++ etc… 
You'll have earned the right to be smart, and you'll figure out those neat ways by yourself!</p>

<p>Until then, have a good read and good luck!</p>

<p>Ok, from what you write I think what you want is the following:</p>

<pre><code>class RGBMixer {
    uint8_t _red, _green, _blue;
    public:
        RGBMixer();
        void begin(uint8_t r_pin, uint8_t g_pin, uint8_t b_pin) {
            _red = r;
            _green = g;
            _blue = b;
            pinMode(r, OUTPUT);
            pinMode(g, OUTPUT);
            pinMode(b, OUTPUT);
        }        
        void mix(uint8_t r, uint8_t g, uint8_t b) {
            analogWrite(_red, r);
            analogWrite(_green, g);
            analogWrite(_blue, b);
        }      
} rgb_mixer;

void setup() {
    rgb_mixer.begin(10, 11, 12);
}

void loop() {
    rgb_mixer.mix(128, 128, 128);
}
</code></pre>
",,26394668,3114
21410976,2,21409042,2014-01-28T16:15:49.220,21,,2711915,,2014-01-28T16:15:49.220,,2,,"<p>The reason it doesn't work is that you need to include something in your a.h or a.cpp files.</p>

<p>Try this in your a.h file and then everything should work.</p>

<pre><code>#ifndef H_A
#define H_A

#include &lt;Arduino.h&gt; //needed for Serial.println
#include &lt;string.h&gt; //needed for memcpy

...
</code></pre>

<p>The reason for this is that you can think of the compiler separately compiling each cpp file. A #include is in fact just an automated copy paste. When the compiler is coming to compile a.cpp, it doesn't know that Serial.println() exists, because it wasn't defined in a.h, which is the only other text that appears in a.cpp. The reason it works when you put it all in the header is that in your main cpp file you have included Arduino.h before the a.h include, so once those #includes have been copy pasted in its as if you just wrote the code there in the first place.</p>

<p>You can just write all your code in headers, but it isn't advisable for various reasons including efficiency at compile time (but as an arduino program can only be 32k, I don't think compile times are going to get too long!)</p>
",,26448152,142
24345704,2,21418036,2014-06-21T20:44:02.887,3,,1789612,,2014-06-21T20:44:02.887,,0,,"<p>I just ran into this same issue and was able to resolve it by including StandardCplusplus.h in my main sketch .ino file, rather than in the C++ class header file that I wanted to use the vector in. So, it looks roughly like this:</p>

<pre><code>/*
 Main.ino (or whatever your main sketch file is called)
*/

#include &lt;StandardCplusplus.h&gt;
#include ""Node.h""

// ...

void setup()
{
}

void loop()
{
}
</code></pre>

<p>Then in Node.h:</p>

<pre><code>/*
 Node.h
*/
#ifndef Node_h
#define Node_h

#include &lt;vector&gt;
class Node
{
  public:
      Node();
      ~Node();
      std::vector&lt;int&gt; test;
};

#endif
</code></pre>
",,26455495,771
21464832,2,21464214,2014-01-30T18:38:05.133,0,,2077394,,2014-01-30T18:56:10.747,2014-01-30T18:56:10.747,7,,"<p>Dynamic array in C++ is found under the name vector. You call would become:</p>

<pre><code>class Relay
{
    public:
        Relay(const std::vector&lt;short&gt; &amp;pins) 
           : _binding(pins.size()), _relay(pins) {}
    private:
        std::vector&lt;short&gt; _relay;
        std::vector&lt;short&gt; _binding;
};


int main() {
  // C++ 11
  //  Relay r({1, 2, 3, 4});

  // C++03
  short arr[] = {1, 2, 3, 4};
  std::vector&lt;short&gt; v(std::begin(arr), std::end(arr));
  Relay r(v);
}
</code></pre>

<p>There are multiple issues in your code, for instance:</p>

<pre><code>short *_relay;
</code></pre>

<p>is a pointer, sizeof(_relay) is the size of the pointer, nothing to do with the size of the memory allocation it points to. So  sizeof(_relay)/sizeof(short); is equivalent to  sizeof(short *)/sizeof(short); which does not really make any sense.</p>

<p>When you do:</p>

<pre><code>_relay = _pins;
</code></pre>

<p>you are copying a pointer, now _relay points to the same place _pins point. However this memory where they points to was ""volatile"": it is a temporary you allocated at the call site. It will be de-allocated as soon as the call return. Your pointer is now pointing to an area you should not access anymore.</p>
",,26455904,2588
21467525,2,21464214,2014-01-30T21:14:54.700,0,,3191481,,2014-01-30T21:33:20.200,2014-01-30T21:33:20.200,0,,"<p>It's generally questionable class design to have a C++ class contain a pointer to ""outside data.""  Often a better way to do it is to have your C++ use a copy of the external data, so it's clear that the memory is de-allocated when the class instance is destroyed.  </p>

<p>Also as someone else mentioned, some of these things are much easier to do with C++11.  If you're using <code>g++</code> or <code>clang++</code> as your compiler, you may already have support for C++11, which makes a lot of things very nice and easy, especially for embedded system work.  </p>

<p>In this particular case, here's a complete and compilable program (I used <code>g++</code> and compiled with <code>g++ -std=c++11 -o relay relay.cpp</code> with the following as the contents of <code>relay.cpp</code>.  I've combined everything into a single file for simplicity of illustration, but in real life, you should keep the separation of <code>.cpp</code> and <code>.h</code> files that you already had.</p>

<p>#include 
   #include </p>

<pre><code>class Relay
{
    public:
        Relay(std::vector&lt;short&gt; pins)
            : _relay(pins), _binding(pins.size()) {}
        // these are just diagnostics for testing the class
        std::ostream&amp; printPins(std::ostream &amp;out) {
                for (auto i : _relay) 
                      out &lt;&lt; i &lt;&lt; ' '; 
                   out &lt;&lt; std::endl; 
        }
        std::ostream&amp; printBindings(std::ostream &amp;out) { 
                for (auto i : _binding) 
                    out &lt;&lt; i &lt;&lt; ' '; 
                out &lt;&lt; std::endl; 
        }
    private:
        std::vector&lt;short&gt; _relay;
        std::vector&lt;short &gt; _binding;
};

enum {A0=80, A1, A2, A3, A4};

int main()
{
    Relay reles{std::vector&lt;short&gt;{11, 10, 9, 8, 7, 3, 2, 73, 
                                 4, A0, A1, A2, A3, A4}};
    reles.printPins(std::cout);
    reles.printBindings(std::cout);
    return 0;
}
</code></pre>

<p>The <code>enum</code> for the <code>A0</code> through <code>A4</code> lines are just for completeness in this example, but they might be <code>#define</code> or <code>const int</code> declarations.  It doesn't matter.  </p>

<p>The two <code>print...()</code> functions are only for illustration to demonstrate that it's actually doing what's expected.  In this case, the output is:</p>

<pre><code>11 10 9 8 7 3 2 73 4 80 81 82 83 84 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 
</code></pre>

<p>The <a href=""http://www.cplusplus.com/reference/vector/vector/vector/"" rel=""nofollow"">std::vector</a> is part of the standard library and could be used even if you're not using C++11.  If you are, then you can take advantage of such interesting things as <em>move</em> semantics and <em>constexpr</em> and other goodies that are of particular use in embedded systems.  One such nice feature is called a <strong>list initialization</strong> and is used within <code>main</code> in this sample program.  In this line:</p>

<pre><code>    Relay reles{std::vector&lt;short&gt;{11, 10, 9, 8, 7, 3, 2, 73, 4, A0, A1, A2, A3, A4}};
</code></pre>

<p>A temporary <code>std::vector&lt;short&gt;</code> is created and then used to initialize the <code>reles</code> class instantiation.  A clever compiler can, under some circumstances, optimize away the creation of such temporaries.  As always, looking at the actual assembly language output is useful for evaluating particular techniques and particular compilers.</p>

<p>Another thing that I find very useful is the <code>for (auto i : _relay)</code> style of <code>for</code> loop. This tells the compiler to automatically infer the type for <code>i</code> by treating <code>relay</code> as a collection of something.  Very concise and very handy.</p>

<p>If you're not yet familiar with the C++ language (or just the relatively new parts), I'd recommend getting a book such as Stroustrup's <strong>The C++ Programming Language, fourth ed.</strong>.</p>

<p><strong>Edit</strong>:
In the unfortunate case that you have a very limited C++ compiler, as seems to be the <a href=""http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_cplusplus"" rel=""nofollow"">the situation</a> with the Arduino, you'll need to do things differently.  Specifically, because you don't have an <code>operator new</code> or <code>operator delete</code> you'll have to either pre-allocate some maximum size for your arrays, or simply rely on those being passed in as part of the initialization.  Here's one way to do that:</p>

<pre><code>#include &lt;cassert&gt;

class Relay
{
    public:
        Relay(int numpins, short *pins, short *bindings)
            : _numpins(numpins), _relay(pins), _binding(bindings) {}
    short pin(int i) 
    {
    if ((i &lt; 0) || (i &gt;= _numpins))
        return -1;
    return _relay[i];
    }
    short binding(int i)
    {
    if ((i &lt; 0) || (i &gt;= _numpins))
        return -1;
    return _binding[i];
    }
    private:
        int _numpins;
        short *_relay;
        short *_binding;
};

enum {A0=80, A1, A2, A3, A4};

int main()
{
    const int numpins = 14;
    short pins[numpins] = {11, 10, 9, 8, 7, 3, 2, 73, 
                           4, A0, A1, A2, A3, A4};
    short bindings[numpins] = {1, 2, 3, 4, 5, 6, 7,
                           8, 9, 10, 11, 12, 13, 14};
    Relay reles(numpins, pins, bindings);
    assert(reles.pin(0) == 11);
    assert(reles.binding(4) == 5);

    return 0;
}
</code></pre>
",,26481217,9039
21500633,2,21500110,2014-02-01T16:36:39.357,0,,3239580,,2014-02-01T16:36:39.357,,7,,"<p>See the following code:</p>

<p>You should put this '\0' at the end of the string in the array.</p>

<p>currentLine[index+1] = '\0';  this line should be called out of the ""while loop"".
Otherwise strcmp alway got only one character from the ""currentLine"".</p>

<p><strong>And please take care of the array length of the string buffer when you store the input</strong></p>

<pre><code>while(inChar=client.read())
{         
    currentLine[index++] = inChar; //read in all characters of count
}
currentLine[index] = '\0';

if(strcmp(currentLine,lastCount)!=0) //no
</code></pre>
",,26489501,2136
21503278,2,21503139,2014-02-01T20:32:34.793,2,,2385309,,2014-02-01T21:23:23.107,2014-02-01T21:23:23.107,4,,"<pre><code>String finaldata = """";
void loop()
{

    while (Serial.available()) {
        char recv = Serial.read();
        if (recv != 0x00) finaldata += recv;
        if(finaldata.indexOf('}') &gt; 1){
            int firstBracket = finaldata.indexOf('{');
            int secondBracket = finaldata.indexOf('}');
            finaldata = finaldata.substring(firstBracket, secondBracket);
            Serial.print(finaldata);
            break;
        }
        delay (10);
    }
}
</code></pre>
",,26518427,5332
21506507,2,21504290,2014-02-02T03:02:09.373,0,,840992,,2014-02-02T03:02:09.373,,0,,"<p>It can get tricky using classes with Arduino/Wiring since, to simplify things for us, there is stuff that goes on at compile time which is not obvious (and not like using straight C++).</p>

<p>For your task, writing a function to set the pin should work (and good practice - the whole encapsulation thing). The code below compiles (though I haven't run it).</p>

<p>Careful with classes on Arduino though - there isn't much memory to play with so sometimes, the cleaner, more obvious approach won't work and one needs to resort to storing things in arrays and using lots of variables.</p>

<pre><code>class output_control{

public:
  void  output_on(){
    digitalWrite(_pin,HIGH);  //Just an example 
  }
  void  setPin(int p){
    _pin = p;
  }

  private:
   int _pin;
};


output_control device[10]; // declare the array of objects

void setup(){
  //init the variables
  device[0].setPin(6);
  device[1].setPin(7);
}

void loop(){
 // do some stuff


}
</code></pre>
",,26541882,231
21532178,2,21531898,2014-02-03T16:11:46.407,0,,391531,,2014-02-03T16:11:46.407,,1,,"<p>The syntax for declaring an array of arrays in C is pretty straightforward:</p>

<pre><code>int twodee[OUTER_SIZE][INNER_SIZE];
</code></pre>

<p>Lookups are similarly simple:</p>

<pre><code>twodee[3]; // This is the 4th INNER_SIZE-element array in the table.
           // It's of type int[INNER_SIZE].
</code></pre>

<p>If all the arrays in your lookup table are the same size, use that. If they're not, you'll need a way to point to different-sized arrays with your table. The best way to do that is with structs:</p>

<pre><code>struct array
{
    int len;
    int data[];
};

struct array *table[NUMBER_OF_ARRAYS];
</code></pre>

<p>That way, you can fill your table with pointers to arrays and keep track of the sizes of the arrays being pointed to. To assign a <code>struct array a</code> to the lookup table, just do this:</p>

<pre><code>table[n] = &amp;a;
</code></pre>
",,26559333,201
21532860,2,21531898,2014-02-03T16:46:31.810,3,,3215383,,2014-02-03T17:36:14.350,2014-02-03T17:36:14.350,3,,"<p>If you don`t want to declare an auxiliary struct, you need at least an array to store the sizes of the data arrays, and pass such length to the function. You can conveniently use sizeof to ensure they are correctly computed. I have tried the following code in arduino and it builds:</p>

<pre><code>#include ""Arduino.h""

//bii:#entry_point()
void setup(){
}
void sendRawDataToIRLED(int array[], int len){
//your code here
}
void loop()
{
    int Samsung_power[] = {4500, 243, 23};
    int Channel_1[] = {450, 23, 233, 44, 55};
    int* FunctionArray[2] = {Samsung_power, Channel_1};
    int sizeArray[] = {sizeof(Samsung_power)/sizeof(int), sizeof(Channel_1)/sizeof(int)};
    int index = 0;//whatever your index
    sendRawDataToIRLED(FunctionArray[index], sizeArray[index]);
}
</code></pre>
",,26559944,55
21565429,2,21564242,2014-02-04T23:06:08.337,1,,3198471,,2014-02-06T10:34:03.497,2014-02-06T10:34:03.497,7,,"<p>I think you better should build program B as a shared library, and add to the include_directories of program A the includes of program B. Then target_link_libraries to your program A.</p>

<p>Edit:</p>

<p>What I have in mind is a project with this folder structure:</p>

<pre><code>projA/
    CMakeLists.txt
    include/
    src/
    B/ 
       CMakeLists.txt
       include/
       src/
</code></pre>

<p>The CMakeLists.txt in B is very classical and build the shared library libB.so (e.g. on linux, .dll on WIN32).</p>

<p>In the CMakeLists.txt of projA folder put:</p>

<pre><code># first build project B
add_subdirectory(B)

# add include directory of project B
include_directories(""${CMAKE_CURRENT_SOURCE_DIR}/B/include"")

# [...] build here your project

# and finally:
target_link_libraries(A B)
</code></pre>

<p>I hope it helps</p>

<p>EDIT2:
To build shared libraries you can set:</p>

<pre><code>OPTION(BUILD_SHARED_LIBS TRUE)
</code></pre>

<p>or simply</p>

<pre><code>SET(BUILD_SHARED_LIBS TRUE)
</code></pre>

<p>EDIT 3:
You can also use it simply as an external library. Set libraries search path first: </p>

<pre><code>LINK_DIRECTORIES(${yourPathToLibB})
</code></pre>

<p>Don't forget to </p>

<pre><code>include_directories(""${yourPathToLibB}/include"") 
</code></pre>

<p>too. And then just do </p>

<pre><code>TARGET_LINK_LIBRARIES(A B)
</code></pre>
",,26606792,415
21607031,2,21606412,2014-02-06T15:28:13.043,0,,1827600,,2014-02-06T15:28:13.043,,2,,"<p>You must protect against buffer overflow. The buffer <code>tmp</code> must be terminated with a zero value byte. <code>tmp</code> is static so is zero filled. Use a sentinel value (<code>BufferMaxChars</code>) to ensure that the final byte of the buffer is zero-value terminated.</p>

<p>I am guessing here - but possibly you want to print out the string value enclosed with quotes. If that is the case, the tmp buffer would only be assigned once count == 1 (when the first quote char was found).</p>

<pre><code>void loop() {
   const int BufferMaxChars = 100-1;
   static int i = 0;
   static int count = 0;
   static char tmp[BufferMaxChars];

   if (wifly.avaible()) {
      char c = wifly.read();
      Serial.print(c);
      tmp[i] = c;
      i++;
      if (c == '""')
         count++;
      if (i &gt;= BufferMaxChars || count == 2)
      {
         Serial.print(""Received : "");
         Serial.println(tmp);
      }
   }
}
</code></pre>
",,26607999,5104
21639955,2,21639725,2014-02-08T00:00:46.613,4,,3125280,,2014-02-08T00:00:46.613,,0,,"<p>You just need to change your code so that it calculates the average when index == 10. If you cahnge numReadings to 10, you could try code like this:</p>

<pre><code>void loop(){
  ...

 //total= total - readings[index];
 //you don't need the array here anymore
 //readings[index] = analogRead(EchoPin);
 //total = total + readings[index];
 total = total + analogRead(EchoPin);
 index = index + 1;

 if (index &gt;= numReadings)
 {
   index = 0;

   average = total / numReadings;

   Serial.print(""Dist_avg = "");
   Serial.print(average);
   Serial.println(""mm"");
   delay(100);

   if (average &gt; 400)
     digitalWrite(LedPin, HIGH);   // turn the LED on (HIGH is the voltage level)
   else
     digitalWrite(LedPin, LOW);    // turn the LED off by making the voltage LOW

   total = 0;
 }
</code></pre>
",,26619517,639
21647902,2,21642134,2014-02-08T15:33:40.683,0,,2227452,,2014-02-08T15:33:40.683,,6,,"<p>You are calling the first function from your main file which means those variables must exist in the main file. You don't actually change them in the rgbInitiate(), so sample code in your main file would looks like this:</p>

<pre><code>int r = 2;
int g = 3;
int b = 4;
libname.rgbInitiate(r,g,b);
</code></pre>

<p>then you pass those variables to the next function from your main file
    libname.rgbMixer( r,g,b,ledID, redvalue, greenvalue, bluevalue)</p>

<p>Also, your first function (as it is written) can be simplified greatly</p>

<pre><code>int rgbInitiate(int r, int g, int b)
{
    pinMode(r, OUTPUT);
    pinMode(g, OUTPUT);
    pinMode(b, OUTPUT);
}
</code></pre>
",,26654568,69
21657278,2,21642134,2014-02-09T09:14:39.907,0,,1927972,,2014-02-09T09:14:39.907,,1,,"<p>You where close, you just need to move the pin variable definitions out of the function.  That will make them have a permanent lifetime.  Your library probably does not need any module other than the .CPP file they are defined in to use the variables 'redpin', etc.  The addition of 'static' below means that these variable will not be visible to other code modules.  That means if some application by chance uses a variable 'redpin' then it will not interfere with your code.</p>

<pre><code>// somefile.cpp
static int redpin;
static int greenpin;
static int bluepin;

int rgbInitiate(int redpin, int greenpin, int bluepin) {   
  redpin = redpin;
  greenpin = greenpin;
  bluepin = bluepin;
  ...
}

void rgbMixer(int redvalue, int greenvalue, int bluevalue) {   
  analogWrite(redpin, redvalue);
  analogWrite(greenpin, greenvalue);
  analogWrite(bluepin, bluevalue);
}
</code></pre>

<p>You showed no use of ledID.  Are you thinking there are more than one LED?  C++ will not construct variable names on the fly.  If you are going to have N LED's then the above would use an array.</p>

<pre><code>static int redpin[4];
...

int rgbInitiate(int ledID, int redpin, int greenpin, int bluepin) {   
   redpin[ledID] = redpin;
   ...
}

void rgbMixer(int ledID, int redvalue, int greenvalue, int bluevalue) {   
  analogWrite(redpin[ledID], redvalue);
  ...
}
</code></pre>
",,26661041,1764
21667726,2,21664672,2014-02-10T01:40:42.243,0,,3231194,,2014-02-10T01:40:42.243,,0,,"<p>this is the way I solved the bug.
changed the way I receive the data.</p>

<pre><code>char Comp(char* This) {

while(Serial.available()) {
  inChar = Serial.read();
  inData.concat(inChar);
 }

  strcpy(inData2, inData.c_str());
   token = strtok(inData2, s);
        strcpy(x1,token);

            token = strtok(NULL, s);
          strcpy(x2,token);

              token = strtok(NULL, s);
              strcpy(x3,token);

if (strcmp(x1,This)  == 0) {

Serial.println(x1);
Serial.println(x2);
Serial.println(x3);

   inData = """";
   inChar = '\0';
    return(0);
}
else {
return(1);
}

}
</code></pre>
",,26685537,742
21679691,2,21678099,2014-02-10T14:21:32.053,3,,225074,,2014-02-10T14:21:32.053,,4,,"<p>You will need to combine the 4 hex bytes into a single unsigned integer.  </p>

<p>This depends on Endianess (search for it).  </p>

<p>For Big Endian:</p>

<pre><code>  unsigned int hex_num;
  hex_num =  uidByte[0] &lt;&lt; 24;
  hex_num += uidByte[1] &lt;&lt; 16;
  hex_num += uidByte[2] &lt;&lt;  8;
  hex_num += uidByte[3];
</code></pre>

<p>For Little Endian, reverse the order of uidByte positions.</p>
",,26691864,825
30013391,2,21690360,2015-05-03T11:39:28.393,0,,4859068,,2015-05-03T12:39:27.680,2015-05-03T12:39:27.680,0,,"<p>You have to add an Error-Byte. Take a look at this website for an explanation: <a href=""https://sf264.wordpress.com/2011/03/10/howto-mlx90614-und-pwm/"" rel=""nofollow"">https://sf264.wordpress.com/2011/03/10/howto-mlx90614-und-pwm/</a></p>

<p>Calculating CRC-8 for <code>00002e4b00</code> gives <code>0xa3</code>.</p>

<p>I used for calculating CRC-8 this website: <a href=""http://smbus.org/faq/crc8Applet.htm"" rel=""nofollow"">http://smbus.org/faq/crc8Applet.htm</a></p>

<p>I haven't tested this, but I think this should work:</p>

<pre><code>buf[0] = 0x2e;
buf[1] = 0x4b;
buf[2] = 0x00;
buf[3] = 0xa3;
why = bcm2835_i2c_write(buf,4);
</code></pre>
",,26695305,60
30151083,2,21690360,2015-05-10T11:54:16.120,0,,4884267,,2015-05-11T17:12:51.293,2015-05-11T17:12:51.293,0,,"<p>Struggled with the exact same problem with my mlx90614s. Here is the write routine I used to solve it (Please note that the bcm2835-library was properly initalized before the call to the routine). </p>

<p>First I called the write routine with ""correct"" Slaveaddress, command=0x2E (EEPROMAccess | SMBusAddressReg) and data=0x0000 (for erase). The ""correct"" slave address can be 0x00 or the factory default 0x5a (or whatever is the chip's true address). </p>

<p>After erasing I used the same write routine but now with data=0x005b, to change from the factory default 0x5a to 0x5b, did a Power Off Reset (POR) and the device showed up with its new address (0x5b) using i2cdetect.</p>

<pre><code>uint8_t memWriteI2C16(uint8_t SlaveAddress, uint8_t command, uint16_t data)
{    
unsigned char arr[5];
uint8_t status;

//Prepare for CRC8 calc
arr[0] = SlaveAddress&lt;&lt;1;        //NB! 7 bit address + a 0 write bit.      
arr[1] = command;                //Command byte in packet       
arr[2] = *((uint8_t *)(&amp;data));  //Extract data low byte
arr[3] = *((uint8_t *)(&amp;data)+1);//Extract data high byte
arr[4] = crc8(&amp;arr[0],4)&amp;0xFF;   //Calculate PEC by CRC8

bcm2835_i2c_setSlaveAddress(SlaveAddress);//Transmit address byte to I2C/SMBus
status = bcm2835_i2c_write (&amp;arr[1], 4);  //Transmit Command,DataL, DataH and PEC       
bcm2835_delay(5);                         //Delay at least 5ms
return (status);
}
</code></pre>

<p>The CRC8 routine I used was:</p>

<pre><code>// Return CRC-8 of the data, using x^8 + x^2 + x + 1 polynomial.  
// A table-based algorithm would be faster, but for only a few bytes 
// it isn't worth the code size. 
// Ref: https://chromium.googlesource.com/chromiumos/platform/vboot_reference/+/master/firmware/lib/crc8.c
uint8_t crc8(const void *vptr, int len)
{
 const uint8_t *data = vptr;
 unsigned crc = 0;
 int i, j;
 for (j = len; j; j--, data++) {
    crc ^= (*data &lt;&lt; 8);
    for(i = 8; i; i--) {
        if (crc &amp; 0x8000)
            crc ^= (0x1070 &lt;&lt; 3);
        crc &lt;&lt;= 1;
    }
 }
 return (uint8_t)(crc &gt;&gt; 8);
}
</code></pre>

<p>In addition: according to the data sheet for the the mlx90614, its default factory state after power up is PWM output. When hooking an mlx90614 in the factory PWM state to the I2C bus on the RPi2, the i2cdetect reports hundreds of I2C devices on the bus. Trying to access the mlx90614 by using the bcm2835-library fails. What is required is to force the mlx90614 out of its PWM-state by holding the SCL low for at least 2ms. Here is what I did:</p>

<pre><code>uint8_t mlx90614SMBusInit()
{
//Hold SCL low for at leat 2ms in order to force the mlx90614 into SMBus-mode
//Ref Melix app note regarding SMBus comm chapter 6.1 and table 5. 
uint8_t SCL1 = 3; //BCM2835 pin no 3 -RPi2 and RevB+. Use if i2cdetect -y 1
uint8_t SCL0 = 1; //BCM2835 pin no 1 -RPi2 and RevB+. Use if i2cdetect -y 0
uint8_t SCL;

SCL = SCL1; 
bcm2835_gpio_fsel(SCL, BCM2835_GPIO_FSEL_OUTP);
bcm2835_gpio_write(SCL ,LOW);
bcm2835_delay( 3); //Delay &gt;2 ms
bcm2835_gpio_write(SCL ,HIGH); 
return (1);
}
</code></pre>

<p>However, this only hold until next power up. Hence it is required to write to the pwmctrl-register in mlx90614's eeprom (disable pwm output and force SDA to OpenDrain). I used the write routine as previously described with command=0x22 (i.e. EEPROMAccess | PWMCTRLAddressRegister) and after erasing the pwmctrl-register content, I wrote 0x0200 to it (the frst 3 nibbles was 020 in my devices...). Power Off Reset (POR) and the device started in SMBus-mode (no jamming of the I2C-bus). The mlx90614 is a tricky little component...</p>
",,26709107,2133
21711354,2,21710744,2014-02-11T19:35:33.530,0,,2367525,,2014-02-11T19:50:18.170,2014-02-11T19:50:18.170,1,,"<p>Well, if by getting the hex code you mean getting the hex representation of those characters, you can do this -</p>

<pre><code>const String hexDigits = ""0123456789abcdef"";
char hex[2] = """";

hex[0] = hexDigits[ (int)line.at(i) / 16 ];
hex[1] = hexDigits[ (int)line.at(i) % 16 ];
</code></pre>

<p>For example, if <code>line.at(i) = A</code>, then <code>hex</code> will be <code>""41""</code>.</p>
",,26712701,844
21711388,2,21710744,2014-02-11T19:37:18.567,1,,645128,,2014-02-11T20:17:30.720,2014-02-11T20:17:30.720,0,,"<p><strong><em>Think of Hexadecimal</em></strong>  as just another format to display any data type (uint8_t, or char or int...) stored in memory.  In memory, its all binary, or hexadecimal.  Just depends on how you want to look at it.</p>

<p>For example:  the following statements:  </p>

<pre><code>long int    A = 34;
uint8_t     B = 34;
char        C = 34;
int         D = 34;

printf(""0x%02x\n"", 'A'); // surrounded with '' gives ASCII value of 65, then displayed in Hex
printf(""0x%02x\n"", A);
printf(""0x%02x\n"", B);
printf(""0x%02x\n"", C);
printf(""0x%02x\n"", D);
</code></pre>

<p>Results in:<br>
<img src=""https://i.stack.imgur.com/mIzgr.gif"" alt=""enter image description here"">  </p>

<p>Breaking any string into its fundamental elements, (char, or uint8_t) and printing them as shown above will yield similar results for you.</p>

<p><strong><em>Edit</em></strong>:<br>
For this input file (call it in.txt, in the executable directory):  </p>

<pre><code>lkjahldfkjghlskjhlskjhlakdjgglsjkahlkj4hl5k6jh67=83kjhlkjshdf8f7s698s7dfgbslfkjbg   
</code></pre>

<p><strong><em>And using this code:</em></strong>    </p>

<pre><code>int main(void)
{
    FILE *fp;
    char filename[]="".\\in.txt"";
    uint8_t c;
    int length=0, i=0;
    uint8_t *array;

    //Get number of entries in file:
    fp=fopen(filename, ""r"");
    c= fgetc(fp);
    while(c&lt;255)
    {
        length++;   
        c= fgetc(fp);
    }
    fclose(fp);

    //give array sufficient space
    array = malloc(sizeof(uint8_t)*length);

    fp=fopen(filename, ""r"");

    //read file into array, and display as hexadecimal
    c = fgetc(fp);
    while(c&lt;255)
    {
        array[i++]= c;
        printf(""0x%02x\n"", c);
        c = fgetc(fp);  
    }
    fclose(fp);
        getchar();//stop execution to view files (hit any key to exit)
        return 0
}  
</code></pre>

<p><strong><em>You should see</em></strong> this output:  (only first 20 or so values shown...)<br>
<img src=""https://i.stack.imgur.com/G10eV.gif"" alt=""enter image description here""></p>
",,26811300,47389
21836257,2,21820336,2014-02-17T18:06:40.603,0,,1290438,,2014-02-17T18:06:40.603,,6,,"<p>well, actually, you're lucky it prints anything!</p>

<p>Your problem is that you actually do not allocate any memory for your array, if I remove all the <code>Sub</code> boilerplate, your code is actually the following:</p>

<pre><code>Item i1, i2, i3, i4;
i1.set(4);
i2.set(5);
i3.set(6);
i4.set(7);

// Sub()
Item * items;
int writeIndex;
writeIndex = 0;
// s.addItem(&amp;i1)
items[writeIndex] = &amp;i1;
writeIndex++;
// s.addItem(&amp;i2)
items[writeIndex] = &amp;i2;
writeIndex++;
// s.addItem(&amp;i3)
items[writeIndex] = &amp;i3;
writeIndex++;
// s.addItem(&amp;i4)
items[writeIndex] = &amp;i4;
writeIndex++;
</code></pre>

<p>thing is, <code>Item* items</code> is a pointer that is not defined, and thus contains an unknown value. So when you do <code>items[writeIndex]</code>, you're accessing memory at the position of a random value contained in the <code>items</code> pointer.</p>

<p>If it ""somehow"" works, it's that you're lucky enough to have that ""random"" value being one that looks like it ""almost"" work, while being totally <em>wrong</em>.</p>

<p>In order to fix that situation, you need to allocate memory to the <code>items</code> array. Either by giving it a size when created in the stack:</p>

<pre><code>#define SUB_LENGTH 5 // store up to 5 values
Item items[SUB_LENGTH]
</code></pre>

<p>or by allocating memory from the heap:</p>

<pre><code>Item* items;
Sub() {
    items = (Item*) malloc(SUB_LENGTH);
}
</code></pre>

<p>if you opt for the first option, you have to add a max length check in <code>addItem()</code>:</p>

<pre><code>bool addItem(Item* obj) {
    if (writeIndex &gt;= SUB_LENGTH)
        return false;
    items[writeIndex] = *obj;
    writeIndex++;
    return true;
}
</code></pre>

<p>if you opt for the second option, you may do the max length check, or reallocate the memory to increase the memory size using <a href=""http://linux.die.net/man/3/realloc"" rel=""nofollow""><code>realloc()</code></a>. I'm not giving you an implementation example, because if you need to change the size of the array, you might prefer to implement a linked list (or use an already existing <a href=""http://playground.arduino.cc//Code/StackList#.UwJPrqKvCJQ"" rel=""nofollow"">linked list</a>).</p>
",,26823892,303
25195843,2,21855114,2014-08-08T03:58:33.857,1,,3920778,,2014-08-08T04:43:36.407,2014-08-08T04:43:36.407,0,,"<p>Change GSM_sms; <br/></p>

<p>to <br/></p>

<p>GSM_smsone;  <br/>
GSM_smstwo;<br/></p>

<p>use<br/></p>

<p>smsone.beginSMS(number1);<br/>
smsone.print(txtMsg);<br/>
smsone.endSMS();</p>

<p>smstwo.beginSMS(number2);<br/>
smstwo.print(txtMsg);<br/>
smstwo.endSMS();<br/></p>

<p>for sending the sms.</p>

<pre><code>#include &lt;GSM.h&gt;

#define PINNUMBER """"
const int buttonPin = 4;
const int ledPin1 = 13;
const int ledPin2 = 12;
int buttonState = 0;

// initialize the library instance
GSM gsmAccess; // include a 'true' parameter for debug enabled
GSM_SMS smsone;
GSM_SMS smstwo;

// char array of the telephone number to send SMS
const char* number1 = ""xxxxxxxxxxxxx""; // enter any two mobile numbers here in international format
const char* number2 = ""xxxxxxxxxxxxx"";

// char array of the message
char txtMsg[200] = ""test"";

// connection state
boolean notConnected = true;

void setup()
{
pinMode(ledPin1, OUTPUT);
pinMode(ledPin2, OUTPUT);
pinMode(buttonPin, INPUT);
// initialize serial communications
Serial.begin(9600);

Serial.println(""SMS Messages Sender"");

// Start GSM shield
// If your SIM has PIN, pass it as a parameter of begin() in quotes
while (notConnected)
{
if (gsmAccess.begin(PINNUMBER) == GSM_READY)
  notConnected = false;
else
{
  Serial.println(""Not connected"");
  delay(1000);
}
}
Serial.println(""GSM initialized"");
}

void loop(){

buttonState = digitalRead(buttonPin);
{
   sendSMS();
}
}

void sendSMS()
{
  digitalWrite(ledPin1, HIGH);
  digitalWrite(ledPin2, LOW);
  if (buttonState == HIGH) {
    buttonState = 1;
  };

  if (buttonState == 1) {
    digitalWrite(ledPin2, HIGH);
    delay(1000);
    Serial.print(""Message to mobile number: "");
    Serial.println(number1);
    // sms text
    Serial.println(""SENDING"");
    Serial.println();
    Serial.println(""Message:"");
    Serial.println(txtMsg);
    // send the first message
    smsone.beginSMS(number1);
    smsone.print(txtMsg);
    smsone.endSMS();
    Serial.println(""\nFirst Message Sent\n"");
    digitalWrite(ledPin2, LOW);

    delay (60000);

    digitalWrite(ledPin2, HIGH);
    delay(1000);
    Serial.print(""Message to mobile number: "");
    Serial.println(number2);
    // sms text
    Serial.println(""SENDING"");
    Serial.println();
    Serial.println(""Message:"");
    Serial.println(txtMsg);
    // send the second message
    smstwo.beginSMS(number2);
    smstwo.print(txtMsg);
    smstwo.endSMS();
    Serial.println(""\nSecond Message Sent\n"");
    digitalWrite(ledPin2, LOW);
  }
}
</code></pre>
",,26858796,211
21899192,2,21891437,2014-02-20T05:44:22.267,2,,1899801,,2014-02-20T05:44:22.267,,1,,"<p>I recommend using a UNION of a structure of bits. It adds a clarity and makes it readily portable. You can specify single or any size of adjacent bits. Along with quickly rearranging them.</p>

<pre><code>union {
  uint8_t BAR;
  struct {
    uint8_t  r1 : 1; // bit position 0
    uint8_t  r2 : 2; // bit positions 1..2
    uint8_t  r3 : 3; // bit positions 3..5
    uint8_t  r4 : 2; // bit positions 6..7 
    // total # of bits just needs to add up to the uint8_t size
  } bar;
} foo;

void setup() {
  Serial.begin(9600);
  foo.bar.r1 = 1;
  foo.bar.r2 = 2;
  foo.bar.r3 = 2;
  foo.bar.r4 = 1;

  Serial.print(F(""foo.bar.r1 = 0x""));
  Serial.println(foo.bar.r1, HEX);
  Serial.print(F(""foo.bar.r2 = 0x""));
  Serial.println(foo.bar.r2, HEX);
  Serial.print(F(""foo.bar.r3 = 0x""));
  Serial.println(foo.bar.r3, HEX);
  Serial.print(F(""foo.bar.r4 = 0x""));
  Serial.println(foo.bar.r5, HEX);

  Serial.print(F(""foo.BAR = 0x""));
  Serial.println(foo.BAR, HEX);
}
</code></pre>

<p>Where you can expand this UNION to be larger than bytes</p>

<p>Note uint8_t is the same as byte.</p>

<p>You can even expand the union to an array of bytes and then send the bytes over serial port or clock them out individual as one long word, etc... see a more <a href=""https://github.com/mpflaga/Arduino-IRremote/blob/master/IRremote.h#L30"" rel=""nofollow"">extensive example</a>. </p>
",,26911620,1340
21919499,2,21918715,2014-02-20T21:01:38.833,0,,2877241,,2014-02-20T21:01:38.833,,0,,"<p>In general case they are not the same.</p>

<p>Let's assume that a and b are some expressions. For example a is expression <code>x += z</code> and <code>b</code> is a single variable <code>y</code></p>

<p>Now consider the following code</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() 
{
   int x = -1;
   int y = 1;
   int z = 2;

   // x += z corresponds to a
   // y corresponds to b

   if ( x += z &amp;&amp; y ) std::cout &lt;&lt; ""( x += z &amp;&amp; y ) is equal to true"" &lt;&lt; std::endl;
   else std::cout &lt;&lt; ""( x += z &amp;&amp; y ) is equal to false"" &lt;&lt; std::endl;

   x = -1;

   if ( ( x += z  ) &amp;&amp; ( y ) ) std::cout &lt;&lt; ""( ( x += z  ) &amp;&amp; ( y ) ) is equal to true"" &lt;&lt; std::endl;
   else std::cout &lt;&lt; ""( ( x += z  ) &amp;&amp; ( y ) ) is equal to false"" &lt;&lt; std::endl;

   return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>( x += z &amp;&amp; y ) is equal to false
( ( x += z  ) &amp;&amp; ( y ) ) is equal to true
</code></pre>
",,26940236,149
21924910,2,21924865,2014-02-21T03:49:36.810,1,,1212306,,2014-02-21T03:58:25.150,2014-02-21T03:58:25.150,2,,"<p>You are right, <code>this</code> <em>can</em> be used implicitly in this condition. It can also be used explicitly as it is being done in the code you showed.</p>

<p>In this situation, this code:</p>

<pre><code>void Metro::reset() {
  this-&gt;previous_millis = millis();
}
</code></pre>

<p>is equivalent to:</p>

<pre><code>void Metro::reset() {
  previous_millis = millis(); // this-&gt; will be resolved implicitly by the compiler
}
</code></pre>

<p>However, note that in this sample, the member will <strong>not</strong> be changed, only the local variable.</p>

<pre><code>void Metro::reset() {
  unsigned long previous_millis;
  previous_millis = millis(); // will assign to local variable
  this-&gt;previous_millis = millis(); // will assign to class member
}
</code></pre>
",,26944217,4428
21946907,2,21946585,2014-02-21T23:02:05.640,3,,3121175,,2014-02-21T23:02:05.640,,2,,"<p>You cannot initialize it like that (non constant, non compatible etc.,), instead you can do it during run time</p>

<pre><code>char *tmp;
int i = 0;
tmp = strtok(readString, "","");
while (tmp) {
   ArrayKey[i++] = atoi(tmp);
   tmp = strtok(NULL, "","");
}
</code></pre>
",,26983548,7862
21960395,2,21946796,2014-02-22T20:52:58.990,1,,3127865,,2014-02-22T20:52:58.990,,1,,"<p>I have not worked with the firmata interface, but the following works for processing sketches in general, but has only millisecond resolution (not microsecond):</p>

<pre><code>    void myDelay(int ms)
    {
      try
      {    
        Thread.sleep(ms)
      }
      catch(Exception e) {
      }
    }
</code></pre>
",,26988940,870
21966504,2,21962467,2014-02-23T09:34:14.443,1,,3342041,,2014-02-23T09:34:14.443,,0,,"<p>After sleeping one night on it and two more hours of digging this site (and testing) I finally came across a solution right here; sorry I was not able to find it before posting (I can't figure out why); now it is matter for me to study exactly why the found solution is working (and why there is still a minor problem: some strange characters acquired on starting).
Thanks (and apology) to everybody has read my post.</p>

<p>Here is the working (test) code:</p>

<pre><code>#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;errno.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;termios.h&gt;

#define bufLen 81

int main() {    

    char buf[bufLen];
    struct termios tty;
    FILE * f;
    int fd=open(""/dev/ttyACM0"",O_RDWR | O_NOCTTY);
    if(fd == -1) {
            perror(""Unable to open /dev/ttyACM1\n"");
            return -1;
    } else {
        if(tcgetattr(fd, &amp;tty)!=0) {perror(""tcgetatt() error""); return -1;}
        else {
            cfsetospeed(&amp;tty, B9600);
            cfsetispeed(&amp;tty, B9600);

            tty.c_cflag &amp;= ~PARENB;
            tty.c_cflag &amp;= ~CSTOPB;
            tty.c_cflag &amp;= ~CSIZE;
            tty.c_cflag |= CS8;
            tty.c_cflag &amp;= ~CRTSCTS; 
            tty.c_cflag |= CLOCAL | CREAD;

            tty.c_iflag |= IGNPAR | IGNCR;
            tty.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
            tty.c_lflag |= ICANON;
            tty.c_oflag &amp;= ~OPOST;
            tcsetattr(fd, TCSANOW, &amp;tty);

            if (!(f = fdopen(fd, ""r+t""))) {perror(""fdopen() error""); return -1;}

            while (1) {
                fgets(buf,bufLen,f);
                printf(""%s--\n"",buf);
            }   
        }
    }
    close(fd);
    return 0;
}
</code></pre>
",,27134512,113
21980837,2,21980076,2014-02-24T06:54:50.920,1,,2259878,,2014-02-24T06:54:50.920,,7,,"<p>But do you need to know the time since the start of the program or just intervals. </p>

<pre><code>unsigned long start = millis();
...
// Long running actions....
...
unsigned long stop = millis();
unsigned long interval = stop-start;
</code></pre>

<p>This will still be valid as long as the start and end are not more then 49 days apart. I doubt that you need to count the interval from start of the program until when the counter overflows.</p>

<p>See also here: <a href=""http://forum.arduino.cc/index.php?topic=122413.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=122413.0</a></p>
",,27155572,705
22013113,2,22012854,2014-02-25T11:38:56.793,2,,264148,,2014-02-25T17:04:35.850,2014-02-25T17:04:35.850,1,,"<p>You have a flow control problem.</p>

<p>Your main loop runs <code>SelectMenu()</code> in there you enter <code>Display_function()</code> which contains no loop so it reaches the end and returns to <code>SelectMenu()</code> which then returns to <code>loop()</code> which again calls <code>SelectMenu()</code> redrawing your menu and overwriting the display with the menu again.</p>

<p>There are many ways to solve this, but as this is an arduino environment where resources are anything other than endless I would suggest you make each ""page"" its own loop breaking out of it when needing to move on. Do not switch pages inside the loops or you will build up quite the callstack.</p>

<p>Pseudo code:</p>

<pre><code>loop():
  #print and handle input
  if (navigate)
    Display_function()

Display_function():
  while(true)
    # print and do whatever
    if (nav_angle)
       Display_angle()
    else if (nav_coord)
       Display_coordinate()
    #... etc.
    if (nav_back)
      return

Display_angle():
  while(true)
    #do stuff
    if (nav_back)
      return
</code></pre>

<p>This should give you the idea, it will work as long as you don't have too deep of a structure and run out of memory.</p>
",,27168976,67
22043230,2,22043065,2014-02-26T13:43:37.443,1,,1290438,,2014-02-26T15:47:10.477,2014-02-26T15:47:10.477,4,,"<p>well the other algorithm is easily translatable to pure C:</p>

<pre><code>uint8_t calculate(byte[] bytes) {
    uint16_t crc = 0xFFFF; // initial value
    // loop, calculating CRC for each byte of the string
    for (uint8_t byteIndex = 0; byteIndex &lt; bytes.Length; ++byteIndex) {
        uint8_t bit = 0x80; // initialize bit currently being tested
        for (uint8_t bitIndex = 0; bitIndex &lt; 8; ++bitIndex) {
            bool xorFlag = ((crc &amp; 0x8000) == 0x8000);
            crc &lt;&lt;= 1;
            if (((bytes[byteIndex] &amp; bit) ^ (uint8_t)0xff) != (uint8_t)0xff)
                crc = crc + 1;
            if (xorFlag)
                crc = crc ^ 0x1021;
            bit &gt;&gt;= 1;
        }
    }
    return (uint8_t)crc;
}
</code></pre>

<p>the only difference being the use of the <code>stdint.h</code> types. </p>

<p>I also changed the type of crc to be <em>exactly</em> a 16 bits unsigned, and for the
indexes, only for sparing some arduino memory which is precious (every byte counts
when you got only 2.5k of RAM! :-) )</p>

<p>Though, I did neither test or proof read that code, so it should be as good as the
original C# one. If it's buggy, that one will be as well.</p>

<p>EDIT: As the OP added in comment, this resource is a good explanation of how the above CRC algorithm work: <a href=""http://www.barrgroup.com/Embedded-Systems/How-To/CRC-Calculation-C-Code"" rel=""nofollow"">http://www.barrgroup.com/Embedded-Systems/How-To/CRC-Calculation-C-Code</a>.
HTH</p>
",,27188148,129
50218649,2,22104059,2018-05-07T16:26:55.543,1,,6446479,,2018-05-07T16:26:55.543,,0,,"<p>With respect to Arduino version 1.8.5</p>

<p>First Refer HardwareSerial.h and you will see following lines:</p>

<pre><code>#if defined(UBRRH) || defined(UBRR0H)
  extern HardwareSerial Serial;
  #define HAVE_HWSERIAL0
#endif
#if defined(UBRR1H)
  extern HardwareSerial Serial1;
  #define HAVE_HWSERIAL1
#endif
</code></pre>

<p>Then Refer HardwareSerial0.cpp. You will see following code:</p>

<pre><code>#if defined(UBRRH) &amp;&amp; defined(UBRRL)
  HardwareSerial Serial(&amp;UBRRH, &amp;UBRRL, &amp;UCSRA, &amp;UCSRB, &amp;UCSRC, &amp;UDR);
#else
  HardwareSerial Serial(&amp;UBRR0H, &amp;UBRR0L, &amp;UCSR0A, &amp;UCSR0B, &amp;UCSR0C, &amp;UDR0);
#endif
</code></pre>
",,27208137,119
22107847,2,22107549,2014-02-28T23:36:38.467,0,,1609219,,2014-02-28T23:36:38.467,,0,,"<p>You're problem is that <code>Serial.println()</code> isn't displaying enough digits of accuracy. With <code>printf()</code> I got it to work like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    double d = 6.626e-34l;
    printf(""%.40f\n"", d);
}
</code></pre>

<p>I think with <code>Serial.println()</code> the following should work: (Don't have an arduino handy to test it on)</p>

<pre><code>Serial.println(h, 40);
</code></pre>

<p><a href=""http://arduino.cc/en/Serial/Println"" rel=""nofollow"">http://arduino.cc/en/Serial/Println</a> Says that the 2nd parameter to <code>Serial.println()</code> for floats will set the decimal accuracy.</p>
",,27236703,1427
22129388,2,22129221,2014-03-02T15:17:15.463,-2,,3250340,,2014-03-02T15:24:37.900,2014-03-02T15:24:37.900,5,,"<p>It's pretty trashy, but you can do that with goto labels:</p>

<pre><code>byte dog[8] = {0,0,1,1,1,1,1,0};
byte cat;
int i = 0;

BitWriteBeginning:    
bitWrite(cat, i, dog[7-i]);
i++
if (i &lt; 8)
   goto BitWriteBeginning;
</code></pre>

<p>But even, i'm not sure it will be more efficient. It still a condition to evaluate, and the compiler probably can't optimize that (for instance put i in ecx).</p>

<p>So you can do even more ugly (:D), with putting register label before int i = 0; .</p>
",,27242253,236
22129427,2,22129221,2014-03-02T15:20:57.387,4,,1956010,,2014-03-02T15:39:21.713,2014-03-02T15:39:21.713,2,,"<p>You could unroll the loop:</p>

<pre><code>bitWrite(cat, 0, dog[7]);
bitWrite(cat, 1, dog[6]);
bitWrite(cat, 2, dog[5]);
bitWrite(cat, 3, dog[4]);
bitWrite(cat, 4, dog[3]);
bitWrite(cat, 5, dog[2]);
bitWrite(cat, 6, dog[1]);
bitWrite(cat, 7, dog[0]);
</code></pre>

<p>Or set the bits without a library function (only works if the bytes are guaranteed to be either 0 or 1):</p>

<pre><code>cat = (dog[7] &lt;&lt; 0) |
      (dog[6] &lt;&lt; 1) |
      (dog[5] &lt;&lt; 2) |
      (dog[4] &lt;&lt; 3) |
      (dog[3] &lt;&lt; 4) |
      (dog[2] &lt;&lt; 5) |
      (dog[1] &lt;&lt; 6) |
      (dog[0] &lt;&lt; 7);
</code></pre>

<p>But there's nothing built into C to do this with a single command so it probably won't get much faster than that.</p>

<p><strong>EDIT:</strong> With some bit-twiddling tricks this can be (probably) sped up a little. Something like the following should work on a little-endian 32-bit processor:</p>

<pre><code>uint32_t int_dog = (uint32_t*)dog;
uint32_t t0, t1;

t0 = int_dog[0];   // .......3.......2.......1.......0
t0 |= t0 &lt;&lt; 9;     // ......23......12......01.......0
t0 |= t0 &lt;&lt; 18;    // ....0123.....012......01.......0
t1 = int_dog[1];   // .......7.......6.......5.......4
t1 |= t1 &lt;&lt; 9;     // ......67......56......45.......4
t1 |= t1 &lt;&lt; 18;    // ....4567.....456......45.......4
cat = (t0 &gt;&gt; 20) | (t1 &gt;&gt; 24);
</code></pre>
",,27242894,220
22130204,2,22129949,2014-03-02T16:28:02.063,1,,845568,,2014-03-02T16:28:02.063,,0,,"<p><code>Device</code> has a member variable named <code>hour</code> which takes precedence during name lookup. You need to use the scope operator to instruct the compiler to explicitly use the global function named <code>hour</code>.</p>

<pre><code>#include &lt;Time.h&gt; 
void Device::checkTimedEvent() {
    if(::hour() == hour[timedIndex]) {
    // ^^ fully qualified name using scope operator 
        Serial.println(""TIME!!!!!: "");
    }
}
</code></pre>
",,27264935,123
22135948,2,22133646,2014-03-03T01:02:15.660,-2,,2500951,,2014-03-03T01:02:15.660,,0,,"<p>The best way to do this is to pass the value into the function as a parameter. Here's a simple example:</p>

<p>Class:</p>

<pre><code>class Test
{
public:
    void doSomething(int v);

private:
    int myValue;
};

void Test::doSomething(int v)
{
     myValue = v;
}
</code></pre>

<p>Sketch:</p>

<pre><code>Test t;
int someNumber;

void setup()
{
    someNumber = 27;
    t.doSomething(someNumber);
}
</code></pre>

<p>The <code>setup()</code> function here passes global variable <code>someNumber</code> into the class's member function. Inside the member function, it stores its own copy of the number.</p>

<p>It's important to note that it has a completely independent <strong>copy</strong> of the number. If the global variable changes, you'd need to pass it in again.</p>
",,27335115,2372
22138528,2,22133646,2014-03-03T04:09:49.913,-2,,1899801,,2014-03-03T04:09:49.913,,2,,"<p>As much as Bloomfiled's answer is correct using the the more accepted practice of employing Getter and Setter functions. Below demonstrates this along with making the attribute public and directly accessing it.</p>

<pre><code>class Test
{
public:
    void SetMyValue(int v);
    int  GetPublicValue();
    int  GetPrivateValue();
    int  myPublicValue;

private:
    int myPrivateValue;
};

void Test::SetMyValue(int v)
{
     myPublicValue = v;
     myPrivateValue = v;
}

int  Test::GetPublicValue()
{
     return myPublicValue;
}

int  Test::GetPrivateValue()
{
     return myPrivateValue;
}

Test t;
int someNumber;

void setup()
{
    someNumber = 27;
    t.SetMyValue(someNumber);         // set both private and public via Setter Function
    t.myPublicValue = someNumber;     // set public attribute directly.
    someNumber = t.GetPublicValue();  // read via Getter
    someNumber = t.GetPrivateValue();
    someNumber = t.myPublicValue;     // read attribute directly

}

void loop() {
  // put your main code here, to run repeatedly:
}
</code></pre>
",,27347289,107
33854112,2,22133646,2015-11-22T11:13:12.610,-1,,5591468,,2015-11-22T11:13:12.610,,0,,"<pre><code>class Test
{
  public:
    int N = 0;

};
</code></pre>

<hr>

<pre><code>Test t;
int someNumber = t.N;
</code></pre>
",,27359717,938
39306906,2,22133646,2016-09-03T12:31:32.987,4,,3570671,,2016-09-03T12:31:32.987,,0,,"<p>It appears that the usual C/C++ ""extern"" syntax works in Arduino as if the sketch file were a .cpp file:</p>

<p>Sketch:</p>

<pre><code>int device = 123;
</code></pre>

<p>SomeClass.cpp:</p>

<pre><code>extern int device;

void SomeClass::checkTimedEvent() {
   someDevice = device; // variable from sketch

   // will display ""123"" (or current value of device)
   // if serial output has been set up:
   Serial.println(""device: "" + String(device));
}
</code></pre>

<p>You <em>may</em> need to worry about startup and initialization order, depending on the complexity of your project.</p>
",,27385183,63
22144944,2,22134681,2014-03-03T10:58:43.833,1,,2500951,,2014-03-03T10:58:43.833,,0,,"<p>A <code>char</code> only represents a single character, so <code>myStrings</code> is actually just an array of 26 individual letters/numbers. Everything else in each string is being ignored. It's also important to note that you should only have one character at a time when using single quotes; e.g. <code>'a'</code> is ok, but <code>'abc'</code> isn't going to work properly.</p>

<p>To use a string literal (text that never has to change while the sketch is running), you can use the <code>const char *</code> data type instead of just <code>char</code>, and enclose the text in double quotes, <code>""like this""</code>.</p>

<p>You could re-write your array of strings to look like this:</p>

<pre><code>const char *myStrings[26] = {""password"", ""123456"", ""12345678"",
    ""1234"", ""qwerty"",""12345"",""password"", ""dragon"", ""pussy"",
    ""baseball"", ""football"",""monkey"", ""letmein"", ""696969"",
    ""abc123"", ""mustang"",""michael"", ""shadow"", ""master"",
    ""jennifer"", ""harley"",""1234567"", ""jordan"",
    ""2000"", ""111111"",
    ""COMMON PASSWORDS EXHAUSTED: ATTEMPTING BRUTE FORCE""};
</code></pre>

<p>Each individual string in that array is itself an array of <code>char</code>'s. You can read more about it in the <a href=""http://arduino.cc/en/Reference/String"" rel=""nofollow"">string documentation</a> on the Arduino website.</p>

<p><strong>Usage</strong><br>
If you're only wanting to output these strings to serial, then you would still access it the same way. For example, this loop should still work:</p>

<pre><code>for (int i = 0; i &lt; 27; i++){
    Serial.println(myStrings[i]);
}
</code></pre>

<p>However, if you want to compare two strings of that type then you can't use the usual equality operator (<code>==</code>). You would need to use <code>strcmp()</code>.</p>

<p><strong>String object</strong><br>
An alternative is to use the <code>String</code> object to store your strings. It's a lot easier to use, and it lets you modify the string data at runtime. However, it uses up more memory (which is quite limited on Arduino). If you want to explore that avenue, you can check out the <a href=""http://arduino.cc/en/Reference/StringObject"" rel=""nofollow"">String object documentation</a> on the Arduino website.</p>
",,27392261,8863
22147690,2,22147651,2014-03-03T13:09:43.780,0,,2096695,,2014-03-03T13:09:43.780,,3,,"<p>open braces for else part also</p>

<pre><code>if(arr[0]=='s' &amp; arr[1] =='t' &amp; arr[2]=='a' &amp; arr[3]=='r' &amp; arr[4]=='t'){
    delay(1000);
    Serial.println(""done"");
}
else {
    delay(1000);
    Serial.println(""oo""); 
}
</code></pre>
",,27409566,626
22172243,2,22172128,2014-03-04T12:40:46.613,1,,2428406,,2014-03-05T11:11:34.860,2014-03-05T11:11:34.860,0,,"<p>try this</p>

<pre><code>   main()
    {
    do
     {
      function();
      printf(""welcome to mAIN"");
     }
     while(button!=NONE);
    }
</code></pre>
",,27412408,1254
22196100,2,22172128,2014-03-05T11:13:42.603,0,,2919825,,2014-03-05T11:13:42.603,,0,,"<p>You have to use do while statement execute atleast one time </p>

<pre><code>main()
{
do
 {
  function();printf(""welcome to mAIN"");
 }
 while(button!=NONE);
}
</code></pre>
",,27418767,7690
22180291,2,22179686,2014-03-04T18:43:39.540,0,,3380417,,2014-03-04T18:43:39.540,,0,,"<p>This does not compile. Remove the empty if 3-6 and start using blocks {} with your ifs.</p>

<pre><code>if(Day==0)
    wsk = &amp;Pon;
if(Day==1)
    wsk = &amp;Wt;
if(Day==3)
if(Day==4)
if(Day==5)
if(Day==6)
</code></pre>
",,27426945,2407
22183424,2,22179686,2014-03-04T21:27:47.070,1,,1901789,,2014-03-04T21:27:47.070,,1,,"<p>Sometimes these things don't work the way you intend them to. Try this</p>

<pre><code>if(Day==0)
    wsk = &amp;Pon;
else if(Day==1)
    wsk = &amp;Wt;
else if(Day==3)
    wsk = &amp;Sr;
else if(Day==4)
    wsk = &amp;Czw;
else if(Day==5)
    wsk = &amp;Pia;
else if(Day==6)
    wsk = &amp;So;
</code></pre>

<p>or even better</p>

<pre><code>switch(Day)
{
    case 0: { wsk = &amp;Pon; break; }
    case 1: { wsk = &amp;Wt; break; }
    case 3: { wsk = &amp;Sr; break; }
    case 4: { wsk = &amp;Czw; break; }
    case 5: { wsk = &amp;Pia; break; }
    case 6: { wsk = &amp;So; break; }
    default: break;
}
</code></pre>
",,27446179,5982
22235592,2,22234835,2014-03-06T20:46:50.623,2,,3388817,,2014-03-06T21:34:04.347,2014-03-06T21:34:04.347,1,,"<p>Nope :)</p>

<p>A quick solution may be to wrap your code in a loop, like so:</p>

<pre><code>int initSingleGPIO(int pin)
{
    char buffer [50]; 
    int numBytes; 

    int fh = open(""/sys/class/gpio/export"", O_WRONLY);

    if(fh&lt;0) return -1;

    sprintf(buffer, """");

    numBytes = sprintf(buffer, ""%s\n%d"", buffer, pin);

    int rv = write(fh, buffer, numBytes);

    close(fh);

    return rv;
}

int initGPIO(int pins[], int numPins)
{     
    int i;   
    for (i=0; i&lt;numPins; i++)
    {
        initSingleGPIO(pins[i]);
    }

}
</code></pre>
",,27475951,4230
22309403,2,22239030,2014-03-10T19:24:41.843,0,,3390444,,2014-03-10T19:24:41.843,,0,,"<p>I have solved the problem, Thank you Paweł Stawarz.  Your advice was just what i needed, i converted the entire function to work with strings and it worked first time.</p>

<p>The code is as follows:</p>

<pre><code>string scratchencode(string cmd)
{
    int cmdlength; // holds the length of cmd
    string combind; // used to store the concatenated Packet
    string mgsSize; // used to store Message size

    cmdlength = cmd.length(); // length of CMD

    //convert intiger to a  4 byte 32-bit big-Endian number, using bit shifting.
    mgsSize = (cmdlength &gt;&gt; 24);
    mgsSize += (cmdlength &gt;&gt; 16);
    mgsSize += (cmdlength &gt;&gt; 8);
    mgsSize += cmdlength;

    combind = mgsSize + cmd; // concatenate mgsSize and cmd producing a structure of  [size][size][size][size][string CMD (size bytes long)]
    return combind; // return the string
}
</code></pre>
",,27519279,110
22243079,2,22242071,2014-03-07T06:24:49.653,0,,3150853,,2014-03-07T10:19:54.063,2014-03-07T10:19:54.063,6,,"<p>your code seems require lot of improvement first it why you compare <code>display_screen_type</code> in 
<code>Display_LCD</code> function?
Just leave it for only display and manage it in <code>Action_UP</code> or <code>Action_DOWN</code> </p>

<p>For increment/decrements <code>display_screen_type</code> you must take it as type <code>int</code></p>

<pre><code>int display_screen_type=DATE_TIME;
</code></pre>

<p>your <code>Action_UP</code> and <code>Action_DOWN</code> should be like this </p>

<pre><code>void Action_UP()
{   
    if(display_screen_type &gt;=DISPLAY_TYPE_MAX)
        display_screen_type=DATE_TIME
    else
        display_screen_type++; 
}

void Action_DOWN()
{    
    if(display_screen_type &lt;= DATE_TIME)
        display_screen_type=SET_PARAMETER
    else
        display_screen_type--; 
}
</code></pre>

<p>Also below condition not require in <code>Display_LCD</code> so remove it.</p>

<pre><code>  if(display_screen_type&gt;DISPLAY_TYPE_MAX)
  {
    display_screen_type=DATE_TIME;
  }
</code></pre>
",,27551335,3175
35326945,2,22255975,2016-02-10T22:09:18.550,5,,3213541,,2016-02-10T22:09:18.550,,1,,"<p>I realize this is an old question but for the record I was able to cross compile my OpenCV project from Ubuntu.</p>

<p>In my case I used the the pre-built raspberry pi toolchain on github: <a href=""https://github.com/raspberrypi/tools"" rel=""noreferrer"">https://github.com/raspberrypi/tools</a> on Ubuntu 12.0.4. I took the approach of copying the native libraries (with OpenCV and PiCamera libraries installed) from the target Raspberry Pi system to the Ubuntu instance and using the CMAKE_TOOLCHAIN_FILE support like you mention in your post. </p>

<p>However, there were certain issues I had to overcome, which I cover in this post: <a href=""https://solderspot.wordpress.com/2016/02/04/cross-compiling-for-raspberry-pi-part-ii"" rel=""noreferrer"">https://solderspot.wordpress.com/2016/02/04/cross-compiling-for-raspberry-pi-part-ii</a></p>

<p>The key points were:</p>

<ol>
<li><p>CMAKE_FIND_ROOT_PATH had not effect. I had to use CMAKE_SYSROOT.</p></li>
<li><p>In my CMakeLists.txt file I still had to explicitly prepend any paths with the path to the folder where I had copied over the native file system.</p></li>
<li><p>I also needed to explicitly specify the dynamic library link paths from within CMAKE_TOOLCHAIN_FILE as the toolchain does not correctly parser the /usr/etc/ld.so.conf file.</p></li>
</ol>

<p>The only current issue I could not solve yet was to do with the Jessie release of Raspbian, as OpenCV uses an gcc/g++ 4.9 feature that is not supported by the gcc/g++ 4.8 version of the toolchain. It looks like the toolchain will be augmented to support 4.9 in the near future.</p>

<p>My final CMAKE_TOOLCHAIN_FILE was:</p>

<pre><code>SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_VERSION 1)

SET(DEVROOT $ENV{HOME}/pidev)
SET(PIROOT ${DEVROOT}/piroot)
SET(PITOOLS ${DEVROOT}/pitools)

SET(TOOLROOT ${PITOOLS}/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64)

# specify the cross compiler
SET(CMAKE_C_COMPILER   ${TOOLROOT}/bin/arm-linux-gnueabihf-gcc)
SET(CMAKE_CXX_COMPILER ${TOOLROOT}/bin/arm-linux-gnueabihf-g++)

SET(FLAGS ""-Wl,-rpath-link,${PIROOT}/opt/vc/lib -Wl,-rpath-link,${PIROOT}/lib/arm-linux-gnueabihf -Wl,-rpath-link,${PIROOT}/usr/lib/arm-linux-gnueabihf -Wl,-rpath-link,${PIROOT}/usr/local/lib"")

UNSET(CMAKE_C_FLAGS CACHE)
UNSET(CMAKE_CXX_FLAGS CACHE)

SET(CMAKE_CXX_FLAGS ${FLAGS} CACHE STRING """" FORCE)
SET(CMAKE_C_FLAGS ${FLAGS} CACHE STRING """" FORCE)

SET(CMAKE_SYSROOT ${PIROOT})
SET(CMAKE_FIND_ROOT_PATH ${PIROOT})


# search for programs in the build host directories
SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
# for libraries and headers in the target directories
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
</code></pre>

<p>Where I had a <strong>pidev</strong> folder in my home directory and under that <strong>piroot</strong> had a copy of /usr /opt /etc and /lib from my pi host, and <strong>pitools</strong> is a clone of the toolchain from GitHub I reference above.</p>

<p>My CMakeLists.txt file for my project was:</p>

<pre><code>cmake_minimum_required(VERSION 2.8)
project( PiCamCVTest )
SET(COMPILE_DEFINITIONS -Werror)

include_directories(SYSTEM ${PIROOT}/opt/vc/include ${PIROOT}/opt/vc/include/interface/vcos/pthreads ${PIROOT}/opt/vc/include/interface/vmcs_host/linux )
link_directories( ${PIROOT}/opt/vc/lib )
add_executable(PiCamCVTest main.cpp camera.cpp cameracontrol.cpp graphics.cpp)

target_link_libraries(PiCamCVTest libmmal_core.so libmmal_util.so libmmal_vc_client.so libvcos.so librt.so libbcm_host.so GLESv2 EGL libopencv_core.so libopencv_imgproc.so)
</code></pre>

<p>Hope this helps.</p>
",,27591694,61
22297712,2,22297580,2014-03-10T10:30:21.947,6,,1290438,,2014-03-10T10:41:46.157,2014-03-10T10:41:46.157,0,,"<p>this is not really a code question, but more a basic arithmetics question:</p>

<blockquote>
  <p>how do I transform two values so <code>a</code> and <code>b</code> give <code>a.b</code>?</p>
</blockquote>

<p>simply by using addition and multiplication:</p>

<pre><code>int a=10;
int b=20;
float r=0;

r = a+(b/100f);
</code></pre>

<p>thre's no need for an operator to do that (it takes two CPU instructions to calculate this value, calling a function would be more expensive) ; and it's not called ""concatenation"", but addition and multiplication (again).</p>

<p>If you want a concatenation, you should instead have ""10"" and ""20"" be strings that you concatenate using a dot, as an example, this is a string concatenation:</p>

<pre><code>printf(""%s.%s"", ""10"", ""20"");
</code></pre>
",,27609972,4549
22297812,2,22297580,2014-03-10T10:35:02.257,0,,2576349,,2014-03-10T10:35:02.257,,1,,"<p>If you really just want to concatenate two integers, you could use c++ stringstream's to accomplish that, something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
  int a = 4;
  int b = 5;
  ostringstream oss;
  oss &lt;&lt; a &lt;&lt; ""."" &lt;&lt; b;
  istringstream iss(oss.str());
  float c;
  iss &gt;&gt; c;
  cout &lt;&lt; c &lt;&lt; endl;

  return 0;
}


Output: 4.5
</code></pre>

<p><a href=""http://ideone.com/0qniTy"" rel=""nofollow"">Ideone example</a></p>
",,27650074,2579
22297863,2,22297580,2014-03-10T10:37:37.497,0,,1004301,,2014-03-10T10:37:37.497,,0,,"<p>You could also use the combination of <code>printf()</code> and <code>strtof()</code>:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char *argv[])
{
    int a = 10;
    int b = 20;
    float f;
    char *buf;

    if (asprintf(&amp;buf, ""%d.%d"", a, b) &gt; 0) {
        f = strtof(buf, NULL);
        printf(""%f\n"", f);
        free(buf);
    }

    exit(EXIT_SUCCESS);
}
</code></pre>
",,27651012,68414
22297870,2,22297580,2014-03-10T10:37:47.667,1,,515862,,2014-03-10T10:44:50.423,2014-03-10T10:44:50.423,0,,"<p>No extra library file (such as math.h) is needed, the <code>concat</code> function can be created like this ... </p>

<pre><code>float concat(int a, int b){
    float c;
    c = (float)b;
    while( c &gt; 1.0f ) c *= 0.1f; //moving the decimal point (.) to left most
    c = (float)a + c;
    return c; 
}
</code></pre>
",,27667299,1155
22306724,2,22306583,2014-03-10T17:10:51.780,0,,388520,,2014-03-10T17:10:51.780,,1,,"<p>It is not possible to do exactly what you described.  However, you can achieve your larger goal using arrays instead of the numbered variables:</p>

<pre><code>static const int enablePin[3] = { 1, 4, 7 };
static const int revPin[3]    = { 2, 5, 8 };
static const int fwdPin[3]    = { 3, 6, 9 };

// ...
int ch = Serial.read();
if (ch &gt;= '0' &amp;&amp; ch &lt;= '3') {
    int selection = ch - '0';

    analogWrite(enablePin[selection], speed);
    digitalWrite(revPin[selection],   !reverse);
    digitalWrite(fwdPin[selection],   reverse);
}
</code></pre>
",,27669372,644
22348287,2,22342874,2014-03-12T10:17:06.677,1,,1632774,,2014-03-12T10:17:06.677,,0,,"<p>I have not looked at any logical errors in your program but the error you post is due to the fact that the mod operator i.e. % expects the operand to be integer. So if you modify your code in this way, it should remove the error.</p>

<pre><code>main()
{
int Time1;
int Time2;
int hour=10;
int minute=5;
int second=13;
int h; int m;
int  Ntime; //double has been changed to int
double Ntime2;
Time1=(3600*5)+(60*30);
Time2=(3600*hour)+(60*minute)+second;
Ntime=Time2-Time1;
Ntime2=((double)((Ntime%60)/100) + (double)(Ntime/60));

h=(int)(Ntime2);
m=((Ntime2 - (double)h)*100);
printf(""hour after subtraction is : %d hour %d min"",h,m) 
}
</code></pre>

<p>There is too much type casting involved in your code, you should look for a simpler way to do this. Look into the time.h header file, you may find something useful to work with.</p>
",,27675599,666
22361546,2,22361474,2014-03-12T19:12:08.947,0,,3066467,,2014-03-12T19:29:52.957,2014-03-12T19:29:52.957,1,,"<p>It doesn't really matter. If you compile with optimizations turned on, the compiler should emit the same code in both cases; but the former has the advantage that it's easier to debug with optimizaton turned off.</p>

<p>I just tried this on my raspberry pi, as i don't have an arduino at hand.</p>

<p>This is my y1.c:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef signed char byte;

struct something {
    byte (*getPatternType)();
    byte (*update)(int i);
};

int main(void) {
    struct something mCols[20];
    int i;
    int m=3;

    for (i=0; i&lt;20; i++) {
            byte patternType=mCols[i].getPatternType();
            byte stepIndex=mCols[i].update(m);
            byte patternValue=getPatternValue(patternType, stepIndex);
            printf(""%d\n"", patternValue);
    }
    exit(0);
}
</code></pre>

<p>and this is y2.c:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef signed char byte;

struct something {
    byte (*getPatternType)();
    byte (*update)(int i);
};

int main(void) {
    struct something mCols[20];
    int i;
    int m=3;

    for (i=0; i&lt;20; i++) {
            byte patternValue=getPatternValue(mCols[i].getPatternType(), mCols[i].update(m));
            printf(""%d\n"", patternValue);
    }
    exit(0);
}
</code></pre>

<p>Then:</p>

<pre><code>pi@pi$ cc -O4 -S y1.c
pi@pi$ cc -O4 -S y2.c
pi@pi$ diff y1.s y2.s
13c13
&lt;       .file   ""y1.c""
---
&gt;       .file   ""y2.c""
</code></pre>

<p>As you see, on assembler level, the only difference is the embedded source file name.</p>

<p>I added a printf so the compiler wouldn't just optimize out everything. It didn't, this is y1.s:</p>

<pre><code>    .arch armv6
    .eabi_attribute 27, 3
    .eabi_attribute 28, 1
    .fpu vfp
    .eabi_attribute 20, 1
    .eabi_attribute 21, 1
    .eabi_attribute 23, 3
    .eabi_attribute 24, 1
    .eabi_attribute 25, 1
    .eabi_attribute 26, 2
    .eabi_attribute 30, 2
    .eabi_attribute 18, 4
    .file   ""y1.c""
    .section        .text.startup,""ax"",%progbits
    .align  2
    .global main
    .type   main, %function
main:
    @ args = 0, pretend = 0, frame = 160
    @ frame_needed = 0, uses_anonymous_args = 0
    stmfd   sp!, {r4, r5, r6, lr}
    mov     r4, #0
    sub     sp, sp, #160
.L2:
    add     r5, sp, #0
    ldr     r3, [r5, r4]!
    blx     r3
    add     r4, r4, #8
    ldr     r3, [r5, #4]
    mov     r6, r0
    mov     r0, #3
    blx     r3
    mov     r1, r0
    mov     r0, r6
    bl      getPatternValue
    sxtb    r1, r0
    ldr     r0, .L5
    bl      printf
    cmp     r4, #160
    bne     .L2
    mov     r0, #0
    bl      exit
.L6:
    .align  2
.L5:
    .word   .LC0
    .size   main, .-main
    .section        .rodata.str1.4,""aMS"",%progbits,1
    .align  2
.LC0:
    .ascii  ""%d\012\000""
    .ident  ""GCC: (Debian 4.6.3-14+rpi1) 4.6.3""
    .section        .note.GNU-stack,"""",%progbits
</code></pre>

<p>Note how the compiler treats the loop: the controlling register r4 is incremented by the size of the structure (8), not by one, and compared to 160, not 20, at the end. This saves the multiplication that the array index normally needs, but there's no way for a debugger to get the ""real"" value of i within the loop.</p>
",,27706118,72
22412793,2,22406031,2014-03-14T18:16:23.960,0,,1899801,,2014-03-14T18:16:23.960,,1,,"<p>Use Interrupts to make the work easy.</p>

<pre><code>volatile int IRQcount;
int pin = 2;
int pin_irq = 0; //IRQ that matches to pin 2

void setup() {
  // put your setup code here, to run once:
attachInterrupt(pin_irq, IRQcounter, RISING);
delay(25);
detachInterrupt(pin);
Serial.print(F(""Counted = "");
Serial.println(IRQcount);
}

void IRQcounter() {
  IRQcount++;
}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>

<p>And if you wanted to use a pin other than INT0/1. You can use <a href=""http://playground.arduino.cc/Main/PinChangeIntExample"" rel=""nofollow"">PinChangeInt Libray</a> to use any pin.</p>
",,27722306,1049
22416735,2,22406031,2014-03-14T22:15:48.500,0,,1899801,,2014-03-14T22:15:48.500,,1,,"<p>You are stuck in the </p>

<pre><code>while ( Ftime - Itime &lt; Dtime )
</code></pre>

<p>as the code never actually update either of Ftime or Dtime, while in the WHILE loop. Try the following:</p>

<pre><code>int PSPin = 13;
int DurationTime = 25; // best to have same type as compare or cast it later, below.

int Counter() {
    int i = 0;
    unsigned long StartTime = millis();
    unsigned long PrvTime = StartTime ;
    while ( PrvTime - StartTime &lt; (unsigned long) DurationTime ) {
        if ( digitalRead(PSPin) == HIGH ) {
            i=i+1;
            while ( digitalRead(PSPin) == HIGH); // BLOCK the function until cycles
        }
        PrvTime = millis();
    }
    return i;
}
</code></pre>
",,27729979,1304
22520259,2,22520084,2014-03-19T23:19:38.823,1,,3439823,,2017-03-26T19:58:53.200,2017-03-26T19:58:53.200,1,,"<p>You need to put the if statement inside a loop with an index.</p>

<pre><code>for(x=0; x &lt; sizeof(column) / sizeof(int); x++) {
  if (column[x] &gt; 2) {
      column[x] = 0;
  }
}
</code></pre>
",,27732684,657
22544971,2,22544751,2014-03-20T21:00:13.597,3,,3439196,,2014-03-20T21:00:13.597,,1,,"<p>On the raspberry pi, the serial port is the device /dev/ttyAMA0.  It might also be running a terminal, so you'll have to open up /etc/inittab and comment out this line and reboot:</p>

<pre><code>#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100
</code></pre>

<p>If you don't, your arduino is going to be trying to log in to your pi whenever it sends anything to the serial port.</p>

<p>Another trap is if you want to use binary data in your protocol, XON/XOFF flow control is enabled by default which will silently eat certain bytes (^S and ^Q).</p>

<p>Here's how to open, set the serial port mode (disable flow control!) and baud rate, and write to the serial port:</p>

<pre><code>#include &lt;termios.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
// (i may be forgetting some headers)

...

int fd = open(""/dev/ttyAMA0"", O_RDWR);
if (fd == -1) {
  perror(""/dev/ttyAMA0"");
  return 1;
}

struct termios tios;
tcgetattr(fd, &amp;tios);
// disable flow control and all that, and ignore break and parity errors
tios.c_iflag = IGNBRK | IGNPAR;
tios.c_oflag = 0;
tios.c_lflag = 0;
cfsetspeed(&amp;tios, B9600);
tcsetattr(fd, TCSAFLUSH, &amp;tios);

// the serial port has a brief glitch once we turn it on which generates a
// start bit; sleep for 1ms to let it settle
usleep(1000);    

// output to serial port
char msg[] = ""hi there"";
write(fd, msg, strlen(msg));
</code></pre>
",,27739409,2097
22588416,2,22580242,2014-03-23T08:04:49.650,3,,3450078,,2014-03-23T08:04:49.650,,0,,"<p>The problem was with my placement of <code>wiringPiISR()</code> function. Since I placed it afterwards the initial triggering operation of trigger pin, I was missing the first echo signal as the <code>wiringPiISR()</code> was not setup yet. So the subsequent triggering and hence the echo was not taking place.The problematic code segment was</p>

<pre><code>pinMode(2,OUTPUT);
pinMode(3,INPUT);
pullUpDnControl(3,PUD_DOWN);
digitalWrite(2,0);
delayMicroseconds(1);
digitalWrite(2,1);
delayMicroseconds(10);
digitalWrite(2,0);
if(wiringPiISR(3,INT_EDGE_BOTH,&amp;myInterrupt) &lt; 0)
  {
    cerr&lt;&lt;""interrupt error [""&lt;&lt;strerror (errno)&lt;&lt; ""]:""&lt;&lt;errno&lt;&lt;endl;
    return 1;
   }
</code></pre>

<p>changing this segment to the following made the interrupt trigger</p>

<pre><code>pinMode(2,OUTPUT);
pinMode(3,INPUT);
pullUpDnControl(3,PUD_DOWN);
if(wiringPiISR(3,INT_EDGE_BOTH,&amp;myInterrupt) &lt; 0)
   {
     cerr&lt;&lt;""interrupt error [""&lt;&lt;strerror (errno)&lt;&lt; ""]:""&lt;&lt;errno&lt;&lt;endl;
     return 1;
   }
digitalWrite(2,0);
delayMicroseconds(1);
digitalWrite(2,1);
delayMicroseconds(10);
digitalWrite(2,0);
</code></pre>

<p>I modified the previous code accordingly, and finally I got the following code working nicely and measuring distance in cm.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;wiringPi.h&gt;
#include&lt;errno.h&gt;
#include&lt;string.h&gt;
#include&lt;stdint.h&gt;       //for uint32_t
using namespace std;
uint32_t time1=0,time2=0;
uint32_t time_diff=0;
float Range_cm=0;
volatile int flag=0;
void show_distance(void);

void myInterrupt(void)
 {
    if(flag==0)
      {
            time1=micros();
            flag=1;

      }
    else
      {
            time2=micros();
            flag=0;
            time_diff=time2-time1;
            Range_cm=time_diff/58;
            show_distance();

       }

  }
void show_distance()
  {
    cout&lt;&lt;""distance= ""&lt;&lt;time1&lt;&lt;"" ""&lt;&lt;time2&lt;&lt;"" ""&lt;&lt;time_diff&lt;&lt;"" ""&lt;&lt;Range_cm&lt;&lt;"" cm\n"";
    cout.flush();
    delay(1000);
    digitalWrite(2,0);
    delayMicroseconds(1);
    digitalWrite(2,1);
    delayMicroseconds(10);
    digitalWrite(2,0);

  }

int main(void)
  {
    if(wiringPiSetup()&lt;0)
     {
       cout&lt;&lt;""wiringPiSetup failed !!\n"";
     }
    pinMode(2,OUTPUT);
    pinMode(3,INPUT);
    pullUpDnControl(3,PUD_DOWN);
    if(wiringPiISR(3,INT_EDGE_BOTH,&amp;myInterrupt) &lt; 0)
            {
            cerr&lt;&lt;""interrupt error [""&lt;&lt;strerror (errno)&lt;&lt; ""]:""&lt;&lt;errno&lt;&lt;endl;
            return 1;
            }
    digitalWrite(2,0);
    delayMicroseconds(1);
    digitalWrite(2,1);
    delayMicroseconds(10);
    digitalWrite(2,0);

    while(1)
    {
    }
    return 0;
 }
</code></pre>
",,27760302,2892
22643927,2,22597633,2014-03-25T19:00:32.300,0,,1526963,,2014-03-25T19:00:32.300,,0,,"<p>Well I managed to solve it by dividing the logic between priming for a answer, and then waiting for the input to the answer, if anyone is interested:</p>

<pre><code>// Squash Scorer, by @MrWigster
            // Squash scoring is fairly easy for the most part, however at 10-10 the first player to have reached 10 must decide whether to play until 13 or 15, as the winner must always have a 2 point lead.
            // For this reason we need to include logic to let the players choose what score to play until, always in either incremenets of 2 || 4. EG: 13 || 15, 17 || 19 etc.

            //To Do :
            // * Set/Games Counter
            // Function for score incrementing to help respect DRY coding
            #include &lt;LiquidCrystal.h&gt;
            LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
            //Setting up Switches, 1 for each player to press.
            const int player1switch = 7;
            const int player2switch = 6;
            //Setting up LEDs, 1 representing each player.
            const int led1 = 9;
            const int led2 = 10;
            //Players names
            String player1 = ""Hraday"";
            String player2 = ""Alex"";
            int switchStatePlayer1 = 0;
            int switchStatePlayer2 = 0;
            int targetChosen = 1;
            int decideTarget = 1;
            int p1score = 0;
            int p2score = 0;
            int winner;
            // Initial Target score to get to
            int target = 11;

            void setup() {
                Serial.begin(9600);
                lcd.begin(16,2);
                pinMode(player1switch,INPUT);
                pinMode(player2switch,INPUT);
                pinMode(led1,OUTPUT);
                pinMode(led2,OUTPUT);
                lcd.print(player1);
                lcd.print("" Vs "");
                lcd.print(player2);
                lcd.setCursor(0,1);
                lcd.print(""SquashScorer 0.1"");
            }

            void loop() {



                // If LED is still on, turn it off.
                if((digitalRead(led1) == HIGH) || (digitalRead(led2) == HIGH)){
                    delay(200);
                digitalWrite(led1, LOW);
                digitalWrite(led2, LOW);
                }




                // If players scores are the same, and it's at the target score to change
                if (targetChosen == 0){
                    lcd.clear();
                    lcd.setCursor(0,0);
                    // Give the players the info about which score they can choose
                    lcd.print(target + 2);
                    lcd.print(""    OR    "");
                    lcd.print(target + 4);
                    targetChosen = 1;
                    decideTarget = 0;
                }
                // While new target score hasn't been decided, keep checking.
                while(decideTarget == 0) {
                        newTarget();
                }
                if((targetChosen == 1) &amp;&amp; (decideTarget == 1)) {
                    switchStatePlayer1 = digitalRead(player1switch);
                    if(switchStatePlayer1 == HIGH){
                        digitalWrite(led1, HIGH);
                        p1score = p1score++;
                        if ((p1score == target - 1) &amp;&amp; (p2score == target - 1)) { targetChosen = 0; }
                        //Deciding if this was winning point
                        if ((p1score == target) || (p2score == target) &amp;&amp; (p1score != p2score)) {
                            winner = whoWins(player1);
                        }
                        Serial.println(""New Score__________"");
                        Serial.println(p1score);
                        newScore();
                    }
                    switchStatePlayer2 = digitalRead(player2switch);
                    if(switchStatePlayer2 == HIGH){
                        digitalWrite(led2, HIGH);
                        p2score = p2score++;
                        if ((p1score == target - 1) &amp;&amp; (p2score == target - 1)) { targetChosen = 0; }
                        //Deciding if this was winning point
                        if ((p1score == target) || (p2score == target) &amp;&amp; (p1score != p2score)) {
                            winner = whoWins(player2);
                        }
                        Serial.println(""New Score__________"");
                        Serial.println(p2score);
                        newScore();
                    }
                }
            }
            int newTarget(){
                Serial.println(decideTarget);
                Serial.println(""Waiting for input..."");
                if(digitalRead(player1switch) == HIGH){
                    target = target + 2;
                    newScore();
                    decideTarget = 1;
                    delay(250);
                }
                if(digitalRead(player2switch) == HIGH){
                    target = target + 4;
                    newScore();
                    decideTarget = 1;
                    delay(250);
                }
            }
            void newScore(){
                lcd.clear();
                lcd.setCursor(0,0);
                lcd.print(player1);
                lcd.print(""      "");
                lcd.print(player2);
                lcd.setCursor(0,1);
                lcd.print(p1score);
                lcd.print("" Target:"");
                lcd.print(target);
                lcd.print(""  "");
                lcd.print(p2score);
                Serial.println(""NewScore() Called"");
            }
            void ledflash(){
                for (int i=0;i&lt;4;i++){
                    digitalWrite(led1, LOW);
                    digitalWrite(led2, HIGH);
                    delay(500);
                    digitalWrite(led1, HIGH);
                    digitalWrite(led2, LOW);
                    delay(500);
                }
                digitalWrite(led1, LOW);
                digitalWrite(led2, LOW);
            }
            int whoWins(String player){
                lcd.clear();
                lcd.setCursor(0,0);
                lcd.print(player);
                lcd.setCursor(0,1);
                lcd.print(""is the Winner!"");
                ledflash();
                delay(3000);
                p1score = 0;
                p2score = 0;
                target = 10;
            }
</code></pre>
",,27785137,6371
22627834,2,22604936,2014-03-25T07:19:59.500,1,,1927972,,2014-03-25T07:19:59.500,,4,,"<p>Presuming you are certain the outBuf is not overflowed (it is smaller than maximum possible request string size and you are using strcat (source of all evil))</p>

<p>The server may timeout in the long time between when the connection is opened, and when you actually send any bytes.  Preconstruct the outBuf so that it is ready to go when the connection opens.</p>

<pre><code>strncat(outBuf,...,127);
... request is fully constructed

if(client.connect(ipBuf,thisPort)) {
  client.write(outBuf);
  client.println("" HTTP/1.1"");
  client.println(""Host: 192.168.1.3"");
...
</code></pre>

<p>To the server, the connection that is SYN'd but not used is a resource to be recovered.  The Arduino will be so slow, it will look like an idle connection.  Also a SYN flood is an old denial of service vector that most servers will protect against.</p>

<p>A difference in the timeout values would explain why the Linux and Win based server act different.  You could confirm this by running Wireshark on the traffic.  If the server is timing out on the Arduino, you will see this sequence:</p>

<ul>
<li>the SYN handshake proceed between server and Arduino</li>
<li>a little time passes</li>
<li>a RST from the server indicating the connection is dead</li>
<li>the Arduino sends the request string to the now dead connection</li>
<li>the Arduino program hangs at the client.write() because the connection state is out of 
sync</li>
<li>the client will probably be retrying - you should see some retransmissions</li>
</ul>
",,27883451,1135
22681306,2,22614945,2014-03-27T07:52:56.543,0,,1717300,,2014-03-27T07:52:56.543,,0,,"<p>Looks like the serial port <code>QIODevice</code> does not implement <code>bytesAvailable</code>, if it returns 0. This may also be why <code>readAll()</code> fails, depending on how it is implemented. But at least <code>readAll()</code> has the problem of not being able to report error.</p>

<p>Try using <code>read</code> method instead for better diagnostics, like this (untested):</p>

<pre><code>void DataGathering::newData()
{
    QByteArray rMsg;
    for(;;) {
        char buf[256]; // read data in this size chunks
        qint64 len = m_serial-&gt;read(buf, sizeof buf);
        if (len &lt;= 0) {
            if (len &lt; 0) {
                qDebug() &lt;&lt; ""newData() read error"" &lt;&lt; m_serial-&gt;errorString();
            }
            break; // for(;;)
        }
        rMsg.append(buf, len);
    }
    qDebug() &lt;&lt; ""newData() got byte array"" &lt;&lt; rMsg.size() &lt;&lt; "":"" &lt;&lt; rMsg;
}
</code></pre>

<p>It may not solve your problem, but with luck it will give you error message.</p>
",,27888152,18792
22692558,2,22669565,2014-03-27T15:43:50.787,0,,1668605,,2014-03-27T17:09:11.407,2014-03-27T17:09:11.407,0,,"<pre><code>for (int i=0;i&lt;strlen(tag); i++){
    if ( (tag[i] &gt;= 'a' &amp;&amp; tag[i] &lt;= 'z') || (tag[i] &gt;= 'A' &amp;&amp; tag[i] &lt;= 'Z') || (tag[i] &gt;= '0' &amp;&amp; tag[i] &lt;= '9'){
        //this char is OK
    }else{
        return;
    }
}
//if you are here tag is valid
</code></pre>

<p>edit: changed the comments to be sure you don't put code in the if</p>
",,27900997,1067
22686042,2,22684638,2014-03-27T11:20:13.183,0,,3242049,,2014-03-27T11:20:13.183,,0,,"<p>Simply add the extern declaration to your main program</p>

<pre><code>#include""glob.h""

int c = 20;
extern int a;

void loop()
{
  if(c&gt;a)
  {
    Serial.printf(""welcome"");
  }
}
</code></pre>
",,27909666,14854
22700772,2,22700411,2014-03-27T22:42:29.290,0,,1769777,,2014-03-28T15:03:58.163,2014-03-28T15:03:58.163,3,,"<p>I don't know arduino, but my guess is that <code>client.read();</code> reads a character from the response. Right now you're reading into the variable <code>c</code> and just overwriting the variable until you read the entire response. Try making a string buffer, and reading the characters into the string. Once that is done try printing out your buffer.</p>

<p>Without any testing the code would be along the lines of:</p>

<pre><code>string buffer;
int counter = 0;
while (client.connected()) {
  while (client.available()) {
   buffer[counter++] = client.read();
  }
}
Serial.println(""Closing connection"");
Serial.println(""Buffer value is: "" + buffer);
client.close();
</code></pre>

<p>That would replace:</p>

<pre><code>char c = client.read();
while (client.connected()) {
  while (client.available()) {
   char c = client.read();
  }
}
Serial.println(""Closing connection"");
client.close();
</code></pre>

<p>You would also have to put an <code>echo $stuff</code> in your PHP file in order to respond to the incoming request.</p>

<p><strong>Edit</strong></p>

<p>You also have a couple more issues. The mysql library has been deprecated, I would recommend looking into the mysqli php library. You are also vulnerable to a SQL injection by <code>$_GET[""value""]</code> directly into your SQL query string. Look into using the function mysqli_real_escape_string() function in order to protect yourself.</p>

<p>You are also not assigning <code>$stuff</code> to a string. Be sure to put <code>ok</code> in quotes.</p>
",,27917832,13971
22703295,2,22702503,2014-03-28T02:49:41.253,1,,3255903,,2014-03-28T03:02:25.863,2014-03-28T03:02:25.863,4,,"<p>For the direction detection, you might look at something like this:</p>

<pre><code>enum Directions {
    Center,
    Left,
    Right,
    Up,
    Down
}

const int threshold = 100;

int getJoyStick() 
{
    // get the X,Y coordinates with 0,0 the centre
    int x = analogRead(xAxis) - 500;
    int y = analogRead(yAxis) - 500;

    /check if we are in the middle.  Both X and Y need to be small for this to happen
    if (abs(x) &lt; threshold &amp;&amp; abs(y) &lt; threshold) return Center;

    //to detect up, down, left, right draw diagonals at 45 degrees from the centre
    //if we are more to the right than we are up or down, then it is Right.  This
    //is to cope if it isn't exactly horizonal or vertical
    //so y big might mean up, but if x is bigger, than it is actually to the right
    if (x&gt;y) {
      if (x&gt;-y) return Right; else return Down;
    }
    else {
      if (x&gt;-y) return Up; else return Left;
    }
}
</code></pre>

<p>The enum is just to show the nice way of doing it.  You would just the same codes through all the code. But instead if it's simpler for you, you could just return numeric codes for each of the directions.</p>
",,27919876,1455
22710429,2,22708300,2014-03-28T10:37:44.873,8,,2500951,,2014-03-28T10:37:44.873,,1,,"<p><strong>General type casting</strong><br>
In C++, there are various types of casts which can be used to convert between types. They are important because C++ is a strongly typed language, and the compiler doesn't necessarily know that any given conversion between types is safe or sensible. By default, it will issue an error or a warning unless you explicitly tell it what to do.</p>

<p>All of the C++ casts have the following format:</p>

<pre><code>x_cast &lt;new_type&gt; (expression)
</code></pre>

<p><code>x_cast</code> can be one of the following: <code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code>, or <code>const_cast</code>.</p>

<p>A reinterpret cast is used when you want to force the compiler to convert between unrelated pointer types. The result is a pointer to exactly the same piece of data in memory. However, it will be handled (or interpreted) as though it's a different type, which can allow some interesting operations.</p>

<p>For example, let's say you have a pointer to a 4 byte unsigned integer, and you want to access each byte individually. You could do that by reinterpreting the pointer to a 1 byte type, like this:</p>

<pre><code>uint32_t num = 12345;
uint32_t *p1 = &amp;num;

uint8_t *p2 = reinterpret_cast&lt;uint8_t*&gt;(p1);

// Access the individual bytes:
uint8_t byte0 = p2[0];
uint8_t byte1 = p2[1];
uint8_t byte2 = p2[2];
uint8_t byte3 = p2[3];
</code></pre>

<p>Pointers <code>p1</code> and <code>p2</code> both point to the data stored in the <code>num</code> variable. The difference is that accessing it via <code>p2</code> will result in the compiler treating it like a 1 byte unsigned integer (instead of the original 4 byte type). This lets you extract/manipulate individual bytes at different locations within the original variable.</p>

<p>For a simple example like this, <code>reinterpret_cast</code> is quite safe. However, there are many situations where it can go very badly wrong, or simply do nothing useful, if it's not used carefully. An example would be trying to reinterpret a <code>float</code> pointer as an <code>int</code>. On its own, it won't do anything bad. The result will be completely useless though, because the underlying binary representation of a <code>float</code> doesn't make sense if you try to handle it like an <code>int</code>.</p>

<p>The same approach can work for objects, letting you interpret an instance of one class as though it's an instance of a different one. However, it doesn't do any intelligent conversion. It simply forces the raw binary data to be treated in a different way, which means you have to be very confident that the reinterpretation makes sense.</p>

<p><strong>Arduino</strong><br>
The line you identified in the Arduino file is fairly complicated when it's fully expanded, so we'll break it down a bit. As I think you've identified, it's defining a macro called <code>F()</code>, and that macro takes a parameter called <code>string_literal</code>.</p>

<p>As the name suggests, it's intended to be used with a string literal, <code>F(""like this"")</code>. Under the surface, the compiler treats a string literal as a pointer to an array of characters; or in other words, <code>char *</code>.</p>

<p>Inside the <code>F()</code> macro, the string literal is put into another macro, called <code>PSTR()</code>. That basically adds a whole bunch of other stuff which tells the compiler to store the string data in program space (where the sketch lives on your Arduino) rather than SRAM (where the variables live).</p>

<p>At this point, the <code>reinterpret_cast</code> comes into play. All the stuff in <code>PSTR()</code> is important, but it doesn't really affect the data type being seen by the cast. You can basically imagine it acting something like this:</p>

<pre><code>char *ptr = ""my string data"";
reinterpret_cast&lt;const __FlashStringHelper *&gt;(ptr);
</code></pre>

<p><code>__FlashStringHelper</code> is a class, which means its type is unrelated to <code>char *</code>. That's why we need to reinterpret it, so the compiler knows that we're taking responsibility for the safety of the operation. When the result of the cast is used, it will act like a pointer to a <code>__FlashStringHelper</code> object, meaning its methods can be used to access/process the string data.</p>

<p>In reality, no instance of <code>__FlashStringHelper</code> is actually created. The underlying data is still just our string literal. This is one of the interesting aspects of C++ -- you can actually call methods of an object which doesn't exist, as long as the object doesn't try to access non-existent member data.</p>
",,27998059,2179
26515254,2,22749477,2014-10-22T19:11:36.947,1,,296460,,2014-10-22T19:11:36.947,,0,,"<p>The quick answer is that they are not available and you need to write your own wrapper classes to get this sort of functionality.</p>

<p>If you want to use c++ for the embedded platform you won't have access to all of the standard library. Importantly though, you don't <em>want</em> all of the standard library as it's too heavyweight for some embedded projects. Some language features (like exception handling) might not be possible on the platform you are choosing or might be too expensive given the resources available to you. The lack of some language features makes it impossible to implement certain standard containers, for example the containers that can throw exceptions might not be able to be implemented in a standards-conforming way on some platforms. Additionally there's some c++ constructs that might be available but would be a bad idea to use on the embedded platform. Dynamic allocation of memory via <code>new</code> and <code>delete</code> will very likely run you into a significant number of problems as you don't have a lot of memory and issues such as memory fragmentation are very difficult to deal with. (you would probably want to look into placement new along with some other memory allocation scheme to avoid some of these issues if you <em>needed</em> dynamic memory for some reason)</p>

<p>If you want to have the benefits of containers like <code>std::array</code> and <code>std::string</code> you will need to write your own memory management classes. One of the main benefits of using the <code>std</code> containers is the way in which they greatly simplify your memory management (compared with using raw C-style-arrays). If you are doing a large embedded c++ project you can write your own wrappers for the memory management using RAII and other basic c++ language constructs. For the most part you need to avoid dynamic memory allocation and exception handling when making these classes.</p>

<p>One of the things I find has a good ROI is making some structs/classes that wrap an array along with the length of the array. By keeping the sizes connected you can keep your code a lot clearer. Frequently I find myself writing something like this:</p>

<pre><code>template&lt;typename T, uint8_t MAX_SIZE&gt;
class array_helper{
    public:
        typedef T value_type;
        array_wrapper():
            m_data()
        {}

        T&amp; operator[](unsigned int idx){
            return m_data[idx];
        }

        T* data(){
            return this-&gt;m_data;
        }

        const uint8_t s_max_size = MAX_SIZE;
    private:
        T m_data[MAX_SIZE];
};
</code></pre>

<p>You would want to expand on this to do what you need, but hopefully this gives you an idea.</p>
",,28005028,838
22761225,2,22749604,2014-03-31T12:11:55.360,0,,1668605,,2014-03-31T23:19:51.013,2014-03-31T23:19:51.013,10,,"<p>you need to parse the HTTP request.
Because limited RAM, keeping all request in memory is not a good idea, but look at the request: you have a list of header separated by <code>\n\r</code>, then an empty line (<code>\n\r</code>), then what you need.</p>

<p>So you have to look for <code>\n\r\n\r</code> and then save result. Something similat to:</p>

<pre><code>char what[] = ""\r\n\r\n"";
String ris = """";
int eq = 0;
while (client.connected()) {
    while (client.available()) { //we assume all data to be in a single TCP packet.
        buffer = client.read();
        if (eq == 4){
            ris += buffer;
        }else{
            if (buffer == what[eq]){
                eq++;
            }else{
                eq = 0;
            }
        }
    }
    Serial.print(""readed: "");
    Serial.println(ris);
    //here send answer
    client.close();
}
</code></pre>
",,28012183,95
22794358,2,22794223,2014-04-01T18:48:47.737,0,,2660282,,2014-04-01T18:48:47.737,,0,,"<p>this should work</p>

<pre><code>uint8_t valu = bcm2835_gpio_lev(SIG);
uint8_t val = 1;
while(valu == 0)
    {
    valu = bcm2835_gpio_lev(SIG);
    data[i] = 0;
    dan = dan + 1;
    delay(0.001);
    }
</code></pre>

<p>...</p>

<pre><code>while(val == 1 &amp;&amp; timeout &lt; 70)
    {
    val = bcm2835_gpio_lev(SIG);
    data[i] = data[i] + 1;
    dat = dat + 1;
    timeout = timeout + 1;
    delay(0.001);
    }
</code></pre>
",,28020971,2420
22866147,2,22859412,2014-04-04T14:54:52.717,0,,2500951,,2014-04-04T14:54:52.717,,1,,"<p><strong>Code issues</strong><br>
There are a number of problems in your code which would prevent it from compiling or working as you intend.</p>

<p>Firstly, as mentioned in the comments, you shouldn't have the word <code>type</code> in front of function signatures. For example, instead of <code>type void loop()</code> it should just be <code>void loop()</code>. That's what's causing the error message you mentioned. The compiler simply doesn't understand it.</p>

<p>The second major problem is your <code>for</code> loops. The correct syntax in C++ is this:</p>

<pre><code>for ( init; condition; iter)
{
}
</code></pre>

<p>The <code>init</code> section is run once before the loop starts, and it's usually used to declare/initialise a counter variable. The <code>condition</code> is checked immediately before each iteration of the loop, and stops as soon as it equates to <code>false</code>. It's typically used to check the counter value. Finally, the <code>iter</code> section is executed at the end of each loop iteration, and is usually used to increment/advance the counter.</p>

<p>It's (usually) important not to have a semi-colon immediately after the <code>for</code> loop, otherwise your loop body is empty (i.e. it won't loop through anything). Either put a single statement after it, or multiple statements surrounded by curly braces <code>{ ... }</code>.</p>

<p>In your case, it looks like you want your <code>for</code> loop to go through values 3, 4, 5 and 6. To do that, you need to do something like this:</p>

<pre><code>for (int pinNumber = 3; pinNumber &lt; 7; ++pinNumber)
{
    // (loop body goes here)
}
</code></pre>

<p>That declares a loop counter called <code>pinNumber</code>, and starts it with the value 3. After each iteration of the loop, the counter goes up by one (<code>++pinNumber</code>). The loop stops when the counter reaches 7.</p>

<p><strong>Corrected code</strong><br>
Putting all of that together, I think this code should work better:</p>

<pre><code>const int sensorPin = A0;   
void setup()
{
    pinMode(2, INPUT);//the switch

    for (int pinNumber = 3; pinNumber &lt; 7; ++pinNumber)
    {
        pinMode(pinNumber, OUTPUT);//four leds
    }

    pinMode(7, OUTPUT);//green led
    pinMode(8, OUTPUT);//red led
}

void loop()
{
    for (int pinNumber = 3; pinNumber &lt; 7; ++pinNumber)
    {        
        if (digitalRead(2) == LOW)
        {
            //if the switch is off the 4 leds are off
            digitalWrite(pinNumber, LOW);
        }
        else
        {
            //if the switch is open the 4 leds are opened
            digitalWrite(pinNumber, HIGH);
        }
    }

    int sensorVal = analogRead(sensorPin);
    float voltage = (sensorVal / 1024.0);
    float temperature = (voltage - 0.5) * 100;
    if (temperature &lt; 40)
    {
        digitalWrite(7, HIGH);
        digitalWrite(8, LOW);
    }
    else
    {
        digitalWrite(7, LOW);
        digitalWrite(8, HIGH);
    } 
}
</code></pre>
",,28044274,6185
22893470,2,22889013,2014-04-06T11:35:08.537,0,,1290438,,2014-04-06T11:35:08.537,,0,,"<p>well, even JSON is ""hard"" to parse for an arduino. So you should consider simplyfying as much as possible the response, by using <code>1</code>/<code>0</code> integers instead of <code>""on""</code> for example.</p>

<p>What you need to run, is basically a state graph:</p>

<pre><code>if ('{' == client.read())
  if ('""' == client.read())
    if ('l' == client.read())
      if ('i' == client.read())
        if ('g' == client.read())
          if ('h' == client.read())
            if ('t' == client.read())
              if ('s' == client.read())
                if ('t' == client.read())
                  if ('a' == client.read())
                    if ('t' == client.read())
                      if ('u' == client.read())
                        if ('s' == client.read())
                          if ('""' == client.read())
                            if (':' == client.read()) {
                               char c = client.read();
                               if (c == '1')
                                 // TURN LIGHT ON
                               else if (c == '0')
                                 // TURN LIGHT OFF
                            }
</code></pre>

<p>which can be improved by using a string, and keeping the state in an index variable:</p>

<pre><code>const char* VAL=""{\""lightstatus\"":""

int parse_value(char c) {
    static int val_idx=0;
    // end of parsing condition, the index reached string length
    if (strlen(VAL) == val_idx) {
        // if the value is '1', return &gt;0, if the value is '0', return 0
        if ('1' == c) return 1;
        else if ('0' == c) return 0;
    }
    // otherwise let's check if we're still in string
    if (c == VAL[val_idx]) {
        // if we do, increment the index variable
        ++val_idx;
    } else {
        // or reset it
        val_idx = 0;
    }
    // return -1 while we're still parsing the string
    return -1;
}
</code></pre>

<p>to use that code:</p>

<pre><code>char val=-1;
while (val &lt; 0)
    val = parse_value(Serial.read())
</code></pre>

<p>I did not test it, but I hope you get the algorithmic idea!</p>

<p>HTH</p>
",,28055159,92
22960006,2,22958354,2014-04-09T10:37:54.670,0,,500974,,2014-04-09T12:33:06.030,2014-04-09T12:33:06.030,9,,"<p>I think your approach is a little off here. </p>

<p>I would suggest that you use a bit field to determine which input is being pressed with a different bit for each input (as each one is effectively independent).</p>

<pre><code>Private _input As Integer = 0

Private Sub Form1_KeyDown(sender As Object, e As KeyEventArgs) Handles Me.KeyDown
    'set the bit of the required input
    Select Case e.KeyCode
        Case Keys.Right
            _input = SetBit(_input, 0) '0001
        Case Keys.Left
            _input = SetBit(_input, 1) '0010
        Case Keys.Up
            _input = SetBit(_input, 2) '0100
        Case Keys.Down
            _input = SetBit(_input, 3) '1000
    End Select
    SerialPort1.Write(Convert.ToChar(_input))
End Sub

Private Sub Form1_KeyUp(sender As Object, e As KeyEventArgs) Handles Me.KeyUp
    'clear the bit of the de-selected input
    Select Case e.KeyCode
        Case Keys.Right
            _input = ClearBit(_input, 0)
        Case Keys.Left
            _input = ClearBit(_input, 1)
        Case Keys.Up
            _input = ClearBit(_input, 2)
        Case Keys.Down
            _input = ClearBit(_input, 3)
    End Select
    SerialPort1.Write(Convert.ToChar(_input))
End Sub

Private Function SetBit(value As Integer, bit As Integer) As Integer
    ' Create a bitmask with the 2 to the nth power bit set:
    Dim mask As Integer = CInt(2 ^ bit)
    ' Set the nth Bit:
    value = value Or mask
    Return value
End Function

Private Function ClearBit(value As Integer, bit As Integer) As Integer
    ' Create a bitmask with the 2 to the nth power bit set:
    Dim mask As Integer = CInt(2 ^ bit)
    ' Clear the nth Bit:
    value = value And Not mask
    Return value
End Function
</code></pre>

<p>You then need to do the opposite in the C++ code (which should be much more elegant) and check for invalid key combinations (e.g. forward and backward together)</p>

<p>Ideally you would want to pass a Byte to the serial port no a character, but I have tried to keep it as similar as possible</p>
",,28056597,3409
22960571,2,22958354,2014-04-09T11:03:50.103,0,,66532,,2014-04-09T11:10:00.817,2014-04-09T11:10:00.817,6,,"<p>I can't help with the C code but the VB code could use a single byte for the control</p>

<pre><code>&lt;FlagsAttribute()&gt; _
Enum ctrl As Byte
    stp = 0 'stop is no bits set
    frwd = 1 &lt;&lt; 0 '1
    back = 1 &lt;&lt; 1 '2
    left = 1 &lt;&lt; 2 '4
    rght = 1 &lt;&lt; 3 '8
    mask = 255
End Enum

Private _control(0) As ctrl

Private Sub Form1_KeyDown(sender As Object, e As KeyEventArgs) Handles Me.KeyDown
    Select Case e.KeyCode
        Case Keys.Right
            _control(0) = _control(0) Or ctrl.rght
        Case Keys.Left
            _control(0) = _control(0) Or ctrl.left
        Case Keys.Up
            _control(0) = _control(0) Or ctrl.frwd
        Case Keys.Down
            _control(0) = _control(0) Or ctrl.back
    End Select
    'SerialPort1.Write(_control, 0, 1)
    Debug.WriteLine(_control(0))
End Sub

Private Sub Form1_KeyUp(sender As Object, e As KeyEventArgs) Handles Me.KeyUp
    Select Case e.KeyCode
        Case Keys.Right
            _control(0) = _control(0) And (ctrl.mask Xor ctrl.rght)
        Case Keys.Left
            _control(0) = _control(0) And (ctrl.mask Xor ctrl.left)
        Case Keys.Up
            _control(0) = _control(0) And (ctrl.mask Xor ctrl.frwd)
        Case Keys.Down
            _control(0) = _control(0) And (ctrl.mask Xor ctrl.back)
    End Select
    'SerialPort1.Write(_control, 0, 1)
    Debug.WriteLine(_control(0))
End Sub
</code></pre>
",,28058806,149
29582676,2,22995125,2015-04-11T20:24:31.097,1,,3265802,,2016-02-19T13:45:08.897,2016-02-19T13:45:08.897,0,,"<p><code>Serial.find();</code> reads Serial buffer and removes every single byte from it,  up to the point where it can find specified by you <code>String</code> or <code>Character</code>.</p>

<p>If you use it in an conditional statement like in your example, it will always find ""<strong>SOMETHING</strong>"" even if ""<strong>SOMETHING ELSE</strong>"" exist because everything up to the point of ""<strong>SOMETHING</strong>"" is removed from buffer ( <em>if ""<strong>SOMETHING</strong>"" actually arrived before ""<strong>SOMETHING ELSE</strong>""</em> ). </p>

<p>If we assume that your data arrives in order <strong>SOMETHING</strong> and then <strong>SOMETHING ELSE</strong>, your Serial buffer will look like this: <strong>SOMETHING ELSESOMETHING</strong></p>

<p>in which case:</p>

<ol>
<li>It will find ""<strong>SOMETHING</strong>"" and stop in there as first condition to meet is to search for this word exactly.</li>
<li>I assumed that you don't actually mean to send ""<strong>SOMETHING</strong>"" so lets say that first <code>String</code> to look for is <strong>StringA</strong> and then <strong>StringB</strong>. Your buffer then will look like this: <strong>StringBStringA</strong> however based on your conditional statement it will still only find <strong>StringA</strong>. This will happen because <strong>StringA</strong> still exist in buffer and now when first condition is checked you basically ask to search for <strong>StringA</strong> and by doing this you are removing <strong>StringB</strong> using <code>Serial.find(StringA)</code> - it simply skips <strong>StringB</strong> because its not aware that you are going to ask about it in your <code>else if</code> later on.</li>
<li>Solution to your problem depends on data that you expect to receive. You can tag beginning of data that you are awaiting for with some specific character or sequence of characters:</li>
</ol>

<p>For example lets assume that you await for <code>String</code> type of data. Before you send it to your <strong>Serial</strong> put each message in a specific format like <code>$START$SOMETHING$</code></p>

<p>You can then use this to find first command that starts with your tag and load content of the message to <code>String</code> so you can compare it with expected results using conditional statement. </p>

<p><strong>Note!!!</strong> Code below will stop on first message with <code>$START$</code> tag so if you want to look into your Serial buffer for other messages you don't want to <code>break</code> <code>while(Serial.available &gt; 0)</code> and use arrays to store each result. </p>

<pre class=""lang-cpp prettyprint-override""><code>char myCharacter;
String myIncomingData;

if(Serial.find(""$START$""))
{
  while (Serial.available() &gt; 0) {

    // Reads byte of Serial at the time
    myCharacter = Serial.read();

    // Stops at the end of data
    if (myCharacter == ""$"") {
      break;
    }

    // Adds each character to String with your data
    myIncomingData += myCharacter; 
  }

  if (myIncomingData == ""SOMETHING"") {
    // Do whatever you like to with your data
  } else if (myIncomingData == ""SOMETHING ELSE"") {
    // Do whatever you like to with your data
  }
</code></pre>

<p>I would use this solution only if you want to use <code>Serial.find()</code>, Im sure that you can get your results in many different ways as well, at the end you can always go through entire 64 bytes of you buffer byte by byte using your own code :D. </p>
",,28088361,281
23035503,2,23035250,2014-04-12T20:04:42.397,0,,3286797,,2014-04-12T20:16:25.867,2014-04-12T20:16:25.867,0,,"<p>You have to pass vector size to your function (you can not read vector size from a pointer MSG, in fact in your case <code>sizeof(MSG) is equal to sizeof(uint8_t*)</code> and it depends by your platform ), so you could change the function as follow:</p>

<pre><code>int Serialbaud=19200;
int byteCount;
uint8_t message[] = {0x06, 0x01, 0x08, 0x01, 0xF0, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01};

// Test the transmission of our message (uint8_t array)
void testFunc(uint8_t *MSG, int len) {

  //uint32_t len= sizeof(MSG)/sizeof(uint8_t);

  Serial.println();
  Serial.println(""After passing to function the message is "" + String(len) + "" bytes:"");
  for(int i=0; i&lt;len; i++) {
    Serial.print(MSG[i]);
    Serial.print("", "");
  }
  Serial.println();

}//end function

//--------SETUP------------------
void setup()
{
 delay(3000);//Give yourself time to open up the serial monitor 
 Serial.begin(Serialbaud);  //Begin serial ommunication with Serial Monitor

 //Report the original length and content of the message to the serial monitor
 uint32_t len= sizeof(message)/sizeof(uint8_t); 
 Serial.println(""Original message before passing to function is "" + String(len) + "" bytes:"");
 for(int i=0; i&lt;len; i++) {
    Serial.print(message[i]);
    Serial.print("", "");
  }
  Serial.println();

 //Pass the message to the test function
 testFunc(message, sizeof(message)/sizeof(uint8_t));

}

//--------MAIN LOOP-------MAIN LOOP-------MAIN LOOP-------MAIN LOOP-------MAIN LOOP-------MAIN LOOP--
void loop()
{

}//END LOOP-------------------
</code></pre>
",,28128824,935
23083450,2,23083131,2014-04-15T12:15:15.197,2,,335858,,2014-04-15T12:15:15.197,,1,,"<p>In C++ constant expressions are computed at compile time. It looks like the compiler for arduino has performed the computation incorrectly, though - it treated <code>0xFF</code> as a negative, and did sign-extension on it; that is why the top byte is set to <code>0xFF</code>.</p>

<p>You can force the constants to be of the right type by using <a href=""http://en.cppreference.com/w/cpp/language/integer_literal"" rel=""nofollow"">type-specific suffixes</a>, like this:</p>

<pre><code>unsigned long red = 0xffUL * 0x10000UL;
unsigned long green = 0xffUL * 0x100UL;
unsigned long blue = 0xffUL;
unsigned long color = red + green + blue;
</code></pre>

<p><code>UL</code> suffix stands for <code>unsigned long</code>.</p>

<p>Rather than multiplying numbers by powers of two and adding up the results, you could use shifts and bitwise OR, like this:</p>

<pre><code>unsigned long red = 0xffUL;
unsigned long green = 0xffUL;
unsigned long blue = 0xffUL;
unsigned long color = (red &lt;&lt; 16)
                    | (green &lt;&lt; 8)
                    | (blue &lt;&lt; 0);
</code></pre>

<p>Zero shift above is completely unnecessary - the compiler will optimize it out. I added it for a more consistent look.</p>
",,28174176,260
23095178,2,23094401,2014-04-15T21:49:43.190,2,,2410359,,2014-04-15T22:15:06.850,2014-04-15T22:15:06.850,3,,"<p>Use <code>qsort()</code>.</p>

<pre><code> #include&lt;stdlib.h&gt;

 typedef struct {
   int Player;
   int Score;
 } PS_T;

 int compar(const void *va, const void *vb) {
   PS_T *ia = (PS_T *) va;
   PS_T *ib = (PS_T *) vb;
   return (ia-&gt;Score &gt;= ib-&gt;Score) - (ib-&gt;Score &gt;= ia-&gt;Score);
 }

 // Return true if Silver beat Bronze (detect ties after 2nd place.)
 int Sort4(int *Gold, int *Silver, 
     int Score1, int Score2, int Score3, int Score4) {
   PS_T PS[4] = { { 1, Score1 }, { 2, Score2 }, { 3, Score3} , {4, Score4} };
   qsort(PS, 4, sizeof PS[0], compar);
   *Gold = PS[0].Player;
   *Silver = PS[1].Player;
   return PS[1].Score &gt; PS[2].Score;
 }

 ...
 int First;
 int Second;
 Sort4(&amp;First, &amp;Second, buttonPushCounter, buttonPushCounter2, 
   buttonPushCounter3, buttonPushCounter4);
</code></pre>
",,28182339,1922
23096464,2,23096366,2014-04-15T23:41:42.307,12,,227267,,2014-04-15T23:41:42.307,,4,,"<p>Arduino specifically provides absolutely no way to exit their <code>loop</code> function, as exhibited by the code that actually runs it:</p>

<pre><code>setup();

for (;;) {
    loop();
    if (serialEventRun) serialEventRun();
}
</code></pre>

<p>Besides, on a microcontroller there isn't anything to exit to in the first place.</p>

<p>The closest you can do is to just halt the processor. That will stop processing until it's reset.</p>
",,28197733,58
23097107,2,23096366,2014-04-16T00:55:01.300,9,,2226079,,2014-04-16T01:01:13.803,2017-05-23T11:55:10.343,1,,"<p><a href=""https://stackoverflow.com/users/227267/matti-virkkunen"">Matti Virkkunen</a> said it right, there's no ""decent"" way of stopping the loop. Nonetheless, by looking at your code and making several assumptions, I imagine you're trying to output a signal with a given frequency, but you want to be able to stop it.</p>

<p>If that's the case, there are several solutions:</p>

<ol>
<li><p>If you want to generate the signal with the input of a button you could do the following</p>

<pre><code>int speakerOut = A0;
int buttonPin = 13;

void setup() {
    pinMode(speakerOut, OUTPUT);
    pinMode(buttonPin, INPUT_PULLUP);
}

int a = 0;

void loop() {
    if(digitalRead(buttonPin) == LOW) {
        a ++;
        Serial.println(a);
        analogWrite(speakerOut, NULL);

        if(a &gt; 50 &amp;&amp; a &lt; 300) {
            analogWrite(speakerOut, 200);
        }

        if(a &lt;= 49) {
            analogWrite(speakerOut, NULL);
        }

        if(a &gt;= 300 &amp;&amp; a &lt;= 2499) {
            analogWrite(speakerOut, NULL);
        }
    }
}
</code></pre>

<p>In this case we're using a button pin as an <code>INPUT_PULLUP</code>. You can read the <a href=""http://arduino.cc/en/Reference/Constants"" rel=""nofollow noreferrer"">Arduino reference</a> for more information about this topic, but in a nutshell this configuration sets an internal pullup resistor, this way you can just have your button connected to ground, with no need of external resistors.
<strong>Note</strong>: This will invert the levels of the button, <code>LOW</code> will be pressed and <code>HIGH</code> will be released.</p></li>
<li><p>The other option would be using one of the built-ins hardware timers to get a function called periodically with interruptions. I won't go in depth be <a href=""http://playground.arduino.cc/Code/Timer1"" rel=""nofollow noreferrer"">here</a>'s a great description of what it is and how to use it.</p></li>
</ol>
",,28211986,250
24359267,2,23096366,2014-06-23T06:00:00.193,4,,3766266,,2014-06-23T22:32:31.907,2014-06-23T22:32:31.907,0,,"<p>The three options that come to mind:</p>

<p>1st)  End <code>void loop()</code> with <code>while(1)</code>... or equally as good... <code>while(true)</code></p>

<pre><code>void loop(){
    //the code you want to run once here, 
    //e.g., If (blah == blah)...etc.

    while(1)        //last line of main loop
}
</code></pre>

<p>This option runs your code once and then kicks the Ard into 
an endless ""invisible"" loop. Perhaps not the nicest way to 
go, but as far as outside appearances, it gets the job done.<br>
The Ard will continue to draw current while it spins itself in
 an endless circle... perhaps one could set up a sort of timer
 function that puts the Ard to sleep after so many seconds, 
minutes, etc., of looping... just a thought... there are certainly 
various sleep libraries out there... see 
e.g., Monk, Programming Arduino: Next Steps, pgs., 85-100 
for further discussion of such.</p>

<p>2nd) Create a ""stop main loop"" function with a conditional control 
structure that makes its initial test fail on a second pass.<br>
This often requires declaring a global variable and having the
 ""stop main loop"" function toggle the value of the variable 
upon termination. E.g.,</p>

<pre><code>boolean stop_it = false;         //global variable

void setup(){
    Serial.begin(9600); 
    //blah...
}

boolean stop_main_loop(){        //fancy stop main loop function

    if(stop_it == false){   //which it will be the first time through

        Serial.println(""This should print once."");

       //then do some more blah....you can locate all the
       // code you want to run once here....eventually end by 
       //toggling the ""stop_it"" variable ... 
    }
    stop_it = true; //...like this
    return stop_it;   //then send this newly updated ""stop_it"" value
                     // outside the function
}

void loop{ 

    stop_it = stop_main_loop();     //and finally catch that updated 
                                    //value and store it in the global stop_it 
                                    //variable, effectively 
                                    //halting the loop  ...
}
</code></pre>

<p>Granted, this might not be especially pretty, but it also works.<br>
It kicks the Ard into another endless ""invisible"" loop, but this 
time it's a case of repeatedly checking the <code>if(stop_it == false)</code> condition in <code>stop_main_loop()</code> 
 which of course fails to pass every time after the first time through.  </p>

<p>3rd) One could once again use a global variable but use a simple <code>if (test == blah){}</code> structure instead of a fancy ""stop main loop"" function.</p>

<pre><code>boolean start = true;                  //global variable

void setup(){

      Serial.begin(9600);
}

void loop(){

      if(start == true){           //which it will be the first time through



           Serial.println(""This should print once."");       

           //the code you want to run once here, 
           //e.g., more If (blah == blah)...etc.

     }

start = false;                //toggle value of global ""start"" variable
                              //Next time around, the if test is sure to fail.
}
</code></pre>

<p>There are certainly other ways to ""stop"" that pesky endless main loop 
but these three as well as those already mentioned should get you started.</p>
",,28219715,430
27832896,2,23096366,2015-01-08T04:23:05.900,41,,1653674,,2015-01-08T04:23:05.900,,6,,"<p>This isn't published on Arduino.cc but you can in fact exit from the loop routine with a simple exit(0);  </p>

<p>This will compile on pretty much any board you have in your board list.  I'm using IDE 1.0.6.  I've tested it with Uno, Mega, Micro Pro and even the Adafruit Trinket</p>

<pre><code>void loop() {
// All of your code here

/* Note you should clean up any of your I/O here as on exit, 
all 'ON'outputs remain HIGH */

// Exit the loop 
exit(0);  //The 0 is required to prevent compile error.
}
</code></pre>

<p>I use this in projects where I wire in a button to the reset pin.  Basically your loop runs until exit(0); and then just persists in the last state.  I've made some robots for my kids, and each time the press a button (reset) the code starts from the start of the loop() function.</p>
",,28249817,322
23167203,2,23167105,2014-04-19T07:21:27.280,1,,1102626,,2014-04-19T07:42:56.183,2014-04-19T07:42:56.183,7,,"<p>The program is probably stuck in an infinite loop:</p>

<pre><code>  while(Serial.available() &gt; 0) //Don't read unless you know there is data
  {
    if(index &lt; 19) //One less than the size of the array
    {
      inChar = Serial.read(); //Read a character
      ...
    }
  }
</code></pre>

<p>Consider the case, when <code>Serial.available() &gt; 0</code>, and <code>index &gt;= 19</code>. The data is not being read, and the <code>while</code> loop goes on.</p>

<p>Try adding <code>else break;</code>:</p>

<pre><code>  int truncated = 0;
  while(Serial.available() &gt; 0) //Don't read unless you know there is data
  {
    if(index &lt; 19) //One less than the size of the array
    {
      inChar = Serial.read(); //Read a character
      inData[index] = inChar; //Store it
      index++; //Increment where to write next
      inData[index] = '\0'; //Null terminate the string
    }
    else
    {
      truncated = 1;
      break;
    }
  }

  if(truncated &amp;&amp; strncmp(inData, input, 19) == 0){
    index = 0;
    inData[index] = '\0';
    return(0);
  }
  else if(!truncated &amp;&amp; strcmp(inData, input) == 0) {
    ...
  }
  else {
    ...
  }
</code></pre>

<p>Or, you could rewrite the Comp function:</p>

<pre><code>int Comp(char* input) {
  //Internal variables
  int i = 0;

  int curr = 0;
  while(Serial.available() &gt; 0) //Don't read unless you know there is data
  {
    if(index &lt; 19) //One less than the size of the array
    {
      inChar = Serial.read(); //Read a character
      if(input[curr] == '\0') return 0; // Input ended, but data is still there.
      if(input[curr++] != inChar) return 0; // Data doesn't match.
    }
    else return 1;  // Data matches.
   }

   return 1;  // Data matches.
}
</code></pre>
",,28285147,1082
23167929,2,23167105,2014-04-19T08:50:08.920,0,,492747,,2014-04-19T08:50:08.920,,0,,"<p>I'm thinking it could have to do with the speed of reading vs the speed of executing your function. Below is a totally untested and uncompiled code that I think (hope) will do what you want.</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

#define MAXLEN 20

char getline(char* unsigned int);

void setup()
{
  //Begin Serial Communication
  Serial.begin(9600);
}

void loop(void){

  //Determine if command mode should be entered
  char cmd[MAXLEN];
  while (!getline(cmd, MAXLEN))
      ; // Wait for a complete input line

  if(strcmp(""BTMODIFY"", cmd) == 0)
  {
     Serial.print(""Entering bluetooth command mode...""); 
  }
}

char getline(char* input, unsigned int size){
  static unsigned int i = 0;
  static char done = 0;

  while(Serial.available() &gt; 0
          &amp;&amp; i &lt; size-1
          &amp;&amp; !done)
  {
    char c = Serial.read(); //Read a character
    input[i++] = c;         //Store it and increment
    if (c == '\n')          //Or whatever newline your serial terminal is sending
    {
        done = 1;
    }
  }
  input[i] = '\0';

  if (done)
  {
    done = 0;
    return 0;
  }

  return 1;
}
</code></pre>
",,28342378,127
23170267,2,23167105,2014-04-19T12:49:07.810,0,,2410359,,2014-04-19T12:56:14.290,2014-04-19T12:56:14.290,0,,"<p><code>Comp()</code> is called many times <em>as</em> data is arriving.</p>

<p><code>Serial.available()</code> returns 0 most of the time and then with <code>else</code> block in place, the count of <code>char</code> in <code>inData</code>  is set to 0.</p>

<p>If <code>Serial.available()</code> does return 1, that single <code>char</code> is put in <code>inData</code>.  The next call to <code>Serial.available()</code> could easily return 0 as this code is far faster than data arriving.  With the <code>else</code> block in place, the count is zero-ed again.</p>

<p>Without the <code>else</code> block, data has a chance to 1) accumulate in <code>inData</code> and match <code>""BTMODIFY""</code> or 2) fill the buffer and no more matches.</p>

<p>The key logic mistake is assuming that data arrives on the serial interface all at once  instead of having potential large gaps of time (from the CPU's point of view) between <code>char</code>.</p>

<p>Suggested changes:<br>
1) When the buffer is full, empty the eldest <code>char</code>. Treat <code>inData</code> as a FIFO.<br>
2) Test for a match after each <code>char</code>.<br>
3) Avoid magic numbers like 19 - used derived values.</p>

<pre><code>char Comp(const char* input) {
  size_t len = strlen(input);
  int i = 0;
  while(Serial.available() &gt; 0) {
    if (index &gt; (sizeof inData - 2)) {
      // toss eldest `char`
      index = sizeof inData - 2;
      memmove(&amp;inData[0], &amp;inData[1], index);
    }
    inChar = Serial.read(); //Read a character
    inData[index] = inChar; //Store it
    index++; //Increment where to write next
    inData[index] = '\0'; //Null terminate the string  **

    if(index &gt;= len &amp;&amp; memcmp(&amp;inData[index-len], input, len) == 0) {
      index = 0;
      inData[index] = '\0'; // **
      return(0);
    }
  }
  return(1);
}
</code></pre>

<p>** These steps not needed and <code>inData</code> could be size 19</p>
",,28353600,119
23194097,2,23194080,2014-04-21T09:00:51.333,1,,661519,,2014-04-21T09:16:39.867,2014-04-21T09:16:39.867,2,,"<p>One obvious problem is that you are returning the address to a local variable:</p>

<pre><code>int *readPot() ///read potentiometer value
{
   int tempValue = analogRead(A0);
   int *potValue = &amp;tempValue;
   return potValue;
}
</code></pre>

<p>Here, the returned pointer points to the address of <code>tempValue</code>. This ceases to be valid once the function returns. Just use an <code>int</code>:</p>

<pre><code>int readPot() ///read potentiometer value
{
   return analogRead(A0);
}
</code></pre>

<p>Next, I doubt that this is a valid argument to <code>Serial.println</code>:</p>

<pre><code>Serial.println(""Potentiometer reading:"" + *potValue); 
</code></pre>

<p>but this should work:</p>

<pre><code>int potValue = readPot();
Serial.print(""Potentiometer reading: "");
Serial.println(potValue); 
</code></pre>
",,28397551,97
23249347,2,23232223,2014-04-23T15:47:44.167,1,,1343924,,2014-04-25T10:33:19.917,2014-04-25T10:33:19.917,4,,"<p>You can do that using timers and interrupts, but some more informations is needed (which board, which processor).</p>

<p><strong>Note:</strong> <code>F_CPU</code> is already defined if you are using arduino libraries (<code>#define F_CPU 20000000U</code>)</p>

<p><strong>Note 2:</strong> You may want to use another timer than TIMER0 since it is use to track time on arduino</p>

<pre><code>#define GMilliSecondPeriod F_CPU / 1000

unsigned int gNextOCR = 0;
volatile unsigned long gMillis = 0;
bool valveOpened = false;

// This interruption will be called every 1ms
ISR(TIMER2_COMPA_vect)
{
  if(valve_open){
    gMillis++;
    if(gMillis &gt;= 30000){
      close_valve();
      gMillis = 0;
    }
  }  

  gNextOCR += GMilliSecondPeriod;
  OCR2A = gNextOCR &gt;&gt; 8; // smart way to handle millis, they will always be average of what they should be
}

// Just call this function within your setup
void setupTime(){
  TCCR2B |= _BV(CS02);
  TIMSK2 |= _BV(OCIE0A);

  sei(); // enable interupts
}
</code></pre>
",,28423387,53
27685641,2,23261572,2014-12-29T08:28:21.043,0,,3477873,,2014-12-29T08:28:21.043,,0,,"<p>Problem resolved! As usually solution is quite simple: use GPIO interrupt but test which button has been pressed. GPIO iterrupt:</p>

<pre><code>void buttonInt(void){ // disable button interrupt 
     M8C_DisableIntMask(INT_MSK0, INT_MSK0_GPIO);
     if (Right_Data_ADDR &amp; Right_MASK) buttonRightPressed = 1;
     if (Left_Data_ADDR &amp; Left_MASK) buttonLeftPressed = 1;
     if (Select_Data_ADDR &amp; Select_MASK) buttonSelectPressed = 1;
}
</code></pre>
",,28448787,133
23272239,2,23271765,2014-04-24T14:44:06.940,1,,1405208,,2014-04-24T15:08:12.427,2017-05-23T11:57:28.763,2,,"<p>Maybe this solution transforming <code>Ctrl+D</code> into <code>Ctrl+C</code> and <code>Ctrl+C</code> into <code>Ctrl+D</code> using term caps may help you : <a href=""https://stackoverflow.com/a/1516414/1405208"">https://stackoverflow.com/a/1516414/1405208</a>.</p>

<p><code>Ctrl+D</code> will therefore send the <code>SIGINT</code> signal. You just have to catch it. You may have to use a global variable though.</p>

<pre><code>volatile sig_atomic_t ctrld_pressed = 0;

void ctrld(int sig)
{
  ctrld_pressed = 1;
}

int main()
{
    signal(SIGINT, ctrld);
    while (!ctrld_pressed)
    {

    }
}
</code></pre>
",,28487502,12086
23273485,2,23271765,2014-04-24T15:35:53.060,1,,2692339,,2014-04-24T15:49:22.473,2014-04-24T15:49:22.473,0,,"<p>As @unwind stated, you may use <a href=""http://linux.die.net/man/2/select"" rel=""nofollow"">select</a>.</p>

<pre><code>#include &lt;sys/select.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main()
{
   int run = 1, rc;
   fd_set fd_list, readfd;

   FD_ZERO(&amp;fd_list);
   FD_SET(STDIN_FILENO, &amp;fd_list);

   while (run)
  {
    readfd = fd_list;
    rc = select(STDIN_FILENO + 1, &amp;readfd, NULL, NULL, NULL);

    if (rc == -1)
    {
        perror(""Select error"");
      return 1;
    }

    if (FD_ISSET(STDIN_FILENO, &amp;readfd) &amp;&amp; read(STDIN_FILENO, &amp;rc, sizeof(rc)) == 0 )
      run = 0;

  }

  return 0;
}
</code></pre>

<p>We have told select to monitor for reading just one fd(STDIN_FILENO): the standard input one.<br>
Once the user enters something, <code>select</code> will alert us of that event; we investigate to know whether that input comes from STDIN_FILENO and if so, we <a href=""http://linux.die.net/man/3/read"" rel=""nofollow""><code>read</code></a> from it. If <code>read</code> returns 0, that means an end-of-file was met. </p>
",,28491732,596
23281616,2,23281584,2014-04-24T23:24:45.007,4,,1670308,,2014-04-25T00:14:08.017,2014-04-25T00:14:08.017,4,,"<p>It is exactly what it is informing: your character strings are way too long to fit in your char array, so your compiler is telling you that it will not proceed any further.</p>

<p>You can make it work by enhancing the size of your arrays like this:</p>

<pre><code>char ns[ ][30] = //... ;
</code></pre>

<p>The <code>30</code> here is just to represent your biggest char string; it needs to have the size of your largest predefined char string + 1 (<a href=""http://en.wikipedia.org/wiki/Null-terminated_string"" rel=""nofollow"">so that the null terminating character <code>\0</code> can be added</a>). For example, if your biggest string were <code>""apple""</code>, your array would need to be of, at least, length <code>6</code>.</p>

<p>You can iterate through these strings by doing this, for example:</p>

<pre><code>int array_items = sizeof(ns) / sizeof(*ns); // this will gives you the amount of items stored in your array
int i;
int j;
for (i = 0; i &lt; array_items; ++i) {
   size_t strSize = strlen(ns[i]); // strSize now contains, if ns[i] contained the example of apple, 5
    for (j = 0; j &lt; strSize; ++j) {
        printf(""%c"", ns[i][j]);
    }
  printf(""\n"");
}
</code></pre>
",,28529915,253
23294076,2,23286308,2014-04-25T13:06:55.673,0,,1343924,,2014-04-25T13:06:55.673,,0,,"<p>Maybe something like that can best suit you.
If I understand correctly your program basically toggle 3 times the led and then check for the pin state with a delay before and after (which is variable).</p>

<p>If you want me to detail some more parts, ask me I will edit my post ;)</p>

<pre><code>#include ""Arduino.h""//Standard Arduino Library
#include ""Print.h"" //Print to serial library, Serial.Println would not work by default for some reason.

// Some debugging macros
#define DEBUG 1
#define slog(a) { if (DEBUG) Serial.println(a); }; // No debug directive will be in compiled file if DEBUG is set to 0

// Let's define our port mapping
#define LED_PIN _BV(7) //bit 7 on PORTB on 2560 correspond to digital pin 13 (check http://arduino.cc/en/Hacking/PinMapping2560)
#define READ_PIN _BV(3)

// Some quick access for led pin / read pin manipulation
// Let's use bitwise operation on PORTB, digitalRead =&gt; 28 cycle, direct read with PORTB =&gt; 1 cycle (28x faster!)
// I prefer defining setters as functions, easier to read, but you are not force to (it is exactly the same once compiled)
//#define LED_ON() { PORTB |= LED_PIN; } // Put LED_PIN bit to 1 on PORTB
//#define LED_OFF() { PORTB &amp;= ~LED_PIN; } // Put LED_PIN bit to 0 on PORTB
#define LED_TOGGLE() { PORTB ^= LED_PIN; } // Put LED_PIN bit to 0 if it was 1 or to 1 if it was 0

#define READ_STATE PORTB &amp; READ_PIN // Read LED_PIN bit on PORTB


int loopcount = 0; //Def as global var so it won't be reset on next loop iteration

// Let's create an array which will define all the delays before and after serial calls
// ex: {1000, 1500} =&gt; 1000ms before serial output, 1500ms after serial output
int wrapDelays[][2] = { {1000, 1500}, {1000, 1000}, {1500, 1000}, {1500, 1000}, {500, 1000}, {500, 0} };

void setup() //Setup function, used to set pins and vars before running main Arduino Program
{
    if (DEBUG) Serial.begin(9600); //Start serial comms, set baud rate
    slog(""\nHello User.\n\nArduio has set baud rate and started serial communication.\n\nThank You, Sketch will run momentarily.\n\n"");

    // Output/Input for PORTB (in DDRB register)
    DDRB |= LED_PIN; // Set LED_PIN to digital output mode (put LED_PIN bit to 1)
    DDRB &amp;= ~READ_PIN; // Ensure READ_PIN is in input mode (put READ_PIN bit to 0)
}

// ToggleLed, write read pin state on serial, and wait `delayBefore`ms before and `delayAfter`ms after
void toggleLedBetweenDelays(int delayBefore, int delayAfter){
    LED_TOGGLE();

    if (delayBefore &gt; 0) delay(delayBefore);

    if (READ_STATE) {//If else funct for outputting pin state to console
        slog(""Pin is in a HIGH state\n\n""); // Output to console
    }
    else
        slog(""Pin is in a LOW state\n\n""); // Output to console

    if (delayAfter &gt; 0) delay(delayAfter);
}

void loopCounter(){
    loopcount++; // increase count of loops
    slog(""This program has ran this many times:\n"");
    slog(loopcount);
}

void loop() //Actual program
{
    for (int i = 0, l = sizeof(wrapDelays) / sizeof(wrapDelays[0]); i &lt; l; ++i)
    {
        toggleLedBetweenDelays(wrapDelays[i][0], wrapDelays[i][1]);
    }

    loopCounter();
}
</code></pre>

<p><strong>Note:</strong> Don't forget that it's not because the code you write is smaller that the final compiled binary will also be smaller/optimized.</p>
",,28557873,1098
23288348,2,23287936,2014-04-25T08:47:16.483,1,,2684539,,2014-04-25T10:07:39.427,2014-04-25T10:07:39.427,2,,"<p>In C++11, you may directly do that:</p>

<pre><code>class Animation
{
public:
    std::uint16_t frames[8][4] = {
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
        {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF}
    };
    std::uint8_t currentFrame = 0;
};
</code></pre>

<p>In C++03, you have to use the constructor:</p>

<pre><code>class Animation
{
public:
    Animation() : currentFrame(0)
    {
        for (int i = 0; i != 8; ++i) {
            for (int j = 0; j != 4; ++j) {
                frames[i][j] = 0xFFFF;
            }
        }
    }

    uint16_t frames[8][4];
    uint8_t currentFrame;
};
</code></pre>
",,28651939,14694
23321840,2,23312619,2014-04-27T09:49:34.980,2,,168986,,2014-04-27T10:12:25.527,2014-04-27T10:12:25.527,5,,"<p>Assuming that the scheduler is cooperative and these fragments of code you have posted are somehow called in some ""big-loop"", then, most non-trivial tasks would typically be implemented as state-machines.  Given:</p>

<pre><code>class cElapsedTime
{
    cElapsedTime()
    {
       zero() ; 
    }

    void zero()
    {
        timestamp = millis() ;
    }

    bool time()
    {
        return millis() - m_timestamp ;
    }
} ;

enum
{
    STATE_A,
    STATE_B
}  state = STATE_A;

cElapsedTime control_task_delay ;
</code></pre>

<p>Then toggle between two states to execute different code blocks after each delay period.  By continuously comparing the elapsed time with the <em>current</em> value of <code>_speedVar</code>, the delay can be changed at any time. If <code>_speedVar</code> changed from 10 seconds to 5, and elapsed time is 7 seconds, the delayed code will be executed immediatly; if the time is extended, so will the delay:</p>

<pre><code>if( control_task_delay.time() &gt;= _speedVar )
{
    switch( state )
    {
        case STATE_A :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_B ;              // Next state
        break ;

        case STATE_B :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_A ;              // Next state
        break ;
    }
}
</code></pre>

<p>It is not clear in your code fragment that the first <code>// Some function</code> is not identical to the second; perhaps <code>// Some other function</code> would have clarified? However if they were in fact identical then the code would be simply:</p>

<pre><code>if( control_task_delay.time() &gt;= _speedVar )
{
    // Some function

    control_task_delay.zero()      // Restart delay
}
</code></pre>

<p>You can see that it is the same principle you have applied to your UART polling task - using a non-blocking test.  That said, there is perhaps no need for separate tasks in any case; you could have:</p>

<pre><code>if( Serial.available() )
{
    _speedVar = Serial.read();
}

if( control_task_delay.time() &gt;= _speedVar )
{
    switch( state )
    {
        case STATE_A :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_B ;              // Next state
        break ;

        case STATE_B :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_A ;              // Next state
        break ;
    }
}
</code></pre>

<p>It is not clear in your code fragment that the first <code>// Some function</code> is not identical to the second; perhaps <code>// Some other function</code> would have clarified? However if they were in fact identical then the code would be simply:</p>

<pre><code>if( control_task_delay.time() &gt;= _speedVar )
{
    // Some function

    control_task_delay.zero()      // Restart delay
}

if( control_task_delay.time() &gt;= _speedVar )
{
    switch( state )
    {
        case STATE_A :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_B ;              // Next state
        break ;

        case STATE_B :
            // Some function

            control_task_delay.zero()      // Restart delay
            state = STATE_A ;              // Next state
        break ;
    }
}
</code></pre>

<p>It is hard to see what the ""scheduler"" is achieving in this scenario.</p>
",,28677381,221
23316379,2,23314794,2014-04-26T20:50:48.847,1,,1927972,,2014-04-26T20:50:48.847,,1,,"<p>Your code does not work because bufferLength is a member variable.  A pointer to a class member variable is not the same as a pointer to simple variable.</p>

<p>In C++, remember that member variables are accessed either:</p>

<pre><code>ptrobj-&gt;bufferLength = 5;  // via class object instance pointer
aobj.bufferLength = 7;  // via class instance
</code></pre>

<p>The address of a member variable is not the address into all memory, it is the address relative to the object.  You are coming from C, so it might help to realize that you can replace the keyword ""class"" with ""struct"".  The class keyword only has different default access, public, private, etc.</p>

<p>Inside a member function access to variables is not truly different that outside, but the compiler is hiding a detail.  There is an implicit this pointer that the compiler is adding</p>

<pre><code>void somememberfunction() {
  bufferLength = 7; // you write this code
  this-&gt;bufferLength = 7 // this is really the code
  ...
</code></pre>

<p>If you write in Python, the compiler does not insert the self/this pointer and you constantly have to type self.somevariable.</p>

<p>As written, there is no solution to your problem.  Your question can be stated ""How can I access a member variable without an object pointer?""  This is a common question for C based functions.</p>

<p>You don't state you intent in the above.  This is the version I would write</p>

<pre><code>Class Base {
public:
  boolean receiveByte();  // the accessors are public
protected:
  uint8_t buffer[ 20 ];  // the data is encapsulated
  uint8_t bufferLength;
}

boolean MyClass::receiveByte() {
  if( Serial.available() &gt; 0 )  {
    bufferLength++;
    // you would insert protection against overflow here
    buffer[bufferLength] = Serial.read();
    return( true );
  }
  return( false );
}

Class MyClass : public Base {
public:
  void execute( void );
}

void MyClass::execute( void )  {
  if( receiveByte() == true ) {
    // Do something
  }
}
</code></pre>
",,28696781,1405
23315471,2,23315017,2014-04-26T19:19:37.527,0,,1004301,,2014-04-26T19:19:37.527,,1,,"<p>There are two method to do that.</p>

<p>Method one:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef char byte;

int main(void)
{
    byte circle0[7] = { 0, 1, 40, 44, 43, 42, 41 };
    byte circle1[7] = { 1, 2, 39, 45, 44, 41, 40 };
    byte circle2[7] = { 2, 3, 38, 46, 45, 40, 39 };
    byte circle3[7] = { 3, 4, 37, 47, 46, 39, 38 };
    byte circle4[7] = { 4, 5, 36, 48, 47, 38, 37 };

    byte *circleArray[] = { circle0, circle1, circle2, circle3, circle4};

    size_t circleArrayLength = sizeof(circleArray)/sizeof(circleArray[0]);

    for (size_t i = 0; i &lt; circleArrayLength; i++) {
        for (size_t c = 0; c &lt; 7; c++) {
            printf(""circleArray[%zu][%zu] = %d\n"", i, c, circleArray[i][c]);
        }
    }
}
</code></pre>

<p>Method Two:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef char byte;

int main(void)
{
    byte circle0[7] = { 0, 1, 40, 44, 43, 42, 41 };
    byte circle1[7] = { 1, 2, 39, 45, 44, 41, 40 };
    byte circle2[7] = { 2, 3, 38, 46, 45, 40, 39 };
    byte circle3[7] = { 3, 4, 37, 47, 46, 39, 38 };
    byte circle4[7] = { 4, 5, 36, 48, 47, 38, 37 };

    byte (*circleArray[])[7] = { &amp;circle0, &amp;circle1, &amp;circle2, &amp;circle3, &amp;circle4};

    size_t circleArrayLength = sizeof(circleArray)/sizeof(circleArray[0]);

    for (size_t i = 0; i &lt; circleArrayLength; i++) {
        for (size_t c = 0; c &lt; 7; c++) {
            printf(""circleArray[%zu][%zu] = %d\n"", i, c, (*circleArray[i])[c]);
        }
    }
}
</code></pre>
",,28721813,2100
23330433,2,23330002,2014-04-27T23:47:56.717,1,,3525545,,2014-04-27T23:47:56.717,,0,,"<p>Perhaps this will help?</p>

<pre><code>#ifndef _nfc_read_h_
  #define _nfc_read_h_

//Libarys
#include &lt;Wire.h&gt;
#include &lt;Adafruit_NFCShield_I2C.h&gt;
</code></pre>

<p>Add the following lines:</p>

<pre><code>#include &lt;stdint.h&gt;
#ifndef boolean
    #define boolean int
#endif
</code></pre>

<p>The above lines will ensure that the proper types are defined.</p>

<pre><code>void setup_adafruit(int mode);  
void read_card(boolean *success,uint8_t *uid,uint8_t *uidLength);//&lt;--here is the error

#endif 
</code></pre>
",,28733011,497
23331949,2,23331917,2014-04-28T03:16:00.750,1,,65678,,2014-04-28T03:23:31.643,2014-04-28T03:23:31.643,5,,"<p>If you wish to talk about the exact same instance, you need to indeed use a reference or a pointer (they are fairly similar in what happens under the hood).</p>

<p>The choice falls to a pointer in this case, because you can only initialize a reference, but not set its value later on anymore. Since you have a <code>setJoint</code>, this is clearly a reason to use a pointer.</p>

<p>To keep the rest of the code mostly the same, we will let <code>setJoint</code> take a reference argument however, and then take its address to gain access to a pointer to the memory location that was passed by reference to the function.</p>

<p>When accessing members (be they data or function) of objects to which we have a pointer, there are two options: You can either dereference the pointer and then use the resulting object as you normally would, or you can use the <code>-&gt;</code> operator to do this in one step.</p>

<p>Putting everything together, this is the result:</p>

<pre><code>// Dancer.h
class Dancer {
  public:
    Joint* joint;
    void setJoint(Joint&amp; newJoint);
    void animate();
}

// Dancer.cpp
Dancer::setJoint(Joint&amp; newJoint) {
  joint = &amp;newJoint;
}
Dancer::animate() {
  joint-&gt;moveTo(random(90));
}

// MainArduinoSketch.ino
Joint frontLeftJoint;
void setup() {
  dancer.setJoint(frontLeftJoint);
}
</code></pre>
",,28750703,6034
23375833,2,23344878,2014-04-29T21:41:48.710,0,,266392,,2014-04-29T21:41:48.710,,0,,"<p>Are you sure it isn't your section 3 that's causing problems?  Because you're declaring a pointer to a structure, but not allocating memory for that structure.</p>

<p>You'd typically write your code like this:</p>

<pre><code>valuesStruct test;
test.valA = 0;
test.valB = 0;
test.valC = 0;

//Section 2: not working
exampleLibObj.processPacket(test);

//Section 3: working
exampleLibObj.processPacket(&amp;test);
</code></pre>

<p>But you also wouldn't typically pass a structure to a function -- you'd pass a pointer to that structure.  There really isn't a need for your second sample.</p>
",,28794539,189
23390016,2,23387848,2014-04-30T13:51:48.180,1,,3323096,,2014-05-01T10:58:01.833,2014-05-01T10:58:01.833,3,,"<p>This is quite an interesting problem, in the normal world of computers we would solve this via threading. However as you are running without an OS we have to do one of two things, implement coroutines (fake threading without an OS) or use asynchronous code and interrupts.</p>

<p>My understanding is that you print something when an object first comes into the way of your sensor, as the arduino uno as opposed to the due is not easy to implement coroutines on we shall try the interrupt route.</p>

<p>First you will likely be interested in this library <a href=""http://playground.arduino.cc/Code/Timer1"" rel=""nofollow"">http://playground.arduino.cc/Code/Timer1</a>
It allows you to add an interrupt service routine to run on a timer. Use the attachInterrupt(function, period) function in the library for this.</p>

<p>In your interrupt service routine you will want to check the sensor, set a variable to say how long ago since it was last triggered and print the message if appropriate. This means your main loop is completely free to run other code and will not block your other sensors.</p>

<p>For example:</p>

<pre><code>void TimFun()
{
    static int LastRead;
    if(LastRead &amp;&amp; (0 == analogRead(sensor1))
    {
        Serial.println(""SensorTrip"");
    }
    LastRead = analogRead(sensor1);
}

void loop()
{
    // Do other stuff here
}

void setup()
{
    Timer1.initialize(100000);
    Timer1.attachInterrupt(TimFun);
    // Rest of setup Here
}
</code></pre>
",,28800533,183
23406071,2,23387848,2014-05-01T10:39:04.740,0,,3121577,,2014-05-01T10:39:04.740,,0,,"<p>I managed to make an int before the void setup and then used a while loop. with in the if statement.</p>

<pre><code>int i = 1;
</code></pre>

<hr>

<pre><code>if (analogRead(sensor1) == 0) {     
  timer.start ();
  tStop = false;

while (i == 1) {
  Serial.println (""Start Time = 0"");
  i++;
 }    
}
</code></pre>
",,28825670,123
23414601,2,23387848,2014-05-01T18:59:26.713,0,,2034089,,2014-05-01T18:59:26.713,,0,,"<p>You probably should use an <code>if</code> instead of a <code>while</code> loop that will never execute more than once.</p>

<pre><code>bool tripped = false;

void setup(){
    //setup stuff here
}

void loop() {
    if ( analogRead(sensor1) == 0 ) 
    {     
        timer.start ();
        tStop = false;

        if ( tripped == false ) 
        {
            Serial.println (""Start Time = 0"");
            tripped = true;
        }
    }
}
</code></pre>
",,28861621,9345
23391916,2,23391125,2014-04-30T15:17:13.117,1,,645128,,2014-04-30T16:21:25.343,2014-04-30T16:21:25.343,4,,"<p><em>Skip to the section</em> <strong><em>Addressing your code...</em></strong> <em>at bottom for most relevant content</em><br>
(this stuff up here is barely useful blither)  </p>

<p>The purpose of your function:  </p>

<pre><code>Sha256.write((char *)bytearray);
</code></pre>

<p>I believe is to write more data to the running hash.  (<strong><em><a href=""https://godoc.org/github.com/rdwilliamson/snippets#Sha256.Write"" rel=""nofollow"">from this</a></em></strong>)
 Therefore, I am not sure in the context of your question <em>how to convert this to a hex-string char back?</em> how this relates to the way you are using it.     </p>

<p><strong><em>Let me offer another approach for the sake of illustrating</em></strong> how you might go about returning the array of ints back into the form of a ""hexadecimal string"":  </p>

<p><strong><em><a href=""http://openssl.6102.n7.nabble.com/sha-256-program-example-td25771.html"" rel=""nofollow"">From Here</a></em></strong></p>

<p>Here is a code fragment that will calculate the digest for the string ""abc""</p>

<pre><code>   SHA256_CTX ctx;
   u_int8_t results[SHA256_DIGEST_LENGTH];
   char *buf;
   int n;

   buf = ""abc"";
   n = strlen(buf);
   SHA256_Init(&amp;ctx);
   SHA256_Update(&amp;ctx, (u_int8_t *)buf, n);
   SHA256_Final(results, &amp;ctx);

   /* Print the digest as one long hex value */
   printf(""0x"");
   for (n = 0; n &lt; SHA256_DIGEST_LENGTH; n++)
           printf(""%02x"", results[n]);
   putchar('\n'); 
</code></pre>

<p>resulting in: </p>

<pre><code>""0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"".   
</code></pre>

<p>In this example <strong><em>The array I believe you want</em></strong>, is contained in <code>u_int8_t results</code> </p>

<p>There is not enough description in your post to be sure this will help, let me know in the comments, and I will try to address further questions. </p>

<p><strong><em>Added</em></strong> after your edit:    </p>

<p><strong><em>Continuing from the example above</em></strong>, to put the array contents of <code>results</code> back into a string, you can do something like this:  </p>

<pre><code>char *newString;
newString = malloc(sizeof(char)*SHA256_DIGEST_LENGTH*2);
memset(newString, 0, sizeof(char)*SHA256_DIGEST_LENGTH*2);
strcat(newString, ""0x"");
for(i=0;i&lt;SHA256_DIGEST_LENGTH;i++)
{
    sprintf(newString, ""%s%02x\n"", newString, results[i]);
}
//use newString for stuff...
free(newString);  
</code></pre>

<p><strong><em>Addressing your code, and your question directly:</em></strong>  </p>

<p>Your code block:  </p>

<pre><code>  for(_batchSize = 100000; _batchSize &gt; 0; _batchSize--){
     bytearray[76] = _batchSize;
     Sha256.write((char *)bytearray); //here are the error
  }    
</code></pre>

<p>is not necessary if all you want to do is <em>to convert an array of <code>int</code> into a ""hexadecimal string""</em>  </p>

<p>Your int array, defined as:  </p>

<pre><code>int bytearray[80];  
</code></pre>

<p>Already contains all the necessary values at this point,  as you illustrated with your latest edit.  If you want to return this data to a ""hexadecimal string"" form, then this will do that for you:  (replacing <code>result</code> with your <code>bytearray</code>)</p>

<pre><code>char *newString;
newString = malloc(sizeof(char)*SHA256_DIGEST_LENGTH*2);//if these defines are not in your environment
memset(newString, 0, sizeof(char)*SHA256_DIGEST_LENGTH*2);//then replace them with appropriate value for length
strcat(newString, ""0x"");
for(i=0;i&lt;sizeof(bytearray)/sizeof(bytearray[0]);i++)
{
    sprintf(newString, ""%s%02x\n"", newString, bytearray[i]);
}
//use newString for stuff...
free(newString);  
</code></pre>
",,28888475,1009
23415445,2,23415242,2014-05-01T19:50:07.040,5,,3477950,,2014-05-01T19:59:45.040,2017-05-23T10:32:27.693,14,,"<p>First off, you can't write your code in ""C/C++"". There's no such language as ""C/C++"", as they are fundamentally different languages. As such, the answer regarding unions differs radically.</p>

<p>As to the title:</p>

<blockquote>
  <p>Are casts as safe as unions?</p>
</blockquote>

<p>No, generally they aren't, because of the <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">strict aliasing rule</a>. That is, if you type-pun a pointer of one certain type with a pointer to an incompatible type, it will result in undefined behavior. <strong>The only exception to this rule is when you read or manipulate the byte-wise representation of an object by aliasing it through a pointer to (signed or unsigned) <code>char</code>.</strong> As in your case.</p>

<p>Unions, however, are quite different bastards. Type punning via copying to and reading from unions is permitted in C99 and later, but results in undefined behavior in C89 and all versions of C++.</p>

<p>In <strong>one direction,</strong> you can also safely type pun (in C99 and later) using a pointer to union, if you have the original union as an actual object. Like this:</p>

<pre><code>union p {
    char c[sizeof(float)];
    float f;
} pun;
union p *punPtr = &amp;pun;

punPtr-&gt;f = 3.14;
send_bytes(punPtr-&gt;c, sizeof(float));
</code></pre>

<p>Because ""a pointer to a union points to all of its members and vice versa"" (C99, I don't remember the exact pargraph, it's around 6.2.5, IIRC). <strong>This isn't true in the other direction, though:</strong></p>

<pre><code>float f = 3.14;
union p *punPtr = &amp;f;
send_bytes(punPtr-&gt;c, sizeof(float)); // triggers UB!
</code></pre>

<p>To sum up: the following code snippet is valid in both C89, C99, C11 and C++:</p>

<pre><code>float f = 3.14;
char *p = (char *)&amp;f;
size_t i;
for (i = 0; i &lt; sizeof f; i++) {
    send_byte(p[i]); // hypotetical function
}
</code></pre>

<p>The following is only valid in C99 and later:</p>

<pre><code>union {
    char c[sizeof(float)];
    float f;
} pun;

pun.f = 3.14;
send_bytes(pun.c, sizeof float); // another hypotetical function
</code></pre>

<p>The following, however, would <strong>not</strong> be valid:</p>

<pre><code>float f = 3.14;
unsigned *u = (unsigned *)&amp;f;
printf(""%u\n"", *u); // undefined behavior triggered!
</code></pre>

<p><strong>Another solution that is always guaranteed to work</strong> is <code>memcpy()</code>. The <code>memcpy()</code> function does a bytewise copying between two objects. (Don't get me started on it being ""slow"" -- in most modern compilers and stdlib implementations, it's an intrinsic function).</p>
",,28905242,1850
23449692,2,23449197,2014-05-03T20:51:30.880,3,,1599004,,2014-05-03T22:51:39.860,2014-05-03T22:51:39.860,1,,"<p>Your program does not properly <strong>open()</strong> the serial port for reading it.<br>
In fact it repeatedly opens it two times every iteration of the <strong>for</strong> loop.<br>
The device should be opened only once by your program.</p>

<p>Instead of</p>

<pre><code>for (i=0; i&lt;50; i++) {

   fcntl(open_port(), F_SETFL, FNDELAY);

   bytes_read = read(open_port(), buf, nbytes);

}
</code></pre>

<p>the main program should be structured like</p>

<pre><code>fd = open_port();
if (fd &lt; 0) {
    /* handle error condition */
}
rc = fcntl(fd, F_SETFL, FNDELAY);
if (rc &lt; 0) {
    /* handle error condition */
}
for (i=0; i&lt;50; i++) {


   bytes_read = read(fd, buf, nbytes);
   if (bytes_read &lt; 0) {
        /* handle error condition */
    }

}
close(fd);
</code></pre>

<p>Your program is too ""simple"".  It sets only a few attributes, and doesn't bother to check the return codes of system calls.  </p>

<p>Is this supposed to be canonical or non-canonical (aka raw) mode (i.e. is the data ASCII text or binary)?<br>
Refer to this <a href=""http://www.cmrr.umn.edu/~strupp/serial.html"" rel=""nofollow"">Serial Programming Guide</a> for proper setup of the serial port.  </p>

<blockquote>
  <p>read data from a USB port  </p>
</blockquote>

<p>USB is a bus.<br>
The device your program reads from is a serial port attached to that USBus.</p>

<p><strong>Second coding issue</strong></p>

<p>Your original code may print garbage data.</p>

<pre><code>nbytes = sizeof(buf);
bytes_read = read(open_port(), buf, nbytes);
printf(""%s "", buf);
buf[0]=0;
</code></pre>

<p>The bytes returned by the <strong>read()</strong> operation are not likely to be terminated by a NULL byte, so a string operation on that read buffer could exceed the bounds of the allocated array.<br>
Code that would not misbehave would be something like:</p>

<pre><code>nbytes = sizeof(buf) - 1;

bytes_read = read(fd, buf, nbytes);
if (bytes_read &lt; 0) {
    /* handle error condition */
} else {
    buf[bytes_read] = 0; /* append terminator */
    printf(""%s "", buf);
}
</code></pre>

<p>Note that <strong>nbytes</strong> is one less than the allocated size of the buffer.<br>
This is to ensure that there is an available byte to store the string terminator byte when the <strong>read()</strong> operation returns a ""full"" buffer of <strong>nbytes</strong>.<br>
For efficiency the assignment of <strong>nbytes</strong> should be performed before entering the <strong>for</strong> loop, rather than within the loop.</p>
",,28909538,447
23531356,2,23502412,2014-05-08T01:46:24.030,0,,1290438,,2014-05-08T01:46:24.030,,0,,"<p>well, as the compiler is telling you, you can't print a <code>HardwareSerial</code>, because it makes no sense.</p>

<p>Though, you're not taking the right approach for your problem, because this is a folded problem:</p>

<ul>
<li>depending on the hardware, you may have a different number of serial ports ;</li>
<li>in the settings you set up or not the serial ports.</li>
</ul>

<p>For the first point, there's not much you can do, everything is setup at compile time, and that's what you'll have to implement: different usecases depending on different AVR.</p>

<pre><code>HardwareSerial *possible_ports[] = {
#if defined(UBRRH) || defined(UBRR0H)
&amp;Serial,
#endif
#if defined(UBBR1H)
&amp;Serial1, 
#endif
#if defined(UBBR2H)
&amp;Serial2,
#endif
#if defined(UBBR3H)
&amp;Serial3
#endif
};
</code></pre>

<p>For the second point, I don't think there's anything to test that in the HardwareSerial class, though you can do it yourself:</p>

<pre><code>bool serial_is_configured() {
    return (_BV(TXEN0) &amp; UCSRB == _BV(TXEN0));
} 
bool serial1_is_configured() {
    return (_BV(TXEN1) &amp; UCSRB == _BV(TXEN1));
} 
// ...
</code></pre>

<p>cf source code of HardwareSerial:</p>

<ul>
<li><a href=""http://github.com/arduino/Arduino/blob/master/hardware/arduino/cores/arduino/HardwareSerial.cpp#L487"" rel=""nofollow"">line 487</a></li>
<li><a href=""http://github.com/arduino/Arduino/blob/master/hardware/arduino/cores/arduino/HardwareSerial.cpp#L406"" rel=""nofollow"">line 406</a></li>
</ul>

<p>in there:</p>

<ul>
<li><code>cbi()</code> clears a bit</li>
<li><code>sbi()</code> sets a bit</li>
</ul>

<p>HTH</p>
",,28916264,473
23545149,2,23519892,2014-05-08T14:46:03.917,0,,1274285,,2014-05-08T21:53:20.533,2014-05-08T21:53:20.533,3,,"<p>Ok. I found a right way, here is it:</p>

<pre><code>    UInt8 data[] = { 0xF0, manufacturerId, databyte1, databyte2, databyte3, 0xF7 };
    MIDIRawData raw;
    memcpy(raw.data, data, 0, sizeof(data));
    raw.length = sizeof(data);

    if ((status = MusicTrackNewMIDIRawDataEvent(track, timestamp, &amp;raw)) != noErr)
    {
        return status;
    }
</code></pre>
",,28920580,249
32245144,2,23519892,2015-08-27T09:09:34.540,0,,5272078,,2015-08-28T08:34:36.917,2015-08-28T08:34:36.917,0,,"<p>Here is an example, how to record normal MIDI and SYSEX messages in a MIDI track and save them in a MIDI file in the shared iTunes folder (set ""Application supports iTunes file sharing"" to ""YES"" in .plist):
See specially ""calloc"" in the code!!</p>

<pre><code>#import ""ViewController.h""
#import &lt;CoreMIDI/MIDIServices.h&gt;
#import &lt;CoreMIDI/CoreMIDI.h&gt;
#import ""AppDelegate.h""
#include &lt;sys/time.h&gt;
#import &lt;UIKit/UIKit.h&gt;
#import &lt;QuartzCore/QuartzCore.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;

@interface ViewController ()

@end

@implementation ViewController

@synthesize SYSEX_8;

long secTempA = 0;
float secTempB = 0;
long secStartA = 0;
float secStartB = 0;
MusicTimeStamp timeStamp = 0;
MusicSequence recordSequence;
MusicTrack recordTrack;
MusicTimeStamp lenRec = 0;
MIDINoteMessage noteMessage;
MusicTrack track;
NSString *fileNameForSave = @"""";
NSString *midiFileWritePath = @"""";
NSString *documentsDirectoryPath = @"""";
UIAlertView *infoStore;
UIAlertView *infoStoreError;
MIDIRawData *sysexData;

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    // Get documents Directory
    // (don't forget the "".plist"" entry ""Application supports iTunes file sharing YES""
    NSArray *pathDocDir = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    documentsDirectoryPath = [pathDocDir objectAtIndex:0];

}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (IBAction)SYSEX_8_touchdown:(id)sender { 
    NewMusicSequence(&amp;recordSequence);
    MusicSequenceNewTrack(recordSequence, &amp;recordTrack);
    MusicSequenceSetSequenceType(recordSequence, kMusicSequenceType_Beats);

    timeStamp = 0;
    struct timeval time;
    gettimeofday(&amp;time, NULL);
    secStartA = time.tv_sec;
    secStartB = time.tv_usec * 0.000001;

    noteMessage.channel = 0x90; // Note ON 
    noteMessage.note = 0x3C;
    noteMessage.velocity = 0x7F;
    MusicTrackNewMIDINoteEvent(recordTrack, timeStamp, &amp;noteMessage);
    NSLog(@""%02x %02x %02x"", 0x90, 0x3C, 0x7F);

    usleep(10000);

    gettimeofday(&amp;time, NULL);
    secTempA = time.tv_sec;
    secTempB = time.tv_usec * 0.000001;
    secTempA = secTempA - secStartA;
    secTempB = secTempB - secStartB;
    timeStamp = (secTempA + secTempB) * 2;

    noteMessage.channel = 0x90; // Note OFF
    noteMessage.note = 0x3C;
    noteMessage.velocity = 0x00;
    MusicTrackNewMIDINoteEvent(recordTrack, timeStamp, &amp;noteMessage);
    NSLog(@""%02x %02x %02x"", 0x90, 0x3C, 0x00);

    usleep(100000);

    gettimeofday(&amp;time, NULL);
    secTempA = time.tv_sec;
    secTempB = time.tv_usec * 0.000001;
    secTempA = secTempA - secStartA;
    secTempB = secTempB - secStartB;
    timeStamp = (secTempA + secTempB) * 2;

    Byte datatest[8];
    UInt32 theSize = offsetof(MIDIRawData, data[0]) + (sizeof(UInt8) * sizeof(datatest));
    sysexData = (MIDIRawData *)calloc(1, theSize);
    sysexData-&gt;length = sizeof(datatest);

    datatest[0] = 0xF0;  // Start SYSEX
    datatest[1] = 0x26;
    datatest[2] = 0x79;
    datatest[3] = 0x0E;
    datatest[4] = 0x00;
    datatest[5] = 0x00;
    datatest[6] = 0x00;
    datatest[7] = 0xF7;  // End SYSEX

    for (int j = 0; j &lt; sizeof(datatest); j++) {
        sysexData-&gt;data[j] = datatest[j];
        NSLog(@""%02x"", sysexData-&gt;data[j]);
    }

    int status;
    if ((status = MusicTrackNewMIDIRawDataEvent(recordTrack, timeStamp, sysexData) != noErr)) {
        NSLog(@""error %i"", status);
    }
    else {
        [self stopRecording];
    }
}

- (void) stopRecording {

    CAShow(recordSequence);  // To show all MIDI events !!!

    UInt32 sz = sizeof(MusicTimeStamp);
    lenRec = 0;
    MusicSequenceGetIndTrack(recordSequence, 0, &amp;track);
    MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &amp;lenRec, &amp;sz);

    if (lenRec &gt; 0.1){
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@""yyyy-MM-dd HH:mm:ss +zzzz""];
        NSDate *startDate = [NSDate date];

        NSTimeZone *zone = [NSTimeZone systemTimeZone];
        NSInteger interval = [zone secondsFromGMTForDate:startDate];
        startDate = [startDate dateByAddingTimeInterval:interval];
        //    NSLog(@""Date: %@"", startDate);

        NSString *strDate = [[NSString alloc] initWithFormat:@""%@"", startDate];
        NSArray *arr = [strDate componentsSeparatedByString:@"" ""];
        NSString *str;
        str = [arr objectAtIndex:0];
        NSArray *arr_date = [str componentsSeparatedByString:@""-""];

        int year = [[arr_date objectAtIndex:0] intValue];
        int month = [[arr_date objectAtIndex:1] intValue];
        int day = [[arr_date objectAtIndex:2] intValue];

        str = [arr objectAtIndex:1];
        NSArray *arr_time = [str componentsSeparatedByString:@"":""];

        int hours = [[arr_time objectAtIndex:0] intValue];
        int minutes = [[arr_time objectAtIndex:1] intValue];
        int seconds = [[arr_time objectAtIndex:2] intValue];

        fileNameForSave = [NSString stringWithFormat:@""%@_%04d%02d%02d_%02d%02d%02d%@"", @""$Record"", year, month, day, hours, minutes, seconds, @"".mid""];
        midiFileWritePath = [documentsDirectoryPath stringByAppendingPathComponent:fileNameForSave];

        infoStore = [[UIAlertView alloc]initWithTitle: @""Save as MIDI file ?""
                                              message: [NSString stringWithFormat:@""\n%@"", fileNameForSave]
                                             delegate: self
                                    cancelButtonTitle: @""YES""
                                    otherButtonTitles: @""NO"",nil];
        [infoStore show];  // rest siehe unten !!!!!
    }
    else {
        MusicSequenceDisposeTrack(recordSequence, track);
        DisposeMusicSequence(recordSequence);
    }

}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(int)buttonIndex {
    // deletion code here
    if (alertView == infoStore) {
        if (buttonIndex == 0) {
            NSURL *midiURL = [NSURL fileURLWithPath:midiFileWritePath];
            OSStatus status = 0;
            status = MusicSequenceFileCreate(recordSequence, (__bridge CFURLRef)(midiURL), kMusicSequenceFile_MIDIType, kMusicSequenceFileFlags_EraseFile, 0);
            if (status != noErr) {
                infoStoreError = [[UIAlertView alloc]initWithTitle: @""Information""
                                                           message: [NSString stringWithFormat:@""\nError storing MIDI file in: %@"", documentsDirectoryPath]
                                                          delegate: self
                                                 cancelButtonTitle: nil
                                                 otherButtonTitles:@""OK"",nil];
                [infoStoreError show];
            }
        }
        MusicSequenceDisposeTrack(recordSequence, track);
        DisposeMusicSequence(recordSequence);
    }

}

@end
</code></pre>
",,28921632,308
23571875,2,23571460,2014-05-09T18:45:48.243,2,,3443596,,2014-05-09T18:51:06.580,2014-05-09T18:51:06.580,0,,"<p>in arduino, i guess this is what you have:</p>

<pre><code>void loop(){
    char c;
    String cmd = """";
    while (Serial.available()) {
        c = Serial.read();
        Serial.println(c);
        cmd.concat(c);
    }
}
</code></pre>

<p>in that code, while a new character is being sent (and you've read the entire buffer), you have</p>

<pre><code>Serial.available() = FALSE
</code></pre>

<p>so the main loop sets</p>

<pre><code>cmd = """"
</code></pre>

<p>and you lose the previous data. Fix this inicializing <code>cmd</code> outside the main loop, and also inicialize <code>c</code> outside the loop:</p>

<pre><code>char c;
String cmd = """";

void loop(){
    while (Serial.available()) {
        c = Serial.read();
        Serial.println(c);
        cmd.concat(c);
    }
}
</code></pre>
",,29026533,337
23576909,2,23576827,2014-05-10T03:49:46.703,2,,3114237,,2014-05-10T03:49:46.703,2017-05-23T12:25:24.137,0,,"<p>First, you need to parse your value. You may do that this way:</p>

<pre><code>void parse_hex(char* a, char* b, char* c, const char* string) {
    //certainly not the most elegant way. Note that we start at 1 because of '#'
    a[0] = string[1];
    a[1] = string[2];
    b[0] = string[3];
    b[1] = string[4];
    c[0] = string[5];
    c[1] = string[6];
}
</code></pre>

<p>Then, you will convert each string into it's correspondent integer. You can learn how to do that from <a href=""https://stackoverflow.com/a/1070499/3114237"">this</a> answer. </p>
",,29051576,10254
23577019,2,23576827,2014-05-10T04:12:08.347,18,,1035008,,2015-12-02T15:12:39.343,2017-05-23T12:32:11.533,6,,"<p>All you need to do is convert the string to integers and then split them into three separate r, g, b values. </p>

<pre><code>string hexstring = ""#FF3Fa0"";

// Get rid of '#' and convert it to integer
int number = (int) strtol( &amp;hexstring[1], NULL, 16);

// Split them up into r, g, b values
int r = number &gt;&gt; 16;
int g = number &gt;&gt; 8 &amp; 0xFF;
int b = number &amp; 0xFF;
</code></pre>

<p>You may want to have a look at <a href=""https://stackoverflow.com/questions/10156409/convert-hex-string-char-to-int"">this question</a> as well. </p>

<hr>

<p><strong>Edit (thanks to James comments):</strong></p>

<p>For some machine (e.g. Arduino (Uno)), ints are 16 bits instead of 32. If red values are dropping for you, use a long instead.</p>

<pre><code>string hexstring = ""#FF3Fa0"";

// Get rid of '#' and convert it to integer
long number = strtol( &amp;hexstring[1], NULL, 16);

// Split them up into r, g, b values
long r = number &gt;&gt; 16;
long g = number &gt;&gt; 8 &amp; 0xFF;
long b = number &amp; 0xFF;
</code></pre>

<hr>

<p><strong>Edit (an even safer version, use <code>strtoll</code> instead of <code>strtol</code>):</strong></p>

<pre><code>long long number = strtoll( &amp;hexstring[1], NULL, 16);

// Split them up into r, g, b values
long long r = number &gt;&gt; 16;
long long g = number &gt;&gt; 8 &amp; 0xFF;
long long b = number &amp; 0xFF;
</code></pre>
",,29077279,523
23577105,2,23576827,2014-05-10T04:29:10.920,0,,434551,,2014-05-10T04:29:10.920,,0,,"<pre><code>#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;

int main()
{
   char const* str = ""#FF9922"";
   char red[5] = {0};
   char green[5] = {0};
   char blue[5] = {0};

   red[0] = green[0] = blue[0] = '0';
   red[1] = green[1] = blue[1] = 'X';

   red[2] = str[1];
   red[3] = str[2];

   green[2] = str[3];
   green[3] = str[4];

   blue[2] = str[5];
   blue[3] = str[6];

   int r = strtol(red, NULL, 16);
   int g = strtol(green, NULL, 16);
   int b = strtol(blue, NULL, 16);

   std::cout &lt;&lt; ""Red: "" &lt;&lt; r &lt;&lt; "", Green: "" &lt;&lt; g &lt;&lt; "", Blue: "" &lt;&lt; b &lt;&lt; std::endl;
}
</code></pre>
",,29122381,60
23579566,2,23579507,2014-05-10T09:50:14.087,0,,3286797,,2014-05-10T10:07:01.670,2014-05-10T10:07:01.670,0,,"<p>I have assumed that you have a good reason not to use write(fd, msg, strlen(msg)) with the parameter length. So I defined the function send_string:</p>

<pre><code>void send_string(int fd, char* s)
{
    while( *s++ )
        write(fd, *s, 1);
}
</code></pre>

<p>use it in the main:</p>

<pre><code>int main( int argc, char** argv )
{
open_port();
    int wr;


    char* msg =""Ciao Mondo!"";

    /* Write to the port */
    send_string(fd, msg);

    // or use lenght parameter
    write(fd, msg, strlen(msg));

    close(fd);
  }
</code></pre>

<p>Angelo</p>
",,29201478,251
23584872,2,23584726,2014-05-10T18:38:03.577,3,,2587816,,2014-05-10T18:38:03.577,,2,,"<pre><code>union Data
{
   char  data[36];
   float f[9];
};


union Data data;
data.data[0] = 0;
data.data[1] = 0;
data.data[2] = 0;
data.data[3] = 0;

fprintf(stdout,""float is %f\n"",data.float[0]);
</code></pre>
",,29258580,323
23592780,2,23590999,2014-05-11T12:45:25.503,0,,3259360,,2014-05-11T12:45:25.503,,3,,"<p>First add this to your setup ...</p>

<pre><code>void setup(){
Serial.begin(9600);
setupTSL230();
pinMode(5,OUTPUT);
myservo1.attach(5);
</code></pre>

<p>}</p>

<p>Then make a new variable and add it to your if statements</p>

<pre><code>Boolean once; // declare this with your other int variables 
if(lightLevel &gt; 800 &amp;&amp; lightLevel &lt; 1000 &amp;&amp; once==True)
  {
    myservo1.writeMicroseconds(1300);delay(1000);
    myservo1.writeMicroseconds(1500);delay(1000);
    once = False;
  }
 else if(lightLevel&lt;800 &amp;&amp; once == False)
  {
    myservo1.writeMicroseconds(1700);delay(5000);
    myservo1.writeMicroseconds(1500);delay(1000);
    once = True;
   }
</code></pre>
",,29287889,51
23616883,2,23616751,2014-05-12T19:04:49.807,1,,3213868,,2014-05-12T19:14:28.257,2014-05-12T19:14:28.257,2,,"<p>You don't need a string of bits at all. Just do this:</p>

<pre><code>  int n = 0;  // unsigned might be better here
  for (i = 0; i &lt; 10; i++) {
    int bit = analogRead(A0) &amp; 1;
    putchar('0' + bit);
    n = (n &lt;&lt; 1) | bit;
    delay(50);
  }
  printf(""\n%d\n"", n);
</code></pre>
",,29310161,699
23617028,2,23616751,2014-05-12T19:12:52.500,1,,3629368,,2014-05-12T19:12:52.500,,0,,"<p>you can use strtol() function : </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, const char * argv[])
{
char *a = ""10100110"";

int b = (int) strtol(a, NULL, 2);

printf(""%d"", b); //prints 166

return 0;
}
</code></pre>
",,29312239,4274
23634960,2,23634291,2014-05-13T15:05:20.130,0,,1162141,,2014-05-13T15:05:20.130,,0,,"<p>You can really cut down printf if you remove the extraneous formats.<br>
Here is an example alternate fprintf (printf is just fprintf with 1 as first arg) that compiles down to 1/2kb including my conversion functions (it could be smaller if you remove more)</p>

<pre><code>void myfprintf_(int fd,int nargs, ...){ 
   va_list ap; va_start(ap, nargs); static char *s; const char *fmt; 
   fmt=va_arg(ap, char *); 
   int i=0,p; 
   char buf[80]; 
while (fmt[i]){ 
   p=0; 
   while (fmt[i]!='%' &amp;&amp; fmt[i]!=0) buf[p++]=fmt[i++]; 
   if (p != 0) write(fd,buf,p); 
   if (nargs--&gt;0){ 
      switch (fmt[++i]) { 
      case 's': s=va_arg(ap, char *); break; 
      case 'd': s=dtos(va_arg(ap, int)); break; 
      case 'x': s=dtox(va_arg(ap, int),'a'); break; 
      case 'X': s=dtox(va_arg(ap, int),'A' ); break; 
      case 'f': s=ftos(va_arg(ap, double)); break; 
      case 'c': buf[0]=(va_arg(ap, int));buf[1]=0;s=buf;break; 
      case '%': s=""%""; break; 
      default : s="""";break; 
      } write(fd,s,strlen(s)); 
   } 
i++; 
} 
va_end(ap); 
}
</code></pre>

<p>just comment out the formats you won't need and modify for your existing conversion functions - Also if you want it to be more compliant, make it an int function vs void and sum the returns of write for the return value ... though 99% of the time I don't use printf's return.</p>
",,29323602,152
23658720,2,23654582,2014-05-14T15:16:25.403,0,,2200999,,2014-05-14T15:16:25.403,,0,,"<p>In your header:</p>

<pre><code>class Wheel
{
public:
    class Stepper; // Forward declaration of embedded class

    Wheel();
    Stepper&amp; stepper() { return *_pStepper; }

private:

    Stepper* _pStepper;
};
</code></pre>

<p>In your implementation:</p>

<pre><code>class Wheel::Stepper
{
public:
    void accelerate() {}
};

Wheel::Wheel()
    : _pStepper( new Stepper() )
{
    stepper().accelerate();
}
</code></pre>
",,29340672,10429
23741840,2,23679215,2014-05-19T15:39:13.917,0,,3090301,,2014-05-19T15:39:13.917,,0,,"<p>I've tried to run your code with some dummy values in (see below), and it seems to run ok with the line commented out, ie innumber does contain values. However after working through it I kinda sense I'm not understanding your logic. Is this roughly the flow:</p>

<ol>
<li><p>check characters are in the serial receive buffer with Serial.available</p></li>
<li><p>If so, do one of three things:</p></li>
</ol>

<p>a) if the char isn't a ';' or ':' or the last char in the array, add it to the inVariable array, increment the index counter and add a zero to the array</p>

<p>b) if the char is a ':', do a couple of checks and read the next char from the buffer as a number, then do something with that, then run cambioVariabiliSeriale</p>

<p>c) if the char is a ';', run cambioVariabiliSeriale and reset some indexes.</p>

<p>(Also, I don't think you need check if inChar != ';' when you're  inside an if statement checked for inChar == ':')</p>

<p>Couldn't this be run as the following, so Serial.println(Serial.available()); can be commented out without effect?</p>

<pre><code>void checkSeriale(){
  while(Serial.available() &gt; 0){
    Serial.println(Serial.available());
    inChar = Serial.read();
    if(inChar != ':' &amp;&amp; index &lt; arraySize-1 &amp;&amp; inChar != ';'){
      inVariable[index] = inChar;
      index++;
      inVariable[index] = '\0';
    }

    else if(inChar == ':'){ 
      index = 0;
      while(Serial.available() &gt;0 &amp;&amp; index &lt; 10){
        inDigit = Serial.read() - '0';
        inNumber = inNumber * 10;
        inNumber = inNumber + inDigit; 
        index++; 
      }
      cambioVariabiliSeriale(inVariable);
    }

    else if if(inChar == ';'){
      cambioVariabiliSeriale(inVariable);
      inNumber=0;
      inChar='0';
      index=0;
    }
  }
}
</code></pre>

<p>I plugged a bunch of Serial Monitor prints into your original code to see what was going on - it's here if it's any use to you. Hope it helps!</p>

<pre><code>#define arraySize 32        
char inChar = '0';
char inVariable[arraySize];
byte index = 0;  
byte inDigit;     
int inNumber;
int i; //counter

String repeatstring;

void setup(){
  Serial.begin(9600);
}

void loop(){
  checkSeriale();
}

void checkSeriale(){
  while(Serial.available() &gt; 0){
    pr(""Start of 'checkSeriale' function"");
    pr(""Characters available in serial receive buffer: "" + String(Serial.available()));
    //Serial.println(Serial.available());
    inChar = Serial.read();
    pr(""Read a char into InChar: "" + String(inChar));
    pr(""Characters available after Serial.read(): "" + String(Serial.available()));
    if(inChar != ':' &amp;&amp; index &lt; arraySize-1 &amp;&amp; inChar != ';'){
      pr(""First 'if' statement (inChar not equal to colon)"");
      inVariable[index] = inChar;
      index++;
      inVariable[index] = '\0';
      for(i=0;i&lt;sizeof(inVariable);i++){
        Serial.print(String(inVariable[i]));
      }
    }
    else{
      pr(""Else statement for first 'if', inChar equals colon hence break"");
      break;
    }
  }
  if(inChar == ':'){ 
    pr(""Second 'if' statement (InChar is equal to colon)"");
    index = 0;
    pr(""Characters available in serial receive buffer: "" + String(Serial.available()));
    while(Serial.available() &gt;0 &amp;&amp; index &lt; 10 &amp;&amp; inChar != ';'){
      inDigit = Serial.read() - '0';
      pr(""Characters available after Serial.read(): "" + String(Serial.available()));
      pr(""inDigit: "" + String(inDigit));
      pr(""inNumber: "" + String(inNumber));
      inNumber = inNumber * 10;
      pr(""inNumber * 10: "" + String(inNumber));
      inNumber = inNumber + inDigit; 
      pr(""InNumber + inDigit : "" + String(inNumber));
      index++; 
    }
    cambioVariabiliSeriale(inVariable);
  }

  if(inChar == ';'){
    pr(""third 'if' statement (inChar is equal to semicolon)"");
    cambioVariabiliSeriale(inVariable);
    inNumber=0;
    inChar='0';
    index=0;
  }

}

void cambioVariabiliSeriale(char test[]){
}

//simple debug technique - use pr(""something""); in your code - askchipbug
void pr(String txt){
  if(repeatstring != txt){
    //if the debug text is different, print it
    Serial.println(txt); //prints the text and adds a newline
    delay(1000); //just pauses the scrolling text for 1 second, make bigger if you want a longer pause
    repeatstring = txt;
  }
}
</code></pre>
",,29341664,1026
23725309,2,23720330,2014-05-18T18:16:08.480,1,,168986,,2014-05-18T18:16:08.480,,0,,"<p>In <code>notmain()</code> you never call <code>clearBit()</code>, only <code>setBit()</code>.</p>

<p>The type:</p>

<pre><code>typedef unsigned int* UINT32_P;
</code></pre>

<p>should be declared:</p>

<pre><code>typedef volatile unsigned int* UINT32_P;
</code></pre>

<p>I would suggest defining your addresses as pointers rather than integers:</p>

<pre><code>#define GPFSEL1 ((UINT32_P)0x20200004)
#define GPFSEL2 ((UINT32_P)0x20200008)

#define GPSET0  ((UINT32_P)0x2020001C)
#define GPCLR0  ((UINT32_P)0x20200028)
</code></pre>

<p>With set/clearBit taking a UINT32_P rather than an unsigned int. Then you won't need numerous casts.</p>

<p>The <a href=""http://www.raspberrypi.org/documentation/hardware/raspberrypi/BCM2835-ARM-Peripherals.pdf"" rel=""nofollow"">BCM2835</a> includes timer hardware that you would do better to utilise than ""busy-loops"".</p>
",,29348094,640
23728470,2,23720330,2014-05-19T01:15:42.793,3,,1401213,,2014-05-19T01:15:42.793,,1,,"<p>The GPIO peripheral has separate registers for setting (<code>GPSET0</code>) and clearing (<code>GPCLR0</code>) output pins so that you don't have to do read-modify-write operations.  Writing to the GPSET register only sets the bits that are 1 while the bits that are 0 remain unchanged.  And writing to the GPCLR register only clears the bits that are 1 while the bits that are 0 remain unchanged.</p>

<p>You should not be using your <code>setBit()</code> and <code>clearBit()</code> routines for setting and clearing GPIO outputs.  Those routines might be appropriate for other peripherals that don't have separate registers for setting and clearing bits.  But the read-modify-write operation is not appropriate for <code>GPSET0</code> and <code>GPCLR0</code>.  In fact the read-modify-write operation may actually be the source of your problem.  It may be that <code>GPSET0</code> and <code>GPCLR0</code> always return 0x00000000 when you read them because it should never be necessary to read them.  (I'm not sure of that, I'm just speculating.)</p>

<p>Instead of calling <code>setBit()</code> and <code>clearBit()</code> to set the GPIO outputs you should just write to <code>GPSET0</code> or <code>GPCLR0</code> directly.  You don't need to read <code>GPSET0</code> or <code>GPCLR0</code> before writing to them.  Because when you write to them, only the bits you set to 1 will change, the bits that you write to 0 will remain unchanged.</p>

<p>Try something like this:</p>

<pre><code>// Set bits
*(UINT32_P)GPSET0 = (1 &lt;&lt; 18);
*(UINT32_P)GPSET0 = (1 &lt;&lt; 24);

// Clear bits
*(UINT32_P)GPCLR0 = (1 &lt;&lt; 18);
*(UINT32_P)GPCLR0 = (1 &lt;&lt; 24);
</code></pre>
",,29394934,842
23728024,2,23720504,2014-05-18T23:57:28.353,0,,3604824,,2014-05-19T00:13:27.977,2014-05-19T00:13:27.977,0,,"<p>Finally I figured out what was the problem:</p>

<p>Compiling with -v -Wl,-verbose and looking at the output showed that rpi_sysroot/usr/lib/arm-linux-gnueabihf/libc.so (a script) was trying to link with the wrong libraries. To fix just open libc.so and changed from this:</p>

<pre><code>   /* GNU ld script
      Use the shared library, but some functions are only in
      the static library, so try that secondarily.  */
   OUTPUT_FORMAT(elf32-littlearm)
   GROUP ( /lib/arm-linux-gnueabihf/libc.so.6 /usr/lib/arm-linux-gnueabihf/libc_nonshared.a
   AS_NEEDED ( /lib/arm-linux-gnueabihf/ld-linux-armhf.so.3 ) )
</code></pre>

<p>to this:</p>

<pre><code> /* GNU ld script
      Use the shared library, but some functions are only in
      the static library, so try that secondarily.  */
OUTPUT_FORMAT(elf32-littlearm)
GROUP ( ../../../lib/arm-linux-gnueabihf/libc.so.6 ../../../usr/lib/arm-linux-gnueabihf/libc_nonshared.a  AS_NEEDED ( ../../../lib/arm-linux-gnueabihf/ld-linux-armhf.so.3 ) )
</code></pre>

<p>so it points to the correct raspberry libraries</p>

<p>EDIT:
An easier solution is to remove rpi_sysroot/usr/lib/arm-linux-gnueabihf/libc.so and rpi_sysroot/usr/lib/arm-linux-gnueabihf/libc.a, making the linker fall back to the cross compiler version of libc.so</p>
",,29437068,926
23727661,2,23725365,2014-05-18T22:48:22.633,0,,3344003,,2014-05-18T22:48:22.633,,1,,"<p>Too long for the comment box… </p>

<p>Do you use guards for your include files?</p>

<pre><code>#ifndef SERVO_H
#define SERVO_H
 . . . . . 
#endif



#ifndef SERVOMOTORCONTROLLER_H
#define SERVOMOTORCONTROLLER_H
 . . . . . 
#endif
</code></pre>
",,29460115,2071
23735596,2,23729744,2014-05-19T10:38:10.973,0,,3090301,,2014-05-19T11:09:56.783,2014-05-19T11:09:56.783,2,,"<p>You have a couple of errors/misunderstandings in your code, so I've added a bit of simple debugging that works by opening Tools>Serial Monitor after you've downloaded your code. In your EdgeDec() function (function = Java method) you had if(EdgeDec = 1), but EdgeDec is just an int with the value of 7. What you wanted was to read the value of a pin numbered 7 - if(digitalRead(edgeDec1) == LOW).</p>

<p>also, I reversed your logic from HIGH (1) to LOW (0) because you hadn't tied down the digitalRead pins either LOW (using external resistors) or HIGH (using the Arduino's internal resistors) - read my comments in the code. Not sure what you were doing with the while(true) loop - maybe some further debugging? Anyway, hope it helps...</p>

<pre><code>int motor_forward = 10;
int motor_reverse = 9;
int motor2_forward = 13;
int motor2_reverse = 12;
int edgeDec1 = 7;
//int edgeDec2 = 6;
int indicator; // pulled this out of your loop - askchipbug

String repeatstring; //debugging variable, stops a debug string from repeating in Serial monitor when watching a loop - askchipbug

//the setup routine runs once when you press reset;
void setup(){
  Serial.begin(9600);           // set up Serial library at 9600 bps, using SerialMonitor to debug - askchipbug
  //initialize the digital pin as an output.
  pinMode(motor_forward, OUTPUT);
  pinMode(motor_reverse,OUTPUT);
  pinMode(motor2_forward,OUTPUT);
  pinMode(motor2_reverse,OUTPUT);
  pinMode(edgeDec1,INPUT_PULLUP); // set this high so it doesn't float about - askchipbug
  // you can use the internal 20k pullups with INPUT_PULLUP which means 1 = off, 0 = on
  // or you have to use external pulldown resistors to have 1 = on, 0 = off
  pr(""setup completed""); // askchipbug

}
//the loop routine runs over and over again forever
void loop(){
  randomSeed(analogRead(0)); // seeds the random() function with a different number each time the loop runs - askchipbug
  indicator = random(2);  
  pr(""indicator: "" + String(indicator)); // askchipbug
  pr(""5 second delay"");
  delay(5000);//5 second delay
  //loop to prevent another 5 second delay
  while(true){
    if (indicator == 0){ //you had this set as indicator = 0 - askchipbug
      pr(""indicator: "" + String(indicator)); // askchipbug
      for(int x = 0; x &lt; random(200); x++){
        Forward();
        EdgeDec();
        delay(10);
      }
    }
    else if ( indicator = 1){
      pr(""indicator: "" + String(indicator)); //askchipbug
      for(int x = 0; x &lt; random(200); x++){
        TurnLeft();
        EdgeDec();
        delay(10);
      }
    }
    else if ( indicator = 2){
      pr(""indicator: "" + String(indicator));// askchipbug
      for(int x = 0; x &lt; random(200); x++){
        TurnRight();
        EdgeDec();
        delay(10);
      }
    }
  }

}
void Forward(){
   //right motor
  pr(""forward""); //askchipbug
  digitalWrite(motor_forward,1);//terminal d1 will be high
  digitalWrite(motor_reverse,0);//terminal d2 will be low

  //left motor
  digitalWrite(motor2_forward,1);//terminal d1 will be high
  digitalWrite(motor2_reverse,0);//terminal d2 will be low
}
//going in reverse
void Reverse(){
  pr(""reverse""); //askchipbug
  //right motor
  digitalWrite(motor_forward,0);//terminal d1 will be low
  digitalWrite(motor_reverse,1);//terminal d2 will be high

  //left motor
  digitalWrite(motor2_forward,0);//terminal d1 will be low
  digitalWrite(motor2_reverse,1);//terminal d2 will be high
}
//rotating left
void TurnLeft(){
  pr(""turn left""); //askchipbug
  //right motor
  digitalWrite(motor_forward,0);//terminal d1 will be high
  digitalWrite(motor_reverse,1);//terminal d2 will be low

  //left motor
  digitalWrite(motor2_forward,1);//terminal d1 will be high
  digitalWrite(motor2_reverse,0);//terminal d2 will be low
}
void TurnRight(){
  pr(""turn right""); //askchipbug
  //right motor
  digitalWrite(motor_forward,1);//terminal d1 will be high
  digitalWrite(motor_reverse,0);//terminal d2 will be low

  //left motor
  digitalWrite(motor2_forward,0);//terminal d1 will be high
  digitalWrite(motor2_reverse,1);//terminal d2 will be low
}
void EdgeDec(){
  pr(""edge detector: "" + String(digitalRead(edgeDec1))); // read pin 7 - askchipbug
  if(digitalRead(edgeDec1) == LOW){ // remember we're using the internal pullups so LOW = on - askchipbug
    pr(""edge detected!""); // askchipbug
    Reverse();
    delay(700);
    TurnLeft();
    delay(1000);
    Forward();
  }
}

//simple debug technique - use pr(""something""); in your code - askchipbug
void pr(String txt){
  if(repeatstring != txt){
    //if the debug text is different, print it
    Serial.println(txt); //prints the text and adds a newline
    Serial.flush(); //waits for all the data to be printed
    delay(1000); //just pauses the scrolling text for 1 second, make bigger if you want a longer pause
    repeatstring = txt;
  }
}
</code></pre>
",,29476007,989
23816097,2,23757857,2014-05-22T20:04:03.887,2,,1710392,,2014-05-22T20:04:03.887,,0,,"<p>You add the terminating null character to <code>line_buffer</code>, but then you pass <code>rx_buffer</code> to the function <code>serial_prints</code>:</p>

<pre><code>line_buffer[rx_index] = 0; // Add terminating NUL
line_valid = 1; // flag new line valid for processing
serial_prints(USART2, rx_buffer);    
rx_index = 0; // Reset content pointer
</code></pre>

<p>This has the consequence that you will iterate past the length of <code>buffer</code> in the function <code>serial_prints</code> because <code>buffer</code> will not be null terminated:</p>

<pre><code>while(*buffer)
{
  USART_SendData(USARTx, *buffer++);
  while (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);
  delay_us(5);
}
</code></pre>

<p>On a side-node, you should also use interrupts to send your characters (TX Empty interrupts). Actively waiting in the interrupt service routine for UART characters to be sent will considerably slow-down your program.</p>
",,29539671,2326
23800403,2,23797480,2014-05-22T07:29:57.507,3,,3386109,,2014-05-22T07:29:57.507,,1,,"<p>The first array (with the last pattern commented out) uses <code>4 * 64 * 3 * sizeof(int)</code> bytes. Assuming that you have one of the 16-bit boards, that's <code>1536</code> bytes. If you uncomment the last pattern, then the array uses <code>5*64*3*2 = 1920</code> bytes. The other array (near the end of the question) also uses <code>1920</code> bytes. So if memory is the problem, then both arrays will have the same problem.</p>

<p>If you want to reduce the memory usage, then you'll need an alternative way to store the patterns.  One solution is to create an array of 2D arrays, where each 2D array is only as big as necessary.  For example, here are the five patterns declared as 2D arrays.  Note that the memory usage is only <code>(3+3+3+9+9) * 3 * 2 = 162</code> bytes. </p>

<pre><code>int pattern0[][3] =
{
    {HIGH, LOW, 500},
    {LOW, HIGH, 500},
    {0,      0,   0}
};

int pattern1[][3] =
{
    {HIGH, LOW, 250},
    {LOW, HIGH, 250},
    {0,      0,   0}
};

int pattern2[][3] =
{
    {HIGH, LOW, 125},
    {LOW, HIGH, 125},
    {0,      0,   0}
};

int pattern3[][3] =
{
    {HIGH, LOW, 250},
    {LOW, LOW, 250},
    {HIGH, LOW, 250},
    {LOW, LOW, 250},

    {LOW, HIGH, 250},
    {LOW, LOW, 250},
    {LOW, HIGH, 250},
    {LOW, LOW, 250},

    {0,     0,   0}
};

int pattern4[][3] =
{
    {HIGH, LOW, 125},
    {LOW, LOW, 125},
    {HIGH, LOW, 125},
    {LOW, LOW, 125},

    {LOW, HIGH, 125},
    {LOW, LOW, 125},
    {LOW, HIGH, 125},
    {LOW, LOW, 125},

    {0,     0,   0}
};
</code></pre>

<p>Since the 2D arrays are not all the same size, you need a way to identify the end of each array. This can be done with a <em><a href=""http://en.wikipedia.org/wiki/Sentinel_value"" rel=""nofollow"">sentinel value</a></em>. In the examples above, I've used a value of 0 in the third column as the sentinel.</p>

<p>Assuming that the arduino compiler is smart enough to understand arrays of pointers to arrays, you can group all of the 2D arrays into a single array as shown below. The resulting array can be used just like the 3D array that you already have.</p>

<pre><code>int (*patterns[])[3] =
{
    pattern0,
    pattern1,
    pattern2,
    pattern3,
    pattern4,
    NULL
};
</code></pre>

<p>Here's some test code that will prove/disprove that the array is setup properly, by printing out the patterns on the serial port.</p>

<pre><code>void loop()
{
    int i, j;

    for ( i = 0; patterns[i] != NULL; i++ )
    {
        Serial.print( ""Pattern "" );
        Serial.println( i + 1 );
        for ( j = 0; patterns[i][j][2] != 0; j++ )
        {
            if ( patterns[i][j][0] == HIGH )
                Serial.print( ""HIGH "" );
            else
                Serial.print( ""LOW  "" );

            if ( patterns[i][j][1] == HIGH )
                Serial.print( ""HIGH "" );
            else
                Serial.print( ""LOW  "" );

            Serial.println( patterns[i][j][2] );
        }
        Serial.println( """" );
        delay( 500 );
    }
}
</code></pre>
",,29585748,6242
23836713,2,23836565,2014-05-23T19:04:37.363,4,,3669613,,2014-05-24T09:34:27.760,2014-05-24T09:34:27.760,4,,"<p>Since Arduino actually provides a StringAdditonOperator <a href=""http://arduino.cc/en/Tutorial/StringAdditionOperator"" rel=""nofollow"">http://arduino.cc/en/Tutorial/StringAdditionOperator</a> you could use:</p>

<pre><code>for(int x = 1; x &lt;=5; x++) {
    String desiredString = ""Button""+x;
    Serial.println(desiredString);
}
</code></pre>

<p>Which will output:</p>

<pre><code>Button1
Button2
...
</code></pre>

<p>As far as I understand from the comments you want to do something like this:</p>

<pre><code>int buttonArray[3] = {7,15,3}; //Or on whatever pins your buttons are

// Setup code and anything else you need goes here

void loop() {
    for(int x = 0; x &lt;= 3; x++) {
         int buttonState = digitalRead(buttonArray[x]);
         digitalWrite(ledPin,buttonState);
    }
}
</code></pre>

<p>But be aware that this will change the state of the LED-Pin only to the last button state read.</p>
",,29589347,2949
23846475,2,23836565,2014-05-24T15:01:58.780,0,,3667196,,2014-05-24T15:01:58.780,,0,,"<p>Got it. This works great. Thanks.</p>

<pre><code>const int myButton1 = 7;
const int myButton2 = 15;
const int myButton3 = 3;
const int myButton4 = 27;
const int myButton5 = 22;
const int myButton6 = 18;
const int myButton7 = 23;
const int myButton8 = 11;

const int myOutput1 = 8;
const int myOutput2 = 16;
const int myOutput3 = 4;
const int myOutput4 = 28;
const int myOutput5 = 24;
const int myOutput6 = 19;
const int myOutput7 = 25;
const int myOutput8 = 12;
</code></pre>

<p>Becomes </p>

<pre><code>int myButton[8]={7,15,3,27,22,18,23,11};
int myOutput[8]={8,16,4,28,24,19,25,12};
</code></pre>

<p>Then add this to the setup</p>

<pre><code> for (int i=0;i&lt;8;i++) {
  pinMode(myButton[i], INPUT);
  pinMode(myOutput[i], OUTPUT);
 }
</code></pre>
",,29599484,2694
23840643,2,23840550,2014-05-24T02:07:10.747,2,,3260688,,2014-05-24T02:27:10.657,2014-05-24T02:27:10.657,7,,"<p>Maybe, that is what you are looking for.</p>

<p><a href=""http://linux.die.net/man/3/popen"" rel=""nofollow"">http://linux.die.net/man/3/popen</a></p>

<p>That is an exmaple:</p>

<pre><code>/* First open the command for reading. */
FILE * file = popen(""/bin/ls /etc/"", ""r"");

char output[100];
/* Read the output line by line */
while (fgets(output, 100, file) != NULL) 
{
    printf(""%s"", output); /* show the result */
}

/* close */
pclose(file);
</code></pre>

<p>Good luck!</p>
",,29602698,35695
23840817,2,23840550,2014-05-24T02:43:38.210,3,,2682142,,2014-05-24T14:43:06.730,2014-05-24T14:43:06.730,2,,"<p>I think the key classes are <a href=""https://qt-project.org/doc/qt-5/qprocess.html"" rel=""nofollow"">QProcess</a> and <a href=""http://qt-project.org/doc/qt-5/qlabel.html#text-prop"" rel=""nofollow"">QLabel</a> or some similar GUI widget here as follows:</p>

<pre><code>QProcess avrDudeProcess;
avrDudeProcess.setProcessChannelMode(QProcess::MergedChannels);
avrDudeProcess.start(""avrdude"", optionList);
if (!avrDudeProcess.waitForStarted())
    return false;

if (!avrDudeProcess.waitForFinished())
    return false;

QByteArray output = avrDudeProcess.readAll();
myLabel.setText(output);
</code></pre>
",,29603977,59
23849022,2,23848934,2014-05-24T19:51:19.117,0,,650884,,2014-05-24T19:51:19.117,,0,,"<p>To cite WhozCraig: That isn't how you convert a char* to an int</p>

<p>A simple cast doesn't do because a char is 1 byte and an int is 4 byte, so the remaining 3 bytes can contain any garbage leading to unpredictable results:</p>

<pre><code>char s[1] = {'2'};

cout &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; (int)s &lt;&lt; endl;
cout &lt;&lt; atoi(s) &lt;&lt; endl;
</code></pre>

<p>leads on my machine to</p>

<pre><code>2
-5760069
2
</code></pre>
",,29647887,630
23875869,2,23874911,2014-05-26T18:27:33.903,5,,17034,,2014-05-26T18:27:33.903,,0,,"<p>The while loop and the delay() call don't help.  Say that the PC sends the START command to enable temperature sampling and STOP to tell it to stop updating them.  You'll need a <em>bool</em> variable to indicate state.  Something like this:</p>

<pre><code>bool sendTemperatures;
String readString;

void executeCommand(String cmd)
{
    if (cmd == ""START"") sendTemperatures = true;
    else if (cmd == ""STOP"") sendTemperatures = false;
    // etc...
    else Serial.println(""Bad command"");
}

void checkSerial()
{
    if (!Serial.available()) return;
    char c = Serial.read();
    if (c == '\n') {
        executeCommand(readString);
        readString = """";
    }
    else readString += c;
}

void sendSensorData() 
{
    // etc..
}


void loop() 
{
    checkSerial();
    if (sendTemperatures) sendSensorData();
}
</code></pre>
",,29648411,317
36970852,2,23874911,2016-05-01T19:17:03.247,0,,6026297,,2016-05-01T19:17:03.247,,0,,"<pre><code>String recievedData;  //readString

void setup() {
  Serial.begin(9600);
}

 void loop() {

  if (Serial.available() &gt; 0) {
   recievedData = Serial.readString();//read full recieved data 
   Serial.println(recievedData);

    for (int i = 0; i &lt; 20 &amp;&amp; Serial.available() &lt;= 0; i++) {
     //Send the temperature, or send a simple message
    }
   }
 }
</code></pre>
",,29662007,480
23875320,2,23875135,2014-05-26T17:44:01.660,0,,2587816,,2014-05-26T18:05:15.927,2014-05-26T18:05:15.927,1,,"<p>You need to convert the string input into an int.  Using a function.  And you need to read in the characters into an array, no just an int.  For example, perhaps:</p>

<pre><code>char var[10];
int i = 0; // index
while (Serial.Available() &gt; 0){
    char readval = Serial.Read();
    var[i++] = readval;
}
var[i] = 0;  // null terminate string
int int_of_var = atoi(var);
</code></pre>

<p>Note that although 5320 can fit into a single integer, the characters '5', '3', '2', '0' require 4 bytes to hold them (plus a byte for null termination).</p>
",,29676802,700
23981059,2,23978691,2014-06-01T14:47:46.113,2,,67455,,2014-06-01T14:47:46.113,,0,,"<p>That might work decently depending on your requirements. Something to consider will be if there are any timing variations at all while looping through the data such as flash read times varying, cache stuff, etc you will run into a problem figuring out where bytes start and stop. You might want to take a look at the 1-Wire protocol:</p>

<p><a href=""http://en.wikipedia.org/wiki/1-Wire"" rel=""nofollow"">http://en.wikipedia.org/wiki/1-Wire</a></p>

<p>You don't have to implement it to spec or anything, just take a look at it for an idea. If you implement something like that your logic is just as simple:</p>

<pre><code>while(word by word memory copy hasn't finished)
  ...
  register = value;
  temp_value = value AND 0x1;
  one_wire_send(temp_value);
  value = value &gt;&gt; 1;
  ...
</code></pre>
",,29714733,8677
23987796,2,23986447,2014-06-02T05:26:14.373,1,,3418066,,2014-06-03T01:56:14.907,2014-06-03T01:56:14.907,4,,"<p>My approach to these sort of communications is to define a protocol that includes start and stop characters (say 0x01 and 0x03) and then build a state machine that processes each incoming byte. </p>

<p>The reason for this is it helps correct for out-of-sequence bytes and communication errors.  You can ignore data until you get a 0x01 and the command doesn't end until you get a 0x03.  If you get a 0x03 before you expect it then you can discard the invalid packet.</p>

<p>One issue you have with your current approach and this technique is that you are sending 8 bit data for the RGB command - this can conflict with your start/end bytes.  It won't have much impact to encode your data as 2 digit hex, so you can have a protocol which looks something like</p>

<ul>
<li>0x01 - Start of packet</li>
<li>1 byte command b=Blink, f=Fade, c=set color</li>
<li>6 bytes arguments.  For command c this would be three pairs of hex characters for rgb.  For b &amp; f it could be 2 characters of blink/fade rate with the other 4 bytes being 0000 for placeholder</li>
<li>0x03 - End of packet</li>
</ul>

<p>Then you can build a state machine -</p>

<ol>
<li>Waiting for 0x01.  Once you get it move to state 2    </li>
<li>Waiting  for a valid command byte.  If you get a valid one move to state 3. 
If you get 0x01 move back to state 2.  If you get any other byte
move to state 1   </li>
<li>Waiting for 6 hex digits. If you get 0x01
stay in state 2.  If you get anything other than 0-9 a-f move
back to state 1    </li>
<li>Waiting for 0x03.  If you get it then process
complete command and return to state 1.  If you get 0x01 move back
to state 2.  If you get anything else move to state 1</li>
</ol>

<p>This won't compile as I don't have an Arduino in front of me, but you would use something like this</p>

<pre><code>int state;   //  Initialise this to 1 
char command;
string hexstring;

void RFduinoBLE_onReceive(char *data, int len) {

    for (int i=0;i&lt;len;i++) {
        stateMachine(data[i]);
    }
}

stateMachine(char data) {


    switch (state) {
       case 1:
          if (data == 1) {
              state=2;
          }
          break;
       case 2:
          if (data=='b' || data== 'f' || data == 'c') {  // If we received a valid command
             command=data;                               // store it
             hexstring="""";                               // prepare to receive a hex string
             state=3;
          } else if (data != 1) {    //Stay in state 2 if we received another 0x01
             state =1;
          }
          break;
       case 3:
          if ((data &gt;='a' &amp;&amp; data &lt;='z') || (data &gt;='0' &amp;&amp; data &lt;='9')) {
              hexstring=hexstring+data;     // if we received a valid hex byte, add it to the end of the string
              if (length(hexstring) == 6) {  // If we have received 6 characters (24 bits) move to state 4
                  state=4;
              }
          } else if (data == 1) {            // If we received another 0x01 back to state 2
             state =2;
          } else {
             state=1;                        // Anything else is invalid - back to look for 0x01
          }
          break;
     case 4:
         if (data == 3)                      // 0x03=valid terminator
         {
           processCommand(command,hexstring);  // We have a valid command message - process it
           state=1;
         } else if (data==1) {               // 0x01= start of new message, back to state 2
           state=2;
         } else {
           state=1;                          // anything else, back to look for 0x01
         }
         break;
     }
}
</code></pre>
",,29716979,458
24091894,2,24087030,2014-06-06T23:06:47.117,1,,1798593,,2014-06-06T23:13:37.177,2014-06-06T23:13:37.177,0,,"<p>This is inspired by @Ben's comments on the question. It appears that <code>Serial.println((unsigned char)b, BIN);</code> gets the desired output.</p>

<p>Here is my complete sketch:</p>

<pre><code>void setup() {
  Serial.begin(9600);
  // Confirm observations from question
  char a = 0x70;
  char b = 0x80;

  long aPrint = Serial.println(a, BIN); // Should print  1110000
  long bPrint = Serial.println(b, BIN); // Should print 10000000

  // Output println results (Ben comment #1)
  Serial.print(""aPrint: "");
  Serial.println(aPrint);
  Serial.print(""bPrint: "");
  Serial.println(bPrint);

  // Explicit cast from char
  Serial.print(""(int)b: "");
  Serial.println((int)b);

  // Via unsigned char
  Serial.print(""(unsigned char)b: "");
  Serial.println((unsigned char)b);
  // And print in binary
  Serial.println((unsigned char)b, BIN);
}

void loop() {
}
</code></pre>

<p>Output:</p>

<pre><code>1110000
11111111111111111111111110000000
aPrint: 9
bPrint: 34
(int)b: -128
(unsigned char)b: 128
10000000
</code></pre>
",,29768115,407
24900588,2,24130212,2014-07-23T01:45:29.133,0,,30997,,2014-07-23T01:45:29.133,,1,,"<p>If you're actually after an average, this won't work for you, but this method requires no extra memory to manage a buffer of samples:</p>

<pre><code>void loop() {
  static float mean = analogRead(A0);
  int newInput = analogRead(A0);
  mean = (mean * 0.95) + (newInput * 0.05);
  Serial.println(mean);
}
</code></pre>

<p>You can adjust the constants (0.95 and 0.05) to whatever you like, as long as they add up to 1. The smaller the multiplier of <code>mean</code>, the faster <code>mean</code> will track new values.</p>

<p>If you don't like the overhead of floating point math, the same idea works quite well in fixed point.</p>
",,29806609,173
24163510,2,24141486,2014-06-11T12:55:22.883,2,,264683,,2014-06-11T21:41:46.890,2014-06-11T21:41:46.890,0,,"<p>I added the following to CMakeLists.txt and then few more changes below and got it working!</p>

<pre><code>include($ENV{HOME}/raspberrypi/rootfs/usr/share/cmake-2.8/Modules/FindPkgConfig.cmake)
set(CMAKE_PREFIX_PATH $ENV{HOME}/raspberrypi/rootfs/)
set(SYSROOT $ENV{HOME}/raspberrypi/rootfs/)
set (PKG_CONFIG_SYSROOT_DIR ${SYSROOT})
set(PKG_CONFIG_PATH ${SYSROOT}/usr/lib/pkgconfig:${SYSROOT}/usr/local/lib/pkgconfig:${SYSROOT}/usr/lib/arm-linux-gnueabihf/pkgconfig:${SYSROOT}/usr/share/pkgconfig)
#Change 1 to 0 to disable logging
add_definitions(-DENABLE_LOG=1)
find_program(PKG_CONFIG_EXECUTABLE NAMES pkg-config PATHS /usr/bin DOC ""pkg-config executable"" NO_CMAKE_FIND_ROOT_PATH)
set (CMAKE_CXX_FLAGS ""-W -O3 -g -Wall -std=c++0x -rdynamic  -D_TRACE ${CMAKE_CXX_FLAGS}""  CACHE STRING """" FORCE)
#rdynamic is for stack unwinding on crash
set(CMAKE_PREFIX_PATH $ENV{HOME}/raspberrypi/rootfs/)
set(CMAKE_LIBRARY_PATH $ENV{HOME}/raspberrypi/rootfs/lib:$ENV{HOME}/raspberrypi/rootfs/usr/lib:$ENV{HOME}/raspberrypi/rootfs/usr/local/lib)
set(CMAKE_MODULE_PATH $ENV{HOME}/raspberrypi/rootfs/usr/share/cmake-2.8/Modules)

include_directories(SYSTEM
$ENV{HOME}/raspberrypi/rootfs/usr/include/arm-linux-gnueabihf
$ENV{HOME}/raspberrypi/rootfs/usr/include
$ENV{HOME}/raspberrypi/rootfs/usr/local/include
)

add_definitions(
-march=armv6zk 
-mfpu=vfp 
-mfloat-abi=hard
)

link_directories(

$ENV{HOME}/raspberrypi/rootfs/lib/arm-linux-gnueabihf
$ENV{HOME}/raspberrypi/rootfs/lib
$ENV{HOME}/raspberrypi/rootfs/usr/lib/arm-linux-gnueabihf
$ENV{HOME}/raspberrypi/rootfs/usr/lib
$ENV{HOME}/raspberrypi/rootfs/usr/local/lib
)   

set_target_properties(${TARGET} PROPERTIES COMPILE_FLAGS ${CMAKE_CXX_FLAGS})
</code></pre>

<p>Then did the following</p>

<pre><code>sudo vim /home/test/raspberrypi/rootfs/usr/lib/arm-linux-gnueabihf/libpthread.so
</code></pre>

<p>edited</p>

<pre><code>OUTPUT_FORMAT(elf32-littlearm)
GROUP ( /lib/arm-linux-gnueabihf/libpthread.so.0 /usr/lib/arm-linux-gnueabihf/libpthread_nonshared.a )
</code></pre>

<p>to</p>

<pre><code>OUTPUT_FORMAT(elf32-littlearm)
GROUP ( libpthread.so.0 libpthread_nonshared.a )
</code></pre>

<p>similarly,</p>

<pre><code>sudo vim /home/test/raspberrypi/rootfs/usr/lib/arm-linux-gnueabihf/libc.so
</code></pre>

<p>edited</p>

<pre><code>OUTPUT_FORMAT(elf32-littlearm)
GROUP ( /lib/arm-linux-gnueabihf/libc.so.6 /usr/lib/arm-linux-gnueabihf/libc_nonshared.a  AS_NEEDED ( /lib/arm-linux-gnueabihf/ld-linux-armhf.so.3 ) ) 
</code></pre>

<p>to</p>

<pre><code>OUTPUT_FORMAT(elf32-littlearm)
GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux-armhf.so.3 ) )
</code></pre>

<p>Lastly, I added the <code>-lpcre</code> library to my <code>COMMON_LIBS</code></p>

<p>Compile was successful. I then booted the raspberrypi via QEMU and used scp <code>scp daemon pi@&lt;ip address&gt;:~</code> to transfer the resulting binary to PI emulator and ran it. Tadaa!!! it works fine!</p>
",,29818894,983
24153088,2,24152743,2014-06-11T00:52:59.687,-2,,3626338,,2014-06-11T01:10:16.713,2014-06-11T01:10:16.713,5,,"<p>Updated below.</p>

<p><code>Serial.print()</code> is a function that ""returns the number of bytes written"", but you have no input to that function and therefore there is a compile-time error.</p>

<pre><code>const int rightCW = 6, leftCW = 11, rightCCW = 5, leftCCW = 10;

void setup()
{
  Serial.begin(9600);
  initMotors();

}

void loop()
{
  delay(10);
  analogWrite(rightCW,255);     
}

void initMotors()
{
  //initialize motors
  pinMode(rightCW, OUTPUT);
  pinMode(leftCW, OUTPUT);
  pinMode(rightCCW, OUTPUT);
  pinMode(leftCCW, OUTPUT);
}
</code></pre>

<p>Assuming you have correctly wired the motors, you can edit right, left CW and CCW's (clockwise and counterclockwise) pins to whatever your control pins are. This program will simply test whether or not you can get one motor working. </p>

<p>Take this for the H-bridge diagram, in case: <a href=""http://9m.no"" rel=""nofollow"">http://9m.no</a>/쵉쀨
Corners go to the power rail, inner two on each side go to ground, 1A, 2A go to control pins on Arduino, 1Y, 2Y go to motor's two wires. The same applies for any other motor you might have.</p>

<p><strong>UPDATE (see comments below):</strong></p>

<p>You will want something like</p>

<pre><code>String input = """";
String result = """";
while (Serial.available() &gt; 0)
{
  char temp = Serial.read();
  if (temp == '\n')
  {
    result = input;
    input = """";
    break; 
  }
  else
  {
    input += temp; 
  }
}
</code></pre>

<p>Serial.read() is the function that reads in one byte at a time.</p>
",,29834066,2302
24175527,2,24175481,2014-06-12T02:21:26.353,1,,718379,,2014-06-12T02:29:24.600,2014-06-12T02:29:24.600,2,,"<p>Assume <code>inData</code>, a <code>char</code> array, is a C-style, <code>'\0'</code> terminated string. Then what you should do is calling <code>strcmp()</code> instead of comparing the 1<sup>st</sup> character only.</p>

<pre><code>#include &lt;cstring&gt;

if (std::strcmp(inData, ""1"") == 0) {
}
else if (std::strcmp(inData, ""2"") == 0) {
}
//...
else if (std::strcmp(inData, ""10"") == 0) {
}
</code></pre>

<p>Please be aware of the difference between <code>''</code> quoted character literal and <code>""""</code> quoted string literal.</p>
",,29837892,37566
24175540,2,24175481,2014-06-12T02:24:00.317,0,,67566,,2014-06-12T02:48:39.303,2014-06-12T02:48:39.303,7,,"<p>I see a couple of issues.</p>

<p>First, use the <code>if..then..else</code> construct or a switch for the several <code>if..then</code> statements.</p>

<p>And, when you do a comparison to a char <code>10</code> is two char values so a simple == won't work.</p>

<p>You could convert it to an integer first, using <code>atoi</code> and then do a comparison, or you can look at <code>if (inData[0] == '1' &amp;&amp; inData[1] == '0')</code> would do what you want.</p>

<p><strong>UPDATE:</strong></p>

<p>I would ensure that each part of inData is set to zero first, not '0'.</p>

<p>Then use a switch, such as something like this:</p>

<pre><code>switch(inData[0]) {
  case '1':
    switch(inData[1]) {
       case 0:
         // This would be '1'
         break;
       case '0':
         // This will be 10
         break;
    }
    break;
  case '2':
     break;
}
</code></pre>

<p>I haven't tested this code, just use as an example.</p>
",,29871968,1004
24175630,2,24175481,2014-06-12T02:36:37.290,0,,14065,,2014-06-12T02:36:37.290,,5,,"<p>You should be using <code>std::string</code> if this is C++</p>

<pre><code>std::string inData; // Allocate some space for the string

// Replace this:
// inData[index] = c;
// index++;
// inData[index] = '\0';   

// with
inData += c;

if (inData == ""10"") {   // Test for a specific string.
</code></pre>
",,29873217,46
25193462,2,24194961,2014-08-07T22:45:26.393,41,,3102264,,2015-03-24T18:03:40.190,2015-03-24T18:03:40.190,0,,"<p>Depending on the libc release it could be needed to set both SO_REUSEADDR and SO_REUSEPORT socket options as explained in <a href=""http://man7.org/linux/man-pages/man7/socket.7.html"">socket(7)</a> documentation :</p>

<blockquote>
<pre><code>   SO_REUSEPORT (since Linux 3.9)
          Permits multiple AF_INET or AF_INET6 sockets to be bound to an
          identical socket address.  This option must be set on each
          socket (including the first socket) prior to calling bind(2)
          on the socket.  To prevent port hijacking, all of the
          processes binding to the same address must have the same
          effective UID.  This option can be employed with both TCP and
          UDP sockets.
</code></pre>
</blockquote>

<p>As this socket option appears with kernel 3.9 and raspberry use 3.12.x, it will be needed to set SO_REUSEPORT.</p>

<p>You can set theses two options before calling bind like this :</p>

<pre><code>    int reuse = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;reuse, sizeof(reuse)) &lt; 0)
        perror(""setsockopt(SO_REUSEADDR) failed"");

#ifdef SO_REUSEPORT
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, (const char*)&amp;reuse, sizeof(reuse)) &lt; 0) 
        perror(""setsockopt(SO_REUSEPORT) failed"");
#endif
</code></pre>
",,29888109,74
51817901,2,24194961,2018-08-13T08:13:30.007,5,,391668,,2018-08-13T08:13:30.007,,2,,"<p>I think you should use SO_LINGER options (with timeout 0). 
In this case, you connection will close immediately after closing your program; and next restart will be able to bind again.</p>

<p>example:</p>

<pre><code>linger lin;
lin.l_onoff = 0;
lin.l_linger = 0;
setsockopt(fd, SOL_SOCKET, SO_LINGER, (const char *)&amp;lin, sizeof(int));
</code></pre>

<p>see definition: <a href=""http://man7.org/linux/man-pages/man7/socket.7.html"" rel=""noreferrer"">http://man7.org/linux/man-pages/man7/socket.7.html</a></p>

<pre><code>SO_LINGER
          Sets or gets the SO_LINGER option.  The argument is a linger
          structure.

              struct linger {
                  int l_onoff;    /* linger active */
                  int l_linger;   /* how many seconds to linger for */
              };

          When enabled, a close(2) or shutdown(2) will not return until
          all queued messages for the socket have been successfully sent
          or the linger timeout has been reached.  Otherwise, the call
          returns immediately and the closing is done in the background.
          When the socket is closed as part of exit(2), it always
          lingers in the background.
</code></pre>

<p>More about SO_LINGER: <a href=""https://stackoverflow.com/questions/3757289/tcp-option-so-linger-zero-when-its-required"">TCP option SO_LINGER (zero) - when it&#39;s required</a></p>
",,29904478,135
24205581,2,24204876,2014-06-13T12:41:50.557,-1,,767368,,2014-06-13T12:41:50.557,,5,,"<p>The folowing code waits for a response from an arduino. If the response contains ""Done"" it returns 1. If it didn't find it within the given timeout, it returns -1.</p>

<p>It should not prove that hard to change this code to fit your needs.</p>

<pre><code>int Serial::waitForResponse()
{
    const int buffSize = 1024;
    char bufferChar[buffSize] = {'\0'};
    int counter = 0;
    std::string wholeAnswer = """";

    int noDataTime = 0;

    while(wholeAnswer.find(""Done"") == std::string::npos) //Done string was found.
    {
        if(noDataTime &gt; 10000)
        {
            std::cout &lt;&lt; ""timeout"" &lt;&lt; std::endl;
            return -1;
        }
        counter = read(this-&gt;hSerial, bufferChar, buffSize - 1);

        if(counter &gt; 0)
        {
            noDataTime = 0;
            bufferChar[counter] = '\0';
            wholeAnswer += std::string(bufferChar);
        } else
        {
            noDataTime++;
            usleep(1000);
        }
    }
    if(!wholeAnswer.empty())
    {
        return 1;
    } else
    {
        return -1;
    }
</code></pre>
",,29932003,31340
25124891,2,24214583,2014-08-04T18:08:37.330,0,,3317006,,2014-08-04T18:08:37.330,,0,,"<p>In your Arduino sketch; I think it's not right to do this :<br>
<code>Serial.write(Serial.read());</code><br></p>

<p>See this from Arduino Forum : <a href=""http://forum.arduino.cc/index.php/topic,45629.0.html"" rel=""nofollow"">Help with Serial.Read() getting string.</a>
<br>
This sketch may help you :<br></p>

<pre><code>char inData[20]; // Allocate some space for the string
char inChar; // Where to store the character read
byte index = 0; // Index into array; where to store the character

void loop()
{
   while(Serial.available() &gt; 0) // Don't read unless
                                                  // there you know there is data
   {
       if(index &lt; 19) // One less than the size of the array
       {
           inChar = Serial.read(); // Read a character
           inData[index] = inChar; // Store it
           index++; // Increment where to write next
           inData[index] = '\0'; // Null terminate the string
       }
   }
   // Now do something with the string (but not using ==)
    for(int i = 0; i &lt; index ; i++){
        Serial.print(inData[i]);
    }
}
</code></pre>

<p><br>
You have to buffer the data before writing it into Serial Interface .</p>
",,29965822,181
24229281,2,24228095,2014-06-15T11:46:57.387,1,,1641102,,2014-06-15T11:46:57.387,,0,,"<p>Have you looked at the 'Fade' example program?</p>

<pre><code>/*
 Fade

 This example shows how to fade an LED on pin 9
 using the analogWrite() function.

 This example code is in the public domain.
 */

int led = 9;           // the pin that the LED is attached to
int brightness = 0;    // how bright the LED is
int fadeAmount = 5;    // how many points to fade the LED by

// the setup routine runs once when you press reset:
void setup()  { 
  // declare pin 9 to be an output:
  pinMode(led, OUTPUT);
} 

// the loop routine runs over and over again forever:
void loop()  { 
  // set the brightness of pin 9:
  analogWrite(led, brightness);    

  // change the brightness for next time through the loop:
  brightness = brightness + fadeAmount;

  // reverse the direction of the fading at the ends of the fade: 
  if (brightness == 0 || brightness == 255) {
    fadeAmount = -fadeAmount ; 
  }     
  // wait for 30 milliseconds to see the dimming effect    
  delay(30);                            
}
</code></pre>

<p>See <a href=""http://arduino.cc/en/Tutorial/Fade"" rel=""nofollow"">http://arduino.cc/en/Tutorial/Fade</a></p>
",,29983943,12460
24252828,2,24252372,2014-06-16T21:51:21.747,0,,2852165,,2014-06-18T13:57:50.603,2014-06-18T13:57:50.603,1,,"<p>You can use <code>pthread_mutex_t</code> init at the constructor, lock for wait, unlock for signal, destroy at the destructor. </p>

<p>like this:</p>

<pre><code>class Mutex{
  pthread_mutex_t m; 
public:
  Mutex(){
    pthread_mutex_init(&amp;m,NULL); 
  }
  ~Mutex(){
    pthread_mutex_destroy(&amp;m);  
  }
  void wait() {
    pthread_mutex_lock(&amp;m);
  }
  void signal() {
    pthread_mutex_unlock(&amp;m);
  }
} ;
</code></pre>

<p>You also should check the return value of the <code>pthread_mutex</code> functions: 0 for success, non zero means error.</p>
",,30024908,1173
24273173,2,24254130,2014-06-17T20:59:03.743,0,,121540,,2014-06-17T20:59:03.743,,1,,"<p>Pass the values you want the function to output by reference or by pointer.  </p>

<pre><code>void Wrong(int a) {
  a = 10;
}

void Right(int&amp; a) {
  a = 20;
}

void Right(int* pA) {
  *pA = 30;
}

int a = 0;
Wrong(a);  printf(""%d "", a);
Right(a);  printf(""%d "", a);
Right(&amp;a);  printf(""%d\n"", a);
</code></pre>

<p>output will be 0 20 30</p>
",,30038172,1029
24284861,2,24283277,2014-06-18T11:52:14.447,1,,584518,,2014-06-18T11:52:14.447,,4,,"<p>Try to solve the actual problem. What you need are multiple callback functions, that are defined in various modules, that aren't in the slightest related to each other. </p>

<p>What you have done though, is to place a global variable in a header file, which is accessible by every module including that header. This introduces a tight coupling between all such files, even though they are not related to each other. Furthermore, it seems only the callback handler .c function needs to actually call the functions, yet they are exposed to the whole program.</p>

<p>So the actual problem here is the program design and nothing else. </p>

<p>And there is actually no apparent reason why you need to allocate this array at compile time. The only sane reason would be to save RAM, but that's of course is a valid reason for an embedded system. In which case the array should be declared as <code>const</code> and initialized at compile time.</p>

<p>You can keep something similar to your design if storing the array as read-write objects. Or if the array must be a read-only one for the purpose of saving RAM, you must do a drastic re-design.</p>

<p>I'll give both versions, consider which one is most suitable for your case:</p>

<p><strong>RAM-based read/write array</strong></p>

<p>(Advantage: flexible, can be changed in runtime. Disadvantages: RAM consumption. Slight over-head code for initialization. RAM is more exposed to bugs than flash.)</p>

<ul>
<li>Let the callback.h and callback.c from a module which is only concerned with the handling of the callback functions. This module is responsible for how the callbacks are allocated and when they are executed.</li>
<li>In callback.h define a type for the callback functions. This should be a function pointer type just as you have done. But remove the variable declaration from the .h file.</li>
<li><p>In callback.c, declare the callback array of functions as </p>

<pre><code> static callback_t callbacks [LARGE_ENOUGH_FOR_WORST_CASE];
</code></pre></li>
<li><p>There is no way you can avoid ""LARGE_ENOUGH_FOR_WORST_CASE"". You are on an embedded system with limited RAM, so you have to actually consider what the worst-case scenario is and reserve enough memory for that, no more, no less. On a microcontroller embedded system, there are no such things as ""usually needed"" nor ""lets save some RAM for other processes"". Your MCU either has enough memory to cover the worst case scenario, or it does not, in which case no amount of clever allocations will save you.</p></li>
<li><p>In callback.c, declare a size variable that keeps track of how much of the callback array that has been initialized. <code>static size_t callback_size;</code>.</p></li>
<li>Write an init function <code>void callback_init(void)</code> which initializes the callback module. The prototype should be in the .h file and the caller is responsible for executing it once, at program startup.</li>
<li>Inside the init function, set <code>callback_size</code> to 0. The reason I propose to do this in runtime is because you have an embedded system where a <code>.bss</code> segment may not be present or even undesired. You might not even have a copy-down code that initializes all static variables to zero. Such behavior is non-conformant with the C standard but very common in embedded systems. Therefore, never write code which relies on static variables getting automatically initialized to zero.</li>
<li>Write a function <code>void callback_add (callback_t* callback);</code>. Every module that includes your callback module will call this function to add their specific callback functions to the list.</li>
<li>Keep your <code>do_callbacks</code> function as it is (though as a minor remark, consider renaming to callback_traverse, callback_run or similar).</li>
</ul>

<p><strong>Flash-based read-only array</strong></p>

<p>(Advantages: saves RAM, true read-only memory safe from memory corruption bugs. Disadvantages: less flexible, depends on every module used in the project, possibly slightly slower access because it's in flash.)</p>

<p>In this case, you'll have to turn the whole program upside-down. By the nature of compile-time solutions, it will be a whole lot more ""hard-coded"". </p>

<p>Instead of having multiple unrelated modules including a callback handler module, you'll have to make the callback handler module include everything else. The individual modules still don't know when a callback will get executed or where it is allocated. They just declare one or several functions as callbacks. The callback module is then responsible for adding every such callback function to its array at compile-time.</p>

<pre><code>// callback.c

#include ""timer_module.h""
#include ""spi_module.h""
...

static const callback_t CALLBACKS [] = 
{
  &amp;timer_callback1,
  &amp;timer_callback2,
  &amp;spi_callback,
  ...
};
</code></pre>

<p>The advantage of this is that you'll automatically get the worst case scenario handed to you by your own program. The size of the array is now known at compile time, it is simply <code>sizeof(CALLBACKS)/sizeof(callback_t)</code>.</p>

<p>Of course this isn't nearly as elegant as the generic callback module. You get a tight coupling from the callback module to every other module in the project, but not the other way around. Essentially, the callback.c is a ""main()"".</p>

<p>You can still use a function pointer typedef in callback.h though, but it is no longer actually needed: the individual modules must ensure that they have their callback functions written in the desired format anyhow, with or without such a type present.</p>
",,30082094,97
32468916,2,24283277,2015-09-08T23:51:21.813,0,,999530,,2015-09-08T23:51:21.813,,0,,"<p>I too am faced with a similar problem: </p>

<blockquote>
  <p>...need are multiple callback functions, that are defined in various
  modules, that aren't in the slightest related to each other.</p>
</blockquote>

<p>Mine is C, on Atmel XMega processor. You mentioned that you are using <code>GCC</code>. The following doesn't solve your problem, it is a variant on the above #1 solution. It exploits the <code>__attribute__((weak))</code> directive.</p>

<p>1) For each <em>optional</em> module, have a unique (per module name) but similar (per purpose) callback function. E.g.</p>

<pre><code>fooModule.c:
void foo_eventCallback(void) {
    // do the foo response here
}

barModule.c:
void bar_eventCallback(void) {
    // do the bar response here
}

yakModule.c:
void yak_eventCallback(void) {
    // do the yak response here
}
</code></pre>

<p>2) Have a callback start point that looks something like:</p>

<pre><code>__attribute__((weak)) void foo_eventCallback(void) { }
__attribute__((weak)) void bar_eventCallback(void) { }
__attribute__((weak)) void yak_eventCallback(void) { }

void functionThatExcitesCallback(void) {
    foo_eventCallback();
    foo_eventCallback();
    foo_eventCallback();
}
</code></pre>

<p>The <code>__attribute__((weak))</code> qualifier basically creates a default implementation with an empty body, which the linker will replace with a different variant IF it finds a non-weak variant by the same name. It doesn't make it completely decoupled, unfortunately. But you can at least put this big super-set-of-all-callbacks in one and only one place, and not get into header file hell with it. And then your different compilation units basically replace the subsets of the superset that they want to. I would love it if there was a way to do this with using the same named function in all modules and just have those called based on what's linked, but haven't yet found something that does that.</p>
",,30082819,2026
37733937,2,24283277,2016-06-09T18:48:06.560,4,,4520015,,2016-06-09T19:02:00.507,2016-06-09T19:02:00.507,4,,"<p>As commented in some previous answer, the best option is to use a custom linker script (with a <code>KEEP(*(SORT(.whatever.*)))</code> input section).</p>

<p>Anyway, <strong>it can be done without modifying the linker scripts</strong> (working sample code below), at least at some platforms with gcc (tested on xtensa embedded device and cygwin) </p>

<p><strong>Assumptions:</strong></p>

<ul>
<li>We want to avoid using RAM as much as possible (embedded)</li>
<li>We do not want the calling module to know anything about the modules with callbacks (it is a lib)</li>
<li>No fixed size for the list (unknown size at library compile time)</li>
<li>I am using GCC. The principle may work on other compilers, but I have not tested it</li>
<li>Callback funtions in this sample receive no arguments, but it is quite simple to modify if needed</li>
</ul>

<p><strong>How to do it:</strong></p>

<ul>
<li>We need the linker to somehow allocate at link time an array of pointers to functions</li>
<li>As we do not know the size of the array, we also need the linker to somehow mark the end of the array</li>
</ul>

<p>This is quite specific, as the right way is using a custom linker script, but it happens to be feasible without doing so if we find a section in the standard linker script that is always ""kept"" and ""sorted"".</p>

<p>Normally, this is true for the <code>.ctors.*</code> input sections (the standard requires C++ constructors to be executed in order by function name, and it is implemented like this in standard ld scripts), so we can hack a little and give it a try.</p>

<p>Just take into account that it may not work for all platforms (I have tested it in xtensa embedded architecture and CygWIN, but this is a hacking trick, so...).</p>

<p>Also, as we are putting the pointers in the constructors section, we need to use one byte of RAM (for the whole program) to skip the callback code during C runtime init.</p>

<hr>

<p><strong>test.c:</strong> </p>

<p>A library that registers a module called <code>test</code>, and calls its callbacks at some point</p>

<pre><code>#include ""callback.h""

CALLBACK_LIST(test);

void do_something_and_call_the_callbacks(void) {

        // ... doing something here ...

        CALLBACKS(test);

        // ... doing something else ...
}
</code></pre>

<p><strong>callme1.c:</strong></p>

<p>Client code registering two callbacks for module <code>test</code>. The generated functions have no name (indeed they do have a name, but it is magically generated to be unique inside the compilation unit)</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""callback.h""

CALLBACK(test) {
        printf(""%s: %s\n"", __FILE__, __FUNCTION__);
}

CALLBACK(test) {
        printf(""%s: %s\n"", __FILE__, __FUNCTION__);
}

void callme1(void) {} // stub to be called in the test sample to include the compilation unit. Not needed in real code...
</code></pre>

<p><strong>callme2.c:</strong></p>

<p>Client code registering another callback for module <code>test</code>...</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""callback.h""

CALLBACK(test) {
        printf(""%s: %s\n"", __FILE__, __FUNCTION__);
}

void callme2(void) {} // stub to be called in the test sample to include the compilation unit. Not needed in real code...
</code></pre>

<p><strong>callback.h:</strong></p>

<p>And the magic...</p>

<pre><code>#ifndef __CALLBACK_H__
#define __CALLBACK_H__

#ifdef __cplusplus
extern ""C"" {
#endif

typedef void (* callback)(void);
int __attribute__((weak)) _callback_ctor_stub = 0;

#ifdef __cplusplus
}
#endif

#define _PASTE(a, b)    a ## b
#define PASTE(a, b)     _PASTE(a, b)

#define CALLBACK(module) \
        static inline void PASTE(_ ## module ## _callback_, __LINE__)(void); \
        static void PASTE(_ ## module ## _callback_ctor_, __LINE__)(void); \
        static __attribute__((section("".ctors.callback."" #module ""$2""))) __attribute__((used)) const callback PASTE(__ ## module ## _callback_, __LINE__) = PASTE(_ ## module ## _callback_ctor_, __LINE__); \
        static void PASTE(_ ## module ## _callback_ctor_, __LINE__)(void) { \
                 if(_callback_ctor_stub) PASTE(_ ## module ## _callback_, __LINE__)(); \
        } \
        inline void PASTE(_ ## module ## _callback_, __LINE__)(void)

#define CALLBACK_LIST(module) \
        static __attribute__((section("".ctors.callback."" #module ""$1""))) const callback _ ## module ## _callbacks_start[0] = {}; \
        static __attribute__((section("".ctors.callback."" #module ""$3""))) const callback _ ## module ## _callbacks_end[0] = {}

#define CALLBACKS(module) do { \
        const callback *cb; \
        _callback_ctor_stub = 1; \
        for(cb =  _ ## module ## _callbacks_start ; cb &lt;  _ ## module ## _callbacks_end ; cb++) (*cb)(); \
} while(0)

#endif
</code></pre>

<p><strong>main.c:</strong></p>

<p>If you want to give it a try... this the entry point for a standalone program (tested and working on gcc-cygwin) </p>

<pre><code>void do_something_and_call_the_callbacks(void);

int main() {
    do_something_and_call_the_callbacks();
}
</code></pre>

<hr>

<p><strong>output:</strong></p>

<p>This is the (relevant) output in my embedded device. The function names are generated at <code>callback.h</code> and can have duplicates, as the functions are static</p>

<pre><code>app/callme1.c: _test_callback_8
app/callme1.c: _test_callback_4
app/callme2.c: _test_callback_4
</code></pre>

<p>And in CygWIN...</p>

<pre><code>$ gcc -c -o callme1.o callme1.c
$ gcc -c -o callme2.o callme2.c
$ gcc -c -o test.o test.c
$ gcc -c -o main.o main.c
$ gcc -o testme test.o callme1.o callme2.o main.o
$ ./testme
callme1.c: _test_callback_4
callme1.c: _test_callback_8
callme2.c: _test_callback_4
</code></pre>

<p><strong>linker map:</strong></p>

<p>This is the relevant part of the map file generated by the linker</p>

<pre><code> *(SORT(.ctors.*))
 .ctors.callback.test$1    0x4024f040    0x0    .build/testme.a(test.o)
 .ctors.callback.test$2    0x4024f040    0x8    .build/testme.a(callme1.o)
 .ctors.callback.test$2    0x4024f048    0x4    .build/testme.a(callme2.o)
 .ctors.callback.test$3    0x4024f04c    0x0    .build/testme.a(test.o)
</code></pre>
",,30082934,103
24336533,2,24336285,2014-06-20T22:25:06.973,3,,1294094,,2014-06-24T20:01:48.323,2014-06-24T20:01:48.323,7,,"<p>If you're open to including some assembler in your code, Atmel AVR uC have the perfect instruction for this purpose : ROR or ROL. They make a bit shift with carry retaining and last carry insertion.
ROR(x) : x[b7] = Carry; x = x >> 1; Carry = x[b0]</p>

<p>You would just have to execute this instruction 5 times to get exactly what you're looking for.</p>

<p><strong>EDIT</strong>: something like that in Arduino IDE should do the trick (I haven't tested it):</p>

<pre><code>asm (""rol %0"" : ""=r"" (pixelData[16][0]) : ""0"" (pixelData[16][0]));
asm (""rol %0"" : ""=r"" (pixelData[16][1]) : ""0"" (pixelData[16][1]));
asm (""rol %0"" : ""=r"" (pixelData[16][2]) : ""0"" (pixelData[16][2]));
asm (""rol %0"" : ""=r"" (pixelData[16][3]) : ""0"" (pixelData[16][3]));
asm (""rol %0"" : ""=r"" (pixelData[16][4]) : ""0"" (pixelData[16][4]));
</code></pre>

<p>The bitflow would be:</p>

<pre><code>ROL &lt;value&gt;:
    # Carry Register = 8th bit of the given value
    # value = value &lt;&lt; 1
    # 1st bit of the value = Previous Carry Register)

ROL 0b10000001 # Result = 0b00000010 and Carry = 1
ROL 0b10000001 # Result = 0b00000011 and Carry = 1
ROL 0b00000001 # Result = 0b00000011 and Carry = 0
ROL 0b00000001 # Result = 0b00000010 and Carry = 0
</code></pre>
",,30092542,5567
24352855,2,24349209,2014-06-22T15:40:46.523,0,,3735428,,2014-06-22T15:40:46.523,,5,,"<p>This is one of these ""should work"" things. I tried the following two pieces of code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(void)
    {
    int i = 0;

    for (;;)
        {
        printf(""%05d\n"", i % 1000000);
        i++;
        fflush(stdout);
        sleep(1);
        }
    return 0;
    }
</code></pre>

<p>which was compiled with:</p>

<pre><code>gcc -Wall -Wstrict-prototypes -o test test.c
</code></pre>

<p>and <code>test.py</code>:</p>

<pre><code>import subprocess

subp = subprocess.Popen(""./test"",stdout=subprocess.PIPE)

for line in iter(subp.stdout.readline, ''):
    print line
</code></pre>

<p>When I run <code>python test.py</code> in the same directory, I get what I expected:</p>

<pre><code>00000

00001

00002
</code></pre>

<p>and so on. (Double line spaces are to be expected.)</p>

<p>If you cannot replicate this success, debugging requires two steps:</p>

<ol>
<li><p>Could it still be a buffering problem? This can be debugged by sending a lot of data. Easiest thing is to replace the <code>sleep(1)</code> by, e.g., <code>usleep(1000)</code>. Then there will be a lot of data flowing, and the buffering will fill in a few seconds. (If you print 6 chars every second, you don't probably wait for 10 minutes to see if it is buffering problem.)</p></li>
<li><p>If it is not a buffering problem, make your C program print something to stderr, as well. E.g., <code>fprintf(sterr, ""Hello?\n"")</code>so that it can be seen that the process is really running.</p></li>
</ol>

<p>When the problem has been isolated, it is easier to find a cure. Also, this sounds like something to do with the operating system. Which OS?</p>
",,30131032,2256
24354018,2,24349209,2014-06-22T17:51:54.410,0,,2836175,,2014-06-22T17:57:22.803,2017-05-23T10:25:24.073,2,,"<p>Try this:</p>

<pre><code>import subprocess
from serial import Serial
port = Serial(""/dev/ttyAMA0"",115200,timeout=3)

subp = subprocess.Popen(""./test"",stdout=subprocess.PIPE)

for line in iter(subp.stdout.readline, ''):
    port.write(line,)
    print line,
</code></pre>

<p>I'm not sure how this works, but as per here <a href=""https://stackoverflow.com/questions/18908897/whats-ending-comma-in-print-function-for"">What&#39;s ending comma in print function for?</a> I think that it prevents the output from being line-buffered, so that your program will no longer block while reading lines.</p>
",,30154005,3206
24456054,2,24415243,2014-06-27T15:56:06.130,3,,1824508,,2014-06-27T15:56:06.130,,0,,"<p>Problem has been solved:</p>

<p>Qt:</p>

<pre><code>if (serial.isOpen() &amp;&amp; serial.isWritable())
            {

                QByteArray ba(""R"");
                serial.write(ba);
                serial.flush();
                qDebug() &lt;&lt; ""data has been send"" &lt;&lt; endl;
                serial.close();
            }
</code></pre>

<p>Arduino:</p>

<pre><code>int led = 13, avlb = 0; 

void setup() 
{ 
Serial.begin(9600);
pinMode(led, OUTPUT); 
Serial.println(""started"");
}

void loop() 
{ 
  if (Serial.available() &gt; 0)
  {
    Serial.println(""available"");
    Serial.println(Serial.available());  
    delay(2000);    
  if(Serial.read())
  {
    Serial.println(""read"");
    Serial.println(Serial.read());
    delay(2000);
  }  
  }

else
{
  Serial.println(""not available"");
  delay(1000);
}

}
</code></pre>

<p>N.B.: Don't forget to put baudrate in Arduino IDE correctly;<br>
In monitor, 9600 baudrate</p>
",,30158480,731
24420279,2,24420246,2014-06-25T23:34:48.393,24,,1967396,,2019-07-12T16:33:53.237,2019-07-12T16:33:53.237,11,,"<p>Easiest is to make a union:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  int ii;
  union {
    float a;
    unsigned char bytes[4];
  } thing;

  thing.a = 1.234;
  for (ii=0; ii&lt;4; ii++) 
    printf (""byte %d is %02x\n"", ii, thing.bytes[ii]);
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>byte 0 is b6
byte 1 is f3
byte 2 is 9d
byte 3 is 3f
</code></pre>

<p>Note - there is no guarantee about the byte order… it depends on your machine architecture.</p>

<p>To get your function to work, do this:</p>

<pre><code>void float2Bytes(byte bytes_temp[4],float float_variable){ 
  union {
    float a;
    unsigned char bytes[4];
  } thing;
  thing.a = float_variable;
  memcpy(bytes_temp, thing.bytes, 4);
}
</code></pre>

<p>Or to really hack it:</p>

<pre><code>void float2Bytes(byte bytes_temp[4],float float_variable){ 
  memcpy(bytes_temp, (unsigned char*) (&amp;float_variable), 4);
}
</code></pre>

<p>Note - in either case I make sure to copy the data to the location given as the input parameter. This is crucial, as local variables will not exist after you return (although you could declare them <code>static</code>, but let's not teach you bad habits. What if the function gets called again…)</p>
",,30167248,345
24420283,2,24420246,2014-06-25T23:35:23.237,5,,3135317,,2014-06-25T23:35:23.237,,0,,"<p>I would recommend trying a ""union"".</p>

<p>Look at this post:</p>

<p><a href=""http://forum.arduino.cc/index.php?topic=158911.0"">http://forum.arduino.cc/index.php?topic=158911.0</a></p>

<pre><code>typedef union I2C_Packet_t{
 sensorData_t sensor;
 byte I2CPacket[sizeof(sensorData_t)];
};
</code></pre>

<p>In your case, something like:</p>

<pre><code>union {
  float float_variable;
  char bytes_array[4];
} my_union;

my_union.float_variable = 1.11;
</code></pre>
",,30185012,69
24420378,2,24420246,2014-06-25T23:47:27.657,2,,972121,,2014-06-26T00:16:19.377,2014-06-26T00:16:19.377,3,,"<p>Although the other answers show how to accomplish this using a union, you can use this to implement the function you want like this:</p>

<pre><code>byte[] float2Bytes(float val)
{
    my_union *u = malloc(sizeof(my_union));
    u-&gt;float_variable = val;
    return u-&gt;bytes_array;
}
</code></pre>

<p>or</p>

<pre><code>void float2Bytes(byte* bytes_array, float val)
{
    my_union u;
    u.float_variable = val;
    memcpy(bytes_array, u.bytes_array, 4);
}
</code></pre>
",,30203507,71
24420675,2,24420246,2014-06-26T00:25:11.200,11,,2284221,,2014-06-26T00:25:11.200,,8,,"<p>Here's a way to do what you want that won't break if you're on a system with a different <a href=""http://en.wikipedia.org/wiki/Endianness"">endianness</a> from the one you're on now:</p>

<pre><code>byte* floatToByteArray(float f) {
    byte* ret = malloc(4 * sizeof(byte));
    unsigned int asInt = *((int*)&amp;f);

    int i;
    for (i = 0; i &lt; 4; i++) {
        ret[i] = (asInt &gt;&gt; 8 * i) &amp; 0xFF;
    }

    return ret;
}
</code></pre>

<p>You can see it in action here: <a href=""http://ideone.com/umY1bB"">http://ideone.com/umY1bB</a></p>

<p>The issue with the above answers is that they rely on the underlying representation of <code>float</code>s: C makes no guarantee that the most significant byte will be ""first"" in memory. The standard allows the underlying system to implement <code>float</code>s however it feels like -- so if you test your code on a system with a particular kind of endianness (byte order for numeric types in memory), it will stop working <em>depending on the kind of processor you're running it on</em>. </p>

<p>That's a really nasty, hard-to-fix bug and you should avoid it if at all possible. </p>
",,30207140,83
35025402,2,24420246,2016-01-26T22:37:29.677,3,,3059385,,2016-01-26T22:37:29.677,,5,,"<p>Yet another way, without unions:
(Assuming byte = unsigned char)</p>

<pre><code>void floatToByte(byte* bytes, float f){

  int length = sizeof(float);

  for(int i = 0; i &lt; length; i++){
    bytes[i] = ((byte*)&amp;f)[i];
  }

}
</code></pre>
",,30272702,178
44369563,2,24420246,2017-06-05T13:00:56.910,2,,6419563,,2017-06-05T15:53:47.237,2017-06-05T15:53:47.237,0,,"<p>this seems to work also</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

float fval = 1.11;
size_t siz;
siz = sizeof(float);

uint8_t ures[siz];

memcpy (&amp;ures, &amp;fval, siz);
</code></pre>

<p>then</p>

<pre><code>float utof;
memcpy (&amp;utof, &amp;ures, siz);
</code></pre>

<p>also for double</p>

<pre><code>double dval = 1.11;
siz = sizeof(double);

uint8_t ures[siz];

memcpy (&amp;ures, &amp;dval, siz);
</code></pre>

<p>then</p>

<pre><code>double utod;
memcpy (&amp;utod, &amp;ures, siz);
</code></pre>
",,30276597,1117
24464350,2,24427320,2014-06-28T06:42:53.817,0,,1484968,,2014-06-28T06:42:53.817,,0,,"<p>Hi Guys thanks for the help. It seems that I was using a screen command on the terminal and at the same time running a python script that was using the same the object and hence the data inconsistency. if u see below the terminal output is better but still not perfect</p>

<pre><code>04001ODR0001
04001OD000
04002ODR001
04002ODR0000
04003ODR0001
04003ODR0000
04004DR0001
04004ODR0000
04005ODR0001
04005ODR000
04004OD0001
0404ODR0000
04003ODR001
04003ODR0000
04003OR0001
04003ODR000
04003ODR001
0403OR000100
04003ODR0000
            0400ODR0001
4003ODR000
04003OR0001
0400ODR0000
</code></pre>
",,30287832,337
24568771,2,24502466,2014-07-04T07:22:51.697,0,,1592772,,2014-07-04T10:31:26.700,2014-07-04T10:31:26.700,0,,"<p>I was missing <code>extern ""C""</code> around my <code>#includes</code>. This works:</p>

<pre><code>#include &lt;cstdio&gt;

extern ""C"" {
#include &lt;interface/vmcs_host/vc_cecservice.h&gt;
#include &lt;interface/vchiq_arm/vchiq_if.h&gt;
}

// rest of program...
</code></pre>
",,30311777,259
24509624,2,24509288,2014-07-01T11:52:39.300,3,,387936,,2014-07-01T14:09:01.373,2014-07-01T14:09:01.373,13,,"<p>The errors shown in the picture are:</p>

<ul>
<li>main.c:101:5: warning: passing argument 2 of 'memset' makes integer from pointer without a cast</li>
<li>compilation failed (undefined references to 'xi_....' stuff.</li>
</ul>

<p>First error, use '0' (zero!), not NULL.  NULL is for pointers, you want to set the memory to zero, use a zero.  That'll fix that one.</p>

<p>As for the other error, you're missing a <code>-lxively</code> somewhere, ... looking...</p>

<p>From your <code>Makefile</code>:</p>

<pre><code>#Any special libraries you are using in your project
LIBS = -lrt -lwiringPi -L$(HOME)/pi/libxively/src/libxively -L/root/libxively/src/libxively -dxively 
#we did try -lxively but that didn't work either 
</code></pre>

<p>No idea what <code>-dxively</code> is supposed to do, no such option for <code>ld</code> or <code>gcc</code>... I see your comment about <code>-lxively</code> not working.</p>

<p>Where is the <code>libxively.so.??</code> file?  In the <code>libxively/src/libxively</code> subdirectory?  You'll have much better luck if you actually install the library in it's proper place (umm, <code>/usr/lib</code> or <code>/lib</code> or ... gosh! somewhere!)  That would make it easier, but in any case, if the library has been properly compiled, figure out where it is, and put the proper PATH in the <code>-L</code> option.  You've got two <code>-L</code>'s there, which one is it?  the <code>pi</code> user typically cannot read anything in <code>/root</code> home directory, that's not going to work, can be removed.</p>

<p>Once you have the <code>libxively.so</code> file compiled and located, with the proper path in an <code>-L</code> option in your <code>Makefile</code>, then the <code>-lxively</code> option should work as expected.</p>

<p>Without some more information about where the file is located, if it's compiled successfully, and an update on the error messages, can't do too much more to help.</p>

<hr>

<p>EDIT:</p>

<p>We're going to rebuild your Makefile:</p>

<pre><code># New and improved Makefile (remember about the TABS vs SPACES here!)
#
XIVELY_OBJ_PATH=$(HOME)/libxively/obj
#
# Any special libraries you are using in your project
LIBS=-lrt -lwiringPi
#
# Now add all the pesky .o files
LIBS+=$(wildcard $(XIVELY_OBJ_PATH)/*.o)
LIBS+=$(wildcard $(XIVELY_OBJ_PATH)/io/posix/*.o)
#
LDFLAGS=
#
# We love the new standard
CFLAGS+=-std=c99
#
# debugging symbols always good
CFLAGS+=-g
#
CC=gcc
#
.PHONY: all clean
#
all: sensortest
#
sensortest: main.c main.h
    $(CC) $(CFLAGS) -c -o $@.o $&lt;
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $@.o $(LIBS)
#
clean:
    rm -f sensortest *.o
</code></pre>

<p>(We discussed this over chat and figured it out)</p>
",,30354405,235
24590953,2,24589235,2014-07-05T22:07:09.637,3,,3735428,,2014-07-06T21:07:47.457,2014-07-06T21:07:47.457,5,,"<p>This does not look like a UART problem, but rather a library problem.</p>

<p>If you want to make sure my assumption is correct, call <code>_write()</code> directly and see, if it works. Most probably it will. Also, I assume you are using <code>newlib</code>.</p>

<p>If <code>_write()</code> works as expected, the problem is limited into the upper layers of <code>printf</code>. Unfortunately <code>printf</code> is like an onion, you have to peel it layer-by-layer, and it'll make you cry.  </p>

<p>Just for fun, a snippet from the <code>newlib</code> source code:</p>

<pre><code>/*
 * Actual printf innards.
 *
 * This code is large and complicated...
 */
</code></pre>

<p>Luckily, there are still some ways to debug the problem without getting lost into <code>vfprintf.c</code>. Maybe the easiest starting point is to try <code>snprintf()</code>, because it lacks the memory management problems. The memory allocation code includes things such as <code>sbrk</code> which may be one problem. One would be tempted to think that the memory management is ok, as <code>malloc()</code> seemingly works, but that is not always the case. (<code>malloc()</code> may look ok even if it gives wrong addresses, but memory corruption will happen.)</p>

<p>Let us know where you get with these debugging steps! (My educated guess is that <code>sbrk</code> does not work for some reason, and that wrecks memory management.)</p>

<hr>

<p><strong>Update</strong> As it seems that the problem is not in memory allocation -- at least not only in memory allocation -- we need to tackle the onion. I hope you are not wearing too heavy make-up... (This makes me cry, and I am not 100 % sure the analysis below is correct. So take it with a pinch of salt.)</p>

<p>What happens in <code>newlib</code> when <code>printf</code> is called? The story is in the <code>newlib</code> source in folder <code>newlib/libc/stidio</code>. </p>

<p><strong>Layer 1: <code>printf()</code></strong></p>

<p>First, <code>printf.c</code>:</p>

<pre><code>int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS) 
{
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
  va_end (ap);
  return ret;
}
</code></pre>

<p>Quite simple. If something is going wrong, it is either:</p>

<ul>
<li><code>_REENT_SMALL_CHECK_INIT(ptr);</code> or</li>
<li>handling of varargs</li>
</ul>

<p>I don't think the re-entrancy is a problem here, so I would concentrate on the varargs. Maybe it would be a good idea to make a minimal varargs test code, which would then show if they are broken. (I do not see why they would be broken, but in an embedded system it is safer not to assume anything.)</p>

<p><strong>Layer 2: <code>_vfprintf_r()</code></strong></p>

<p>This is an internal version of standard <code>vfprintf</code> (varargs-version of file-<code>printf</code>) with re-entrant code. It is defined in <code>vfprintf.c</code>. It comes in several flavours depending on which switches have been used during the library compilation: <code>STRING_ONLY</code> (no memory allocation) and/or <code>NO_FLOATING_POINT</code>. I'll assume you have the full version, in which case the correct function can be found under the name <code>_VFPRINTF_R</code> (some <code>#define</code>ing has been going on).</p>

<p>The code is not too easy to read, first few hundred lines of the function consist of declaring many variables (depending on the compile options) and a dozen or so macros. However, the first thing the function really does is an endless loop to scan the format string for <code>%</code>. When it finds a <code>\0</code> instead, it does <code>goto done;</code> (yeah, it's got <code>goto</code>s, as well -- I'd like to throw this to code review...)</p>

<p>However, this gives us a clue: if we do not put any extra arguments, we just jump to <code>done</code> where we have some cleanup. This we can survive, but not the handling of any format arguments. So, let us look at where <code>%s</code> would end up. This is done as one would expect, there is a big <code>switch(ch) ...</code>. At <code>s</code> it says:</p>

<pre><code>    case 's':
        cp = GET_ARG (N, ap, char_ptr_t);
        sign = '\0';
        if (prec &gt;= 0) {
            /*
             * can't use strlen; can only look for the
             * NUL in the first `prec' characters, and
             * strlen () will go further.
             */
            char *p = memchr (cp, 0, prec);

            if (p != NULL) {
                size = p - cp;
                if (size &gt; prec)
                    size = prec;
            } else
                size = prec;
        } else
            size = strlen (cp);

        break;
</code></pre>

<p>(Now, I have assumed you do not have multibyte string support <code>MB_CAPABLE</code> switched on in your <code>newlib</code>. If you have, the thing just got much more complicated.) The rest looks easy to debug (<code>strlen</code> and <code>memchr</code>), but the <code>GET_ARG</code>macro may be complicated -- again depending on your compile settings (if you have <code>_NO_POS_ARGS</code>, it is much simpler).</p>

<p>After the switch, the simple case (no padding in the format string) is:</p>

<pre><code>PRINT (cp, size);
</code></pre>

<p>which is the printing macro. At least if the pointer <code>cp</code> is wrong, then odd things will happen. </p>

<p>The macro itself cannot be horrendously crazy, as we can print the simple case; only the arguments cause problems.</p>

<p>I am afraid this is a bit sticky to debug, but the symptoms point at something getting corrupted in memory. One thing to check is the return value of your <code>printf</code>. It should return the number of characters printed. Whether or not the return value is sane helps debugging the rest.</p>
",,30367270,128
27257841,2,24589235,2014-12-02T19:57:37.350,2,,1073171,,2014-12-02T19:57:37.350,,1,,"<p>I'm sorry I'm so late to solve this problem for you. I'm the author of the valvers.com bare metal tutorials. The cause of the crash is due to something I was aware of, but hadn't had time to solve. Actually, I didn't know it would be the solution to your problem.</p>

<p>In short, the problem is that we're telling the toolchain that the processor is an ARM1176 and more importantly that the floating point unit is VFP, and we should use the hard-float ABI.</p>

<p>Using the VFP is an important option - it means we pick up the C library that's also been compiled with this option. Generally the VFP instructions aren't used and therefore do not trip us up. Clearly, portions of printf do use VFP instructions.</p>

<p>The reason this trips us up is because the startup assembler which is responsible for generating a good C runtime environment doesn't enable VFP, so when you reach a VFP instruction the processor jumps to the undefined instruction exception vector.</p>

<p>This is how I found out that this was the problem. I simple enabled the LED in any of the exception vectors and it lit when using printf formatting. Then it was a case of removing the LED calls in the exception vectors until it didn't light anymore. This happened in the ""Undefined Instruction"" exception. A quick search on the ARM site reveals the processor will go here if a VFP instruction is encountered and the VFP is not enabled. Hence, it reminded me to sort that out!</p>

<p><strong>The Solution</strong></p>

<p>There are a few things you need to do. You need to replicate the CMAKE_C_FLAGS to CMAKE_ASM_FLAGS in the CMakeLists.txt file so that the correct options are passed to the assembler, currently they are not! I will update the tutorials as soon as possible to fix this!</p>

<p>Just below the last <code>set( CMAKE_C_FLAGS ... )</code> command in the CMakeLists.txt file add <code>set( CMAKE_ASM_FLAGS ${CMAKE_C_FLAGS} )</code> which works okay because CMake uses gcc as the assembler.</p>

<p>Next, we need to modify the startup assembler file (in my tutorials armc-nnn-start.S) to enable the VFP. Insert the code below just above <code>bl    _cstartup</code></p>

<p>(This is directly off the <a href=""http://processors.wiki.ti.com/index.php/Cortex-A8#How_to_enable_NEON"" rel=""nofollow"">TI Website</a>)</p>

<pre><code>// Enable VFP/NEON
// r1 = Access Control Register
MRC p15, #0, r1, c1, c0, #2
// enable full access for p10,11
ORR r1, r1, #(0xf &lt;&lt; 20)
// ccess Control Register = r1
MCR p15, #0, r1, c1, c0, #2
MOV r1, #0
// flush prefetch buffer because of FMXR below
MCR p15, #0, r1, c7, c5, #4
// and CP 10 &amp; 11 were only just enabled
// Enable VFP itself
MOV r0,#0x40000000
// FPEXC = r0
FMXR FPEXC, r0
</code></pre>

<p>You can find some information from ARM about this <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0098a/index.html"" rel=""nofollow"">here</a>.</p>

<p>Those changes are enough to get printf formatting working okay (I've tested it on the UART). If you have any further problems, don't hesitate to ask.</p>

<p>Lastly, sorry you've had grief because the startup code is not correct! The last thing I'd want to do is cost someone's time!!</p>
",,30394108,198
24598000,2,24597929,2014-07-06T16:35:35.193,2,,3809494,,2014-07-06T17:02:21.020,2014-07-06T17:02:21.020,1,,"<p>Below logic will help you</p>

<pre><code>iDst = (cSrc[0] &lt;&lt; 16) | (cSrc[1] &lt;&lt; 8) | cSrc[2]
</code></pre>

<p>or else you can use union for this case</p>

<pre><code>union byte2char
{
    char c[4];
    int i;
};
</code></pre>

<p>But union implementation needs to consider little and big endian systems</p>
",,30404718,1303
24598029,2,24597929,2014-07-06T16:38:30.520,2,,2950041,,2020-07-31T19:00:29.793,2020-07-31T19:00:29.793,0,,"<ol>
<li><p>The return value of <code>Serial.read()</code> is an <code>int</code>. Therefore, if you have the following code snippet:</p>
<pre class=""lang-cpp prettyprint-override""><code>int input[3];

for (int i = 0; i &lt; 3; i++) {
  input[i] = Serial.read();
}
</code></pre>
<p>Then <code>input</code> should store three <code>int</code>s. However, the code:</p>
<pre class=""lang-cpp prettyprint-override""><code>char* input[3];

for (int i = 0; i &lt; 3; i++) {
 input[i] = Serial.read();
}
</code></pre>
<p>Will just store the byte conversion from <code>int</code> to <code>char</code>.</p>
</li>
<li><p>If you want to store this as a string, you need to do a proper conversion. In this case, use <code>itoa</code> (see <a href=""http://playground.arduino.cc/Code/PrintingNumbers"" rel=""nofollow noreferrer"">Arduino API description</a>).</p>
<p>The code snippet would be:</p>
<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdlib&gt;
char* convertedString = itoa(input[i]);
</code></pre>
</li>
</ol>
",,30413724,949
24605552,2,24605439,2014-07-07T07:55:31.423,1,,198536,,2014-07-07T07:55:31.423,,1,,"<p>You said nothing about the environment and anything else that needs doing.  If there are not other tasks nor an o/s, maybe something this is what you want?:</p>

<pre><code>int last_state = -1;   // impossible state so change is noticed the first time
for (;;)  // do forever
{
       int state = get_gpio (THE_EVENT);
       if (state == last_state)
       {
            sleep (100);
            continue;
       }
       do_loader_stuff();
       last_state = state;
}
</code></pre>
",,30424236,8652
46231332,2,24605439,2017-09-15T03:41:28.757,1,,198480,,2017-09-15T03:41:28.757,,0,,"<p>You can configure the pin to be interrupt driven.  The way this works is that after you perform the configuration, you can now <code>select()</code> on the file representing the pin, and <code>select()</code> will return when the pin changes state.</p>

<p>Here is the documentation on the sysfs gpio interface: <a href=""https://www.kernel.org/doc/Documentation/gpio/sysfs.txt"" rel=""nofollow noreferrer"">https://www.kernel.org/doc/Documentation/gpio/sysfs.txt</a></p>

<p>Here is what the setup for pin 19 would look like:</p>

<pre><code>QFile exportFile(""/sys/class/gpio/gpio19/export"");
exportFile.open(QIODevice::WriteOnly);
exportFile.write(""19"");

QFile directionFile(""/sys/class/gpio/gpio19/direction"");
directionFile.open(QIODevice::WriteOnly);
directionFile.write(""in"");

QFile edgeFile(""/sys/class/gpio/gpio19/edge"");
edgeFile.open(QIODevice::WriteOnly);
edgeFile.write(""body"");
</code></pre>

<p>Now, instead of using <code>select()</code> directly, you can use <code>QSocketNotifier</code>.</p>

<pre><code>QFile file(""/sys/class/gpio/gpio19/value"");

QSocketNotifier notifier(file.handle(), QSocketNotifier::Read);
connect(&amp;notifier, &amp;QSocketNotifier::activated, this, &amp;MyClass::interruptFired);
</code></pre>
",,30428872,463
24606298,2,24605718,2014-07-07T08:38:15.850,0,,878532,,2014-07-07T12:51:20.010,2017-05-23T12:24:51.663,13,,"<p>You have to copy the libstdc++ and others to your respary pi. If you use an newer compiler which generate executables which needs a newer lib this lib must be present on the target. Static linking is not a useful option. Simply copy the new libs to the appropriate path on your target.</p>

<blockquote>
  <p>So I suspect the crosscompiler is using the libstd++.so of my host machine instead of the one that is part of the crosscompiler, but I have no idea how to fix it.</p>
</blockquote>

<p>No, I don't believe this. If your compiler was configured correctly, it uses the correct libs. And if it tries to use you x86 libs, you don't get an message of wrong version because the dynamic linker can not work with x86 libs at all.</p>

<p>For the downvoters :-):
You can have more then one version on the target, so it is no problem to do this, see ldconfig for details. Also you can have the lib in the local or any other path without a problem, for this you can use LD_LIBRARY_PATH. And yes, I have not written that you should remove older versions. Linux is not windows so a added library will not break the system. Linux have no problems like the dll hell of win...</p>

<p>Of your special request I build one program with two different compilers and get from ldd:</p>

<p>gcc 4.9:</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fff4b7fe000)
librt.so.1 =&gt; /lib64/librt.so.1 (0x00000030f2200000)
libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00000030f1200000)
libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00000030f0e00000)
libstdc++.so.6 =&gt; /opt/linux-gnu_4.9-20140105/lib64/libstdc++.so.6 (0x00007fa4aadc4000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x00000030f1600000)
libgcc_s.so.1 =&gt; /opt/linux-gnu_4.9-20140105/lib64/libgcc_s.so.1 (0x00007fa4aabad000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00000030f0a00000)
</code></pre>

<p>gcc 4.8.2:</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fff4b7fe000)
librt.so.1 =&gt; /lib64/librt.so.1 (0x00000030f2200000)
libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00000030f1200000)
libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00000030f0e00000)
libstdc++.so.6 =&gt; /opt/linux-gnu_4.8.2/lib64/libstdc++.so.6 (0x00007fa4aadc4000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x00000030f1600000)
libgcc_s.so.1 =&gt; /opt/linux-gnu_4.8.2/lib64/libgcc_s.so.1 (0x00007fa4aabad000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00000030f0a00000)
</code></pre>

<p>As you can see: Two versions of one library one one system and no problems at all.</p>

<p>Some more infos on different of libs on the os look here at:</p>

<p><a href=""https://stackoverflow.com/questions/3839756/how-do-applications-resolve-to-different-versions-of-shared-libraries-at-run-tim"">How do applications resolve to different versions of shared libraries at run time?</a></p>

<p>If it will not work on your system, feel free to ask again. </p>
",,30439969,1635
24654493,2,24654293,2014-07-09T13:02:36.017,1,,2666289,,2014-07-09T13:02:36.017,,1,,"<p>Your <code>&amp;GeneralInput</code> are incorrect, in fact you create temporary objects and store their adresses in an array, but as soon as your <code>GeneralInput</code> object get destroy (same line as creation), a new object takes place at the same address:</p>

<pre><code>// Create GeneralInput at address @
Inputs[0] = &amp;GeneralInput(0,0,true,false,NULL,10);
// End of your temporary object, the `GeneralInput` object is destroyed but you still
// points to its address...
/* etc. */
</code></pre>

<p>You're getting the last value because the compiler always create the <code>GeneralInput</code> at the same address, so all <code>Inputs[]</code> point to the same address.</p>

<p>You need to dynamically create your <code>GeneralInput</code>:</p>

<pre><code>Inputs[0] = new GeneralInput(0,0,true,false,NULL,10);
</code></pre>
",,30443394,736
24659561,2,24654293,2014-07-09T16:55:07.877,0,,2041317,,2014-07-09T20:59:19.343,2014-07-09T20:59:19.343,0,,"<p>As others have said, the problem is with the address of the temporary variables.  You can get around the ""new"" problem by having default parameters.</p>

<pre><code>class GeneralInput
{
public:
    GeneralInput(int a = 0, int b = 0, bool c = true, bool d = true, int* e = NULL, int f = 0);
    ...
};
</code></pre>

<p>Then declare your array - this takes GeneralInput with the default parameters</p>

<pre><code>GeneralInput inputs[20];
</code></pre>

<p>Then in Initialize - then you won't have the new problem or the problem of temporaries disappearing at the end of the routine.</p>

<pre><code>void InitializeInputs()
{
    inputs[0] = GeneralInput(0,0,true,false,NULL,10);
    ...
}
</code></pre>

<p>I don't know what the NULL points to but you might want to put in a copy operator for this if it is anything else other than copying the value.  Not very efficient because it calls the constructor twice but that only happens at initialization.</p>
",,30444454,119
24715398,2,24715359,2014-07-12T17:12:41.290,6,,616460,,2014-07-12T17:18:43.260,2014-07-12T17:18:43.260,4,,"<p>It worked for your friend because his compiler's default settings happened to ignore invalid preprocessor directives without failing, and also accept all of that other code (which is valid in C99). </p>

<p>As far as the preprocessing stuff goes:</p>

<pre><code># --------------------------------------
# Written by Scott Vincent
# 16 Feb 2014
# --------------------------------------
</code></pre>

<p>But these aren't comments. This should be (or whatever your favorite <code>/* ... */</code> style is):</p>

<pre><code>/* 
  --------------------------------------
  Written by Scott Vincent
  16 Feb 2014
  --------------------------------------
*/
</code></pre>

<p>Or with C++-style comments (also valid with C99):</p>

<pre><code>// --------------------------------------
// Written by Scott Vincent
// 16 Feb 2014
// --------------------------------------
</code></pre>

<p>Lines that start with <code>#</code> are preprocessor directives; special commands for the preprocessor that processes the file prior to compilation (e.g. <code>#if</code>). There is only a certain set of valid commands. These are not comments.</p>

<p>You could add compiler flags to make <code>gcc</code> accept this but it would be better to use proper comment syntax for comments and leave the <code>#</code> for actual preprocessing directives.</p>

<p>For the rest of your issues, you can do as the compiler recommends and ""use option <code>-std=99</code> or <code>-std=gnu99</code> to compile your code"". E.g. declaring variables in <code>for</code> loops (<code>for (int n ...</code>) requires at least C99.</p>
",,30458971,1786
24742504,2,24741765,2014-07-14T17:43:08.480,0,,515028,,2014-07-14T17:43:08.480,,0,,"<p>Code works by simply adding a delay(100) after the first Serial.available()</p>

<p>This is the code:</p>

<pre><code>void get_command() 
{
    char received;

    if (Serial.available() &gt; 0) {
        delay(100); // let the buffer fill up
        int index = 0;

        while (Serial.available() &gt; 0) {

            if (index &lt; BUFFER_SIZE -1) {
                received = Serial.read();
                if (received != '\n') {
                    buffer[index] = received;
                    index++;
                } else {
                    buffer[index] = '\0';
                    parse_command(buffer);
                }
            } else {
                Serial.println('666'); // buffer overflow
            }
        }
    }
}
</code></pre>
",,30520252,459
24758754,2,24757939,2014-07-15T12:55:07.930,1,,2666289,,2014-07-15T14:48:52.467,2014-07-15T14:48:52.467,2,,"<p><strong>Edit:</strong> I make a big edit of this post, because I think that's currently not the best solution. This edit is really similar to @MarkusMayer answer, but I came to it in a very different way of thinking (I think), so maybe it will help you.</p>

<p>First, let define a GPIO pin, which can be anything you want (a class would be good, then you can do <code>pin.setOutput()</code> or <code>pin.set()</code>, etc. I let you define it the way you want, let's just assume we have a <code>GPIOPin</code> class.</p>

<p>First, I define an abstract board as a set of pin, which look quite correct to me:</p>

<pre><code>template &lt;int N&gt;
class Board {
protected:
    Board (std::array &lt;GPIOPin, N&gt; const&amp; pins) : _pins(pins) { }
    std::array &lt;GPIOPin, N&gt; _pins ;
};
</code></pre>

<p>Then I define interface for <code>ADC</code> and <code>LEDs</code> which are also abstract:</p>

<pre><code>class ADC {
public:
    ADC () { }
    float read () { }
} ;

class LEDs {
public:
    LEDs () { }
    void set (int) { }
} ;
</code></pre>

<p>Now I can create what represent the real board with <code>ADC</code> and <code>LED</code>:</p>

<pre><code>class MyBoard : public Board &lt;5&gt; { // Let's assume it's connect to 5 bits
public:
    MyBoard (std::array &lt;GPIOPin, N&gt; const&amp; pins) : Board&lt;5&gt;(pins) {
        // Here you can initialize what you want
    }
} ;
</code></pre>

<p>Then you create your own <code>ADC</code> and <code>LED</code>:</p>

<pre><code>class AD7813 : public ADC {
    Board &lt;5&gt; _board ;
public:
    AD7813 (Board &lt;5&gt; *board) : ADC(), _board(board) { }
} ;

// Same for the LED
</code></pre>

<p>Finally, you can simply use it as follow:</p>

<pre><code>Board &lt;5&gt; *board = new MyBoard(/* The corresponding GPIO pins. */) ;
ADC *adc = new AD7813(board) ;
LEDs *led = new MyLEDs(board) ;
</code></pre>

<p>I did not define destructor for <code>MyBoard</code> or <code>Board</code> but of course you can. You can also use <code>shared_ptr</code> like @MarkusMayer.</p>

<p><strong>End of edit.</strong></p>

<p>I think there are different approaches to this problem, I'll present here what I would have done. It is often difficult to use OO design on embedded system, first thing is that you should have singleton class almost everywhere because you've only one <code>ADC</code> (you cannot instanciate multiple ADC), so your ADC class (and LEDBoard class) should look like:</p>

<pre><code>class ADC {
public:
    static ADC *getInstance () {
        if (_instance == nullptr) {
            _instance = new ADC () ;
        }
        return _instance ;
    }
private:
    ADC () ;
};
</code></pre>

<p>To answer your problem, I would create a base class that do your initialization, and will do it only once (use of a static member to know if ports are already initialized).</p>

<pre><code>class GPIOs {
protected:
    GPIOs () {
        if (!GPIOs::_init) {
            /* Do what you want. */
            GPIOs::_init = true ;
        }
    }
private:
    static bool _init ;
} ;

bool GPIOs::_init = false ;
</code></pre>

<p>Then your <code>ADC</code> and <code>LEDBoard</code> class inherit from <code>GPIOs</code>:</p>

<pre><code>class ADC : public GPIOs {
public:
    ADC *getInstance () { /* ... */ }
private:
    ADC () : GPIOs () { } // Call constructor
} ;
</code></pre>

<p>Then in your code, you simply do:</p>

<pre><code>ADC *adc = ADC::getInstance () ;
</code></pre>

<p>You could also use a singleton for the <code>GPIOs</code> class but since it's an abstract class than is only used by <code>ADC</code> and <code>LEDBoard</code> which are already singleton, it's not the most useful.</p>

<p>I'm sure there are plenty of other ways to deal with your problem, but the main idea I wanted to show is the use of <code>init</code> method / class that you can call multiple time without doing mutiple initialization because of the <code>_init</code> boolean.</p>
",,30524827,365
24759886,2,24757939,2014-07-15T13:43:21.160,0,,2430032,,2014-07-15T13:50:45.943,2014-07-15T13:50:45.943,2,,"<p>I'll sketch you an idea. I don't know of any design patterns for this, but the below may fit your need.</p>

<p>Firstly I agree with your idea of using a GPIOPort to control the whole port, but I want to introduce a more modular approach than a ""class in a class"". Instead of setting up the ports in the device constructor, I suggest creating an object that describes the device, and let GPIOPort setup the devices based on these descriptors.</p>

<p>My idea is to encapsulate the access to the GPIO through the GPIOPort class. But, leave the raw output open for the user of the code to work with. This could be combined with other classes as well, but they should be <em>using</em> <code>GPIOPort</code> in this design, and not the other way around.</p>

<p>One (of many, sometimes conflicting) advices in OOP is that you should only subtype a class if its behaviour has changed. If you can express difference between two classes simply by changing the attributes, they are of the same class. I'm unsure if that is the case here, depending on how how much work you have to do to initialize a device.</p>

<pre><code>using ports = uint64_t; // some suitable unsigned bit-maskable type.

// Used to control the IO.
struct DeviceDescriptor {
    ports    in_mask,  // Which pins does this device use for input
             out_mask, // Which pins does this device use for output
             init,     // Initial state of the pins.
             shutdown; // State to send when device should power down.
};

class GPIOPort {
    static const ports ALL_PORTS = ~static_cast&lt;ports&gt;(0);
    std::vector&lt;Device&gt; devices; 
public:
    // Initialize the devices.
    GPIOPort( std::vector&lt;Device&gt; &amp; devices ) : devices(devices) { 
        ports used_ports = 0, init = 0;
        for ( auto &amp; device : devices ) {
              init |= device.init;

              // Assert no overlapping ports
              ports partition = device.init | device.in_mask | device.out_mask | device.shutdown;
              if ( used_ports &amp; partition){
                 // Signal overlapping ports.
              } else {
                 used_bits |= current;
              }
          }
          set_bits(init, ALL_PORTS); // Actually sets the output.
      }

      // Read the input of device number 'dev'
      ports read_state( int dev, ports mask = ALL_PORTS ) {
          return read_bits( devices.at(dev).input_mask &amp; mask );
      }

      // etc...

      ~GPIOPort() {
           ports shutdown;
           for ( auto &amp; device : devices ) {
              shutdown |= device.shutdown;
           }
           set_bits(shutdown, ALL_PORTS);
      }
};
</code></pre>
",,30571009,149
24760569,2,24757939,2014-07-15T14:14:40.777,3,,3815677,,2014-07-15T14:14:40.777,,0,,"<p>Some definitions:</p>

<ul>
<li>Device: The entire device that is attached to the GPIO (Input and Output)</li>
<li>LEDBoard: The output parts of a Device</li>
<li>ADCBoard: The input parts of a Device</li>
</ul>

<p>I highly recomment to <strong>not</strong> use a singleton. Some day you may connect a second device to other GPIO Pins and you will be in trouble.</p>

<p>If you create separate classes for LEDBoard and ADCBoard, you have to ask: 
""What do I need to create a LEDBoard/ADCBoard?""
Well... You need a Device!</p>

<p>So my design would be the following:</p>

<pre><code>struct DeviceDescriptor
{
  int portNumber;
  // add additional variables to identify the device
}

class Device
{
  Device(DeviceDescriptor descriptor)
  {
    //Insert your initialization...
    //You can maintain a static vector of already opened Devices to throw an
    //error if an allready opened device is reopened
  }
  ~Device()
  {
    //Deinit device
  }

  // A device should not be copyable
  Device(const&amp; Device) = delete;
  //TODO do the same for copy assignment
  //TODO implement move ctr and move assignment operator

  //TODO add needed mamber variables
}

class LEDBoard
{
  LEDBoard(std::shared_ptr&lt;Device&gt; device) : m_device(device)
  {
    //Do init stuff
  }

  //Your functions

  private:
  std::shared_ptr&lt;Device&gt; m_device;
}

 //ADCBoard is analog to LEDBoard
</code></pre>

<p>You can use the classes like this:</p>

<pre><code>int main(void)
{
   auto device = std::make_shared&lt;Device&gt;(DeviceDescriptor());
   LEDBoard led1(device);
   ADCBoard adc1(device);
   //Your stuff...
}
</code></pre>

<p>Benefits:</p>

<ul>
<li>You can have multiple Devices</li>
<li>More LEDBoards can be added easily</li>
<li>By the use of shared_ptr, the device object will be destoryed when the last LEDBoard/ADCBoard is destroyed     </li>
</ul>
",,30575610,90
24801440,2,24800937,2014-07-17T10:44:05.677,0,,3368201,,2014-07-17T19:48:45.120,2014-07-17T19:48:45.120,2,,"<p>So you want to stay in the function statTemp() until time T has passed?
Then something like this might work</p>

<pre><code>void statTemp(){
    unsigned long currentMillis;
    unsigned long enteringMillis = millis();
    while (((currentMillis = millis()) -enteringMillis) &lt; T)
    {
        if(currentMillis - previousMillis &gt; ttemp){
        etc etc etc....
    }
    return ;
}
</code></pre>

<p>Notice the MIGHT. I don't know if millis is updated at every timer interrupt or just in the loop function; in the latter case, you will be stuck forever in the function.</p>

<p>Consequently i suggest you not to do this, but think at another approach: an FSM which handles the function to be executed. It's a cleaner way to proceed and less error-prone.</p>

<p>Bye</p>

<p>EDIT:
Here is a complete working example. In this example, the function <code>myfunc</code> is executed for 10 seconds; during this time the board performs some actions (in this example serial output). When 10 seconds pass, the program goes on, thus repeating the loop function.</p>

<pre><code>unsigned long previousTime;
void myfunc();

void setup() {                
  Serial.begin(9600);     
}

void loop() {
  Serial.println(""I'm in the loop function"");
  myfunc();
}

void myfunc()
{
  unsigned long currentTime;
  unsigned long enteringTime = millis();
  while(((currentTime = millis()) - enteringTime) &lt; 10000)
  {
    if(currentTime - previousTime &gt; 1000)
    {
      previousTime = currentTime;
      Serial.println(""I'm in the custom function"");
    }
  }
}
</code></pre>

<p>HOWEVER my suggestion is still the same: instead of blocking the execution inside of a function, use a finite state machine; it's much more flexible and easier to understand, implement and edit.</p>
",,30581285,422
24816837,2,24812235,2014-07-18T03:36:40.540,1,,3695794,,2014-07-18T03:36:40.540,,0,,"<p>Just let the Xivley library do the work for you:</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;Xively.h&gt;

// MAC address for your Ethernet shield
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// Your Xively key to let you upload data
char xivelyKey[] = ""[Put your Key here]"";

// Define a datastream textual name 
char sensorId[] = ""TEMP_001"";

// Create as many datastreams you need (one in this case)
XivelyDatastream datastreams[] = {
  XivelyDatastream(sensorId, strlen(sensorId), DATASTREAM_FLOAT),
};

// Finally, wrap the datastreams into a feed
XivelyFeed feed([put your feed number here], datastreams, 1); // Where 1 is the number of datastreams we are wrapping

// Create a Etherent client
EthernetClient client;

// Let Xively know about the Ethernet client
XivelyClient xivelyclient(client);


// Run all the setup you need
void setup(void) {
  Serial.begin(9600);
  while (Ethernet.begin(mac) != 1){
    Serial.println(""Error getting IP address via DHCP, trying again..."");
    delay(15000);
  }
}


// Loop over
void loop(void) {

  // Read your sensor
  float celsius = [put your sensor reading value here];

  // Copy sensor reading to the apropriate datastream
  datastreams[0].setFloat(celsius);

  // Ask Xively lib to PUT all datastreams values at once
  int ret = xivelyclient.put(feed, xivelyKey);

  // Printout PUT result
  Serial.print(""xivelyclient.put returned "");
  Serial.println(ret);

  // Wait 10 sec.
  delay(10000);  
}
</code></pre>
",,30586884,882
24849787,2,24849124,2014-07-20T10:56:40.930,0,,3639886,,2014-07-20T10:56:40.930,,0,,"<p>hi I noticed that you have used the C ""else if"" statements in your loop() function however you have not finished with an else statement </p>

<pre><code>if(boolean_expression 1)
{
   /* Executes when the boolean expression 1 is true */
}
else if( boolean_expression 2)
{
   /* Executes when the boolean expression 2 is true */
}
else if( boolean_expression 3)
{
   /* Executes when the boolean expression 3 is true */
}
else 
{
   /* executes when the none of the above condition is true */
}
</code></pre>

<p>can you please try this, I do not have Arduino compiler installed </p>

<pre><code>void loop() 
{
  if(Serial.available() &gt; 0)
  {
    str = Serial.readStringUntil(' ');
    //x = Serial.parseInt();
    //Serial.println(str);
    if(str.equals (data))
    {
      Serial.println(""Access Granted. "");
      calfunc();
    }

    if(str.equals(data2))
    {
      digitalWrite(5, HIGH);
      digitalWrite(13, HIGH);
      Serial.println(""Access Denied"");
    }
  }
  delay(100);
}
</code></pre>
",,30603334,268
24856497,2,24856173,2014-07-21T01:17:37.960,0,,20862,,2014-07-21T01:17:37.960,,0,,"<p>This goes in your makefile:</p>

<pre><code>TARGET?=DEPLOY

all: build ...

build:
\tgcc ... -D$(TARGET) ...

.PHONY: all build ...
</code></pre>

<p>This goes in your source code:</p>

<pre><code>#ifdef DEPLOY
#include ""defs_deploy.h""
#else
#ifdef HOME
#include ""defs_home.h""
#else
#error Neither DEPLOY nor HOME is defined
#endif /* HOME */
#endif /* DEPLOY */
</code></pre>

<p>One of these goes on your command line:</p>

<pre><code>make TARGET=DEPLOY
make TARGET=HOME
</code></pre>

<p>Not pretty, but it will work.</p>
",,30609696,159
24900505,2,24871420,2014-07-23T01:35:41.190,1,,30997,,2014-07-23T01:35:41.190,,0,,"<p>You should look at the internal pull-up resistors on the Arduino. You can debounce the signal from your button entirely with software:</p>

<pre><code>void setup() {
    pinMode(2, INPUT_PULLUP);
}

void loop() {
  if (digitalRead(2) == LOW)  // NOTE THAT PULLUPS REVERSE YOUR LOGIC
  {
    delay(1000);  //wait 1 second
    digitalWrite(13, HIGH);
    delay(1000);                
    digitalWrite(13, LOW);  
  }
}
</code></pre>
",,30640748,1177
24878760,2,24878529,2014-07-22T04:09:09.967,1,,3386109,,2014-07-22T04:09:09.967,,1,,"<p>You're getting tripped up by pointer arithmetic.  Consider the snippet <code>&amp;header+(i*BLOCK_SIZE)</code>.  What you evidently expect to happen is that you'll get some address, let's call it <code>addr</code>, and then add some small number to it to calculate a new address, i.e.</p>

<pre><code>finalAddress = addr + (i * 8);
</code></pre>

<p>But because <code>&amp;header</code> is a pointer to a <code>struct HEADER</code>, the actual calculation the compiler does is</p>

<pre><code>finalAddress = addr + (sizeof(struct HEADER) * i * 8);
</code></pre>

<p>The result is an address that's well beyond the end of the header for any <code>i</code> greater than 0.  The same thing is happening with <code>&amp;buff+(i*8)</code>, since <code>&amp;buff</code> is a pointer to 32 bytes.</p>

<p>To solve the problem, I recommend using intermediate variables that are <code>char *</code>, e.g.</p>

<pre><code>char *headAddress = (char *)&amp;header;
char *buffAddress = (char *)&amp;buff;
for (uint32_t i = 0; i &lt; 4; i++)
{
    memcpy(data, headAddress+(i*BLOCK_SIZE), BLOCK_SIZE);
    xteaEncrypt((uint32_t*)data);
    memcpy(&amp;buffAddress+(i*BLOCK_SIZE), data, BLOCK_SIZE);
}
</code></pre>
",,30686789,142
24900212,2,24883961,2014-07-23T00:55:45.263,8,,30997,,2014-07-23T00:55:45.263,,0,,"<p>You have a few options. You can have the caller provide the buffer that will be used to store the return value:</p>

<pre><code>void foo0(char * buf, int maxBufferSize) {
  while(maxBufferSize &amp;&amp; *buf = getByteFromSerial()) { //assumes getByte returns 0 for done
    maxBufferSize--;
  }
}  // If you really feel like it, you can alter this to return the original buf
</code></pre>

<p>You can have the method itself maintain a buffer that it uses for return values:</p>

<pre><code>char * foo1() {
  static char buf[BUF_SIZE+1];
  int copiedBytes = 0;
  while (copiedBytes&lt;BUF_SIZE &amp;&amp; buf[copiedBytes++] = getByteFromSerial());
  buf[copiedBytes] = '\0';
  return buf;   // Note that when you call foo() again, this will be destroyed.
}
</code></pre>

<p>You can have the method allocate the buffer:</p>

<pre><code>char * foo2() {
   static char buf[BUF_SIZE+1];
   // do all the stuff from the previous version
   char * retval = malloc(copiedBytes);
   strcpy(retval, buf);
   return retval;
 }
</code></pre>

<p>This last solution has a number of problems. Yeah, you have to remember to deallocate, but worse than that, dynamic memory allocation on something with so little memory should scare the hell out of you. For details, look up memory fragmentation. Come to think of it, I've NEVER used malloc on a microprocessor for exactly this reason. When there's so little memory available, you can probably come up with better ways to dynamically assign memory yourself.</p>

<p>My preference is for having the caller provide the buffer. This way, any necessary allocation and deallocation is neatly taken care of on the stack and you don't have the multiple-callers problem that foo1(), above, would stick you with.</p>

<pre><code>void someFunction() {
  char buf[BUFF_SIZE+1];
  fillMyBuffer(buf, BUFF_SIZE);
  doSomethingWithMyBuffer(buf);
}
</code></pre>

<p>This way, when someFunction returns, its buffer is no longer taking up memory and I don't have a function in my program that has a static buffer taking up space that may only be used very infrequently. </p>
",,30708800,1339
24991392,2,24991358,2014-07-28T08:42:25.640,1,,841108,,2014-07-28T08:50:25.540,2017-05-23T12:08:45.180,4,,"<p><code>GetLocalTime</code> is not a usual Linux function.</p>

<p>Read <a href=""http://man7.org/linux/man-pages/man7/time.7.html"" rel=""nofollow noreferrer"">time(7)</a>, you probably want <a href=""http://man7.org/linux/man-pages/man2/clock_gettime.2.html"" rel=""nofollow noreferrer"">clock_gettime(2)</a>, or (as commented by <a href=""https://stackoverflow.com/users/440558/joachim-pileborg"">Joachim Pileborg</a>), the older <a href=""http://man7.org/linux/man-pages/man2/gettimeofday.2.html"" rel=""nofollow noreferrer"">gettimeofday(2)</a></p>

<p>If you need some <code>struct</code> giving all of hours, minutes, seconds, milliseconds you have to code that yourself using <a href=""http://man7.org/linux/man-pages/man3/localtime.3.html"" rel=""nofollow noreferrer"">localtime(3)</a> and explicitly computing the millisecond part.</p>

<p>Something like the below code is printing the time with milliseconds</p>

<pre><code> struct timespec ts = {0,0};
 struct tm tm = {};
 char timbuf[64];
 if (clock_gettime(CLOCK_REALTIME, &amp;ts))
    { perror(""clock_gettime""), exit(EXIT_FAILURE);};
 time_t tim = ts.tv_sec;
 if (localtime(&amp;tim, &amp;tm))
    { perror(""localtime""), exit(EXIT_FAILURE);};
 if (strftime(timbuf, sizeof(timbuf), ""%D %T"", &amp;tm))
     { perror(""strftime""), exit(EXIT_FAILURE);};
 printf(""%s.%03d\n"", timbuf, (int)(ts.tv_nsec/1000000));
</code></pre>
",,30755994,41
24996105,2,24994433,2014-07-28T13:13:12.813,1,,3074564,,2014-07-28T13:13:12.813,,0,,"<p>Example 1 on how to convert a byte to a hexadecimal, null terminated string:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
   unsigned int uValue;
   unsigned int uNibble;

   char sHexByte[3];
   sHexByte[2] = '\0';

   const char csHexChars[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };

   for (uValue = 0; uValue &lt; 256U; uValue++)
   {
      uNibble = (uValue &amp; 0xFFU) &gt;&gt; 4U;
      sHexByte[0] = csHexChars[uNibble];
      uNibble = uValue &amp; 0x0FU;
      sHexByte[1] = csHexChars[uNibble];

      if (uValue &gt; 0) putchar(':');
      fputs(sHexByte,stdout);
   }
   putchar('\n');

   /* Dummy code to have no warnings on build. */
   if(argv[0][1] == ' ') return argc;
   return 0;
}
</code></pre>

<p>This method is usually faster than the second example below.</p>

<p>Example 2 on how to convert a byte to a hexadecimal, null terminated string:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
   unsigned int uValue;
   unsigned int uNibble;

   char sHexByte[3];
   sHexByte[2] = '\0';

   for (uValue = 0; uValue &lt; 256U; uValue++)
   {
      uNibble = (uValue &amp; 0xFFU) &gt;&gt; 4U;
      sHexByte[0] = (uNibble &lt; 10) ? uNibble + '0' : uNibble + ('A' - 10U);
      uNibble = (uValue &amp; 0x0FU);
      sHexByte[1] = (uNibble &lt; 10) ? uNibble + '0' : uNibble + ('A' - 10U);

      if (uValue &gt; 0) putchar(':');
      fputs(sHexByte,stdout);
   }
   putchar('\n');

   /* Dummy code to have no warnings on build. */
   if(argv[0][1] == ' ') return argc;
   return 0;
}
</code></pre>
",,30756790,177
24997820,2,24994433,2014-07-28T14:44:47.200,2,,645128,,2014-07-28T15:21:21.870,2014-07-28T15:21:21.870,0,,"<p>First, a <code>char</code> is <em>one byte</em> in size.  In memory, a char <em>is</em> a byte, <em>and</em> is an integer value that can be depicted in hexadecimal form.  If I understand your request <em>convert Byte to Hex char and then print it</em>, here is a simple example showing how to do that:  </p>

<pre><code>int main(void)
{
    char byte[10]={2,23,76,125,43,65,78,37,19,84};
    char string[160];
    int i;
    for(i=0;i&lt;sizeof(byte)/sizeof(*byte);i++)
    {
        printf(""0x%02x, "", byte[i]);
    }
    printf(""\n"");

    //Placing elements into a string:  
    sprintf(string, ""Null Terminated String:\n0x%02x, 0x%02x, 0x%02x,0x%02x, 0x%02x,""
                    ""0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x\n"",
                     byte[0], byte[1], byte[2], byte[3], byte[4],
                     byte[5], byte[6], byte[7], byte[8], byte[9]);
    printf(""%s"", string);//null terminated string
    getchar();
    return 0;   
}  
</code></pre>

<p>This code simply formats the integer values stored in the char array to a hexadecimal as they are printed, then uses <code>sprintf()</code> to place the values into a NULL terminated <code>char</code> array (C string) and prints that out also.  The output  is:  </p>

<p><img src=""https://i.stack.imgur.com/nrzhj.jpg"" alt=""enter image description here""></p>
",,30766975,87
25029533,2,24994433,2014-07-30T05:40:29.570,1,,1008923,,2014-07-30T05:40:29.570,,0,,"<pre><code>unsigned char firstNibble=0U;  // a Nibble is 4 bits, half a byte, one hexadecimal character
char firstHexChar=0;
unsigned char initialByte;  //initialize this to the byte you want to print
unsigned char secondNibble=0U;
char secondHexChar=0;


firstNibble=(initialByte&gt;&gt;4);  // isolate first 4 bits

if(firstNibble&lt;10U)
{
     firstHexChar=(char)('0'+firstNibble);
}
else
{
     firstNibble-=10U;
     firstHexChar=(char)('A'+firstNibble);
}

secondNibble=(initialByte&amp;0x0F);  // isolate last 4 bits

if(secondNibble&lt;10U)
{
     secondHexChar=(char)('0'+secondNibble);
}
else
{
     secondNibble-=10U;
     secondHexChar=(char)('A'+secondNibble);
}

printf(""%c%c\n"", firstHexChar, secondHexChar);
</code></pre>
",,30805621,5653
33882825,2,24997433,2015-11-23T23:34:25.507,2,,2916761,,2015-11-23T23:44:06.700,2015-11-23T23:44:06.700,2,,"<p>I'm not sure if you're ok with it never going into sleep mode in the first place, but this is what I use:</p>

<pre><code>sudo leafpad /etc/kbd/config
    change BLANK_TIME=0
    change POWERDOWN_TIME=0
sudo leafpad /etc/xdg/lxsession/LXDE-pi/autostart
    Add line: @xset s noblank
    Add line: @xset s off
    Add line: @xset -dpms
</code></pre>

<p><strong>Edit</strong> Just realized how old this question was. I hope I ended your 20 months of waiting and page refreshing.</p>
",,30806085,1087
25013059,2,25012460,2014-07-29T10:21:41.697,1,,2077479,,2014-07-29T10:21:41.697,,0,,"<p><strong>SOLUTION</strong></p>

<p>so here is my solution thank everyone.</p>

<pre><code>  String a = String(msg[0]);
  String b = String(msg[1]);
  String c = a + "","" + b;
  char* d;
  c.toCharArray(d,c.length());

  mclient.publish(""topic1/sensorAck"",d);
</code></pre>
",,30849421,402
25017747,2,25015459,2014-07-29T14:23:00.447,1,,3116708,,2014-07-29T14:23:00.447,,0,,"<p>There is a String class in Arduino that you can use.
In your case</p>

<pre><code>String trackName = ""track"";
track += currentTrack;
if (currentTrack &lt; 9) {
    track += currentTrack;
}
else {
    track += ""0"";
    track += currentTrack;
}
track += "".mp3"";
playMP3(trackName);
</code></pre>

<p>There are other String manipulation methods in the String class that may be useful. See <a href=""http://arduino.cc/en/Reference/StringObject"" rel=""nofollow"">http://arduino.cc/en/Reference/StringObject</a></p>
",,30855330,116
25032303,2,25031731,2014-07-30T08:41:17.327,3,,3852513,,2014-07-30T08:41:17.327,,10,,"<p>In your <code>void Motor::run()</code>
you are filling your <code>_currentTime</code> with <code>millis()</code>
But it is giving you the time since the arduino started and NOT since the <code>Effect::runEffect()</code> started. So it could be already higher than the duration of your first effect.
Try to store the actual starting time when you first call <code>runEffect()</code> and use it as an offset for your <code>_currentTime</code></p>

<p>For example in your <code>runMotor()</code></p>

<pre><code>void Motor::runMotor()
{
       if(_firstRun == true)
       {
           _startTime = millis();
           _firstRun = false;
       }

       ...your code...

       _currentTime = millis() - _startTime;

       ...your code...
}
</code></pre>

<p>That is just what i noticed. Try it that first. If i does not help come back and say so.</p>
",,30858032,579
25033748,2,25033308,2014-07-30T09:50:39.717,0,,3150853,,2014-07-30T09:50:39.717,,2,,"<p>I assuming you want something like this</p>

<pre><code>#define MAX_VAL 10
int arrvalues[MAX_VAL] = {0,10,20,30,40,50,60,70,80,90};
</code></pre>

<p>Now you can write like using <code>for..loop</code></p>

<pre><code>int i;
for ( i = 0; i &lt; MAX_VAL ; ++i )
   EEPROM.write ( i, arrvalues[ i ] );
</code></pre>

<p>using <code>while...loop</code></p>

<pre><code>int i=0;
while(i&lt;MAX_VAL){
   EEPROM.write ( i, arrvalues[ i ] );
   i++;
  }
</code></pre>
",,30858500,1724
25084801,2,25072586,2014-08-01T16:33:21.237,2,,1484189,,2014-08-01T16:33:21.237,,4,,"<p>It works! Ran through a simple program this AM to test:</p>

<pre><code>#include &lt;stlport.h&gt;
#include &lt;Eigen30.h&gt;

using Eigen::MatrixXd;

MatrixXd m(2, 2);

void setup()
{
     Serial.begin(115200);

  /* add setup code here */
     m(0, 0) = 3;
     m(1, 0) = 2.5;
     m(0, 1) = -1;
     m(1, 1) = m(1, 0) + m(0, 1);

}

void loop()
{

  /* add main program code here */
     Serial.println(m(1,1));
     delay(2000);
}
</code></pre>

<p>You're right about bloat, though, as this sketch was >5 KB.</p>
",,30871851,1143
25093050,2,25092986,2014-08-02T08:11:39.917,5,,661519,,2014-08-02T08:33:18.250,2014-08-02T08:33:18.250,8,,"<p>The problem is that in <code>Program::data()</code>, <code>buff</code> is a local variable. You are returning a pointer to its first element, which is a dangling pointer at the call side. You need to ensure the buffer you export is something that stays alive for long enough. There are different ways of doing this, but I am not entirely familiar with the limitations arduino places on what parts of the C and C++ standard libraries you can use. </p>

<p>The simplest approach could be to reserve a buffer in <code>main</code>, and pass that around to the code that populates it and consumes it. Alternatively, you could give your <code>Program</code> class a buffer data member. The main problem is going to be ensuring that the buffer is large enough for different messages.</p>

<p>I would first try something like this:</p>

<pre><code>void create_msg_(const char* name, uint8_t buff, size_t size)
{
  // populate buff with the message
}

void send_msg(const char* name)
{
  size_t size = strlen(name) + 2;
  uint8_t buff[size]; // VLA extension, not std C++
  create_msg_(name, buff, size);
  BTLEserial.write(buff, size);
}
</code></pre>
",,30943229,927
25100989,2,25100957,2014-08-03T02:10:48.013,5,,3553031,,2014-08-03T04:46:06.943,2014-08-03T04:46:06.943,7,,"<p>As written, that won't compile because <code>pins</code> doesn't have a defined size and assigning an array to another array of a different size is not allowed.  However, you can use a pointer to an array to achieve what you appear to be attempting:</p>

<pre><code>int one[] = {1,2};
int four[] = {1,2,3,4};
int* pins = nullptr; // use NULL if your compiler doesn't support C++11.
size_t pinslen = 0;

switch (num) {
case 1:
    pins = one;
    pinslen = sizeof one;
    break;
case 4:
    pins = four;
    pinslen = sizeof four;
    break;
}
</code></pre>
",,31075798,3973
25102718,2,25100957,2014-08-03T07:53:09.063,1,,2684539,,2014-08-03T08:07:08.733,2014-08-03T08:07:08.733,1,,"<p><code>int one[] = {1,2};</code>, <code>int four[] = {1,2,3,4};</code> are not the same type, we have <code>int one[2]</code> and <code>int four[4]</code>. They both may decay to <code>int*</code> but you loose the size information and should keep the size on your own.</p>

<p>A possibility is to use <code>std::vector</code> as follow:</p>

<pre><code>std::vector&lt;int&gt; one = {1, 2};
std::vector&lt;int&gt; four = {1, 2, 3, 4};
std::vector&lt;int&gt;* pins = nullptr;
switch (num) {
    case 1: pins = &amp;one; break;
    case 4: pins = &amp;four; break;
}
</code></pre>

<p>And for C++03:</p>

<pre><code>const int c_one[] = {1, 2};
const int c_four[] = {1, 2, 3, 4};
std::vector&lt;int&gt; one(c_one, c_one + 2);
std::vector&lt;int&gt; four(c_four, c_four + 4);
std::vector&lt;int&gt;* pins = 0;// or NULL
switch (num) {
    case 1: pins = &amp;one; break;
    case 4: pins = &amp;four; break;
}
</code></pre>

<p>Alternatively, you may want to copy in pins and don't use pointer, something like:</p>

<pre><code>const int one[] = {1, 2};
const int four[] = {1, 2, 3, 4};
std::vector&lt;int&gt; pins;
switch (num) {
    case 1: pins.assign(one, one + 2); break;
    case 4: pins.assign(four, four + 4); break;
}
</code></pre>
",,31094177,4210
25109494,2,25109415,2014-08-03T21:54:09.877,-1,,1660022,,2014-08-03T21:54:09.877,,2,,"<p>You just assign the <code>payload</code> pointer to point to the constant string, you do not copy the string to what it currently points to.</p>

<p>In order to copy the string you need to use strcpy or memcpy:</p>

<pre><code>char *bigPacket = malloc(25);
bigPacket[0] = bigpacket[1] = 72;

strcpy( bigpacket+2, ""Hello, World"");

print( bigPacket );
</code></pre>

<p>Note that this is rather unlikely to save memory, since ""Hello, world"" will exist as a constant string in your code, to save memory it is probably most efficient to call print multiple times.</p>

<p>However, I guess that is not possible in this case.</p>
",,31103000,355
25153311,2,25153153,2014-08-06T06:08:33.443,6,,616460,,2014-08-06T06:18:11.160,2014-08-06T06:18:11.160,6,,"<p>You have to actually allocate the array; and you'll want to use a pointer type, <code>float array[]</code> is not what you think there. As juanchopanza reminds us, you'll also want to either disable the copy constructor and assignment operator, or implement ones that do a proper deep copy.</p>

<pre><code>//Inside Header
class runningAverage{
    private:
        byte n;
        float *array; // &lt;= correct type
    public:
        runningAverage(byte);
        ~runningAverage(); // &lt;= you'll need a destructor to cleanup
    private:
        runningAverage(const runningAverage &amp;);
        runningAverage &amp; operator = (const runningAverage &amp;);
};

//Inside .cpp
runningAverage::runningAverage(byte a){
    array = new float[n]; // &lt;= allocate array
    n = a;
    for (byte i = 0; i&lt;n; i++) {
        array[i] = 0;
    }
}

// clean up
runningAverage::~runningAverage(){
    delete[] array;
}
</code></pre>

<p>However, if you have some dynamic, automatic container at your disposal (e.g. <code>std::vector</code>) you might want to use that instead - then you don't have to deal with copy / assignment / destructor / memory management.</p>
",,31165566,1937
25153423,2,25153153,2014-08-06T06:18:13.560,3,,3780453,,2014-08-06T06:18:13.560,,4,,"<p>If you only know the size at runtime, Jason C's answer is what you want. ( With juanchopanzas comment )</p>

<p>If the size is known at compile time, you can use templates:</p>

<pre><code>template &lt; int SIZE &gt;
class runningAverage
{
    float array [ SIZE ];
};

runningAverage &lt; 10 &gt; ra;
</code></pre>

<p>Or use classes like <code>std::array</code> instead of <code>std::vector</code>.</p>
",,31175395,138
25164269,2,25164002,2014-08-06T15:23:44.607,0,,3896566,,2014-08-06T15:23:44.607,,0,,"<p>Without seeing how the rest of your code is set up, I would try having windturncounter as a global variable, and add another integer that is iterated every second your main program loops. Then:</p>

<pre><code>// in the main loop
if(iteratorVariable &gt;= 5){
  iteratorVariable = 0;
  // take your windreading and implement logic here
} else {
  iteratorVariable++;
}
</code></pre>

<p>I'm not sure how your anemometer stores data or what other challenges you might be facing, so this may not be a 100% solution, but it would allow you to run the logic from your original post every five seconds.</p>
",,31200835,855
25174645,2,25170821,2014-08-07T05:13:38.963,1,,1927972,,2014-08-07T05:13:38.963,,2,,"<blockquote>
  <p>What should I do?</p>
</blockquote>

<p>Use your code as shown without any of the volatile and be happy :)</p>

<p>The volatile keyword is only a hint to the compiler that a variable might change by unseen paths.  If a simple variable was modified only by the ISR, then it would not hurt to mark volatile.  Such a mark could prevent the compiler from doing the wrong thing with code like this:</p>

<pre><code>volatile int n = 0;

ISR(TIMER1_COMPA_vect) {
    n = 1;
}


void loop() {

    n = 0;

    // At this point the tricky compiler might think 
    // ""n must be zero, why do this comparison?""
    // it might also think,
    // ""hey, I've got the value of n still sitting in a
    // register, I don't even have to read it from memory
    // The volatile keyword says ""stop thinking""

    if(n == 1) {
      // do something when ISR() occurred just before if()
      // a very small window, but it would eventually happen
      n = 0;
    }

 }
</code></pre>

<p>For your object, it is only about whether the changes introduced by the ISR cause variable changes that other users of the object might not see.  If the PID object is consuming the input and the only driver of the outputs via compute() there isn't an issue.  In other words, the changes in compute() are not affecting the main loop()</p>

<p>The bigger concern should be consistency which is not fixed with <strong>volatile</strong>.  If <strong>setpoint</strong> is a 32 bit integer then the value in memory cannot change atomically.  The main loop() might have an innocent line</p>

<pre><code>setpoint = setpoint + 20;
</code></pre>

<p>But this involves getting the value from memory into a register, performing the math and writing back out.  At any clock tick in the process, the interrupt may occur.  Exactly in the middle of storing the new value of <strong>setpoint</strong> to memory, the interrupt might occur (will occur eventually).</p>

<p>You protect this by disabling the interrupts in the main loop() while accessing the shared object.</p>

<pre><code>nointerrupts()
setpoint = setpoint + 20;
interrupts()
</code></pre>

<p>Now you are ensured that the interrupt will not occur at the exact worst moment and execute compute() on a broken value of setpoint.</p>
",,31204950,393
25185398,2,25184611,2014-08-07T14:41:17.570,3,,2194336,,2014-08-07T14:44:42.953,2017-05-23T12:24:14.883,4,,"<p>As described in the comments post you can not simply swap arrays in such fasion the article describing what arrays in C++ actually are <a href=""https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c"">How do I use arrays in C++?</a>. In order to swap the pointers like you want you should create the two private arrays and the pointers to them.</p>

<p>So for instance:</p>

<pre><code>private: 
    uint8_t array1[WIDTH][HEIGHT];
    uint8_t array2[WIDTH][HEIGHT];
    uint8_t (*nextState)[WIDTH][HEIGHT];
    uint8_t (*prevState)[WIDTH][HEIGHT];
</code></pre>

<p>now if you base every operation on the pointers to nextState and prevState you can swap them as you described. Note that it will not work with 2d arrays as they are not the pointers but the types (as described in the reference article).</p>
",,31221212,794
25185476,2,25184611,2014-08-07T14:45:01.857,-1,,3817250,,2014-08-07T15:24:21.977,2014-08-07T15:24:21.977,0,,"<pre><code>#define WIDTH 10
#define HEIGHT 12

#include &lt;stdint.h&gt;

uint8_t arr1[WIDTH][HEIGHT];
uint8_t arr2[WIDTH][HEIGHT];
uint8_t (*currState)[WIDTH][HEIGHT];
uint8_t (*nextState)[WIDTH][HEIGHT];

void copyArray(uint8_t ar1[WIDTH][HEIGHT], uint8_t ar2[WIDTH][HEIGHT]) {
    uint8_t i,j;
    for (i=0; i&lt;WIDTH; i++) {
        for (j=0; j&lt;HEIGHT; j++) {
            ar1[i][j] = ar2[i][j];
        }
    }
}

int main(void) {
    currState = &amp;arr1;
    nextState = &amp;arr2;

    uint8_t tempState[WIDTH][HEIGHT];

    copyArray(tempState, *currState);
    currState = nextState;
    nextState = &amp;tempState;

    return 0;
}
</code></pre>
",,31246457,156
25215446,2,25213457,2014-08-09T05:17:37.353,1,,840992,,2014-08-09T05:23:30.590,2014-08-09T05:23:30.590,5,,"<p>You're on your way but you are getting tangled a bit in variables.</p>

<p>It can be simpler: just one global variable and one conditional check.</p>

<pre><code>int lastRead = -1; // init to value outside of possible range

void setup()
{
  Serial.begin(9600);
}

void loop() {

  // get current value
  int currentRead = analogRead(0);

  //compare and only print if !=
  if (currentRead != lastRead){
   lastRead = currentRead; // store
   Serial.println(lastRead);
  }
}
</code></pre>
",,31373909,84
25215500,2,25213457,2014-08-09T05:27:41.893,2,,1927972,,2014-08-09T05:27:41.893,,0,,"<p>That is really close.  This line is your mistake</p>

<pre><code>int flag=potValue;
</code></pre>

<p>As written, that creates a new local variable <em>flag</em>.  The local variable hides the global variable.  So the comparison is always to itself and never fails.  Change the line to :</p>

<pre><code>flag=potValue;
</code></pre>

<p>and your program will function as desired.</p>

<p>You can save some memory and code space like this:</p>

<pre><code>int g_lastValue = 0;

void loop() {

  int nowValue = analogRead(A0);

  if (nowValue != g_lastValue) {
    Serial.println(nowValue);
    g_lastValue = nowValue;
  }
  ...
}
</code></pre>

<p>The use of g_ as name prefix is a cue that a variable is global.  I use this naming convention as it helps when reading a function to know variables that are not local.  Without a name cue, you need to scan the entire function body to see if there is a variable declaration present, and only by looking through the function and <strong>not</strong> finding a declaration can you know the variable must be global.  On small functions, not really an issue, but as your code grows, you may want some self documentation a naming convention provides.</p>
",,31374104,54
25219783,2,25219647,2014-08-09T14:52:35.037,2,,752261,,2015-05-25T16:24:45.833,2015-05-25T16:24:45.833,2,,"<p>The below code creates an array of your groups and then iterates through it, invoking a call to a Foo method for each of your instantiations (foo[0-8]). It makes a few assumptions about the contents of the arrays involved (namely the bounds on i and j), but it should do for the example, and should be easy enough to customize to your liking:</p>

<pre><code>#include &lt;iostream&gt;

// Example Foo class (instantiated with foo[0-8]).
class Foo
{
    public:

        Foo(int x)
        {
            bar = x;
        }

        void FooMethod()
        {
            std::cout &lt;&lt; bar &lt;&lt; std::endl;
        }

    private:

        int bar;
};

int main(int argc, char* argv[])
{
    // Instantiate foo[0-8].
    Foo foo0 = Foo(0);
    Foo foo1 = Foo(1);
    Foo foo2 = Foo(2);
    Foo foo3 = Foo(3);
    Foo foo4 = Foo(4);
    Foo foo5 = Foo(5);
    Foo foo6 = Foo(6);
    Foo foo7 = Foo(7);
    Foo foo8 = Foo(8);

    // Declare Foo group arrays of, type Foo*.
    Foo* group0[] = { &amp;foo0, &amp;foo1, &amp;foo2 };
    Foo* group1[] = { &amp;foo3, &amp;foo4, &amp;foo5 };
    Foo* group2[] = { &amp;foo6, &amp;foo7, &amp;foo8 };

    // Declare Foo* group array to hold Foo groups, of type Foo**.
    Foo** groups[] = { group0, group1, group2 };

    // Iterate through Foo groups and over each individual Foo object.
    for (int i = 0; i &lt; 3; ++i)
    {
        for (int j = 0; j &lt; 3; ++j)
        {
            // Do something with Foo (i.e. invoke its member method).
            groups[i][j]-&gt;FooMethod();
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>0
1
2
3
4
5
6
7
8
</code></pre>

<p>I hope that this answers your question. Let me know if it doesn't, and I'll see what I can do :)</p>
",,31409029,1055
25219817,2,25219647,2014-08-09T14:58:01.437,0,,2098932,,2014-08-09T14:58:01.437,,0,,"<pre><code>Foo** list[] = {group0, group1, group2};
Foo** pGroup;

for(int i = 0; 3 &lt; i; ++i)
{
  pGroup = list[i]; // Ptr to one of the groups
}
</code></pre>

<p>And then just dereference pGroup to get at the group elements</p>
",,31413593,2690
25266180,2,25263989,2014-08-12T13:56:29.167,3,,3826372,,2014-08-12T13:56:29.167,,4,,"<p>The buffer you're allocating for the message is 1 byte to short. The total length of all the constant strings you're adding is 29, but you also need to add one more byte for the <code>'\0'</code> character that <code>strcat</code> will terminate the string with. </p>

<p>If you run the following code it shows you that concatenated length of all the string literals is <code>30</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

int
main() {
    printf(""%d\n"", (int) sizeof(""FROM: &lt;"" ""&gt;\r\n""
                                ""TO: &lt;"" ""&gt;\r\n""
                                ""SUBJECT: "" ""\r\n""));
}
</code></pre>

<p>There are two other problem with the message. One is that you're not putting a blank line between the headers and the message as required. The other is that you're not terminating the final line of the message with <code>\r\n</code>. This might confuse the curl library as it will need to add the end of line terminator itself. If it doesn't the message won't be sent through SMTP correctly.</p>
",,31447841,207
25322128,2,25316654,2014-08-15T06:27:13.943,0,,2647380,,2014-08-15T06:27:13.943,,0,,"<p>If you use Werkzeug, you can take a look at this snippet <a href=""http://flask.pocoo.org/snippets/67/"" rel=""nofollow"">http://flask.pocoo.org/snippets/67/</a> to create a shutdown method and call it after your first request.</p>

<pre><code>from flask import request

def shutdown_server():
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    func()
</code></pre>
",,31451153,298
25318457,2,25318312,2014-08-14T22:19:07.260,0,,2877241,,2014-08-14T22:35:11.207,2014-08-14T22:35:11.207,8,,"<p>First of all there is no such constructions as</p>

<pre><code>Serial.print(MyStuff[1], HEX);
</code></pre>

<p>in C. except as it was pointed out by <strong>Jashaszun</strong>  Serial is an instance of a structure and print is its data member (function pointer). But usually names of instances are written in lower case letters. So it looks like you are using C++.</p>

<p>If you will substitute this call for simple printf( ""%d"", MyStuff[1] ) you will get the correct value.
So the problem is in this construction that is in function pointed by <code>print</code></p>

<pre><code>Serial.print(MyStuff[1], HEX);
</code></pre>

<p>Here is a demonstrative code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

#define MY_BYTES 0x26,0x28,0X1B,0X52,0X07,0X62,0X62 


int main(void) 
{
    uint8_t a[] = {MY_BYTES};
    int i;

    for ( i = 0; i &lt; sizeof( a ) / sizeof( *a ); i++ ) printf( ""%d "", a[i] );
    puts( """" );

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>38 40 27 82 7 98 98 
</code></pre>
",,31454905,2107
25320837,2,25320790,2014-08-15T03:25:36.363,9,,187690,,2014-08-15T03:54:06.513,2014-08-15T03:54:06.513,6,,"<p>Just add <code>const</code>. This </p>

<pre><code>extern const BitChar BitFont[];
...
const BitChar BitFont[] = {
    B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,2, // 32 - Space
    B10000000,B10000000,B10000000,B10000000,B10000000,B00000000,B10000000,B00000000,1, // 33 - !
    ...
    B00000000,B00000000,B11100000,B11100000,B11100000,B00000000,B00000000,B00000000,3, // 127 - Unknown
};
</code></pre>

<p>should work perfectly fine in C. (Assuming that your compiler knows what these <code>B00000000</code> identifiers mean.)</p>

<p>This will also work perfectly fine in C++. The only potential for error in the C++ version is based on C++-specific properties of <code>const</code>.  If the definition does not see the declaration, then you have to specify the explicit <code>extern</code> in the definition as well</p>

<pre><code>extern const BitChar BitFont[] = {
    B00000000
    ...
</code></pre>

<p>because in C++ <code>const</code> objects have <em>internal</em> linkage by default. However, if the declaration already contains the <code>extern</code> and the definition can see the declaration, then that <code>extern</code> in the definition is optional.</p>

<p>The error message you quoted suggests that somewhere in your code you are trying to initialize a reference of type <code>BitChar &amp;</code> (aka <code>unsigned char (&amp;)[9]</code>) with a const-qualified <code>BitChar</code> array. This will not work, since it violates the basic rules of const-correctness. The reference has to become const-qualified as well, i.e. it has to change to <code>const BitChar &amp;</code> (aka <code>const unsigned char (&amp;)[9]</code>).</p>
",,31496332,872
25328164,2,25320790,2014-08-15T14:22:43.853,1,,1899801,,2014-08-15T14:22:43.853,,2,,"<p>Please note that the CONST's will still consume RAM space. For large constant arrays you may want to consider placing them into program space (aka Flash or non-volatile space). Below is an example.</p>

<pre><code>const uint8_t BitFont[] PROGMEM = {
    B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,2, // 32 - Space
    B10000000,B10000000,B10000000,B10000000,B10000000,B00000000,B10000000,B00000000,1, // 33 - !
    B00000000,B00000000,B11100000,B11100000,B11100000,B00000000,B00000000,B00000000,3, // 127 - Unknown
};
#define BITFONT_X_SIZE (sizeof(BitFont)/sizeof(BitFont[0]))

void setup() {
  Serial.println("""");
  Serial.print(F(""BitFont[] = ""));
  for(int y = 0 ; y &lt; BITFONT_X_SIZE ; y++) {
    Serial.print(pgm_read_byte_near( &amp;(BitFont[1]) ) );
    Serial.print(F("",""));
  }
  Serial.println("""");
}
</code></pre>

<p>Note there are THREE things happening. First the PROGMEM macro is used by the avr-gcc to link this into program space. Second the pgm_read_byte_near function is used to read the pointer from program space. As it requires the use of a special opcode, to read program space.</p>

<p>Third and not directly related to your example, but similar is the F() function used in Serial.print()'s which likewise places the constant string into program space. Otherwise strings within the Serial.print consume static ram. </p>

<hr>

<p>Alternatively you can create a matrix</p>

<pre><code>#define BRICK_COLUMNS 9
const uint8_t BitFont[][BRICK_COLUMNS] PROGMEM = {
    {B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,2}, // 32 - Space
    {B10000000,B10000000,B10000000,B10000000,B10000000,B00000000,B10000000,B00000000,1}, // 33 - !
    {B00000000,B00000000,B11100000,B11100000,B11100000,B00000000,B00000000,B00000000,3} // 127 - Unknown
};
#define BITFONT_X_SIZE (sizeof(BitFont)/sizeof(BitFont[0]))

void setup() {
  Serial.println("""");

  for(int x = 0 ; x &lt; BITFONT_X_SIZE ; x++) {
    Serial.print(F(""BitFont[""));
    Serial.print(x);
    Serial.print(F(""][y] = ""));
    for(int y = 0 ; y &lt; BRICK_COLUMNS ; y++) {
      Serial.print(pgm_read_byte_near ( &amp;(BitFont[1]) ));
      Serial.print(F("",""));
    }
    Serial.println("""");
  }
  Serial.println("""");
}
</code></pre>
",,31507840,303
25325074,2,25324817,2014-08-15T10:42:03.140,0,,1941161,,2014-08-15T11:23:42.920,2017-05-23T10:33:32.417,1,,"<p>If I understand correctly and you want to have some sort of white list of prefixes. 
You could use <a href=""http://en.cppreference.com/w/cpp/algorithm/remove"" rel=""nofollow noreferrer""><code>remove_if</code></a> to look for them, and use a small function to check whether one of the prefixes fits(using <a href=""http://en.cppreference.com/w/cpp/algorithm/mismatch"" rel=""nofollow noreferrer""><code>mismatch</code></a> like <a href=""https://stackoverflow.com/a/7913978/1941161"">here</a>) for example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;

int main() {
    list&lt;string&gt; l = {""aab"", ""aac"", ""abb"", ""123"", ""aaw"", ""wws""};
    list&lt;string&gt; whiteList = {""aa"", ""ab""};
    auto end = remove_if(l.begin(), l.end(), [&amp;whiteList](string item)
        {
            for(auto &amp;s : whiteList)
            {
                auto res = mismatch(s.begin(), s.end(), item.begin());
                if (res.first == s.end()){
                    return false; //found allowed prefix
                }
            }
            return true; 
        });
    for (auto it = l.begin(); it != end; ++it){
        cout&lt;&lt; *it &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>(<a href=""http://ideone.com/wG6aL1"" rel=""nofollow noreferrer"">demo</a>)</p>
",,31630888,838
25344516,2,25344250,2014-08-16T22:20:48.930,0,,3807729,,2014-08-16T22:20:48.930,,0,,"<p>Your line <code>static int* link[6]; // array of pointers</code> inside your class definition is only a <em>declaration</em> because it is static. You need to ad a <em>definition</em> outside the class in a source file (not a header): <code>int* Scenario::link[6];</code></p>

<p>Something like this:</p>

<pre><code>struct led
{
    int fade;
};

led led1;

// put this in a header file Scenario.h
class Scenario
{

public:
    int byte; // byte of the eeprom
    static int* link[6]; // array of pointers (DECLARATION)

    Scenario(int byteI) // constructor of the class
    {

        byte = byteI;
        link[0] = &amp;led1.fade;
    }
};

// put this in a source file Scenario.cpp
int* Scenario::link[6]; // (DEFINITION)

// make sure you link Scenario.o along with your main object file
int main()
{
    Scenario s(4);
}
</code></pre>
",,31634631,2499
25578588,2,25578490,2014-08-30T02:56:08.073,0,,3991948,,2014-08-30T02:56:08.073,,1,,"<p>The Array of Array of objects is often known as a matrix. You can imagine the matrix as a grid. This would be the fastest and most basic way to access all of your objects. To create a matrix declare it like below.</p>

<pre><code>int matrix[10][10];
</code></pre>

<p>Now fill each spot of the matrix with an object</p>

<pre><code>for(int row = 0; row&lt;10;row++){
     for(int column = 0; column&lt;10;column++){
          matrix[row][column] = Obj();
     }
}
</code></pre>

<p>Now that the matrix is filled you can access group 5 by a simple fast for loop</p>

<pre><code>for(int i = 0; i&lt;matrix[].length;i++){
   matrix[4] = _________
}
</code></pre>

<p>This would be the fastest and easiest way to attempt what you are doing. I hope this helps.</p>
",,31707629,339
25580526,2,25579757,2014-08-30T08:31:03.823,2,,1740065,,2014-08-30T08:55:58.383,2014-08-30T08:55:58.383,0,,"<p>If you change your code to a practical and simple 'helloworld.cpp' file and compile it with a GNU C++ compiler, you are warned about the problem with how you are currently returning a pointer to something on the heap that gets destroyed when getLat() goes out of scope:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* getLat();

int main(int argc, char **argv)
{
    char test[20] = {0};
    strncpy(test,getLat(),10);
    fprintf(stdout, ""%s\n"", test);
    return 1;
}

char* getLat(){
  char buffer[10] = {0};
  memset(buffer,0,sizeof(buffer));
  strcpy(buffer, ""Testycole"");
  // dtostrf(flat, 3, 6, buffer);
  // Serial.write(buffer);
  // Serial.print("" "");
  return buffer;
}
</code></pre>

<hr>

<p>Compiling:</p>

<pre><code>$ g++ file.cpp 
file.cpp: In function ‘char* getLat()’:
file.cpp:16:8: warning: address of local variable ‘buffer’ returned [-Wreturn-local-addr]
   char buffer[10] = {0};
</code></pre>

<hr>

<p>At runtime, I see garbage:</p>

<pre><code>$ a.out
 ��
</code></pre>

<hr>

<p>A quick fix, but not necessarily the best fix, is to allocate the buffer variable on the heap instead of within the scope of getLat().  Change GetLat() code like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char* getLat();

int main(int argc, char **argv)
{
    char test[20] = {0};
    char *heapBuffer = getLat();
    strncpy(test,heapBuffer,10);
    fprintf(stdout, ""%s\n"", test);
    //delete[] heapBuffer; // C++ deallocation; prevents memory leak.
    free(heapBuffer);    // C deallocation; prevents memory leak.

    return 1;
}


char* getLat(){
  //char *buffer = new char[10]; // C++ allocation
  char *buffer = (char*)malloc(10); // C allocation - to be a C purist.

  memset(buffer,0,sizeof(buffer));
  strcpy(buffer, ""Testycole"");
  // dtostrf(flat, 3, 6, buffer);
  // Serial.write(buffer);
  // Serial.print("" "");
  return buffer;
}
</code></pre>

<p>...this yields better results:</p>

<pre><code>$ a.out
Testycole
</code></pre>

<p>Don't forget that you have to deallocate the heap memory storing the char[10] buffer object after you finish with it, or you have yourself a memory leak. :-)</p>
",,31733726,1124
25669202,2,25588292,2014-09-04T15:18:26.760,0,,176958,,2014-09-04T15:18:26.760,,0,,"<p>You can use <a href=""https://github.com/mikalhart/TinyGPSPlus"" rel=""nofollow"">TinyGPS</a> to parse the NMEA strings. If you are interested in only 1 sentence. You can write a custom parser as below for that sentence only.</p>

<pre><code>int handle_byte(int byteGPS) {
buf[counter1] = byteGPS;
//Serial.print((char)byteGPS);
counter1++;
if (counter1 == 300) {
  return 0;
}

if (byteGPS == ',') {
    counter2++;
    offsets[counter2] = counter1;
    if (counter2 == 13) {
      return 0;
    }   }   if (byteGPS == '*') {
    offsets[12] = counter1;   }

  // Check if we got a &lt;LF&gt;, which indicates the end of line   if (byteGPS == 10) {

    // Check that we got 12 pieces, and that the first piece is 6 characters
    if (counter2 != 12 || (get_size(0) != 6)) {
      return 0;
    }

    // Check that we received $GPRMC
    // CMD buffer contains $GPRMC
    for (int j=0; j&lt;6; j++) {

      if (buf[j] != cmd[j]) {
        return 0;
      }
    }

    // Check that time is well formed
    if (get_size(1) != 10) {

      return 0;
    }

    // Check that date is well formed
    if (get_size(9) != 6) {
      return 0;
    }

    SeeedOled.setTextXY(7,0);
    for (int j=0; j&lt;6; j++) {
      SeeedOled.putChar(*(buf+offsets[1]+j));
    }
    SeeedOled.setTextXY(7,7);

    for (int j=0; j&lt;6; j++) {
      SeeedOled.putChar(*(buf+offsets[9]+j));
    }

    // TODO: compute and validate checksum

    // TODO: handle timezone offset

      return 0;   }   
return 1; }
</code></pre>
",,31749615,99
35033032,2,25588292,2016-01-27T09:11:05.723,0,,5696946,,2016-01-27T09:11:05.723,,0,,"<p>Try this which can help you</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
#include &lt;TinyGPS.h&gt;

TinyGPS gps;
SoftwareSerial ss(3,4);


static void smartdelay(unsigned long ms);
static void print_float(float val, float invalid, int len, int prec);
static void print_int(unsigned long val, unsigned long invalid, int len);
static void print_date(TinyGPS &amp;gps);
static void print_str(const char *str, int len);

void setup()
{
  Serial.begin(9600);
  ss.begin(9600);
}

void loop()
{
  float flat, flon;

  unsigned short sentences = 0, failed = 0;

  gps.f_get_position(&amp;flat, &amp;flon);
  Serial.print(""LATITUDE: "");
  print_float(flat, TinyGPS::GPS_INVALID_F_ANGLE, 10, 6);
  Serial.println("" "");
  Serial.print(""LONGITUDE: ""); 
  print_float(flon, TinyGPS::GPS_INVALID_F_ANGLE, 11, 6);
  Serial.println("" "");

  Serial.print(""altitude: "");
  print_float(gps.f_altitude(), TinyGPS::GPS_INVALID_F_ALTITUDE, 7, 2);
  Serial.println("" "");
  Serial.print(""COURSE:"");
  print_float(gps.f_course(), TinyGPS::GPS_INVALID_F_ANGLE, 7, 2);
  Serial.println("""");

  Serial.print(""DIRECTION: "");
  int d;
  print_str(gps.f_course() == TinyGPS::GPS_INVALID_F_ANGLE ? ""*** "" : TinyGPS::cardinal(gps.f_course()), 6);
  d=gps.f_course(); 
  Serial.println();
  Serial.println();
  smartdelay(1000);    

}

static void smartdelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (ss.available())
      gps.encode(ss.read());
  } while (millis() - start &lt; ms);
}

static void print_float(float val, float invalid, int len, int prec)
{
  if (val == invalid)
  {
    while (len-- &gt; 1)
      Serial.print('*');
    Serial.print(' ');
  }
  else
  {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val &lt; 0.0 ? 2 : 1); // . and -
    flen += vi &gt;= 1000 ? 4 : vi &gt;= 100 ? 3 : vi &gt;= 10 ? 2 : 1;
    for (int i=flen; i&lt;len; ++i)
      Serial.print(' ');
  }
  smartdelay(0);
}

static void print_int(unsigned long val, unsigned long invalid, int len)
{
  char sz[32];
  if (val == invalid)
    strcpy(sz, ""*******"");
  else
    sprintf(sz, ""%ld"", val);
  sz[len] = 0;
  for (int i=strlen(sz); i&lt;len; ++i)
    sz[i] = ' ';
  if (len &gt; 0) 
    sz[len-1] = ' ';
  Serial.print(sz);
  smartdelay(0);
}
static void print_str(const char *str, int len)
{
  int slen = strlen(str);
  for (int i=0; i&lt;len; ++i)
    Serial.print(i&lt;slen ? str[i] : ' ');
  smartdelay(0);
}
</code></pre>
",,31756504,842
48373540,2,25588292,2018-01-22T01:22:26.353,1,,9249185,,2018-01-22T01:45:35.523,2018-01-22T01:45:35.523,0,,"<p>NMEA data is in a  GPS-style (ddmm.ssss) format, Google wants it in Decimal Style (dd.mmssss), there is a coversion function at the bottom of the code for this step.</p>

<p>I wrote this because I don't like the large, complicated libraries to do simple little things, especially when I am trying to figure out how it works.
This parses the GLL sentence, but you can change the sentence it's looking for and rearrange the sections if needed.</p>

<pre><code>String ReadString;

void setup() {  
  Serial.begin(9600);  //Arduino serial monitor thru USB cable 
  Serial1.begin(9600); // Serial1 port connected to GPS
}

void loop() {  
  ReadString=Serial1.readStringUntil(13);   //NMEA data ends with 'return' character, which is ascii(13)
  ReadString.trim();                      // they say NMEA data starts with ""$"", but the Arduino doesn't think so.
  // Serial.println(ReadString);         //All the raw sentences will be sent to monitor, if you want them, maybe to see the labels and data order.

  //Start Parsing by finding data, put it in a string of character array, then removing it, leaving the rest of thes sentence for the next 'find'
   if (ReadString.startsWith(""$GPGLL"")) {   //I picked this sentence, you can pick any of the other labels and rearrange/add sections as needed. 
      Serial.println(ReadString);     // display raw GLL data in Serial Monitor
     // mine looks like this: ""$GPGLL,4053.16598,N,10458.93997,E,224431.00,A,D*7D""

//This section gets repeated for each delimeted bit of data by looking for the commas
     //Find Lattitude is first in GLL sentence, other senetences have data in different order
      int Pos=ReadString.indexOf(',');   //look for comma delimetrer
      ReadString.remove(0, Pos+1); // Remove Pos+1 characters starting at index=0, this one strips off ""$GPGLL"" in my sentence
      Pos=ReadString.indexOf(','); //looks for next comma delimetrer, which is now the first comma because I removed the first segment   
        char Lat[Pos];            //declare character array Lat with a size of the dbit of data
           for (int i=0; i &lt;= Pos-1; i++){    // load charcters into array
            Lat[i]=ReadString.charAt(i);           
           }   
            Serial.print(Lat);          // display raw latitude data in Serial Monitor, I'll use Lat again in a few lines for converting   
//repeating with a different char array variable        
       //Get Lattitude North or South
        ReadString.remove(0, Pos+1);               
        Pos=ReadString.indexOf(',');    
        char LatSide[Pos];           //declare different variable name
           for (int i=0; i &lt;= Pos-1; i++){
            LatSide[i]=ReadString.charAt(i);  //fill the array          
            Serial.println(LatSide[i]);       //display N or S
           }

          //convert the variable array Lat to degrees Google can use
          float LatAsFloat = atof (Lat);            //atof converts the char array to a float type
          float LatInDeg;
           if(LatSide[0]==char(78)) {        //char(69) is decimal for the letter ""N"" in ascii chart   
               LatInDeg= ConvertData(LatAsFloat);   //call the conversion funcion (see below) 
           }
           if(LatSide[0]==char(83)) {        //char(69) is decimal for the letter ""S"" in ascii chart   
               LatInDeg= -( ConvertData(LatAsFloat));   //call the conversion funcion (see below) 
           }
           Serial.println(LatInDeg,15); //display value Google can use in Serial Monitor, set decimal point value high
//repeating with a different char array variable               
       //Get Longitude
        ReadString.remove(0, Pos+1);               
        Pos=ReadString.indexOf(',');    
        char Longit[Pos];             //declare different variable name
           for (int i=0; i &lt;= Pos-1; i++){
            Longit[i]=ReadString.charAt(i);      //fill the array  
           }   
            Serial.print(Longit);      //display raw longitude data in Serial Monitor      
//repeating with a different char array variable 
            //Get Longitude East or West
        ReadString.remove(0, Pos+1);              
        Pos=ReadString.indexOf(',');    
        char LongitSide[Pos];         //declare different variable name
           for (int i=0; i &lt;= Pos-1; i++){
            LongitSide[i]=ReadString.charAt(i);      //fill the array          
            Serial.println(LongitSide[i]);        //display raw longitude data in Serial Monitor
           }       
           //convert to degrees Google can use  
          float LongitAsFloat = atof (Longit);    //atof converts the char array to a float type
          float LongInDeg;
         if(LongitSide[0]==char(69)) {        //char(69) is decimal for the letter ""E"" in ascii chart
                 LongInDeg=ConvertData(LongitAsFloat);   //call the conversion funcion (see below
         }    
         if(LongitSide[0]==char(87)) {         //char(87) is decimal for the letter ""W"" in ascii chart
                 LongInDeg=-(ConvertData(LongitAsFloat)); //call the conversion funcion (see below
         }             
           Serial.println(LongInDeg,15);  //display value Google can use in Serial Monitor, set decimal point value high
//repeating with a different char array variable 
            //Get TimeStamp - GMT
        ReadString.remove(0, Pos+1);                
        Pos=ReadString.indexOf(',');    
        char TimeStamp[Pos];          //declare different variable name
           for (int i=0; i &lt;= Pos-1; i++){
            TimeStamp[i]=ReadString.charAt(i);         //fill the array     
            }
           Serial.print(TimeStamp);   //display raw longitude data in Serial Monitor, GMT
           Serial.println("""");       
   }
}

//Conversion function
float ConvertData(float RawDegrees)
{ 
  float RawAsFloat = RawDegrees; 
  int firstdigits = ((int)RawAsFloat)/100; // Get the first digits by turning f into an integer, then doing an integer divide by 100;
  float nexttwodigits = RawAsFloat - (float)(firstdigits*100);
  float Converted = (float)(firstdigits + nexttwodigits/60.0);
  return Converted;
}
</code></pre>
",,31791902,579
25596662,2,25596640,2014-08-31T21:55:27.343,0,,2877241,,2014-08-31T21:55:27.343,,0,,"<p>If <code>String</code> is <code>std::string</code> then you can write</p>

<pre><code>std::string packetBufferString(packetBuffer);

//

packetBufferString.assign(packetBuffer);
</code></pre>

<p>or</p>

<pre><code>std::string packetBufferString(packetBuffer);

//

packetBufferString  = packetBuffer;
</code></pre>

<p>provided that <code>packetBuffer</code> is zero-terminated. Otherwise you can do the same (that is assigning) but using initial and ending iterators for <code>packetBuffer</code></p>
",,31865380,91
25613483,2,25601716,2014-09-01T22:15:20.517,6,,1927972,,2014-09-01T22:15:20.517,,0,,"<p>The best advice someone gave me for resource constrained embedded systems is:</p>

<blockquote>
  <p>Stay off the heap.</p>
</blockquote>

<p>You may not be leaking memory, you are likely just fragmenting it.  The program you show is allocating and deallocating structures on a FIFO queue.  That pattern has poor chance operating robustly.  When a second object is added to the heap and put on the queue, it has buried the first object on the heap.  When the head of the Q is processed, the code does delete() the first objects allocation, but that leaves a hole in memory.  If the third object cannot fit in the hole, then that third object moves to the unused space.</p>

<p>For any application that you intend to run a fixed task and hopefully run that forever, make one time memory allocations and reuse.  In other words, there is no operating system or huge runtime library to support your application: you must manage the memory.</p>

<p>Allocate a fixed pool of N objects</p>

<pre><code>struct OMessage {
  int scoutId;
  char message[50];
  int messageKey;
};

const int sizePool = 10;
OMessage pool[10];
int ixNext = 0;
int ixHead = -1;
</code></pre>

<p>This fixed allocation is now also your queue.  You manage the head and tail.  When you ""add"" and object to the queue, you fill in the structure and adjust the indexes:</p>

<pre><code>// detect full queue if ixNext = ixHead and reject addition
pool[ixNext].scoutId = ...
pool[ixNext].messageKey = ...
ixNext += 1;
ixNext = ixNext % sizePool;
</code></pre>

<p>When you ""pull"" and item from the queue, you just move the index:</p>

<pre><code>if(ixHead &gt;= 0) {
  do something with pool[ixHead]
  ixHead += 1;
  ixHead = ixHead % sizePool;
  // detect if head = tail and mark q empty
}
</code></pre>

<p>With the fixed memory allocation, as long as your program starts, you can be certain it will never run out of memory.</p>
",,31881095,187
25641539,2,25641314,2014-09-03T10:04:49.230,1,,2684539,,2014-09-03T12:12:23.413,2014-09-03T12:12:23.413,3,,"<p>You may use:</p>

<pre><code>byte (*(test[3]))[5]={&amp;A, &amp;B, &amp;gamma};

static_assert(5 == sizeof(*test[0]), ""unexpected size"");
</code></pre>

<p>But using <code>std::vector</code> would be simpler.</p>

<p>if the sizes of different arrays are different, you have to provide a way to know the size:</p>

<ul>
<li>Provide a sentinel value (as <code>'\0'</code> for C-string)</li>
<li><p>Give the length/size along the pointer, something like:</p>

<pre><code>std::pair&lt;byte*, std::size_t&gt; tests[] = {
    {A, sizeof(A)},
    {B, sizeof(B)},
    {gamma, sizeof(gamma)}
};
</code></pre></li>
</ul>
",,31933893,610
25755069,2,25754886,2014-09-09T23:27:24.907,0,,3723423,,2014-09-10T18:26:43.070,2014-09-10T18:26:43.070,2,,"<p>Here a piece of code to detect and remove CR+LF (Attention:  if A CR is read but it's not followed by a LF, it is removed as well):    </p>

<pre><code>   if (Serial.peek()==13) {      // check if CR (without reading)
       Serial.read();            // read and ignore 
       if (Serial.peek()==10)    // then check if LF (without reading)
          Serial.read(); 
       } 
</code></pre>

<p>To read the rest of the response from <a href=""http://arduino.cc/en/Reference/Serial"" rel=""nofollow"">Serial</a> you could use:  </p>

<pre><code>buffer[Serial.readBytesUntil(13, buffer, 199)]=0; // readbytes returns the number of bytes read  
</code></pre>

<p>You then have to discard the ending CRLF (same as above).  </p>

<p><strong>Edit</strong></p>

<p>There are several issues with the code that you've posted in a separate answer.  </p>

<p>When you <code>powerUpSim908()</code> you have to be aware that the gsm module may send unrequested data  (see documentation, chapter 1.4):  </p>

<blockquote>
  <p>Note: A HEX string such as ""00 49 49 49 49 FF FF FF FF"" will be sent
  out through serial port at the baud rate of 115200 immediately after
  SIM908 is powered on. The string shall be ignored since it is used for
  synchronization with PC tool. Only enter AT Command through serial
  port after SIM908 is powered on and Unsolicited Result Code ""RDY"" is
  received from serial port.</p>
</blockquote>

<p>This means that before you send anything, you have to discard this data by reading it.  I guess this is why you don't get  CRLF when reading the response:  you first get the HEX string or ""RDY"".  </p>

<p>Then <a href=""http://arduino.cc/en/Serial/ReadBytesUntil"" rel=""nofollow""><code>readBytesUntil()</code></a> reads as many bytes as available (maxi 199 in my example above), stores them in the buffer.  It stops reading when it encounters the byte 13 (i.e.CR).  There is no need to loop on an index.  The function returns the number of chars that could be read, and it doesn't put an ending 0 at the end of the buffer (i.e. no valid C string). If you want to use the function in another way than what I proposed, you must store the length returned, because you have no other way to find it out later on.     </p>
",,31968397,1537
25766320,2,25754886,2014-09-10T13:09:23.270,0,,1395480,,2014-09-10T15:48:40.340,2014-09-10T15:48:40.340,0,,"<p>It's very interresting what you show me. Here is how I adapt my code</p>

<p>I adapted my code and by the way I created a file for testing Serail while we send a AT command.
The concern function are loop() and read_AT_string(). (I renamed the read_String to read_AT_string().</p>

<p>Here my code and I explain, after the issue, regardin your proposal</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

int baud_rate = 9600;
int pin_gsm = 3;
int pin_gps = 4;
int pin_power = 5;
//int pin_dtr = 6;
boolean debug = true;
boolean raedy_to_go = false;

// Reading String
#define BUFFERSIZE 200
char buffer[BUFFERSIZE];
char inChar;
int index;

void setup()
{
  Serial.begin(baud_rate);
  delay(5000);                         // Wait for 5sec after begin

  if(debug)
  {
    Serial.println(F(""\n****************************""));
    Serial.println(F(""STARTING SYSTEM Read AT stream""));
    Serial.println(F(""******************************""));
  }
  pinMode(pin_gsm,OUTPUT);            // Set the pins
  pinMode(pin_gps,OUTPUT);
  pinMode(pin_power,OUTPUT);

  powerUpSim908:
  if(powerUpSim908())
  {
    delay(1000);

    if(gps_power()){

      gsm_enable();
      raedy_to_go = true;

      if(debug)
      {
        Serial.println(F(""\n****************************""));
        Serial.println(F(""READY TO GO\n""));
        Serial.println(F(""****************************\n""));
      }  
    }
    else
    {
      raedy_to_go = false;
      if(debug)
      {
       Serial.println(F(""\nNOT READY TO GO.\nGPS could not be power\nRestart the module\nor/and check the battery level.\n""));
      }
      goto powerUpSim908;
    }
  }
  else
  {
    raedy_to_go = false;
    if(debug)
    {
      Serial.println(F(""\nNOT READY TO GO.\nCheck the battery level.\n""));
    } 
  };
}

void loop()
{
  /*
   if (Serial.available())
   {
     Serial.print(""Character received: "");
     Serial.write(Serial.read());
     Serial.println("""");
   }
   */
    if(raedy_to_go)
    {

       read_AT_string(""AT"",5000);
       delay(10000);

    }  

}

char read_AT_string(char* command, int timeout)
{
  unsigned long previous;
  previous = millis();


  Serial.println(F(""\nDISPLAY BUFFER:""));
  index=0;

  Serial.println(command);
  do
  {
    if(Serial.available() &gt; 0) // Don't read unless
    // there you know there is data
    {
      Serial.println(""1"");
      if (Serial.peek() == 13)           // check if CR (without reading)
      {      
        Serial.println(""13"");
        if(Serial.available() &gt; 0)
        {
        Serial.read();                // read and ignore 
        if (Serial.peek()==10)        // then check if LF (without reading)
         {
           Serial.println(""10"");
           if(index &lt; Serial.readBytesUntil(13, buffer, BUFFERSIZE-1))   // One less than the size of the buffer array
            {
              Serial.println(""b"");
              inChar = Serial.read();  // Read a character
              buffer[index] = inChar;  // Store it
              index++;                 // Increment where to write next
              buffer[index] = '\0';    // Null terminate the string
            }
          }
         }
      }
    }
  }while(((millis() - previous) &lt; timeout));

  Serial.println(buffer);
  buffer[0]='\0';
  Serial.println(F(""END DISPLAY BUFFER""));
}

/* FUNCTION */

boolean powerUpSim908(void)
{
  if(debug)
  {
    Serial.println(F(""Powering up SIM908""));  
  }
  boolean turnedON = false;
  //uint8_t answer=0;
  int cont;

  for (cont=0; cont&lt;3; cont++)
  {
    digitalWrite(pin_power,HIGH);
    delay(1500);
    digitalWrite(pin_power,LOW);

    Serial.println(F(""Checking if the module is up""));
    if(sendATcommand(""AT"", ""OK"", 5000))
    {
    cont = 4; // Leave the loop
    turnedON = true;
    }
    else
    {
      turnedON = false;
      if(debug)
      {
    Serial.println(F(""\nTrying agin to turn on SIM908""));  
      }
    };
  }

  if(turnedON)
  {
    if(debug)
    {
      Serial.println(F(""Module is tunrned up\n""));
    }
  }
  else
  {
      if(debug)
      {
    Serial.println(F(""Module is NOT tunrned ON\n""));  
      }
   }    
    return turnedON;
}

boolean sendATcommand(char* ATcommand, char* expected_answer, unsigned int timeout)
{
    uint8_t x=0;
    bool answer=false;
    //åchar response[100];
    //buffer[0]='\0';
    unsigned long previous;

    //memset(response, '\0', 100);    // Initialice the string
    //Serial.println(response);

    delay(100);

    while( Serial.available() &gt; 0) Serial.read();    // Clean the input buffer

    if (ATcommand[0] != '\0')
    { 
        Serial.println(ATcommand);    // Send the AT command   
    }

    x = 0;
    previous = millis();

    index=0;
    do
    {
      if(Serial.available() &gt; 0) 
      // there you know there is data
      {
        if(index &lt; BUFFERSIZE-1) // One less than the size of the array // Same as buffer size
        {
          inChar = Serial.read(); // Read a character
          buffer[index] = inChar; // Store it
          index++; // Increment where to write next
          //Serial.println(index);
          buffer[index] = '\0'; // Null terminate the string
        }
      }
    }while(((millis() - previous) &lt; timeout));


    if(strstr(buffer,""NORMAL POWER DOWN"") != NULL)
    {
       answer = false;
    }
    else if (strstr(buffer, expected_answer) != NULL)    // check if the desired answer (OK) is in the response of the module
    {

      /*
      Serial.println(F(""### BUFFER"")); 
      Serial.println(buffer);
      Serial.println(F(""### END BUFFER""));
      */
       answer = true;
    }
    else
    {
      answer = false;
    }   

    if(debug)
        {
          if(answer)
          {
            //Serial.println(F(""Expected answer : OK!\n""));
          }
          else
          {
            //Serial.println(F(""Expected answer : KO!\n""));
          };
  }     
  return answer;
}


void gps_enable(void)
{
  if(debug)
  {
    Serial.println(F(""\nEnabling GPS ...""));
  }
  digitalWrite(pin_gps,LOW);                //Enable GPS mode
  digitalWrite(pin_gsm,HIGH);                //Disable GSM mode
  delay(2000);
}



void gsm_enable(void)
{
  if(debug)
  {
    Serial.println(F(""\nEnabling GSM ...""));
  }
  digitalWrite(pin_gsm,LOW);                //Enable GSM mode
  digitalWrite(pin_gps,HIGH);               //Disable GPS mode
  delay(2000);
}


/* UTILISTIES */


/* GPS */

boolean gps_power(void)                            //turn on GPS power supply
{
  /*
  Serial.println(""AT"");  
  delay(2000);
  */

  boolean gpspwr = false;
  boolean gpsrst = false;


  if(sendATcommand(""AT+CGPSPWR=1"",""OK"",2000))
  {
    gpspwr = true;
     if(debug)
    {
      Serial.println(""turn on GPS power supply =&gt; OK"");
    }
  }
  else
  {
    if(debug)
    {
      Serial.println(""turn on GPS power supply =&gt; KO"");
    }
  }; 
  //delay(1000);

  if(sendATcommand(""AT+CGPSRST=1"",""OK"",2000))
  {
    gpsrst = true;
    if(debug)
    {
      Serial.println(""reset GPS in autonomy mode =&gt; OK"");
    }
  }
  else
  {
    if(debug)
    {
      Serial.println(""reset GPS in autonomy mode =&gt; KO"");
    }
  };   //reset GPS in autonomy mode

  delay(1000);

  if(gpspwr &amp;&amp; gpsrst)
  {
    return true;
  }else
  {
    return false;
  }
}
</code></pre>

<p>At the read_AT_string, the first if(Serial.peek()==13) always return false.</p>

<p>1 is printed, but '13' is not, then I supposed</p>

<pre><code>if(Serial.peek()==13)
</code></pre>

<p>return false</p>

<p>Here is what is printed within 5 sec</p>

<pre><code>AT DISPLAY BUFFER:
1 
1 
1 
1 
1 
1 
1 
1 
1 
[...] // It prints 1 until now 
1

END DISPLAY BUFFER
</code></pre>
",,32026391,680
25759391,2,25758753,2014-09-10T07:14:35.450,0,,3684343,,2014-09-11T11:49:20.170,2014-09-11T11:49:20.170,3,,"<p>2 possible solutions: create a thread, which checks the button and the original thread let the led blink. or you do the for loop faster and toggle the led only each 1000th iteration or so.</p>

<p>for example something like this:</p>

<pre><code>for (int x=0; x&lt;=100000;x++){
    //wait to make the 1024 iteration blinking visible
    BUTTON5_state = digitalRead(START_BUTTON);

    if (BUTTON5_state == HIGH ){
        break;
    }
    else if (x &amp; (1 &lt;&lt; 10)){ //each 1024th iteration
        toggleLed();
    }
}
</code></pre>
",,32037217,4463
25790852,2,25790633,2014-09-11T14:59:41.773,0,,4030973,,2018-02-14T01:26:32.220,2018-02-14T01:26:32.220,1,,"<p>Do you have access to the atoi function in your Arduino environment?</p>

<p>If not, you can just write some simple conversion code in there:</p>

<pre><code>int my_atoi(const char *s)
{
    int sign=1;
    if (*s == '-')
        sign = -1;
    s++;
    int num = 0;
    while(*s)
    {
        num = ((*s)-'0') + num*10;
        s++;
    }
    return num*sign;
}
</code></pre>
",,32063073,1189
34959006,2,25790633,2016-01-23T02:37:31.903,0,,5767681,,2016-01-23T02:37:31.903,,1,,"<p>String to Long Arduino IDE:</p>

<pre><code>    //stringToLong.h

    long stringToLong(String value) {
    long outLong=0;
        long inLong=1;
        int c = 0;
        int idx=value.length()-1;
        for(int i=0;i&lt;=idx;i++){

            c=(int)value[idx-i];
            outLong+=inLong*(c-48);
            inLong*=10;
        }
        return outLong;
    }
</code></pre>
",,32149483,394
25827521,2,25827193,2014-09-13T20:42:45.320,0,,1395480,,2014-09-13T20:48:44.173,2014-09-13T20:48:44.173,0,,"<p>I solve like this, but I am not satisfied.</p>

<pre><code>char* gps_read (void) {

  if(strstr(read_AT_string(""AT+CGPSINF=2"",3000),""OK"") != NULL)
  {
    Serial.println(F(""------- Show buffer------""));
    Serial.println(buffer);
    Serial.println(F(""-------------------------\n""));

    char fix[BUFFERSIZE];

    int z = 0;
    int y = 0;
    int w = 0;

    for(y=0; y &lt; BUFFERSIZE; y++)
    {
      if(buffer[y]==',') z++;

      if(z &gt; 0){
        if(buffer[y] == '\n'){
          fix[w-1]='\0';
          break;
        }

        fix[w] = buffer[y+1];
        w++;
      }

    }
    Serial.println(F(""------- Show Fix------""));
    Serial.println(fix);
    Serial.println(F(""----------------------""));

    return fix;
  }
  else
  {
    return ""Error : no fix"";
  }
}
</code></pre>

<p>It's not important of '2,' is not display. 
How would you do better?</p>
",,32193124,1944
30640671,2,25829174,2015-06-04T09:53:53.803,1,,4973153,,2015-06-05T10:27:24.073,2015-06-05T10:27:24.073,0,,"<p>UART data is sent only in ascii format...you have to convert the integer data  to ascii format..use itoa() or do this one</p>

<pre><code>int main(void)
 {
 unsigned char c;
 unsigned char b;

while(1)
{
    a = USART_Receive();
    c = 10;
    b=c;
    b=c/10;
    USART_Transmit(b+48);
    b=0;
    b=c%10;
    USART_Transmit(b+48);
    _delay(10000);
}
}
</code></pre>
",,32254044,1196
25853405,2,25838378,2014-09-15T17:19:11.160,1,,3368201,,2019-02-18T09:49:35.430,2019-02-18T09:49:35.430,3,,"<p>The problem is related to the signed/unsigned implicit cast.</p>

<p>With <code>uint32_t a = 0xFF &lt;&lt; 8;</code> you mean</p>

<ul>
<li><code>0xFF</code> is declared; it is a <code>signed char</code>;</li>
<li>There is a &lt;&lt; operation, so that variable is converted to int. Since it was a signed char (and so its value was -1) it is padded with 1, to preserve the sign. So the variable is <code>0xFFFFFFFF</code>;</li>
<li>it is shifted, so <code>a = 0xFFFFFF00</code>.</li>
</ul>

<blockquote>
  <p>NOTE: this is slightly wrong, see below for the ""more correct"" version</p>
</blockquote>

<p>If you want to reproduce the same behaviour, try this code:</p>

<pre><code>uint32_t a = 0xFF &lt;&lt; 8;
uint32_t b = (signed char)0xFF;
uint32_t c = b &lt;&lt; 8;

Serial.println(a, HEX);
Serial.println(b, HEX);
Serial.println(c, HEX);
</code></pre>

<p>The result is</p>

<pre><code>FFFFFF00
FFFFFFFF
FFFFFF00
</code></pre>

<p>Or, in the other way, if you write</p>

<pre><code>uint32_t a = (unsigned)0xFF &lt;&lt; 8;
</code></pre>

<p>you get that <code>a = 0x0000FF00</code>.</p>

<p>There are just two weird things with the compiler:</p>

<ol>
<li><code>uint32_t a = (unsigned char)0xFF &lt;&lt; 8;</code> returns a = 0xFFFFFF00</li>
<li><code>uint32_t a = 0x000000FF &lt;&lt; 8;</code> returns a = 0xFFFFFF00 too.</li>
</ol>

<p>Maybe it's a wrong cast in the compiler....</p>

<p>EDIT:</p>

<p>As phuclv pointed out, the above explanation is slightly wrong. The correct explanation is that, with <code>uint32_t a = 0xFF &lt;&lt; 8;</code>, the compiler does this operations:</p>

<ul>
<li><code>0xFF</code> is declared; it is an <code>int</code>;</li>
<li>There is a &lt;&lt; operation, and thus this becomes <code>0xFF00</code>; it was an int, so it is negative</li>
<li>it is then promoted to <code>uint32_t</code>. Since it was negative, <code>1</code>s are prepended, resulting in a <code>0xFFFFFF00</code></li>
</ul>

<p>The difference with the above explanation is that if you write <code>uint32_t a = 0xFF &lt;&lt; 7;</code> you get <code>0x7F80</code> rather than <code>0xFFFFFF80</code>.</p>

<p>This also explains the two ""weird"" things I wrote in the end of the previous answer.</p>

<p>For reference, in the <a href=""https://stackoverflow.com/questions/8108642/type-of-integer-literals-not-int-by-default"">thread linked in the comment</a> there are some more explanations on how the compiler interpretes literals. Particularly in <a href=""https://stackoverflow.com/a/8108715/3368201"">this answer</a> there is a table with the types the compiler assigns to the literals. In this case (no suffix, hexadecimal value) the compiler assigns this type, according to what is the smallest type that fits the value:</p>

<ol>
<li><code>int</code></li>
<li><code>unsigned int</code></li>
<li><code>long int</code></li>
<li><code>unsigned long int</code></li>
<li><code>long long int</code></li>
<li><code>unsigned long long int</code></li>
</ol>

<p>This leads to some more considerations:</p>

<ul>
<li><code>uint32_t a = 0x7FFF &lt;&lt; 8;</code> this means that the literal is interpreted as a signed integer; the promotion to the bigger integer extends the sign, and so the result is <code>0xFFFFFF00</code></li>
<li><code>uint32_t b = 0xFFFF &lt;&lt; 8;</code> the literal in this case is interpreted as an unsigned integer. The result of the promotion to the 32-bit integer is therefore <code>0x0000FF00</code></li>
</ul>
",,32277033,971
54734661,2,25838378,2019-02-17T15:20:02.783,0,,995714,,2019-02-17T15:20:02.783,,0,,"<p>The most important thing here is that in Arduino <strong>int is a 16-bit type</strong>. That'll explain everything</p>

<ol>
<li><p>For <code>uint32_t a = 0xFF &lt;&lt; 8</code>: 0xFF is of type <code>int</code><sup>1</sup>. <code>0xFF &lt;&lt; 8</code> results in 0xFF00 which is a signed negative value in 16-bit int<sup>2</sup>. When assigning the <code>int</code> value to a <code>uint32_t</code> variable again it'll be sign-extended <sup>3</sup> when upcasting, thus the result becomes <strong>0xFFFFFF00U</strong></p></li>
<li><p>For the following lines</p>

<pre><code>uint32_t b = 0xFF;
uint32_t c = b &lt;&lt; 8;
</code></pre>

<p>0xFF is <strong>positive</strong> in 16-bit int, therefore <code>b</code> also contains 0xFF. Then shifting it left 8 bits results in 0x0000FF00, because <code>b &lt;&lt; 8</code> is an <code>uint32_t</code> expression. It's wider than <code>int</code> so there's no promotion to <code>int</code> happening here</p></li>
</ol>

<p>Similarly with <code>uint32_t a = (unsigned)0xFF &lt;&lt; 8</code> the output is 0x0000FF00 because the positive 0xFF when converted to <code>unsigned int</code> is still positive. Upcasting <code>unsigned int</code> to <code>uint32_t</code> does a zero extension, but the sign bit is already zero so even if you do <code>int32_t b = 0xFF; uint32_t c = b &lt;&lt; 8</code> the high bits are still zero. Same to the <em>""weird""</em> <code>uint32_t a = 0x000000FF &lt;&lt; 8</code>. Instead of (unsigned)0xFF you can just use the exact equivalent version (but shorter) <code>0xFFU</code></p>

<p>OTOH if you declare b as <code>uint8_t b = 0xFF</code> or <code>int8_t b = 0xFF</code> then things will be different, integer promotion occurs and the result will be similar to the first line (0xFFFFFF00U). And if you cast 0xFF to <code>signed char</code> like this</p>

<pre><code>uint32_t b = (signed char)0xFF;
uint32_t c = b &lt;&lt; 8;
</code></pre>

<p>then upon promoting to int it'll be sign-extended to 0xFFFF. Similarly casting it to <code>int32_t</code> or <code>uint32_t</code> will result in a sign-extension from <code>signed char</code> to the 32-bit wide  value 0xFFFFFFFF</p>

<p>If you cast to <code>unsigned char</code> like in <code>uint32_t a = (unsigned char)0xFF &lt;&lt; 8;</code> instead then the <code>(unsigned char)0xFF</code> will be promoted to int using zero extension<sup>4</sup>, therefore the result will be exactly the same as <code>uint32_t a = 0xFF &lt;&lt; 8;</code></p>

<p><strong>In summary:</strong> When in doubt, consult the standard. The compiler rarely lies to you</p>

<hr>

<p><sup>1</sup> <a href=""https://stackoverflow.com/q/8108642/995714"">Type of integer literals not int by default?</a></p>

<blockquote>
  <p>The type of an integer constant is the first of the corresponding list in which its value can be represented.</p>
</blockquote>

<pre><code>Suffix      Decimal Constant          Octal or Hexadecimal Constant
-------------------------------------------------------------------
none        int                       int
            long int                  unsigned int
            long long int             long int
                                      unsigned long int
                                      long long int
                                      unsigned long long int
</code></pre>

<p><sup>2</sup> Strictly speaking shifting into sign bit like that is undefined behavior</p>

<ul>
<li><a href=""https://stackoverflow.com/q/26319592/995714"">1 &lt;&lt; 31 produces the error, &quot;The result of the &#39;&lt;&lt;&#39; expression is undefined&quot;</a></li>
<li><a href=""https://stackoverflow.com/a/41717899/995714"">Defining (1 &lt;&lt; 31) or using 0x80000000? Result is different</a></li>
</ul>

<p><sup>3</sup> The rule is to add UINT_MAX + 1</p>

<blockquote>
  <p>Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>
</blockquote>

<ul>
<li><a href=""https://stackoverflow.com/q/50605/995714"">Signed to unsigned conversion in C - is it always safe?</a></li>
</ul>

<p><sup>4</sup>A cast will always preserve the input value if the value fits in the target type, so casting a signed type to a wider signed type will be done by a sign-extension, and casting an unsigned type to a wider type will be done by a zero-extension</p>
",,32334757,746
25877604,2,25877510,2014-09-16T20:11:59.577,1,,1050844,,2014-09-16T20:32:46.953,2014-09-16T20:32:46.953,7,,"<pre><code>int sensorPin1 = A5;
int sensorPin2 = A4;
int ledPin2 = 7;
int ledPin1 = 8;
int moto = 12;
int sensorValue1last = 0;
int sensorValue2last = 0;

void setup() {
        Serial.begin(9600);
        pinMode(ledPin1, OUTPUT);
        pinMode(ledPin2, OUTPUT);
        pinMode(moto, OUTPUT);
        pinMode(sensorPin1, INPUT);
        pinMode(sensorPin2, INPUT);
        digitalWrite(ledPin1, HIGH);
        digitalWrite(ledPin2, HIGH);
        digitalWrite(moto, LOW);
}

int limit = 450;

void loop() {

    // read the value from the sensor:
    int sensorValue1 = analogRead(sensorPin1);
    int sensorValue2 = analogRead(sensorPin2);
    int sensorValue1a = analogRead(sensorPin1 - 2);
    int sensorValue2a = analogRead(sensorPin2 - 2);
    int diff1 = sensorValue1-sensorValue1last;
    int diff2 = sensorValue2-sensorValue2last;

    if ( sensorValue1 &gt; limit || diff1 &gt; 5 ) {
        digitalWrite(moto, LOW);
        digitalWrite(ledPin1, LOW);
        digitalWrite(ledPin2, HIGH);
        sensorValue1last = sensorValue1;
    }

    delay(0);

    if ( sensorValue2 &gt; limit || diff2 &gt; 5 ) {
        digitalWrite(moto, HIGH);
        digitalWrite(ledPin1, HIGH);
        digitalWrite(ledPin2, LOW);
        sensorValue2last = sensorValue2;
    }

    Serial.println(sensorValue1);
    // delay(100);

}
</code></pre>
",,32413959,2967
25938652,2,25936002,2014-09-19T16:40:24.187,3,,3837231,,2014-09-19T16:40:24.187,,0,,"<p>You have some miss match problems in the indexing of the code between C++ and python.</p>

<p>First, when working with bit operation it's much better to work with <code>unsigned types</code> (in this case would be unsigned char), because you avoid a lot of problem caused by sign extended when C++ need to convert to larger type.</p>

<p>The C++ version the only change I make was that, changing the input type to <code>unsigned char</code></p>

<pre class=""lang-cpp prettyprint-override""><code>void encodeManchester(unsigned char* input, unsigned char* output, int size)
</code></pre>

<p>The python version is:</p>

<pre class=""lang-python prettyprint-override""><code>def manDecode(data):
    ret = []
    for i in range(0, len(data)/2):
        ret.append(0b00000000);

        for p in range(0, 2):
            print(bin(data[i*2+p]));

            for j in range(0, 4):
                part = (data[i*2+p] &gt;&gt; (6-(j*2))) &amp; 0b11
                if part == 0b10:
                    ret[i] = ret[i] | (1 &lt;&lt; (j+(1-p)*4))
    return ret;
</code></pre>

<p>The change was in the line: <code>ret[i] = ret[i] | (1 &lt;&lt; (j+(1-p)*4))</code> check <strong>(1-p)</strong> instead of <strong>p</strong> this is needed because you are forming the number first the <code>high nible</code> then the <code>low nible</code> and in the first iteration with the previous version would be <code>ret[i] | (1 &lt;&lt; (0 + 0 * 4))</code> no shifting anything (changing the <code>low nible</code>)</p>
",,32417848,2760
25940485,2,25940073,2014-09-19T18:43:42.507,0,,1395480,,2014-09-19T18:43:42.507,,1,,"<p>I declare spliedString like this</p>

<pre><code>// SlitString
#define NBVALS 9
char *splitedString[NBVALS];
</code></pre>

<p>I have that function
splitString(""toto,+345,titi"",slitedString)</p>

<pre><code>void splitString(char *ligne, char **splitedString)
{

  char *p = ligne;

  int i = 0;
  splitedString[i++] = p;
  while (*p) {


    if (*p==',') {
      *p++ = '\0';
      if (i&lt;NBVALS){
         splitedString[i++] = p;
      }
    } 
    else
    {
      p++;
    }

  }
  while(i&lt;NBVALS){
    splitedString[i++] = p; 
  }
}
</code></pre>

<p>If I do a for with splitedString display, it display this</p>

<pre><code>for(int i=0;i&lt;4;i++){
Serialprint(i);Serial.print("":"");Serial.println(splitedString[i]);
}

//0:toto
//1:+4176112233
//2:14/09/19
</code></pre>

<p>I also declared and want to copy..</p>

<pre><code>char sms_who[15];
char sms_phone_number[15];
char sms_data[15];
//and I want to copy 
strcpy(sms_who,splitedString[0]
strcpy(sms_phone_number,splitedString[1]
strcpy(sms_date,splitedString[2]
</code></pre>

<p>I know, I am very confused with char and pointer * :o(</p>
",,32427630,21041
53192334,2,25940073,2018-11-07T15:15:37.197,0,,765827,,2018-11-07T15:15:37.197,,0,,"<p>Strings and Chars can be confusing for noobs, especially if you've used other languages that can be more flexible.</p>

<pre><code>char msg[40];  // creates an array 40 long that can contains characters
msg = 'a';     // this gives an error as 'a' is not 40 characters long 
(void) strcpy(msg, ""a"");              // but is fine : ""a""
(void) strcat(msg, ""b"");              // and this    : ""ab""
(void) sprintf(msg,""%s%c"",msg, 'c');  // and this    : ""abc""
</code></pre>

<p>HTH</p>
",,32523589,972
25948351,2,25948196,2014-09-20T11:38:59.240,0,,264325,,2014-09-21T13:27:00.993,2014-09-21T13:27:00.993,4,,"<p>I am answering only compile-time solution for the expression:</p>

<pre><code>Serial &lt;&lt; ""sdf"" &lt;&lt; var;
</code></pre>

<p>Assume <code>Serial</code> is a global instance of class. Let's say instance of class <code>DebugWriter</code>. This class has overloaded <code>operator &lt;&lt;</code>. Now, you can make another class <code>FakeDebugWriter</code>, which will also have <code>operator &lt;&lt;</code> implemented, but that would do nothing. Further, you can declare <code>Serial</code> instance as:</p>

<pre><code>#if CRIPWEB_DEBUG_BITS &amp; DEBUG_CMD
DebugWriter Serial;
#else
FakeDebugWriter Serial;
#endif
</code></pre>

<p>But it should be noted that <code>Serial&lt;&lt;</code> will still make call to function in case of <code>FakeDebugWriter</code> - though compiler may omit out the function call.</p>

<p>Therefore, it would be better to write debug-logging as function-style macro only. You can craft the macro has do some thing (or something heavy), and another as Do-nothing.</p>

<p>EDIT: After comment from OP. Here is analogues similar example.</p>

<pre><code>SmallInt a, b;
</code></pre>

<p>Where <code>SmallInt</code> would be type-defined, depending on value(s) of pre-processor macro (not macro macro).</p>

<pre><code>#if SomeCondition
typedef int SmallInt;
#else
typedef short SmallInt;
#endif
</code></pre>
",,32524483,339
25965004,2,25964731,2014-09-21T23:44:50.533,1,,1927972,,2014-09-21T23:44:50.533,,1,,"<p>The documentation on the website is misleading because they say <strong>string</strong> but the function prototype is (char).  A <strong>string</strong> is a variable length character array.  A <strong>char</strong> is a single character.  When in doubt, always believe the function declaration in the header file (.H).  From Stream.h:</p>

<pre><code>bool find(char *target);   // reads data from the stream until the target string is found
// returns true if target string is found, false if timed out (see setTimeout)

bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
// returns true if target string is found, false if timed out
</code></pre>

<p>With those in mind, there are two ways forward.  Search single characters:</p>

<pre><code>// method as you started - accepts terminators in either order
char charCr = 13;
char charNl = 10;

if (Serial.find(&amp;charCr, 1) &amp;&amp; Serial.find(&amp;charNl, 1))
</code></pre>

<p>or string form:</p>

<pre><code>char termseq1[] = {13, 10, 0};
char termseq2[] = {10, 13, 0};

if (Serial.find(termseq1) || Serial.find(termseq2))
</code></pre>
",,32528449,255
25984891,2,25982525,2014-09-23T00:04:17.697,9,,3826372,,2014-09-23T00:04:17.697,,7,,"<p>Here's the documentation for the Linux i2c interface: <a href=""https://www.kernel.org/doc/Documentation/i2c/dev-interface"" rel=""noreferrer"">https://www.kernel.org/doc/Documentation/i2c/dev-interface</a></p>

<p>At the simplest level you can use <code>ioctl(I2C_SLAVE)</code> to set the slave address and the <code>write</code> system call to write the command.  Something like:</p>

<pre><code>i2c_write(int file, int address, int subaddress, int size, char *data) {
    char buf[size + 1];               // note: variable length array
    ioctl(file, I2C_SLAVE, address);  // real code would need to check for an error
    buf[0] = subaddress;              // need to send everything in one call to write
    memcpy(buf + 1, data, size);      // so copy subaddress and data to a buffer 
    write(file, buf, size + 1); 
}
</code></pre>
",,32534928,1062
26083525,2,25985510,2014-09-28T09:32:23.133,0,,4087975,,2014-09-28T09:32:23.133,,0,,"<p><a href=""http://sixfortyfour.wordpress.com/2014/09/26/displaying-intel-galileo-ip-address-on-a-16x2-lcd/"" rel=""nofollow"">http://sixfortyfour.wordpress.com/2014/09/26/displaying-intel-galileo-ip-address-on-a-16x2-lcd/</a>
As a quick fix I modified Print.h and Stream.h, the files are located in {Galileo Project Folder}\packages\Microsoft.IoT.Galileo.Arduino.1.0.5\build\native\include. For Print.h I added:</p>

<pre><code>#ifndef _PRINT_H
#define _PRINT_H

class Print
{
// Rest of print class
}

#endif
</code></pre>

<p>For Stream.h I changed:</p>

<p><code>enter code here</code>class Stream : public Print -> class Stream</p>

<p>I checked the github repository and Print.h includes the changes, Stream.h still inherits from Print (<a href=""https://github.com/ms-iot/galileo-sdk/tree/develop/source"" rel=""nofollow"">https://github.com/ms-iot/galileo-sdk/tree/develop/source</a>).</p>

<p>I also modified RS, ENABLE, D0, D1, D2, D3 to match the LCD configuration I used for a netduino project.</p>
",,32594585,4472
26007685,2,26006250,2014-09-24T02:46:31.033,5,,4071096,,2014-09-24T12:34:51.377,2014-09-24T12:34:51.377,3,,"<p>I think the easiest approach would be to use the millis() function. Here's one example, but this will depend on how your control is operating.</p>

<pre><code>const int onTime=1000; // in ms
const int offTime=12000; // in ms
const int resistorPin=7; // Change as necessary
boolean currentlyOn=false;
unsigned long startTime;

void setup(){
  pinMode(resistorPin,OUTPUT);
  digitalWrite(resistorPin,LOW);
  startTime=millis(); // Initialize
}

void loop(){
  if (currentlyOn &amp;&amp; millis()&gt;startTime+onTime){ // Switch resistor off
    digitalWrite(resistorPin,LOW);
    currentlyOn=false;
    startTime=millis(); // Reset timer
  }
  if (!currentlyOn &amp;&amp; millis()&gt;startTime+offTime){ // Switch resistor on
    digitalWrite(resistorPin,HIGH);
    currentlyOn=true;
    startTime=millis(); // Reset timer
  }
  delay(10);
}
</code></pre>

<p>I have no idea if this is going to work as far as controlling the temperature, since I would expect there to be significant non-linearities involved in that, but at least the resistor would do what you want. If you really want to control the temperature, I would suggest a feedback loop in which you measure the temperature and adjust accordingly (maybe with a PID controller?). But that's of course much more complicated.</p>

<p>EDIT: A few additional thoughts:
The reason I suggested the millis()-based approach was because it allows you to have other code executing while you wait, making it more versatile. But if you don't need that, you can always just go super-simple and use delay():</p>

<pre><code>void loop(){
  digitalWrite(resistorPin,HIGH);
  delay(onTime);
  digitalWrite(resistorPin,LOW);
  delay(offTime);
}
</code></pre>

<p>Lastly, you could also just hook the resistor up to a PWM pin and use analogWrite() instead, keeping the resistor constantly activate at a low level.</p>
",,32596006,90
26051162,2,26048539,2014-09-26T02:32:37.070,0,,2041472,,2014-09-26T03:08:42.430,2014-09-26T03:08:42.430,0,,"<p>As far as I am aware &amp;&amp; in C is for logical comparison only.</p>

<pre><code>trafiksignal(redLed &amp;&amp; yellowLed, 1000);
</code></pre>

<p>What this line is basically doing is checking if redLed and yellowLed are true or false, and if they're both true it will send a 1 or if either are false it will send a 0. Since both of them are not 0 it should treat them as both true so you're actually most likely telling pin 1 to go high for 1 second instead of pin 3 and 4.</p>

<p>A few simple work around would be to either create a separate function for turning the red and yellow light off or putting a quick if clause inside trafiksignal functio. Bellow is a quick a dirty if statement to add to trafiksignal that should get you up and running with your current code.</p>

<pre><code>if (pin == 1) {
  digitalWrite(3, HIGH);
  digitalWrite(4, HIGH);
  delay(duration)
  digitalWrite(3, LOW);
  digitalWrite(4, LOW);
 }
else {
  digitalWrite(pin, HIGH);
  delay(duration);
  digitalWrite(pin, LOW);
}
</code></pre>

<p>Typed the code from my ipad so I would proof read it before copy and pasting. </p>

<p>edited from my computer:</p>

<p>A better solution would be to send the pins to the function as an array, i'm not super experienced in plain C so I'm not sure if what i've done bellow is 100% accurate but it should be fairly close.</p>

<pre><code>const byte greenLed = 2;
const byte yellowLed = 3;
const byte redLed = 4;
const byte redYellow[2] = {redLed, yellowLed} // create an array of 2 pins


void setup() {
pinMode(greenLed, OUTPUT);
pinMode(yellowLed, OUTPUT);
pinMode(redLed, OUTPUT);
}

    void loop() {
    // the middle number is the number of LEDs the function will need to control.
        trafiksignal(redLed, 1, 3000);
        trafiksignal(redYellow, 2, 1000);
        trafiksignal(greenLed, 1, 3000);
        trafiksignal(yellowLed, 1, 1000);
    }

    void trafiksignal(byte pin[], unsigned int numberOfLeds, unsigned int duration)
    {
      for (int i =0; i &lt; numberOfLeds; ++i {
        digitalWrite(pin[i], HIGH);
      }
        delay(duration);
       for (int i = 0; i &lt; numberOfLeds; ++i) {
        digitalWrite(pin[i], LOW);
       }
    }
</code></pre>
",,32597021,121
26087477,2,26085416,2014-09-28T17:18:26.043,1,,4071096,,2014-09-28T17:18:26.043,,0,,"<p>First off, using 'if' is more versatile than 'switch'. For example, if the value was 601, you'd still want the LED to flash, but your current code wouldn't do it.</p>

<p>What you need is a persistent variable that's defined outside of the functions. You can't define it in setup() or else it won't be recognized in loop(). You then look for changes in the values read from the switches, and adjust the variable accordingly. For example:</p>

<pre><code>int threshold=600;
int prevUp=LOW;
int prevDown=LOW;
const int increment=10;
const int flashPin=13;
const int upButtonPin=12;
const int downButtonPin=11;
const int micPin=0;

void setup() {
  pinMode(flashPin,OUTPUT);
  pinMode(upButtonPin,INPUT);
  pinMode(downButtonPin,INPUT);  
  digitalWrite(flashPin,LOW);
}

void loop() {
  int up=digitalRead(upButtonPin);
  int down=digitalRead(downButtonPin);
  if (up==HIGH &amp;&amp; prevUp==LOW) threshold+=increment;
  if (down=HIGH &amp;&amp; prevDown==LOW) threshold-=increment;
  threshold=constrain(threshold,0,1023);
  int (analogRead(micPin)&gt;=threshold){
    digitalWrite(flashPin, HIGH);
    delay(100);
    digitalWrite(flashPin, LOW);
  }
  prevUp=up;
  prevDown=down;
}
</code></pre>

<p>Note that how I've written it here, the threshold will reset to 600 each time the device is turned on. If you want the threshold to be persistent even when the device is unplugged, you'll need to use the Arduino's EEPROM. But that's more complicated. Let me know if you'd like me to get into it.</p>
",,32790982,74
28646733,2,26108643,2015-02-21T14:10:14.950,3,,2608152,,2015-02-21T14:52:34.493,2015-02-21T14:52:34.493,0,,"<p>You are using wrong structure. Y0u should use</p>

<pre><code>struct v4l2_streamparm
</code></pre>

<p>instead of</p>

<pre><code>struct v4l2_captureparm
</code></pre>

<p>First check if your camera does support those frame rates for desired resoulution and pixel format:</p>

<pre><code>v4l2-ctl --list-formats-ext
</code></pre>

<p>Then, you need to set resolution and pixel format. For example:</p>

<pre><code>struct v4l2_format fmt;
meset(&amp;fmt, 0, sizeof(fmt));
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width       = 1280;
fmt.fmt.pix.height      = 720;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;
fmt.fmt.pix.field       = V4L2_FIELD_NONE;

if (v4l2_ioctl(m_fd, VIDIOC_S_FMT, &amp;fmt) != 0)
{
   // Error
}
</code></pre>

<p>Ideally nominator and denominator should be selected from one enumerated from device. Also you should get v4l2_streamparm structure:</p>

<pre><code>struct v4l2_streamparm streamparm;
memset(&amp;streamparm, 0, sizeof(streamparm));
streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
if (v4l2_ioctl(m_fd, VIDIOC_G_PARM, &amp;streamparm) != 0)
{
   // Error
}

streamparm.parm.capture.capturemode |= V4L2_CAP_TIMEPERFRAME;
streamparm.timeperframe.numerator = X;
streamparm.timeperframe.denominator = y;
if(v4l2_ioctl(descriptor,VIDEO_S_PARM, &amp;s) !=0) 
{
     cout&lt;&lt; ""Failed to set frame rate ""&lt;&lt;endl;
}
</code></pre>
",,32867422,74
26217341,2,26110581,2014-10-06T13:31:22.930,1,,3925899,,2014-10-06T13:31:22.930,,3,,"<p>With SDL2 on Raspbian you can draw directly on a framebuffer without using X at all. The graphical window is always full screen. You can start the code from console mode (with X stopped or from LXDE with X running, the idea is that SDL2 won't use X).</p>

<p>Unfortunately, Raspbian doesn't come with SDL2 (the SDL2 from Jessie doesn't work) so you will need to build it yourself (takes about an hour). Here is a description of the process of building SDL2:</p>

<pre><code>sudo apt-get install build-essential libfreeimage-dev libopenal-dev libpango1.0-dev libsndfile-dev libudev-dev libasound2-dev
</code></pre>

<p>Download the sources for SDL2 from <a href=""https://www.libsdl.org/download-2.0.php"" rel=""nofollow"">https://www.libsdl.org/download-2.0.php</a> . Assuming that your downloaded file is called SDL2*.tar.gz, you can build and install it with:</p>

<pre><code>cd ~/Downloads
tar zxvf SDL2*.tar.gz
cd SDL2*

./configure --disable-video-x11
make
sudo make install
</code></pre>

<p>After that, you should be able to link any C++ program with SDL2, e.g:</p>

<pre><code>g++ my_program.cpp -lSDL2 -o my_program
./my_program
</code></pre>
",,32882361,103
43826514,2,26156076,2017-05-06T23:58:06.477,0,,7974677,,2017-05-07T00:18:40.263,2017-05-07T00:18:40.263,0,,"<p>I am late but - there is a function to do that. </p>

<p>Use: </p>

<pre><code>manager.setThisAddress(ID);

void RHDatagram::setThisAddress(uint8_t thisAddress)
{
    _driver.setThisAddress(thisAddress);
    // Use this address in the transmitted FROM header
    setHeaderFrom(thisAddress);
    _thisAddress = thisAddress;
}
</code></pre>
",,32900314,2615
26211166,2,26211084,2014-10-06T06:51:43.713,1,,14860,,2014-10-06T07:00:25.800,2014-10-06T07:00:25.800,1,,"<p>That will work fine, <em>provided</em> you declare the functions correctly:</p>

<pre><code>#include &lt;stdio.h&gt;

int functionOne(int x)   { return 1; }
int functionTwo(int x)   { return 2; }
int functionThree(int x) { return 3; }
int functionFour(int x)  { return 4; }
int functionFive(int x)  { return 5; }
int functionSix(int x)   { return 6; }

int (*functionsArray[2][3])(int x) = {
    {functionOne,  functionTwo,  functionThree},
    {functionFour, functionFive, functionSix}
};

int main (void) {
    printf (""%d\n"", (functionsArray[0][1])(99));
    printf (""%d\n"", (functionsArray[1][2])(99));
    return 0;
}
</code></pre>

<p>The output of that program is <code>2</code> and <code>6</code>.</p>

<hr>

<p>It will also work if you want <em>no</em> return value:</p>

<pre><code>#include &lt;stdio.h&gt;

void functionOne(int x)   { puts (""1""); }
void functionTwo(int x)   { puts (""2""); }
void functionThree(int x) { puts (""3""); }
void functionFour(int x)  { puts (""4""); }
void functionFive(int x)  { puts (""5""); }
void functionSix(int x)   { puts (""6""); }

void (*functionsArray[2][3])(int x) = {
    {functionOne,  functionTwo,  functionThree},
    {functionFour, functionFive, functionSix}
};

int main (void) {
    (functionsArray[0][1])(99);
    (functionsArray[1][2])(99);
    return 0;
}
</code></pre>

<p>That program <em>also</em> outputs <code>2</code> and <code>6</code>, as expected.</p>

<hr>

<p>It all comes down to ensuring that the function declarations match the type given in the array.</p>
",,32987397,159
26211230,2,26211084,2014-10-06T06:58:06.467,0,,434551,,2014-10-06T06:58:06.467,,0,,"<p>When you declare an array:</p>

<pre><code>int (*functionsArray[2][3])(int x) = 
{
   {functionOne,functionTwo,functionThree},
   {functionFour,functionFive,functionSix}
};
</code></pre>

<p>every element of the array has to be of type  <code>int (*)(int)</code>. Otherwise, the compiler correctly reports an error.</p>

<p>Take a simple case:</p>

<pre><code>void foo()
{
}

int (*fp)(int x) = foo;
</code></pre>

<p>should result in the same compiler error because you are trying to initialize a variable of type <code>int (*)(int)</code> using <code>foo</code>, whose type is <code>void (*)()</code>.</p>
",,32994710,775
26250629,2,26238307,2014-10-08T06:40:50.577,2,,4057102,,2014-10-08T06:40:50.577,,1,,"<p>Why not move the code that is for a connected client into the if statement where you connect. Then you do not need to poll the <code>client.connected()</code> function.</p>

<p>It seems the logic is flawed. If a client is connected, it will probably remain connected until the line you have below the loop: <code>client.close();</code> Which would cause the loop to never end.</p>

<p>Alternatively you could also add some code inside the loop to prevent it from running for ever.</p>

<pre><code>uint32_t theTime = millis();

while(client.connected()){
  if( ( millis() - theTime ) &gt;1000 ) break;  //exit loop after one second.
}
</code></pre>
",,33039930,53
26247693,2,26247353,2014-10-08T01:06:14.190,1,,908494,,2014-10-08T01:06:14.190,,0,,"<p>I'm willing to bet this is your problem:</p>

<p>Whatever your <code>client</code> object is, it's probably either an Arduino <a href=""http://arduino.cc/en/Reference/ClientConstructor"" rel=""nofollow"">Ethernet Client</a>, or one of the many other types with the same interface.</p>

<p>If you look at the docs for the <a href=""http://arduino.cc/en/Reference/ClientRead"" rel=""nofollow""><code>read</code></a> method, it returns:</p>

<blockquote>
  <p>The next byte (or character), or -1 if none is available.</p>
</blockquote>

<p>So, when you first connect, you immediately start reading, but nothing has been sent yet, so the first few reads all return -1.</p>

<p>Since this is a <code>char</code>, -1 and 255 are the same value. And the character 255, in Latin-1 (and Latin-1-derived character sets) is <code>ÿ</code>, so that's why you're seeing a bunch of <code>ÿ</code> at the start. Changing the encoding will either give you encoding errors or interpret the 255 as some different character, it won't get rid of it.</p>

<p>So, how do you fix this?</p>

<hr>

<p>Some client classes (although not all, and the basic Ethernet Client is not one of them) can be put into blocking mode, which means <code>read</code> will wait until there's something to read.</p>

<hr>

<p>The Client protocol doesn't actually specify what type <code>read</code> returns. Some Client types return <code>int</code>. And in an <code>int</code>, unlike a <code>char</code>, you can distinguish <code>-1</code> and <code>255</code>. But once you cast it to <code>char</code>, you throw away the other 3 bytes that and can no longer do so. So, depending on the type you're using, you may be able to do this:</p>

<pre><code>int recieved = client.read();
if (recieved == -1) continue;
inData[n] = (char)recieved;
</code></pre>

<hr>

<p>If you only want to send ASCII text (so only values up to 127 are valid), you know that the <code>-1</code> will never be an actual character. In that case, you can just do this:</p>

<pre><code>char recieved = client.read();
if (recieved == -1) continue;
</code></pre>

<hr>

<p>Most client types have a method <a href=""http://arduino.cc/en/Reference/ClientAvailable"" rel=""nofollow""><code>available</code></a>, which tells you how many bytes are available to read. If this returns <code>0</code>, wait a bit and try again instead of reading:</p>

<pre><code>if (!client.available()) {
    delay(200);
    continue;
}
</code></pre>

<p>Many Arduino samples put this together with a <code>delay(500)</code> or longer at the start of the program, because there's no point wasting time checking for data when the odds are very high that nothing is there yet.</p>

<hr>

<p>You can add a ""start"" character to your protocol, just like the ""end"" character. The same way you keep reading until you get a <code>%</code> and then disconnect, you can first keep reading until you get, say, a <code>$</code> character, throwing away everything up to that point:</p>

<pre><code>while (client.connected()) {
    char received = client.read();
    if (received == '$') break;
}
while (client.connected()) {
    /* your original code here */
}
</code></pre>
",,33077354,2850
26249135,2,26248334,2014-10-08T04:18:05.990,1,,3386109,,2014-10-08T04:18:05.990,,0,,"<p>I'm not familiar with the AVR instruction set, but the general idea is to use the <code>CALL</code> instruction to put the program counter (PC) on the stack. Then use <code>POP</code> to move the PC to the Z register.  Then you can <code>ADD</code> some number to the Z register, and use <code>IJMP</code> to jump to the resulting address.</p>

<p>So something along these lines</p>

<pre><code>delay:  call delay1             ; push the PC onto the stack
delay1: pop  r30                ; pop the PC into the Z registers
        pop  r31
        add  r30,r0             ; add some amount to the PC value
        addc r31,r1
        ijmp                    ; use IJMP to jump to the resulting address
        nop
        nop
        nop
        ...
</code></pre>

<p>Random thoughts:</p>

<ul>
<li>On the 8MB machines, you need a third pop to remove the third byte of
the PC from the stack.</li>
<li>Z is only sixteen bits, therefore this code must be in the first
128KB of program memory.</li>
<li>I'm not sure which register (r30 or r31) is supposed to be popped
first.</li>
<li>The value added to Z must be relative to <code>delay1</code> since <code>call</code> is
going to push the address of <code>delay1</code> onto the stack. In other words,
the minimum amount that needs to be added is 6, since that's the
number of instructions from <code>delay1</code> to the first <code>nop</code>.</li>
<li>The minimum delay is determined by the six instructions up to and
including the <code>ijmp</code>. You should increase r1/r0 (reduce the number of
nops) accordingly.</li>
</ul>

<p>Like I said, I'm no expert on the AVR instruction set, so you should take this as a general suggestion, and be prepared to spend some time working out the particulars.  Good luck!</p>
",,33084754,658
26296153,2,26294738,2014-10-10T09:28:53.930,0,,3156373,,2014-10-10T09:28:53.930,,1,,"<p>You have a lot of explicit code that can be brought down to single-line statements.</p>

<pre><code>ab = 0;
for( ic=0; ic &lt; guns.size(); ic++ )
{
    roi_c = guns[i];
    if( roi_c.area() &gt; ab )
    {
        roi_b = roi_c;
        ab = roi_c.area();
    }

    rectangle(frame, roi_c, Scalar(0, 0, 255), 2, 8, 0);
}
</code></pre>

<p>If you want to check if <em>at least</em> one gun is detected, you could write: <code>if( guns.size() &gt; 0 ) { .. }</code>. If you want to check if the largest gun detected is larger than some threshold, you could go with something like <code>if( roi_b.area() &gt; some_threshold )</code>.</p>

<p>Hope this answers.</p>
",,33125117,409
26370448,2,26369649,2014-10-14T21:15:47.667,2,,434551,,2014-10-14T21:15:47.667,,2,,"<p>One of the following options should work:</p>

<ol>
<li><p>Return a pointer to an array of <code>char</code> allocated from the heap. Make sure to delete the returned value in the calling function.</p>

<pre><code>char* readByteArray()
{
   unsigned char l = readByte();
   char *ret = new char[l + 1];
   ret[0] = l;
   readBytes(ret + 1, l);
   return ret;
}
</code></pre></li>
<li><p>Return a <code>std::vector&lt;char&gt;</code>.</p>

<pre><code>std::vector&lt;char&gt; readByteArray()
{
   unsigned char l = readByte();
   std::vector&lt;char&gt; ret(l);
   readBytes(ret.data(), l);
   return ret;
}
</code></pre></li>
</ol>
",,33158123,108
26425732,2,26394668,2014-10-17T13:07:16.530,2,,,user3738848,2018-06-07T23:50:38.040,2018-06-07T23:50:38.040,0,,"<p>You have to call strip.show() in your for loop, like so:</p>

<pre><code>for (int16_t i = steps; i &gt;= 0; i--) {
    redValue = (int16_t)startColor.getR() + (redDiff * i / steps);
    greenValue = (int16_t)startColor.getG() + (greenDiff * i / steps);
    blueValue = (int16_t)startColor.getB() + (blueDiff * i / steps);

    sprintf(rgbString, ""%i,%i,%i"", redValue, greenValue, blueValue);
    Spark.publish(""rgb"", rgbString);

    for (uint16_t i = 0; i &lt; strip.numPixels(); i++) {
        strip.setPixelColor(i, strip.Color(redValue, greenValue, blueValue));
    }



    // !!! Without this, you'll only see the result the next time you call
    // tinkerSetColor() !!!
    strip.show();



    delay(_delay);
}
</code></pre>

<p>To understand what's happening, you can look at the NeoPixel library source. You'll see that <code>strip.setPixelColor()</code> only stores the RGB value in memory (think of it as a drawing buffer, so that you can update the whole strip at once, which makes sense if you look at how the controller chips work). Calling <code>strip.show()</code> causes the routine that will push the values out to each pixel in serial to run.</p>
",,33178470,582
26454115,2,26448152,2014-10-19T18:51:02.650,1,,179585,,2014-10-19T18:51:02.650,,0,,"<blockquote>
  <p>For now all I'm trying to do is move a servomotor in a direction if a
  js variable is under a certain value and moving it the other way if
  it's above that value.</p>
</blockquote>

<p>Here's how you can accomplish this with <a href=""https://github.com/rwaldron/johnny-five"" rel=""nofollow"">Johnny-Five</a>: </p>

<ol>
<li>Make sure you have node and npm installed</li>
<li>With the Arduino IDE, upload StandardFirmata (File -> Examples -> Firmata -> StandardFirmata) to the Arduino, close the IDE</li>
<li><code>npm install johnny-five</code></li>
<li>create a new JS file, save the following in it: </li>
</ol>

<pre class=""lang-js prettyprint-override""><code>var five = require(""johnny-five"");
var board = new five.Board();

board.on(""ready"", function() {

  var servo = new five.Servo(11);

  this.repl.inject({
    move: function(value) {
      var angle = 0;
      if (value &gt; 0) {
        angle = 180;
      }
      servo.to(angle);
    }
  });
});
</code></pre>

<ol start=""4"">
<li>With the USB cable plugged in to the board and computer, run the above program in your terminal. Once it's running, call <code>move(n)</code> where <code>n</code> is any number. Numbers greater than 0 will move the servo to 180°; numbers less than or equal to 0 will move the servo to 0°.</li>
</ol>
",,33188719,113
26456673,2,26455495,2014-10-19T23:47:46.570,0,,2200675,,2014-10-19T23:47:46.570,,1,,"<p>This should work for you:</p>

<pre><code>float contSurfArea(float x, float y){
  float z;
  z = (3.14159*x*x)+(2*3.14159*x*y);
  return (z);
}




 void setup()
  {
    Serial.begin(9600); //serial communication initialized


}

void loop(){
  float baseRad, contHeight = -1; 
  char junk = ' ';

  Serial.println(""Open-top Cylindrical Container Program"");
  delay(2000);

  Serial.println(""Radius of the base(in meters): "");
  while (Serial.available() == 0); //Wait here until input buffer has a character
  baseRad = Serial.parseFloat();
  Serial.print(""baseRad = ""); Serial.println(baseRad, DEC);
  while (Serial.available() &gt; 0) { //parseFloat() can leave non-numeric characters
    junk = Serial.read(); //clear the keyboard buffer
  }

  Serial.println(""Height of the container(in meters): "");
  while (Serial.available() == 0); //Wait here until input buffer has a character
  contHeight = Serial.parseFloat();
  Serial.print(""contHeight = ""); Serial.println(contHeight, DEC);
  while (Serial.available() &gt; 0) {
    junk = Serial.read(); //clear the keyboard buffer
  }

  float q;
  q = contSurfArea(baseRad, contHeight);

  Serial.print(""The surface area of your container is: "");
  Serial.print(q);
  Serial.print( ""meters^2"");

}
</code></pre>
",,33204808,104
26461149,2,26455904,2014-10-20T08:15:18.347,0,,1458617,,2014-10-20T21:22:13.777,2014-10-20T21:22:13.777,5,,"<p>I'm also using VisualGDB for Raspberry Pi development, one of the greatest plugins I've seen. From your log it seems that you are using a cross compilation toolchain to make build. 
First thing you can do is go to the <code>C:\Users\Kels\LinuxHelloWorld\LinuxHelloWorld</code> and verify the existence of a <code>Makefile</code> there and check the contents (maybe even add them to the question there so they can be expected). Another option is to set up compilation on the Pi itself instead of the using a toolchain (this can be done through the project wizard) - it will be slower since Pi cannot be compared to a PC, but then again, any 3rd party libraries which you may need (and most likely you will) can be easily installed on the Pi via <code>apt-get</code> and just used while you will have to cross compile them on your PC if you use the toolchain.</p>

<p><strong>UPDATE</strong></p>

<p>Heres is an example Makefile of one of my sample projects:</p>

<pre><code>#Generated by VisualGDB project wizard. 
#Note: VisualGDB will automatically update this file when you add new sources to the project.
#All other changes you make in this file will be preserved.
#Visit http://visualgdb.com/makefiles for more details

#VisualGDB: AutoSourceFiles     #&lt;--- remove this line to disable auto-updating of SOURCEFILES and EXTERNAL_LIBS

TARGETNAME := RpiOmxTunnelReconfiguration
#TARGETTYPE can be APP, STATIC or SHARED
TARGETTYPE := APP

to_lowercase = $(subst A,a,$(subst B,b,$(subst C,c,$(subst D,d,$(subst E,e,$(subst F,f,$(subst G,g,$(subst H,h,$(subst I,i,$(subst J,j,$(subst K,k,$(subst L,l,$(subst M,m,$(subst N,n,$(subst O,o,$(subst P,p,$(subst Q,q,$(subst R,r,$(subst S,s,$(subst T,t,$(subst U,u,$(subst V,v,$(subst W,w,$(subst X,x,$(subst Y,y,$(subst Z,z,$1))))))))))))))))))))))))))

CONFIG ?= DEBUG

CONFIGURATION_FLAGS_FILE := $(call to_lowercase,$(CONFIG)).mak

include $(CONFIGURATION_FLAGS_FILE)
include $(ADDITIONAL_MAKE_FILES)

ifeq ($(BINARYDIR),)
error:
    $(error Invalid configuration, please check your inputs)
endif

SOURCEFILES := Omx/Component.cpp Omx/ComponentPort.cpp RpiOmxTunnelReconfiguration.cpp
EXTERNAL_LIBS := 
EXTERNAL_LIBS_COPIED := $(foreach lib, $(EXTERNAL_LIBS),$(BINARYDIR)/$(notdir $(lib)))

CFLAGS += $(COMMONFLAGS)
CXXFLAGS += $(COMMONFLAGS)
ASFLAGS += $(COMMONFLAGS)
LDFLAGS += $(COMMONFLAGS)

CFLAGS += $(addprefix -I,$(INCLUDE_DIRS))
CXXFLAGS += $(addprefix -I,$(INCLUDE_DIRS))

CFLAGS += $(addprefix -D,$(PREPROCESSOR_MACROS))
CXXFLAGS += $(addprefix -D,$(PREPROCESSOR_MACROS))
ASFLAGS += $(addprefix -D,$(PREPROCESSOR_MACROS))

CXXFLAGS += $(addprefix -framework ,$(MACOS_FRAMEWORKS))
CFLAGS += $(addprefix -framework ,$(MACOS_FRAMEWORKS))
LDFLAGS += $(addprefix -framework ,$(MACOS_FRAMEWORKS))

LDFLAGS += $(addprefix -L,$(LIBRARY_DIRS))

LIBRARY_LDFLAGS = $(addprefix -l,$(LIBRARY_NAMES))

ifeq ($(IS_LINUX_PROJECT),1)
    RPATH_PREFIX := -Wl,--rpath='$$ORIGIN/../
    LIBRARY_LDFLAGS += $(EXTERNAL_LIBS)
    LIBRARY_LDFLAGS += -Wl,--rpath='$$ORIGIN'
    LIBRARY_LDFLAGS += $(addsuffix ',$(addprefix $(RPATH_PREFIX),$(dir $(EXTERNAL_LIBS))))

    ifeq ($(TARGETTYPE),SHARED)
        LIBRARY_LDFLAGS += -Wl,-soname,$(TARGETNAME)
    endif

else
    LIBRARY_LDFLAGS += $(EXTERNAL_LIBS)
endif

LIBRARY_LDFLAGS += $(ADDITIONAL_LINKER_INPUTS)

all_make_files := Makefile $(CONFIGURATION_FLAGS_FILE) $(ADDITIONAL_MAKE_FILES)

ifeq ($(STARTUPFILES),)
    all_source_files := $(SOURCEFILES)
else
    all_source_files := $(STARTUPFILES) $(filter-out $(STARTUPFILES),$(SOURCEFILES))
endif

source_obj1 := $(all_source_files:.cpp=.o)
source_obj2 := $(source_obj1:.c=.o)
source_obj3 := $(source_obj2:.s=.o)
source_objs := $(source_obj3:.S=.o)

all_objs := $(addprefix $(BINARYDIR)/, $(notdir $(source_objs)))

ifeq ($(GENERATE_BIN_FILE),1)
all: $(BINARYDIR)/$(basename $(TARGETNAME)).bin

$(BINARYDIR)/$(basename $(TARGETNAME)).bin: $(BINARYDIR)/$(TARGETNAME)
    $(OBJCOPY) -O binary $&lt; $@

else
all: $(BINARYDIR)/$(TARGETNAME)
endif

ifeq ($(TARGETTYPE),APP)
$(BINARYDIR)/$(TARGETNAME): $(all_objs) $(EXTERNAL_LIBS)
    $(LD) -o $@ $(LDFLAGS) $(START_GROUP) $(all_objs) $(LIBRARY_LDFLAGS) $(END_GROUP)
endif

ifeq ($(TARGETTYPE),SHARED)
$(BINARYDIR)/$(TARGETNAME): $(all_objs) $(EXTERNAL_LIBS)
    $(LD) -shared -o $@ $(LDFLAGS) $(START_GROUP) $(all_objs) $(LIBRARY_LDFLAGS) $(END_GROUP)
endif

ifeq ($(TARGETTYPE),STATIC)
$(BINARYDIR)/$(TARGETNAME): $(all_objs)
    $(AR) -r $@ $^
endif

-include $(all_objs:.o=.dep)

clean:
ifeq ($(USE_DEL_TO_CLEAN),1)
    del /S /Q $(BINARYDIR)
else
    rm -rf $(BINARYDIR)
endif

$(BINARYDIR):
    mkdir $(BINARYDIR)

#VisualGDB: FileSpecificTemplates       #&lt;--- VisualGDB will use the following lines to define rules for source files in subdirectories
$(BINARYDIR)/%.o : %.cpp $(all_make_files) |$(BINARYDIR)
    $(CXX) $(CXXFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)

$(BINARYDIR)/%.o : %.c $(all_make_files) |$(BINARYDIR)
    $(CC) $(CFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)

$(BINARYDIR)/%.o : %.S $(all_make_files) |$(BINARYDIR)
    $(CC) $(CFLAGS) $(ASFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)

$(BINARYDIR)/%.o : %.s $(all_make_files) |$(BINARYDIR)
    $(CC) $(CFLAGS) $(ASFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)

#VisualGDB: GeneratedRules              #&lt;--- All lines below are auto-generated


$(BINARYDIR)/Component.o : Omx/Component.cpp $(all_make_files) |$(BINARYDIR)
    $(CXX) $(CXXFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)


$(BINARYDIR)/ComponentPort.o : Omx/ComponentPort.cpp $(all_make_files) |$(BINARYDIR)
    $(CXX) $(CXXFLAGS) -c $&lt; -o $@ -MD -MF $(@:.o=.dep)
</code></pre>

<p>As you see here <code>TARGETNAME := RpiOmxTunnelReconfiguration</code> and </p>

<pre><code>ifeq ($(GENERATE_BIN_FILE),1)
all: $(BINARYDIR)/$(basename $(TARGETNAME)).bin

$(BINARYDIR)/$(basename $(TARGETNAME)).bin: $(BINARYDIR)/$(TARGETNAME)
    $(OBJCOPY) -O binary $&lt; $@

else
all: $(BINARYDIR)/$(TARGETNAME)
endif
</code></pre>

<p>will always define an output binary file. Maybe recreate the project.</p>
",,33247615,244
26484776,2,26481217,2014-10-21T10:44:24.373,1,,2200675,,2014-10-21T10:44:24.373,,3,,"<p>This Web client sketch has been tested and works flawlessly.</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// this must be unique
byte mac[] = {  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// change to your network settings
IPAddress ip(192,168,2,2);
IPAddress gateway(192, 168, 2, 1);
IPAddress subnet(255, 255, 255, 0);

// change to your server
IPAddress server(74,125,227,16); // Google

//Change to your domain name for virtual servers
char serverName[] = ""www.google.com"";
// If no domain name, use the ip address above
// char serverName[] = ""74.125.227.16"";

// change to your server's port
int serverPort = 80;

EthernetClient client;
int totalCount = 0;
char pageAdd[64];

// set this to the number of milliseconds delay
// this is 30 seconds
#define delayMillis 30000UL

unsigned long thisMillis = 0;
unsigned long lastMillis = 0;

void setup() {
  Serial.begin(9600);

  // disable SD SPI
  pinMode(4,OUTPUT);
  digitalWrite(4,HIGH);

  // Start ethernet
  Serial.println(F(""Starting ethernet...""));
  Ethernet.begin(mac, ip, gateway, gateway, subnet);

  // If using dhcp, comment out the line above 
  // and uncomment the next 2 lines

  // if(!Ethernet.begin(mac)) Serial.println(F(""failed""));
  // else Serial.println(F(""ok""));

  Serial.println(Ethernet.localIP());

  delay(2000);
  Serial.println(F(""Ready""));
}

void loop()
{
  thisMillis = millis();

  if(thisMillis - lastMillis &gt; delayMillis)
  {
    lastMillis = thisMillis;

    // Modify next line to load different page
    // or pass values to server
    sprintf(pageAdd,""/"",totalCount);

    // sprintf(pageAdd,""/arduino.php?test=%u"",totalCount);

    if(!getPage(server,serverPort,pageAdd)) Serial.print(F(""Fail ""));
    else Serial.print(F(""Pass ""));
    totalCount++;
    Serial.println(totalCount,DEC);
  }    
}

byte getPage(IPAddress ipBuf,int thisPort, char *page)
{
  int inChar;
  char outBuf[128];

  Serial.print(F(""connecting...""));

  if(client.connect(ipBuf,thisPort) == 1)
  {
    Serial.println(F(""connected""));

    sprintf(outBuf,""GET %s HTTP/1.1"",page);
    client.println(outBuf);
    sprintf(outBuf,""Host: %s"",serverName);
    client.println(outBuf);
    client.println(F(""Connection: close\r\n""));
  } 
  else
  {
    Serial.println(F(""failed""));
    return 0;
  }

  // connectLoop controls the hardware fail timeout
  int connectLoop = 0;

  while(client.connected())
  {
    while(client.available())
    {
      inChar = client.read();
      Serial.write(inChar);
      // set connectLoop to zero if a packet arrives
      connectLoop = 0;
    }

    connectLoop++;

    // if more than 10000 milliseconds since the last packet
    if(connectLoop &gt; 10000)
    {
      // then close the connection from this end.
      Serial.println();
      Serial.println(F(""Timeout""));
      client.stop();
    }
    // this is a delay for the connectLoop timing
    delay(1);
  }

  Serial.println();

  Serial.println(F(""disconnecting.""));
  // close client end
  client.stop();

  return 1;
}
</code></pre>

<p>If for some reason it keeps hanging, you can implement a watchdog timer mechanism. For more info about WDT on <a href=""https://www.google.gr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CB4QFjAA&amp;url=http%3A%2F%2Fwww.atmel.com%2Fimages%2Fatmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf&amp;ei=5DlGVOC2FMOlygP05ICgAg&amp;usg=AFQjCNG11iPfTyE8Bo48itJKyz_DwRYClg&amp;sig2=qVB5Pa3j234_VRtdWMmkPw&amp;bvm=bv.77880786,d.bGQ"" rel=""nofollow"">ATmega328P Datasheet.</a>
I have an example from one of my projects:</p>

<pre><code>void watchdogSetup(void) {
cli(); // disable all interrupts
wdt_reset(); // reset the WDT timer
/*
WDTCSR configuration:
WDIE = 1: Interrupt Enable
WDE = 1 :Reset Enable
WDP3 = 0 :For 2000ms Time-out
WDP2 = 1 :For 2000ms Time-out
WDP1 = 1 :For 2000ms Time-out
WDP0 = 1 :For 2000ms Time-out
*/
// Enter Watchdog Configuration mode:
WDTCSR |= (1&lt;&lt;WDCE) | (1&lt;&lt;WDE); //x |= y is the same as  x = x | y
// Set Watchdog settings:
WDTCSR = (1&lt;&lt;WDIE) | (1&lt;&lt;WDE) | (0&lt;&lt;WDP3) | (1&lt;&lt;WDP2) | (1&lt;&lt;WDP1) | (1&lt;&lt;WDP0);
sei();
}

ISR(WDT_vect){// Watchdog timer interrupt.
  digitalWrite(ETHERNET_SHIELD_RESET_PIN, LOW); 
}
</code></pre>
",,33257028,341
26512618,2,26489501,2014-10-22T16:40:19.263,1,,4166250,,2014-10-22T16:40:19.263,,0,,"<p>Thank's everyone.
This is my final code.</p>

<pre><code>unsigned long redButtonPress = 0;
unsigned long yellowButtonPress = 0;

void setup()
{
  pinMode(0, OUTPUT);
  pinMode(1, OUTPUT);
  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(10, OUTPUT);
  pinMode(11, OUTPUT);
  pinMode(12, INPUT);
  pinMode(13, INPUT);
}

void loop()
{
  if (digitalRead(12) == HIGH &amp;&amp; yellowButtonPress+399 &lt; millis())
  {
    yellowButtonPress = millis();
  }
  if (digitalRead(11) == HIGH &amp;&amp; redButtonPress+399 &lt; millis())
  {
    redButtonPress = millis();
  }


  if (millis() &lt;= yellowButtonPress+99 &amp;&amp; millis() &gt;= yellowButtonPress+2)
  {
    digitalWrite(2, HIGH);
  }else{digitalWrite (2, LOW);}

  if (millis() &lt;= redButtonPress+99 &amp;&amp; millis() &gt;= redButtonPress+2)
  {
    digitalWrite(6, HIGH);
  }else{digitalWrite (6, LOW);}

  if (millis() &gt;= yellowButtonPress+100 &amp;&amp; millis() &lt;= yellowButtonPress+199)
  {
    digitalWrite(3, HIGH);
  }else{digitalWrite (3, LOW);}

  if (millis() &gt;= redButtonPress+100 &amp;&amp; millis() &lt;= redButtonPress+199)
  {
    digitalWrite(7, HIGH);
  }else{digitalWrite (7, LOW);}

  if (millis() &gt;= yellowButtonPress+200 &amp;&amp; millis() &lt;= yellowButtonPress+299)
  {
    digitalWrite(4, HIGH);
  }else{digitalWrite (4, LOW);}

    if (millis() &gt;= redButtonPress+200 &amp;&amp; millis() &lt;= redButtonPress+299)
  {
    digitalWrite(8, HIGH);
  }else{digitalWrite (8, LOW);}

  if (millis() &gt;= yellowButtonPress+300 &amp;&amp; millis() &lt;= yellowButtonPress+399)
  {
    digitalWrite(5, HIGH);
  }else{digitalWrite (5, LOW);}

  if (millis() &gt;= redButtonPress+300 &amp;&amp; millis() &lt;= redButtonPress+399)
  {
    digitalWrite(9, HIGH);
  }else{digitalWrite (9, LOW);}
}
</code></pre>
",,33323740,1792
26580650,2,26489501,2014-10-27T03:09:16.383,1,,3090932,,2014-10-27T03:09:16.383,,0,,"<p>This is how I would write the code for this project.</p>

<pre><code>unsigned long yellowButtonPress = 0;
unsigned long yellowTimeElapsed = 0;
int yellowLED = 2

unsigned long redButtonPress = 0;
unsigned long redTimeElapsed = 0;
int redLED = 6

unsigned long MAX_Time = 400;

void setup(){
  //Setup the INPUT and OUTPUT pins
  for (int x=2; x&lt;10; x++){
    pinMode(x, OUTPUT);
  }
    pinMode(12, INPUT);  //Yellow Button
    pinMode(13, INPUT);  //Red Button
}

void loop{
  yellowTimeElapsed = millis() - yellowButtonPress;
  redTimeElapsed = millis() - redButtonPress;

  //Check if yellow button has been pressed
  if(digitalRead(12) == HIGH &amp;&amp; yellowTimeElapsed &gt; MAX_Time){
    yellowButtonPress = millis();
  }

  //Check if red button has been pressed
  if(digitalRead(13) == HIGH &amp;&amp; redTimeElapsed &gt; MAX_Time){
    redButtonPress = millis();
  }

  //Identify which yellow LED needs to be on at this time
  if (yellowTimeElapsed &gt; Max_Time){
    yellowLED=0; //This will turn off all yellow LEDs
  } else {
    yellowLED = map(yellowTimeElapsed, 0, MAX_Time, 2,5);
  }

  //Identify which red LED needs to be on at this time
  if (redTimeElapsed &gt; Max_Time){
    redLED=0;  //This will turn off all red LEDs
  } else {
    redLED = map(redTimeElapsed, 0, MAX_Time, 6,9);
  }

  //Turn the yellow and/or red LEDs on and off
  for (int i = 2; i&lt;10; i++){
    if (i == yellowLED || i == redLED){
      digitalWrite(i,HIGH);
    } else {
      digitalWrite(i,LOW);
    }
  }
}
</code></pre>
",,33336698,1050
26519032,2,26518427,2014-10-22T23:45:48.770,1,,971127,,2014-10-23T00:02:59.267,2014-10-23T00:02:59.267,3,,"<pre><code>int val = 0;
for(int j = i+1; j &lt; size; j++){
    if(isdigit(input[j] )){
        val = val * 10 + input[j]-'0';// val = (val &lt;&lt; 8) | input[j];
    }   
}
return val;
</code></pre>
",,33359198,37
26519127,2,26518427,2014-10-22T23:58:18.567,1,,3386109,,2014-10-22T23:58:18.567,,1,,"<p>The problem here is that you are using nested loops to perform tasks that should be done with sequential loops. </p>

<p>For example, the <code>i</code> loop searches for the colon, and then the loop in <code>compare_string</code> searches for the colon again. You could run the <code>i</code> loop first, and then call <code>compare_string</code> after the <code>i</code> loop finishes.  But a better design is to have <code>compare_string</code> search for the colon while comparing, and then return the index of the character after the colon (or -1 if the colon is not found).</p>

<p>The same is true of the <code>j</code> and <code>k</code> nested loops. The <code>j</code> loop is searching for the end of the number. The <code>k</code> loop only runs once after the <code>j</code> loop is finished, and so the <code>k</code> loop should be after the <code>j</code> loop, not nested.  But a better design is a single loop that converts the number while searching for the end of the number.</p>

<p>The code below demonstrates one possible implementation using the techniques I've described.</p>

<pre><code>const uint8_t hrmSet[] = ""Heart Rate:"";

int compare_string( uint8_t *input, const uint8_t *expected, int size )
{
    for ( int i = 0; i &lt; size; i++ )
    {
        if ( *input != *expected || *expected == '\0' )
            return( -1 );

        if ( *input == ':' &amp;&amp; *expected == ':' )
            return( i + 1 );

        input++;
        expected++;
    }

    return( -1 );
}

int parse( uint8_t *input, uint8_t size )
{
    int i, val;

    if ( (i = compare_string( input, hrmSet, size )) &lt; 0 )
        return( -1 );

    val = 0;
    for ( ; i &lt; size &amp;&amp; isdigit( input[i] ); i++ )
        val = val * 10 + input[i] - '0';

    return( val );
}

int main( void )
{
    uint8_t input[] = ""Heart Rate:75"";
    int rate = parse( input, sizeof(input) - 1 );
    printf( ""%d\n"", rate );
}
</code></pre>
",,33373226,812
26541892,2,26541882,2014-10-24T05:15:50.633,7,,4176466,,2014-10-24T05:37:04.130,2014-10-24T05:37:04.130,2,,"<p>No, you have to port a C library to your operating system because the library has ""stubs"" that hook into operating system specifics. The C standard mandates that certain headers are present in freestanding mode, which is always available to you. But library functions like printf have to be implemented yourself or ported by filling in the stubs. Take a look at <a href=""https://sourceware.org/newlib/"">newlib</a> to see the kind of work you have to do. At the very minimum it requires a working kernel that has a syscall interface (for read, write, etc.) These will depend on the features available in your operating system (for example, a filesystem.) Taken from the FAQ:</p>

<blockquote>
  <ol start=""6"">
  <li>What steps do I need to do to port newlib to a new platform?</li>
  </ol>
  
  <blockquote>
    <p>A basic port needs to alter a number of files and add some
    directories.</p>
    
    <ol>
    <li><p>Add a subdirectory to the newlib/libc/machine directory for your platform</p>
    
    <p>In this directory you need to have a setjmp/longjmp implementation. This is required because setjmp/longjmp usually is
    assembler. Look at the libc/machine/fr30 directory and copy/modify the
    files in there.</p></li>
    <li><p>Edit newlib/libc/include/machine/ieeefp.h</p>
    
    <p>This defines the ieee endianness for your platform. The compiler should be defining something that identifies your machine. In some
    cases, the endianness may be a compiler-option so you may have to
    check another define in addition to your platform identifier. See
    examples in the file.</p></li>
    <li><p>Edit newlib/libc/include/machine/setjmp.h</p>
    
    <p>You need to specify the setjmp buffer characteristics to match up with your setjmp/longjmp implementation. This is just the size of
    the
    setjmp buffer. See file for examples.</p></li>
    <li><p>Edit newlib/libc/include/sys/config.h</p>
    
    <p>This has various defines as needed. Mostly, it defines some max values. There are defaults that may apply to your platform in which
    case you needn't do anything.</p></li>
    <li><p>Edit configure.host</p>
    
    <p>You need to add your configuration so newlib can recognize it. You should specify your new machine directory for your platform via
    the
    machine_dir variable. If needed, you can add special newlib compile
    flags. The sys_dir is for OS stuff so you won't need to alter that.
    Older platforms used the sys_dir to implement syscalls but this is not
    correct and is a historical nuisance. The syscall_dir is a choice, but
    I recommend as a default to specify syscall_dir=syscalls. Read the
    comments in newlib/libc/include/reent.h for an explanation of choices.</p></li>
    <li><p>Add a platform subdirectory to libgloss</p>
    
    <p>You need to add a bsp for your platform. This is the minimum set of syscalls needed by newlib and any linker scripts needed. This
    varies from board to board (it can also be a simulator). See the
    mn10300 or fr30 for examples. You will need to edit configure.in and
    regenerate configure so it will build your new files. By default you
    get libnosys which gives you a set of default syscall stubs. The
    majority of the stubs just return failure.You still need to supply an
    __exit routine. This can be as simple as generating an exception to stop the program.</p></li>
    <li><p>Possibly override header files</p>
    
    <p>If you need to override any default machine header files, you can add a machine directory to newlib/libc/machine/ Header files in
    that
    subdirectory will overwrite the defaults found in
    newlib/libc/include/machine. You will likely not need to do this.</p></li>
    </ol>
    
    <p>This assumes you have already handled adding your new configuration to
    the top directory files.</p>
    
    <p>Now linux is a different animal. It is an OS that has an extensive set
    of syscalls. If you look in the newlib/libc/sys/linux directory, you
    will find a number of syscalls there (e.g. see io.c). There is a set
    of basic syscall macros that are defined for the particular platform.
    For the x86, you will find these macros defined in
    newlib/libc/sys/linux/machine/i386/syscall.h file. At the moment,
    linux support is only for x86. To add another platform, the syscall.h
    file would have to be supplied for the new platform plus some other
    platform-specific files would need to be ported as well.</p>
  </blockquote>
</blockquote>

<p>For newlib, take a look at the <a href=""https://sourceware.org/newlib/libc.html#Syscalls"">syscall documentation page</a> which lists what you need to implement and what a minimal implementation consists of. You'll quickly realize that stuff like <code>sbrk</code> will become meaningless if you haven't already implemented memory management. You'll probably end up having written most of your kernel by the time you get to porting a C library.</p>

<blockquote>
  <p><code>_exit</code></p>
  
  <p>Exit a program without cleaning up files. If your system doesn't provide this, it is best to avoid linking with subroutines that
  require it (exit, system). </p>
  
  <p><code>close</code></p>
  
  <p>Close a file. Minimal implementation:</p>

<pre><code>          int close(int file) {
            return -1;
          }
</code></pre>
  
  <p><code>environ</code></p>
  
  <p>A pointer to a list of environment variables and their values. For a minimal environment, this empty list is adequate:</p>

<pre><code>          char *__env[1] = { 0 };
          char **environ = __env;
</code></pre>
  
  <p><code>execve</code></p>
  
  <p>Transfer control to a new process. Minimal implementation (for a system without processes):</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int execve(char *name, char **argv, char **env) {
            errno = ENOMEM;
            return -1;
          }
</code></pre>
  
  <p><code>fork</code></p>
  
  <p>Create a new process. Minimal implementation (for a system without processes):</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int fork(void) {
            errno = EAGAIN;
            return -1;
          }
</code></pre>
  
  <p><code>fstat</code></p>
  
  <p>Status of an open file. For consistency with other minimal implementations in these examples, all files are regarded as character
  special devices. The sys/stat.h header file required is distributed in
  the include subdirectory for this C library.</p>

<pre><code>          #include &lt;sys/stat.h&gt;
          int fstat(int file, struct stat *st) {
            st-&gt;st_mode = S_IFCHR;
            return 0;
          }
</code></pre>
  
  <p><code>getpid</code></p>
  
  <p>Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes. Minimal implementation, for a system
  without processes:</p>

<pre><code>          int getpid(void) {
            return 1;
          }
</code></pre>
  
  <p><code>isatty</code></p>
  
  <p>Query whether output stream is a terminal. For consistency with the other minimal implementations, which only support output to
  stdout, this minimal implementation is suggested:</p>

<pre><code>          int isatty(int file) {
            return 1;
          }
</code></pre>
  
  <p><code>kill</code></p>
  
  <p>Send a signal. Minimal implementation:</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int kill(int pid, int sig) {
            errno = EINVAL;
            return -1;
          }
</code></pre>
  
  <p><code>link</code></p>
  
  <p>Establish a new name for an existing file. Minimal implementation:</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int link(char *old, char *new) {
            errno = EMLINK;
            return -1;
          }
</code></pre>
  
  <p><code>lseek</code></p>
  
  <p>Set position in a file. Minimal implementation:</p>

<pre><code>          int lseek(int file, int ptr, int dir) {
            return 0;
          }
</code></pre>
  
  <p><code>open</code></p>
  
  <p>Open a file. Minimal implementation:</p>

<pre><code>          int open(const char *name, int flags, int mode) {
            return -1;
          }
</code></pre>
  
  <p><code>read</code></p>
  
  <p>Read from a file. Minimal implementation:</p>

<pre><code>          int read(int file, char *ptr, int len) {
            return 0;
          }
</code></pre>
  
  <p><code>sbrk</code></p>
  
  <p>Increase program data space. As malloc and related functions depend on this, it is useful to have a working implementation. The
  following suffices for a standalone system; it exploits the symbol
  _end automatically defined by the GNU linker.</p>

<pre><code>          caddr_t sbrk(int incr) {
            extern char _end;     /* Defined by the linker */
            static char *heap_end;
            char *prev_heap_end;

            if (heap_end == 0) {
              heap_end = &amp;_end;
            }
            prev_heap_end = heap_end;
            if (heap_end + incr &gt; stack_ptr) {
              write (1, ""Heap and stack collision\n"", 25);
              abort ();
            }

            heap_end += incr;
            return (caddr_t) prev_heap_end;
          }
</code></pre>
  
  <p><code>stat</code></p>
  
  <p>Status of a file (by name). Minimal implementation:</p>

<pre><code>          int stat(char *file, struct stat *st) {
            st-&gt;st_mode = S_IFCHR;
            return 0;
          }
</code></pre>
  
  <p><code>times</code></p>
  
  <p>Timing information for current process. Minimal implementation:</p>

<pre><code>          int times(struct tms *buf) {
            return -1;
          }
</code></pre>
  
  <p><code>unlink</code></p>
  
  <p>Remove a file's directory entry. Minimal implementation:</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int unlink(char *name) {
            errno = ENOENT;
            return -1;
          }
</code></pre>
  
  <p><code>wait</code></p>
  
  <p>Wait for a child process. Minimal implementation:</p>

<pre><code>          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int wait(int *status) {
            errno = ECHILD;
            return -1;
          }
</code></pre>
  
  <p><code>write</code></p>
  
  <p>Write to a file. libc subroutines will use this system routine for
  output to all files, including stdout—so if you need to generate any
  output, for example to a serial port for debugging, you should make
  your minimal write capable of doing this. The following minimal
  implementation is an incomplete example; it relies on a outbyte
  subroutine (not shown; typically, you must write this in assembler
  from examples provided by your hardware manufacturer) to actually
  perform the output.</p>

<pre><code>          int write(int file, char *ptr, int len) {
            int todo;

            for (todo = 0; todo &lt; len; todo++) {
              outbyte (*ptr++);
            }
            return len;
          }
</code></pre>
</blockquote>

<p>For a more comprehensive overview of the steps you need to take to port newlib, see <a href=""http://wiki.osdev.org/Porting_Newlib#libc.2Fsys.2Fmyos"">osdev.org</a>. Although I recommend reading the other tutorials on the website first that pertain to writing your kernel because porting a C library is absolutely not the first step you take when writing a kernel.</p>
",,33392427,17278
26560212,2,26559333,2014-10-25T07:25:35.820,1,,4167092,,2014-10-26T00:54:35.437,2014-10-26T00:54:35.437,2,,"<p>A couple changes might help:</p>

<p>1) Try adding an infinite loop in your code. The program on a microcontroller should follow a general structure of initialization functions followed by an infinite loop. </p>

<p>2) Looking at the datasheet for the PIC10F204, it says that pin 3 is input only. Try modifying as follows: TRISGPIO = 0x08;</p>

<p>I modified your code below to illustrate this. Hopefully this works for you. </p>

<pre><code>int main(void) {

    // PIC Initializations should go here
    OSCCAL= 0x00;
    CMCON0 = 0x51;
    TRISGPIO = 0x08;
    GPIO= 0xFF;

    while(1) {
        // Program main loop (should never end)
    }

    return 0; // we should never reach this
}
</code></pre>
",,33450659,3133
26559997,2,26559944,2014-10-25T06:48:54.300,0,,4167677,,2014-10-25T06:48:54.300,,1,,"<p>You want to get the voltage change over time?  Why to just declare a global array like:</p>

<pre><code>float prev_voltage0[9];
float prev_voltage1[9];

for (...) {
    ....
    //difference is (voltage0 - prev_voltage0[row])
    prev_voltage0[row] = voltage0;
    prev_voltage1[row] = voltage1;
    delay(2000);
}
</code></pre>
",,33474070,4901
47000595,2,26606792,2017-10-29T13:15:29.153,0,,2602309,,2017-10-29T13:15:29.153,,0,,"<p>HighPredator is right!</p>

<p>From the panstamp lib we see that the CCPACKET::data field is a uint8_t array:
<a href=""https://github.com/panStamp/panstamp/wiki/CCPACKET#data"" rel=""nofollow noreferrer"">https://github.com/panStamp/panstamp/wiki/CCPACKET#data</a></p>

<p>Basically when you write:</p>

<pre><code>float lon=26.533255;
float lat=27.533463;
data.data[0]=lon;
data.data[1]=lat;
</code></pre>

<p>The compiler is essentially doing:</p>

<pre><code>data.data[0]=uint8_t(lon); // So 26.533255f just becomes 26
data.data[1]=uint8_t(lat); // So 27.533463just becomes 27
</code></pre>

<p>You need to understand the float type, which is 4-bytes long and so you need to make your packet 8 bytes long and transmit the raw bytes like this:</p>

<pre><code>data.length = 8;
data.data[0] = ((uint8_t*)(&amp;lon))[0]; // Transfer first byte of the float
data.data[1] = ((uint8_t*)(&amp;lon))[1];
data.data[2] = ((uint8_t*)(&amp;lon))[2];
data.data[3] = ((uint8_t*)(&amp;lon))[3]; // Transfer last byte of the float

data.data[4] = ((uint8_t*)(&amp;lat))[0]; // Transfer first byte of the float
data.data[5] = ((uint8_t*)(&amp;lat))[1];
data.data[6] = ((uint8_t*)(&amp;lat))[2];
data.data[7] = ((uint8_t*)(&amp;lat))[3]; // Transfer last byte of the float
</code></pre>

<p>On the receiving end, you can recompose the floats like this:</p>

<pre><code>float lon, lat;
((uint8_t*)(&amp;lon))[0] = data.data[0]; // Place first byte
((uint8_t*)(&amp;lon))[1] = data.data[1];
((uint8_t*)(&amp;lon))[2] = data.data[2];
((uint8_t*)(&amp;lon))[3] = data.data[3]; // Place last byte

((uint8_t*)(&amp;lat))[0] = data.data[4]; // Place first byte
((uint8_t*)(&amp;lat))[1] = data.data[5];
((uint8_t*)(&amp;lat))[2] = data.data[6];
((uint8_t*)(&amp;lat))[3] = data.data[7]; // Place last byte
</code></pre>

<p>Hope that helps.</p>
",,33559313,889
28909945,2,26607999,2015-03-07T00:29:02.443,1,,3834652,,2017-11-16T19:37:56.387,2017-11-16T19:37:56.387,1,,"<p>Answer might be a little late but;</p>

<p>It appears the Arduino IDE doesn't like member functions being declared in the class definition. </p>

<p>Just to be clear:</p>

<pre><code>class example {
    public:
           void function(){ /*code not here*/ };  
    private:
            int variable;
};

void example::function(){
    //code here
}  
</code></pre>
",,33602020,2185
26621443,2,26619517,2014-10-29T01:33:25.400,1,,1599004,,2014-10-29T02:06:36.383,2014-10-29T02:06:36.383,0,,"<p>The ""successful"" <strong>write()</strong> s are false positives.  The data was output, but not properly received by the device.  </p>

<p>Your program has not properly configured the serial port using <em>termios</em> after the <strong>open()</strong> and before any <strong>write()</strong> or <strong>read()</strong>.  You should configure the port for canonical rather than raw mode.  You also need to configure the baud rate, character length, parity and number of stop bits.  </p>

<p>Use the <a href=""http://www.cmrr.umn.edu/~strupp/serial.html"" rel=""nofollow"">Serial Programming Guide for POSIX Operating Systems</a>. </p>

<p>Workable(?) configuration code might look like (for 115200 baud rate, 8N1 and canonical input, i.e. read terminates on NL character):</p>

<pre><code>#include &lt;termios.h&gt;

struct termios  serialSettings;
speed_t     spd;
int fd;
int rc;

fd = open(deviceName, O_RDWR | O_NOCTTY);
if (fd == -1) {
    printf(""\n %s\n"", deviceName);
    perror(""unable to open port"");
    return -1;
}

rc = tcgetattr(fd, &amp;serialSettings);
if (rc &lt; 0) {
    perror(""unable to get attributes"");
    return -2;
}

spd = B115200;
cfsetospeed(&amp;serialSettings, spd);
cfsetispeed(&amp;serialSettings, spd);

serialSettings.c_cflag &amp;= ~CSIZE;
serialSettings.c_cflag |= CS8;

serialSettings.c_cflag &amp;= ~PARENB;
serialSettings.c_cflag &amp;= ~CSTOPB;

serialSettings.c_cflag &amp;= ~CRTSCTS;    /* no HW flow control? */
serialSettings.c_cflag |= CLOCAL | CREAD;

serialSettings.c_iflag &amp;= ~(PARMRK | ISTRIP | IXON | IXOFF | INLCR);
serialSettings.c_iflag |= ICRNL;
serialSettings.c_oflag &amp;= ~OPOST;
serialSettings.c_lflag &amp;= ~(ECHO | ECHONL | ISIG | IEXTEN);
serialSettings.c_lflag |= ICANON;

rc = tcsetattr(fd, TCSANOW, &amp;serialSettings);
if (rc &lt; 0) {
    perror(""unable to set attributes"");
    return -2;
}
/* serial port is now configured and ready */
...
</code></pre>

<hr>

<p>Additional comments on your code:</p>

<pre><code>bufferRecv[strlen(bufferRecv)] = '\0';
</code></pre>

<p>This is illogical code.  If you could actually determine the string length of what's in <em>bufferRecv</em>, then that text would already be null terminated, and this assignment would not be necessary.<br>
Secondly and much worse, the <strong>read()</strong> does not terminate the receive data with a null byte, so the <strong>strlen()</strong> could scan past the buffer end.  </p>

<p>The <strong>read()</strong> does return the number of bytes stored in the buffer, and that value can be used to locate where a null byte should be written.<br>
Workable code would look like (note the reduction in requested read length):</p>

<pre><code>readInt = read(fd, bufferRecv, sizeof(bufferRecv) - 1);
if (readInt &lt; 0){
    perror(""Unable to read from the port\n"");
    return -3;
}
bufferRecv[readInt] = '\0';
printf(""ADC value read = %s\n"", bufferRecv);
</code></pre>

<hr>

<p>The strings that you send to the USB device should be preceded and terminated with a carriage return just like the Win examples:</p>

<pre><code>strcpy(bufferSend, ""\rgpio set 0\r"");
...
strcpy(bufferSend, ""\rgpio read 0\r"");
</code></pre>
",,33626480,4490
26655692,2,26654568,2014-10-30T14:28:59.583,0,,20862,,2014-10-30T14:28:59.583,,10,,"<blockquote>
<pre><code>String zoneChk = ""zone"" + String(myInput);
ArrayCount = sizeof(zoneChk) / sizeof( int ) ; // sizeof( int ) is the newpart
</code></pre>
</blockquote>

<p>Nooo no no no no.</p>

<pre><code>const int * const zones[] = {zone2, zone3, zone4};

 ...

for (int z = 0; z &lt; 3; ++z)
{
  // access zones[z]
}
</code></pre>

<p>Also, consider null-terminating each <code>zoneX</code> (and optionally <code>zones</code>) so that you know when you've reached the end.</p>
",,33627745,599
26660933,2,26654568,2014-10-30T18:42:15.910,0,,77469,,2014-10-30T18:42:15.910,,0,,"<pre><code>String zoneChk = ""zone"" + String(myInput);
ArrayCount = sizeof(zoneChk) / sizeof( int ) ; // sizeof( int ) is the newpart
</code></pre>

<p>This will not allow you to access the zone2..5 variables at runtime. You are creating a ""zone2"" string that has nothing to do with the zone2 variable.</p>

<p>The code below compiles but I don't have an Arduino with me to fully test it. It will still allow you to change the size of zone2,3,4 without any modifications to the code. You will have to add more case statements (there is commented out zone5 code included) if you want more zones.</p>

<p>If you want it to be fully dynamic we can use a multi-dimensional array for the zones but this should be a good start for minimal code</p>

<pre><code>for (myInput = 2;myInput&lt;5; myInput++) {
    int buttonState = digitalRead(myInput);

    int ArrayCount;
    const int *zoneChk;

    //This is the part you will have to add to if you want more zones
    switch(myInput){
        case 2:
          ArrayCount = sizeof(zone2) / sizeof (zone2[0]);
          zoneChk = zone2;
        break;
        case 3:
          ArrayCount = sizeof(zone3) / sizeof (zone3[0]);
          zoneChk = zone3;
        break;
        case 4:
          ArrayCount = sizeof(zone4) / sizeof (zone4[0]);
          zoneChk = zone4;
        break;
        //ex. case 5
        //case 5:
        //  ArrayCount = sizeof(zone5) / sizeof (zone5[0]);
        //  zoneChk = zone5;
        //break;
    }

    int arrayPosition;

    for (arrayPosition = 0;arrayPosition &lt; ArrayCount ; arrayPosition++) {
        if (buttonState == HIGH) {     
            // turn LED on:    
            digitalWrite(zoneChk[arrayPosition], HIGH);  
        } 
        else {
            // turn LED off:
            digitalWrite(zoneChk[arrayPosition], LOW);
        }
    } 
}
</code></pre>
",,33651753,2280
26661151,2,26661041,2014-10-30T18:54:59.583,1,,3754223,,2014-10-30T18:54:59.583,,0,,"<p>If <code>char delta(e, z) {}</code> should be a function definition, you have to remember the proper syntax to do so.</p>

<pre><code>char delta(int e, char *z) 
{
    char result;

    /* do whatever here... */

    return result; 
}

char z[4] = ""z_0"";
int e = 0;

char result = delta(e, z);
</code></pre>
",,33667405,115
26686057,2,26685537,2014-11-01T03:56:49.933,0,,3604898,,2014-11-01T03:56:49.933,,1,,"<p>You can convert a char to a uint8_t like this:</p>

<pre><code>//assume these variables
char thisChar = '9';
uint8_t thisByte;

thisByte |= thisChar;

Serial.println(thisByte, BIN);
</code></pre>

<p>The output of this is: 00111001</p>

<p>This works because they are both a single byte variable. You are moving the bits over using a bitwise operation.</p>
",,33675737,671
26689808,2,26685537,2014-11-01T13:32:17.217,0,,4204454,,2014-11-01T13:32:17.217,,0,,"<p>Found the solution:</p>

<p>This is the full program:</p>

<pre><code>#include &lt;HIDSerial.h&gt;

HIDSerial serial;

unsigned char buffer[2];

void setup() {
  serial.begin();
}

void loop() {
  if(serial.available()) {
    int size = serial.read(buffer);
    if (size!=0) {
      int bright = atoi((char *) buffer) ;
      analogWrite(0,bright);
      serial.println(bright);

    }
  }
  serial.poll();
}
</code></pre>
",,33692271,595
33199408,2,26691864,2015-10-18T14:56:27.957,1,,5261603,,2015-10-18T14:56:27.957,,0,,"<pre><code>uint8_t stackArray[30];
void createStackDump() 
{
  volatile uint8_t* mSP = (uint8_t*)SP;

  for (int i = 0; i &lt; 30; i++) 
  {
    stackArray[i] = *mSP;
    mSP++;
  }
}
</code></pre>
",,33704918,362
55250902,2,26691864,2019-03-19T22:28:55.910,0,,3131332,,2019-03-19T22:28:55.910,,0,,"<p>Call addresses on the stack are LSB first, so LSB has the higher stack address.
And they are shifted right 1 bit.</p>

<pre><code>uint8_t * tStackPtr = (uint8_t *) SP;
// We have 19 pushs and pops for this function so add 19+1
uint16_t tPC = *(tStackPtr + 20);
tPC &lt;&lt;= 8;
tPC |= *(tStackPtr + 21);
tPC &lt;&lt;= 1;
Serial.print(F(""PC=0x""));
Serial.println(tPC, HEX);
</code></pre>
",,33712802,149
26695334,2,26695305,2014-11-02T02:11:47.060,2,,3933332,,2014-11-02T02:25:29.707,2014-11-02T02:25:29.707,2,,"<p>You need a main function in every C program! Otherwise the program don't know where to start! So this should work:</p>

<pre><code>#include &lt;stdio.h&gt;

int test_func( char *s ) {
        if( s == NULL ) {
                fprintf( stderr,
                        ""%s: recieved null pointer argument\n"", __func__ );
                return -1;
        }
        /* ... */
}

int main() {

    //test_func(str)  call the function with the required parameters

    return 0;

}
</code></pre>
",,33749216,2640
26709825,2,26709107,2014-11-03T07:43:59.557,2,,3830887,,2020-05-06T02:25:15.447,2020-05-06T02:25:15.447,1,,"<p>This site <a href=""http://fossies.org/dox/gpsd-3.11/gps_8h_source.html"" rel=""nofollow noreferrer"">enter link description here</a> Indicates it is a unix timestamp with a fractional part.  Assuming this means the numbers to the left of the decimal are the number of seconds since 1/1/1970 and the 'decimal' component is a fractional part of one second, you could strip off the the integer component and use ctime():</p>

<pre><code>#include &lt;time.h&gt;

time_t seconds;
timestamp_t ts = 1415000462.999000;

seconds = (time_t) timestamp_t;

printf(""Time: %s\n"", ctime(&amp;seconds));
</code></pre>

<p>This of course ignores the fractional part of a second, but 
you should be able to handle that easily.</p>
",,33758004,905
27122172,2,26712701,2014-11-25T08:48:36.693,0,,292412,,2014-11-25T08:48:36.693,,0,,"<p>I would suggest using <a href=""http://www.arduino.cc/en/Reference/AttachInterrupt"" rel=""nofollow"">interrupts</a>, especially since the Leonardo supports interrupts triggered on state changes of both of your chosen pins.</p>

<p>If I understand the core of the problem correctly, you want the time elapsed between a falling edge (HIGH to LOW) from your button press on pin 2 to a rising edge (LOW to HIGH) on pin 7.  If I misinterpreted that and your button is actually active-high, just change the final parameter of <code>attachInterrupt(interrupt, ISR, mode)</code> to <code>RISING</code>.</p>

<p>After these are setup, our specified interrupt service routine (ISR) functions will be called whenever the specified state or state change occurs.  We want to do minimal work in these ISRs since no other ISR can be triggered while one is running.  Recording a start or stop time would be fine.</p>

<p>However, interrupts cannot use <code>millis()</code> or <code>micros()</code> directly because those functions themselves use interrupts.  To work around that constraint, we'll toggle a simple flag of our own in each ISR--to indicate that it was triggered--then poll for that flag value in the main loop, where we'll do our timer start/stop actions.  I subbed-in <code>micros()</code> for better accuracy since the time between a button press and a signal received should be small (never on the order of minutes, anyway).</p>

<pre><code>#define ULONG_MAX 0xFFFFFFFFUL

unsigned long startTimeKeeper, stopTimeKeeper, elapsedTime;
volatile boolean buttonFlag = false, signalFlag = false;

void setup() {
  Serial.begin(9600);

  pinMode(2, INPUT);
  pinMode(7, INPUT);
  pinMode(13, OUTPUT);
  pinMode(8, OUTPUT);

  // Int.2 corresponds to pin 2
  attachInterrupt(2, buttonPressed, FALLING);
  // Int.4 corresponds to pin 7
  attachInterrupt(4, signalReceived, RISING);
}

void loop() {
  // Loop until the buttonPressed ISR sets this flag
  if (buttonFlag) {
    // Record the start time
    startTimeKeeper = micros();

    // Do nothing until the signal flag is set by the ISR
    while (!signalFlag);

    // Record the end time
    stopTimeKeeper = micros();

    // Normal case - stop time is apparently after start time
    if (stopTimeKeeper &gt; startTimeKeeper)
      elapsedTime = stopTimeKeeper - startTimeKeeper;
    // Overflow case - stop time is apparently before start time
    else
      elapsedTime = stopTimeKeeper + (ULONG_MAX - startTimeKeeper);

    Serial.print(elapsedTime);

    signalFlag = buttonFlag = false;
  }
}

// Very lightweight ISRs
void buttonPressed() {
  buttonFlag = true;
}

void signalReceived() {
  signalFlag = true;
}
</code></pre>

<p>Since we immediately begin waiting for the <code>signalReceived()</code> ISR to activate <code>signalFlag</code> after we register a button press, we don't have to worry too much about debouncing the switch in this case.</p>

<p>In general, you'll want to debounce your switches, either with physical circuitry or software counters.  Check out <a href=""http://arduino.cc/en/Tutorial/Debounce"" rel=""nofollow"">this tutorial</a> to get started with software, or look <a href=""http://www.labbookpages.co.uk/electronics/debounce.html"" rel=""nofollow"">here</a> for information on building debounce circuits.</p>
",,33837420,286
26811914,2,26811300,2014-11-07T23:41:52.473,0,,2759738,,2016-02-29T11:33:50.530,2016-02-29T11:33:50.530,0,,"<p>What value are you trying to read?</p>

<p>Let's say you have a light sensor. It would look like this:</p>

<pre><code>int photocellPin = 0;
int photocellReading;

void setup() {
    Serial.begin(9600);
    myservo.attach(9);
}

void loop() {
    photcellReading = analogRead(photocellPin);
    myservo.write(photocellReading);
}
</code></pre>
",,33856680,57
26812041,2,26811300,2014-11-07T23:56:03.753,5,,3604898,,2014-11-07T23:56:03.753,,4,,"<p>Your issue is a bit more nuanced than you have laid out. Since Serial.read() will give you each character one at a time, if you type ""180"" in the serial monitor you will get '1' then '8' then '0'.</p>

<p>When you receive a char and change to an int you will get the char equivalent in ASCII. The value of '0' is actually 48 so you will need to handle that. Then with each successive char you will need to shift the result right by one space (power of 10) and insert the new value in the 1's column to reassemble the angle typed in.</p>

<p>Here is some code which should work:</p>

<pre><code>#include &lt;Servo.h&gt;
Servo myservo;

void setup() 
    { 
      myservo.attach(9); 
      Serial.begin(9600);
      myservo.write(0); //or another starting value
    } 


    void loop() 
    { 
      //reset the values each loop but only reprint
      //them to the servo if you hit the while loop
      int angle = 0;

      while(Serial.available() &gt; 0){
        //Get char in and convert to int
        char a = Serial.read();
        int c = (int)a - 48;
        //values will come in one character at a time
        //so you need to increment by a power of 10 for
        //each character that is read
        angle *= 10;
        //then add the 1's column
        angle += c;
        //then write the angle inside the loop
        //if you do it outside you will keep writing 0
        Serial.println(angle);//TODO this is a check. comment out when you are happy
        myservo.write(angle);
      }


    }
</code></pre>
",,33875583,680
35699314,2,26811300,2016-02-29T12:15:17.717,2,,5880678,,2016-02-29T12:15:17.717,,0,,"<p>In short, in your case it is more appropriate to use <a href=""https://www.arduino.cc/en/Reference/ParseInt"" rel=""nofollow""><code>Serial.parseInt()</code></a>:</p>

<pre><code>void loop() {
    if (Serial.available()) {
        int c = Serial.parseInt();
        myservo.write(c);
    }
}
</code></pre>
",,33879391,94
26824023,2,26823892,2014-11-09T01:35:13.160,2,,66363,,2014-11-09T05:05:14.023,2014-11-09T05:05:14.023,1,,"<p>In the private section, declare the member variables</p>

<pre><code>AF_DCMotor motor1;
AF_DCMotor motor2;
AF_DCMotor motor3;
AF_DCMotor motor4; 
</code></pre>

<p>Then in the constructor, initialize them</p>

<pre><code>JAAmtr::JAAmtr() : motor1(1), motor2(2), motor3(3), motor4(4)
{  
    motor1.setSpeed(200); //Turn on the Motor
    motor1.run(RELEASE);
    motor2.setSpeed(200); //Turn on the Motor
    motor2.run(RELEASE);
    motor3.setSpeed(200); //Turn on the Motor
    motor3.run(RELEASE);
    motor4.setSpeed(200); //Turn on the Motor
    motor4.run(RELEASE);

}
</code></pre>
",,33888794,377
26881402,2,26858796,2014-11-12T07:24:05.823,0,,1309431,,2014-11-12T07:24:05.823,,0,,"<p>I eventually did this :</p>

<pre><code>int startVideoRecording() {
    int error;
    error = 0;

    if ((AVRecordingProcess = fork()) != -1) {
        switch (AVRecordingProcess) {
            case -1:
                printf(""Error: Fail to create AVRecordingProcess\n"");
                error = -1;
            case 0:
                setpgid(AVRecordingProcess,0);  &lt;-- NEW
                execl(""record.sh"", ""0"", NULL);
                //system(""//root//record.sh"");
                printf(""Error: Fail to execute AVRecordingProcess\n"");
                error = -1;
            default:
               printf(""Video Recording...process id %d\n"", AVRecordingProcess); 
                break;
        }
    } else {  
        printf(""Error: MainHost failed to fork AVRecordingProcess\n"");
        error = -1;
    } 

    return error;

}

void stopAllRecordings() {
    int ret; 
    FILE *infile, *outfile;
    int ch;


    printf(""Terminating child processes..%d\n"", AVRecordingProcess);
    ret = killpg(AVRecordingProcess, SIGINT); &lt;-- NEW
    printf(""Sending interrupt to GStreamer process.. Status %d\n"", ret);

    int status;
    printf(""Wait for the GStreamer process %d to end...."", AVRecordingProcess);
    waitpid(AVRecordingProcess,0,0); &lt;-- NEW
    printf(""GStreamer ended.\n""); 
}
</code></pre>

<p>and it works. </p>

<p>Basically, during the creation of the AVRecordingProcess, I set it as the head of the process group. 
Sending the process group SIGINT sends it also to the rest of the processes within the group. 
To make sure the process group ended, I used waitpid. </p>

<p>Linux experts, feel free to correct me, thanks! </p>
",,33930792,4016
26920512,2,26911620,2014-11-13T23:39:14.707,1,,369450,,2014-11-15T14:35:33.510,2014-11-15T14:35:33.510,1,,"<p>Your code is C++, but your error suggests you are trying to compile it as a C program because <code>cstdio</code> is the C++ version of C's <code>stdio.h</code>.</p>

<p>Your compile command:</p>

<pre><code>gcc -shared -o mycfile.so -fPIC mycfile.c
</code></pre>

<p>Is trying to compile <code>mycfile.c</code> as C (not C++) which is causing your error. GCC detects the type of file based upon extension (<code>.c</code> for C, <code>.cpp</code>, <code>.cxx</code>, <code>.cc</code> , and <code>.C</code> for C++). Rename <code>mycfile.c</code> to <code>mycfile.cpp</code>, link the C++ runtime library <code>stdc++</code>, and run:</p>

<pre><code>gcc -lstdc++ -shared -o mycfile.so -fPIC mycfile.cpp
</code></pre>

<hr>

<p>I am unfamiliar with <em>CImg</em>, but if you're open to suggestions, you can
give <a href=""https://github.com/nothings/stb/blob/master/stb_image.h"" rel=""nofollow""><em>stb_image.h</em></a> a try:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include ""stb_image.h""

double compare_pictures(const char* path1, const char* path2);

double compare_pictures(const char* path1, const char* path2)
{
    double totalDiff = 0.0;
    unsigned int x, y;

    int width1, height1, comps1;
    unsigned char * image1 = stbi_load(path1, &amp;width1, &amp;height1, &amp;comps1, 0);

    int width2, height2, comps2;
    unsigned char * image2 = stbi_load(path2, &amp;width2, &amp;height2, &amp;comps2, 0);

    if (image1 == NULL || image2 == NULL)
    {
        fprintf(stderr, ""One of the images does not exist\n"");
        return -1;
    }

    if ((width1 != width2) || (height1 != height2))
    {
        fprintf(stderr, ""width/height of the images must match!\n"");
        return -1;
    }
    else 
    {
        for (y = 0; y &lt; height1; y++)
        {
            for (x = 0; x &lt; width1; x++)
            {
                totalDIff += fabs((int)image1[(x + y*width1) * comps1 + 0] - (int)image2[(x + y*width2) * comps2 + 0]) / 255.0;
                totalDiff += fabs((int)image1[(x + y*width1) * comps1 + 1] - (int)image2[(x + y*width2) * comps2 + 1]) / 255.0;
                totalDiff += fabs((int)image1[(x + y*width1) * comps1 + 2] - (int)image2[(x + y*width2) * comps2 + 2]) / 255.0;
            }
        }
        totalDiff = 100.0 * totalDiff / (double)(width1 * height1 * 3);
        printf(""%lf\n"", totalDiff);
        return totalDiff;
    }
}
</code></pre>
",,33978232,893
27022738,2,26911620,2014-11-19T17:06:28.003,1,,2289964,,2014-11-19T17:06:28.003,,0,,"<p>With the tips I gained I created this solution.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#ifndef STB_IMAGE_IMPLEMENTATION
    #define STB_IMAGE_IMPLEMENTATION
    #include ""stb_image.h""

    #ifndef STBI_ASSERT
        #define STBI_ASSERT(x)
    #endif
#endif

#define COLOR_R 0
#define COLOR_G 1
#define COLOR_B 2
#define OFFSET 10

double compare_pictures(const char* path1, const char* path2);

double compare_pictures(const char* path1, const char* path2)
{
    double totalDiff = 0.0, value;
    unsigned int x, y;

    int width1, height1, comps1;
    unsigned char * image1 = stbi_load(path1, &amp;width1, &amp;height1, &amp;comps1, 0);

    int width2, height2, comps2;
    unsigned char * image2 = stbi_load(path2, &amp;width2, &amp;height2, &amp;comps2, 0);

    if (image1 == NULL || image2 == NULL)
    {
        return -1;
    }

    if ((width1 != width2) || (height1 != height2))
    {
        return -2;
    }
    else
    {
        for (y = 0; y &lt; height1; y++)
        {
            for (x = 0; x &lt; width1; x++)
            {
                // Calculate difference in RED 
                value = (int)image1[(x + y*width1) * comps1 + COLOR_R] - (int)image2[(x + y*width2) * comps2 + COLOR_R];
                if (value &lt; OFFSET &amp;&amp; value &gt; (OFFSET * -1)) { value = 0; }
                totalDiff += fabs(value) / 255.0;

                // Calculate difference in GREEN 
                value = (int)image1[(x + y*width1) * comps1 + COLOR_G] - (int)image2[(x + y*width2) * comps2 + COLOR_G];
                if (value &lt; OFFSET &amp;&amp; value &gt; (OFFSET * -1)) { value = 0; }
                totalDiff += fabs(value) / 255.0;

                // Calculate difference in BLUE
                value = (int)image1[(x + y*width1) * comps1 + COLOR_B] - (int)image2[(x + y*width2) * comps2 + COLOR_B];
                if (value &lt; OFFSET &amp;&amp; value &gt; (OFFSET * -1)) { value = 0; }
                totalDiff += fabs(value) / 255.0;
            }
        }
        totalDiff = 100.0 * totalDiff / (double)(width1 * height1 * 3);
        return totalDiff;
    }
}
</code></pre>

<p><strong>Thanks to cpburnz for pointing out to use stb_image.h</strong></p>

<p>stb_image.h is easy to use. I added 2 defines which should be added when using stb_image.h (as I noticed from comments in the .h file)</p>

<hr>

<p>The difference rates where not optimal yet. I created a test environment to optimize the color checks.</p>

<p>I created a few 10x10 images.
- base image which is entirely red (255,0,0)
- test image 1 which contained red (255,0,0) and green (0, 255, 0)
- test image 2 which contained red (255,0,0) and white (255, 255, 255)</p>

<p>Most of the time 255 was seen as 255, 254 or 253. And 0 was seen as 0, 1, 2.
I created an OFFSET (10) which I use to filter the result of these minor color differences.</p>

<p>I created in c a small project which prints out all the red, green and blue values of both images and the difference. And also a visual representence of the difference between the images. (a '.' for same color and a '+' for different color)</p>

<p>Below you see the result of my test environment with the base image and the second test image.</p>

<p><img src=""https://i.stack.imgur.com/haUIv.png"" alt=""Result of my test environment with the base image and the red/white image""></p>
",,34010961,360
26941530,2,26940236,2014-11-15T01:30:50.943,0,,66363,,2014-11-15T01:38:33.867,2014-11-15T01:38:33.867,0,,"<p>I am guessing the sensor is similar to an SRF005. You should include that detail in your question.</p>

<p>The trigger looks okay, but there is no harm in pulsing a little longer, say 20 us, to make sure. The capturing of the echo looks right, except that that datasheet I found says to divide by 5.8, not 58.0, and the return value is an unsigned long, not float..</p>

<p>But you shouldn't be using <code>analogRead()</code> on the echo pin. It will be 0 at that point. Rather, you already have the distance in the <code>cm</code> variable.</p>

<p>(There are sensors which use pin voltage to indicate distance as well, but they don't have trigger and echo pins. Which kind are you actually using?)</p>

<pre><code>void loop()
{
    int cm = 0;

    digitalWrite(TrigPin, LOW); //Low-high-low level sent a short time pulse to TrigPin
    delayMicroseconds(2);
    digitalWrite(TrigPin, HIGH);
    delayMicroseconds(10); // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Change to 20
    digitalWrite(TrigPin, LOW);
    cm = (int)(pulseIn(EchoPin, HIGH) * 10 / 58); //Echo time converted into cm &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 5.8 ????
    Serial.print(cm);
    Serial.print(""cm"");
    Serial.println();


    if(cm &lt; 50)
    {
        digitalWrite(ledPin, HIGH); 
    }
    else
    {
        digitalWrite(ledPin, LOW);
    }

    delay(1000);
}
</code></pre>
",,34013075,129
27354227,2,26944217,2014-12-08T08:41:29.480,7,,2013192,,2018-03-21T13:26:58.147,2018-03-21T13:26:58.147,0,,"<p><code>-std=gnu99</code> is the solution. More detailed below.</p>

<p>Result of the gcc/c99 -M call is identical but it does not mean anything! The explanation of this behavior are preprocessor macros (specifically <strong>GNU extensions</strong>, like said Mat).</p>

<p>In detail:</p>

<pre><code>cat -n main.c
     1  #include &lt;termios.h&gt;
     2
     3  int printf(const char *, ...);
     4
     5  int main(void)
     6  {
     7      printf(""%d\n"", CRTSCTS);
     8      return 0;
     9  }
gcc main.c -o main --std=c89 -&gt; 'CRTSCTS' undeclared compilation error
gcc main.c -o main --std=cgnu89 -&gt; successfully compiled
</code></pre>

<p>This behavior is the same for c99 and gnu99!</p>

<p>Like said Cameron, -M output is identical:</p>

<pre><code>gcc -M --std=c89 main.c | grep termios.h | nl
     1  main.o: main.c /usr/include/termios.h /usr/include/features.h \
     2   /usr/include/arm-linux-gnueabihf/bits/termios.h
gcc -M --std=gnu89 main.c | grep termios.h | nl
1  main.o: main.c /usr/include/termios.h /usr/include/features.h \
     2   /usr/include/arm-linux-gnueabihf/bits/termios.h \
</code></pre>

<p>CRTSCTS is defined in the bits/termios.h when __USE_MISC is defined</p>

<pre><code>     1  #ifdef __USE_MISC
     2  # define CIBAUD   002003600000          /* input baud rate (not used) */
     3  # define CMSPAR   010000000000          /* mark or space (stick) parity */
     4  # define CRTSCTS  020000000000          /* flow control */
</code></pre>

<p>Let's look at __USE_MISC. </p>

<pre><code>gcc -M /usr/include/termios.h | nl
     1  termios.o: /usr/include/termios.h /usr/include/features.h \
     2   /usr/include/arm-linux-gnueabihf/bits/predefs.h \
     3   /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
     4   /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
     5   /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
     6   /usr/include/arm-linux-gnueabihf/bits/types.h \
     7   /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
     8   /usr/include/arm-linux-gnueabihf/bits/termios.h \
     9   /usr/include/arm-linux-gnueabihf/sys/ttydefaults.h
</code></pre>

<p>First one, features.h, contains definition of __USE_MISC, but only when _BSD_SOURCE or _SVID_SOURCE is defined</p>

<pre><code>grep 'define __USE_MISC' /usr/include/features.h -B 1 | nl
     1  #if defined _BSD_SOURCE || defined _SVID_SOURCE
     2  # define __USE_MISC     1
</code></pre>

<p>and _BSD_SOURCE and _SVID_SOURCE is defined when _GNU_SOURCE or 'nothing' is defined</p>

<pre><code>     1  #ifdef _GNU_SOURCE
     2  # undef  _ISOC95_SOURCE
     3  # define _ISOC95_SOURCE 1
     4  # undef  _ISOC99_SOURCE
     5  # define _ISOC99_SOURCE 1
     6  # undef  _POSIX_SOURCE
     7  # define _POSIX_SOURCE  1
     8  # undef  _POSIX_C_SOURCE
     9  # define _POSIX_C_SOURCE        200809L
    10  # undef  _XOPEN_SOURCE
    11  # define _XOPEN_SOURCE  700
    12  # undef  _XOPEN_SOURCE_EXTENDED
    13  # define _XOPEN_SOURCE_EXTENDED 1
    14  # undef  _LARGEFILE64_SOURCE
    15  # define _LARGEFILE64_SOURCE    1
    16  # undef  _BSD_SOURCE
    17  # define _BSD_SOURCE    1
    18  # undef  _SVID_SOURCE
    19  # define _SVID_SOURCE   1
    20  # undef  _ATFILE_SOURCE
    21  # define _ATFILE_SOURCE 1
    22  #endif

    23  /* If nothing (other than _GNU_SOURCE) is defined,
    24     define _BSD_SOURCE and _SVID_SOURCE.  */
    25  #if (!defined __STRICT_ANSI__ &amp;&amp; !defined _ISOC99_SOURCE &amp;&amp; \
    26       !defined _POSIX_SOURCE &amp;&amp; !defined _POSIX_C_SOURCE &amp;&amp; \
    27       !defined _XOPEN_SOURCE &amp;&amp; !defined _BSD_SOURCE &amp;&amp; !defined _SVID_SOURCE)
    28  # define _BSD_SOURCE    1
    29  # define _SVID_SOURCE   1
    30  #endif
</code></pre>
",,34024437,1551
27045694,2,26983548,2014-11-20T17:21:03.000,1,,1738399,,2014-11-20T17:21:03.000,,0,,"<p>Boost has Boost.Preprocessor which does this among other things.  From:</p>

<p><a href=""http://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html</a></p>

<p><strong>BOOST_PP_REPEAT</strong></p>

<p>For your code:</p>

<pre><code>#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;

#define OP(z, n, text) text
...
__asm__( BOOST_PP_REPEAT(5, OP, ""noop\n""\t);
</code></pre>
",,34050119,526
29144052,2,26983548,2015-03-19T12:01:42.400,8,,4057102,,2015-07-26T10:29:09.503,2015-07-26T10:29:09.503,1,,"<p>If you want to do it without including a whole library or using define, you can use a <em>simple</em> recursive template:</p>

<pre><code>//By Christopher Andrews, released under MIT licence.

template&lt; unsigned N &gt; struct Nops{
  static void generate() __attribute__((always_inline)){
    __asm__ volatile (""nop"");
    Nops&lt; N - 1 &gt;::generate();
  }
};
template&lt;&gt; struct Nops&lt;0&gt;{ static inline void generate(){} };

void setup() {
  Nops&lt;10&gt;::generate();
}

void loop(){}
</code></pre>

<p>This will generate the exact number of nop's required.</p>

<blockquote>
  <p>0000010a setup:<br>
   10a: 00 00           nop<br>
   10c: 00 00           nop<br>
   10e: 00 00           nop<br>
   110: 00 00           nop<br>
   112: 00 00           nop<br>
   114: 00 00           nop<br>
   116: 00 00           nop<br>
   118: 00 00           nop<br>
   11a: 00 00           nop<br>
   11c: 00 00           nop<br>
   11e: 08 95           ret</p>
</blockquote>

<p>I have used this method in a TFT driver for Arduino.</p>

<h2>EDIT:</h2>

<p>There is another way to easily do this on an AVR compiled with avr-gcc. I'm assuming this may not be available on older toolchains.</p>

<blockquote>
  <p>In order to delay execution for a specific number of cycles, GCC
  implements</p>
  
  <p><code>void __builtin_avr_delay_cycles (unsigned long ticks)</code> ticks is the number of ticks to delay execution. Note that this built-in does
  not take into account the effect of interrupts which might increase
  delay time. ticks must be a compile time integer constant; delays with
  a variable number of cycles are not supported</p>
</blockquote>

<p>From here: <a href=""https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/AVR-Built_002din-Functions.html"" rel=""noreferrer"">https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/AVR-Built_002din-Functions.html</a></p>
",,34089453,1869
45630251,2,26983548,2017-08-11T08:18:50.853,3,,4456192,,2017-08-11T08:18:50.853,,0,,"<p>The following code works with GNU C,</p>

<pre><code>#define NOP __asm__(""nop"")

#define ten(a)     a;a;a;a;a;a;a;a;a;a
#define handred(a) ten(ten(a))


int
main()
{
    handred(NOP);
    return 0;
}
</code></pre>

<p>Compile and debug:</p>

<pre><code>code@lab:~/debug$ gcc -g -o debug_NOP debug_NOP.c
code@lab:~/debug$ gdb -q --nh debug_NOP
Reading symbols from debug_NOP...done.
(gdb) set disassembly-flavor intel
(gdb) start
Temporary breakpoint 1 at 0x664: file debug_NOP.c, line 10.
Starting program: /home/code/debug/debug_NOP 

Temporary breakpoint 1, main () at debug_NOP.c:10
10      handred(NOP);
(gdb) disassemble 
Dump of assembler code for function main:
   0x0000555555554660 &lt;+0&gt;: push   rbp
   0x0000555555554661 &lt;+1&gt;: mov    rbp,rsp
=&gt; 0x0000555555554664 &lt;+4&gt;: nop
   0x0000555555554665 &lt;+5&gt;: nop
   0x0000555555554666 &lt;+6&gt;: nop
   0x0000555555554667 &lt;+7&gt;: nop
   0x0000555555554668 &lt;+8&gt;: nop
   0x0000555555554669 &lt;+9&gt;: nop
   ....
   0x00005555555546c6 &lt;+102&gt;:   nop
   0x00005555555546c7 &lt;+103&gt;:   nop
   0x00005555555546c8 &lt;+104&gt;:   mov    eax,0x0
   0x00005555555546cd &lt;+109&gt;:   pop    rbp
   0x00005555555546ce &lt;+110&gt;:   ret    
End of assembler dump.
</code></pre>
",,34096172,200
26989246,2,26988940,2014-11-18T07:57:54.897,3,,28169,,2014-11-18T08:20:35.930,2014-11-18T08:20:35.930,2,,"<p>No, there's no such thing as <code>volatile</code> in Python, it's a much too low-level concept.</p>

<p>You should just make sure there is some shared context (like an object instance) in which the variable can reside, so that it can be shared between the two contexts. Python will do the rest.</p>

<pre><code>class MyApp(object):
  def __init__(self):
    self._counter = 0
    registerInterrupt(self.interruptHandler)

  def interruptHandler(self):
    self._counter += 1

  def getCount(self):
    return self._counter
</code></pre>

<p>Something like that could be enough, of course you'd have to fill in the details and make the required call(s) to create an instance of <code>MyApp</code> and make sure there's a function <code>registerInterrupt()</code> that does the needed work to set up the callback into the instance.</p>

<p>Also, do note that a <code>counter</code> of events should almost never be <code>float</code> in C, that's incredibly strange design.</p>
",,34103553,52
27134707,2,27134512,2014-11-25T19:07:01.230,2,,4288486,,2014-11-25T19:52:49.310,2014-11-25T19:52:49.310,1,,"<p>The common code can be factored out of the if statement </p>

<p>You can use a switch statement for the only character that changes in the string</p>

<pre><code>switch(obj[4]) {
    case 'r':
        Serial.println(""RED: "" + red_brightness );
    case 'g':
        Serial.println(""GREEN: "" + green_brightness );
    case 'b':
        Serial.println(""BLUE: "" + blue_brightness );
}
</code></pre>
",,34110974,3605
27134834,2,27134512,2014-11-25T19:15:32.093,5,,4192931,,2014-11-25T19:15:32.093,,2,,"<p>The other answers prior to this are good too.  The advantage of this answer is that you can change the option names to anything and it would still work.  You can also extend this kind of option parsing to a much larger set of options.</p>

<pre><code>// Assuming these are globals.
int red_brightness, green_brightness, blue_brightness;

// Use this array to help you parse.
static const struct {
    const char *optionName;
    int        *brightness;
    const char *label;
} ledOptions[] = {
    { ""led_r"", &amp;red_brightness,   "" RED: ""   },
    { ""led_g"", &amp;green_brightness, "" GREEN: "" },
    { ""led_b"", &amp;blue_brightness,  "" BLUE: ""  },
};

// A handy macro for later.
#define DIM(array)  (sizeof(array) / sizeof(array[0]))

...

// Now in your actual code:    
strlcpy(obj, &amp;jarr[i], arr[i]);
for (j=0;j&lt;DIM(ledOptions);j++) {
    if( !strcmp( obj, ledOptions[i].optionName ) ){
        i++;
        strlcpy( obj, &amp;jarr[i], arr[i] );
        *ledOptions[i].brightness = atoi( obj );

        Serial.print(ledOptions[i].label);
        Serial.println(*ledOptions[i].brightness);
    }
}
</code></pre>
",,34111853,888
27135275,2,27134512,2014-11-25T19:41:12.900,0,,433209,,2014-11-25T19:53:24.313,2014-11-25T19:53:24.313,0,,"<p>This is what I came up with. Disclaimer, I haven't tried to compile/run it.</p>

<pre><code>for (int i=0; i&lt;6; i++)
{
   i++;
   int b = atoi( &amp;jarr[i] );
   switch (i)
   {
     case 1:
        Serial.print("" RED: "");
        red_brightness = b;
        break;
     case 3: 
        Serial.print("" GREEN: "");
        green_brightness = b;
        break;
     case 5:
        Serial.print("" BLUE: "");
        blue_brightness = b;
        break;
     default:
        break;
   }
   Serial.println(b);
}
</code></pre>

<p>The idea being that values you want to print are in the &amp;jarr[] at the odd number indexes.</p>
",,34121110,3968
27137057,2,27134512,2014-11-25T21:29:56.810,0,,1521926,,2014-11-25T21:29:56.810,,0,,"<p>Just for fun here my personal approach of this ...</p>

<pre><code>#ifndef ARDUINO
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

/* PART of code derived from question but unspecified in code . done to be able to compile */

// this is not specified in question 
//   either it a char jarr[1024] but then why do we iterate on char ( i++ would go to next char and not to next word )
//   either it is a char* jar[6] but then we access its char * content with jarr[i] and not with &amp;jarr[i]
//char * jarr[6];
// this look like to be size of each argument.
//int arr[6];

/*
TEST vectors
 */

char * jarr0[] = { ""led_r"", ""200"", ""led_g"", ""100"", ""led_b"", ""150"" };
int arr0[] = { 5, 3, 5,3, 5,3 };

char * jarr1[] = { ""led_g"", ""200"", ""led_r"", ""100"", ""led_b"", ""150"" };
int arr1[] = { 5, 3, 5,3, 5,3 };

char * jarr2[] = { ""lgd_g"", ""200"", ""ged_r"", ""100"", ""led_b"", ""150"" };
int arr2[] = { 5, 3, 5,3, 5,3 };

int red_brightness = 0;
int blue_brightness = 0;
int green_brightness = 0;

/* end of unspecified PART */
#endif

/*real code *

/* use indirection */
struct led_color_map {
  int * color_brightness_p;
  const char * color_name;
  char key;
} led_color[] = {
  {&amp;red_brightness,""RED"",'r'},
  {&amp;green_brightness,""GREEN"",'g'},
  {&amp;blue_brightness,""BLUE"",'b'}
};


enum { RED_IDX=0, GREEN_IDX, BLUE_IDX };

// for perf test
int miss = 0;

#ifdef ARDUINO
void led_setup()
#else
  void led_setup(char * jarr[], int arr[])
#endif
{

  char* obj=NULL;
  int i=0;
  int offset=0;

  for (i=0; i &lt;6; i+=2)
    {
      obj=jarr[i];
      // test 'led_' prefix with reverse statistical letter apparence
      // which is 'l' then 'd' then 'e' , guessing that '_' can be used in other words ... 
      if ( ( obj[0] == 'l' ) &amp;&amp; ( obj[2] == 'd' ) &amp;&amp; (obj[1] == 'e' ) &amp;&amp; (obj[3] == '_') )
    {
      int idx=0;
      for ( idx = 0; idx &lt;= BLUE_IDX; idx ++)
        {
          int rolling_idx = (idx + offset) % ( BLUE_IDX + 1 );
          struct led_color_map * color_found = &amp;led_color[rolling_idx]; 
          if ( color_found-&gt;key == obj[4] )
        {
          char ivalue[32];
          if ( arr[i+1] &lt; sizeof(ivalue) )
            {
              #ifdef ARDUINO
              strlcpy(ivalue, jarr[i+1], arr[i+1]);
              #else
              strncpy(ivalue, jarr[i+1], arr[i+1]);
              #endif
              {
            int brightness = atoi( ivalue );
            *(color_found-&gt;color_brightness_p) = brightness;
            #ifdef ARDUINO
            Serial.print( color_found-&gt;color_name );
            Serial.println( *color_brightness );
            #else
            printf("" %s :%i\n"", color_found-&gt;color_name, brightness);
            #endif
              }
              offset=(rolling_idx + 1) % ( BLUE_IDX + 1 ); // try with next color first next time.
              break;
            }
        }
          else
        {
          miss ++;
          printf(""miss %i wrong color order expected %s\n"",miss, led_color[rolling_idx].color_name);
        }
        }     
    }
      else
    {
      miss ++;
      printf(""miss %i wrong variable expected led_%c\n"", miss, led_color[offset % ( BLUE_IDX + 1 )].key);
    }
    }

}

#ifndef ARDUINO
int main(int argc, char ** argv)
{

led_setup(jarr0, arr0);
 printf(""test0 : miss %i\n"",miss);

miss=0;
led_setup(jarr1, arr1);
 printf(""test1 : miss %i\n"",miss);

miss=0;
led_setup(jarr2, arr2);
 printf(""test2 : miss %i\n"",miss);

}
#endif
</code></pre>

<p>gcc led.c
./a.out</p>

<pre><code> RED :200
 GREEN :100
 BLUE :150
test0 : miss 0
miss 1 wrong color order expected RED
 GREEN :200
miss 2 wrong color order expected BLUE
 RED :100
miss 3 wrong color order expected GREEN
 BLUE :150
test1 : miss 3
miss 1 wrong variable expected led_r
miss 2 wrong variable expected led_r
miss 3 wrong color order expected RED
miss 4 wrong color order expected GREEN
 BLUE :150
test2 : miss 4
</code></pre>
",,34122599,114
27159226,2,27134512,2014-11-26T21:31:18.433,0,,3743152,,2014-11-26T21:31:18.433,,0,,"<pre><code>char obj[5];
strlcpy(obj, &amp;jarr[i], arr[i]);
int *brightness;
String ostr();
if( !strcmp( obj, ""led_r"" ) ){
 ostr = "" RED: "";
 brightness = red_brightness;
}
if( !strcmp( obj, ""led_g"" ) ){
 ostr = "" GREEN: "";
 brightness = green_brightness;
}
if( !strcmp( obj, ""led_b"" ) ){
 ostr = "" BLUE: "";
 brightness = blue_brightness;
}
i++;
strlcpy( obj, &amp;jarr[i], arr[i] );
*brightness = atoi( obj );
Serial.print(ostr);
Serial.println(*brightness);
</code></pre>
",,34261512,5146
27158146,2,27155572,2014-11-26T20:18:17.573,1,,3368201,,2014-11-26T20:18:17.573,,3,,"<p>First of all.... Why do you set the registers? Arduino's only benefit is that it wraps up some functions, so why not use it? Instead of</p>

<pre><code>DDRB =  0b11111111;
PORTB = 0b00000000;
...
PORTB ^=1&lt;&lt;PINB5;
</code></pre>

<p>use simply</p>

<pre><code>int myoutpin = XXXX; // Put here the number of the ARDUINO pin you want to use as output
...
pinMode(myoutpin, OUTPUT);
...
digitalWrite(myoutpin, !digitalRead(myoutpin));
</code></pre>

<p>I think that probably there are some similar functions for the timer too..</p>

<p>As for your question, I tried this code:</p>

<pre><code>// the setup routine runs once when you press reset:
void setup() {
  TCCR1A = 0; //clear control register A (not sure that I need this)
  TCCR1B |= 1&lt;&lt;CS10; //no prescaler, turns on CS10 bit of TCCR1B
  Serial.begin(9600);
}

// the loop routine runs over and over again forever:
void loop() {
  if (TCNT1 &gt;= 12000){
    TCNT1 = 0; //resets timer to zero
    Serial.println(""Timer hit"");
  } 
}
</code></pre>

<p>in a simulator and it works well; I should try it with a real Arduino, but I haven't any at the moment... As soon as i get one I'll try to use it</p>
",,34308740,154
27169082,2,27168976,2014-11-27T11:03:44.957,0,,28169,,2014-11-27T11:03:44.957,,1,,"<p>Don't use string-like data types for this, since strings are represented as arrays in C and arrays are not assignable.</p>

<p>Encode the color in an integer, the typical choice would be <code>uint32_t</code> for full 24-bit RGB, with 8 bits to spare.</p>

<p>Then you'd just have:</p>

<pre><code>uint32_t heelwheel[12];
</code></pre>

<p>And the colours defined like so:</p>

<pre><code>/* these assume red in the msbs, blue in the lsbs. */
const uint32_t red = 0xff0000;
const uint32_t purple = 0xff00ff;
const uint32_t yellow = 0xffff00;
/* and so on */
</code></pre>

<p>And you can assign directly, no problems:</p>

<pre><code>heelwheel[0] = red;
heelwheel[1] = purple;
</code></pre>
",,34317500,263
27192363,2,27188148,2014-11-28T16:04:10.383,0,,1804251,,2014-11-28T16:04:10.383,,1,,"<p>The error is really really really small and i noticed it just by luck. </p>

<p>I changed the counter of the list to byte to reduce the steps. But if my list is empty it is -1 so this would not work. Thats all! changed the count to short type and it works!</p>

<pre><code>template &lt;typename T&gt;
class LinkedList
{
private:
    struct Node
    {
        Node* prev;
        Node* next;
        T value;
    };

    Node* last;
    Node* first;
    short count; // HERE 
/...
};
</code></pre>
",,34328414,252
27208167,2,27208137,2014-11-29T23:11:03.307,1,,,user4118620,2014-11-29T23:11:03.307,,1,,"<p>If you want to execute code depending on whether <code>isASH</code> returned true of false, just do this:</p>

<pre><code>if (isASH(&amp;buf)) {
  // This is ASH
  ASHtoChar(...);
} else {
  // This is not ASH
}
</code></pre>

<p>Is this what you were looking for?</p>
",,34342802,28
27236966,2,27236703,2014-12-01T20:45:10.127,0,,168986,,2014-12-01T20:45:10.127,,0,,"<p><code>strcmp()</code> won't do that.  <code>scanf()</code> will, do something close:</p>

<pre><code>int i ;
if( scanf( ""LP%d"", &amp;i) == 1 )
{
    printf( ""match"" ) ;
}
else
{
    printf( ""no match"" ) ;
}
</code></pre>

<p>But not specifically 5 digits.  The obvious solution is to use a <em>regular expression</em> library, but that might be a little heavyweight for Arduino and this simple requirement - it would be easy enough to write your own function to your specific requirement.</p>
",,34390406,1268
27239431,2,27236703,2014-12-01T23:40:45.283,1,,971127,,2014-12-01T23:40:45.283,,0,,"<pre><code>int i,j,k,l,m;
if(strlen(input)==7 &amp;&amp;
   sscanf(input, ""LP%1d%1d%1d%1d%1d"", &amp;i,&amp;j,&amp;k,&amp;l,&amp;m)==5)
{
    //run this
}
</code></pre>
",,34390979,60
27242635,2,27236703,2014-12-02T05:41:41.453,0,,3944479,,2014-12-02T06:59:03.583,2014-12-02T06:59:03.583,0,,"<p>Here is a piece of code that might suit your requirement very well, this code copies the first two letters from a[0] to a[1] . Furthermore, it then places a check to see if the letters entered were indeed L and P</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
  char* a[2] ;
  int size = 7;
  a[0] = (void *) malloc( sizeof(char) * ( size + 1 ) );
  a[1] = (void *) malloc( sizeof(char) * 2 );
  printf(""Enter device\n"");
  fgets(a[0], 8, stdin);
  //strcpy( a[0], ""LPC1768"");
  puts(a[0]);
  printf(""\n"");
  //printf(""a[0] = %s\n"", a[0]);
  memcpy( a[1], a[0], 2 );
  if ( *(a[1]) == 'L' &amp;&amp; *(a[1] + 1) == 'P')
  {
    puts(a[1]);
  }
free(a[0]);
free(a[1]);
}
</code></pre>
",,34423244,693
27245758,2,27242253,2014-12-02T09:19:08.870,0,,4209269,,2014-12-02T09:19:08.870,,1,,"<p>change </p>

<pre><code> if (statusLed1 = true) {
    Serial.print(""on"");
  } 
  if (statusLed1 = false){
    Serial.print(""off"");
  }
}
</code></pre>

<p>to </p>

<pre><code> if (statusLed1 == true) {
    Serial.print(""on"");
  } 
  if (statusLed1 == false){
    Serial.print(""off"");
  }
}
</code></pre>

<p>or </p>

<pre><code> if (statusLed1) {
    Serial.print(""on"");
  } 
  if (!statusLed1){
    Serial.print(""off"");
  }
}
</code></pre>
",,34431412,1078
27250948,2,27242894,2014-12-02T13:43:20.380,1,,2056772,,2014-12-02T13:43:20.380,,4,,"<p>there is something quite broken here:</p>

<pre><code>  CvSize size = cvSize(100, 100);
  if ((img = cvCreateImage(size, IPL_DEPTH_16S, 1)) != NULL) {
     img = frame;
     cvSaveImage(pathToImage, img);
  }
</code></pre>

<p>first, you create a useless 16-bit image (why even?), then you reassign(alias) that pointer to your original image, and then you don't cvReleaseImage it (memleak).</p>

<p>please, stop using opencv's deprecated c-api. please.</p>

<p>any noob <em>will</em> shoot into his foot using this (one of the main reasons to get rid of it)</p>

<p>also, you can only use ~30% of opencv's functionality this way (the opencv1.0 set)</p>

<p>again, please, stop using opencv's deprecated c-api. please.</p>
",,34463713,128
27270318,2,27264935,2014-12-03T11:15:22.467,0,,2205264,,2014-12-03T11:15:22.467,,0,,"<p>You have to use the condition `while(Serial.available()) { //do something }``</p>

<p>This way, the main <code>loop()</code> function will continue to run and the <code>while</code> loop will only be executed when the condition is met, i.e. when there are serial data available to read.</p>

<p>The <code>Serial.available()</code> function is a callback to another function run outside of <code>void loop()</code></p>

<p>This is what a real Arduino program looks like:</p>

<pre><code>int main(void)
{
 init();
 initVariant();
#if defined(USBCON)
 USBDevice.attach();
#endif

 setup();

 for (;;) {
  loop();
  if (serialEventRun) serialEventRun();
 }

 return 0;
}
</code></pre>

<p>As you can see, if your program is stuck in <code>while(!Serial.avalaible())</code> inside loop, there is no way it could reach the 'if (serialEventRun) serialEventrun();` line. Therefore the issue you are having.</p>

<p>Here is a very interesting discussion about this issue on the Arduino Google Groups : <a href=""https://groups.google.com/a/arduino.cc/forum/#!topic/developers/dtxWeWVza5s"" rel=""nofollow"">Defect In SerialEvent</a></p>

<p>Hope this helps.</p>
",,34466946,92
27335179,2,27335115,2014-12-06T18:51:43.827,2,,3134621,,2014-12-06T19:17:08.953,2014-12-06T19:17:08.953,9,,"<blockquote>
  <p>...leading 'B' only works with 8 bit values (0 to 255)...</p>
</blockquote>

<p>from <a href=""http://arduino.cc/en/pmwiki.php?n=Reference/IntegerConstants"" rel=""nofollow"">http://arduino.cc/en/pmwiki.php?n=Reference/IntegerConstants</a>  </p>

<p>Just use hexadecimal notation, ie. <code>0x0000</code> for 2 bytes.<br>
<code>0x</code> signals that it is hex, and every digit (<code>0123456789ABCDEF</code>) replaces 4 bit.  </p>

<p>Instead of bitRead and bitSet, you can use following code;<br>
The variable is x and the bit number i, with i=0 is the right-most bit, 1 the next ...):  </p>

<pre><code>//set bit to 1
x |= 1&lt;&lt;i;
//set bit to 0
x &amp;= ~(1&lt;&lt;i);
//check if bit is set
if(x &amp; (1&lt;&lt;i))  
</code></pre>

<p>Eg. <code>x &amp;= ~(1&lt;&lt;3);</code> sets a value B11111111 (in binary representation) to B11110111,<br>
that is 0xff to 0xf7. Btw., <code>x &amp;= ~(1&lt;&lt;3);</code> is equivalent to <code>x &amp;= ~8;</code></p>
",,34469728,2432
27347452,2,27347289,2014-12-07T20:31:35.217,0,,1413395,,2014-12-07T20:31:35.217,2017-05-23T11:43:32.933,0,,"<p>Instead of using a pointer returned from a locally defined raw array on the stack, you must use a <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow noreferrer""><strong><code>std::array</code></strong></a> to make the returned values accessible:</p>

<pre><code>std::array&lt;float,2&gt; CreateArray(int i) {
    std::array&lt;float,2&gt; test;
    test[0] = float(i+1); 
    test[1] = float(i+2);
    return test;
}
</code></pre>

<p>This should fix all of your problems regarding undefined behavior, as stated in the <a href=""https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"">formerly marked duplicate</a> to this question.</p>
",,34472585,132
28135902,2,27359717,2015-01-25T11:35:30.760,0,,2028569,,2015-01-25T11:35:30.760,,0,,"<p>This worked for me, </p>

<pre><code>String CharArrayInLocal[20];
String inputString = """";         
boolean stringComplete = false;  
int i=0;

void serialEvent() {
while (Serial.available()) {

char inChar = (char)Serial.read();

    if (inChar == '\n') {

      CharArrayInLocal[i]=inputString;

      i++;
      stringComplete = true;
      inputString="""";
    }
    else{
      inputString += inChar;
    }
  }
}
</code></pre>
",,34503358,44
27385803,2,27385183,2014-12-09T18:08:53.423,1,,1496472,,2014-12-09T18:08:53.423,,2,,"<p>I'm sure I'm probably violating SO protocol here, but base on your comments, you can do:</p>

<pre><code>a = 100;
b = 23;
Serial.print('#');
Serial.print(a);
Serial.print('#');
Serial.println(b);
</code></pre>

<p>This will send this string of characters to your serial port: ""#100#23"", and in what is probably the most efficient way possible.</p>
",,34526720,250
44593931,2,27392261,2017-06-16T16:27:19.850,6,,2179756,,2017-06-16T16:27:19.850,,1,,"<p>Assuming you want to print ""number"" in HEX:</p>

<pre><code>  uint64_t number;
  unsigned long long1 = (unsigned long)((number &amp; 0xFFFF0000) &gt;&gt; 16 );
  unsigned long long2 = (unsigned long)((number &amp; 0x0000FFFF));

  String hex = String(long1, HEX) + String(long2, HEX); // six octets
</code></pre>
",,34559058,5788
49719356,2,27392261,2018-04-08T15:11:57.603,4,,131929,,2018-04-08T15:11:57.603,,0,,"<p>This is like the sequel to the answer by @john.</p>

<p>I use the following function:</p>

<pre><code>String uint64ToString(uint64_t input) {
  String result = """";
  uint8_t base = 10;

  do {
    char c = input % base;
    input /= base;

    if (c &lt; 10)
      c +='0';
    else
      c += 'A' - 10;
    result = c + result;
  } while (input);
  return result;
}
</code></pre>

<p>Source: <a href=""https://github.com/markszabo/IRremoteESP8266/blob/master/src/IRutils.cpp#L48"" rel=""nofollow noreferrer"">https://github.com/markszabo/IRremoteESP8266/blob/master/src/IRutils.cpp#L48</a></p>
",,34570304,221
50279664,2,27392261,2018-05-10T18:50:30.210,4,,9772636,,2018-05-10T18:50:30.210,,0,,"<p>Just to add onto the list of possible solutions. 
I use the following function:</p>

<pre><code>char *uint64_to_string(uint64_t input)
{
    static char result[21] = """";
    // Clear result from any leftover digits from previous function call.
    memset(&amp;result[0], 0, sizeof(result));
    // temp is used as a temporary result storage to prevent sprintf bugs.
    char temp[21] = """";
    char c;
    uint8_t base = 10;

    while (input) 
    {
        int num = input % base;
        input /= base;
        c = '0' + num;

        sprintf(temp, ""%c%s"", c, result);
        strcpy(result, temp);
    } 
    return result;
}
</code></pre>
",,34579873,284
27409884,2,27409566,2014-12-10T20:07:12.553,0,,3179706,,2014-12-10T20:07:12.553,,2,,"<pre><code>for(int i; i&lt;2; i++)
{
    for(int i; i&lt;4; i++)digitalWrite(led[i],HIGH);
    delay(delaySwitch);
    for(int i; i&lt;4; i++)digitalWrite(led[i],LOW);
}
</code></pre>

<p>You have a problem in the section above. Looks like you're trying to declare the variable ""i"" within the scope of the loop where it's already declared. Try doing this: </p>

<pre><code>for(int i; i&lt;2; i++)
{
    for(int x; x&lt;4; x++)digitalWrite(led[x],HIGH);
    delay(delaySwitch);
    for(int z; z&lt;4; z++)digitalWrite(led[z],LOW);
}
</code></pre>
",,34597189,564
27412489,2,27412408,2014-12-10T23:04:17.153,2,,1769720,,2014-12-10T23:19:48.537,2014-12-10T23:19:48.537,2,,"<p>What you probably want is to cut your moves in increments, and check the sensors in between each of these increments:</p>

<pre><code>while (distance &gt; 0 &amp;&amp; !Obstacle){
    forward(step);
    distance-=step;
    check_sensors();
}
</code></pre>

<p>With multithreading, you could make those operations (moving and sensing) work asynchronously, and use some kind of event posting to warn each thread of a change. Here we're simulating that functionality by interwinding the tasks (you could also look into coroutines for a similar, yet much more effective idea).</p>
",,34631256,326
27419015,2,27418767,2014-12-11T09:09:59.863,1,,2703418,,2014-12-11T09:31:28.663,2014-12-11T09:31:28.663,7,,"<p>The basic syntax of a <code>make</code> rule is:</p>

<pre><code>target … : prerequisites …
    recipe
    …
    …
</code></pre>

<p>On the left of the semicolon are the targets. The targets are your object files(<code>.o</code>). On the right of the semicolon are the files that you will need to create this file. Those files are the source files(<code>.c</code>).</p>

<p>Lets give a basic example of what such a rule could look like.</p>

<pre><code>%.o: %.c
    gcc -c $&lt; -o $@
</code></pre>

<p>The <code>%</code> sign is a wildcard. <code>%.o</code> means everything that ends with <code>.o</code>. So, if you want to make an object file, you can say <code>make file.o</code>, and <code>make</code> will try to find a rule with which it can make this target. This happens to be the rule I just showed as an example, because <code>file.o</code> matches <code>%.o</code>.</p>

<p>Then the <code>recipe</code>. This is what will be executed. Usually it's about invoking the compiler(<code>gcc</code>), and feeding it the source file to generate the object file. That's what we do with <code>gcc -c $&lt; -o $@</code>. The <code>$&lt;</code> and <code>$@</code> mean <code>target</code> and <code>prerequisites</code> respectively.</p>

<p>So, what happens when you 'just' want to build your program? You usually will type <code>make</code>, and it will build. The default rule that's used when you type <code>make</code>, is <code>all</code>. So, if you make a rule about <code>all</code>,  then you can specify what files you want to create to build your program. Example of such a rule:</p>

<pre><code>all: main
</code></pre>

<p>Then, when <code>make</code> is invoked, it will find that rule and finds out it needs <code>main</code>. To create <code>main</code> you need another rule:</p>

<pre><code>main: file.o
</code></pre>

<p>This rule says that to build <code>main</code>, you need <code>file.o</code>. So, when you put all of the example rules together you get this:</p>

<pre><code>all: main

main: file.o

%.o: %.c
    gcc -c $&lt; -o $@
</code></pre>

<p>Note that you can specify more than one file, so instead of <code>file.o</code>, you can say <code>file.o main.o other_file.o</code> etc. Every prerequisite that you specify will be made, if they can find a rule to make it.</p>
",,34672254,62
27419330,2,27418767,2014-12-11T09:26:47.747,1,,440558,,2014-12-11T09:26:47.747,,0,,"<p>A very simple but typical makefile could look like this</p>

<pre><code>SOURCES = source1.c source2.c source3.c
OBJECTS = $(SOURCES:%.c=%.o)

TARGET = myExecutable

$(TARGET): $(OBJECTS)
    gcc $^ -o $@

%.o: %.c
    gcc -c $&lt; -o $@
</code></pre>

<p>The complicated parts:</p>

<ul>
<li><p><code>SOURCES = source1.c source2.c source3.c</code> This is a variable definition, it assigns the string <code>""source1.c source2.c source3.c</code> to the variable <code>SOURCES</code>.</p></li>
<li><p><code>$(SOURCES:%.c=%.o)</code> This is a shorthand for the <code>patsubst</code> <a href=""http://www.gnu.org/software/make/manual/make.html#Text-Functions"" rel=""nofollow"">text function</a>. It takes all text from the <code>$(SOUCES)</code> variable, and replaces the pattern <code>%.c</code> with <code>%.o</code>, i.e. it takes e.g. the string <code>source1.c</code> and replace it with <code>source1.o</code>.</p></li>
<li><p><code>$(TARGET): $(OBJECTS)</code> This makes <code>myExecutable</code> depend on all object files, meaning if one object file is modified then the command in the rule will be executed.</p></li>
<li><p><code>gcc $^ -o $@</code> This calls the <code>gcc</code> command, passing all dependencies (<code>$^</code>) as arguments (that is, all object files), and tells <code>gcc</code> to output a file with the name of the target (<code>$@</code>).</p></li>
<li><p><code>%.o: %.c</code> This is the rule that makes object files depend in their source file. So if you have <code>source1.c</code> then <code>source1.o</code> will depend on that source file.</p></li>
<li><p><code>gcc -c $&lt; -o $@</code> This is the command that compiles the source file (the first dependency, <code>$&lt;</code>) to an object file (with the <code>-c</code> option) and name it as the target of the rule (<code>$@</code>).</p></li>
</ul>

<p>Also note that if you invoke <code>make</code> without a specific target, then the first rule will be selected. In the case of the above makefile, it will be the <code>$(TARGET): $(OBJECTS)</code> rule which will make sure that all object files are build from the source files, and then link the object files into the resulting executable.</p>
",,34681286,1869
27430017,2,27426945,2014-12-11T18:35:44.217,1,,898142,,2014-12-11T18:35:44.217,,2,,"<p>ReadFile() can return success even when zero bytes are read. Use dwBytesRead to find the actual number of received characters.</p>

<pre><code>while (ReadFile(hserial, buffer, 1, &amp;dwBytesRead, NULL)) 
{
    if (dwBytesRead != 0)
    {
       store += buffer[0];

       if (buffer[0] == '?')  
       {                               
           end = true;     
           break;
       }
    }
}
</code></pre>
",,34704778,2074
27446956,2,27446179,2014-12-12T15:34:16.290,0,,205608,,2014-12-12T15:34:16.290,,0,,"<p>You're implementing HTTP line by line in your C++ program. It's probably helpful for your learning to look up the appropriate RFCs even if they're a little hard to read.  <a href=""http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5"" rel=""nofollow"">http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5</a></p>

<p>Given the GET request you've shown us, your <code>add_data.php</code> program needs to accept the <code>$_REQUEST['sensor']</code> parameter. I can't find where you do that.</p>

<p>Your HTTP client program, on your Arduino, needs to send this kind of block to your web server running your php program.  First, it opens a connection to the server. You seem to have done this correctly on port 80. Then it sends something like this.</p>

<pre><code>GET /te/add_data.php?sensor=2323 HTTP/1.1\r\n
Host: 192.168.1.7\r\n
User-Agent: Arduino\r\n
Accept: text/html\r\n
\r\n
</code></pre>

<p>Notice two things.</p>

<ol>
<li>Your payload -- your useful information being sent to the php program -- is entirely in the GET line.</li>
<li>Each line needs to end with carriage return/newline. And, at the end of the request block, there needs to be a blank line that ends with an extra carriage return / newline.</li>
</ol>

<p>Your C++ code -- your <code>client.println()</code> code -- doesn't seem to do that. In particular, the value of <code>newtag</code> will be misplaced in your request block.</p>

<p>Notice also that the only item of data you're sending to the php program is 'sensor', and you're sending it the hard-coded value <code>2323</code>. I can't tell from your program exactly what you're trying to do. But what you're doing isn't very interesting, so maybe it's a test to get things working.</p>

<p>I hope this helps. When you get it working, you will have implemented a reasonably complex system.</p>
",,34716017,1425
27476220,2,27475951,2014-12-15T01:33:04.360,1,,3959454,,2014-12-15T01:33:04.360,,0,,"<p>I have no experience in Arduino, but here is what I've unerstood after reading <a href=""https://github.com/FastLED/FastLED/blob/master/FastLED.h"" rel=""nofollow"">FastLED.h</a>.</p>

<p><code>TM1803</code> is <a href=""https://github.com/FastLED/FastLED/blob/master/FastLED.h#L58"" rel=""nofollow"">declared as</a>:</p>

<pre><code>template&lt;uint8_t DATA_PIN, EOrder RGB_ORDER&gt;
class TM1803 : public TM1803Controller400Khz&lt;DATA_PIN, RGB_ORDER&gt; {};
</code></pre>

<p>So <code>LEDS.addLeds()</code> should somehow invoke one of <a href=""https://github.com/FastLED/FastLED/blob/master/FastLED.h#L154"" rel=""nofollow"">these two overloads</a>:</p>

<pre><code>template&lt;template&lt;uint8_t DATA_PIN, EOrder RGB_ORDER&gt; class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER&gt;
static CLEDController &amp;addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
    static CHIPSET&lt;DATA_PIN, RGB_ORDER&gt; c;
    return addLeds(&amp;c, data, nLedsOrOffset, nLedsIfOffset);
}

template&lt;template&lt;uint8_t DATA_PIN, EOrder RGB_ORDER&gt; class CHIPSET, uint8_t DATA_PIN&gt;
static CLEDController &amp;addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
    static CHIPSET&lt;DATA_PIN, RGB&gt; c;
    return addLeds(&amp;c, data, nLedsOrOffset, nLedsIfOffset);
}
</code></pre>

<p>So you have to specify either <code>DATA_PIN</code> or both <code>DATA_PIN</code> and <code>RGB_ORDER</code> in template paramenters, whatever they mean:</p>

<pre><code>LEDS.addLeds&lt;TM1803, SOME_DATA_PIN, SOME_RGB_ORDER&gt;(leds, NUM_LEDS); 
LEDS.addLeds&lt;TM1803, SOME_DATA_PIN&gt;(leds, NUM_LEDS);
</code></pre>
",,34738446,37
27787596,2,27519279,2015-01-05T20:45:31.060,0,,1959776,,2015-01-05T20:45:31.060,,0,,"<p>Assuming you are using the <a href=""http://arduino.cc/en/Tutorial/ReadWrite"" rel=""nofollow"">Arduino SD card library</a>, you could pre-format the lines written to your file and then save it as .CSV instead of .TXT.</p>

<p>From the Arduino SD lib code example:</p>

<pre><code>myFile = SD.open(""measurements.csv"", FILE_WRITE);

  // if the file opened okay, write to it:
  if (myFile) {
    Serial.print(""Writing to measurements.csv..."");

    // create the string to be written to the file
    CSVLine = pressureOne
    CSVLine += "",""
    CSVLine += pressureTwo
    CSVLine += ""\n""

    myFile.println(CSVLine);
    // close the file:
    myFile.close();
    Serial.println(""done."");
  } else {
    // if the file didn't open, print an error:
    Serial.println(""error opening measurements.csv"");
  }
</code></pre>

<p>Note this code is untested as I do not have an Arduino handy...</p>

<p>Best of luck with your project!</p>
",,34738835,490
27556581,2,27551335,2014-12-18T22:08:17.703,0,,20862,,2014-12-18T22:08:17.703,,0,,"<p>Some things about C/C++ I hate. And some I do not.</p>

<pre><code>#define cmpID(var, b1, b2, b3, b4) \
( \
  var[0] == 0x ## b1 &amp;&amp; \
  var[1] == 0x ## b2 &amp;&amp; \
  var[2] == 0x ## b3 &amp;&amp; \
  var[3] == 0x ## b4 \
)

 ...

if (cmpID(readTag, 12, 34, 56, 78))
{
   ...
}
</code></pre>
",,34770031,72
27593224,2,27591694,2014-12-21T20:00:37.570,1,,3134049,,2014-12-21T20:00:37.570,,0,,"<p>Assuming you have a sketch like below and reading temperature from a function like <code>readTemp()</code>, you need to define a global <code>maxTemp</code> variable and check every new temperature value with this variable. </p>

<pre><code>int maxTemp;

void setup() {
   maxTemp = -99; //assigning min temp value to make sure new value will take place of this in first comparison.
}

void loop() {
   int newTemp; //This variable will keep new value.
   newTemp = readTemp(); //Read temperature

   if ( newTemp &gt;= maxTemp ) { //Do the comparison, only if greater-than or equal.
       maxTemp = newTemp; //Assign new temperature as maxTemp.
       Serial.print(newTemp); //Write it to serial.
   }

   delay(250); //wait 250ms before another comparison.
}
</code></pre>
",,34776524,700
27608420,2,27591694,2014-12-22T18:30:37.657,0,,4207013,,2014-12-22T18:30:37.657,,0,,"<p>Use Something like this:</p>

<pre><code>double maxTemp;

void setup() {
maxTemp = -99; // pre set value that won't be reached(lowest amount)    }

void loop() {
   int newTemp; //This variable will keep new value.
   newTemp = readTemp(); //Read temperature

   if ( newTemp &gt;= maxTemp ) { 
       maxTemp = newTemp; 
       Serial.print(newTemp); 
   }

   delay(1000); 
}
</code></pre>
",,34782709,1360
31508827,2,27609972,2015-07-20T04:24:33.283,0,,853795,,2015-07-20T04:24:33.283,,0,,"<p>The arduino shows up as a serial device. You should look at using the <code>open()</code> and <code>close()</code> function. I've done this on Linux but I'm pretty sure this works similarly on Mac. This is an example snippet of code. The first snippet opens and sets up the file descriptor. </p>

<pre><code>int fd;                             // File descriptor
// Open port
fd = open(""/dev/ttyACM0"", O_RDWR | O_NOCTTY | O_NDELAY);
if (fd == -1){
    printf(""Device cannot be opened.\n"");
    exit(-1);                       // If the device is not open, return -1
}
struct termios options;

fcntl(fd, F_SETFL, FNDELAY);                    // Open the device in nonblocking mode

// Set parameters
tcgetattr(fd, &amp;options);                        // Get the current options of the port
bzero(&amp;options, sizeof(options));               // Clear all the options
speed_t         Speed;
switch (baudRate)                               // Set the speed (baudRate)
{
    case 110  :     Speed=B110; break;
    case 300  :     Speed=B300; break;
    case 600  :     Speed=B600; break;
    case 1200 :     Speed=B1200; break;
    case 2400 :     Speed=B2400; break;
    case 4800 :     Speed=B4800; break;
    case 9600 :     Speed=B9600; break;
    case 19200 :    Speed=B19200; break;
    case 38400 :    Speed=B38400; break;
    case 57600 :    Speed=B57600; break;
    case 115200 :   Speed=B115200; break;
    default : exit(-4);
}
cfsetispeed(&amp;options, Speed);                   // Set the baud rate at 115200 bauds
cfsetospeed(&amp;options, Speed);
options.c_cflag |= ( CLOCAL | CREAD |  CS8);    // Configure the device : 8 bits, no parity, no control
options.c_iflag |= ( IGNPAR | IGNBRK );
options.c_cc[VTIME]=0;                          // Timer unused
options.c_cc[VMIN]=0;                           // At least on character before satisfy reading
tcsetattr(fd, TCSANOW, &amp;options);               // Activate the settings
</code></pre>

<p>This just closes it: </p>

<pre><code>close(fd); 
</code></pre>

<p>To read from the actual file descriptor: </p>

<pre><code>ioctl(fd, FIONREAD, &amp;t1);                           
if(t1 &gt; 0) {
    // If the number of bytes read is equal to the number of bytes retrieved
    if(read(fd,pByte, t1) == t1) {  
        for(int i =0; i &lt; t1; i++) {
            if(pByte[i] != '\r'){ // Just makes sure you're not scanning new lines
                // TODO: Do what you want with this character
            }
        }
    }
}
</code></pre>
",,34812263,2283
27652196,2,27650074,2014-12-26T02:04:44.250,0,,498599,,2014-12-26T02:04:44.250,,0,,"<p>so as it turns out, changing the function that retrieves the data to this:</p>

<pre><code>std::string serial::readData(int serialPort)
{
    char buffer[1];
    int bytesRead = 0;
    std::string returnString;

    do
    {
        bytesRead = read(serialPort, buffer, 1);

        if(bytesRead &gt; 0)
        {
            returnString += buffer[0];
        }

    } while (bytesRead == sizeof(buffer));

    return returnString;
}
</code></pre>

<p>appears to fix the problem. Not sure if its ideal, but it works for me.</p>
",,34833550,152
27652012,2,27651012,2014-12-26T01:22:09.420,119,,3248168,,2015-02-18T05:25:09.650,2015-02-18T05:25:09.650,2,,"<p>Due to some performance reasons <code>%f</code> is not included in the Arduino's implementation of <code>sprintf()</code>. A better option would be to use <code>dtostrf()</code> - you convert the floating point value to a C-style string, Method signature looks like:</p>

<pre><code>char *dtostrf(double val, signed char width, unsigned char prec, char *s)
</code></pre>

<p>Use this method to convert it to a C-Style string and then use sprintf, eg:</p>

<pre><code>char str_temp[6];

/* 4 is mininum width, 2 is precision; float value is copied onto str_temp*/
dtostrf(temp, 4, 2, str_temp);
sprintf(temperature,""%s F"", str_temp);
</code></pre>

<p>You can change the minimum width and precision to match the float you are converting.</p>
",,34861462,77
31033123,2,27667299,2015-06-24T17:25:04.193,0,,,user1557496,2015-06-24T17:25:04.193,,1,,"<p>some thing like that for termios is best option</p>

<pre><code>options.c_cflag &amp;= ~CRTSCTS;    
options.c_cflag |= (CLOCAL | CREAD);                   
options.c_iflag |= (IGNPAR | IGNCR);                  
options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          
options.c_oflag &amp;= ~OPOST;

options.c_cflag &amp;= ~CSIZE;            
options.c_cflag |= CS8;              
options.c_cflag &amp;= ~PARENB;         
options.c_iflag &amp;= ~INPCK;         
options.c_iflag &amp;= ~(ICRNL|IGNCR);
options.c_cflag &amp;= ~CSTOPB;      
options.c_iflag |= INPCK;       
options.c_cc[VTIME] = 0.001;  //  1s=10   0.1s=1 *
options.c_cc[VMIN] = 0;
</code></pre>
",,34917638,42
27686640,2,27669372,2014-12-29T09:55:45.977,0,,2190294,,2014-12-29T09:55:45.977,,0,,"<p>Thanks all of you, guys.
Yesterday I found a way how to accomplish this task. Maybe someone will be looking for the answer in the future, so here it is:
I gave up on Dallas library, finally it turned out that it's not first need.</p>

<h1><strong>Programming ATmega8 to work with DS18B20 Temperature Sensor and RF433Mhz Transmitter:</strong></h1>

<pre><code>#include &lt;OneWire.h&gt; 
// RF433
#include &lt;VirtualWire.h&gt;

int DS18S20_Pin = 2; //DS18S20 Signal pin on digital 2

//Temperature chip i/o
OneWire ds(DS18S20_Pin); // on digital pin 2
int led = 13;
void setup(void) {
  // RF433
  vw_set_ptt_inverted(true);
  vw_setup(2000);

  pinMode(led, OUTPUT);
}

void loop(void) {
  float dTmp = getTemp();
  char buf[6];
  dtostrf(dTmp, 6, 3, buf);

  char Msg[10];
  strcpy(Msg, ""TMP:"");

  strncat(Msg, buf, 6);
  digitalWrite(led, HIGH);
  for (int i = 0; i &lt; 10; ++i) // avoid loosing packets in the air
  {
    vw_send((uint8_t *)Msg, strlen(Msg));
    vw_wait_tx();
    delay(300);
  }
  digitalWrite(led, LOW);

  // Sleep 15 s.
  delay(15000);
}


float getTemp(){
  //returns the temperature from one DS18S20 in DEG Celsius

  byte data[12];
  byte addr[8];

  if ( !ds.search(addr)) {
    //no more sensors on chain, reset search
    ds.reset_search();
    return -1000;
  }

  if ( OneWire::crc8( addr, 7) != addr[7]) {
    //   Serial.println(""CRC is not valid!"");
    return -1000;
  }

  if ( addr[0] != 0x10 &amp;&amp; addr[0] != 0x28) {
    //   Serial.print(""Device is not recognized"");
    return -1000;
  }

  ds.reset();
  ds.select(addr);
  ds.write(0x44,1); // start conversion, with parasite power on at the end

  byte present = ds.reset();
  ds.select(addr);  
  ds.write(0xBE); // Read Scratchpad


  for (int i = 0; i &lt; 9; i++) { // we need 9 bytes
    data[i] = ds.read();
  }

  ds.reset_search();

  byte MSB = data[1];
  byte LSB = data[0];

  float tempRead = ((MSB &lt;&lt; 8) | LSB); //using two's compliment
  float TemperatureSum = tempRead / 16;

  return TemperatureSum;

}
</code></pre>

<p>Above code as a binary takes about 6300 bytes, so there is still a little space left for some improvements.</p>

<p>Hope you'll find it usefull :)</p>
",,34945811,6842
27676526,2,27675599,2014-12-28T12:50:33.723,2,,1413395,,2014-12-28T13:02:41.963,2014-12-28T13:02:41.963,3,,"<p>I think your problems appear in these lines of code</p>

<pre><code>if(tcgetattr(arduino,&amp;ttable)&lt;0) {
    // ...
}
else {
    // ...

    if(tcsetattr(arduino,TCSANOW,&amp;ttable)&lt;0) {
        // ...
    }
}
</code></pre>

<p>The <code>arduino</code> variable is of type <code>ofstream</code>, where <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/tcgetattr.html"" rel=""nofollow""><code>tcgetattr()</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/tcsetattr.html"" rel=""nofollow""><code>tcsetattr()</code></a> expect a file descriptor obtained with <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html"" rel=""nofollow""><code>open()</code></a> at this point.</p>

<p><code>ofstream</code> provides an automatic conversion to <code>bool</code> and thus <code>int</code> implicitely. Supposed the</p>

<pre><code>arduino.open(""/dev/tty.usbmodem3a21"");
</code></pre>

<p>went OK, you are effectively passing <code>1</code> to <code>tcgetattr()</code> and <code>tcsetattr()</code>, which is the standard input file descriptor.</p>

<hr>

<p>Solution is not to use a <code>ofstream</code> for <code>arduino</code>, but an ordinary file descriptor</p>

<pre><code>int arduino = open(""/dev/tty.usbmodem3a21"",O_WRONLY);
</code></pre>
",,35015264,581
27706294,2,27706118,2014-12-30T13:22:36.253,0,,10156,,2014-12-30T13:24:02.440,2014-12-30T13:24:02.440,1,,"<p>As @iharob has pointed out, char() in C is not a function for translation.  The easiest way in C to do the ASCII transformation you are looking for is to subtract '0' from the entered value.  This relies on the fact that the numbers are in order in the ASCII table.  However, you will want to ensure that the user's input is actually a digit.  Your code will also only allow repeats from 0-9.</p>

<pre><code>nRepeat = incomingByte - '0';
if (nRepeat &gt;= 0 &amp;&amp; nRepeat &lt;= 9) {
    // Valid digit entered, proceed
    //...
}
</code></pre>
",,35043482,1680
27723291,2,27722306,2014-12-31T15:48:38.367,0,,4112856,,2015-01-06T16:12:21.373,2015-01-06T16:12:21.373,4,,"<p>There is some trouble :/ </p>

<p>First, the default coordinator ADD is 0x0 0x0, so the line where </p>

<pre><code>XBeeAddress64 address = XBeeAddress64 (0x13A200,0x4081B77C );
</code></pre>

<p>should be </p>

<pre><code>XBeeAddress64 address = XBeeAddress64 (0x0,0x0 );
</code></pre>

<p>Then, is the Xbee at 57600 baud too? </p>

<p>To get an ACK, you can use:</p>

<pre><code>  if (xbee.readPacket(1000))
  {     
    if (xbee.getResponse().getApiId() == ZB_TX_STATUS_RESPONSE) 
    {
      xbee.getResponse().getZBTxStatusResponse(txStatus);
      if (txStatus.getDeliveryStatus() == SUCCESS) 
      {
        //It's sent
      } 
    }
</code></pre>

<p>It could be from you payload too. You better use a hexadecimal value or int to be sure of what you send.</p>

<p>EDIT:</p>

<p>I see you don't use the last version of Xctu. Try it and test the direct communication between them to see if you can have direct contact between Coordinator and Routeur/End device.</p>
",,35068592,1683
27730013,2,27729979,2015-01-01T10:35:40.577,1,,2173917,,2015-01-01T10:35:40.577,,6,,"<p>You did not put any success check on the return value of <code>fopen(""/dev/ttyACM0"",""w"");</code>. In case <code>fopen()</code> fails, using <code>file</code> further is undefined behavior, causing segmentation fault. Do something like</p>

<pre><code>file = fopen(""/dev/ttyACM0"",""w"");  //Opening device file
if (file)
{
        //do something with file
}
else
     return 0;
</code></pre>

<p>Also, add a <code>return 0</code> before ending <code>main()</code>.</p>
",,35075178,274
27730258,2,27729979,2015-01-01T11:16:23.987,0,,1983495,,2015-01-01T11:35:38.130,2015-01-01T11:35:38.130,0,,"<p>On failure <code>fopen</code> returns <code>NULL</code>, so you are potentially dereferencing a <code>NULL</code> pointer, the correct way of doing that, is checking the result of <code>fopen</code>. I would however suggest low level IO for this kind of thing something like</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

int main()
{
    char data[] = {'f','b','r'};  //Random data we want to send
    int fd;
    int i;

    fd = open(""/dev/ttyACM0"", O_WRONLY);  //Opening device file
    if (fd == -1)
    {
        perror(""cannot open /dev/ttyACM0"");
        return -1;
    }

    for(i = 0 ; i &lt; 3 ; i++)
    {
        write(fd, &amp;(data[i]), 1);
        write(fd, "","", 1);

        sleep(1);
    }
    close(fd);

    return 0;
}
</code></pre>

<p>on error <code>open</code> returns a special value <code>-1</code> so you should abort writing to it.</p>

<p>I'm pretty sure in your case there will be a <code>permission denied</code> error, since normally the <code>/dev/tty*</code> belong to group <code>dialout</code> and they have group write permission by default, but since probably your user doesn't belong to that group you don't have write access to <code>/dev/ttyACM0</code>.</p>
",,35096267,67
27730524,2,27729979,2015-01-01T11:50:46.200,0,,3629249,,2015-01-01T11:50:46.200,,2,,"<pre><code>// the following code:
//  compiles cleanly
//  performs appropriate error checking
//  has proper return statement

#include &lt;unistd.h&gt; // sleep()
#include &lt;stdio.h&gt;  // fopen(), fclose(), fprintf(), perror()
#include &lt;stdlib.h&gt; // exit() and EXIT_FAILURE

int main()
{
    char data[] = {'f','b','r'};  //Random data we want to send
    FILE *file;
    if( NULL == (file = fopen(""/dev/ttyACM0"",""w"") ) )  //Opening device file
    { // then fopen failed
        perror(""fopen failed for ttyACM0"" );
        exit( EXIT_FAILURE );
    }

    // implied else, fopen successful

    int i = 0;
    for(i = 0 ; i &lt; 3 ; i++)
    {
        if( 0 &gt;= fprintf(file,""%c"",data[i]) ) //Writing to the file
        { // fprintf failed
            perror(""fprintf data failed"" );
            exit( EXIT_FAILURE );
        }

        // implied else, fprintf successful for data

        if( 0 &gt;= fprintf(file,""%c"",',') ) //To separate digits
        { // then, fprintf failed
            perror( ""fprintf for comma failed"");
            exit( EXIT_FAILURE );
        }

        // implied else, fprintf successful for comma

        sleep(1);
    } // end for
    fclose(file);
    return(0);
} // end function: main
</code></pre>
",,35106904,301
27732730,2,27732684,2015-01-01T16:55:40.340,0,,2303475,,2015-01-01T17:04:54.573,2015-01-01T17:04:54.573,2,,"<p>Read this article:</p>

<p><a href=""https://www.udemy.com/blog/c-programs-to-convert-decimal-to-binary/"" rel=""nofollow"">C Program to Convert Decimal to Binary</a></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main()
{
  int d[20];
  int decimalno,i=0;
  printf(""Enter the decimal number you want to conver to binary: \n"");
  scanf(""%d"",&amp;decimalno);
  while(decimalno&gt;0)
  {
       d[i]=decimalno%2;
       i++;
       decimalno=decimalno/2;
  }
  printf(""The binary version of the number you input, %d, is = "",decimalno);
  for(int j=i-1;j&gt;=0;j--)
  {
        printf(""%d"",d[j]);
  }
  //getch();
  return 0;
}
</code></pre>
",,35108622,1111
27732957,2,27732684,2015-01-01T17:25:37.383,0,,1983495,,2015-01-01T19:18:51.883,2015-01-01T19:18:51.883,8,,"<p>I think this is the solution for you, there is no need for an array since you can directly write the bits</p>

<pre><code>int main()
{
    int displayNumber;
    int pins[6] = {3, 0, 1, 2};
    int i;

    wiringPiSetup();

    pinMode(0, OUTPUT);
    pinMode(1, OUTPUT);
    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(6, OUTPUT);

    digitalWrite(0, LOW);
    digitalWrite(1, LOW);
    digitalWrite(2, LOW);
    digitalWrite(3, LOW);
    digitalWrite(6, LOW);

    displayNumber = -1;
    while ((displayNumber &lt; 0) || (displayNumber &gt; 9))
    {
        printf(""Please select a number to display! 0-9\n"");
        scanf(""%i"", &amp;displayNumber);
    }

    digitalWrite(6, LOW);
    for (i = 0 ; i &lt; 4 ; i++)
        digitalWrite(pins[i], displayNumber &amp; (1 &lt;&lt; i) ? HIGH : LOW);
    digitalWrite(6, HIGH);

    return 0;
}
</code></pre>
",,35150262,3458
27733182,2,27732684,2015-01-01T17:56:53.327,1,,2410359,,2015-01-01T17:56:53.327,,0,,"<p>Replace switch statements with</p>

<pre><code>digitalWrite(6, LOW);
digitalWrite(3, displayNumber &amp; 1 ? HIGH : LOW);
digitalWrite(0, displayNumber &amp; 2 ? HIGH : LOW);
digitalWrite(1, displayNumber &amp; 4 ? HIGH : LOW);
digitalWrite(2, displayNumber &amp; 8 ? HIGH : LOW);
digitalWrite(6, HIGH);
</code></pre>
",,35153377,763
27748700,2,27739409,2015-01-02T21:20:46.390,4,,469006,,2015-01-02T21:20:46.390,,1,,"<p>The documentation may not say it, but the implementation shows that both the source and destination must be 32-bit aligned:</p>

<pre><code>int flashWriteBlock( void *dst, const void *src, int cb )
{
    uint32_t *d = dst;
    const uint32_t *s = src;

    /* The rest of the function snipped*/
}
</code></pre>

<p>The failure is due to the <code>settings</code> variable being 16-bit aligned. It will have to be forced to 32-bit alignment. How this is done is compiler dependent. The following example works for gcc:</p>

<pre><code>struct settings_t
{   
  uint16_t n;
  uint8_t b;
  bool e;
} __attribute__ ((aligned (4))) settings;
</code></pre>
",,35187006,353
27760492,2,27760302,2015-01-03T23:02:45.327,1,,168986,,2015-01-03T23:02:45.327,,2,,"<pre><code>const char* binary = ""000101011110011110101110"" ;
char hex[9] = """" ;

uint32_t integer = 0 ;

for( int i = 0; binary[i+1] != '\0'; i++ )
{
    if( binary[i] == '1' )
    {
        integer |= 1 ;
    }
    integer &lt;&lt;= 1 ;
}

sprintf( hex, ""0x%06x"", integer ) ;
</code></pre>
",,35227449,12230
27760504,2,27760302,2015-01-03T23:04:03.840,1,,225074,,2015-01-03T23:04:03.840,,4,,"<p>Let's try some simple bit shifting.  </p>

<pre><code>std::string sample_str = ""000101011110011110101110"";
uint32_t result = 0;
for (unsigned int i = 0; i &lt; sample_str.length(); ++i)
{
  result = result &lt;&lt; 1;
  result = result | (sample_str[i] &amp; 1);
}
</code></pre>

<p>There may be faster methods, but you would have to search the web for ""bit twiddling string"".</p>

<p><strong>Background</strong><br>
This is based on the assumption that the character representation of zero has the least significant bit set to zero.  Likewise the character representation of one has the least significant bit set to one.  </p>

<p>The algorithm shifts the result left by one to make room for a new bit value.
Taking the character value and ANDing with 1 results in a value of zero for '0' and one for '1'. This result is ORed into the <code>result</code> value, to produce the correct value.  </p>

<p>Try single stepping with a debugger to see how it works.</p>
",,35249727,1132
27786141,2,27785137,2015-01-05T19:05:46.503,0,,1899801,,2015-01-05T19:05:46.503,,0,,"<p>It is not clear as to your goal. However, I guess you want Python to send a byte to the Arduino, perhaps over a serial port or such. Python does not have an equivalent type. Where the ""write"" method will send just the byte ,for the effect you are looking for.</p>

<pre><code>import serial
arduino = serial.Serial(port,speed)
time.sleep(2) # may need 5s
byte = chr(0x31)
arduino.write(byte) # byte0&lt;=i&lt;=255
time.sleep(2)
arduino.close()
</code></pre>

<p>Note that you need to have brief pause after opening the port and before the byte is sent, as the Arduino is reseting.</p>

<p>You can also send sections of arrays or strings...</p>

<pre><code>mystring = ""1234""
ser.write(mystring[0:1])
</code></pre>
",,35262377,304
27884168,2,27883451,2015-01-11T05:09:57.997,0,,4441359,,2015-01-11T05:16:15.957,2015-01-11T05:16:15.957,0,,"<p>Using append instead of write somehow fixed the problem:</p>

<pre><code>FILE * writeTemp = fopen(""temp.txt"", ""a"");
</code></pre>

<p>I also had to remove the second request:</p>

<pre><code>    /*
// Humidity every 3 seconds
  if(millis()-timeHum&gt;=3000){
    serialPuts (fd, ""06\n"");
    timeHum=millis();
  }

  // read signal
  if(serialDataAvail (fd)){
    char humChar = serialGetchar (fd);
    printf(""%c"", humChar);
    fflush(stdout);
    }
*/
</code></pre>

<p>because it was interfering with the data for some reason, even with different char variable.</p>

<p>Thank you for the answers.</p>
",,35264733,282
27888165,2,27888152,2015-01-11T14:29:50.040,6,,1983495,,2015-01-11T14:40:31.970,2015-01-11T14:40:31.970,2,,"<p>That's not possible, create a fixed size array, and pass it to the function as a pointer, and initialize it in the function</p>

<pre><code>char results[4];

getData(results); /* the getData function should take a 'char *' paramenter */

client.println(""1: %i"", results[0]);
client.println(""2: %i"", results[1]);
client.println(""3: %i"", results[2]);
client.println(""4: %i"", results[3]);
</code></pre>

<p>and of course if the array is bigger just <code>char results[A_BIGGER_SIZE];</code></p>

<p>Suppose that get data just puts a string <code>""ABC""</code> in the <code>result</code> array it would look like</p>

<pre><code>void getData(char *dest)
{
    dest[0] = 'A';
    dest[1] = 'B';
    dest[2] = 'C';
    dest[3] = '\0';
}
</code></pre>
",,35324295,90
27903669,2,27900997,2015-01-12T13:58:45.660,0,,4140282,,2015-01-12T13:58:45.660,,2,,"<p>what is unit of 700 and 2000?I guess usec.You have not exaplained much in your question but i identified that you need pulses of 25msec duration in which 700 usec on time may be 0 degree and 2000 may be for 180 degree now pulse input of each servo may be attached with any GPIO of AVR.and this GPIOs provide PWM signal to Servo.so i guess you can even control this all motors with only one timer.With this kind of code:</p>

<p>suppose you have a timer that genrate inturrupt at every 50 usec.
now if you want 700 usec for motor1,800 usec for motor 2,900 usec for motor 3 &amp; 1000 usec for motor 4 then just do this:</p>

<pre><code>#define CYCLE_PERIOD 500 // for 25 msec = 50 usec * 500

unsigned short motor1=14;  // 700usec = 50x14
unsigned short motor2=16;  // 800usec
unsigned short motor3=18;  // 900usec
unsigned short motor4=20;  // 1000usec

unsigned char motor1_high_flag=1;
unsigned char motor2_high_flag=1;
unsigned char motor3_high_flag=1;
unsigned char motor4_high_flag=1;

PA.0 = 1; // IO for motor1 
PA.1 = 1; // IO for motor2
PA.2 = 1; // IO for motor3
PA.3 = 1; // IO for motor4

void timer_inturrupt_at_50usec()
{
   motor1--;motor2--;motor3--;motor4--;
   if(!motor1)
   {
      if(motor1_high_flag)
      {
          motor1_high_flag = 0;
          PA.0 = 0;
          motor1 = CYCLE_PERIOD - motor1;
      }
      if(!motor1_high_flag)
      {
          motor1_high_flag = 1;
          PA.0 = 1;
          motor1 = 14;    // this one is dummy;if you want to change duty time update this in main
      }
   }

   if(!motor2)
   {
      if(motor2_high_flag)
      {
          motor2_high_flag = 0;
          PA.1 = 0;
          motor2 = CYCLE_PERIOD - motor2;
      }
      if(!motor2_high_flag)
      {
          motor2_high_flag = 1;
          PA.1 = 1;
          motor2 = 16;
      }
   }


   if(!motor3)
   {
      if(motor3_high_flag)
      {
          motor3_high_flag = 0;
          PA.2 = 0;
          motor3 = CYCLE_PERIOD - motor3;
      }
      if(!motor3_high_flag)
      {
          motor3_high_flag = 1;
          PA.2 = 1;
          motor3 = 18;
      }
   }

   if(!motor4)
   {
      if(motor4_high_flag)
      {
          motor4_high_flag = 0;
          PA.3 = 0;
          motor4 = CYCLE_PERIOD - motor4;
      }
      if(!motor4_high_flag)
      {
          motor4_high_flag = 1;
          PA.3 = 1;
          motor4 = 19;
      }
   }
}
</code></pre>

<p>&amp; tell me what is ESC?  </p>
",,35383873,1335
27909780,2,27909666,2015-01-12T19:58:53.003,10,,505088,,2015-01-12T20:04:06.183,2015-01-12T20:04:06.183,7,,"<p>Windows error codes are documented here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382.aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382.aspx</a></p>

<p>Your error code is <code>ERROR_FILE_NOT_FOUND</code>. Which means that <code>COM15</code> cannot be found. According to <a href=""https://support.microsoft.com/kb/115831/en-gb?wa=wsignin1.0"" rel=""noreferrer"">this article</a> you need to use the name: <code>""\\\\.\\COM15""</code>.</p>

<blockquote>
  <p><code>CreateFile()</code> can be used to get a handle to a serial port. The
  ""Win32 Programmer's Reference"" entry for ""CreateFile()"" mentions that
  the share mode must be 0, the create parameter must be OPEN_EXISTING,
  and the template must be NULL. </p>
  
  <p>CreateFile() is successful when you use ""COM1"" through ""COM9"" for the
  name of the file; however, the message <code>INVALID_HANDLE_VALUE</code> is
  returned if you use ""COM10"" or greater. </p>
  
  <p>If the name of the port is <code>\\.\COM10</code>, the correct way to specify the
  serial port in a call to CreateFile() is as follows:</p>

<pre><code>CreateFile(
  ""\\\\.\\COM10"",     // address of name of the communications device
  fdwAccess,          // access (read-write) mode
  0,                  // share mode
  NULL,               // address of security descriptor
  OPEN_EXISTING,      // how to create
  0,                  // file attributes
  NULL                // handle of file with attributes to copy
);
</code></pre>
  
  <p>NOTES: This syntax also works for ports COM1 through COM9. Certain boards will let you choose the port names yourself. This
  syntax works for those names as well.</p>
</blockquote>

<p>Or alternatively from the documentation to <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx"" rel=""noreferrer""><code>CreateFile</code></a> itself:</p>

<blockquote>
  <p>The CreateFile function can create a handle to a communications
  resource, such as the serial port COM1. For communications resources,
  the dwCreationDisposition parameter must be OPEN_EXISTING, the
  dwShareMode parameter must be zero (exclusive access), and the
  hTemplateFile parameter must be NULL. Read, write, or read/write
  access can be specified, and the handle can be opened for overlapped
  I/O.</p>
  
  <p>To specify a COM port number greater than 9, use the following syntax:
  <code>\\.\COM10</code>. This syntax works for all port numbers and hardware that
  allows COM port numbers to be specified.</p>
</blockquote>
",,35399223,42
27917950,2,27917832,2015-01-13T08:42:49.720,1,,3640699,,2015-01-13T09:16:48.493,2015-01-13T09:16:48.493,4,,"<p>You are not mentioning the data type of that arguments. You have to mention the arguments.
Then you have to declare the function prototype.</p>

<pre><code> boolean arrayIncludeElement(int array[], int element);
 boolean arrayIncludeElement(int array[], int element) {
 for (int i = 0; i &lt; max; i++) {
      if (array[i] == element) {
          return true;
      }
    }
  return false;
 }
</code></pre>

<p>Edit: As like Dmitri said, pass the no of elements in the array as a function argument.
Don't use the sizeof. </p>

<p>Then declartion of function, must be placed before where it is used. So in this place the function prototype before the function <code>void loop()</code>.</p>
",,35414530,2380
27918518,2,27917832,2015-01-13T09:15:09.657,0,,4402721,,2015-01-13T09:15:09.657,2017-05-23T11:50:56.850,0,,"<p>It seems that this question is getting closer to <a href=""https://stackoverflow.com/questions/37538/how-do-i-determine-the-size-of-my-array-in-c"">How do I determine the size of my array in C?</a></p>

<p>BUT, in the general case, you do have to provide the length of the array or use some guard element (like null-terminated strings). Somewhere up the call chain you must know the size of the array, don't you?</p>

<p>A small example to show why sizeof() may not be correct:</p>

<pre><code>int size_test(char b[])
{
    char a[10];
    char foo[] = {'a', 'b', 'c', 'd', 'e'};
    char *bar = malloc(20);
    printf(""sizeof a = %ld, sizeof b = %ld, sizeof foo = %ld, sizeof bar = %ld\n"", sizeof(a), sizeof(b), sizeof(foo), sizeof(bar));
}
int main()
{
    char b[12];
    size_test(b);
}
</code></pre>

<p>which, on my (64 bit) machine, prints </p>

<p><code>sizeof a = 10, sizeof b = 8, sizeof foo = 5, sizeof bar = 8</code></p>
",,35451657,775
28322814,2,27919876,2015-02-04T13:37:37.443,0,,4350672,,2015-02-04T13:37:37.443,,0,,"<blockquote>
  <p>I was able to receive the message. But I want my GSM to only receive
  from a specific number.</p>
</blockquote>

<p>Do you wish to stop the GSM from receiving SMS from unknown numbers, or do you want to output to serial when the conditions are met?</p>

<p>If it's the former, you may want to talk to your network provider, and consider the architectures pitfalls in this approach.</p>

<blockquote>
  <p>It immediately deletes the message once it does not satisfies the
  condition</p>
</blockquote>

<p>On that same if condition where you discard the sms if not sent from numXXX, 
add an </p>

<pre><code>else{
SIM900.print(""AT+CNMI=2,2,0,0,0\r"");
Serial.println(""AUTOMATIC asd"");
SIM900.println(""AT+CMGD=1,4"");
// or write high to led pin if that's what you want.......
}
</code></pre>

<p>Of course, it would help if we could see that sketch...</p>
",,35461155,1426
27999948,2,27998059,2015-01-17T13:29:48.807,5,,3156750,,2015-09-07T20:34:57.757,2015-09-07T20:34:57.757,6,,"<p>Most of what you've referenced is about synchronising memory accesses between multiple CPUs, or pre-emptively scheduled threads on the same CPU, which seems entirely inappropriate given the stated situation. ""Atomicity"" in that sense refers to guaranteeing that when one observer is <em>updating memory</em>, any observer <em>reading memory</em> sees either the initial state, or the updated state, but never something part-way in between.</p>

<p>""Atomicity"" <em>with respect to interrupts</em> follows the same principle - i.e. ensuring that if an interrupt occurs, a sequence of code has either not run at all, or run completely - but is a conceptually different thing<sup>1</sup>. There are only two things guaranteed to be atomic w.r.t. interrupts: a single instruction<sup>2</sup>, or a sequence of instructions executed with interrupts disabled.</p>

<p>The ""right"" way to achieve that is indeed via the <code>CPSID</code>/<code>CPSIE</code> instructions, which are wrapped in the <a href=""http://www.keil.com/support/man/docs/armcc/armcc_pge1397111458225.htm"" rel=""nofollow""><code>__disable_irq()</code></a>/<a href=""http://www.keil.com/support/man/docs/armcc/armcc_chr1359124996163.htm"" rel=""nofollow""><code>__enable_irq()</code></a> intrinsics. Note that there are two ""stages"" of interrupt handling in the system: the M3 core itself only has a single IRQ signal - it's the external NVIC's job to do all the routing/multiplexing/prioritisation of the system IRQs into this one line. When the CPU wants to enter a critical section, all it needs to do is mask its own IRQ input with <code>CPSID</code>, do what it needs, then unmask with <code>CPSIE</code>, at which point any pending IRQ from the NVIC will be taken immediately.</p>

<p>For the case of nested/re-entrant critical sections, the intrinsics provide a handy <code>int __disable_irq(void)</code> form which returns the previous state, so you can unmask conditionally on that.</p>

<p>For other compilers which don't offer such intrinsics, it's straightforward enough to roll your own, e.g.:</p>

<pre><code>static inline int disable_irq(void) {
    int primask;
    asm volatile(""mrs %0, PRIMASK\n""
                 ""cpsid i\n"" : ""=r""(primask));
    return primask &amp; 1;
}

static inline void enable_irq(int primask) {
    if (primask)
        asm volatile(""cpsie i\n"");
}
</code></pre>

<hr>

<p><sub>[1] One confusing overlap is the latter sense is often used to achieve the former in single-CPU multitasking - if interrupts are off, no other thread can get scheduled until you've finished, thus will never see partially-updated memory.</sub></p>

<p><sub>[2] With the possible exception of load/store-multiple instructions - in the low-latency interrupt configuration, these <em>can</em> be interrupted, and either restarted or continued upon return.</sub></p>
",,35472216,112
28005093,2,28005028,2015-01-17T22:35:40.377,2,,1983495,,2015-01-17T22:44:11.660,2015-01-17T22:44:11.660,2,,"<p>You need to use dynamic allocation, or pass the array to the function as a parameter which is a better solution in your case </p>

<pre><code>void receiveMessage(AndroidAccessory acc, boolean accstates, byte *theMessage){
    if (theMessage == NULL)
        return;
    if(accstates){
        byte rcvmsg[255];
        int len = acc.read(rcvmsg, sizeof(rcvmsg), 1);
        if (len &gt; 0) {
            if (rcvmsg[0] == COMMAND_TEXT) {
                if (rcvmsg[1] == TARGET_DEFAULT){
                byte textLength = rcvmsg[2];
                int textEndIndex = 3 + textLength;
                int i=0;
                    for(int x = 3; x &lt; textEndIndex; x++) {
                        theMessage[i]=rcvmsg[x];
                        i++;
                        delay(250);
                    }
                return;
                }
            }
        }
    }       
}
</code></pre>

<p>with this, you will call the function passing the array to it, for example</p>

<pre><code>byte theMessage[255];

receiveMessage(acc, accstates, theMessage);
/* here the message already contains the data you read in the function */
</code></pre>

<p>But you can't return a local variable, because the data is only valid in the scope where the variable is valid, in fact it's invalid right outside the <code>if (rcvmsg[0] == COMMAND_TEXT)</code> block, because you defined it local to that block.</p>

<p><strong>Note</strong>: please read <strong>Wimmel</strong>'s comment, or you could set the last byte to <code>'\0'</code> if it's just text, and then use the array as a string.</p>
",,35482878,330
28012378,2,28012183,2015-01-18T17:03:46.237,0,,1983495,,2015-01-18T17:03:46.237,,4,,"<p>I don't know how <code>println()</code> works, but is suppose it takes a <code>nul</code> terminated sequence of bytes, so you need to <code>nul</code> terminate the after this declaration</p>

<pre><code>int inp[5]
</code></pre>

<p>add this</p>

<pre><code>inp[4] = '\0';
</code></pre>

<p>or you can add it here</p>

<pre><code>inputBuf[0] = cmOne;
inputBuf[1] = cmTwo;
inputBuf[2] = cmThree;
inputBuf[3] = cmFour;
inputBuf[4] = 0; // &lt;--- here
</code></pre>
",,35486045,19162
29954198,2,28020971,2015-04-29T20:46:46.953,1,,122762,,2015-04-29T20:46:46.953,,0,,"<p>The official mavlink project includes encoding/decoding code in C (and Python): <a href=""https://github.com/mavlink/mavlink"" rel=""nofollow"">https://github.com/mavlink/mavlink</a></p>

<p>There's an example of using the mavlink C code at <a href=""http://qgroundcontrol.org/dev/mavlink_linux_integration_tutorial"" rel=""nofollow"">http://qgroundcontrol.org/dev/mavlink_linux_integration_tutorial</a>:</p>

<pre><code>memset(buf, 0, BUFFER_LENGTH);
recsize = recvfrom(sock,
                   (void *)buf, BUFFER_LENGTH,
                   0,
                   (struct sockaddr *)&amp;gcAddr, &amp;fromlen);
if (recsize &gt; 0) {
    // Something received - print out all bytes and parse packet
    mavlink_message_t msg;
    mavlink_status_t status;

    printf(""Bytes Received: %d\nDatagram: "", (int)recsize);
    for (i = 0; i &lt; recsize; ++i)
      {
        temp = buf[i];
        printf(""%02x "", (unsigned char)temp);
        if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &amp;msg, &amp;status))
          {
            // Packet received
            printf(""\nReceived packet: SYS: %d, COMP: %d, LEN: %d, MSG ID: %d\n"",
                   msg.sysid, msg.compid, msg.len, msg.msgid);
          }
      }
}
</code></pre>
",,35530025,49
28044936,2,28044274,2015-01-20T12:03:28.860,0,,3368201,,2015-01-20T12:03:28.860,,3,,"<p>It depends on what you are trying to achieve. For a shorter code, I'll just call your functions <code>funcA</code> and <code>funcB</code> and the parameters <code>par1</code> and <code>par2</code>.</p>

<p>You can do either</p>

<pre><code>void funcA(int par1, int par2)
{ ... use par1 and par2 ... }

void funcB(int par1, int par2)
{
    ...
    funcA(par1, par2);
    ...
}
</code></pre>

<p>or</p>

<pre><code>int global_par1;
int global_par2;

void funcA(int par1, int par2)
{ ... use par1 and par2 ... }

void funcB()
{
    ...
    funcA(global_par1, global_par2);
    ...
}
</code></pre>

<p>In the first case you only use local variables, while in the second you use global ones.</p>

<p>The difference is that in the global case (please call them differently in <code>funcA</code> and <code>funcB</code>, since there could be readability issues) the variables are unique for the whole program (i.e. if you modify them in the <code>main</code> you will modify them even in the functions), while in the local case you are just working on a local copy of them.</p>

<p>In my opinion, since these variables identify the position (which is unique) I'd go with a fully global solution, i.e.</p>

<pre><code>int global_par1;
int global_par2;

void funcA()
{ .. use global_par1 and global_par2.. }

void funcB()
{
    ...
    funcA();
    ...
}
</code></pre>
",,35533665,1336
28055278,2,28055159,2015-01-20T21:15:32.977,0,,867206,,2015-01-20T21:15:32.977,,0,,"<p>You want to pass a single-dimension array as an argument in a function, you would have to declare function formal parameter.</p>

<p>/* pass pointer to the array as an argument */</p>

<pre><code>printArray( question) ;

void printArray(char question[])
{
//process
}
</code></pre>
",,35601089,474
28056861,2,28055159,2015-01-20T23:06:57.837,0,,134554,,2015-01-20T23:06:57.837,,5,,"<p>It's not quite clear what you're asking for; do you want one function to print both the question and all four answers in one operation?  </p>

<p>If so, you could write something like the following:</p>

<pre><code>char question[] = ""Question here"";
char answ_A[] = ""answer1"";
char answ_B[] = ""answer2"";
char answ_C[] = ""answer3"";
char answ_D[] = ""answer4"";

/**
 * Set up an array of pointers to char, where each
 * element will point to one of the above arrays
 */
const char *q_and_a[] = { question, answ_A, answ_B, answ_C, answ_D, NULL };

printQandA( q_and_a );
</code></pre>

<p>then your <code>printQandA</code> function would look something like this:</p>

<pre><code>/**
 * Print the question and answers.  Use the pointer p to 
 * ""walk"" through the question and answer array.
 */
void printQandA( const char **question )
{
  const char **p = question; 

  /**
   * First element of the array is the question; print it
   * by itself
   */
  printf( ""%s\n"", *p++ );

  /**
   * Print the answers until we see the NULL element
   * in the array.
   */
   while ( *p )
     printf( ""\t-%s\n"", *p++ );
}
</code></pre>
",,35617216,402
28094816,2,28056597,2015-01-22T17:17:31.393,0,,529630,,2015-01-22T19:11:16.963,2015-01-22T19:11:16.963,3,,"<p><a href=""https://docs.python.org/3/library/ctypes.html"" rel=""nofollow""><code>ctypes</code></a> is better suited to what you are trying to do.</p>

<p>For instance: (test.py)</p>

<pre><code>from ctypes import create_string_buffer, c_char_p, c_int, CDLL

libtest = CDLL(""./libtest.so"")

_putAll = libtest.putAll
_putAll.restype = None
_putAll.argtypes = [c_int, c_char_p]

def putAll(values):
    """"""Expects a bytes object, bytearray, or a list of ints.""""""
    char_buffer = create_string_buffer(bytes(values))
    _putAll(len(char_buffer), char_buffer)

getAll = libtest.getAll
getAll.restype = c_char_p
getAll.argtypes = None
</code></pre>

<p>Usage:</p>

<pre><code>import test
test.putAll(b""hello world"")
assert test.getAll() == b""hello world""
test.putAll(bytearray(b""another string""))
test.putAll([1, 2, 3, 255])
</code></pre>

<p>The above is for python 3 . If you're running python 2 then you can substitute <code>bytes</code> for <code>str</code>, but the function is less flexible. In addition, be aware that <code>create_string_buffer</code> creates a C-string (adds an additional NUL character on the end of the string).</p>

<p>To compile the shared library you need to do the following:</p>

<pre><code>gcc -fPIC -g -c -Wall test.c
gcc -shared -Wl,-soname,libtest.so.1 -o libtest.so test.o
</code></pre>
",,35689780,213
38216418,2,28056597,2016-07-06T04:39:40.173,1,,2872810,,2016-07-06T04:39:40.173,,0,,"<p>You can use Python's bytearray with Cython and I think is cleaner and easier than ctypes:</p>

<p>test.py</p>

<pre><code>larr = bytearray([4, 1, 2])
pyPutAll(3, larr)
</code></pre>

<p>This works with your original putAll C function:</p>

<p>test.c</p>

<pre><code>...
void putAll(int n, char c[]) {
    memcpy(a, c, n);
}
...
</code></pre>

<p>pytest.pyx</p>

<pre><code># Pass python bytearray to C
def pyPutAll(int n, char[:] pyc):
    defns.putAll(n, &amp;pyc[0])
</code></pre>

<p>If you need to pass a list, you would have to convert it to a vector inside the pyx function, and pass a reference to that instead:</p>

<p>pytest.pyx</p>

<pre><code>def pyPutAllList(int n, list pyc):
    cdef vector[char] vec = pyc
    defns.putAll(n, &amp;vec[0])
</code></pre>
",,35704878,475
28058972,2,28058806,2015-01-21T03:07:27.730,0,,253056,,2015-01-21T03:28:10.430,2015-01-21T03:28:10.430,0,,"<p>Your code isn't doing anything remotely useful. It's certainly not measuring input frequency - in fact it does not even care what the value of the input signal is and will behave the same regardless of whatever is going on externally. All it is doing is measuring the time between calls to <code>loop()</code> and converting this time to a frequency in cycles per minute. Since you have a 500 ms delay in <code>loop()</code> you get a frequency of 2 Hz = 120 cycles / minute, which is consistent with the numbers you are seeing.</p>

<p>To be brutally honest I doubt your circuit will ever be able to measure ECG signals even if you do get the code right - it's just too crude - but so that you can at least measure <em>something</em> frequency-related you might want to try and implement the following code in <code>loop()</code>:</p>

<pre><code>input = digitalRead(signal);
while (input == digitalRead(signal))
    ; // wait for input signal to change state (sync)
start = millis();
while (input != digitalRead(signal))
    ; // wait for input signal to change state (first part of period)
while (input == digitalRead(signal))
    ; // wait for input signal to change state (one complete period)
end = millis();
period = end - start;
freq = 60000 / period;
</code></pre>

<p>Note that this will hang if your input signal is not changing state regularly.</p>

<p>Note also that this will only give a useful frequency measurement if you have a completely clean input signal, i.e. a signal that only changes state at the frequency of interest, with no noise transitions. In practice you may well just end up measuring the frequency of mains hum or other background noise.</p>
",,35723025,58
28090765,2,28088361,2015-01-22T14:06:50.450,1,,4213662,,2015-01-22T14:17:06.290,2015-01-22T14:17:06.290,0,,"<p>Are you perhaps confusing 'file' and 'translation unit'.</p>

<p>Refer here <a href=""http://port70.net/~nsz/c/c99/n1256.html#6.2.2"" rel=""nofollow"">http://port70.net/~nsz/c/c99/n1256.html#6.2.2</a></p>

<p>You can use identifiers for static objects declared in other <strong>files</strong> so long as they are part of the same <strong>translation unit</strong> (and appropriately declared at the point of use...).
A translation unit is a (normally notional) file made up of a source file (.c or .cpp probably) with all it's <code>#include</code> directives 'expanded'.</p>

<p>You can 'use' data declared static in another translation unit. But not an identifier. How?</p>

<p><strong>daft.h</strong>:</p>

<pre><code>static int x=0;

int nextX(void);
</code></pre>

<p><strong>daft.c</strong></p>

<pre><code>#include ""daft.h""

int nextX(void){
    return ++x;
}
</code></pre>

<p><strong>my.c</strong></p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include ""daft.h""

int main(void){

    printf(""%d\n"", nextX());//outputs 1.
    printf(""%d\n"", x);//prints 0.

    return EXIT_SUCCESS;
}
</code></pre>

<p>Where we assume that <code>daft.c</code> and <code>my.c</code> are source files. Both their translation units have an identifier <code>x</code> for an internally linked <code>int</code>.
The two identifiers and the storage for the objects are unrelated!
The call to <code>nextX()</code> accesses the storage for the identifier <code>x</code> internally linked in <code>daft.c</code>. The direct access <code>x</code> accesses the identifier internally linked in <code>my.c</code>.</p>

<p>Unless identifiers are declared <code>const</code> having <code>static</code> linkage identifiers in header files usually leads to trouble.</p>
",,35727864,1036
28137230,2,28128824,2015-01-25T14:01:14.420,1,,1985423,,2015-01-25T14:11:43.563,2017-05-23T11:43:30.883,1,,"<p>If you use the example code (and forget about using python3) given <a href=""https://docs.python.org/2/extending/embedding.html"" rel=""nofollow noreferrer"">in the python docs</a> and save it in a file like pythonInC.c, you have to do <a href=""https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory"">two things (vartecs answer)</a>. First the example code:</p>

<pre><code>#include &lt;Python.h&gt;

int
main(int argc, char *argv[])
{
  Py_SetProgramName(argv[0]);  /* optional but recommended */
  Py_Initialize();
  PyRun_SimpleString(""from time import time,ctime\n""
                     ""print 'Today is',ctime(time())\n"");
  Py_Finalize();
  return 0;
}
</code></pre>

<p>2nd, the configuration steps (see below for dev3.x packages):</p>

<pre><code>sudo apt-get install python-dev
</code></pre>

<p>and add (you have to use python3.x whenever python2.7 is written here (see below))</p>

<pre><code>-I/usr/include/python2.7 -lpython2.7
</code></pre>

<p>to your gcc command. When I did (again ""python3.x"" and s. below)</p>

<pre><code>user ~/stack $ gcc -I/usr/include/python2.7 -lpython2.7 pythonInC.c
user ~/stack $ ./a.out 
Today is Sun Jan 25 13:03:37 2015
</code></pre>

<p>on my raspberry running raspbian, I got the expected output as you can see.</p>

<p>However, coming back to python3. I have 3.2 here an did the steps analogue to the given above with 2.7 changed to 3.2. This gave me an error:</p>

<pre><code>user ~/programming/stack $ gcc -Wall -I/usr/include/python3.2 -lpython3.2 pythonInC.c 
pythonInC.c: In function 'main':
pythonInC.c:6:3: warning: passing argument 1 of 'Py_SetProgramName' from incompatible pointer type [enabled by default]
/usr/include/python3.2/pythonrun.h:25:18: note: expected 'wchar_t *' but argument is of type 'char *'
/usr/bin/ld: cannot find -lpython3.2
collect2: ld returned 1 exit status
</code></pre>

<p>There is at least one discussion <a href=""https://stackoverflow.com/questions/18245140/how-do-you-use-the-python3-c-api-for-a-command-line-driven-app"">here</a>, however I did not solve that yet to give here as an easy answer. But <a href=""https://stackoverflow.com/questions/18245140/how-do-you-use-the-python3-c-api-for-a-command-line-driven-app"">there</a> might be solutions for you.</p>
",,35740038,789
28177746,2,28174176,2015-01-27T18:45:12.240,0,,773102,,2015-01-27T18:45:12.240,,0,,"<p>Found the answer to my problem. If I modify my code like this it's working properly in both cases: </p>

<pre><code>typedef struct
{
    const __FlashStringHelper* desc;
    int a;    
} SensorStringInformation;

void setup()
{
       const SensorStringInformation res = 
       {
          F(""Depth: ""),
          2
       };
}

void loop()
{

}
</code></pre>
",,35740112,84
28182651,2,28182339,2015-01-28T00:30:43.210,0,,549312,,2015-01-28T00:30:43.210,,2,,"<p>void* will solve your cast problem
and sizeof a pointer is never going to be > 33
so try this instead:</p>

<pre><code>void LCD(char RGBXXX, void *str, int is_data) {  
  RGB(RGBXXX);   
  if (is_data != 0) {   
    char data[33];   
    memcpy(data,(uint8_t*)str,33);  
    writeLCD(data);   
 }   
 else {   
   BMP((uint16_t *)str);
 } 
</code></pre>

<p>}</p>
",,35755329,104
28197858,2,28197733,2015-01-28T16:52:02.723,3,,204847,,2015-01-28T16:52:02.723,,0,,"<p>You've got an <code>else</code> with no attached <code>if</code>.</p>

<p>Presumably, the <code>println</code> are supposed to be inside the following block, rather than being the entire body of the <code>if</code> statement:</p>

<pre><code>if(ID.indexOf(msg)&gt;=0)
{
  Serial.println(""Access granted."");  // &lt;&lt;&lt; inside if body
  digitalWrite(10, HIGH);
  delay(2000);
  digitalWrite(10, LOW);
}
else
{
  Serial.println(""Access denied."");   // &lt;&lt;&lt; inside else body
  digitalWrite(9, HIGH);
  delay(2000);
  digitalWrite(9, LOW);
}
</code></pre>
",,35784700,20004
28214670,2,28211986,2015-01-29T12:23:36.290,0,,2205264,,2015-01-29T12:23:36.290,,0,,"<p>To avoid SIOF, you can do something like that:</p>

<p>I created a class called Fred here is the .h and .cpp files :</p>

<p>Fred.h</p>

<pre><code>#ifndef Fred_h
#define Fred_h
#include ""Arduino.h""
class Fred
  {
   public:
     Fred();
     void printMessage();
  };
#endif
</code></pre>

<p>Fred.cpp</p>

<pre><code>#include ""Fred.h""
Fred::Fred()
{
    // nothing to do here
}

void Fred::printMessage()
{
  Serial.println(""Hello Arduino!"");
}
</code></pre>

<p>and in the sketch:</p>

<pre><code>#include &lt;Fred.h&gt;
Fred a;
void setup()
{
    Serial.begin(9600);
}
void loop()
{
    a.printMessage();
}
</code></pre>

<p>Hope this helps.</p>
",,35793246,542
28223943,2,28219715,2015-01-29T20:26:15.260,0,,693357,,2015-01-29T21:31:28.430,2015-01-29T21:31:28.430,7,,"<p>Based on PDizzle745's suggestions, here is what I came up with:</p>

<pre><code>class RelayInfo
{
  public:
    RelayInfo(int pin, const char* message);
    ~RelayInfo();
    int Pin;
    char* Message;
};

RelayInfo::RelayInfo( int pin, const char* message )
{
  Pin = pin;

  //Allocate enough memory for copying the input string.
  Message = (char*) malloc( strlen(message) * sizeof(char) + 1 );

  //Copy the input string to the class's field.
  strcpy( Message, message );
}

RelayInfo::~RelayInfo(void)
{
  free( Message );
}

void setup() {
  pinMode(13, OUTPUT);

  digitalWrite( 13, HIGH );
  delay(1000);
}

void loop() {

  RelayInfo info( 13, ""Hello"" );

  if( strcmp( info.Message, ""Hello"" ) == 0 )
  {
    digitalWrite( info.Pin, LOW );
  }
}
</code></pre>
",,35835070,606
29379071,2,28249817,2015-03-31T21:40:02.123,0,,2574178,,2015-03-31T21:45:21.270,2015-03-31T21:45:21.270,0,,"<p>The browser is not going to be very happy with what you've done.  Nothing you are returning to the browser obeys the HTTP protocol specs.  You should use a telnet client to open a connection on port 80 to the IP Address of the Core.  You will then see something closer to what you expected.</p>

<p>Using the SparkCore and it's modest facilities to return a web page is possible but you must be tight on sizes.  To return a web page, a browser will be happy with, you can ignore the request and always return this:</p>

<pre><code>HTTP/1.1 200 OK
Date: Tue, 31 Mar 2015 22:38:34 GMT
Server: SparkCore
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Accept-Ranges: bytes
Connection: close

&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;An Example Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Hello World, this is a very simple HTML document.
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>This is a minimal HTTP Response.  I have not tested it but am pretty confident it will work.  To learn more about HTTP and what you will need to do, check out wikipedia:</p>

<p><a href=""http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"" rel=""nofollow"">http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p>

<p>I also found a good thread on community.spark.io:</p>

<p><a href=""http://community.spark.io/t/spark-core-web-server-solved/10110/4"" rel=""nofollow"">http://community.spark.io/t/spark-core-web-server-solved/10110/4</a></p>

<p>Good Luck!</p>
",,35837910,72
28285287,2,28285147,2015-02-02T19:31:31.150,4,,1214743,,2015-02-02T22:30:20.280,2015-02-02T22:30:20.280,9,,"<p>You really need to start from the beginning.  Learn the blink program first so you understand how the Arduino works and interacts with the code that you give it.</p>

<p>look at this picture for example</p>

<p><img src=""https://i.stack.imgur.com/bU4za.png"" alt=""Arduino Blink""></p>

<p>Create the <a href=""http://arduino.cc/en/Reference/Setup"" rel=""nofollow noreferrer""><code>setup()</code></a> Method (without parameters) and setup all the pins you need, then create a <a href=""http://arduino.cc/en/Reference/Loop"" rel=""nofollow noreferrer""><code>loop()</code></a> method that will loop and take the input from the pins and output to the pins at a set interval.  </p>

<p>Please look at the links throughout this answer, I think that you will find them helpful.</p>

<hr>

<p>You should have something like this instead</p>

<pre><code>void setup() //make joystick arcade style controller
{
    //Joystick input you may need more depending on the 
    //device that you are using
    pinMode(13, INPUT);
    pinMode(14, INPUT); 
    //output pins to the motors
    pinMode(11, OUTPUT);
    pinMode(12, OUTPUT);
    //

}

void loop()
{
    int powY;
    int powX;
    int y = analogRead(13); // you could also set your pins to variables
    int x = analogRead(14); // and probably should for readability

    int powRightMotor;
    int powLeftMotor;
    int powmotordriveright;
    int powmotordriveleft;

    // convert joystick -128 to 127 range to -100 to 100 for powering motors
    powY = (y * 100) / 127; //joystick y axis gives maximum power level
    powX = (x * 100) / 127; //x axis determines which motor is reduced or
    //reversed for a turn


    if (powX &lt; 0) //if x negative, turning left; otherwise, turning right
    {
        powLeftMotor = (powY * (100 + (2 * powX))/100); //left motor reduced for right turn
        powRightMotor = (powY * -(100 + (2 * powX))/100); //right motor is reversed
    }
    else
    {
        powRightMotor = (powY * (100 - (2 * powX))/100); //right motor reduced for left turn
        powLeftMotor = (powY * -(100 + (2 * powX))/100); //left motor reversed
    }

    powRightMotor = powmotordriveright;
    powLeftMotor = powmotordriveleft;

    //you are going to want to transform the value to something between 0-255 for an analogWrite
    //it's been a while since I worked with arduinos and wrote the actual code, and I don't know
    //what you are working with either.

    analogWrite(11, powRightMotor);
    analogWrite(12, powLeftMotor
}
</code></pre>

<p>in this case we don't need the for loop because the <code>loop()</code> method already does this ""out of the box"".  so we just check all the input and translate the values to run the motors.</p>

<p>I probably slaughtered this because I don't know what kind of hardware setup that you have going on, but I am pretty sure this should compile </p>

<p>To run on the Arduino platform you absolutely need these 2 Methods, Arduinos are picky.</p>

<hr>

<p>should you need to setup an infinite loop using a for loop it would be structured like this</p>

<pre><code>for (;;)
{
    //do work here
}   
</code></pre>

<p>putting <code>loop;</code> doesn't do anything, it is a syntax error.</p>

<p>(Reference <a href=""http://arduino.cc/en/Tutorial/ForLoop"" rel=""nofollow noreferrer"">Arduino.cc</a> for proper for loop structure)</p>

<p>A While loop might be better for an infinite loop though, then you can set a boolean, and have it exit in certain cases.  Having an inescapable loop is not a good idea.</p>
",,35842994,948
28342654,2,28342378,2015-02-05T11:22:46.737,0,,1606345,,2015-02-05T11:22:46.737,,0,,"<ol>
<li>You are mixing <code>int</code>s and <code>'xxx'</code>? (if it's supposed to be a string it must be <code>""xxx""</code>), and this is not legal in C.</li>
<li><code>ConfigSonde_[i][3]</code> where <code>i = 0</code> doesn't give you a reference to the variable <code>ConfigSonde_0[3]</code></li>
</ol>

<p>Maybe you are looking for:</p>

<pre><code>int ConfigSonde_0[] = {'x', 3, 'A', 1, 0, 0, 0, 0, 0, 0}; 
int ConfigSonde_1[] = {'x', 1, 'A', 1, 0, 0, 0, 0, 0, 0};
int *ConfigSonde [] = {ConfigSonde_0, ConfigSonde_1};

for (i = 0; i &lt; 2; i = i + 1) {ConfigSonde[i][3] = 0;}
</code></pre>

<p>or</p>

<pre><code>int ConfigSonde[][10] = {
    {'x', 3, 'A', 1, 0, 0, 0, 0, 0, 0},
    {'x', 1, 'A', 1, 0, 0, 0, 0, 0, 0}
};

for (i = 0; i &lt; 2; i = i + 1) {ConfigSonde[i][3] = 0;}
</code></pre>
",,35843869,1233
28353804,2,28353600,2015-02-05T20:54:44.077,0,,3133316,,2015-02-05T21:23:05.263,2015-02-05T21:23:05.263,5,,"<p>The code compiles cleanly here:  </p>

<p><a href=""http://ideone.com/AuDEQL"" rel=""nofollow"">http://ideone.com/AuDEQL</a> </p>

<pre><code>class Foobar {};

void myFunction(const Foobar&amp; n) {
}

void setup() {
}

void loop() {
}

int main() {}
</code></pre>

<p>If the code is as you've posted, the cause is usually</p>

<p>1) An invisible character (usually a control character) is embedded on one of the previous lines where the error occurs, and the C++ parser is picking it up as a syntax error </p>

<p>or</p>

<p>2) The characters you <em>are</em> seeing in your source file are not ASCII, but some ""fancified"" version of the character (thus either Unicode or some other encoding).  This can happen if you copy and paste from an application that uses the alternate encoding to make the text ""look good"", for example, a word processor such as MS Word.</p>

<p>I would take the file and inspect it in a hex editor to ensure it doesn't have such characters. </p>

<p>Edit:  The other scenario, which was pointed out in the comments by <code>Ignacio Vazquez-Abrams</code> is </p>

<p>3) you could be compiling a different file than the one you have posted.  This seems to be the case for Arduino IDE.</p>
",,35879948,498
28354111,2,28353600,2015-02-05T21:13:42.073,0,,3921341,,2015-02-05T21:13:42.073,,0,,"<p>Oh my <code>$DEITY</code>!</p>

<p>Following Ignacio suggestions, I checked out the final assembled cpp file that Arduino generates and the build system tries to compile:</p>

<pre><code>#line 1 ""sketch_feb05b.ino""
#include ""Arduino.h""
void myFunction(const Foobar&amp; n);
void setup();
void loop();
#line 1
class Foobar {};

void myFunction(const Foobar&amp; n) {
}

void setup() {
}

void loop() {
}
</code></pre>

<p>So the IDE generates the declarations of the functions and puts them in the beginning of the file, before the types are declared. </p>

<p>No invisible symbols after all but a terrible decision of Arduino authors :-(</p>

<p>I wonder whether putting the types in external header files would fix it. </p>
",,35898926,1907
28501330,2,28397551,2015-02-13T14:01:55.653,0,,1703536,,2015-02-23T18:04:24.127,2015-02-23T18:04:24.127,0,,"<p>I think what you're trying to do is something like this:</p>

<pre><code>int var1=0;
int var2=0;

typedef struct {
    unsigned int item_value;
    char item_name[17];
} Select_Item;

typedef struct {
  char item_name[17];
  int* variable;
  Select_Item* list;
} Menu_Item;

Select_Item sel_one = { 0, ""Selection 1"" };
Select_Item sel_two = { 1, ""Selection 2"" };
Select_Item sel_three = {2, ""Selection 3"" };
Select_Item sel_four = {3, ""Selection 4"" };

Select_Item* sel_list_1[] = { &amp;sel_one, &amp;sel_two };
Select_Item* sel_list_2[] = { &amp;sel_three, &amp;sel_four };

Menu_Item menu_item1 = { ""Item 1"", &amp;var1, sel_list_1[0] }; // Note the syntax here
Menu_Item menu_item2 = { ""Item 2"", &amp;var2, sel_list_2[0] }; // Note the syntax here
Menu_Item* menu_list[2] = { &amp;menu_item1, &amp;menu_item2 };

// Added for testing
int main()
{
    printf(""Menu item '%s'\n"", menu_list[0]-&gt;item_name);
    printf(""    %d - %s\n"", menu_list[0]-&gt;list[0].item_value, menu_list[0]-&gt;list[0].item_name);
    printf(""    %d - %s\n"", menu_list[0]-&gt;list[1].item_value, menu_list[0]-&gt;list[1].item_name);
    printf(""Menu item '%s'\n"", menu_list[1]-&gt;item_name);
    printf(""    %d - %s\n"", menu_list[1]-&gt;list[0].item_value, menu_list[1]-&gt;list[0].item_name);
    printf(""    %d - %s\n"", menu_list[1]-&gt;list[1].item_value, menu_list[1]-&gt;list[1].item_name);
    return 0;
}
</code></pre>

<p>Note the syntax for the initialization of <code>menu_item1</code> and <code>menu_item2</code>.  </p>

<p>I added main() just so I could test this with a normal C compiler (since I don't have an Arduino with an LCD handy).  The output from my testing looks like this:</p>

<pre><code>Menu Item 'Item 1'
    0 - Selection 1
    1 - Selection 2
Menu Item 'Item 2'
    3 - Selection 3
    4 - Selection 4
</code></pre>

<p>And I think that's what you're trying to achieve with your data structures.  You'll just need to adapt this to your Arduino code and use these data structures to manage the menu selections on your LCD.</p>
",,35904556,2448
28423450,2,28423387,2015-02-10T03:13:28.837,1,,2069064,,2015-02-10T03:13:28.837,,0,,"<p><code>myRTC1.now</code> cannot be converted to a function pointer - it's a class method. You need an instance of <code>myRTC1</code> to call <code>now</code> on. What you're trying to do as-is is impossible.</p>

<p>What you can instead do is take a <code>std::function</code>:</p>

<pre><code>class Logger {
public:
    using LogFunc = std::function&lt;char()&gt;; // any function that takes no 
                                          // args and returns a char

    template &lt;typename F&gt;
    void ini(F&amp;&amp; f) { logTime = std::forward&lt;F&gt;(f); }
    LogFunc logTime;
};
</code></pre>

<p>Which you can then assign thusly:</p>

<pre><code>Logger myLogger;
myLogger.ini(std::bind(&amp;RTC1::now, myRTC1));
myLogger.ini([&amp;]{ return myRTC2.now(); });
</code></pre>
",,35952105,1508
28450536,2,28448787,2015-02-11T09:18:21.467,2,,3386109,,2015-02-11T09:40:50.277,2015-02-11T09:40:50.277,11,,"<p>The following code shows how to use the <code>millis()</code> function to determine the time between two events. Each time the piezo returns a value greater than 2, the elapsed time is displayed, and the timestamp is updated.</p>

<pre><code>unsigned long timestamp = 0;

void loop()
{
    int piezoValue;
    unsigned long elapsedTime;

    piezoValue = analogRead(piezo);

    if ( piezoValue &gt; 2 )
    {
        // compute the time (in milliseconds) since the last knock
        elapsedTime = millis() - timestamp;

        Serial.print( ""Time since the last knock "" );
        Serial.print( elapsedTime );
        Serial.println( "" msec"" );

        // store the current time 
        timestamp = millis();
    }
}
</code></pre>
",,35966790,332
28487664,2,28487502,2015-02-12T21:00:41.510,4,,1703536,,2015-02-12T21:28:01.723,2015-02-12T21:28:01.723,0,,"<p>Declare <code>board</code>, <code>displayWidth</code>, and <code>displayHeight</code> globally (outside of any function definition). Like this:</p>

<pre><code> const int displayWidth  = 14;
 const int displayHeight = 10;
 int board[displayWidth][displayHeight];

void generateBoard() {
  // Modifies the array board by setting 0

  for (int y=0; y &lt; displayHeight; y++) {
    for (int x=0; x &lt; displayWidth; x++) {
      board[x][y] = 0;
    }
  }
}

void setup() {
  generateBoard(); 
}

void loop() {}
</code></pre>

<p>Declaring them inside of setup() makes them local variables - local variables are only accessible to the function in which they are declared.</p>
",,35981302,334
28493396,2,28491732,2015-02-13T05:56:34.610,2,,2705055,,2015-02-13T11:05:09.483,2015-02-13T11:05:09.483,1,,"<p>First of all comments in ""regular"" (not cpp pre-processed) assembler code begin with a hash sign, not with two slashes. So you might want that a comment named ""# onesectimer"" is in the assembler code.</p>

<p>This may be archieved the following way:</p>

<pre><code>asm(""\n# onesectimer"");
void OneSecTimer()
{
  if(bags!=0){
    asm(""\n# for counter 1"");
    if(counter1 == 3)
...
</code></pre>

<p>--- Edit ---</p>

<p>Reading your comments and your edits I think you are mixing the words ""assembly"" and ""disassembly"":</p>

<p>When translating C code to binary code the C compiler generates ""assembly"" code. This code may contain comments:</p>

<pre><code># This is a comment
lds r24, 0
ldi r22, 1
call digitalWrite
</code></pre>

<p>The assembler then translates this ""assembly"" code to binary code. In binary code there is no information about comments any more but only the binary data to be written to the memory.</p>

<p>The ""disassembly"" translates the binary data back to assembly code but only information that is present in binary code may be disassembled - so you cannot have any comments in disassembly code!</p>

<p>What you may do is to insert a symbol into the object file at a point of interest:</p>

<pre><code>digitalWrite(0,1);
asm volatile("".global Here_is_Delay\nHere_is_Delay:"");
delay(1000);
</code></pre>

<p>The names of these symbols must be unique over the whole project and not be identical to any function or variable name used.</p>

<p>Depending on the disassembler (not sure about the AVR one) you'll see the symbols then:</p>

<pre><code>loop():
C:\Program Files (x86)\Arduino/sketch_jul17a.ino:19
   0:   80 91 00 00     lds r24, 0x0000
   4:   61 e0           ldi r22, 0x01   ; 1
   6:   0e 94 00 00     call    0   ; 0x0 &lt;loop&gt;

Here_is_Delay():
C:\Program Files (x86)\Arduino/sketch_jul17a.ino:20
   a:   68 ee           ldi r22, 0xE8   ; 232
   c:   73 e0           ldi r23, 0x03   ; 3
     ...
</code></pre>
",,35991092,497
28560880,2,28529915,2015-02-17T11:27:45.613,0,,1875791,,2015-02-17T11:27:45.613,,4,,"<p>Open the serial port on Raspberry side in RAW mode. Use the following piece of code to open the port in RAW mode:</p>

<pre><code>int fd = open(""/dev/ttyS0"", O_RDWR | O_NOCTTY | O_NDELAY);

if(fd == -1)
{
        return -1;
}
else
{

        struct termios new_termios;
        struct termios orig_termios;

        tcgetattr(fd, &amp;orig_termios);
        memcpy(&amp;new_termios, &amp;orig_termios, sizeof(new_termios));

        cfmakeraw(&amp;new_termios);

        cfsetispeed(&amp;new_termios, B57600);
        cfsetospeed(&amp;new_termios, B57600);

        tcsetattr(fd, TCSANOW, &amp;new_termios);

}
</code></pre>

<p>Hopefully that would work perfect in your case.</p>
",,36000243,37
29844594,2,28557873,2015-04-24T10:03:46.170,1,,1753857,,2015-04-24T10:03:46.170,,0,,"<p>use python and spidev module!
It will look something like!</p>

<pre><code>import spidev

spi = spidev.SpiDev()
spi.open(0,0)

def read(ch):
    adc = (spi.xfer2([1,(8+ch)&lt;&lt;4,0])
    data = ((adc[1]&amp;3 &lt;&lt; 8) + adc[2]
</code></pre>

<p>This should give u proper readings from the mcp3008 chip.
I am currently using this chip in a sensor module for connecting my analog sensors. Ch is the channel on the mcp3008 (0-7)</p>
",,36044770,303
28652025,2,28651939,2015-02-21T22:16:03.297,12,,586873,,2015-02-21T22:24:49.567,2015-02-21T22:24:49.567,5,,"<p>There is no <code>byte</code> type in C. Unless it's some type definition, you could use <code>unsigned char</code> or some fixed type from <code>&lt;stdint.h&gt;</code> portably. Anyway, here is some solution:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    unsigned char a[3+3] = {1, 2, 3}; // n+m
    unsigned char b[3]   = {4, 5, 6}; // m

    memcpy(a+3, b, 3); // a+n is destination, b is source and third argument is m

    for (int i = 0; i &lt; 6; i++) {
        printf(""%d\n"", a[i]);
    }

    return 0;
}
</code></pre>

<p>Make sure that array <code>a</code> has room for at least <code>n + m</code> elements (here <code>n = 3</code> and <code>m = 3</code> as well) in order to avoid issues with array overflow (i.e. undefined behavior, that may crash yor program or even worse).</p>
",,36058764,4705
28677778,2,28677381,2015-02-23T15:55:48.327,1,,31762,,2015-02-23T17:55:17.513,2015-02-23T17:55:17.513,4,,"<p>Apparently you don't need to break the string into bits the API does it for you.... </p>

<p>Anyway if you did:</p>

<p>Each char in your ""hello world\n"" string is a byte when encoded in ASCII. ASCII actually only used the lowest 7 bits. If you want to pick apart a char into bits I would use the following code as a start.</p>

<pre><code>char ch = 'h';
for (i=0; i&lt;7; i++) {
   bool b = (ch &amp; 1 == 1);
   ch &gt;&gt;= 1;
   // set the bit value b off to the pin....
   }
</code></pre>

<p>you would need a loop around this to process whole strings.</p>
",,36097861,39
28732744,2,28677381,2015-02-26T01:04:50.080,0,,339937,,2015-02-26T01:04:50.080,,0,,"<p>For move 7-bits ASCII-char to the port bit-by-bit, you can use:</p>

<pre><code>void toPort(unsigned char x) {
  x |= 0200; // Set unused high-bit to 1
  for ( ; ; ) {
   char bit = x &amp; 1;
   x &gt;&gt;= 1;
   if(x == 0) return;
   push_to_port(bit);
  } 
}
</code></pre>
",,36116398,1262
28697189,2,28696781,2015-02-24T13:34:23.923,1,,4377400,,2015-02-24T13:34:23.923,,3,,"<p>You are making the classic struct-to-network/serial/insert communication layer mistake. Structs have hidden padding in order to align the members onto suitable memory boundaries. This is not guaranteed to be the same across different computers, let alone different CPUs/microcontrollers.</p>

<p>Take this struct as an example:</p>

<pre><code>struct Byte_Int
{
     int x;
     char y;
     int z;
}
</code></pre>

<p>Now on a basic 32-bit x86 CPU you have a 4-byte memory boundary. Meaning that variables are aligned to either 4 bytes, 2 bytes or not at all according to the type of variable. The example would look like this in memory: int x on bytes 0,1,2,3, char y on byte 4, int z on bytes 8,9,10,11. Why not use the three bytes on the second line? Because then the memory controller would have to do two fetches to get a single number! A controller can only read one line at a time. So, structs (and all other kinds of data) have hidden padding in order to get variables aligned in memory. The example struct would have a sizeof() of 12, and not 9!</p>

<p>Now, how does that relate to your problem? You are memcpy()ing a struct directly into a buffer, including the padding. The computer on the other end doesn't know about this padding and misinterprets the data. What you need a serialization function that takes the members of your structs and pasts them into a buffer one at a time, that way you lose the padding and end up with something like this:
[0,1,2,3: int x][4: char y][5,6,7,8: int z]. All as one lengthy bytearray/string which can be safely sent using Serial(). Of course on the other end you would have to parse this string into intelligible data. Python's unpack() does this for you as long as you give the right format string.</p>

<p>Lastly, an int on an Arduino is 16 bits long. On a pc generally 4! So assemble your unpack format string with care.</p>
",,36149942,1653
28737044,2,28696781,2015-02-26T07:52:15.767,0,,4116421,,2015-02-26T07:52:15.767,,0,,"<p>The char array I was passing to the crc_string function contained '\0' characters. The crc_string was iterating through the array until it found a '\0' which shouldn't happen in this case since I was using the char array as a stream of bytes to be sent over a serial connection. </p>

<p>I've changed the crc_string function to take the array size as argument and iterate through the array using that value. This solved the issue.</p>

<p>Here's the new function</p>

<pre><code>unsigned long crc_string(char *s, size_t arraySize) 
{ 
  unsigned long crc = ~0L; 
  for (int i=0; i &lt; arraySize; i++) { 
    crc = crc_update(crc, s[i]); 
  } 
  crc = ~crc; 
  return crc; 
}
</code></pre>
",,36170616,1634
28722148,2,28721813,2015-02-25T14:53:20.610,0,,2246371,,2015-02-25T15:00:14.747,2015-02-25T15:00:14.747,0,,"<p>Use a flag that you set when the button is read as pressed for the first time, and unset it when no button press is read.</p>

<p>To check that the button has been pressed for a while, make a second call to the read function after some milliseconds and if it still is pressed, go on. There are more elegant solutions to this but they require use of interrupts.</p>

<pre><code>...
int ButtonPressed = 0;
...
void loop()
{
    // Button pressed?
    if (digitalRead(BUTTON)==HIGH)
    {
        // Try again in a while
        delay_ms(500);
        // Still pressed?
        if (digitalRead(BUTTON)==HIGH)
        {
            // Has button been pressed previously?
            if ((ButtonPressed &amp; (1&lt;&lt;BUTTON)) == 0)
            {
                // Yes
                ButtonPressed |= (1&lt;&lt;BUTTON);
                ...
            }
        }
    }

    else
    {  
        // Button has been released
        ButtonPressed &amp;= ^(1&lt;&lt;BUTTON);
        ...
    }
}
</code></pre>
",,36188155,7640
28741163,2,28733011,2015-02-26T11:25:26.903,0,,4363988,,2015-02-26T11:25:26.903,,0,,"<p>You can use the millis() function, something similar to the following code:</p>

<pre><code>if(ButtonPress==true){
 time=millis() //time was previously declared as unsigned long
    if(time&gt;=5000){ //5000 = 5 sec
     ButtonPress==false
    }
}
</code></pre>

<p>It will not stop the arduino loop as dealy() does.
More info: <a href=""http://playground.arduino.cc/Code/AvoidDelay"" rel=""nofollow"">http://playground.arduino.cc/Code/AvoidDelay</a></p>
",,36192067,75
28743207,2,28733011,2015-02-26T13:02:17.113,0,,4452578,,2015-02-26T13:02:17.113,,0,,"<p>Perhaps you are trying to de-bounce the button. I usually do this in the main loop, and expect 5 consecutive ""pressed"" reads before I say the button is really pressed, something like this:</p>

<pre><code>int  button1PressedCount = 0;
int  debounceCounter = 5; // Number of successive reads before we say the switch is pressed
boolean buttonPressed = false;
int inputPin1 = 7;

void setup() {
  // Grounding the input pin causes it to actuate
  pinMode(inputPin1, INPUT ); // set the input pin 1
  digitalWrite(inputPin1, HIGH); // set pin 1 as a pull up resistor.
}

void loop()     
{
  // Some code

  // Check button, we evaluate below
  checkButton();

  // Some more code
}

void checkButton() {
  if (digitalRead(inputPin) == 0) {
    // We need consecutive pressed counts to treat this is pressed    
    if (button1PressedCount &lt; debounceCounter) {
      button1PressedCount += 1;
      // If we reach the debounce point, mark the start time
      if (button1PressedCount == debounceCounter) {
        // Button is detected as pressed!
        buttonPressed = true;
      }
    }
  } else {
    if (button1PressedCount == debounceCounter) {
        // We were pressed, but are not any more 
        buttonPressed = false;
    }

    button1PressedCount = 0;
  }
}
</code></pre>

<p>Also it seems using an analogue input with a check if the analogue value is exactly equal to 0 might be a bit sensitive in noisy environments. This is why I use a digital input and the internal pull up resistor.</p>
",,36200295,877
33325411,2,28750703,2015-10-25T02:00:34.743,0,,5484895,,2015-10-25T02:05:39.017,2015-10-25T02:05:39.017,0,,"<p>I wrote the following code for PCF8591 using a C language.
This cord work fine.</p>

<pre><code>#include &lt;wiringPi.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

/*
cc -o test1 test1.c -lwiringPi
*/

int main (void)
{
  int fd;
  int i;
  int a2dChannel = 0; // analog channel
  int a2dVal;
  float a2dVol;
  float Vref = 3.3;

  if ((fd = wiringPiI2CSetup(0x48)) &lt; 0) {
    printf(""wiringPiI2CSetup failed:\n"");
  }

  for(i=0;i&lt;20;i++) {
    wiringPiI2CWrite(fd,0x40 | a2dChannel);
    a2dVal = wiringPiI2CRead(fd); // Previously byte
    a2dVal = wiringPiI2CRead(fd);
    a2dVol = a2dVal * Vref / 255;
    printf(""a2dVal=%d\n"",a2dVal);
    printf(""a2dVol=%f[V]\n"",a2dVol);
    sleep(1);
  }
}
</code></pre>

<p>And you can use analogRead().</p>

<pre><code>#include &lt;wiringPi.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pcf8591.h&gt;

#define PINBASE 100

/*
cc -o test2 test2.c -lwiringPi
*/

int main (void)
{
  int i;
  int a2dChannel = 0; // analog channel
  int a2dVal;
  float a2dVol;
  float Vref = 3.3;

  if (pcf8591Setup(PINBASE, 0x48) &lt; 0)
  {
    printf(""pcf8591Setup failed:\n"");
  }

  for(i=0;i&lt;20;i++) {
    a2dVal = analogRead(PINBASE + a2dChannel);
    a2dVol = a2dVal * Vref / 255;
    printf(""a2dVal=%d\n"",a2dVal);
    printf(""a2dVol=%f[V]\n"",a2dVol);
    sleep(1);
  }
}
</code></pre>
",,36211171,12219
28794947,2,28794539,2015-03-01T14:55:53.010,-1,,2489299,,2015-03-01T15:13:31.573,2015-03-01T15:13:31.573,2,,"<p>As pointed out below, this applies to C not C++:</p>

<p>Arrays need a size that is a <em>constant expression</em>, making something <code>const</code> does not meet that criteria.</p>

<pre><code>char keys[4][3] = {
    {'1','2','3'},
    {'4','5','6'},
    {'7','8','9'},
    {'#','0','*'}
};
</code></pre>
",,36231302,2085
28801060,2,28800533,2015-03-02T00:33:16.420,0,,4548546,,2015-03-02T00:33:16.420,,0,,"<p>This did the trick, still not sure why echo didn't work.</p>

<pre><code>FILE *ain;
ain = fopen(""/sys/devices/bone_capemgr.9/slots"", ""w"");
fseek(ain,0,SEEK_SET);
fprintf(ain,""cape-bone-iio"");
fflush(ain);

fclose(ain);
return 0;
</code></pre>
",,36234735,982
28825798,2,28825670,2015-03-03T06:54:42.900,0,,3723423,,2015-03-03T23:25:46.203,2015-03-03T23:25:46.203,0,,"<p>The problem is that a c-string stored as an array of char cannot be copied, passed as argument by value,  or  compared like build-in scalar type. </p>

<p><strong>Solution 1:</strong> use <strong><a href=""http://www.cplusplus.com/reference/string/string/?kw=string"" rel=""nofollow""><code>string</code></a></strong> instead of <code>char[4]</code>. <strong>That's the recommended C++ way</strong>. They are extremeley easy and intuitive to use, and they have no real length restriction.  But if you desire to limit their length, you can control it at user entry.   </p>

<p><strong>Solution 2:</strong> if you can't use solution 1, because of technical limitations of an embedded system, you could use a structure/class for holding the string.  Here a templatized version: </p>

<pre><code>template &lt;int N&gt;
struct fstring {
    char s[N+1];                // fixed string
    fstring() : s{} {}          // create an empty string
    fstring(const char*st) {    // convert a c-string to a fixed string
        strncpy(s, st, N);
        s[N] = 0;
    }
    bool operator== (fstring x) // compare two strings 
    {
        return strncmp(s, x.s, N) == 0;
    }
};
... 
fstring&lt;3&gt; names[10];  // ten fixed strings
</code></pre>

<p><strong>Solution 3:</strong> You can keep your data structures exactly as they are, but use <code>strncpy()</code> instead of assignment, and <code>strcmp()</code> instead of comparison.   </p>
",,36242308,2364
28876157,2,28861621,2015-03-05T10:54:28.463,8,,2704120,,2015-03-05T10:59:44.010,2015-03-05T10:59:44.010,2,,"<p>You have to tell Arduino that your library uses C naming.  You can use <code>extern ""C""</code>  directly in the Arduino code.</p>

<p>The next code compiles in Arduino IDE 1.05.</p>

<pre><code>extern ""C""{
  #include &lt;mycLib.h&gt;
}

void setup()
{
  mycLibInit(0);
}

void loop()
{
}
</code></pre>

<p>mycLib.h</p>

<pre><code>#ifndef _MY_C_LIB_h
#define _MY_C_LIB_h

typedef struct {char data1;
                int data2;
                } sampleStruct;

  void mycLibInit(int importantParam);
  void mycLibDoStuff(char anotherParam);

  sampleStruct mycLibGetStuff();

#endif
</code></pre>

<p>mycLib.c:</p>

<pre><code>#include ""mycLib.h""
sampleStruct _sample;
void mycLibInit(int importantParam)
{
    //init stuff!
    //lets say _sample.data2 = importantParam
}

void mycLibDoStuff(char anotherParam)
{
    //do stuff!
    //lets say _sample.data1 = anotherParam
}

sampleStruct mycLibGetStuff()
{
    //return stuff, 
    // lets say return _sample;
}
</code></pre>
",,36242505,71
28888527,2,28888475,2015-03-05T21:56:12.453,3,,1540468,,2015-03-05T22:01:56.447,2015-03-05T22:01:56.447,0,,"<p>Use <a href=""http://man7.org/linux/man-pages/man3/popen.3.html"" rel=""nofollow""><code>popen(3)</code></a> like this</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int main() 
{
    FILE *in;
    char buff[512];

    if(!(in = popen(""ls -la"", ""r"")))
    {
        return 1;
    }

    while(fgets(buff, sizeof(buff), in)!=NULL)
    {
        cout &lt;&lt; buff;
    }

    pclose(in);

    return 0;
}
</code></pre>
",,36269847,1145
28906090,2,28905242,2015-03-06T19:20:55.563,0,,3593970,,2015-03-06T19:20:55.563,,1,,"<p>This is just a basic programming logic.</p>

<p>Imagine that you want to count to 5 and call some function, e.g. <code>DoSomething</code>, in and endless loop.</p>

<pre><code>int count = 0;
bool called = false; // DoSomething not called yet

while (true) // main loop
{
    ++count;

    if (count == 5)
    {
        // the count is 5
        if (called == false)
        {
            // function not called yet, call it!
            called = true;
            DoSomething();
        }
    }
}
</code></pre>

<p>This might seem as a non-sense in a way. Just wait for it...</p>

<p>However, the problem you're facing is that you don't have a simple counter like mine <code>count</code>. Instead, you're using a timer that could be a few milliseconds off and you still want the code to execute even if it's late.</p>

<p>For example:</p>

<pre><code>int count = 0;
bool called = false; // DoSomething not called yet

while (true) // main loop
{
    count += 2; // emulate counter being late

    if (count &gt;= 5) // note that count == 5 will be always false here...
    {
        // the count is 5 or more
        if (called == false)
        {
            // function not called yet, call it!
            called = true;
            DoSomething();
        }
    }
}
</code></pre>

<p>Now that completely inverses the value of the <code>if</code>s. This way, the application almost always passes the first <code>if</code> but only <strong>once</strong> the second. In order to optimize this, you can just swap the <code>if</code>s:</p>

<pre><code>if (called == false)
{
    if (count &gt;= 5)
    {
        called = true;
        DoSomething();
    }
}
</code></pre>

<p>And now, as you probably know, these nested <code>if</code> statements can be easily grouped into one using <code>&amp;&amp;</code> operator. Also, <code>called == false</code> can be made less verbose by using <code>!called</code>. This in the end results in</p>

<pre><code>while (true) // main loop
{
    count += 2; // emulate counter being late

    if (!called &amp;&amp; count &gt;= 5)
    {
        // function not called yet and count is already 5 or more
        called = true;
        DoSomething();
    }
}
</code></pre>

<p>So what is going on is:<br>
a) you want to execute a piece of code only <strong>once</strong><br>
   - represented by <code>bool called = false; if (!called) called = true;</code> logic or <code>timer0fired</code> in your code for the matter</p>

<p>b) you want to delay the call until some timer reaches a certain amount<br>
   - represented by <code>count &gt;= 5</code> or <code>timer &gt;= interval</code> in your example</p>

<p><strong>tl;dr<br>
Your code is working correctly.</strong></p>
",,36308733,2305
28909702,2,28909538,2015-03-07T00:01:00.547,1,,343721,,2015-03-07T00:01:00.547,,0,,"<p>Ah, I found the solution in the SD library: one clever <code>extern</code> keyword!</p>

<p><strong>myobj.h</strong></p>

<pre><code>#pragma once
struct myobj {
  myobj();
  ...
};
extern myobj Myobj;
</code></pre>

<p><strong>myobj.cpp</strong></p>

<pre><code>#include ""myobj.h""
myobj::myobj() { ... }
...
myobj Myobj;
</code></pre>

<p><strong>mysketch.ino</strong></p>

<pre><code>#include ""myobj.h""
Myobj.someMethod(); // works, no multiple definition error
...
</code></pre>
",,36326399,319
28926151,2,28916264,2015-03-08T12:01:13.140,1,,4607349,,2015-03-08T12:01:13.140,,4,,"<p>Your sample is not even compilable. Here you are fixed version. </p>

<p>After you connect you better close connection with client.stop() otherwise some simple servers might not be listening for a new connection and are still waiting data to come on the previous connection.</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
IPAddress ip;
IPAddress localIp (192,168,1,181);
EthernetClient client ;

void setup()
{
  Serial.begin(9600);
  Ethernet.begin(mac , localIp);
  char x[] = ""192.168.1.1"" ;//my pc , running SimpleHTTPServer (python)  
  client.connect(x , 8000);
  if( client.connected() ){
    Serial.println(""connected""); //does never print
  }
  client.println (""Hellou world from Arduino!"") ;
  client.stop();       
}

void loop()
{

}
</code></pre>

<p>Michal</p>
",,36373870,1895
28978093,2,28920580,2015-03-11T03:30:51.887,1,,4656431,,2015-03-11T03:30:51.887,,1,,"<p>The issue you are experiencing lies in the actual timeline of events.</p>

<p>When the RPi sends the data to the Arduino, remember that it is sending it <em>serially</em>, i.e. one character at a time.</p>

<p>As soon as the first byte of data arrives at the Arduino, then Serial.available() will return 1, indicating that the first byte has arrived! Your code then goes to work to process only that first byte (the Arduino is much faster than the serial communication).</p>

<p>An easy solution is to use <a href=""http://arduino.cc/en/Serial/ReadBytes"" rel=""nofollow"">Serial.readBytes()</a>, which will keep reading the bytes until the RPi stops sending, and buffer them up for you. It will keep reading the bytes until the serial timeout is achieved (default:1 second), or until the buffer is filled up.</p>

<pre><code>while(Serial.available() == 0)
    ; // Waiting for data

char buffer[80];
int bytesRead = Serial.readBytes(buffer, 80);

String msg = ""Arduino received "";
msg += bytesRead;
msg += "" bytes"";
Serial.println(msg);
delay(10000);
</code></pre>

<p>The problem with the RPi printing out garbage characters on the last line is likely a different, seperate issue.</p>
",,36381932,1166
29324572,2,28921632,2015-03-29T01:15:08.363,2,,4674154,,2015-03-29T01:15:08.363,,0,,"<p>Yes, this is possible by querying the OMX_PARAM_PORTDEFINITIONTYPE structure of the decoder output port. You have to use something along these lines:</p>

<pre><code>OMX_PARAM_PORTDEFINITIONTYPE portdef;
portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
portdef.nVersion.nVersion = OMX_VERSION;
portdef.nPortIndex = 131;

OMX_GetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamPortDefinitionType, portdef);

printf(""Width: %d, Height: %d\n"", portdef.format.video.nFrameWidth, portdef.format.nFrameHeight);
</code></pre>

<p>Please note that this will only give you correct values after the OMX_EventPortSettingsChanged event has fired (which happens after processing the first buffer). Otherwise, this values can and probably will be wrong.</p>
",,36392527,969
29026801,2,29026533,2015-03-13T07:21:09.117,0,,264808,,2015-03-13T07:21:09.117,,1,,"<p>I updated my GPSLocation class as follows which solved my problem.  Thanks guys.</p>

<p><strong>GPSLocation.h</strong></p>

<pre><code>#ifndef GpsLocation_h
#define GpsLocation_h

#include ""Arduino.h""

class GpsLocation
{
  public:
   float latitude;
   float longitude;
};

#endif
</code></pre>

<p><strong>GPSLocation.cpp</strong></p>

<pre><code>#include ""Arduino.h""
#include ""GpsLocation.h""
</code></pre>

<p>Setting and getting from <strong>Test.ino</strong> as follows</p>

<pre><code>loc1.latitude = -12.3456;
Serial.print(loc1.latitude, 4);
</code></pre>
",,36401027,2296
51814187,2,29051576,2018-08-13T01:36:36.633,2,,1394966,,2018-08-13T01:36:36.633,,0,,"<p>This is an update as of 8/12/2018.<br>
The process has changed since 2014.
It may change again. </p>

<pre><code>This is my configuration:
Ubuntu (18.04)
Eclipse: Photon (4.9)
C++ Oxygen 2 (9.3)
Arduino CDT   (3.0)
</code></pre>

<p>There is on official way to add a library member.</p>

<p>And there is a hacked way. I do not support the hacked way
I will only tell you what I have found that works
for today. No guarantees, warranties, or other legal
liabilities. No money, you get what you paid. If it
works use it. If it does not, don't bring up any problems with
the official support. There is no support for the hacked way.</p>

<p>The official way is to download the library members
from the website: //arduino.cc. This is made possible
by installing the Arduino CDT package from the market place.
After the install, an additional menu item is added to the
""Help"" menu. It is labeled ""Arduino Download Manager"".
Follow the panels to the libraries tab and select ""Add"" option. 
Receive a list of groups. Expand a group to see the members under each group that identifies libraries that can be added to your installation.</p>

<p>The non-official way is to create a folder with the name
of your library. In this folder place 3 files: the library's "".h"" and "".cpp""
files, and an additional ""library.properties"". 
An arduino library is essentially a C++ class definition.</p>

<p>Here is a sample of the library.propertiels contents:</p>

<p>library.properties:</p>

<hr>

<pre><code> name=&lt;your library name&gt;
 version=1.0.0
 author=&lt;your name&gt;
 maintainer=&lt;your name&gt;
 sentence=&lt;brief description&gt;
 paragraph=&lt;more detailed description&gt;
 category=Private 
 url=local
 architectures=* 
</code></pre>

<hr>

<p>Notice: I named the category ""Private"". This will keep
all of my libraries out of the listing of standard libraries.</p>

<p>Copy this directory with the three files into the ""/home/user/.arduinocdt/libaries/"" folder. </p>

<p>Restart your Eclipse session (so it rebuilds the library definitions).  </p>

<p>This installs the library but it does not mean you can use it
in your project. To have access in your project you have
to make it apart of your project. </p>

<p>To make it useful to your project, access the ""Project"" view 
(acces this view by: /window/show view/Project Explorer).
Select the project you wish to modify, and right-click on
that project. You should receive a pop-up menu which contains
an entry labeled ""Properties"" (at the very bottom). This will 
cause an properties panel to be displayed. In that panel 
select the ""libraries"" options. You should receive a list of 
all the possible categories. Expand the ""Private"" category, 
and place a checkmark next to your library and click ""apply"" 
or ""apply and close"". </p>

<p>You should now be able to add a ""#include &lt;.....h>"" statement
in a member of your project (.i.e. sketch). If you make changes to your
library member, make them outside of the "".arduinocdt"" directory.
shutdown eclipse; copy the new contents into the library, and
restart your eclipse session. </p>

<p>This is NON-OFFICIAL ""hack"" and I do not support this. It is just what
I found works for me. becareful it may cause problems, now or in the
future with updates or releases. Be prepared to abandon it is there
is a problem. (If you go into ""Help/Arduino Download Manager/ under the
""libraries"" tab you should see a list of  groups which should include
the ""Private"" group under that group you should see your library listed.
By selecting it and clicking ""uninstall"", It will remove your library
folder from the "".arduinocdt/libraries"" directory. Maintaining your
libraries is your responsibility. Deleting a library will impact your
projects. Buyer be ware. </p>
",,36421213,2677
35033831,2,29077279,2016-01-27T09:47:22.317,0,,5696946,,2016-01-27T09:47:22.317,,0,,"<p>Try this code.</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;    
#include &lt;TinyGPS.h&gt;    
TinyGPS gps;          

static void print_long(long val, long invalid, int len, int prec);          
static void print_int(unsigned long val, unsigned long invalid, int len);      
static void print_date(TinyGPS &amp;gps);                                          
static void print_str(const char *str, int len);                                

SoftwareSerial ss(3,4);

void setup()
{
  Serial.begin(9600);       
  ss.begin(9600);        
 }

void loop()
{

  long lat, lon;
  int alt;

  unsigned short sentences = 0, failed = 0;
  gps.get_position(&amp;lat, &amp;lon);
  alt=gps.altitude();

  Serial.print(""CURRENT LATITUDE &amp; LONGITUDE:"");
  Serial.print(lat);
  Serial.print("","");
  Serial.println(lon);
  Serial.print(""CURRENT ALTITUDE:"");
  Serial.println(alt);
  smartdelay(1000); 
}


static void smartdelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (ss.available())
      gps.encode(ss.read());
  } while (millis() - start &lt; ms);
}

static void print_long (long val, long invalid, int len, int prec)  
{
  if (val == invalid)
  {
    while (len-- &gt; 1)
      Serial.print('*');
    Serial.print(' ');
  }
  else
  {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val &lt; 0.0 ? 2 : 1); // . and -
    flen += vi &gt;= 1000 ? 4 : vi &gt;= 100 ? 3 : vi &gt;= 10 ? 2 : 1;
    for (int i=flen; i&lt;len; ++i)
      Serial.print(' ');
  }
  smartdelay(0);
}


static void print_int(unsigned long val, unsigned long invalid, int len)
{
  char sz[32];
  if (val == invalid)
    strcpy(sz, ""*******"");
  else
    sprintf(sz, ""%ld"", val);
  sz[len] = 0;
  for (int i=strlen(sz); i&lt;len; ++i)
    sz[i] = ' ';
  if (len &gt; 0) 
    sz[len-1] = ' ';
  Serial.print(sz);
  smartdelay(0);
}
static void print_str(const char *str, int len)
{
  int slen = strlen(str);
  for (int i=0; i&lt;len; ++i)
    Serial.print(i&lt;slen ? str[i] : ' ');
  smartdelay(0);
}
</code></pre>
",,36431493,365
29131867,2,29122381,2015-03-18T20:17:48.073,0,,1899801,,2015-03-18T20:17:48.073,,0,,"<p>You can wrap your low level differences between the following pragma.</p>

<pre><code>#if defined(ARDUINO) 
  Serial.print...
#else
  .. Processing way..
#endif
</code></pre>
",,36432350,812
29201617,2,29201478,2015-03-23T00:33:01.293,0,,65863,,2015-03-23T00:38:12.240,2015-03-23T00:38:12.240,2,,"<p>Look at the actual constructors available for <code>Adafruit_HX8357</code> and <code>Adafruit_STMPE610</code>:</p>

<pre><code>Adafruit_HX8357(int8_t _CS, int8_t _DC, int8_t _MOSI, int8_t _SCLK, 
                int8_t _RST, int8_t _MISO); 
Adafruit_HX8357(int8_t _CS, int8_t _DC, int8_t _RST = -1); 
</code></pre>

<p></p>

<pre><code>Adafruit_STMPE610(uint8_t cspin, uint8_t mosipin, uint8_t misopin, uint8_t clkpin); 
Adafruit_STMPE610(uint8_t cs); 
Adafruit_STMPE610(void); 
</code></pre>

<p>Your <code>Display</code> constructor is trying to call the second constructor of each class.  However, <code>Display</code> is passing <code>int</code> values where <code>int8_t</code> and <code>uint8_t</code> values are expected.  It sounds like maybe your compiler is not performing implicit conversions from <code>int</code> to <code>(u)int8_t</code>, so try using explicit conversions to force it:</p>

<pre><code>Display::Display(int displayCSPin, int displayDCPin, int touchCSPin, int newBacklightPin, int newRotation, int newBrightness)
    : Adafruit_HX8357((int8_t)displayCSPin, (int8_t)displayDCPin, -1),
      Adafruit_STMPE610((uint8_t)touchCSPin)
{
    //Initialize display
}
</code></pre>

<p>Otherwise, change you <code>Display</code> constructor parameters to use <code>int8_t</code> and <code>uint8_t</code> instead of <code>int</code>:</p>

<pre><code>Display::Display(int8_t displayCSPin, int8_t displayDCPin, uint8_t touchCSPin, int newBacklightPin, int newRotation, int newBrightness)
    : Adafruit_HX8357(displayCSPin, displayDCPin, -1),
      Adafruit_STMPE610(touchCSPin)
{
    //Initialize display
}
</code></pre>
",,36475331,5277
29259090,2,29258580,2015-03-25T14:54:30.240,1,,253056,,2015-03-25T14:54:30.240,,0,,"<p>In <code>Memory::ChangeServer</code> you are writing the pointer itself to EEPROM (i.e. the address), rather than the string that the pointer points to. One way to fix this would be:</p>

<pre><code>void Memory::ChangeServer(char *number_str)
{
    for (int i = 0; i &lt;= strlen(number_str); ++i)
    {
        EEPROM_writeAnything(70 + i, number_str[i]);
    }
    ReadAll();
}
</code></pre>
",,36524425,42
29287982,2,29287889,2015-03-26T20:15:47.783,0,,1359034,,2015-03-26T20:15:47.783,,0,,"<p>it seems like you want to use <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""nofollow"">chrono</a>:</p>

<pre><code>void loop()
{
    std::time_t start_time;
    std::time_t end_time;
    while(onLine)
    {
        //on the line
        if (alreadyPassedLine)
        {
            //2nd time robot hit line
            end_time = std::chrono::system_clock::now();
        }
        if (!alreadyPassedLine)
        {
            //1st line
            start_time = std::chrono::system_clock::now();
        }
    }
    std::time_t total_time = end_time - start_time;
}
</code></pre>
",,36529100,582
29310574,2,29310161,2015-03-27T21:34:16.150,3,,4142924,,2015-03-27T21:34:16.150,,6,,"<p>You can use an array of function pointers. Be careful to index it by a positive value - a <code>char</code>  might be signed. Whether this is any more tedious than using a <code>switch</code> statement is arguable - but execution will certainly be quicker.</p>

<pre><code>#include &lt;stdio.h&gt;

// prototypes
int func00(void);
int func01(void);
...
int funcFF(void);

// array of function pointers
int (*funcarry[256])(void) = {
    func00, func01, ..., funcFF
};

// call one function
int main(void){
    unsigned char switchstate = 0x01;
    int res = (*funcarry[switchstate])();
    printf (""Function returned %02X\n"", res);
    return 0;
}

// the functions
int func00(void) {
    return 0x00;
}
int func01(void) {
    return 0x01;
}
...
int funcFF(void) {
    return 0xFF;
}
</code></pre>
",,36531137,57
48268278,2,29312239,2018-01-15T17:53:19.813,1,,3804422,,2018-01-15T17:53:19.813,,1,,"<p>Serial works though you disabled Timer 0. This simple experiment concludes that.</p>

<pre><code>#include ""avr/pgmspace.h""
#include ""avr/io.h""

#define cbi(sfr, bit) (_SFR_BYTE(sfr) &amp;= ~_BV(bit))
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))


void setup() {
  Serial.begin(9600);
  cbi (TIMSK0, TOIE0); // disable Timer0 !!! delay() is now not available
}

void loop() {
  if (Serial.available()){
    Serial.write(Serial.read());
  }
  delay(1000);              // this is not working since Timer 0 disabled
}
</code></pre>
",,36548206,81
29358312,2,29323602,2015-03-30T23:51:58.407,1,,4592033,,2015-03-31T02:20:52.507,2015-03-31T02:20:52.507,1,,"<p>First you should know the length of the number, and subtract 48 (48 is the ascii representation of 0) later multiply the number for 1, 10, 100, 1000, 10000, ... depending of the position of each number.</p>

<p>For example: String ""233"" to integer, using custom method</p>

<pre><code>void setup() {
  Serial.begin(9600);

}

void loop() {
  String Numero1 = ""40"";
String Numero2 = ""50"";
double Suma = StringAInt(Numero1)+StringAInt(Numero2);//+ StringAInt(Numero2);
Serial.println(Suma);



}



double StringAInt(String Dato)
{
String Numero = Dato;
char Valores [Numero.length()+1];
Numero.toCharArray(Valores,Numero.length()+1);
double NumeroEnt = 0;

for(int i = 0; i&lt;Numero.length(); i++)
{
    int NumValores = Valores[i];
    NumValores-=48;
    double MultPor = pow(10,Numero.length()-(i+1));
    NumeroEnt += (NumValores*MultPor);
    //Serial.println(NumValores*MultPor);
}
return NumeroEnt;
}
</code></pre>

<p>Now you only need build a string with the data received from serial port, and you can do math simply.</p>
",,36560828,232
29340767,2,29340672,2015-03-30T07:40:17.123,1,,4185106,,2015-03-30T07:40:17.123,,1,,"<p>You can use the <code>system()</code> command to use those commands you described.</p>

<pre><code>int main(){

   //some code before disable hdmi
   system(""tvservice -o"");

   //do somethings when HDMI is disabled

   //turn HDMI back on
   system(""tvservice -p"");
   system(""fbset -depth 8 &amp;&amp; fbset -depth 16"");

   return 0;

}
</code></pre>
",,36571454,864
29341799,2,29340672,2015-03-30T08:44:05.937,5,,193892,,2015-03-31T09:42:37.810,2015-03-31T09:42:37.810,2,,"<p>If you want to go for pure C, look at the source code for <code>tvservice</code>, which is a C program. It can be found <a href=""https://github.com/raspberrypi/userland/blob/master/host_applications/linux/apps/tvservice/tvservice.c"" rel=""nofollow"">at github</a>. It appears to be using the <code>vc_tv_hdmi_power_on_preferred();</code> function defined in <code>#include ""interface/vmcs_host/vc_tvservice.h""</code></p>

<p>If you decide to call the <code>tvservice</code> program like in @moffeltje's answer, you could use the <code>execl()</code> it's a little safer - you have to give full path to the binary. (With execlp you can also have control over environment variables):</p>

<pre><code>pid_t pid;


pid = fork();
if (0 == pid) {
    execl(""/opt/vc/bin/tvservice"", ""-p"", NULL);
}
if (-1 == pid) {
    // Handle error here, close program?
}
</code></pre>
",,36577523,1775
29406669,2,29341664,2015-04-02T06:46:02.173,1,,4728813,,2015-04-02T06:46:02.173,,0,,"<p>This binary math and bitwise manipulation is new to me, but I'm beginning to understand.  I implemented a Direct Digital Synthesis (DDS) example in Matlab.  Code below for others.  May also run on Octave.</p>

<pre><code>% INPUT PARAMETERS
%-----------------------
fs    = 2^14;   % Clock Sample Rate (hz)
NT    = 1e4;    % Total Samples for example 
foutd = 80;     % Desired Output Freq. (hz)
N     = 16;     % Accumulator resolution (bits)
P     = 12;     % Lookup Table resolution (bits)


% FREQUENCY TUNING WORD
%------------------------------
FTWf = foutd/fs*2^N;          % float
FTW  = round(foutd/fs*2^N);   % actual integer term for accumulator
fout = FTW*fs/2^N;            % actual output frequency


% SINE WAVE LOOKUP TABLE
%---------------------------
x = [0:2^P-1]';
y = sin(x*2*pi / (2^P-1) );


% INITIALIZE
%--------------------------
dt    = 1/fs;                % Time Step (sec)
t     = [0:dt:dt*(NT-1)]';   % Time Vector
phase = zeros(NT,1);         % Save phase vs. time
wave  = zeros(NT,1);         % Save wave amplitude vs. time


% SAMPLE THROUGH TIME
%-----------------------
pa = 0;   % Phase accumulator

for ii=1:length(t)

    % ACCUMULATE PHASE
    pa = pa + FTW;

    % ROLLOVER PHASE
    if pa &gt; 2^N
        pa = 1;
    end 

    % PHASE TRUNCATION
    indx = ceil(pa * 2^(P-N));

    % LOOKUP
    phase(ii) = pa;
    wave(ii)  = y( indx );

end

figure;
subplot(211),  plot(t, phase); grid on;
subplot(212),  plot(t, wave);  grid on; hold on
               plot(t,sin(foutd*2*pi*t), 'r-.');
</code></pre>

<p>My next step is to implement this on the ArduinoDue.  This algorithm will be the basis of the ISR interrupt function.  I will definitely use binary operators to speed up the division (i.e., ""Phase Truncation"").  </p>

<p>After that, I need to figure out how to handle non-integer frequency inputs.</p>
",,36589009,155
29348491,2,29348094,2015-03-30T14:12:24.803,2,,1073171,,2015-03-30T14:12:24.803,,0,,"<p>In order to detect a keypress change, you need to detect the button state change event. In which case you need to keep track of the previous button state:</p>

<pre><code>void loop() {

    static int firstPrevious = LOW;
    static int secondPrevious = LOW;

    int first = digitalRead(firstButton);
    int second = digitalRead(secondButton);

    if((first == HIGH) &amp;&amp; (firstPrevious == LOW)) {
        digitalWrite(firstLed, HIGH);
        Serial.println(""First button pressed"");
        delay(250);
    }

    if((second == HIGH) &amp;&amp; (secondPrevious == LOW)) {
        digitalWrite(secondLed, HIGH);
        Serial.println(""Second button pressed"");
        delay(250);
    }

    firstPrevious = first;
    secondPrevious = second;
}
</code></pre>

<p>After this, you'll want to look into switch ""de-bounce"" so you don't get multiple events for each keypress...</p>
",,36589454,347
29395667,2,29394934,2015-04-01T16:09:29.813,0,,4690503,,2015-04-01T16:09:29.813,,0,,"<p>I suppose you are using the QSerialPort class from QT.</p>

<p>As you can see from the documentation (<a href=""http://doc.qt.io/qt-5/qserialport-members.html"" rel=""nofollow"">http://doc.qt.io/qt-5/qserialport-members.html</a>), you have three functions overloading the write(...), from the super class</p>

<pre><code>write(const char *, qint64) : qint64
write(const char *) : qint64
write(const QByteArray &amp;) : qint64
</code></pre>

<p>What you are actually sending with <code>""'0'""</code> is actually a string composed by three characters, two single quotes and the number zero.</p>

<p>If you'd like to send more than one character, you have to pack all the characters into a QByteArray.</p>

<p>You'll have to call serial.write() in the following way</p>

<pre><code>QByteArray ba;
ba.append('1')
ba.append('2')
ba.append('3')
etc...
serial.write(ba)
</code></pre>

<p>In this way you send data composed by three bytes { '1', '2', '3' }</p>
",,36589676,96
29500687,2,29437068,2015-04-07T20:27:09.730,0,,3443596,,2015-04-07T20:27:09.730,,0,,"<p>To solve the error ""RX not declared in this scope"", you should declare your variables</p>

<pre><code>int RX_PIN= 0;    
int TX_PIN= 1;
</code></pre>

<p>before using them here</p>

<pre><code>SoftwareSerial bluetooth(RX_PIN,TX_PIN);
</code></pre>

<p>result:</p>

<pre><code>/*some lines here*/

Servo servo_1;    
Servo servo_2;    
Servo servo_3;    
Servo servo_4;    
Servo servo_5;    
Servo servo_6;    

int RX_PIN= 0;   
int TX_PIN= 1;
SoftwareSerial bluetooth(RX_PIN,TX_PIN);

int motornumber;     
int pos=0;

/*code continues here*/
</code></pre>

<p>For the ""duplicate case value"" error, you should indent your code correctly, and you might be able to see duplicate cases.</p>
",,36595115,462
29460225,2,29460115,2015-04-05T17:38:18.483,4,,4593267,,2015-04-05T18:01:44.257,2015-04-05T18:01:44.257,2,,"<p><code>int</code> seems to be only 16 bit wide on your target machine.
<code>1</code> is an <code>int</code>, therefore shifting it by more than 15 bits invokes undefined behavour.  The solution is simple, you should use a <code>long</code> constant:</p>

<pre><code> unsigned long test = 1UL &lt;&lt; 20;
</code></pre>

<p>The language you write in is not exactly C, but this solution should still be correct.</p>

<p>Incidentally, <code>1 &lt;&lt; 40</code> invokes undefined behaviour if <code>int</code> is 32 bits.  Below is a simple test:</p>

<pre><code>#include &lt;stdio.h&gt;

int a = 1, b = 40;

int main() {
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
    printf(""%d &lt;&lt; %d = %d\n"", a, b, a &lt;&lt; b);
}
</code></pre>

<p>On OS/X with <code>clang</code>, I get this output:</p>

<pre><code>~/dev/stackoverflow &gt; make t42
clang -O3 -Wall -o t42 t42.c
t42.c:6:32: warning: shift count &gt;= width of type [-Wshift-count-overflow]
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
                               ^  ~~
t42.c:7:32: warning: shift count &gt;= width of type [-Wshift-count-overflow]
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
                               ^  ~~
t42.c:8:32: warning: shift count &gt;= width of type [-Wshift-count-overflow]
    printf(""1 &lt;&lt; 40 = %d\n"", 1 &lt;&lt; 40);
                               ^  ~~
3 warnings generated.
~/dev/stackoverflow &gt; ./t42
1 &lt;&lt; 40 = 1386850896
1 &lt;&lt; 40 = 256
1 &lt;&lt; 40 = 512
1 &lt;&lt; 40 = 256
~/dev/stackoverflow &gt; ./t42
1 &lt;&lt; 40 = 1477618256
1 &lt;&lt; 40 = 256
1 &lt;&lt; 40 = 512
1 &lt;&lt; 40 = 256
</code></pre>

<p><code>clang</code> warns the programmer about the problem and insists on generating undefined behaviour, with consistently inconsistent output.  Amazing isn't it?  A good example of why one should never ignore compiler warnings</p>
",,36631942,64
29476524,2,29476007,2015-04-06T17:45:27.860,0,,3704293,,2015-04-06T17:45:27.860,,1,,"<p>Why do you use the interrupt? I would suggest to use a simple state pattern by comparing the previous button state like in this <a href=""http://www.multiwingspan.co.uk/arduino.php?page=led4"" rel=""nofollow"">code example</a> from <a href=""http://www.multiwingspan.co.uk"" rel=""nofollow"">http://www.multiwingspan.co.uk</a></p>

<pre><code>int ledPin = 13;
int buttonPin = 3;
int lastButtonState = HIGH;
int ledState = HIGH;

void setup()
{
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT);
}

void loop()
{
  // read from the button pin
  int buttonState = digitalRead(buttonPin);
  // if the button is not in the same state as the last reading
  if (buttonState==LOW &amp;&amp; buttonState!=lastButtonState)
  {
    // change the LED state
    if (ledState==HIGH)
    {
      ledState = LOW;
    }
    else
    {
      ledState = HIGH;
    }
  }
  digitalWrite(ledPin, ledState);
  // store the current button state
  lastButtonState = buttonState;
  // add a delay to avoid multiple presses being registered
  delay(20);
}
</code></pre>
",,36646395,124
29539790,2,29539671,2015-04-09T13:24:57.207,3,,25324,,2015-04-09T14:24:37.583,2015-04-09T14:24:37.583,7,,"<p>Convert the <code>time_t</code> value to <code>struct tm</code> and then format appropriately</p>

<pre><code>char dt[20]; // space enough for DD/MM/YYYY HH:MM:SS and terminator
struct tm tm;
time_t current_time;

current_time = time(NULL);
tm = *localtime(&amp;current_time); // convert time_t to struct tm
strftime(dt, sizeof dt, ""%d/%m/%Y %H:%M:%S"", &amp;tm); // format

fprintf(currfd, ""%s %d %d\n"", dt, temp, humidity);
</code></pre>

<p>See the POSIX descriptions of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html"" rel=""nofollow""><code>localtime()</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html"" rel=""nofollow""><code>strftime()</code></a>.</p>
",,36650547,12197
29585761,2,29585748,2015-04-12T03:53:12.000,2,,4505712,,2015-04-12T16:34:40.067,2015-04-12T16:34:40.067,3,,"<p>You have this function, which starts with the wrong brace type.</p>

<pre><code>void WriteByte(uint8_t addr, uint8_t reg, byte data)
} // Remove this, it's wrong
{ // Opening brace
    ... the rest of your code ...
} // Closing brace
} // Another closing brace, but I don't know why (I'd just remove it too)
</code></pre>

<p>You should have.</p>

<pre><code>void WriteByte(uint8_t addr, uint8_t reg, byte data)
{ // Opening brace
    ... the rest of your code ...
} // Closing brace
</code></pre>
",,36651114,108
29593637,2,29589347,2015-04-12T19:24:12.127,0,,4771355,,2015-04-12T19:24:12.127,,0,,"<p>As said before, <code>b1 = LOW</code> is an assignment that always return true. To avoid this common mistake, that can even be a typo, you can use <a href=""http://en.wikipedia.org/wiki/Yoda_conditions"" rel=""nofollow"">Yoda conditions</a>, that is, put the value and then the variable.</p>

<pre><code>if (LOW == b1)
</code></pre>

<p>Then, if you miss one <code>=</code> sign, you will have a compiling error and detect that mistake.</p>

<p>About bouncing, you can use a short delay to avoid it.</p>

<pre><code>if (LOW == b1)
{
    delay(5);
    sspeed += 0.01;
}
</code></pre>
",,36652840,50
29599913,2,29599484,2015-04-13T07:25:37.403,1,,3423234,,2015-04-13T11:54:07.690,2015-04-13T11:54:07.690,7,,"<p>You are almost there.</p>

<p>Your menu data structure is an array of <code>struct MenuT</code> items. The function prototype for your <code>Menu()</code> function is then</p>

<pre><code>int Menu(struct MenuT menu[])
{
    ...
}
</code></pre>

<p>(You probably might want to add a second parameter to have the number of valid elements in the array available within your function).</p>

<p>There are still (kindly spoken) some inconsistencies left in your code for you to fix (functions called before declaration, for example) and some - ummh - ugly parts (function pointers and data on the same structure member using voids, this is what unions are meant for), but I guess you can fix that on your own.</p>

<p>[edit: added this as requirements where made more clear with additional comments]</p>

<p>if you need to have more than a single menu, you can set up your data structure as follows:</p>

<pre><code>struct MenuT {
    int num_items;           /* number of items in mline-array */
    menu_item_type *mline;
};

struct menu_item_type main_menu_items[] = {
    { 1,2,0, ""STOP TIMER....% 5.1i MIN""  ,0, (void *) 85,0,0 },
    { 1,2,1, ""CHEM RATE....% 5.2f Lt/Hr"" ,1, (void *) DemoData,0,0 },
    { 1,2,0, ""CHEM PUMP.... %s""          ,0, (void *) ""ON/OFF"",0,0 },
};

struct menu_item_type other_menu_items[] = {
    { .... },
};
struct MenuT main_menu = {
    3,
    main_menu_items
};

struct MenuT other_menu = {
    2,
    other_menu_items
};
</code></pre>

<p>referencing the items in <code>Menu()</code> would then just become</p>

<pre><code>int Menu(struct MenuT *menu) {
    for (int i = 0; i &lt; menu-&gt;num_items; i++) {
        Serial.println(menu-&gt;items[i].mtext);
    }
}
</code></pre>

<p>when called from <code>main()</code> like</p>

<pre><code>Menu(&amp;main_menu);
Menu(&amp;other_menu);
</code></pre>
",,36690492,2824
29608470,2,29599484,2015-04-13T14:54:42.750,0,,1233840,,2015-04-13T14:54:42.750,,2,,"<p>Not the answer yet, but, most of the problems fixed now.
What remains - is how I use unions, or if not using unions, how I initiate the call to the function that returns the data. This, is seems, is not it:-</p>

<pre><code>long myint=(*(mymenu[i].mdata1))(); 
</code></pre>

<p>Here's the code - search for ""// Help""</p>

<pre><code>// Example for doing Menus for JB

#define MAX_MENU_LINES 3  // How many lines are on each of your menu screens

// This is unused - I think it's imposible to static-init using these?
union multi_data {
  int d_int;             // mdatatype 0
  void *d_function;      // 1
  float d_float;         // 2
};

// This is the definition of each line in a menu
typedef struct menu_item_def {
  byte x; byte y;        // Coordinates of the start for the line of test
  byte selected;         // set to 1 if the menu buttons have this option selected
  char *mtext;           // What to say, including sprintf placeholders:  eg: ""STOP TIMER...% 4.2i MIN""

  byte mdatatype1;       // 0 means this is actual data to print.  1 means go call the supplied function to get the data when needed.
  void *mdata1;          // Where to get any data from for the menu (upto 2 different bits allowed per line)

  byte mdatatype2;
  void *mdata2;

} menu_item_type;

// All menus are a collection of lines (exactly MAX_MENU_LINES (3 in this example) of them to be exact)
struct menu_item_def main_menu_items[MAX_MENU_LINES] = {
    { 1,2,0, ""STOP TIMER....% 5.1i MIN""  ,0, (void *)85,0,0 },
    { 1,2,1, ""CHEM RATE....% 5.2f Lt/Hr"" ,1, (void *)DemoData,0,0 },
    { 1,2,0, ""CHEM PUMP.... %s""          ,0, (void *)""ON/OFF"",0,0 },
};

struct menu_item_def sub_menu_items[MAX_MENU_LINES] = {
  {1,2,0, ""MOTOR RPM.....% 5.1i RPM""  ,0,(void *)8500,0,0},
  {1,2,1, ""ALARM MAX....% 5.2f Lt/Hr"" ,0,(void *)85,0,0},
  {1,2,0, ""ALARM MIN.... %s""          ,0,(void *)""ON/OFF"",0,0},
};


#define MAX_WIDTH 256   // This is the max width of anything you need to print - increase this if your LCD is wider
char buf[MAX_WIDTH];
char *p(char *fmt, ... ){  // Helper routine for putting numbers/readings/etc into printable strings
   va_list args; va_start (args, fmt );
   vsnprintf(buf, MAX_WIDTH, fmt, args);
   va_end (args);
   return buf;
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600); // I have no LCD, so, my output is to serial (Hit Ctrl+Shit+M or go Tools-&gt;Serial Monitor to see output). Note: Seral-Monitor will reset board.
  Menu(main_menu_items);
  Menu(sub_menu_items);
}

void loop() {
  // put your main code here, to run repeatedly:
  // Does nothing - the setup outputted the menu already
}

int Menu( struct menu_item_def *mymenu ) {
  for(int i=0;i&lt;MAX_MENU_LINES;i++) {
    if(mymenu[i].mdatatype1==0) { // an int
      long myint=(long)mymenu[i].mdata1;
      Serial.println(p(mymenu[i].mtext,42));
    } else {
      long myint=(*(mymenu[i].mdata1))(); // Help - gives: ""JB_Menus.ino:67:37: error: 'void*' is not a pointer-to-object type""
      Serial.println(p(mymenu[i].mtext,myint));
    }
  };
   Serial.print(p(""STOP TIMER...% 4.2i MIN"",5));
   MenuLine(5,6);
}


int MenuLine(int x, int y) {
   Serial.print(x);
}

int DemoData() {
  return 86;
}
</code></pre>
",,36699535,878
29677765,2,29599484,2015-04-16T14:28:18.290,0,,1233840,,2015-04-16T14:28:18.290,,0,,"<p>Here's how I ended up doing it.  Thanks to everyone who supplied the clues I needed!!!</p>

<p>Best I can tell - Macros must be used - it is impossible any other way owing to the architecture of the chip and the necessity to use PROGMEM.</p>

<p>Be warned: there are all kinds of size and line-end limits and bugs in arduino: if you're using this, compile often and frequently - it's impossible to debug macro errors, so you must not allow mistakes to creep in.</p>

<p>For any of you scratching your head: PROGMEM lets you put some stuff in FLASH (which you've got lots of) instead of storing it in SRAM (which is severely limited).  When you run out of space using arduino variables, you need to do this stuff.</p>

<pre><code>#include &lt;avr/pgmspace.h&gt;  // This lets us store static variables in FLASH instead of SRAM

#define MAX_MENU_WIDTH 64  // Max number of characters on a single menu line, PLUS 1
#define SERIAL_RATE 115200 // The BAUD rate of the serial port


// This is the definition of each line in a menu.  Each line uses 14 bytes of SRAM
typedef struct menu_item_def {
  byte x; byte y;        // Coordinates of the start for the line of test
  byte selected;         // set to 1 if the menu buttons have this option selected
  byte mdatatype1;       // This number explains how to use the following 2 mdata* as output when needed:
  char *mtext;           // What to say, including sprintf placeholders:  eg: ""STOP TIMER...% 4.2i MIN""
  void *mdata1;          // Refer to the ""int Menu()"" function for details.
  void *mdata2;
  void *mdata3;
  void *mdata4;
} menu_item_type;


#define Pv(a,b) a ## _ ## b
#define Ev(a,b) Pv(a,b)
// The following macro makes menu definitions easy-to-type, and stores menu text in (unchangeable) FLASH and menu data in (precious but small) SRAM
// These numbers should range from 1 to MAX_MENU_LINES.  Best not to edit these, or add more than 12: they're already at the absolute max size that an arduino macro can be.

#define FLASH_PART(n, m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11) \
                     const char Ev(n,0)[] PROGMEM=m0; \
                     const char Ev(n,1)[] PROGMEM=m1; \
                     const char Ev(n,2)[] PROGMEM=m2; \
                     const char Ev(n,3)[] PROGMEM=m3; \
                     const char Ev(n,4)[] PROGMEM=m4; \
                     const char Ev(n,5)[] PROGMEM=m5; \
                     const char Ev(n,6)[] PROGMEM=m6; \
                     const char Ev(n,7)[] PROGMEM=m7; \
                     const char Ev(n,8)[] PROGMEM=m8; \
                     const char Ev(n,9)[] PROGMEM=m9; \
                     const char Ev(n,10)[] PROGMEM=m10; \
                     const char Ev(n,11)[] PROGMEM=m11; 


#define MAX_MENU_LINES 12   // How many lines are on each of your menu screens

#define MAKE_MENU(n, x0,y0,s0,m0,t0,f0,d0,z0,q0, x1,y1,s1,m1,t1,f1,d1,z1,q1, x2,y2,s2,m2,t2,f2,d2,z2,q2, x3,y3,s3,m3,t3,f3,d3,z3,q3, x4,y4,s4,m4,t4,f4,d4,z4,q4, x5,y5,s5,m5,t5,f5,d5,z5,q5, x6,y6,s6,m6,t6,f6,d6,z6,q6, x7,y7,s7,m7,t7,f7,d7,z7,q7, x8,y8,s8,m8,t8,f8,d8,z8,q8, x9,y9,s9,m9,t9,f9,d9,z9,q9, x10,y10,s10,m10,t10,f10,d10,z10,q10, x11,y11,s11,m11,t11,f11,d11,z11,q11) \
FLASH_PART(n, m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11) \
struct menu_item_def n[MAX_MENU_LINES] = { {x0,y0,s0,t0,(char *)Ev(n,0),f0,d0,z0,q0},{x1,y1,s1,t1,(char *)Ev(n,1),f1,d1,z1,q1},{x2,y2,s2,t2,(char *)Ev(n,2),f2,d2,z2,q2},{x3,y3,s3,t3,(char *)Ev(n,3),f3,d3,z3,q3},{x4,y4,s4,t4,(char *)Ev(n,4),f4,d4,z4,q4},{x5,y5,s5,t5,(char *)Ev(n,5),f5,d5,z5,q5},{x6,y6,s6,t6,(char *)Ev(n,6),f6,d6,z6,q6},{x7,y7,s7,t7,(char *)Ev(n,7),f7,d7,z7,q7},{x8,y8,s8,t8,(char *)Ev(n,8),f8,d8,z8,q8},{x9,y9,s9,t9,(char *)Ev(n,9),f9,d9,z9,q9},{x10,y10,s10,t10,(char *)Ev(n,10),f10,d10,z10,q10},{x11,y11,s11,t11,(char *)Ev(n,11),f11,d11,z11,q11}, };

//FINALLY - Here is the ""readable"" way to initialize the structures (all the 7,8,9 stuff are placeholders for future expansion):
MAKE_MENU (main_menu_items,
     1,1,1, ""STOP TIMER.....% 5.1i MIN""     ,0, (void *)83,          (void *)7, (void *)8, (void *)9,
     1,2,1,  ""CHEM ON/OFF....%s""            ,2, (void *)""ON/OFF"",    (void *)7, (void *)8, (void *)9,
     1,3,0,  ""MOTOR RPM......% s RPM""       ,1, (void *)ReadRPM,     (void *)7, (void *)8, (void *)9,
     1,4,1,  ""TOT CHEM RATE..% 5.2i L/Hr""   ,1, (void *)DemoData,    (void *)7, (void *)8, (void *)9,
     1,5,0,  ""TOT CHEM USED..% 5.2i L/Hr""   ,1, (void *)DemoData,    (void *)7, (void *)8, (void *)9,
     1,6,1,  ""CHEM 1 RATE....% 23.6i L/Hr""  ,0, (void *)83,          (void *)7, (void *)8, (void *)9,
     1,7,1,  ""CHEM 2 RATE....% 16.3i L/Hr""  ,0, (void *)84,          (void *)7, (void *)8, (void *)9,
     1,8,1,  ""CHEM 3 RATE....% 34.9i L/Hr""  ,0, (void *)85,          (void *)7, (void *)8, (void *)9,
     1,9,0,  ""PH READ........% s PH""        ,1, (void *)ReadpHVolts, (void *)7, (void *)8, (void *)9,
     1,10,1, ""PH: Min: %f Max: %f""          ,1, (void *)ReadpHMin,   (void *)7, (void *)ReadpHMax, (void *)9,
     1,11,0, ""BATT VOLTS.....% s V""         ,1, (void *)ReadBatt,    (void *)7, (void *)8, (void *)9,
     1,12,0, ""Msg:%s""                       ,1, (void *)DemoData,    (void *)7, (void *)8, (void *)9
  );
</code></pre>

<p>To USE that stuff, I'm simply doing this for simple datatypes:</p>

<pre><code>long myval=(long)mymenu[i].mdata1;
</code></pre>

<p>And this to call my functions:</p>

<pre><code>long myval=(*reinterpret_cast&lt;long (*)()&gt;(mymenu[i].mdata1))();
</code></pre>
",,36701979,114
29629950,2,29602698,2015-04-14T14:24:51.353,17,,1836314,,2015-04-17T10:17:02.567,2015-04-17T10:17:02.567,11,,"<p>Three things:</p>

<ol>
<li>As you're developing your own client and server components, I suggest you to use Modbus only if strictly required or convenient with an eye to openness (i.e. other manufacturers must be able to communicate with your client or server components by means of a standardized protocol - and Modbus fits).</li>
<li>Be aware that Modbus TCP isn't just Modbus RTU(/ASCII) over TCP/IP (which is still allowed, of course, also UDP would be allowed). There are some important differences to take into account.</li>
<li>I understand that you need to understand Modbus at a deeper level. At that point, once you have an open serial channel or (listening) TCP socket inside your C program, you may just start with simple Modbus requests/responses.</li>
</ol>

<p>Take a look at this <a href=""http://www.simplymodbus.ca/FAQ.htm"" rel=""noreferrer"">short but quite complete description</a>, and also at the documentation of this <a href=""http://libmodbus.org/"" rel=""noreferrer"">constantly updated library</a>.</p>

<hr>

<p>Here's a super-simplified RTU example for Linux, based on <a href=""http://libmodbus.org/"" rel=""noreferrer"">libmodbus</a>.<br>
Allow me some C99 relaxation for compactness.<br>
In the real world you should also properly handle signals like SIGTERM, etc...<br>
There's also a <code>modbus_rtu_set_serial_mode</code> (RS232 vs RS485) function for Linux kernels 2.6.28 onwards. You may find other libraries that make working with RS485 easier on your platform.</p>

<h2>Master snippet</h2>

<pre><code>//Create a new RTU context with proper serial parameters (in this example,
//device name /dev/ttyS0, baud rate 9600, no parity bit, 8 data bits, 1 stop bit)
modbus_t *ctx = modbus_new_rtu(""/dev/ttyS0"", 9600, 'N', 8, 1);
if (!ctx) {
    fprintf(stderr, ""Failed to create the context: %s\n"", modbus_strerror(errno));
    exit(1);
}

if (modbus_connect(ctx) == -1) {
    fprintf(stderr, ""Unable to connect: %s\n"", modbus_strerror(errno));
    modbus_free(ctx);
    exit(1);
}

//Set the Modbus address of the remote slave (to 3)
modbus_set_slave(ctx, 3);


uint16_t reg[5];// will store read registers values

//Read 5 holding registers starting from address 10
int num = modbus_read_registers(ctx, 10, 5, reg);
if (num != 5) {// number of read registers is not the one expected
    fprintf(stderr, ""Failed to read: %s\n"", modbus_strerror(errno));
}

modbus_close(ctx);
modbus_free(ctx);
</code></pre>

<h2>Slave snippet</h2>

<pre><code>//Prepare a Modbus mapping with 30 holding registers
//(plus no output coil, one input coil and two input registers)
//This will also automatically set the value of each register to 0
modbus_mapping_t *mapping = modbus_mapping_new(0, 1, 30, 2);
if (!mapping) {
    fprintf(stderr, ""Failed to allocate the mapping: %s\n"", modbus_strerror(errno));
    exit(1);
}


//Example: set register 12 to integer value 623
mapping-&gt;tab_registers[12] = 623;


modbus_t *ctx = modbus_new_rtu(""/dev/ttyS0"", 9600, 'N', 8, 1);
if (!ctx) {
    fprintf(stderr, ""Failed to create the context: %s\n"", modbus_strerror(errno));
    exit(1);
}

//Set the Modbus address of this slave (to 3)
modbus_set_slave(ctx, 3);


if (modbus_connect(ctx) == -1) {
    fprintf(stderr, ""Unable to connect: %s\n"", modbus_strerror(errno));
    modbus_free(ctx);
    exit(1);
}


uint8_t req[MODBUS_RTU_MAX_ADU_LENGTH];// request buffer
int len;// length of the request/response

while(1) {
    len = modbus_receive(ctx, req);
    if (len == -1) break;

    len = modbus_reply(ctx, req, len, mapping);
    if (len == -1) break;
}
printf(""Exit the loop: %s\n"", modbus_strerror(errno));

modbus_mapping_free(mapping);
modbus_close(ctx);
modbus_free(ctx);
</code></pre>
",,36703831,236
29604168,2,29603977,2015-04-13T11:26:47.783,2,,496161,,2015-04-13T11:26:47.783,,4,,"<p>C++ can't map between run-time strings and compile-time variable names. You could use a <code>map</code> to do the mapping yourself. Something like this:</p>

<pre><code>std::map&lt;String, String&gt; varMap;
varMap[""A1""] = ""test"";
varMap[""A2""] = ""12:00"";
//...

lcd.print(varMap[cADP1]);
</code></pre>
",,36743680,219
29649192,2,29647887,2015-04-15T11:37:22.540,0,,1884780,,2015-04-15T11:37:22.540,,0,,"<p>About second question:</p>

<p><code>uint8_t</code>/<code>int8_t</code> is same as <code>unsigned</code>/<code>signed char</code> and <code>cout</code> will handli it as <code>char</code>. Use <code>static_cast&lt;int&gt;</code> to print as number.</p>

<p>About first quiestion:</p>

<p>I never worked with emac, but judging by <a href=""http://asf.atmel.com/docs/latest/sam3x/html/emac_quickstart.html"" rel=""nofollow"">this example</a> mac should be set this way:</p>

<pre><code>#define ETHERNET_CONF_ETHADDR0                        0x00
#define ETHERNET_CONF_ETHADDR0                        0x00
#define ETHERNET_CONF_ETHADDR1                        0x04
#define ETHERNET_CONF_ETHADDR2                        0x25
#define ETHERNET_CONF_ETHADDR3                        0x1C
#define ETHERNET_CONF_ETHADDR4                        0xA0
#define ETHERNET_CONF_ETHADDR5                        0x02

static uint8_t gs_uc_mac_address[] =
        { ETHERNET_CONF_ETHADDR0, ETHERNET_CONF_ETHADDR1, ETHERNET_CONF_ETHADDR2,
            ETHERNET_CONF_ETHADDR3, ETHERNET_CONF_ETHADDR4, ETHERNET_CONF_ETHADDR5
};

emac_options_t emac_option;
memcpy(emac_option.uc_mac_addr, gs_uc_mac_address, sizeof(gs_uc_mac_address));
emac_dev_init(EMAC, &amp;gs_emac_dev, &amp;emac_option);
</code></pre>
",,36812818,248
29652157,2,29648411,2015-04-15T13:53:08.903,1,,4142924,,2015-04-15T13:53:08.903,,7,,"<p>It <strong>does</strong> work when <code>e==1</code>. When <code>e==0</code> the computation is trivial, since <code>s</code> and <code>v</code> fall out due to power of 0 always being 1. This is the code copied and altered only enough to get it to compile.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;math.h&gt;

int random (int low, int high) {
    return low + rand() % (high - low);
}

int getGCD(int a, int b) {
    int c;
    while (a != 0)
    {
        c = a;
        a = b % a;
        b = c;
    }
    return b;
}

int getCoprime(int n) {
    int coprime;
    do
    {
        coprime = random(1, n);
    } 
    while (getGCD(n, coprime) != 1);
    return coprime;
}

int main(void) {
        int e, x, y, r, n, s, v, test, ysqmodn;

        srand((unsigned)time(NULL));
        n = 7 * 3;
        s = getCoprime(n);
        v = (s * s) % n;

        e = random(0, 2);
        r = random(1, n);

        printf(""n=%d, s=%d, e=%d, r=%d\n"", n,s,e,r);

        y = (r * (int)pow(s, e)) % n;
        x = (r * r) % n;

        ysqmodn = y * y % n;
        test = (x * (int)pow(v, e)) % n;

        if(ysqmodn == test)
            printf(""The current ICC matches. \n"");
        else
            printf(""%d\n"", e);

        return 0;
    }
</code></pre>

<p>Sample results:</p>

<pre><code>n=21, s=2, e=1, r=2
The current ICC matches.

n=21, s=11, e=0, r=12
The current ICC matches.

n=21, s=8, e=1, r=14
The current ICC matches.

n=21, s=17, e=1, r=13
The current ICC matches.

n=21, s=1, e=0, r=9
The current ICC matches.

n=21, s=4, e=0, r=13
The current ICC matches.
</code></pre>
",,36826078,2090
29663093,2,29662007,2015-04-16T00:04:55.070,0,,4605105,,2015-04-16T00:04:55.070,,0,,"<p>I have tried to split your code and factorized it. I don't have an Arduino build system I can't test my code.
I don't understand your mapping x, y, z to pin number I have tried one.</p>

<pre><code>/* Struct for global conf */
static struct {                                                                
    int ledBuffer[4][4][4];                                                    
    int ledXY[4][4];                                                           
    int ledZ[4];                                                               
} _G;                                                                          

void setup() {                                                                 
    _G.ledXY = {                                                               
        {22, 24, 26, 28} ,                                                     
        {30, 32, 34, 36},                                                      
        {23, 25, 27, 29},                                                      
        {31, 33, 35, 37}                                                       
    };                                                                         
    _G.ledZ = {38,40,42,44};                                                   

    //sets all used pins as output                                                  
    for(int i = 0; i &lt; 4; i++){                                                
        pinMode(_G.ledZ[i], OUTPUT);                                           
        for (int j = 0; j &lt; 4; j++) {                                          
            pinMode(_G.ledXY[i][j], OUTPUT);                                   
        }                                                                      
    }                                                                          
    allOn(); /* switch on all led*/                                                                   
    allOff(); /* switch off all led */                                                                  
}                                                                              

void loop() {                                                                  
    static int xSeed;                                                          
    static int ySeed;                                                          
    static int zSeed;                                                          

    _G.ledBuffer[xSeed][ySeed][zSeed] = 0;                                     

    if (zSeed == 0)                                                            
    {                                                                          
        xSeed = random(0, 3);                                                  
        ySeed = random(0, 3);                                                  
        zSeed = random(0, 3);                                                  
    } else {                                                                   
        zSeed--;                                                               
    }                                                                          
    _G.ledBuffer[xSeed][ySeed][zSeed] = 1;                                     

    doLight();                                                                 
} 

static void doLight();                                                         

    for (int step = 0; step &lt; 80; step++) { /* Perhaps use sleep instead */                                   
        allOff();                                                              
        for(int i = 0; i &lt; 4; i++){                                            
            for(int j = 0; j &lt; 4; j++){                                        
                for(int k = 0; i &lt; 4; i++){                                    
                    digitalSwitch(i, j, k, ledBuffer[i][j][k]);                
                }                                                              
            }                                                                  
        }                                                                      
    }                                                                          
}                                                                              

static void digitalSwitch(int x, int y, int z, int on) {
    /* convert x y z to the correct pin*/                       
    digitalWrite(_G.ledXY[x][y], _G.[ledZ[z]], on ? HIGH : LOW);               
}                                                                              


static void _all(int on) {                                                     
    for(int i = 0; i &lt; 4; i++){                                                
        for(int j = 0; j &lt; 4; j++){                                            
            for(int k = 0; i &lt; 4; i++){                                        
                digitalSwitch(i, j, k, on);                                    
            }                                                                  
        }                                                                      
    }                                                                          
}                                                                              
int allOff(){                                                                  
    _all(0);                                                                   
};                                                                             

int allOn(){                                                                   
    _all(1);                                                                   
};     
</code></pre>
",,36848295,48
29676843,2,29676802,2015-04-16T13:52:12.650,0,,1359034,,2015-04-16T14:03:02.967,2015-04-16T14:03:02.967,1,,"<p>You have a <code>Rectangle</code> as part of your <code>Image</code> class, and aren't constructing it in your initialization list, so it defaults to getting default constructed, and you don't have a default constructor.</p>

<p>You need to initialize your Rectangle with the one passed in inside the initialization list:</p>

<pre><code>Image(Rectangle s_bounds, String s1, String s2 = """", String s3 = """", String s4 = """", String s5 = """", String s6 = """", String s7 = """", String s8 = """", String s9 = """", String s10 = """")
 : bounds(s_bounds)
{
  images[0] = s1;
  images[1] = s2;
  images[2] = s3;
  images[3] = s4;
  images[4] = s5;
  images[5] = s6;
  images[6] = s7;
  images[7] = s8;
  images[8] = s9;
  images[9] = s10;

}
</code></pre>

<p>Your second problem seems to be because you are trying to write code in the global namespace, outside of a function, which isn't valid.  It compiled fine when I moved it to <code>main()</code>.</p>
",,36848967,55
29743561,2,29714733,2015-04-20T09:08:26.960,1,,784318,,2015-04-20T10:46:19.107,2017-05-23T11:50:41.617,0,,"<p>I am providing an own answer which should document my steps which will hopefully lead me to the desired end result:</p>

<h3>Download the sources</h3>

<pre><code>git clone https://gerrit-ring.savoirfairelinux.com/ring
cd ring
</code></pre>

<h3>Build the <code>contrib</code> section</h3>

<p>According to <a href=""https://stackoverflow.com/users/641095/aberaud"">@aberaud</a>'s <a href=""https://stackoverflow.com/a/29722221/784318"">remarks</a> I can update <code>contrib/src/libav/rules.mak</code> and remove any video-related dependencies (remember that I am headless):</p>

<p>So I changed line 70 form</p>

<pre><code>DEPS_libav = zlib x264 vpx $(DEPS_vpx)
</code></pre>

<p>to </p>

<pre><code>DEPS_libav = zlib opus speex
</code></pre>

<p>Now build the <code>contrib</code> section.</p>

<pre><code>cd ../contrib/
rm -fr native/ &amp;&amp; mkdir native
cd native
../bootstrap
make
</code></pre>
",,36871334,2142
29724875,2,29716979,2015-04-19T01:39:38.107,-1,,4771355,,2015-04-20T18:48:51.843,2015-04-20T18:48:51.843,11,,"<p>The function <code>millis()</code> will fail when the value overflows. As @CPU_Terminator said, use interrupts. There are useful Arduino libraries for that, for example <a href=""http://playground.arduino.cc/code/timer1"" rel=""nofollow"">Timer1</a>.</p>

<p><strong>EDIT</strong>. Assuming that what you want to do is send an SMS each 100ms if some of your inputs changed, you can use a code like this (I removed some delays that doesn't seem necesary to me, add them again if I'm wrong):</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
#include ""TimerOne.h""

const int DI = 2;
const int DT = 3;
const int DGP1 = 4;
const int DGP2 = 5;
const long interval = 100000; // in microseconds

int value1 = 0;
int value2 = 0;
int value3 = 0;
int value4 = 0;
int value1_old = 0;
int value2_old = 0;
int value3_old = 0;
int value4_old = 0;
boolean changed1 = false;
boolean changed2 = false;
boolean changed3 = false;
boolean changed4 = false;

SoftwareSerial SIM900 (7, 8);

void SIM900power(){
  digitalWrite(9, HIGH);
  delay(1000);
  digitalWrite(9, LOW);
  delay(5000);
}

void initia(){
  SIM900.print(""AT+CMGF=1\r"");
  SIM900.println(""AT + CMGS = \""+212xxxxxxx\"""");
}

void Send_SMS(){
  SIM900.println((char)26);
  SIM900.println();
  delay(20);
  SIM900power();
}

void isr_timer(){
  if (changed2) {
    initia();
    SIM900.println(""Station 85: Defaut electrique"");
    Send_SMS();
    changed2 = false;
  }

  if (changed3) {
    initia();
    SIM900.println(""Station 85: DefautGP1"");
    Send_SMS();
    changed3 = false;
  }

  if (changed4) {
    initia();
    SIM900.println(""Station 85:DD&gt;1000"");
    Send_SMS();
    changed4 = false;
  }
}

void setup() {
  pinMode(DI, INPUT);
  pinMode(DT, INPUT);
  pinMode(DGP1, INPUT);
  pinMode(DGP2, INPUT);

  SIM900.begin(19200);
  SIM900power();
  delay(20000);
  Timer1.initialize(interval);
  Timer1.attachInterrupt(isr_timer);
}

void loop() {
  value1 = digitalRead (DI);
  value2 = digitalRead (DT);
  value3 = digitalRead (DGP1);
  value4 = digitalRead (DGP2);

  if (value1 != value1_old &amp;&amp; value1 == HIGH) changed1 = true;
  if (value2 != value2_old &amp;&amp; value2 == HIGH) changed2 = true;
  if (value3 != value3_old &amp;&amp; value3 == HIGH) changed3 = true;
  if (value4 != value4_old &amp;&amp; value4 == HIGH) changed4 = true;

  value1_old = value1;
  value2_old = value2;
  value3_old = value3;
  value4_old = value4;

  // Here the rest of your code
}
</code></pre>

<p>This way the function <code>isr_timer()</code> will be executed each 0.1 seconds.</p>
",,36913723,924
39851992,2,29716979,2016-10-04T12:12:04.277,-1,,6914800,,2016-10-04T12:12:04.277,,0,,"<p>You may try using the code in isr_timer() function:</p>

<pre><code>if (changed2) {
    initia();
    SIM900.println(""Station 85: Defaut electrique"");
    delay(100);
    Send_SMS();
    changed2 = false;
}
</code></pre>

<p>Best regards</p>
",,36960748,159
41487008,2,29716979,2017-01-05T14:01:41.893,1,,3368201,,2017-01-05T14:01:41.893,,0,,"<p>As mclopez pointed out, is better to provide a good answer rather than pointing out only what are the flaws of the other ones, so... Here we go.</p>

<p>In my opinion the ISR solution is not a good choice, because ISRs block the normal execution. The only feasible implementation using interrupts is to record the pin change and then send the SMSs.</p>

<p>This, however, is not a good solution in my opinion. For this problem, I'd go with a state machine to send the SMSs; since you have states, you can wait the transition while doing other things, like checking the buttons.</p>

<p>I do not know how SIM900 sends the SMS, so I'm taking your workflow and implementing it in a state machine. I'm not sure this is the optimal solution, particularly because I don't think you actually need to reboot the module each time, but you can trim it later.</p>

<p>Now, the workflow has seven actions you have to perform, each followed by a wait. I write it here so it's simpler to see every action:</p>

<pre><code>SIM900.print(""AT+CMGF=1\r"");
delay(100);
SIM900.println(""AT + CMGS = \""+212xxxxxxx\"""");
delay(100);  
SIM900.println(""Message you want"");
delay(100);  
SIM900.println((char)26);
delay(100);
SIM900.println();
delay(100);
digitalWrite(9 ,HIGH);
delay(1000);
digitalWrite(9 ,LOW);
delay(5000);
</code></pre>

<p>So we have eight states: an idle one (when you are waiting for the state machine to start, named SIM_IDLE), followed by five ""SEND"" states (I name them SIM_SEND1..5) and two states to reset the power (named SIM_POW1 and SIM_POW2). You are normally in idle state; when one or more buttons are pressed, you switch to the first send, cycle through them and then reset the power and go back to idle.</p>

<p>The pressed button changes only state SIM_SEND3 (when you actually send the message), so whenever a button press is detected a boolean variable is set (a button press is detected also during the state machine execution) and is reset only in that state, after the correct message is sent.</p>

<p>Now, here is the code which implements this:</p>

<pre><code>const uint8_t DI = 2;
const uint8_t DT = 3;
const uint8_t DGP1 = 4;
const uint8_t DGP2 = 5;

const uint8_t SIMPOW = 9;

uint8_t value1_old = 0;
uint8_t value2_old = 0;
uint8_t value3_old = 0;
uint8_t value4_old = 0;

boolean value1_changed = false;
boolean value2_changed = false;
boolean value3_changed = false;
boolean value4_changed = false;

/********************************/
//         SIM STATES
#define SIM_IDLE   0
//SEND1: SIM900.print(""AT+CMGF=1\r"");delay(100);
#define SIM_SEND1  1
//SEND2: SIM900.println(""AT + CMGS = \""+212xxxxxxx\"""");delay(100);
#define SIM_SEND2  2
//SEND3: SIM900.println(""Message you want"");delay(100);
#define SIM_SEND3  3
//SEND4: SIM900.println((char)26);delay(100);
#define SIM_SEND4  4
//SEND5: SIM900.println();delay(100);
#define SIM_SEND5  5
//POW1: digitalWrite(SIMPOW,HIGH);delay(1000);
#define SIM_POW1   6
//POW2: digitalWrite(SIMPOW,LOW);delay(5000);
#define SIM_POW2   7
/********************************/

unsigned long previousMillis;
uint8_t currentSimState;

#include&lt;SoftwareSerial.h&gt;
SoftwareSerial SIM900 (7, 8);

void setup()
{
    pinMode(DI, INPUT);
    pinMode(DT, INPUT);
    pinMode(DGP1, INPUT);
    pinMode(DGP2, INPUT);
    pinMode(SIMPOW, OUTPUT);

    SIM900.begin(19200);

    digitalWrite(SIMPOW,HIGH);
    delay(1000);
    digitalWrite(SIMPOW,LOW);
    delay(25000);
    currentSimState = -1; // Force a state transition
}

void loop()
{
    uint8_t value1 = digitalRead (DI);
    uint8_t value2 = digitalRead (DT);
    uint8_t value3 = digitalRead (DGP1);
    uint8_t value4 = digitalRead (DGP2);

    unsigned long currentMillis = millis();

    if (value2 != value2_old &amp;&amp; value2 == HIGH)
        value2_changed = true;
    if (value3 != value3_old &amp;&amp; value3 == HIGH)
        value3_changed = true;
    if (value4 != value4_old &amp;&amp; value4 == HIGH)
        value4_changed = true;

    value1_old = value1;
    value2_old = value2;
    value3_old = value3;
    value4_old = value4;

    // Check if a state transition is needed
    uint8_t newSimState = currentSimState;
    switch (currentSimState)
    {
    case SIM_IDLE: // Start sending if a value changed
        if ((value2_changed) || (value3_changed) || (value4_changed))
            newSimState = SIM_SEND1;
        break;
    case SIM_SEND1: // Wait 100 ms
        if ((currentMillis - previousMillis) &gt;= 100)
            newSimState = SIM_SEND2;
        break;
    case SIM_SEND2: // Wait 100 ms
        if ((currentMillis - previousMillis) &gt;= 100)
            newSimState = SIM_SEND3;
        break;
    case SIM_SEND3: // Wait 100 ms
        if ((currentMillis - previousMillis) &gt;= 100)
            newSimState = SIM_SEND4;
        break;
    case SIM_SEND4: // Wait 100 ms
        if ((currentMillis - previousMillis) &gt;= 100)
            newSimState = SIM_SEND5;
        break;
    case SIM_SEND5: // Wait 100 ms
        if ((currentMillis - previousMillis) &gt;= 100)
            newSimState = SIM_POW1;
        break;
    case SIM_POW1: // Wait 1000 ms
        if ((currentMillis - previousMillis) &gt;= 1000)
            newSimState = SIM_POW2;
        break;
    case SIM_POW2: // Wait 1000 ms
        if ((currentMillis - previousMillis) &gt;= 1000)
            newSimState = SIM_IDLE;
        break;
    default:
        newSimState = SIM_IDLE;
        break;
    }

    // If there was a transition, do the appropriate action
    if (newSimState != currentSimState)
    {
        case SIM_IDLE:
            // Do nothing
            break;
        case SIM_SEND1:
            SIM900.print(""AT+CMGF=1\r"");
            previousMillis = millis();
            break;
        case SIM_SEND2:
            SIM900.println(""AT + CMGS = \""+212xxxxxxx\"""");
            previousMillis = millis();
            break;
        case SIM_SEND3:
            if (value2_changed)
            {
                SIM900.println(""Station 85: Defaut electrique"");
                value2_changed = false;
            }
            else if (value3_changed)
            {
                SIM900.println(""Station 85: DefautGP1"");
                value2_changed = false;
            }
            else if (value4_changed)
            {
                SIM900.println(""Station 85:DD&gt;1000"");
                value2_changed = false;
            }
            else
            {
                // Should never arrive here. Just in case, you
                // can either abort the SMS sending if you can
                // or send another message
            }
            previousMillis = millis();
            break;
        case SIM_SEND4:
            SIM900.println((char)26);
            previousMillis = millis();
            break;
        case SIM_SEND5:
            SIM900.println();
            previousMillis = millis();
            break;
        case SIM_POW1:
            digitalWrite(SIMPOW,HIGH);
            previousMillis = millis();
            break;
        case SIM_POW2:
            digitalWrite(SIMPOW,LOW);
            previousMillis = millis();
            break;
        }
    }

    // Advance state
    currentSimState = newSimState;
}
</code></pre>

<p>It may look complicated, but it is indeed very simple. The loop is made by three ""blocks"".</p>

<p>The first one is the button check. If any button is pressed, the corresponding <code>valueX_changed</code> flag is set. This is a very trivial part, just check if any button has a different state and then set the flag.</p>

<p>The second part is the check for a state transition. In this switch statement the program determines if the state of the state machine needs to be changed. This happens when a button was pressed if the state was idle, or if a specified amount of time has passed if in the process of sending an SMS.</p>

<p>The third part is the action to be performed when a state changes. So if the state changed, do the state action, which means nothing for the idle state, send something for the SIM_SENDx states and change the pin for the SIM_POWx states.</p>

<p>Just a note: in the setup you added a 20 seconds delay not presend in the normal workflow. If you want to remove this, you can just remove the four lines from the setup performing the reset and modify the <code>default</code> case in the first switch to set <code>newSimState = SIM_POW1;</code> instead of <code>SIM_IDLE</code>.</p>

<p>There can be small bugs in this code, since I haven't tested it, but it should do what you wanted</p>
",,36961326,1375
29768648,2,29768115,2015-04-21T09:48:57.533,4,,898348,,2015-04-21T09:48:57.533,,0,,"<p>You have following instructions over 20 times:</p>

<pre><code>else if (strcmp(message_buff, ""AAAA"") == 0) {
                                kaKuTransmitter.sendSignal(B, C, D);
                                client.publish(""/arduino/status/"",""DDDD"");
                              }
</code></pre>

<p>with different values for AAAA, B, C, D, and DDDD</p>

<p>Make a table like this:</p>

<pre><code>struct
{
  const char *message1,
  char        signal,
  int         value1,
  bool        value2,
  const char *pubmessage
} table[] =
{
  {""A1ON"", 'A', 1, true,  ""Living1 aan""},
  {""A1OF"", 'A', 1, false, ""Living1 uit},
  {""A2ON"", 'A', 2, true,  ""Living2 aan},
  {""A2OF"", 'A', 2, false, ""Living2 uit},
  ....
} ;
</code></pre>

<p>In your callback function instead of calling 20 times <code>strcmp(...</code> scan that table and retrieve the values corresponding to the command string (""A1ON"" etc.).</p>

<pre><code>int index = FindCommandIndex(message_buff);
if (index != -1)
{
  kaKuTransmitter.sendSignal(table[index].signal,
                             table[index].value1,
                             table[index].value2)

  client.publish(""/arduino/status/"", table[index].pubmessage);
}

int FindCommandIndex(const char *message_buff)
{
   // Return the index in table containing the message_buff command.
   // Left as an exercise to the reader.
}
</code></pre>

<p>But this will probably not reduce your code that much because there is certainly much overhead coming from the libraries you use.</p>
",,36973568,284
29807186,2,29806609,2015-04-22T19:33:56.360,1,,168986,,2015-04-23T08:58:58.337,2015-04-23T08:58:58.337,2,,"<p>The named structure member initialisation in C99 is not implemented in C++.  In C++ you can perform member initialisation using a constructor.  E.g:</p>

<pre><code>struct sConfig 
{
    int m_x ;
    int m_y ;

    sConfig( int x, int y ) : m_x(x),
                              m_y(y)
    {}
} ;
</code></pre>

<p>Or:</p>

<pre><code>struct sConfig 
{
    int m_x ;
    int m_y ;

    sConfig( int x, int y )
    {
        m_x = x ;
        m_y = y ;
    }
} ;
</code></pre>

<p>or even a combination of the two methods.  Then you instantiate an object thus:</p>

<pre><code>sConfig myConfig( 10, 20 ) ;
</code></pre>

<p>Initialising <code>m_x</code> and <code>m_y</code> to 10 and 20 respectively in this example.</p>

<p>You can then of course only perform the initialisation provided by the structures defined constructors; but that is not necessarily a bad thing - letting the user arbitrarily decide which members to initialise is not particularly safe or maintainable.  You can of course define multiple constructors to perform different initialisations; you would normally want define a default constructor for example:</p>

<pre><code>struct sConfig 
{
    int m_x ;
    int m_y ;

    sConfig( int x, int y ) : m_x(x),
                              m_y(y)
    {}

    sConfig( ) : m_x(0),
                 m_y(0)
    {}
} ;
</code></pre>

<p>So that in this example:</p>

<pre><code>sConfig myConfig ;
</code></pre>

<p>is equivalent to all of the following:</p>

<pre><code>sConfig myConfig( 0, 0 ) ;
sConfig myConfig = { 0, 0 } ;
sConfig myConfig = {0} ;
</code></pre>
",,36981513,1079
29825323,2,29818894,2015-04-23T13:43:05.710,0,,2110465,,2015-04-23T21:50:22.970,2015-04-23T21:50:22.970,0,,"<p>Try slowing down the interval on the interrupt. It is possible that due to several <code>if</code> statements running under <code>isr_timer()</code>that the main loop <em>may</em> be locking up. I have a sneaking suspicion you are trying to do too much!</p>

<blockquote>
  <p>Be careful about trying to execute too complicated of an interrupt at too high of a frequency, or the CPU may never enter the main loop and your program will 'lock up'. <a href=""http://playground.arduino.cc/code/timer1"" rel=""nofollow"">Reference</a></p>
</blockquote>

<p>Saying that and to check that your main loop is actually running why not add a simple debug at the bottom of the main <code>loop()</code> to flash the on board led..</p>

<pre><code>int onBoardLED = 13;

void setup()
 {
    pinMode(onBoardLED, OUTPUT);

    // And all the rest
 } 

void loop()
 {
    // Doing stuff

    if (onBoardLED == LOW) digitalWrite(ledPin, HIGH);
    else digitalWrite(ledPin, LOW);
 }
</code></pre>

<p>At least then you will know if the main <code>loop()</code> is even actually executing.
It obviously runs once as you are getting a single SMS through but really with no other way of telling its a guess after that...</p>

<p>If all looks good try adding some further flags around the place just to see whats getting executed and what is not. Other than that suggestion i cant spot anything further but interested to find out! Best of luck</p>

<p><strong>Update</strong><br>
Just dug this link out of my bookmarks. You may find it useful.<br>
- <a href=""http://gammon.com.au/interrupts"" rel=""nofollow"">Nick Gammon - Interrupts</a></p>
",,36982362,77
29835538,2,29834066,2015-04-23T22:34:06.587,3,,1298153,,2015-04-23T22:34:06.587,,3,,"<p>I would try this:</p>

<pre><code>HttpClient client;
client.setHeader(""Authorization: Bearer &lt;access token here&gt;"");
client.addHeader();
client.setHeader(""Content-Type: application/json"");
client.addHeader();
client.post(""https://api.pushbullet.com/v2/pushes"", ""{\""type\"": \""note\"", \""title\"": \""Note Title\"", \""body\"": \""Note Body\""}""
</code></pre>

<p>I don't have a Yún to test with. Despite the post method <a href=""http://www.arduino.cc/en/Tutorial/HttpClient"" rel=""nofollow"">not</a> <a href=""http://www.arduino.cc/en/Reference/YunHttpClientConstructor"" rel=""nofollow"">being documented</a>, it <a href=""https://github.com/arduino/Arduino/blob/1.6.3/libraries/Bridge/src/HttpClient.cpp#L70"" rel=""nofollow"">does appear to exist</a>..</p>
",,37002058,286
31312839,2,29834066,2015-07-09T09:02:20.370,0,,5097659,,2015-07-09T09:02:20.370,,1,,"<p>In questo modo funziona :-):</p>

<pre><code>Process avviso;


if (!avviso.running())
  {
    avviso.begin(""curl"");
    avviso.addParameter(""-k"");
    avviso.addParameter(""-H"");
    avviso.addParameter(""Authorization: Bearer v1EhAXIVEhms05l97PTHkQFRNWiK5q6L6fujzny9qxWvc"");
    avviso.addParameter(""-X"");
    avviso.addParameter(""POST"");
    avviso.addParameter(""https://api.pushbullet.com/v2/pushes"");
    avviso.addParameter(""-H"");
    avviso.addParameter(""Content-Type:application/json"");
    avviso.addParameter(""--data-binary"");
    String titolo = ""Arduino"";
    avviso.addParameter(""{\""type\"": \""note\"", \""title\"": \""""+titolo+ ""\"", \""body\"": \""Note Body\""}"");
    avviso.run(); 
  }
</code></pre>
",,37013039,2119
40063032,2,29837892,2016-10-15T18:59:55.057,26,,895245,,2020-04-22T16:41:10.533,2020-04-22T16:41:10.533,0,,"<p><strong>Fully automated minimal bare metal blinker example</strong></p>

<p>Tested on Ubuntu 16.04 host, Raspberry Pi 2.</p>

<p><a href=""https://github.com/dwelch67/raspberrypi"" rel=""noreferrer"">https://github.com/dwelch67/raspberrypi</a> is the most comprehensive example set I've seen to date (previously mentioned on this <a href=""https://stackoverflow.com/a/29839456/895245"">now deleted answer</a>), but this is a minimal easy to setup hello world to get you started quickly.</p>

<p>Usage:</p>

<ol>
<li><p>Insert SD card on host</p></li>
<li><p>Make the image:</p>

<pre><code>./make.sh /dev/mmblck0 p1
</code></pre>

<p>Where:</p>

<ul>
<li><code>/dev/mmblck0</code> is the device of the SD card</li>
<li><code>p1</code> is the first partition of the device (<code>/dev/mmblck0p1</code>)</li>
</ul></li>
<li><p>Inset SD card on PI</p></li>
<li><p>Turn power off and on</p></li>
</ol>

<p><a href=""https://i.stack.imgur.com/hztMj.gif"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/hztMj.gif"" alt=""enter image description here""></a></p>

<p>GitHub upstream: <a href=""https://github.com/cirosantilli/raspberry-pi-bare-metal-blinker/tree/d20f0337189641824b3ad5e4a688aa91e13fd764"" rel=""noreferrer"">https://github.com/cirosantilli/raspberry-pi-bare-metal-blinker/tree/d20f0337189641824b3ad5e4a688aa91e13fd764</a></p>

<p>start.S</p>

<pre><code>.global _start
_start:
    mov sp, #0x8000
    bl main
hang:
    b hang
</code></pre>

<p>main.c</p>

<pre><code>#include &lt;stdint.h&gt;

/* This is bad. Anything remotely serious should use timers
 * provided by the board. But this makes the code simpler. */
#define BUSY_WAIT __asm__ __volatile__("""")
#define BUSY_WAIT_N 0x100000

int main( void ) {
    uint32_t i;
    /* At the low level, everything is done by writing to magic memory addresses.
    The device tree files (dtb / dts), which are provided by hardware vendors,
    tell the Linux kernel about those magic values. */
    volatile uint32_t * const GPFSEL4 = (uint32_t *)0x3F200010;
    volatile uint32_t * const GPFSEL3 = (uint32_t *)0x3F20000C;
    volatile uint32_t * const GPSET1  = (uint32_t *)0x3F200020;
    volatile uint32_t * const GPCLR1  = (uint32_t *)0x3F20002C;

    *GPFSEL4 = (*GPFSEL4 &amp; ~(7 &lt;&lt; 21)) | (1 &lt;&lt; 21);
    *GPFSEL3 = (*GPFSEL3 &amp; ~(7 &lt;&lt; 15)) | (1 &lt;&lt; 15);
    while (1) {
        *GPSET1 = 1 &lt;&lt; (47 - 32);
        *GPCLR1 = 1 &lt;&lt; (35 - 32);
        for (i = 0; i &lt; BUSY_WAIT_N; ++i) { BUSY_WAIT; }
        *GPCLR1 = 1 &lt;&lt; (47 - 32);
        *GPSET1 = 1 &lt;&lt; (35 - 32);
        for (i = 0; i &lt; BUSY_WAIT_N; ++i) { BUSY_WAIT; }
    }
}
</code></pre>

<p>ldscript</p>

<pre><code>MEMORY
{
    ram : ORIGIN = 0x8000, LENGTH = 0x10000
}

SECTIONS
{
    .text : { *(.text*) } &gt; ram
    .bss : { *(.bss*) } &gt; ram
}
</code></pre>

<p>make.sh</p>

<pre><code>#!/usr/bin/env bash

set -e

dev=""${1:-/dev/mmcblk0}""
part=""${2:-p1}""
part_dev=""${dev}${part}""
mnt='/mnt/rpi'

sudo apt-get install binutils-arm-none-eabi gcc-arm-none-eabi

# Generate kernel7.img
arm-none-eabi-as start.S -o start.o
arm-none-eabi-gcc -Wall -Werror -O2 -nostdlib -nostartfiles -ffreestanding -c main.c -o main.o
arm-none-eabi-ld start.o main.o -T ldscript -o main.elf
# Get the raw assembly out of the generated elf file.
arm-none-eabi-objcopy main.elf -O binary kernel7.img

# Get the firmware. Those are just magic blobs, likely compiled
# from some Broadcom proprietary C code which we cannot access.
wget -O bootcode.bin https://github.com/raspberrypi/firmware/blob/597c662a613df1144a6bc43e5f4505d83bd748ca/boot/bootcode.bin?raw=true
wget -O start.elf https://github.com/raspberrypi/firmware/blob/597c662a613df1144a6bc43e5f4505d83bd748ca/boot/start.elf?raw=true

# Prepare the filesystem.
sudo umount ""$part_dev""
echo 'start=2048, type=c' | sudo sfdisk ""$dev""
sudo mkfs.vfat ""$part_dev""
sudo mkdir -p ""$mnt""
sudo mount ""${part_dev}"" ""$mnt""
sudo cp kernel7.img bootcode.bin start.elf ""$mnt""

# Cleanup.
sync
sudo umount ""$mnt""
</code></pre>

<p><strong>QEMU friendly bare metal examples</strong></p>

<p>The problem with the blinker is that it is hard to observe LEDs in QEMU: <a href=""https://raspberrypi.stackexchange.com/questions/56373/is-it-possible-to-get-the-state-of-the-leds-and-gpios-in-a-qemu-emulation-like-t"">https://raspberrypi.stackexchange.com/questions/56373/is-it-possible-to-get-the-state-of-the-leds-and-gpios-in-a-qemu-emulation-like-t</a></p>

<p>Here I describe some bare metal QEMU setups that may be of interest: <a href=""https://stackoverflow.com/questions/38914019/how-to-make-bare-metal-arm-programs-and-run-them-on-qemu/50981397#50981397"">How to make bare metal ARM programs and run them on QEMU?</a> Writing to the UART is the easiest way to get output out from QEMU.</p>

<p>How well QEMU simulates the Raspberry Pi can be partially inferred from: <a href=""https://stackoverflow.com/questions/38837606/how-to-emulate-raspberry-pi-raspbian-with-qemu/45893057#45893057"">How to emulate Raspberry Pi Raspbian with QEMU?</a> Since even the Linux terminal shows up, it is likely that your baremetal stuff will also work.</p>

<p><strong>Bonus</strong></p>

<p>Here is an x86 example for the curious: <a href=""https://stackoverflow.com/questions/22054578/how-to-run-a-program-without-an-operating-system/32483545#32483545"">How to run a program without an operating system?</a></p>
",,37041961,599
29872525,2,29871968,2015-04-26T01:04:21.957,0,,2668996,,2015-04-26T01:20:00.507,2015-04-26T01:20:00.507,5,,"<p>This is what ended up working for me:</p>

<pre><code>// Interrupt handler for button press
void button_press_handler(uint32_t a, uint32_t b)
{
    // Turn the LED's on or off
        if (pio_get(PIOC, PIO_TYPE_PIO_OUTPUT_0, BLUE_LED4))
        pio_clear(PIOC, BLUE_LED4);
        else
        pio_set(PIOC, BLUE_LED4);
}
</code></pre>

<p>and here is the called ""set"" function which worked to turn the LED on:</p>

<pre><code>void pio_set(Pio *p_pio, const uint32_t ul_mask)
{
    p_pio-&gt;PIO_SODR = ul_mask;
}
</code></pre>
",,37106198,577
29873867,2,29873217,2015-04-26T04:46:45.477,0,,2769185,,2015-04-26T04:46:45.477,,0,,"<p>Hope This will help you:<br><br>
Algorithm:<br>
1)Get the X and Y co-ordinates of the start and end points of the line.<br>
2)Find the difference in the X and Y co-ordinates values as dx and dy.<br>
3)Check if dx is greater of dy is greater and assign the greater value to ‘steps’.<br>
4)Increment X and Y values at regular intervals by dividing the corresponding axes difference by steps.<br>
5)Plot the initial point by using “PUTPIXEL” syntax.<br>
6)Repeat step 4 ‘steps’ number of times and mark the end point by using “PUTPIXEL” syntax.<br>
7)End the program.<br><br></p>

<pre>Program:
#include""graphics.h""<br>
#include""stdio.h""<br>
#include""conio.h""<br>
#include""math.h""<br>
void linedraw(int,int,int,int);<br>
int main()<br>
{<br>
    int x1coeff,y1coeff,x2coeff,y2coeff;<br>
    printf(""\Enter the x and y value for starting point:"");<br>
    scanf(""%d%d"",&x1coeff,&y1coeff);<br>
    printf(""\Enter the x and y value for end point:"");<br>
    scanf(""%d%d"",&x2coeff,&y2coeff);<br>
    linedraw(x1coeff,y1coeff,x2coeff,y2coeff);<br>
    getch();<br>
    return 0;<br>

}<br>
void linedraw(int xa,int ya,int xb,int yb)<br>
{<br>
    int dx,dy,steps,k;<br>
    int gdriver=DETECT,gmode;<br>
    float xinc,yinc,x,y;<br>
    initgraph(&gdriver,&gmode,""""); //initialise graphics<br>
    dx=xb-xa;<br>
    dy=yb-ya;<br>
    x=xa;<br>
    y=ya;<br>
    if(abs(dx)>abs(dy))<br>
    {<br>
        steps=abs(dx);<br>
    }<br>
    else<br>
    {<br>
        steps=abs(dy);<br>
    }<br>
    xinc=dx/steps;<br>
    yinc=dy/steps;<br>
    putpixel(x,y,WHITE);<br>
    for(k=0;k
    {<br>
        x+=xinc;<br>
        y+=yinc;<br>
        putpixel(x,y,WHITE);<br>
    }}<br>

Output:<br>
 Enter the x and y value for starting point:100 100<br>
 Enter the x and y value for end point:200 200<br>
 The Line drawn is</pre>

<p><img src=""https://i.stack.imgur.com/lp92B.png"" alt=""enter image description here""></p>
",,37134896,178
29888625,2,29888109,2015-04-27T06:26:53.287,0,,4802937,,2015-04-27T06:26:53.287,,0,,"<p>Thanks to @bolov by using int8_t i could convert it bach to signed value</p>

<pre><code>int PromedioD_turn = PromedioD &lt;&lt; 8 | turn &amp; 0b11111111;
Serial.println(""test"");
Serial.println(PromedioD);
Serial.println(turn);
Serial.println(PromedioD_turn);
Serial.println(int8_t(PromedioD_turn &amp;0b11111111));
</code></pre>
",,37151109,368
29904853,2,29904478,2015-04-27T19:59:44.533,2,,3543752,,2015-04-27T19:59:44.533,,0,,"<p>There are a few issues with your code.  First you can't get the value of a variable or a define by dynamically using a string that is the name of the variable.  It doesn't work that way in C.  The easiest approach is to use an array and then just index through it.  To make this work well I've changed the for loop to count from 0 since the array is indexed starting at 0.  I changed the all_active logic assuming that at some point later you are going to want to know how many sensors are active instead of just whether they are all active or not.  If you don't want that, then your logic is also more complicated than needed.  It could just return 1 at the end of the for loop since all must have passed the test to get there.</p>

<pre><code>#define Sensor_1 2
#define Sensor_2 3
#define Sensor_3 4
#define Sensor_4 5
#define Sensor_5 6
int sensors[] = {Sensor_1, Sensor_2, Sensor_3, Sensor_4, Sensor_5};

int checkSensors(){
    int all_active = 1;
    int num_sens = 5; 
    int n;
    int active_sens = 0; 

    for(n= 0; n &lt; num_sens; n++){
        if( !digitalRead(sensors[n])){
            active_sens= active_sens+ 1;    
        }
        else {
            all_active = 0;
        }
     }
     return all_active;
}
</code></pre>
",,37191164,462
33644158,2,29932003,2015-11-11T04:11:14.500,15,,60075,,2015-11-11T04:11:14.500,,0,,"<p>Alternatively, you could access it via the kernel <code>at24.c</code> driver, if you're able to compile and install a different kernel device tree for your Raspberry Pi.</p>

<p>The kernel device tree needs to specify the EEPROM's type and address, and which I²C bus it's connected to. I'm not sure about Raspberry Pi, but for the BeagleBone Black EEPROM it goes like this:</p>

<pre><code>&amp;i2c0 {
    eeprom: eeprom@50 {
        compatible = ""at,24c32"";
        reg = &lt;0x50&gt;;
    };
};
</code></pre>

<p>For your device you'd specify <code>compatible = ""at,24c256"";</code></p>

<p>Ensure the kernel config specifies <code>CONFIG_EEPROM_AT24=y</code> (or <code>=m</code>).</p>

<p>Then you should be able to access the EEPROM memory from userspace at something like <code>/sys/bus/i2c/devices/0-0050/eeprom</code> or <code>/sys/bus/i2c/drivers/at24/0-0050/eeprom</code>.</p>
",,37226299,66
46319897,2,29932003,2017-09-20T10:41:22.523,0,,8640262,,2017-09-20T10:41:22.523,,5,,"<p>My code:</p>

<pre><code>enter code here

__s32 write_eeprom(__s32 fd,__u32 offset,__u32 len,__u8 *buf)
{
    __s32 ret;
    struct i2c_rdwr_ioctl_data msg_set;
    struct i2c_msg iomsgs;
    __u32 sended, sending;
    __u8 temp[ONE_PAGE + 1];

    if((offset + len) &gt; BYTES_MAX || len == 0)
    {
        printf(""write too long than BYTES_MAX\n"");
        return -1;
    }
    sended = 0;
    iomsgs.addr = DEVICE_ADDR;
    iomsgs.flags = 0;   //write
    iomsgs.buf = temp;
    msg_set.msgs = &amp;iomsgs;
    msg_set.nmsgs = 1;
    while(len &gt; sended)
    {
        if(len - sended &gt; ONE_PAGE)
            sending = ONE_PAGE;
        else
            sending = len - sended;
        iomsgs.len = sending + 1;
        temp[0] = offset + sended;
        memcpy(&amp;temp[1], buf + sended, sending);
        //printf(""sending:%d sended:%d len:%d offset:%d \n"", sending, sended, len, offset);
        ret = ioctl(fd, I2C_RDWR, (unsigned long)&amp;msg_set);
        if(ret &lt; 0)
        {
            printf(""Error dring I2C_RDWR ioctl with error code: %d\n"", ret);
            return ret;
        }
        sended += sending;
        usleep(5000);
    }

    return sended;
}
</code></pre>
",,37227015,462
48961740,2,29932003,2018-02-24T10:21:42.513,1,,6651335,,2018-02-24T10:21:42.513,,0,,"<p><strong>Small and simple program to understand the easy management of an eeprom</strong></p>

<pre><code>/*
    Simple program to write / read the eeprom AT24C32.
    Developed and tested on the Raspberry pi3B jessie

    To create the executable use the following command:

        gcc -Wall -o thisprogram.exe thisprogram.c
*/

#include &lt;stdio.h&gt;
#include &lt;sys/ioctl.h&gt; // ioctl
#include &lt;fcntl.h&gt;     // open
#include &lt;unistd.h&gt;    // read/write usleep
#include &lt;time.h&gt;
#include &lt;netinet/in.h&gt; // htons
#include &lt;linux/i2c-dev.h&gt;

#pragma pack(1)

#define PAGESIZE 32
#define NPAGES  128
#define NBYTES (NPAGES*PAGESIZE)

#define ADDRESS 0x57  //  AT24C32's address on I2C bus 

typedef struct {
    ushort AW;
    char  buf[PAGESIZE+2];
}WRITE;

static WRITE AT = {0};

int main() {
  int fd;
  char bufIN[180] = {0};
  time_t clock=time(NULL);

  snprintf(AT.buf, PAGESIZE+1, ""%s: my first attempt to write"", ctime(&amp;clock)); //  the buffer to write, cut to 32 bytes

  if ((fd = open(""/dev/i2c-1"", O_RDWR)) &lt; 0) {  printf(""Couldn't open device! %d\n"", fd); return 1; }

  if (ioctl(fd, I2C_SLAVE, ADDRESS) &lt; 0)     { printf(""Couldn't find device on address!\n""); return 1; }

  AT.AW = htons(32);    //  I will write to start from byte 0 of page 1 ( 32nd byte of eeprom )

  if (write(fd, &amp;AT, PAGESIZE+2) != (PAGESIZE+2)) { perror(""Write error !"");    return 1; }
  while (1) { char ap[4];  if (read(fd,&amp;ap,1) != 1) usleep(500); else break; } //   wait on write's end 

  if (write(fd, &amp;AT, 2) != 2) {  perror(""Error in sending the reading address"");    return 1;  }

  if (read(fd,bufIN,PAGESIZE) != PAGESIZE) { perror(""reading error\n""); return 1;}
  printf (""\n%s\n"", bufIN);

  close(fd);
  return 0;
}
</code></pre>
",,37228351,2004
29979250,2,29965822,2015-04-30T23:05:19.427,0,,595114,,2016-07-31T23:39:00.883,2016-07-31T23:39:00.883,5,,"<p>SPI clocks the data every other edge.  Including an edge of the clock with your data is probably faster (same OR but saves one assign)</p>

<pre><code>port = CLOCK
for (i = 7; i &gt;= 0; i--)
{
    if ((data &gt;&gt; i) &amp; 0x01)
    {
        // set output pin to 1
        port |= OUTPUT | CLOCK;
    }
    else
    {
        // set output pin to 0
        port &amp;= OUTPUT;
        port |= CLOCK;
    }
    // strobe clock
    port &amp;= ~CLOCK;
}
</code></pre>
",,37258537,2343
29984108,2,29983943,2015-05-01T09:00:08.403,3,,4751603,,2015-05-01T09:06:26.687,2015-05-01T09:06:26.687,6,,"<p>You can print the binary value of an integer using the bitwise.</p>

<p>As far as I am concerned, I'm using this kind of function to understand how it works :</p>

<pre><code>int     main()
{
  int   nb = 10;
  int   i = 31;

  while (i &gt;= 0) {
    if ((nb &gt;&gt; i) &amp; 1)
      printf(""1"");
    else
      printf(""0"");
    --i;
  }
  printf(""\n"");
}
</code></pre>

<p>In this code, the <strong>i</strong> represents the selected bit. With this selected bit, I'm searching if it's a 1 using the logical AND (&amp;) operator. If it is, I print ""1"" and I select the next bit until the end of the number (which contains 32 bits, because it's an integer).</p>

<p>There is many way to obtain the value using the bitwise.. You have to try it yourself to understand better !</p>

<p>Good luck!</p>
",,37273326,1583
30028217,2,30024908,2015-05-04T10:47:22.220,0,,4841248,,2015-05-04T10:47:22.220,,2,,"<p>As mentioned in the comments, it's better to use the new C++ interface.</p>

<p>The following code will show the feed from a webcam in a window, the program will terminate when 'q' is pressed: (<a href=""http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture"" rel=""nofollow"">source</a>)</p>

<pre class=""lang-cpp prettyprint-override""><code>#include ""opencv2/highgui/highgui.hpp""

int main(int argc, const char** argv) {
    cv::VideoCapture capture;
    cv::Mat image;

    // Unless you need to get images from multiple devices,
    // using '-1' will automatically select the webcam.
    capture.open(-1);
    if (capture.isOpened()) {
        cv::namedWindow(""WebCam"", cv::WINDOW_AUTOSIZE);
        while (1) {
            capture.read(image);
            cv::imshow(""WebCam"", image);
            int c = cv::waitKey(10);
            if ((char)c == 'q') {
                break;
            }
        }
    }

    capture.release();

    return 0;
}
</code></pre>

<p>I have tested this code on Ubuntu 14.04 and compiled it like this:</p>

<pre><code>$ clang++ -o cvtest cvtest.cpp -lopencv_core -lopencv_highgui
</code></pre>

<hr>

<p>If you desperately want to continue using <code>IplImage</code> and the C interface, then I can't help you.</p>
",,37311903,828
30044527,2,30038172,2015-05-05T04:51:54.270,5,,214796,,2015-05-05T05:03:41.940,2015-05-05T05:03:41.940,7,,"<p>This is almost certainly an alignment issue. Judging by the size of your struct, your compiler seems to be automatically packing it.</p>

<hr>

<p>The <code>LDR</code> instruction loads a 4-byte value into a register, and operates on 4-byte boundaries. If it needs to load a memory address that isn't on a 4-byte boundary, it actually performs <em>two loads</em> and combines them to obtain the value at that address.</p>

<p>For example, if you want to load the 4-byte value at <code>0x02</code>, the processor will do two loads, as <code>0x02</code> does not fall on a 4-byte boundary.</p>

<p>Let's say we have the following memory at address <code>0x00</code> and we want to load the 4-byte value at <code>0x02</code> into the register <code>r0</code>:</p>

<pre><code>Address |0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|0x08|
Value   | 12 | 34 | 56 | 78 | 90 | AB | CD | EF | 12 |
------------------------------------------------------
r0: 00 00 00 00
</code></pre>

<p>It will first load the 4 bytes at <code>0x00</code>, because that's the 4-byte segment containing <code>0x02</code>, and store the 2 bytes at <code>0x02</code> and <code>0x03</code> in the register:</p>

<pre><code>Address |0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|
Value   | 12 | 34 | 56 | 78 | 90 | AB | CD | EF |
Load 1  |           **   ** |
------------------------------------------------------
r0: 56 78 00 00
</code></pre>

<p>It will then load the 4 bytes at <code>0x04</code>, which is the next 4-byte segment, and store the 2 bytes at <code>0x04</code> and <code>0x05</code> in the register.</p>

<pre><code>Address |0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|
Value   | 12 | 34 | 56 | 78 | 90 | AB | CD | EF |
Load 2                      | **   **           |
------------------------------------------------------
r0: 56 78 90 AB
</code></pre>

<p>As you can see, each time you want to access the value at <code>0x02</code>, the processor actually has to split your instruction into two operations. However, if you instead wanted to access the value at <code>0x04</code>, the processor can do it in a single operation:</p>

<pre><code>Address |0x00|0x01|0x02|0x03|0x04|0x05|0x06|0x07|
Value   | 12 | 34 | 56 | 78 | 90 | AB | CD | EF |
Load 1                      | **   **   **   ** |
------------------------------------------------------
r0: 90 AB CD EF
</code></pre>

<hr>

<p>In your example, with both <code>flags1</code> and <code>flags2</code> commented out, your struct's size is 15. This means that <strong>every second struct in your array is going to be at an odd address</strong>, so none of it's pointer or long members are going to be aligned correctly.</p>

<p>By introducing one of the <code>flags</code> variables, your struct's size increases to 16, which is a multiple of 4. This ensures that all of your structs begin on a 4-byte boundary, so you likely won't run into alignment issues.</p>

<hr>

<p>There's likely a compiler flag that can help you with this, but in general, it's good to be aware of the layout of your structures. Alignment is a tricky issue to deal with, and only compilers that conform to the current standards have well defined behavior.</p>
",,37326215,92
30082289,2,30082094,2015-05-06T16:21:17.723,1,,1978011,,2015-05-06T16:27:41.920,2017-05-23T12:14:17.207,6,,"<p><strong>NO</strong> the previously allocated memory will not be freed. You will lose all allocated memory.</p>

<p>By overwriting your <code>persons</code> pointer, you lose your handle on the allocated storage. So before you do this, you have to call</p>

<pre><code>::operator delete(persons[0].pets);
::operator delete(persons[1].pets);
::operator delete(persons);
</code></pre>

<p>This is pretty ugly, isn't it? For that reason exists the <code>std::vector</code> container.</p>

<pre><code>#include &lt;vector&gt;

struct Person {
  std::vector&lt; Pet &gt; pets;
};

std::vector&lt; Person &gt; persons(2);
persons[0].pets = std::vector&lt; Pet &gt;(2);
persons[1].pets = std::vector&lt; Pet &gt;(3);

persons = std::vector&lt; Person &gt;(3); // won't lose memory
</code></pre>

<p>Since you have probably not heard of it, I would recommend to read up on <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow noreferrer"">RAII</a> or <a href=""https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii"">here</a>.</p>
",,37332466,359
30082916,2,30082819,2015-05-06T16:52:05.707,2,,3638234,,2015-05-06T16:52:05.707,,4,,"<p>It is because you declare buffer on the stack. If you want to return a dynamically allocated buffer, use malloc:</p>

<pre><code>uint8_t *buffer = new uint8_t[length];
if (buffer == NULL) error_allocation;

// Make sure to de-allocate after you finish to use it
delete [] buffer;
</code></pre>
",,37343447,711
30083261,2,30082934,2015-05-06T17:08:54.557,1,,434551,,2015-05-06T17:08:54.557,,0,,"<p>You can expand that single line of code to:</p>

<pre><code>int temp = (byte)(CharacterMask[0][(customKey - '0') - 1][0]);
if ( K_count &lt; temp )
{
   K_count = ++K_count;
   // This is bad. See the comment about sequence points.
   // It should be
   K_count = K_count + 1;
}
else
{
   K_count = 1;
}
</code></pre>
",,37355134,1519
30083583,2,30082934,2015-05-06T17:23:58.647,1,,4499923,,2015-05-06T17:42:52.380,2015-05-06T17:42:52.380,1,,"<p>this basically increments through the available options on a standard US telephone keypad for the ""3"" key, looping back to the first option after the last is reached.  it does so by referencing a 3-dimensional array containing the options for each key layed out as row/column/options. it is written in such a way that it can be reused for other keys with minor modifications.</p>

<p>the ""...?...:..."" construct is basically a shortcut for if/else. so you can rewrite the statement like this:</p>

<pre><code>if (K_count &lt; (byte)(CharacterMask[0][(customKey - '0') - 1][0])) {
    K_count = ++K_count;
} else {
    K_count = 1;
}
</code></pre>

<p>the ""++"" operator simply adds 1 to the variable, so you can rewrite as:</p>

<pre><code>if (K_count &lt; (byte)(CharacterMask[0][(customKey - '0') - 1][0])) {
    K_count = K_count + 1;
} else {
    K_count = 1;
}
</code></pre>

<p>CharacterMask is a 3-dimensional array that describes a typical telephone keypad. the first 2 dimensionsindicate the row and column of the keypad. the third dimension contains the options available on that key. so, for example, the 3 key on a telephone has 4 options (3,d,e, and f). for some reason, the author also includes the option count as the first item in the array (index 0).  so CharacterMask[0][2] would give you an array containing the number 4 followed by the characters '3','d','e', and 'f'. as such, CharacterMask[0][2][0] will return the number 4. similarly CharacterMask[0][2][1] would return the char '3'. since this line of code is only really concerned with the number of options, not their values, the final array index is hard-coded to 0. given that, you can rewrite the code like this to clarify:</p>

<pre><code>rowIndex = 0;
columnIndex = (customKey - '0') - 1;
optionCountIndex = 0;
if (K_count &lt; (byte)(CharacterMask[rowIndex][columnIndex][optionCountIndex])) {
    K_count = K_count + 1;
} else {
    K_count = 1;
}
</code></pre>

<p>since customKey is a char and not a number, we can use the ""-"" operator to subtract the '0' char. this implicitly casts both values to a byte and returns the difference between those bytes.  since the numbers are ordered 0-9 in most character sets, this effectively gets us the numerical value of the character stored in the customKey variable (e.g. char 3 becomes byte 3). so the code can be rewritten as follows:</p>

<pre><code>rowIndex = 0;
keyNumber = (customKey - '0');
columnIndex = keyNumber - 1;
optionCountIndex = 0;
if (K_count &lt; (byte)(CharacterMask[rowIndex][columnIndex][optionCountIndex])) {
    K_count = K_count + 1;
} else {
    K_count = 1;
}
</code></pre>

<p>since they keys 1,2,3 are found in columns 0,1,2 in a zero-based indexed column count, we need to subtract 1 from the keyNumber to get the column index as shown above</p>

<p>because CharacterMask is a char array, we need to cast the first value to a byte to get the value initially entered back. this rewrite clarifies that:</p>

<pre><code>rowIndex = 0;
keyNumber = (customKey - '0');
columnIndex = keyNumber - 1;
optionCountIndex = 0;
optionCountAsCharType = (CharacterMask[rowIndex][columnIndex][optionCountIndex]);
if (K_count &lt; (byte)optionCountAsCharType) {
    K_count = K_count + 1;
} else {
    K_count = 1;
}
</code></pre>

<p>the comparison with K_count relies on the fact that the option array length is equal to the option count plus 1. since it is zero-based indexed, that means the last index is equal to the option count. so as long as the current K_count (aka option index) is less than the option count, you can still add 1 without exceeding the max index value. but if you are on the last index, you must roll back to 1 (the index of the first option). it could be made more clear with one more refactor:</p>

<pre><code>rowIndex = 0;
keyNumber = (customKey - '0');
columnIndex = keyNumber - 1;
optionCountIndex = 0;
optionCountAsCharType = (CharacterMask[rowIndex][columnIndex][optionCountIndex]);
nextIndexIsInsideArrayBounds = K_count &lt; (byte)optionCountAsCharType
if (nextIndexIsInsideArrayBounds) {
    K_count = K_count + 1;
} else {
    K_count = 1;
}
</code></pre>
",,37367878,81
30092615,2,30092542,2015-05-07T05:30:21.997,2,,14860,,2017-08-25T00:43:42.420,2017-08-25T00:43:42.420,0,,"<p>First things first, that code as you've shown it will <em>never</em> deviate from a delay of <code>2000</code> simply because there's no way to exit from the initial <code>for(;;)</code> loop. That's probably the <em>first</em> thing you need to check and fix.</p>

<hr>

<p>In terms of being able to end a delay early, you can do something like change:</p>

<pre><code>delay (2000);
</code></pre>

<p>into:</p>

<pre><code>for (i = 0; i &lt; 2000; i += 10) {
    delay (10);
    if (digitalRead (IN) == 1)
        break;
}
</code></pre>

<p>This basically exits the delay early if the switch changes, so that you'll never be waiting more than 10 time units (rather than up to 2000).</p>

<p>Just be aware that there may be an overhead to repeatedly calling delay. In other words, while <code>delay(2000)</code> may take very close to 2000 time units, two hundred calls to <code>delay(10)</code> may take a little more because of setup time for each call and so on.</p>

<hr>

<p>In fact, you can probably greatly simplify your code by not using hard-coded values at all. Instead, you can have a single loop with minimal delay, with some internal controls which work out when and how to change the LED (i.e., not <em>every</em> time through the loop).</p>

<p>For example, something like this would do it. I haven't tested it since my Pi2 is still sitting in a box awaiting some time for me to play with it, but it should be pretty close:</p>

<pre><code>#include &lt;wiringPi.h&gt;
#include &lt;stdio.h&gt;

#define LED 18
#define IN 24
#define RES 10

int main (void) {
    int cycleTime, ledState, lastSwitch, currSwitch, timeLeft;

    wiringPiSetupGpio ();
    pinMode (LED, OUTPUT);
    pinMode (IN, INPUT);

    cycleTime = 2000;  // Initial cycle time
    ledState = 0;      //   and LED state.
    lastSwitch = 0;    // Previous switch state,

    // Start infinite loop with first cycle time.

    timeLeft = cycleTime;
    for (;;) {
        // Delay for minimal time and adjust time left.

        delay (RES);
        timeLeft = timeLeft - RES;

        // Detect switch change.

        currSwith = digitalRead (IN);
        if (currSwitch != lastSwitch) {
            // If so, store new state, change cycle time
            //   and force IMMEDIATE end of current cycle.

            lastSwitch = currSwitch;
            cycleTime = 2500 - cycleTime;  // switch 500 &lt;-&gt; 2000
            timeLeft = 0;
        }

        // Detect end of cycle.

        if (timeLeft &lt;= 0) {
            // Toggle LED and start new cycle.

            ledState = 1 - ledState;
            digitalWrite (LED, ledState);
            timeLeft = cycleTime;
        }
    }
}
</code></pre>

<p>Basically, you have a single loop but one which loops every ten time units rather than every 500 or 2000. You maintain a <em>separate</em> counter which decides when the LED should be flipped and the starting value for this counter depends on the current cycle time.</p>

<p>When the switch is flipped, that counter is zeroed so that it (almost) immediately changes to the next cycle.</p>
",,37381320,116
30133865,2,30131032,2015-05-08T22:38:50.247,2,,1726622,,2015-05-08T22:38:50.247,,1,,"<p>I have resolved it :D .For those having this problem follow these steps:   </p>

<p>1.Go to file gcc_armv7.h line 31 and comment lines  </p>

<pre><code>30 #if !(__ARM_ARCH_7A__)
31 #error compilation requires an ARMv7-a architecture.   
32 #endif
</code></pre>

<p>2.Next in the same file gcc_armv7.h go to line 56 and replace it with </p>

<pre><code>56 #define __TBB_full_memory_fence() 0xffff0fa0  // __asm__ __volatile__(""dmb ish"": : :""memo    ry"")
</code></pre>

<p>For those who want an explanation how I did it, after the first step I get the following errors :</p>

<pre><code>/tmp/ccnkbkfd.s:313: Error: selected processor does not support ARM mode `dmb ish'
/tmp/ccnkbkfd.s:386: Error: selected processor does not support ARM mode `dmb ish'
/tmp/ccnkbkfd.s:533: Error: selected processor does not support ARM mode `dmb ish'
/tmp/ccnkbkfd.s:562: Error: selected processor does not support ARM mode `dmb ish'
</code></pre>

<p>After I have searched on google and found this :</p>

<pre><code>The alternative for using dmb is to call the Linux kernel __kuser_memory_barrier

the __kuser_memory_barrier helper operation is found in all ARM kernels 2.6.15 and later
and provide a way to issue a memory barrier that will work across all ARM arch.__kuser_memory_barrier 
helper function found at address 0xffff0fa0
</code></pre>
",,37383063,152
30154618,2,30154005,2015-05-10T17:47:10.990,0,,4799298,,2015-05-10T17:47:10.990,,0,,"<p>First off, some code cleanup. After trying to compile the provided code, I ran into numerous errors. I have fixed them and the code below should compile:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

#define RX 0
#define TX 1
#define PIN_SENSOR 2

SoftwareSerial Bluetooth(RX,TX); 

byte state = B00000000;

void setup(){

    Serial.begin(9600);
    pinMode(RX, INPUT);
    pinMode(TX, OUTPUT);

}

void loop(){


for(int i=0; i&lt;8; i++){
    if(digitalRead(i+PIN_SENSOR) == HIGH)
    state += (1 &lt;&lt; i);
}

Bluetooth.write(state);


} 
</code></pre>

<p>If you still get the error about software serial library, try downloading the Arduino IDE again from here: <a href=""http://www.arduino.cc/en/Main/Software"" rel=""nofollow"">http://www.arduino.cc/en/Main/Software</a></p>
",,37409395,65
30159482,2,30158480,2015-05-11T04:02:34.873,0,,20862,,2015-05-11T04:02:34.873,,0,,"<p>A <code>for</code> loop is a runtime operation. You cannot perform runtime operations that assign to a <code>PROGMEM</code> variable since the variable will be stored in (read-only at runtime) flash.</p>

<p>But since the only variable part is the number, store the other two parts in flash and create the filename at runtime.</p>

<pre><code>#define FILEPREFIXLEN 5
char fileprefix[] PROGMEM = ""Track"";
#define FILESUFFIXLEN 4
char filesuffix[] PROGMEM = "".WAV"";
#define FILEMIDLEN 2

 ...

char filename[FILEPREFIXLEN + FILEMIDLEN + FILESUFFIXLEN + 1];
// Read fileprefix into filename, append number, append filesuffix
</code></pre>
",,37423262,1187
30167452,2,30167248,2015-05-11T12:19:12.897,1,,646887,,2015-05-11T13:17:36.673,2015-05-11T13:17:36.673,3,,"<p>Turn right 90 degrees:</p>

<pre><code>tmp = -sprite-&gt;dx;
sprite-&gt;dx = sprite-&gt;dy;
sprite-&gt;dy = tmp; 
</code></pre>

<p>Turn left 90 degrees:</p>

<pre><code>tmp = sprite-&gt;dx; 
sprite-&gt;dx = -sprite-&gt;dy;
sprite-&gt;dy = tmp;
</code></pre>

<p><strong>Edit:</strong> </p>

<p>If you would like just a temporary shift (while the button is pressed), you need to apply the modifier when updating x/y instead:</p>

<pre><code>if (LEFT_BUTTON_PRESSED) {
    sprite-&gt;x -= sprite-&gt;dy;
    sprite-&gt;y += sprite-&gt;dx;
} 
else if (RIGHT_BUTTON_PRESSED) {
    sprite-&gt;x += sprite-&gt;dy;
    sprite-&gt;y -= sprite-&gt;dx;
}
else {
    sprite-&gt;x += sprite-&gt;dx;
    sprite-&gt;y += sprite-&gt;dy;
}
</code></pre>
",,37424070,69
30168167,2,30167248,2015-05-11T12:51:22.857,0,,3436922,,2015-05-11T12:51:22.857,,2,,"<p><strong>My solution will be like this</strong></p>

<pre><code>typedef enum 
{
   north,
   south,
   east,
   west
}DIRECTIONS;

typedef struct
{
    uint8_t x;
    uint8_t y;
    uint8_t dx;
    uint8_t dy;
    DIRECTIONS currentDir;
}Sprite;


void change_direction (Sprite * sprite)
{
    sprite-&gt;x += sprite-&gt;dx; 
    sprite-&gt;y += sprite-&gt;dy;

    if (pressed (SW0) )
    {
       switch(sprite-&gt;currentDir)
       {
          case north:
                     sprite-&gt;dx = 1;
                     sprite-&gt;dy = 0;
                     break;
          case south:
                     sprite-&gt;dx = -1;
                     sprite-&gt;dy = 0;
                     break;
          case east:
                     sprite-&gt;dx = 0;
                     sprite-&gt;dy = 1;
                     break;
          case west:
                     sprite-&gt;dx = 0;
                     sprite-&gt;dy = -1;
                     break;
       }
   }
}
</code></pre>
",,37427046,69
30189054,2,30185012,2015-05-12T11:08:20.110,0,,1689090,,2015-05-12T11:08:20.110,,0,,"<p>The main problem is that <code>Sprite zombie_sprite</code> is only one object.  Make this an array of objects and you can start looking at other problems.  Next there is a fair bit of confusion over pointers to the <code>Sprite</code> objects.  To simplify things a bit we can tweak the variables in the <code>zombies</code> function, along with some 'tidying up' for best practices.</p>

<pre><code>// Start by using a compile-time constant to define the number of zombies.
// This could be changed to a vriable in the, once the simple case is working.
#define NUMBER_OF_ZOMBIES 8

void zombies()
{
    // Eight zombies are required, so define an array of eight sprites.
    Sprite zombie_sprites[NUMBER_OF_ZOMBIES];
    byte zombie_bitmap [] = 
    {
        BYTE( 11100000 ),
        BYTE( 01000000 ),
        BYTE( 11100000 )
    };

// Continued below...
</code></pre>

<p>This makes the rest of the function to initialise the sprites easier.  This time, it is possible to get the pointer to the <code>i</code>th element in the array.  Also, you will see that the <code>create_zombies</code> function requires an argument: the address of a <code>Sprite</code> object, so pass it the address of the first sprite in the same array that has just been initialised.</p>

<p>Again, with a bit of housekeeping, the rest of the function would look like this:</p>

<pre><code>    // ...continued from above

    for (int i = 0; i &lt; NUMBER_OF_ZOMBIES; i++)
    {
        // Initialise the ith sprite using the address of its element
        // in the zombie_sprites array.
        init_sprite(&amp;zombie_sprites[i], rand()%76, rand()%42,
                    3, 3, zombie_bitmap);
    }

    // Animate the zombies in the array.
    create_zombies(&amp;zombie_sprites[0]);       
}
</code></pre>

<p>Finally, the <code>create_zombies</code> function itself needs a minor change to loop through all of the sprites in the array passed as its parameter.  Also, being of type <code>void</code> it does not have a return statement.</p>

<pre><code>void create_zombies(Sprite * zombie_sprites)
{
    while(1)
    {
        clear();

        // loop round drawing all of the sprites.
        for(int zombie_index = 0; zombie_index &lt; NUMBER_OF_ZOMBIES; zombie_index++)
        {
            draw_sprite( &amp;zombie_sprites[zombie_index] );
        }

        refresh();
    }
}
</code></pre>

<p>Future enhancements might include:</p>

<ul>
<li>Changing NUMBER_OF_ZOMBIES to be a variable.</li>
<li>Replacing the static array with a dynamically allocated array using <code>malloc</code> and <code>free</code>.</li>
<li>Replacing the array with a more complex abstract data type such as a list or doubly linked list, so that zombies can be added or removed at run-time.</li>
<li>Renaming the functions and restructuring where each gets called.</li>
</ul>
",,37517042,444
30215860,2,30203507,2015-05-13T13:10:51.867,1,,4808380,,2015-05-13T13:10:51.867,,0,,"<p>Arduino UNO integers are 16bit wide, just use unsigned long variables or a #define.</p>

<pre><code>#define watertime 300000
#define waittime 3600000

// some code...
delay(watertime);
// more code...
delay(waittime);
</code></pre>
",,37569079,1413
30207371,2,30207140,2015-05-13T06:38:32.447,0,,4862552,,2015-05-13T08:00:01.567,2015-05-13T08:00:01.567,1,,"<p></p>

<pre><code>//Sorry for the bad format. Must learn how to use it correctly.
void createRandom(std::string &amp; randString, const int len)
{

    static const std::string theCharacters =  ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";

    for (int i = 0; i &lt; len; ++i) 
    {
        //generate a random number which not bigger that max size of the available characters, then add it to the string.
        randString += theCharacters[rand() % (sizeof(theCharacters) - 1)];
    }
}
createRandom(message);
this-&gt;serialPort1-&gt;WriteLine(message);
</code></pre>
",,37580655,544
30272758,2,30272702,2015-05-16T06:57:14.363,2,,694576,,2015-05-16T07:28:46.823,2015-05-16T07:28:46.823,4,,"<p>C is pass by value.</p>

<p><code>score_increaser()</code> as shown in your question increases just a <strong>copy</strong> of what is passed in.</p>

<p>To fix this there are (mainly) two options:</p>

<ol>
<li><p>As <code>score</code> is defined globally, do not pass in anything:</p>

<pre><code>void score_increaser(void) {
  score++;
  _delay_ms( 3000 );
}
</code></pre>

<p>This modifes the globale <code>score</code> directly.</p></li>
<li><p>Pass in the address of <code>score</code> and de-reference it inside the function</p>

<pre><code>void score_increaser(int * pscore) {
  (*pscore)++;
  _delay_ms( 3000 );
}
</code></pre>

<p>Call it like this</p>

<pre><code>...
score_increaser(&amp;score);
...
</code></pre></li>
</ol>

<p>A 3rd, a bit more complex, approach (which assumes signals are supported on the target platform) would </p>

<ol>
<li>setup a signal and a referring handler, then </li>
<li>setup a timer to fire a signal every N seconds. </li>
<li>This signal then is handled by the handler, which in turn </li>
<li>increases the global <code>score</code> and</li>
<li>starts the timer again.</li>
</ol>

<p>This might look like:</p>

<pre><code>#include &lt;signal.h&gt; /* for signal() and sig_atomic_t */
#include &lt;unistd.h&gt; /* for alarm() */


#define DURATION (3) /* Increase score every 3 seconds. */

sig_atomic_t score = 0;


void set_alarm(unsigned);

void handler_alarm(int sig)
{
  ++score;
  set_alarm(DURATION);
}

void set_alarm(unsigned duration)
{
  signal(SIGALRM, handler_alarm);
  alarm(duration);
}


int main(void)
{
  set_alarm(DURATION);

  ... /* The game's codes here. */
}
</code></pre>

<p>This latter approach has the advantage that your game's code does not need to take care about increasing <code>score</code>. <code>score</code> is just increased every 3 seconds as long as the program runs.</p>
",,37581925,9259
30272929,2,30272702,2015-05-16T07:20:54.587,1,,4228131,,2015-05-16T07:20:54.587,,0,,"<p>I'd recommend using a timer interrupt. Configure the timer to 3 seconds.</p>

<pre><code>volatile int score = 0; //global

void Intr_Init(peripheral_t per)
{
    //Initialize the timer interrupt
}

void draw_score(int score_d)
{
    char score_draw[99];
    sprintf(score_draw,""%d"", score_d);
    draw_string(score_draw, 9, 0);
}

int main(void)
{
    Intr_Init(TIMER);
    while(1)
    {
        //Code that makes your game run
        draw_score(score);
    }
}

ISR (TIMER1_COMPA_vect)
{
    //clear disable interrupt
    score++;
    //enable interrupt
}
</code></pre>

<p>In embedded, you should rely on Timers for better time critical tasks and accuracy. The way Delay routines are implemented is usually a loop or a up/down counter. Whereas a timer is usually based on counting SysTicks.
Another major advantage of Interrupts is that you let processor do its tasks all the while instead of making it block in a delay loop.</p>
",,37584133,411
30273015,2,30272702,2015-05-16T07:30:58.550,0,,4903563,,2015-05-17T00:02:34.323,2015-05-17T00:02:34.323,1,,"<p>You dont need parameter for the score since it's declared globally.. </p>

<pre><code>//global 
int score = 0;

void score_increaser()
{
   _delay_ms(3000);
   score++;
}
</code></pre>

<p>calling is like: <code>score_increaser();</code> should do the work.. 
i suggest you check for <code>score</code> in any other line/function.. maybe you have redeclared it or accidentally changed the value.. </p>

<p>hope this helped.. </p>
",,37625357,136
30280826,2,30272702,2015-05-16T21:13:48.157,0,,3629249,,2015-05-16T21:13:48.157,,0,,"<p>here is a good method for handling the score.</p>

<p>in the 'start game' function, </p>

<pre><code>clear 'score' to 0
setup a timer: 
--to expire once each 3 seconds 
--enable the automatic reload feature, 
--enable the timer interrupt
--enable the timer counter
</code></pre>

<p>in the timer interrupt handler function</p>

<pre><code>--increment 'score'
--clear the timer interrupt pending flag
</code></pre>

<p>in the 'end game' function</p>

<pre><code>disable the timer counter
disable the timer interrupt
display the 'score' value
</code></pre>
",,37670643,734
30556578,2,30276597,2015-05-31T10:55:59.160,1,,4958279,,2015-05-31T11:44:49.717,2015-05-31T11:44:49.717,0,,"<p>I was having the same problem. The solution is to stop the time 2 interrupt from running to send the message.</p>

<p>The edit of your code:</p>

<pre><code>void sendSMS2()
{
 cli();
   gsm_condition_1 = HIGH;
   SIM900.print(""AT+CMGF=1\r"");    //AT command to send SMS message
   delay(100);
   SIM900.println(""AT + CMGS = \"""" + destinationNumber +""\"""");           
   delay(100);
   SIM900.println(outMessage2);    //message to send
   delay(100);
   SIM900.println((char)26);   //End AT command with a^Z, ASCII code 26 or     ctrl+z
   delay(100);
   sei();
   }
</code></pre>

<p>The problem is that the sensor can only read using the interrupt, but your sim900 will not function when the interrupt is active. So you'll have to temporarily disable the interrupt and then carry on. Also, <code>SIM900.print(""AT+CMGF=1\r"");</code> should be in void loop.
The last problem is that your sim 900 will not send integer. So you'll have to send it as a string. Please follow this example for that: <a href=""http://microembarcado.blogspot.com.au/p/wr-bridge-send-sms-with-temperature.html"" rel=""nofollow"">http://microembarcado.blogspot.com.au/p/wr-bridge-send-sms-with-temperature.html</a></p>

<p>I sat for about 4 hours to figure it out. 
Hope this makes things a little simplier for you.</p>
",,37670899,108
30293141,2,30287832,2015-05-17T23:22:11.587,1,,4908976,,2015-05-17T23:22:11.587,,0,,"<p>My problem was not the code but the terminals (stdout) buffered output. </p>

<p>The read was returning with zero characters so the $line was an empty string that is silently added to the output line buffer.  Eventually the 
serial data would receive the end of line (\n) and cause the buffer to print displaying the received serial data.</p>

<p>With the formated printf the \n caused the output buffer to print every time the read returned.  And, this displayed and endless stream of empty 
brackets.  This confused the poor terminal operator.</p>

<p>Problem solved.... test the character count returned from the read before trying to printf it.</p>

<pre><code>use Device::SerialPort;
$ob = Device::SerialPort-&gt;new(""/dev/ttyACM0"") or die ""new failed\n"" ;
$ob-&gt;baudrate(115200) or die ""parm set failed"" ;
$ob-&gt;parity('none') or die ""parm set failed"" ;
$ob-&gt;databits(8) or die ""parm set failed"" ;
$ob-&gt;stopbits(1) or die ""parm set failed"";
$ob-&gt;handshake('none') or die ""parm set failed"" ;
$ob-&gt;write_settings or die ""no settings\n"";
while(1){
  ($count, $line) = $ob-&gt;read(255);
  if($count &gt;0) {
    printf ""&lt;%s&gt;\n"", $line;
  }
}
</code></pre>
",,37674722,114
30327957,2,30311777,2015-05-19T14:04:23.553,0,,4908743,,2015-05-19T14:04:23.553,,0,,"<p>Thanks for the help, It works!</p>

<p>this is the makefile I'm using:</p>

<pre><code>all:
    g++ -fPIC -shared -o lcdcontrol.so -I/usr/local/include -L/usr/local/lib -lwiringPi lcdcontrol.cpp
    sudo cp lcdcontrol.so /usr/lib/lcdcontrol.so
</code></pre>

<p>nm lcdcontrol.so returns:</p>

<pre><code>     (...)
     U digitalWrite
     (...)
     00002968 T _Z10drawstringv
     00002a04 t _Z41__static_initialization_and_destruction_0ii
     0000293c T _Z5clearv
     00002834 T _Z5startv
     000028cc T _Z6setpixv
     0000bab6 b _ZL10xUpdateMax
     0000bab5 b _ZL10xUpdateMin
     0000bab8 b _ZL10yUpdateMax
     (...)
</code></pre>

<p>In my python code I can now use:</p>

<pre><code>mylcd._Z5startv()
mylcd._Z6setpixv()
mylcd._Z10drawstringv()
</code></pre>

<p>And it works!</p>
",,37694440,5635
30382989,2,30354405,2015-05-21T19:44:59.417,1,,846566,,2015-05-21T21:16:37.237,2015-05-21T21:16:37.237,0,,"<p>Thanks for everyone's help.  In case someone has the same problem I wanted to show my solution.  Much of this code came from the devmem2 from Jan-Derk Bakker.</p>

<p>Here are the two routines I wrote to read and write from memory.</p>

<pre><code>static const u_int32_t MAP_SIZE = 4096;
static const u_int32_t MAP_MASK = (MAP_SIZE - 1);

bool CGpio::writeMem(u_int32_t memAddr, u_int32_t &amp;value)
{
    int fd;
    void *map_base, *virt_addr;
    off_t target = memAddr;

    // open the mem file
    if((fd = open(""/dev/mem"", O_RDWR | O_SYNC)) == -1)
        return false;

    // map one page
    map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target &amp; ~MAP_MASK);
    if (map_base == (void *)-1)
        return false;

    // map virutial space
    virt_addr = map_base + (target &amp; MAP_MASK);

    // write the value
    *((u_int32_t *) virt_addr) = value;

    // clean up
    bool ret = (munmap(map_base, MAP_SIZE) != -1);
    close(fd);

    return ret;
}

bool CGpio::readMem(u_int32_t memAddr, u_int32_t &amp;value)
{
    int fd;
    void *map_base, *virt_addr;
    off_t target = memAddr;

    // open the mem file
    if((fd = open(""/dev/mem"", O_RDWR | O_SYNC)) == -1)
        return false;

    // map one page
    map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target &amp; ~MAP_MASK);
    if (map_base == (void *)-1)
         return false;

    // map virutial space
    virt_addr = map_base + (target &amp; MAP_MASK);

    // read the value
    value = *((u_int32_t *) virt_addr);

    // clean up
    bool ret = (munmap(map_base, MAP_SIZE) != -1);
    close(fd);

    return ret;
}
</code></pre>

<p>And here are the headers I used.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;sys/types.h&gt;
</code></pre>
",,37698164,2005
30374265,2,30367270,2015-05-21T12:49:08.750,6,,1401213,,2015-05-21T12:49:08.750,,2,,"<p>You should create a Hardware Abstraction Layer (HAL).  The code within the HAL encapsulates all the hardware specific differences.  The higher level code that calls into the HAL should not be aware of any hardware specific differences because the HAL has abstracted those details into a more generic interface.</p>

<p>Your example does not abstract the difference but rather passes the differences along to the higher level code in the form of different parameters.  The higher level code will need to check the hardware type so that it can make the appropriate call to <code>dacWrite()</code>.</p>

<p>As an alternative, consider how you can abstract both <code>int level</code> and <code>byte highbyte, lowbyte</code> into a more generic parameter that is hardware independent.  Then the higher level code that calls <code>dacWrite()</code> doesn't need to know what hardware it is running on.  Instead, <code>dacWrite()</code> will take care of the details.</p>

<p>I'm not sure whether this is technically correct for your situation but here is an example.</p>

<pre><code>    int dacWrite(int level) {
#ifdef internaldac
        byte highbyte = (level &gt;&gt; 8) &amp; 0xFF;
        byte lowbyte = level &amp; 0xFF;
#endif 
    ...
    }
</code></pre>
",,37700321,604
30394529,2,30394108,2015-05-22T10:37:52.233,0,,750173,,2015-05-22T10:37:52.233,,0,,"<p>How about this?</p>

<pre><code>int wall_collision(Sprite *w_sprite)
{
  if(w_sprite-&gt;left &gt;= wall_sprite-&gt;right) return 0;
  if(w_sprite-&gt;right &lt;= wall_sprite-&gt;left) return 0;
  if(w_sprite-&gt;top &gt;= wall_sprite-&gt;bottom) return 0;
  if(w_sprite-&gt;bottom &lt;= wall_sprite-&gt;top) return 0;
  return 1;
}
</code></pre>

<p>Left/Right/Top/Bottom could be values or functions, or just replace them with the actual values. The ""left"" and ""top"" would be the same as the x/y value of the sprite or wall. The ""right"" and ""bottom"" would be the x/y + the width/height in pixels of the sprite or wall, respectively.</p>

<p>Take a look at this link for a more in-depth tutorial on simple collision detection: <a href=""http://lazyfoo.net/SDL_tutorials/lesson17/index.php"" rel=""nofollow"">http://lazyfoo.net/SDL_tutorials/lesson17/index.php</a></p>

<p><strong>EDIT:</strong> The example code assumes a coordinate system where x increases as you go right, and y increases as you go down.</p>
",,37709237,1448
30395081,2,30394108,2015-05-22T11:04:25.120,1,,4785453,,2015-05-22T11:15:53.360,2015-05-22T11:15:53.360,0,,"<p>First of all, you're code seems a little complex - below is canonical (or so I believe) method of detecting collisions.  With this function, instead of having to check each collision manually, we can detect any collision between colliders <code>A</code> and <code>B</code>.  Keep in mind, the <code>collider</code> struct used in this would have to contain information on the <code>top</code>, <code>bottom</code>, <code>left</code> and <code>right</code> co-ordinates on each collider.  You can then store all colliders in an array and then index through them to check for collisions.  The function:</p>

<pre><code>int collisionFunction(collider * A, collider * B){

    //Check to see if the colliders are ""lined up"" on the X-axis 
    if( (A-&gt;right &gt; B-&gt;left ) &amp;&amp; (B-&gt;right &gt; A-&gt;left) ){

        //Check to see if the colliders are also ""lined up"" on the Y-axis
        if( (A-&gt;top &lt; B-&gt;bottom) &amp;&amp; (B-&gt;top &lt; A-&gt;bottom) ){
            return 1; // COLLISION DETECTED
        }
    }

    return 0;//NO COLLISION DETECTED      
}
</code></pre>

<p><strong>Explanation of the function/algorithm:</strong> First of all, we check to see if <code>A</code> and <code>B</code> are ""lined up"" on the x axis.  By ""lined up"", I mean to say that two colliders could be colliding based off their position on the X-axis.  Then, we check to see if each collider is lined up on the Y-axis.  If both conditions are met, then the colliders are colliding.  <strong>It can be a little hard to grasp this at first so I suggest you trace this</strong> by drawing out shapes on paper (some colliding, others not) and see whether the algorithm says they're colliding or not.  This algorithm will work for coordinate systems where the origin (i.e. (0,0) ) is in the top left corner of the screen, <strong>which is the convention for 2D graphics</strong>.</p>

<p>Keep in mind that your player would go through the wall partially when using this algorithm - this is very common in 2D games.  But, given the number of pixels you're using, this could obviously be a problem.  Therefore, you should take that into account when implementing this algorithm.</p>
",,37751051,415
30405197,2,30404718,2015-05-22T20:15:04.893,3,,1076479,,2015-05-22T20:15:04.893,,3,,"<p>If you are doing this in an interrupt handler, why would you need different threads? It shouldn't matter what else you're doing, as long as interrupts are enabled.</p>

<p>As for FSM, I wouldn't call a ""detect_string"". RS232 is going to give you one character at a time. It's possible your UART interrupts you only when you've received more than one, but there's usually a time component as well so it would be unwise to count on that. Make your FSM take one input character at a time. Your states would be something like:</p>

<pre><code>=&gt; new state = [Init] (turn LED off if on)

Init: (Get 'O') =&gt; new state = [GotO]
Init: (Get anything else) =&gt; new state = [Init]
Init: (Timer expires) =&gt; who cares? new state = [Init]

GotO: (Get 'N') =&gt; new state = [GotON] (turn on LED, set timer)
GotO: (Get anything else) =&gt; new state = [Init]
GotO: (Timer expires) =&gt; who cares? new state = [GotO]

GotON: (Get anything) =&gt; who cares? new state = [GotON]
GotON: (Timer expires) =&gt; turn LED off, new state = [Init]
</code></pre>

<p>Obviously lots of tinkering you could do with details, but that's the general idea.</p>
",,37758512,103
30408076,2,30404718,2015-05-23T01:47:17.377,2,,3282056,,2015-05-23T01:56:20.770,2015-05-23T01:56:20.770,0,,"<p>A preemptive kernel will usually provide the ability for an interrupt to set an event that a higher priority thread is pending on. </p>

<p>As for the interrupts, one way of implementing something like a state machine is to use nested pointers to function, similar to an asynchronous callback, but with optional nesting: For example:</p>

<pre><code>typedef void (*PFUN)(void);
/* ... */
PFUN pFunInt = UnexpectedInt;   /* ptr to function for interrupt */
PFUN pFunIntSeqDone;
/* ... */
void DoSeq(void)
{
    pFunIntSeqDone = IntSeqDone;
    pFunInt = IntStep0;
    /* enable interrupt, start I/O */
}
void IntStep0(void)
{
    pFunInt = IntStep1;
    /* handle interrupt */
}
void IntStep1(void)
{
    pFunInt = IntStep2;
    /* handle interrupt */
}
void IntStep2(void)
{
    /* done with sequence, disable interrupt */
    pFunInt = UnexpectedInt;
    pFunIntSeqDone();    /* call end action handler */
}
void IntSeqDone(void)
{
    /* interrupt sequence done handling code */
    /* set event for pending thread */
}
void UnexpectedInt(void)
{
    /* ... error handling code */
}
</code></pre>
",,37769451,478
30834482,2,30413724,2015-06-14T20:59:53.893,0,,2197070,,2015-06-14T20:59:53.893,,0,,"<p>I had the same problem than you and the reason why <code>./RFSniffer &gt; rfsniffer.log</code> doesn't work is that printf() function in RFSniffer code is not flushed.</p>

<p>Try with this source code :</p>

<pre class=""lang-c prettyprint-override""><code>/*
  RF_Sniffer

  Hacked from http://code.google.com/p/rc-switch/

  by @justy to provide a handy RF code sniffer
*/

#include ""RCSwitch.h""
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

RCSwitch mySwitch;

int main(int argc, char *argv[]) {

     // This pin is not the first pin on the RPi GPIO header!
     // Consult https://projects.drogon.net/raspberry-pi/wiringpi/pins/
     // for more information.
     int PIN = 2;

     if(wiringPiSetup() == -1)
       return 0;

     mySwitch = RCSwitch();
     mySwitch.enableReceive(PIN);  // Receiver on inerrupt 0 =&gt; that is pin #2

     while(1) {

      if (mySwitch.available()) {

        int value = mySwitch.getReceivedValue();

        if (value == 0) {
          printf(""Unknown encoding"");
        } else {
          printf(""Received %i\n"", mySwitch.getReceivedValue() );
        }

        fflush(stdout); // Add this line to flush the previous printf()
        mySwitch.resetAvailable();

      }

  }

  exit(0);

}
</code></pre>

<p>And if you <strong>run the RFSniffer tool with sudo permission</strong>, you can execute with :</p>

<p><code>sudo ./RFSniffer | sudo tee rfsniffer.log</code></p>

<p><strong>OR</strong></p>

<p><code>sudo sh -c './RFSniffer &gt;&gt; rfsniffer.log'</code></p>
",,37780177,87
33357636,2,30424236,2015-10-26T23:54:22.230,7,,5491400,,2016-09-07T05:38:02.593,2016-09-07T05:38:02.593,0,,"<p>I just figured this out today thanks to Sebastian over at github.</p>

<p>Assuming that you have wiringPi installed, the easiest thing to do is to make a FindWiringPi.cmake with the following:</p>

<pre><code>find_library(WIRINGPI_LIBRARIES NAMES wiringPi)
find_path(WIRINGPI_INCLUDE_DIRS NAMES wiringPi.h)

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(wiringPi DEFAULT_MSG WIRINGPI_LIBRARIES WIRINGPI_INCLUDE_DIRS)
</code></pre>

<p>And then put this in the folder where cmake looks for it's modules. For Ubuntu it's /usr/share/cmake-2.x/Modules. It's basically the same path for pi too.</p>

<p>Then in your CMakeLists.txt file use:</p>

<pre><code># Locate libraries and headers
find_package(WiringPi REQUIRED)
find_package(Threads REQUIRED) 

# Include headers
include_directories(${WIRINGPI_INCLUDE_DIRS}) 

# Link against libraries
target_link_libraries(&lt;yourProjectName&gt; ${WIRINGPI_LIBRARIES}) 
target_link_libraries(&lt;yourProjectName&gt; ${CMAKE_THREAD_LIBS_INIT}) 
</code></pre>

<p>The pthread module is a stock package and should be on your system already. So then navigate to your folder and do a <code>cmake ./</code> and then <code>make</code>. If this doesn't work the first time, then remove your CMakeCache.txt with <code>rm CMakeCache.txt</code> and try again. MAKE SURE THAT YOU REMOVE THE CACHE AND NOT THE LIST!!</p>
",,37829430,834
55733527,2,30424236,2019-04-17T18:01:23.253,3,,6277051,,2019-04-17T18:01:23.253,,0,,"<p>Thanks for the QA, I figured out this can be done in a simpler manner (Raspberry Pi 3 Model B+) without altering anything in <code>/usr/share/cmake-x.y/Modules</code>. After your <code>add_executable</code> line, add the following</p>

<pre><code>find_library(WIRINGPI_LIBRARIES NAMES wiringPi)
target_link_libraries(&lt;executable_name&gt; ${WIRINGPI_LIBRARIES})
</code></pre>

<p>For example:</p>

<pre><code>cmake_minimum_required(VERSION 3.5)
project(OpenInsulin)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_VERBOSE_MAKEFILE ON)

# Include headers
include_directories(.)

add_executable(OpenInsulin
        main.cpp
        MCP9600.cpp
        MCP9600.h)

# Link against wiringPi
find_library(WIRINGPI_LIBRARIES NAMES wiringPi)
target_link_libraries(OpenInsulin ${WIRINGPI_LIBRARIES})
</code></pre>
",,37975604,261
30451131,2,30428872,2015-05-26T06:35:16.767,0,,3704293,,2015-05-26T06:45:37.367,2015-05-26T06:45:37.367,0,,"<p>You have to use another structure. At the moment your mainloop consists of many single for-loops, which were executed sequently. In order to realize a parallel execution (I think that is what you want) you need somethink like this:</p>



<pre class=""lang-c prettyprint-override""><code>int i;

void setup() {
    i=255;
//...
}

void loop() {
     i--;
     motor_shoulderx.setSpeed(i);
     motor_elbow.setSpeed(i);  
     if(i==0)i=255;   
}
</code></pre>

<p>If you need more complex logic you can easily realize that with conditions. If you need delays you have to use time-comparing code patterns like this:</p>



<pre class=""lang-c prettyprint-override""><code>unsigned long interval=1000;    // the time we need to wait
unsigned long previousMillis=0; // millis() returns an unsigned long.

void setup() {
//...
}

void loop() {
 if ((unsigned long)(millis() - previousMillis) &gt;= interval) {
 previousMillis = millis();
 // ... 
 }
}
//...
</code></pre>

<p>All in all, I think the important thing is that the main loop should not be delayed by the single for-statements. Hope this helps you.</p>
",,37979863,286
53209729,2,30439969,2018-11-08T14:25:38.907,0,,5397444,,2018-11-08T14:25:38.907,,0,,"<p>I'm not sure if the below what you mean (supposing that you are dealing with int type):</p>

<pre><code>int map(int value, int fromLow, int fromHigh, int toLow, int toHigh) {

int returnValue = 0;

if (value &lt;= fromLow) return toLow;
else if (value &gt;= fromHigh) return toHigh;
else {
    int fromDifference = fromHigh - fromLow;
    int toDifference = toHigh - toLow;

    returnValue = (value * static_cast&lt;int&gt;(toDifference / fromDifference)) + toLow;

return returnValue;
}
</code></pre>
",,38021241,131
30443850,2,30443394,2015-05-25T18:10:06.193,-3,,2632478,,2015-05-25T21:18:37.060,2017-05-23T10:26:53.063,8,,"<p>An option would be to declare your struct as: <br>
<code>typedef struct phOsal_RPi_DataParams_t
{
    ...
}phOsal_RPi_DataParams_t;</code><br>
Look here when your aliasing a struct with typedef at the declaration example:<br>
<a href=""http://en.wikipedia.org/wiki/Struct_(C_programming_language)#typedef"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Struct_(C_programming_language)#typedef</a></p>

<p>if you want to you the ""dataparams"" alias then do the following:<br></p>

<pre><code>typedef struct phOsal_RPi_DataParams_t
{

 ...
} dataparams;
</code></pre>

<p>Then in main.c ditch the struct and just declar it as:<br></p>

<pre><code>dataparams osal;
</code></pre>

<p>The ordering of where you declare it and your main may be wrong as the commenters suggested, and yes the include should be in """" keep that. Here's a good model to follow:<br>
<a href=""https://stackoverflow.com/questions/26308481/unknown-type-name-with-typedef-struct-in-c"">Unknown type name with typedef struct in C</a></p>

<p>Edited because of comments.</p>
",,38063578,448
30444620,2,30444454,2015-05-25T19:10:17.717,1,,4142924,,2015-05-25T19:24:30.987,2015-05-25T19:24:30.987,3,,"<p>Output ports are often readable, so where you have</p>

<pre><code>outportb(0x103, 0x10);                      // set b4
...
outportb(0x103, 0x11);                      // set b1 and b4
</code></pre>

<p>You can do, say</p>

<pre><code>outportb(0x103, 0x10);                      // set b4
...
outportb(0x103, inportb(0x103) | 0x01);     // set b0 too
</code></pre>

<p>But sometimes it is not recommended to read / modify / write an output port. Anyway it is cleaner to keep a copy of the output state, modify that, and write it to the port</p>

<pre><code>unsigned char bcopy = 0;                    // init port output
outportb(0x103, bcopy);
...
bcopy |= 0x10;                              // set b4
outportb(0x103, bcopy);
...
bcopy |= 0x01;                              // set b0
outportb(0x103, bcopy);
...
bcopy &amp;= 0xEF;                              // now clear b4
outportb(0x103, bcopy);
</code></pre>

<p>Or as one-liners:</p>

<pre><code>outportb(0x103, bcopy = 0);                 // init port
...
outportb(0x103, bcopy |= 0x10);             // set b4
...
outportb(0x103, bcopy |= 0x01);             // set b0
...
outportb(0x103, bcopy &amp;= 0xEF);             // now clear b4
</code></pre>
",,38081575,97
30466886,2,30458971,2015-05-26T19:08:16.193,5,,1053968,,2015-05-29T04:50:05.357,2015-05-29T04:50:05.357,4,,"<p>As far as I know, it is not possible to get this particular behavior with Boost.Asio.  While the kernel flags some files on the procfs and sysfs as pollable, they do not provide the stream-like behavior that is expected from <a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/posix__stream_descriptor.html"" rel=""nofollow""><code>boost::asio::posix::stream_descriptor</code></a> and its operations.  </p>

<p>Boost.Asio's epoll reactor is edge-triggered (see Boost.Asio 1.43 <a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/history.html#boost_asio.history.asio_1_4_5___boost_1_43"" rel=""nofollow"">revision history notes</a>).  Under certain conditions<sup>1</sup>, Boost.Asio will attempt the I/O operation within the context of the <em>initiating function</em> (e.g. <a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/async_read/overload3.html"" rel=""nofollow""><code>async_read()</code></a>).  If the I/O operation completes (success or failure), then the completion handler is posted into the <code>io_service</code> as-if by <code>io_service.post()</code>.  Otherwise, the file descriptor will be added to the event demultiplexer for monitoring.  The documentation alludes to this behavior:</p>

<blockquote>
  <p>Regardless of whether the asynchronous operation <strong>completes immediately</strong> or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post()</code>.</p>
</blockquote>

<p>For composed operations, such as <code>async_read()</code>, <a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/overview/core/streams.html#boost_asio.overview.core.streams.why_eof_is_an_error"" rel=""nofollow"">EOF is treated as an error</a>, as it indicates a violation in the operation's contract (i.e. completion condition will never be satisfied because no more data will be available).  In this particular case, the I/O system call will occur within the <code>async_read()</code> initiating function, reading from the start of the file (offset 0) to the end of file, causing the operation to fail with <code>boost::asio::error::eof</code>.   As the operation has completed, it is never added to the event demultiplexer for edge-triggered monitoring:</p>

<pre class=""lang-cpp prettyprint-override""><code>boost::asio::io_service io_service;
boost::asio::posix::stream_descriptor stream_descriptor(io_service);

void read_handler(const boost::system::error_code&amp; error, ...)
{
  if (error.value() == boost::asio::error::eof)
  {
    // Reset to start of file.
    lseek(sd.native_handle(), 0, SEEK_SET);
  }

  // Same as below.  ::readv() will occur within this context, reading
  // from the start of file to end-of-file, causing the operation to
  // complete with failure.
  boost::asio::async_read(stream_descriptor, ..., &amp;read_handler);
}

int main()
{
  int fd = open( /* sysfs file */, O_RDONLY);

  // This would throw an exception for normal files, as they are not
  // poll-able.  However, the kernel flags some files on procfs and
  // sysfs as pollable.
  stream_descriptor.assign(fd);

  // The underlying ::readv() system call will occur within the
  // following function (not deferred until edge-triggered notification
  // by the reactor).  The operation will read from start of file to
  // end-of-file, causing the operation to complete with failure.
  boost::asio::async_read(stream_descriptor, ..., &amp;read_handler);

  // Run will invoke the ready-to-run completion handler from the above
  // operation.
  io_service.run();
}
</code></pre>

<hr>

<p><sub>1. Internally, Boost.Asio refers to this behavior as <em>speculative</em> operations.  It is an implementation detail, but the I/O operation will be attempted within the initiating function if the operation may not need event notification (e.g. it can immediately attempt to a non-blocking I/O call), and and there are neither pending operations of the same type nor pending out-of-band operations on the I/O object.  There are no customization hooks to prevent this behavior.</sub></p>
",,38097160,571
30562302,2,30520252,2015-05-31T20:26:31.147,0,,2080712,,2015-05-31T20:26:31.147,,0,,"<p>So following @PaulOgilvie's idea I fixed the problem with the following code:</p>

<pre><code>if (BPY &gt;= 160 || BPY &lt;= 0) {//Goal Detection
    if (BPY &gt;= 160) {  
      playerScore = playerScore + 1;
    }
    else {
      computerScore = computerScore + 1;
    }
    DrawCourt(0);
    EsploraTFT.fillCircle(BPX, BPY, 7, ST7735_BLACK);
    EsploraTFT.fillRect(computerPaddle, 154, 32, 3, ST7735_GREEN);
    EsploraTFT.fillRect(1,0,126,15,ST7735_BLACK);
    EsploraTFT.fillRect(playerPaddle, 3, 32, 3, ST7735_GREEN);
    DisplayScore(playerScore, computerScore);
    BPX = 64;
    BPY = 80;
    EsploraTFT.fillCircle(BPX, BPY, 4, ST7735_GREEN);
    delay(3000);
    EsploraTFT.fillCircle(BPX, BPY, 7, ST7735_BLACK);
    byx = 80;
  }
</code></pre>

<p>Basically I just made a workaround drawing a big black rectangle on top of the whole thing.</p>
",,38111272,297
30529983,2,30524827,2015-05-29T12:44:58.107,1,,379311,,2015-05-29T13:01:20.310,2015-05-29T13:01:20.310,3,,"<p>Yes, the overflow interrupt could happen at any time (although it does happen regularly). So could the pin change interrupt. Each of them in this case only touch a single 8-bit volatile variable (<code>tot_overflow</code> and <code>pInt</code> respectively), which in turn are polled by your main loop. This construction doesn't really help you unless the main loop has other work to do which may take longer than one full timer period (256*8=2048 cycles in this case). </p>

<p>So instead of enabling interrupts, you could check GIFR bit PCIF (instead of pInt) and TIFR bit TOV1 in your main loop, which would get you more easily understood behaviour. Resetting them is a special case of writing a 1 to that bit and only that bit. This would save you time for the pin change interrupt, as the main loop check could happen more frequently and would not need the latency of jumping to the interrupt service routine. </p>

<p>It would not, however, fix your problem. You are trying to measure a pulse width, which on slightly larger AVRs is easily done using the timer input capture feature. The timers in the ATtiny85 don't have this feature. On AVRs that do, the input capture and timer overflow interrupts are arranged in such a way that the input capture interrupt can safely read the software driven overflow counter. </p>

<p>When you get a timer overflow, you increment tot_overflow, and when you've detected a pin change, you read TCNT1 to combine the values. These two counters, while one feeds the other, are not read at the same time. Your threshold values are 0x5d2 and 0x613. If the rollover occurs after reading tot_overflow but before reading TCNT1, you may well get a time like 0x501 at a time which should be 0x601. Similarly if you stop tot_overflow from updating. If you read TCNT1 before tot_overflow, you might get 0x6fe when you should have read 0x5fe. Simply put, there is no safe order - but there is a relation. What we need to know is if the overflow count value was up to date or not at the time the counter value was read. </p>

<pre><code>static uint8_t ovf;
if (TIFR &amp; 1&lt;&lt;TOV1) {
   TIFR = 1&lt;&lt;TOV1;   // Clear overflow flag
   ovf++;
}
if (GIFR &amp; 1&lt;&lt;PCIF) {
   GIFR = 1&lt;&lt;PCIF;   // clear pin change flag
   uint16_t timestamp = ovf&lt;&lt;8 | TCNT1;
   if (TIFR&amp;1&lt;&lt;TOV1 &amp;&amp; (timestamp&amp;0xff)&lt;0x80)
       timestamp += 0x100;   // Overflow had not been counted
   // Do what we like with the timestamp here
}
</code></pre>

<p>The key is that we check for an overflow after we have already loaded the timer value. If the overflow occurred before we read the value, the value read must be low; otherwise we want the old count. This particular sample actually relies on the overflow not being handled in an interrupt, but you can use the same method by enclosing the block in an interrupt masking. We need the two reads of TOV1 and ovf to match, and to read TOV1 after TCNT1. What we don't want is to have an interrupt process and thus clear TOV1 so that we can't infer the order of ovf and TCNT1. Note that using a pin change interrupt to do this logic grants us that automatically, since interrupt handlers run with interrupts disabled. </p>

<p>You won't get higher precision on your pulse widths than the latency variance for responding to the pin change, and in the code you've shown, the timer reset (which should also reset the prescaler, bit PSR1 in GTCCR). This usually means you do want to read the timer in the interrupt handler itself. We can also observe that you could choose a timer pace that makes your thresholds fit in the 8 bit value; for instance with timer1 running at 8MHz/64, your thresholds would be at 186 and 194, with an offset of 16-24µs. One might even do tricks like setting one threshold precisely at an overflow since the timer doesn't have to start at 0. </p>
",,38116924,545
30571201,2,30571009,2015-06-01T10:30:56.367,4,,2636457,,2015-06-01T11:06:50.537,2015-06-01T11:06:50.537,11,,"<p>One way is just to have a simple setup like so:</p>

<p>version.inc:</p>

<pre><code>""1.0.0rc1"";
</code></pre>

<p>main.cpp:</p>

<pre><code>const string version = 
#include ""version.inc""

...
</code></pre>

<p>Note that the newline between the <code>=</code> and the <code>#include</code> is in place to keep the compiler happy. Also, if you don't want to include the semicolon in the <code>.inc</code> file, you can do this:</p>

<p>main.cpp:</p>

<pre><code>const string version = 
#include ""version.inc""
; // Put the semicolon on a newline, again to keep the compiler happy
</code></pre>

<p><hr>
EDIT: Instead of a <code>.inc</code> file, you can really have any file extension you desire. It's all up to taste</p>

<p><hr>
EDIT: If you really wanted to, you could omit the quotes from the <code>.inc</code> file, but that would lead to messy code like this:</p>

<p>version.inc:</p>

<pre><code>STRINGIFY(
    1.0.0rc1
);
</code></pre>

<p>main.cpp:</p>

<pre><code>#define STRINGIFY(X) #X

const string version = 
#include ""version.inc""
...
</code></pre>

<p><hr>
EDIT:</p>

<p>As @Ôrel pointed out, you could handle the generation of a <code>version.h</code> or similar in your Makefile. Assuming you're running a *nix system, you could try a setup like this:</p>

<p>Makefile:</p>

<pre><code>...
# ""1.0.0rc1""; &gt; version.h
echo \""`cat version.inc`\""\; &gt; version.h
...
</code></pre>

<p>version.inc:</p>

<pre><code>1.0.0rc1
</code></pre>

<p>main.cpp:</p>

<pre><code>const string version = 
#include ""version.h""
</code></pre>
",,38145266,651
30576935,2,30575610,2015-06-01T15:05:58.170,0,,3100312,,2015-06-02T12:35:36.153,2015-06-02T12:35:36.153,7,,"<p>The more elegant code would be:</p>

<pre><code>int main() {
    int x[4][9];
    //...
    passwordCreate(x);
    //...
    return(0);
}

void passwordCreate(int x[4][9]) {
    int i;
    int a=9;
    int c=0;
    int space[a];
    while(c &lt; a) {
        for (i=0; i&lt;4; i++)x[i][c]= 0;
        if     (b1s==HIGH) x[0][c]= ++c;
        else if(b2s==HIGH) x[1][c]= ++c;
        else if(b3s==HIGH) x[2][c]= ++c;
        else if(b4s==HIGH) x[3][c]= ++c;
    }
}
</code></pre>

<p>(And use <code>=</code> for assignment, not <code>==</code>.)</p>

<p>(EDIT: shown how to call and return the array.)</p>

<p>Note: there is an infinite loop if all the bIs are low.</p>

<p>Note: only one of the bIs may be high at any time (any next bIs being high will be ignored)</p>
",,38147929,1585
30584444,2,30581285,2015-06-01T22:35:55.160,1,,1998269,,2015-06-01T22:35:55.160,,1,,"<p>It's ""Arduino.h"", not ""arduino.h"" so you should change the lines to:</p>

<pre><code>#ifndef _STRUCTS_h
#define _STRUCTS_h

#if defined(ARDUINO) &amp;&amp; ARDUINO &gt;= 100
    #include ""Arduino.h""
#else
    #include ""WProgram.h""
#endif

typedef struct {
    byte lastCountry;
    byte lastMode;
} Settings;

#endif
</code></pre>

<p>The next problem is your awkward include syntax?! I don't know this extern ""C"" stuff, but it should work by simply using:</p>

<pre><code>#include ""Structs.h""
</code></pre>

<p>without any boilder plate.</p>

<p>Just as a tip, when working with multiple files Arduino IDE, it's missing autocomplete and its *.ino garbage will get your project messy and ensure you to get compile problems from time to time. For multifile projects i would recommend using biicode(<a href=""http://docs.biicode.com/arduino/gettingstarted.html"" rel=""nofollow"">http://docs.biicode.com/arduino/gettingstarted.html</a>) with default c/++. </p>
",,38161060,124
30590716,2,30581285,2015-06-02T08:10:53.327,2,,4744142,,2015-06-12T13:28:22.140,2015-06-12T13:28:22.140,0,,"<p>As I said in a comment, the <em>langage de prédilection</em> for Arduino is C++, not C.</p>

<p>So is seems a good idea to comply to the C++ way of structuring your applications.  Forget the C way which often consists of workarounds for the lack of adequate mechanisms for clean programming in C. (not that C++ is perfect...).</p>

<p>So I restructured your sample code, which now shows how to define and use a library for the <code>Settings</code> type.</p>

<p>First start from the main ino file </p>

<pre><code>// StopLicht.ino

#include ""Settings.h""

Settings settings;

void setup()
{
   settings.read(); // doing it the OO way
}

void loop()
{
   // code here. does some stuff with 
   // settings.mode and settings.country
}
</code></pre>

<p>The <code>Settings</code> type is defined as a <code>struct</code> with 2 fields, and (here comes C++) a member function <code>read()</code> which acts on <code>Settings</code> :</p>

<pre><code>// Settings.h

#ifndef SETTINGS_H_INCLUDED
#define SETTINGS_H_INCLUDED

struct Settings 
{
  byte country; 
  byte mode;

  void read();   // to get values from EEPROM
};

#endif
</code></pre>

<p>And it is implemented in an ino file</p>

<pre><code>// Settings.ino

#include &lt;EEPROM.h&gt;

#include ""Settings.h""

void Settings::read() 
{
     country = EEPROM.read(0);
     mode    = EEPROM.read(1);
};
</code></pre>

<p>Remark: <code>Settings</code> could of course be written as a <em>class</em> instead of a <em>struct</em>. Not a big deal in this case.</p>
",,38172993,2376
30587579,2,30586884,2015-06-02T04:50:46.903,2,,21945,,2015-06-02T04:50:46.903,,0,,"<p>In your Python code, the first character of the data being read from the serial port is <code>'\xff'</code> in which case <code>json.dumps()</code> will throw the exception shown:</p>

<pre><code>&gt;&gt;&gt; json.dumps({'gps_c': '\xffblah'})
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 1, in &lt;module&gt;
  File ""/usr/lib64/python2.7/json/__init__.py"", line 243, in dumps
    return _default_encoder.encode(obj)
  File ""/usr/lib64/python2.7/json/encoder.py"", line 207, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File ""/usr/lib64/python2.7/json/encoder.py"", line 270, in iterencode
    return _iterencode(o, 0)
UnicodeDecodeError: 'utf8' codec can't decode byte 0xff in position 0: invalid start byte
</code></pre>

<p>The data read from the serial port looks corrupted - it should be 14 bytes long (6 lat + 6 lon + <code>','</code> + <code>'\n'</code>), however, the data printed shows that it is far longer than that.</p>

<p>I suspect that the baud rates are not properly matched. In your C/C++ code you set one port to 155200 and another (<code>SoftwareSerial</code>) to 9600. The Python code expects 9600. Are you sure that you have configured the correct speeds?</p>
",,38174727,977
30603442,2,30603334,2015-06-02T18:07:44.850,3,,4342498,,2015-06-02T18:07:44.850,2017-05-23T11:58:13.723,0,,"<p>In Timer.h you have:</p>

<pre><code>TimerAction* actions;
</code></pre>

<p>At the point in time that the compiler sees that line of code it has not seen what a <code>TimerAction</code> is.  As such it does not know what the type is and is giving you an error.  What you need to do is <a href=""https://stackoverflow.com/questions/4926105/what-is-forward-declaration-in-c"">forward declare</a> <code>TimerAction</code> before <code>Timer</code> so the compiler knows what it is doing.</p>

<pre><code>#ifndef _TIMER_h
#define _TIMER_h

#if defined(ARDUINO) &amp;&amp; ARDUINO &gt;= 100
    #include ""arduino.h""
#else
    #include ""WProgram.h""
#endif

struct TimerAction;

struct Timer {
//...
</code></pre>
",,38176121,148
30609712,2,30609696,2015-06-03T02:15:34.157,1,,296460,,2015-06-03T02:28:33.317,2015-06-03T02:28:33.317,3,,"<p>This looks like an issue with namespacing.
The compiler error tells you that the compiler wasn't able to find the name, the reason it couldn't was because the name <code>tft</code> is within the <code>STD</code> namespace here. You need to fix that or change how the code is designed.</p>

<p>Given that this is C++ I would change things a few things to make use of C++ language features:</p>

<pre><code>//get rid of some of the #defines
const int cs = 10;
const int dc = 8;

//Make a struct to contain info about the screens 
struct Screens {
    Adafruit_SSD1331 scr1;
    Adafruit_SSD1331 scr2;

    Screens():
       scr1(cs, dc, rst),
       scr2(cs2, dc2, rst)
    { }
};
</code></pre>

<p>Then you can just instantiate this class once in <code>setup</code> if this is using the Arduino convention. (Or place somewhere appropriate before you enter your main loop)</p>
",,38183840,3256
30649983,2,30640748,2015-06-04T17:05:05.993,0,,721269,,2015-06-04T17:05:05.993,,0,,"<p>Well, you can add two integers with <code>+</code>, so all you really need is a way to convert a string to an integer. The simplest is probably <code>sprintf</code>.</p>

<pre><code>int j;
char const* s;
sprintf(s, ""%d"", &amp;j);
</code></pre>

<p>If you don't want to use <code>sprintf</code>, you can trivially write your own routine:</p>

<pre><code>int stringToInt (char const *s)
{
    int i = 0;
    while (*s != 0)
    {
        i *= 10;
        i += (*s - '0');
        s++;
    }
    return i;
}
</code></pre>

<p>Note that this will return garbage unless <code>s</code> contains only a decimal integer expressed in base 10.</p>
",,38189676,1954
30741676,2,30686789,2015-06-09T19:58:14.183,0,,2887185,,2015-06-09T19:58:14.183,,0,,"<p>I found it !</p>

<p>It seems like on Raspbian, the communications were terminated by a NULL character. But not on Debian. And this NULL character was polluting my calculations of incomming buffer length. So i ended up by eventually suppress it on the Arduino side :</p>

<pre><code>boolean readCommand()
{
  // Reads the current buffer
  Serial.readBytes(cmd, 9);

  // If sender sends a null character, remove it.
  int test = Serial.peek();
  if (test == 0x00) {
    test = Serial.read();
  }

  // ...
}
</code></pre>
",,38218887,470
30713074,2,30708800,2015-06-08T15:20:55.307,0,,296460,,2015-06-08T15:20:55.307,,3,,"<p>Most of your attempts have the same issue, you have stored the pointer to the table in progmem but the actual table data itself (in this case the strings) are not stored in progmem. Unfortunately GCC attributes (as of gcc 4.7) only apply to the current declaration so you have to specify progmem on each variable.</p>

<p>So when you have</p>

<pre><code> const char message1[][2] PROGMEM = { ""Value 1"", ""Value 2"" };
</code></pre>

<p><code>message1</code> is stored in progmem but the strings <code>""Value 1""</code> are not. Further, if I recall correctly, avr-gcc compiler always stores string literals in SRAM. Even if you specify a place to put them in progmem it's still copied in SRAM (at one point I was trying to write a library to use the c++11 user defined string literals to put things in progmem but this was thwarting me). The 1 dimensional array solution also falls into this same problem.</p>

<p>To fix this you store everything explicitly in progmem, for example your 1D solution looks something like this:</p>

<pre><code>const char string_msg0_0[] PROGMEM = ""Value 1"";
const char string_msg0_1[] PROGMEM = ""Value 2"";

PGM_P strings_pgm_table[] PROGMEM = {string_msg0_0, string_msg0_1};

char buffer[MAX_STRING_SIZE];
strcpy_P(buffer, (PGM_P)pgm_read_word(&amp;(strings_pgm_table[i])));
</code></pre>

<p>I would recommend you have a look at the <a href=""http://www.nongnu.org/avr-libc/user-manual/pgmspace.html"" rel=""nofollow"">AVR-GCC tutorial putting data in progmem</a>.</p>
",,38235645,85
30756678,2,30755994,2015-06-10T12:41:52.850,1,,4952137,,2015-06-10T12:41:52.850,,0,,"<p>I think I finally got you, because your code is somehow confusing! As you wrote in the comment you get a <code>OK10</code> or <code>OKOO</code> because you are printing this in your code:</p>

<pre><code>...
client.println(""HTTP/1.1 200 OK"");
client.println(""Content-Type: text/html"");
client.println(""Connection: close"");  // the connection will be closed after completion of the response
client.println(""Refresh: 5"");  // refresh the page automatically every 5 sec
client.println();
client.println(""&lt;!DOCTYPE HTML&gt;"");
client.println(""&lt;html&gt;"");
client.println(""OK "");   //Prints OK of course
client.print(IsLed);     //Prints an int!!
client.print(Ledstatus); //Also prints an int!!
...
</code></pre>

<p>You Need to Change it to something like this:</p>

<pre><code>...
client.println(""HTTP/1.1 200 OK"");
client.println(""Content-Type: text/html"");
client.println(""Connection: close"");  // the connection will be closed after completion of the response
client.println(""Refresh: 5"");  // refresh the page automatically every 5 sec
client.println();
client.println(""&lt;!DOCTYPE HTML&gt;"");
client.println(""&lt;html&gt;"");
client.print(""OK "");   //Prints OK of course
if(Ledstatus == on)
    client.println(""ON"");
else
    client.println(""OFF"");
...
</code></pre>

<p>Also what I mentioned in the comments, you don't read line buffer from the Client but you are parsing it. It will be empty! I don't know about the API but there must be a function similar to</p>

<pre><code>client.read(linubuffer, 20);
</code></pre>
",,38267072,6463
30845241,2,30756790,2015-06-15T12:30:51.817,1,,463687,,2015-06-15T12:30:51.817,,1,,"<p>If you have nothing else to do during the pulse, you could use a busy
loop instead of interrupts:</p>

<pre><code>#include &lt;avr/io.h&gt;
#include &lt;util/delay_basic.h&gt;

/* Send a pulse of width = 4*count cycles. */
void pulse(uint16_t count, uint8_t channel)
{
    uint8_t mask     = 1 &lt;&lt; channel,
            old_port = PORTB,
            high     = old_port | mask,
            low      = old_port &amp; ~mask;

    PORTB = high;
    _delay_loop_2(count);
    PORTB = low;
}
</code></pre>

<p>This will give you a resolution of 4 clock cycles, or 0.5&nbsp;µs with a
8&nbsp;MHz clock.</p>

<p>Sending the pulses to the 5 servos should take at most 10&nbsp;ms. Since
you repeat the pulse train every 21&nbsp;ms, this leaves you 11&nbsp;ms
to compute the next set of positions, which should be plenty. You could
program a timer to wake you up every 21&nbsp;ms, then your <code>main()</code> may
look like:</p>

<pre><code>int main(void)
{
    static uint16_t pos[] = {4000, 3000, 3800, 2600, 3400};
    uint8_t i;

    /* Wake up every 21 ms. */
    setup_timer();
    sleep_enable();

    for (;;) {
        /* Update the servos. */
        for (i = 0; i &lt; 5; i++) pulse(pos[i], i);

        /* Compute the next set of positions. */
        ...

        /* Wait for timer interrupt. */
        sleep_cpu();
    }
}
</code></pre>
",,38278755,1172
30767044,2,30766975,2015-06-10T20:49:24.290,1,,1983957,,2015-06-10T20:57:21.567,2017-05-23T12:05:58.863,5,,"<p><strong>To convert each character to its respective int do the following</strong></p>

<pre><code>int first = message[11] - '0';
int second= message[12] - '0';
int third = message[13] - '0';
</code></pre>

<p>To see why this works, you can check here: <a href=""https://stackoverflow.com/questions/15598698/why-does-subtracting-0-in-c-result-in-the-number-that-the-char-is-representing"">Why does subtracting &#39;0&#39; in C result in the number that the char is representing?</a></p>

<p><strong>To concatenate ints, you could use this function</strong></p>

<pre><code>unsigned concatenate(unsigned x, unsigned y) {
     unsigned pow = 10;
     while(y &gt;= pow)
         pow *= 10;
     return x * pow + y;        
}
</code></pre>

<p>I did not write this function, it was written by @TBohne originally <a href=""https://stackoverflow.com/questions/12700497/how-to-concatenate-two-integers-in-c"">here</a> </p>
",,38292164,699
30767122,2,30766975,2015-06-10T20:54:27.043,1,,2797746,,2015-06-10T23:03:16.070,2015-06-10T23:03:16.070,1,,"<p>I'd go with:</p>

<pre><code>char *partMessage = (char*)malloc(4);
partMessage[3] = '\0';
strncpy(partMessage, message + 11, 3);
result = (int)strtol(partMessage, NULL, 10);
free(partMessage);
</code></pre>
",,38372030,7337
30767312,2,30766975,2015-06-10T21:07:00.360,0,,45685,,2015-06-10T21:12:06.473,2015-06-10T21:12:06.473,0,,"<p>you could try something like this</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  // example
  char message[] = { ""000255000"" };
  int r=0, g=0, b=0;

  // make sure right number of values have been read
  if ( sscanf(message, ""%03d%03d%03d"", &amp;r, &amp;g, &amp;b ) == 3 )
  {
    printf( ""R:%d, G:%d, B:%d\n"", r,g,b );
  }
  else
  {
    fprintf(stderr, ""failed to parse\n"");
  }
}
</code></pre>

<p>sscanf will skip any white space so even a string like <code>message[] = "" 000 255 000 "";</code> will work.</p>
",,38381521,387
30767508,2,30766975,2015-06-10T21:19:39.497,0,,2192494,,2015-06-10T21:19:39.497,,0,,"<p>Just do the conversion manually:</p>

<pre><code>int convert_digits(char *cp, int count) {
    int result = 0;
    for (int i = 0; i &lt; count; i += 1) {
        result *= 10;
        result += (cp[i] - '0');
    }
    return result;
}

char *input = ""000045255"";

int main(int ac, char *av[]) {
    printf(""r=%d g=%d, b=%d\n"",
        convert_digits(cp, 3),
        convert_digits(cp+3, 3),
        convert_digits(cp+6, 3));
}
</code></pre>
",,38417516,2236
30767681,2,30766975,2015-06-10T21:33:07.433,0,,2410359,,2015-06-10T21:33:07.433,,0,,"<p>Convert string to a number and then numerically peal off 3 digits at a time.</p>

<pre><code>const char *s = ""000255000"";
char *endptr;
unsigned long num = strtoul(s, &amp;endptr, 10);

// add error checking on errno, num, endptr) here if desired.

blue = num%1000;
num /= 1000;
green = num%1000;
num /= 1000;
red = num%1000;

// Could add check to insure r,g,b &lt;= 255.
</code></pre>
",,38425750,193
30806713,2,30805621,2015-06-12T15:21:56.137,11,,1629821,,2015-06-12T15:42:14.170,2015-06-12T15:42:14.170,2,,"<p>Given the code link in your question, it seems the problem is here:</p>

<blockquote>
<pre><code>Serial::Serial(char *portName)
{
    ...

    this-&gt;hSerial = CreateFile(portName,  // &lt;--- ERROR
</code></pre>
</blockquote>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx"" rel=""noreferrer""><code>CreateFile</code> is a Win32 API that expects an <code>LPCTSTR</code> as first string parameter</a> .</p>

<p><code>LPCTSTR</code> is a Win32 typedef, which is expanded to:</p>

<ul>
<li><code>const char*</code> in ANSI/MBCS builds</li>
<li><code>const wchar_t*</code> in Unicode builds (which have been the default since VS2005)</li>
</ul>

<p>Since you are using VS2010, probably you are in the default Unicode build mode. </p>

<p>Actually, there is no ""physical"" <code>CreateFile</code> API exposed, but there are two distinct functions: <code>CreateFileA</code> and <code>CreateFileW</code>. The former takes a <code>const char*</code> input string, the latter takes a <code>const wchar_t*</code>.</p>

<p>In Unicode builds, <code>CreateFile</code> is a preprocessor macro expanded to <code>CreateFileW</code>; in ANSI/MBCS builds, <code>CreateFile</code> is expanded to <code>CreateFileA</code>.</p>

<p>So, if you are in Unicode build mode, your CreateFile call is expanded to <code>CreateFileW(const wchar_t*, ...)</code>. Since <code>portName</code> is defined as a <code>char*</code>, there is a mismatch between <code>wchar_t*</code> and <code>char*</code>, and you get a compiler error.</p>

<p>To fix that, you have some options.</p>

<p>For example, you could be explicit in your code, and just call <strong><code>CreateFileA()</code></strong> instead of <code>CreateFile()</code>. In this way, you will be using the ANSI/MBCS version of the function (i.e., the one taking a <code>const char*</code>), independently from the actual ANSI/MBCS/Unicode settings in Visual Studio.</p>

<hr>

<p>Another option would be to change your current build settings from the default Unicode mode to ANSI/MBCS. To do that, you can follow the path:</p>

<pre><code>Project Properties | Configuration Properties | General | Character Set
</code></pre>

<p>and select <strong>""Use Multi-Byte Character Set""</strong>, as showed in the following screenshot:</p>

<p><img src=""https://i.stack.imgur.com/aE54Y.png"" alt=""Setting Multi-Byte Character Set in VS2010 IDE""></p>
",,38497603,387
30806829,2,30806085,2015-06-12T15:28:44.757,0,,1678764,,2015-06-12T15:28:44.757,,0,,"<p>For parsing strings using a delimeter, consider using strtok.  You should create a buffer that your Serial reads into, then parse that</p>

<pre><code>char buffer[50];
uint8_t bufferReadIndex = 0;
while (Serial.available() &gt; 0) {
    buffer[bufferReadIndex++] = Serial.read();
}
char* stringPtr;
stringPtr = strtok(&amp;buffer, "","");
while (stringPtr != NULL)
{
    Serial.println(stringPtr);
    stringPtr = strtok(NULL, "","");
}
</code></pre>
",,38501650,1375
30893487,2,30849421,2015-06-17T13:44:57.167,-1,,4929456,,2015-06-17T13:44:57.167,,0,,"<p>Setting up the wrong Baudrate in the setup function is giving wrong output.</p>

<pre><code> lLastError = serial.Setup(CSerial::EBaud115200,CSerial::EData8,CSerial::EParNone,CSerial::EStop1);
</code></pre>

<p>and also</p>

<pre><code>std::ofstream output_file;
        //Creating a text file
        output_file.open(""save_test.txt"", std::ios_base::app);
            //writing data to text file
                output_file /*&lt;&lt; ""Data: ""*/ &lt;&lt; szBuffer;
</code></pre>

<p>instead of this code below (which will overwrite the text file everytime and no data is seen)</p>

<pre><code>  //writing data to text file
                    std::ofstream o(""save.txt"");
                    o &lt;&lt; ""Data: "" &lt;&lt; szBuffer &lt;&lt; std::endl &lt;&lt; ""BytesRead: "" &lt;&lt;dwBytesRead &lt;&lt;std::endl;
</code></pre>

<p>will append the data to the text file, which will give the complete data which is transmitted by RS232 can be seen in the text file.</p>
",,38533480,1245
30855421,2,30855330,2015-06-15T21:40:19.843,3,,1413395,,2015-06-15T21:53:21.123,2015-06-15T21:53:21.123,2,,"<p>You have missed to specify the parameter types in your function definition according to your constructor function declaration:</p>

<pre><code>Sonar(int,int,int,int); // Declaration
</code></pre>

<hr>

<pre><code>Sonar::Sonar(int trigLeft, int echoLeft, int trigRight, int echoRight) {
          // ^^^           ^^^           ^^^            ^^^
    // ...
}
</code></pre>

<p>Since the corresponding class member variables are declared as <code>const</code></p>

<pre><code>    const int triggerPinLeft,echoPinLeft,triggerPinRight,echoPinRight;
 // ^^^^^  
</code></pre>

<p>they'll need to be initialized using the constructors member initializer list:</p>

<pre><code>Sonar::Sonar(int trigLeft, int echoLeft, int trigRight, int echoRight) 
: triggerPinLeft(trigLeft)
, echoPinLeft(echoLeft)
, triggerPinRight(trigRight)
, echoPinRight(echoRight) {
}
</code></pre>

<p>That's the only way you can do it.</p>
",,38548926,1092
30858448,2,30858032,2015-06-16T03:49:47.167,2,,1684426,,2015-06-16T20:01:09.963,2015-06-16T20:01:09.963,2,,"<p>Keep your connect command outside of the loop</p>

<pre><code>$mysqli = new mysqli(""localhost"", ""my_user"", ""my_password"", ""world"");
if (!$mysqli) {
 fprintf(stderr, ""1 \n"");
 finish_with_error(con);
}
</code></pre>

<p>Then start the loop, you dont need to connect everytime you loop:</p>

<pre><code>while (1+1 = 2){
 if (!$mysqli){ 
  $mysqli = new mysqli(""localhost"", ""my_user"", ""my_password"", ""world"");
 }
 uint32_t intVal;
 sscanf(&amp;sn_str[1],""%x"",&amp;intVal);
 fprintf(stderr, ""valor: %x   %d\n"", intVal, intVal);
 if ($mysqli-&gt;query(""INSERT INTO `Order2Dock`.`Actividad`(`TiempoInicio`,`Proceso_Id`, `Orden_Id`) VALUES (now(),1,1)"") === TRUE) {
  echo '&lt;p&gt;Yeah, another query!!&lt;/p&gt;';
 }
}
</code></pre>

<p>Edit: I just added a condition to test if the link is still up, otherwise re-connect to the database.</p>

<p>I was just thinking that if this is an infinite loop running over a Web server like apache or IIS... then something must be configured in order to let the script run forever instead and prevent the web server from timing it out.</p>

<p>Cheers.</p>
",,38552359,1344
30858953,2,30858500,2015-06-16T04:42:46.053,0,,,user2517419,2015-06-16T04:42:46.053,,0,,"<p>I assume that pint 9 is LSD and pin 2 is MSD, try following code. </p>

<pre><code>LEDControlLoop(){

    int x = 0;
    int delaytime = 500;
    DDRD = B11111111; // sets port d as output

    while(1){ // infinte while loop,
        PORTD = x;
        delay(delaytime);
        x++;
        if(x&gt;255){
            x = 0;
            //break; //optional
        }   
    }
}
</code></pre>
",,38638045,937
30872155,2,30871851,2015-06-16T15:37:58.870,5,,981959,,2015-06-16T15:51:49.960,2015-06-16T15:51:49.960,1,,"<p>The problem is the the output is being buffered by the stdio library, you need to flush the output stream to make it appear immediately:</p>

<pre><code>    std::cout &lt;&lt; ""OK "" &lt;&lt; std::flush;
</code></pre>

<p>Your solution is very inefficient because it does a busy loop, constantly re-checking the system time between intervals.</p>

<p>I would use a single call to get the time, and then <a href=""http://en.cppreference.com/w/cpp/thread/sleep_until"" rel=""nofollow""><code>this_thread::sleep_until()</code></a> to make the program block until you want to run the script again:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;chrono&gt;
# include &lt;thread&gt;

int main()
{
  std::chrono::milliseconds period(100);
  auto next = std::chrono::high_resolution_clock::now() + period;
  while (true)
  {
    std::this_thread::sleep_until(next);
    next += period;
    // std::system(""php run.php"");
    std::cout &lt;&lt; ""OK "" &lt;&lt; std::flush;
  }
}
</code></pre>

<p>Since you're using C++14 you could also use the <a href=""http://en.cppreference.com/w/cpp/chrono/operator%22%22ms"" rel=""nofollow""><code>operator""""ms</code> literal</a> to simplify the declaration of <code>period</code>:</p>

<pre><code>using namespace std::literals::chrono_literals;
auto period = 100ms;
</code></pre>

<p>Or, more similar to the answer you found, instead of using a variable that represents 100ms you can define a type that represents that duration and then add units of that type (instead of 100 units of type <code>milliseconds</code>) to the <code>next</code> value:</p>

<pre><code>// a type that represents a duration of 1/10th of a second
using period = std::chrono::duration&lt;long, std::ratio&lt;1, 10&gt;&gt;;
auto next = std::chrono::high_resolution_clock::now() + period(1);
while (true)
{
  std::this_thread::sleep_until(next);
  next += period(1);
  ...
}
</code></pre>
",,38638421,161
30944110,2,30943229,2015-06-19T17:35:29.070,0,,259032,,2015-06-19T17:35:29.070,,7,,"<p>If you aren't worried about really tight timing, the easy solution is to use the delay function. <a href=""http://www.arduino.cc/en/Reference/Delay"" rel=""nofollow"">http://www.arduino.cc/en/Reference/Delay</a> </p>

<p>The following might be a simple sketch that would do what you want. Adjust it as needed.</p>

<pre><code>void setup()
{
  Serial.begin(9600); // initialize serial routines
}

void loop()
{
int a = analogRead(0);  // read the value of lightness
  Serial.println(a);      // tell processing what the value is
  delay(5000);          // wait for a 5 seconds
}
</code></pre>
",,38643407,113
30944991,2,30943229,2015-06-19T18:30:29.237,0,,4541045,,2015-06-19T18:38:54.600,2015-06-19T18:38:54.600,0,,"<p>I believe what you're looking for is called a ""state machine"".</p>

<p>Make a variable that you can use to store a time value, then compare that to the current time to see if 5s have passed.</p>

<pre><code>uint32_t last_trigger = 0; // millis() returns an unsigned, 32-bit integer

void setup()
{
    Serial.begin(9600);
}

void loop()
{
    if (millis() - last_trigger &gt; 5000) { // 5000 milliseconds
        last_trigger = millis(); // update last_trigger
        Serial.print(""last triggered at ""); // report findings
        Serial.print(last_trigger);
        Serial.println("" milliseconds"");    
    }
}
</code></pre>

<p><a href=""http://www.arduino.cc/en/Reference/Millis"" rel=""nofollow"">http://www.arduino.cc/en/Reference/Millis</a></p>
",,38659146,810
31079468,2,31075798,2015-06-26T18:04:48.420,2,,655436,,2016-06-07T17:29:47.113,2016-06-07T17:29:47.113,3,,"<p>Did you add crc.c into your arduino project?</p>

<p>Either wrap your include of crc.h with extern ""C"" or rename the crc.c into crc.ino:</p>

<pre><code>extern ""C"" {
    #include ""crc.h""
}

void setup() {
    crcsum((const unsigned char*)""0123456789"", 50000, 4);  
}
</code></pre>

<p>The compiled function name would be different between C and C++. <code>crcsum(...)</code> name after C compiler would be just _crcsum. After c++ compiler the name would be something like <code>crcsum__Fcii</code>. extern ""C"" just tells compiler to expect these names to be in C format.</p>
",,38667981,67
31094551,2,31094177,2015-06-27T23:23:18.007,2,,3959454,,2015-06-27T23:23:18.007,,1,,"<p>The library you use is written in a strange way. In the file <code>DigiKeyboard.h</code> there are such definitions as (comments mine):</p>

<pre><code>// Declares a global variable.
// If you include this file in more than one cpp file it will cause linker error.
DigiKeyboardDevice DigiKeyboard = DigiKeyboardDevice();

// Defines a non-inline function
// Again, multiple definitions error if the file is included in several source files.
uchar usbFunctionSetup(uchar data[8]) {
    // code
}
</code></pre>

<p>So you have to use it by including this .h file into only one of .cpp files.</p>
",,38670667,64
31103492,2,31103000,2015-06-28T18:49:40.733,0,,905902,,2015-06-28T18:49:40.733,,0,,"<p>Minimal approach to buffering. You should probably check the contents of the buffer before returning valid (is there a final \n ? )</p>

<pre><code>char read_rfid(char* rfid_num) {
    fd_set input_fdset;
    ssize_t length;
    int done;

    for(done=0; done &lt; 14; ) {
        FD_ZERO(&amp;input_fdset);
        FD_SET(fd,&amp;input_fdset);

        if(select(fd+1 ,&amp;input_fdset, NULL,NULL,NULL) == -1) {
            if (errno == EAGAIN) continue;
            perror(""Terminal select() failed"");
            return -1;
            }

        if(FD_ISSET(fd,&amp;input_fdset)) {
            if((length = read(fd,rfid_num+done,14-done)) == -1) {
                if (errno == EAGAIN) continue;
                perror(""Terminal: read() failed"");
                return -1;
                }
            write(STDOUT_FILENO,rfid_num+done,length);
            done += length;
        }
    }
return 0;
}
</code></pre>

<p>Note: I don't understand why this function returns <code>char</code>.</p>
",,38673748,662
31166790,2,31165566,2015-07-01T16:22:49.863,0,,1101001,,2015-07-06T22:28:11.060,2015-07-06T22:28:11.060,3,,"<p>Since you would like to get better at programming, I would recommend starting by being more descriptive with your variables.  For example, <code>flag</code> doesn't really describe what that variable is doing.  It really resembles a timer, so why not call it <code>timer_100ms</code>?  Then you know exactly what that variable is for.</p>

<p>I would also recommend using an enumeration for <code>case</code> statements so that what you are trying to accomplish is a little more clear.  For example:</p>

<pre><code>/* This timer is incremented every 100ms by the interrupt. */
int timer_100ms;

void blink (int how_many_times, int duration)
{
    enum
    {
        ELAPSED_TIME_200MS = 2,
        ELAPSED_TIME_400MS = 4,
        /* Fill in other values */
        ELAPSED_TIME_1200MS = 12
    };

    if (how_many_times &gt;= 1)
    {
        switch (timer_100ms)
        {
            case ELAPSED_TIME_200MS:
                LED_ON;
                break;

            case ELAPSED_TIME_400MS:
                LED_OFF;
                break;
        }
    }

    /* The rest of your code follows... */
}
</code></pre>

<p>Doing this makes your code a lot more readable.</p>

<p>That being said, to make your code more scalable - with the ability to create more LED blinks without adding more code - I would recommend starting with something like the following:</p>

<pre><code>void blink (int number_of_blinks, int delay_between_blinks_in_seconds)
{
    #define ELAPSED_TIME_200MS  2

    static int blink_count = 0;
    static int timer_prev_100ms = 0;

    /* If the delay has been satisfied, start blinking the LED. */
    if (timer_100ms &gt;= (delay_between_blinks_in_seconds * 10))
    {
        /* Change the state of the LED every 200ms. */
        if ((timer_100ms - timer_prev_100ms) &gt;= ELAPSED_TIME_200MS)
        {
            timer_prev_100ms = timer_100ms;

            if (led_is_on())
            {
                LED_OFF;
                blink_count++;
            }
            else
            {
                LED_ON;
            }
        }

        if (blink_count &gt;= number_of_blinks)
        {
            timer_100ms      = 0;
            timer_prev_100ms = 0;
            blink_count      = 0;
        }
    }
}
</code></pre>

<p>Obviously, you would need to add the <code>led_is_on()</code> function to check the state of the pin you are using to flash the LED.  Since, I don't know how you have your LED wired, I didn't want to assume how that would be done.  It is very simple to implement though.</p>
",,38696032,261
31177557,2,31175395,2015-07-02T06:57:53.260,0,,3861548,,2015-07-02T06:57:53.260,,8,,"<p>This code isn't inside any function:</p>

<pre><code>read.Serial(searchedItem);
</code></pre>

<p>Moreover, the function is <code>Serial.read</code>. And you need to ensure that there are available data in the buffer with <code>Serial.available()</code>
Try something like that inside <code>loop()</code>:</p>

<pre><code>if (Serial.available() &gt; 0) {
    // read the incoming byte:
    incomingByte = Serial.read();
    //Your code here
}
</code></pre>
",,38708837,164
31201395,2,31200835,2015-07-03T07:47:52.807,1,,584518,,2015-07-03T08:27:06.600,2015-07-03T08:27:06.600,8,,"<p>First of all, it doesn't make any sense to increase the buffer size with 2 bytes if you want to add two 16 bit numbers == 4 bytes. I would suggest you do something like this:</p>

<pre><code>typedef union
{
  struct s
  {
    AccelerationReading accelData;
    uint16_t shortflexposition;
    uint16_t longflexposition;
  };
  uint8_t raw_data [sizeof(struct s)];
} my_data;


// use whatever compile-time assert you have available to check for padding:
static_assert(sizeof(my_data) == sizeof(AccelerationReading) + 2*sizeof(uint16_t), 
              ""Unwanted padding detected."");


my_data data;
data.accelData.xAxis = x;
data.accelData.yAxis = y;
data.accelData.ZAxis = z;
data.shortflexposition = something;
data.longflexposition  = something;

my_data some_other_data = data; // equivalent of memcpy
</code></pre>

<p>If you need to access the data byte by byte, you simply use <code>data.raw_data[i]</code> instead.</p>

<hr>

<p>If you are using an old compiler, you will have to change the code to:</p>

<pre><code>typedef union
{
  struct s
  {
    AccelerationReading accelData;
    uint16_t shortflexposition;
    uint16_t longflexposition;
  } my_compiler_is_old;
  uint8_t raw_data [sizeof(struct s)];
} my_data;

data.my_compiler_is_old.accelData.xAxis = x;
data.my_compiler_is_old.accelData.yAxis = y;
...
</code></pre>
",,38724187,664
31206025,2,31204950,2015-07-03T11:43:10.920,0,,270654,,2015-07-03T12:13:56.517,2015-07-03T12:13:56.517,0,,"<p>As long as the predicate in <code>PT_WAIT_UNTIL</code> (i.e. <code>digitalRead(yMaxLimitLeft)==HIGH</code>) is true, execution will be stuck in that while loop.</p>

<p>The code probably becomes easier to reason about if <code>loop()</code> <em>only</em> is responsible for keeping the protothreads running. If we move the initial enabling of the relays into <code>setup()</code>, <code>runLeft/Right</code> can be rewritten to contain <em>all</em> logic related to a certain switch+relay. In that case, a second <code>PT_WAIT_UNTIL</code> statement can be used to wait for the switch to open again.</p>

<pre><code>#include &lt;pt.h&gt;

#define yMaxLimitLeft 8 //these are the limit switches that control the relays
#define yMaxLimitRight 9 //these are the limit switches that control the relays
#define leftRelay 4
#define rightRelay 5

static struct pt pt1, pt2; // each protothread needs one of these



void setup() {
  Serial.begin(9600);
  PT_INIT(&amp;pt1);  // initialise the two
  PT_INIT(&amp;pt2);  // protothread variables
  pinMode(leftRelay, OUTPUT);  //set pins     
  pinMode(rightRelay, OUTPUT);
  pinMode(yMaxLimitLeft,INPUT);
  pinMode(yMaxLimitRight,INPUT);    

  digitalWrite(leftRelay, HIGH);//enable relays
  digitalWrite(rightRelay, HIGH);//enable relays

}

void loop() {

  runLeft(&amp;pt1); //protothreads that controls relay number 1
  runRight(&amp;pt2); //protothreads that controls relay number 2

}

/////////////////////////////////////////////////////////////////////////////
// This function controls the left relay
static int runLeft(struct pt *pt) {

  PT_BEGIN(pt);

  while(1) {

    PT_WAIT_UNTIL(pt, digitalRead(yMaxLimitLeft)==HIGH); //wait until the switch is closed
    Serial.println(""left off""); 
    digitalWrite(leftRelay, LOW);//disable relay

    PT_WAIT_UNTIL(pt, digitalRead(yMaxLimitLeft)==LOW); //wait until the switch opens again
    digitalWrite(leftRelay, HIGH);//enable relay

  }   

  PT_END(pt);
}


//this function controls the right relay
static int runRight(struct pt *pt) {
  PT_BEGIN(pt);

    while(1){

      PT_WAIT_UNTIL(pt, digitalRead(yMaxLimitRight)==HIGH); //wait until the switch is closed
      Serial.println(""Right off"");   
      digitalWrite(rightRelay, LOW);//disable relay

      PT_WAIT_UNTIL(pt, digitalRead(yMaxLimitRight)==LOW); //wait until the switch opens again
      digitalWrite(rightRelay, HIGH);//enable relay
    }


  PT_END(pt);
}
</code></pre>
",,38729657,220
31221738,2,31221212,2015-07-04T14:28:17.897,1,,694576,,2015-07-04T14:57:19.373,2015-07-04T14:57:19.373,0,,"<p>If <code>header:data</code> is the only use case you have you want to look for <code>strchr()</code>.</p>

<p>Example:</p>

<pre><code>#include &lt;string.h&gt; /* for strchr() and strlen() */
#include &lt;errno.h&gt; /* for EINVAL */

int get_header_and_data(const char * input, char ** pheader, char ** pdata)
{
  int result = 0;

  if (NULL == input  
      || NULL == pheader || NULL == *pheader 
      || NULL == pdata || NULL == *pdata 
  )
  {
    /* Trivial case of ""no"" input and/or missing references to store the result. */
    errno = EINVAL;
    result = -1;
  }
  else
  {
    char * pcolon = strchr(input, ':');
    if (NULL == pcolon) 
    {
      /* No delimiter found. */
      errno = EINVAL;
      result = -1;
    }
    else
    {
      /* Delimiter found. */
      if (pcolon == input) 
      {
        /* No header found. */
        errno = EINVAL;
        result = -1;
      }
      else 
      {
        if (1 == strlen(pcolon)) 
        {
          /* No data found. */
          errno = EINVAL;
          result = -1;
        }
        else
        {
          /* Success. */
          *pcolon = '\0';

          ++pcolon;

          (*data) = pcolon;
          (*pheader) = input;
        }
      }
    }
  }

  return result;
}
</code></pre>

<p>and use it like this:</p>

<pre><code>#include &lt;stdio.h&gt;  

int get_header_and_data(const char *, char **, char **);

...

char content[50] = """";

 /* Load content here. */

char * header = NULL;
char * data = NULL;
if (-1 == get_header_and_data(content, &amp;header, &amp;data)
{
  perror(""get_header_and_data() failed."");
  abort(); /* Or what ever to handle the error. */
}
else
{
  /* Dereference and/or use header and data here .*/
}
</code></pre>

<p>Please not that on success <code>header</code> and <code>data</code> (still) refer to the memory of <code>content</code>, as well as that on success the latter is modifed.</p>

<hr>

<p>Just for fun, the code above can be shrunk down to:</p>

<pre><code>int get_header_and_data(const char * input, char ** pheader, char ** pdata)
{
  int result = 0;

  if (NULL == input  
    || NULL == pheader || NULL == *pheader 
    || NULL == pdata || NULL == *pdata 
  )
  {
    /* Trivial case of ""no"" input and/or missing references to store the result. */
    errno = EINVAL;
    result = -1;
  }
  else
  {
    char * pcolon = strchr(input, ':');
    if (NULL == pcolon /* No delimiter found. */
      || pcolon == input /* No header found. */
      || 1 == strlen(pcolon) /* No data found. */
    )
    {
      errno = EINVAL;
      result = -1;
    }
    else
    {
      /* Success. */
      *pcolon = '\0';
      ++pcolon;

      (*data) = pcolon;
      (*pheader) = input;
    }
  }

  return result;
}
</code></pre>
",,38730611,1372
31258493,2,31246457,2015-07-07T01:51:12.003,2,,1625380,,2015-07-07T01:51:12.003,,0,,"<pre><code>using System;

public class Program
{
    public static void Main()
    {
        var stringToCheck = ""hi there"";

        Console.WriteLine(""Checksum for "" + stringToCheck + "": "" + CalcChecksum(stringToCheck, stringToCheck.Length));
    }

    static int CalcChecksum(string packet, int packetLength)
    {
        char checksum = (char)0;

        for (int i = 0; i &lt; packetLength; i++)
        {
            checksum ^= packet[i];
        }

        return checksum;
    }
}
</code></pre>

<p><a href=""https://dotnetfiddle.net/6icpvv"" rel=""nofollow"">https://dotnetfiddle.net/6icpvv</a></p>
",,38741577,724
31373946,2,31373909,2015-07-13T00:32:16.610,2,,106104,,2015-07-13T00:32:16.610,,1,,"<p>You can't create an object without calling its constructor. Because a <code>StateController</code> is also a <code>DataControl</code>, you can't create one without calling <code>DataControl</code>'s constructor (as well as <code>StateController</code>'s). But that constructor takes an argument, so the compiler can't add the call for you.</p>

<p>The way to call a base class's constructor is to modify the derived class's constructor like so:</p>

<pre><code>StateController::StateController(CDOS_Info *inputtedInfo)
    : DataControl(inputtedInfo) // calls DataControl's constructor
{
   // info = inputtedInfo; // Don't need this, because DataControl's constructor does it.
   userInput = InputInterface();
   dataControl = DataControl(info);
   lightController = LEDController();
}
</code></pre>

<p>Pay attention to the weird syntax - this is not exactly a normal function call. And yes, it <em>does</em> go outside the curly brackets.</p>
",,38742326,208
33191204,2,31374104,2015-10-17T20:21:19.327,0,,5109129,,2015-10-17T21:24:14.313,2015-10-17T21:24:14.313,1,,"<p>I resolved it on my own using strok() function</p>

<pre><code>{
     const char *delim  = ""("";   //a '(' is the delimiter
     const char *delim1  = "","";
     const char *delim3  = "")"";
     char *text;
     char *firstItem;
     char *secondItem;
     char *thirdItem;
     char *fourthItem;
     char *fivethItem;
     char *sixthItem;
     char *seventhItem;
     char *eighthItem;
     text = strtok(password,delim);
     firstItem = strtok(NULL,delim1);
     secondItem = strtok(NULL,delim3);
     secondItem++;
     thirdItem = strtok(NULL,delim1);
     thirdItem++;
     fourthItem = strtok(NULL,delim3);
     fourthItem++;
     fivethItem = strtok(NULL,delim1);
     fivethItem++;
     sixthItem = strtok(NULL,delim3);
     sixthItem++;
     polyX[0] = atof(firstItem);
     polyY[0] = atof(secondItem);
     polyX[1] = atof(thirdItem);
     polyY[1] = atof(fourthItem);
     polyX[2] = atof(fivethItem);
     polyY[2] = atof(sixthItem);
     memset (password,NULL,sizeof(password));
}
</code></pre>
",,38759247,149
31409432,2,31409029,2015-07-14T14:24:36.860,2,,4774918,,2015-07-14T14:37:41.347,2015-07-14T14:37:41.347,3,,"<p>You fell into the pit of <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.1.1"" rel=""nofollow""><em>integer promotion</em> and coercion</a>. <code>((1&lt;&lt;8)-1)</code> is processed as <code>int</code>, not <code>long</code> (better: <code>uint32_t</code>). On AVR, <code>int</code> has the minimum size allowed by the standard: 16 bits.</p>

<p>As is is anyway too complicated, you can use the following:</p>

<pre><code>uint8_t shift = 32U;   // enough is enough
do {
    shift -= 8U;
    EEPROM_write(eeadr++, (uint8_t)(EE_Data &gt;&gt; shift));
} while ( shift ) ;
</code></pre>

<p>This safes you one additional shift and the explicit masking and some registers.</p>

<p>Note my use of <code>stdint.h</code> types (you have to include the header, of course). You should correct all declarations accordingly. The cast to <code>uint8_t</code> implies masking.</p>
",,38766190,653
31415347,2,31413593,2015-07-14T19:12:18.617,1,,4573270,,2015-07-14T19:17:28.773,2015-07-14T19:17:28.773,0,,"<p><strong>EDIT:</strong> A better solution would be to use GPIO interrupts to time the echo interval</p>

<p>One suggestion (must really be a comment, but I don't have enough reputation)</p>

<p>Use gettimeofday() instead of time() -- it provides a greater resolution in timing. </p>

<p>Also, I'd change the while loops this way:</p>

<pre><code>struct timeval start, end;

while (!bcm2835_gpio_lev(ECHO));   // Although gcc may be smart
gettimeofday(&amp;start, NULL);        // enough to do this optimisation
while (bcm2835_gpio_lev(ECHO));    // on its own
gettimeofday(&amp;end, NULL);

double delta = (end.tv_sec - start.tv_sec) * 1000.0;     // s to ms
       delta += (end.tv_usec - start.tv_usec) / 1000.0;  // us to ms

printf(""D: %f ms\n"", delta);
</code></pre>
",,38834502,154
37213727,2,31413593,2016-05-13T15:18:52.113,0,,3212099,,2016-05-13T15:18:52.113,,0,,"<p>This is a tutorial I made on my blog, to get values from the HC-SR04 in C++ on Raspberry Pi!</p>

<p>You may want to take a look at it:</p>

<p><strong><a href=""https://causeyourestuck.io/2016/04/15/hc-sr04-raspberry-pi-c/"" rel=""nofollow"">https://causeyourestuck.io/2016/04/15/hc-sr04-raspberry-pi-c/</a></strong></p>

<p>At the end it look like this:</p>

<pre><code>Sonar sonar;
sonar.init(trigger, echo);

while(1){
    cout &lt;&lt; ""Distance is "" &lt;&lt; sonar.distance(30000) &lt;&lt; "" cm."" &lt;&lt; endl; // 30000 is a timeout in microseconds
}
</code></pre>
",,38837859,4991
31448020,2,31447841,2015-07-16T07:32:59.877,1,,1275169,,2015-07-16T08:25:37.027,2015-07-16T08:25:37.027,2,,"<p>Include <code>pthread.h</code> and call <code>pthread_exit</code>:</p>

<pre><code>#include &lt;pthread.h&gt;

....

softPwmWrite (1, val) ;
pthread_exit(0);
}
</code></pre>

<p>When the <code>softPwmWrite</code> returns, it'll exit the program. softPwmWrite uses threads and you just need ensure your program doesn't die before the threads complete. When all threads complete, the process will exit at the end.</p>
",,38842747,143
31460809,2,31451153,2015-07-16T17:28:26.463,0,,2410359,,2015-07-16T17:28:26.463,,0,,"<p>Insure <code>buffer</code> is a valid string before the while loop.  (Maybe arduino initializes values to 0 by default - IDK.  C does not and an infinite loop may result and cause ""while loop is never exited"".)</p>

<pre><code>char buffer[MAX_BUF];
// int sofar;
int sofar = 0;  // Initialize to 0. 

buffer[0] = 0;  // Add 
</code></pre>

<p>During the while loop, append a null character after each time a character is appended.  This is especially important should a <code>;</code> is not found or the buffer is long.  Is is not posted what happens to <code>buffer</code> after the <code>while</code> loop.</p>

<pre><code>if (sofar&lt;MAX_BUF-1) {
  buffer[sofar++] = c;
  buffer[sofar] = 0; // Add
 }
</code></pre>
",,38905366,2659
31455340,2,31454905,2015-07-16T13:17:52.707,2,,2072005,,2015-07-16T13:17:52.707,,1,,"<p>You can always call the commandline tool inside your C code:</p>

<pre><code>settimeofday(timeval, NULL);
system(""hwclock --systohc"")
</code></pre>

<p>Or you can direct access your rtc device-driver trough ioctl interface. (<a href=""http://lxr.free-electrons.com/source/include/uapi/linux/rtc.h"" rel=""nofollow"">http://lxr.free-electrons.com/source/include/uapi/linux/rtc.h</a>)</p>

<p>Example:</p>

<pre><code>struct rtc_time rtc = {};
tnow.tm_year = 2015; /* fill up entire struct */
int fd = open(""/dev/rtc0"", O_RDWR)
ioctl(fd, RTC_SET_TIME, &amp;tnow);
close(fd);
</code></pre>
",,38952729,229
31456315,2,31454905,2015-07-16T13:56:15.553,2,,5008284,,2015-07-16T14:02:19.407,2015-07-16T14:02:19.407,0,,"<p>If this is what you are asking: the <code>settimeofday(2)</code> system call sets the time on Unix.
You need to be root to do so. Loosely:</p>

<pre><code>#include &lt;sys/time.h&gt;
struct timeval tv;
tv.tv_sec = seconds since 1 jan 1970;
tv.tv_usec = 0; /* microseconds */
if(settimeofday(&amp;tv, NULL) == 0)// it was ok
</code></pre>

<p>See <code>mktime(3)</code> for how to convert a date into seconds in C.</p>
",,38958849,482
46344398,2,31496332,2017-09-21T12:49:05.490,0,,6622777,,2017-09-21T12:49:05.490,,0,,"<p><code>bool bSuccess =  Camera.cv::imread(frame);</code> is an error,there is no <code>imread</code>funciton in <code>raspicam::RaspiCam_Cv</code>.If you want grub a frame,you can use function <code>grub</code> and than <code>retrieve</code> .
For example:</p>

<pre><code>Mat img;
camera.grab();
camera.retrieve(img);
</code></pre>

<p>You can see the declaration:</p>

<pre><code>/**
 * Grabs the next frame from video file or capturing device.
 */
bool grab();
/**
*Decodes and returns the grabbed video frame.
 */
void retrieve ( cv::Mat&amp; image );
</code></pre>

<p>Also ,you can get example in:<a href=""https://github.com/cedricve/raspicam"" rel=""nofollow noreferrer"">https://github.com/cedricve/raspicam</a></p>
",,38970132,407
31507923,2,31507840,2015-07-20T02:04:45.697,1,,14860,,2015-07-20T02:18:09.370,2015-07-20T02:18:09.370,0,,"<p>It's possible you're overflowing in one of the situations.</p>

<p>The multiplication of <code>var1</code> and <code>var2</code> (both <code>long</code>) gives a <code>long</code> which is then loaded into <code>var3</code>.</p>

<p>If both <code>info-&gt;accelXYZ[0]</code> and <code>info-&gt;taughtAccelXYZ[0]</code> are <code>int</code> (for example), the result of the multiplication will be <code>int</code> which is then loaded into a <code>long</code>.</p>

<p>The intermediate <code>int</code> form may be overflowing, something you can see in the following snippet:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main(void) {
    printf(""int has %d bytes\n"",sizeof(int));
    printf(""long has %d bytes\n"",sizeof(long));

    int a = INT_MAX;
    int b = 2;

    long var1 = a;
    long var2 = b;

    long var3 = a * b;
    long var4 = var1 * var2;

    printf (""var3=%ld\n"", var3);
    printf (""var4=%ld\n"", var4);

    return 0;
}
</code></pre>

<p>which outputs:</p>

<pre><code>int has 4 bytes
long has 8 bytes
var3=-2
var4=4294967294
</code></pre>
",,38973171,588
31630949,2,31630888,2015-07-25T20:45:31.853,0,,296460,,2015-07-25T21:01:53.713,2017-05-23T10:28:21.600,3,,"<p>EDIT: My original answer made some assumptions that Arduino IDE was closer to AVR-GCC than it actually was. My general recommendation for anyone who is familiar with C or C++ that is doing a lot of work with these chips is to use Atmel studio and AVR-GCC directly as you will run into less issues this way.</p>

<p>Arduino is actually C++ underneath but it does some preprocessing before it turns your code into the C++ code that gets compiled for the chip (like creating <code>main</code> from <code>setup</code> and <code>loop</code>). The issue you have is due to a preprocessing step and is explained by <a href=""https://stackoverflow.com/a/31630990/296460"">Ignacio Vazquez-Abrams' answer</a>.</p>

<p>As a more general c++ usage note I'd recommend changing your struct definition to this:</p>

<pre><code>struct motor
{
   int EN;
   /*some more ints*/
};
</code></pre>

<p>You might want to read <a href=""https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c"">Difference between &#39;struct&#39; and &#39;typedef struct&#39; in C++?</a> to see why things are a bit different in c++.</p>
",,39016997,1085
31630990,2,31630888,2015-07-25T20:50:02.083,5,,20862,,2015-07-25T20:50:02.083,,1,,"<p>Because the road to hell is paved with good intentions.</p>

<p>The Arduino IDE tries to be helpful by generating prototypes for all user-defined functions at the beginning of the code. When one of these prototypes references a user-defined type, things blow up in the manner described.</p>

<p>The trick is to make the code unparseable by the IDE:</p>

<pre><code>namespace
{
  int drive (MOTOR*)
  {
     return 1;
  }
}
</code></pre>

<p>The IDE runs into <code>namespace</code> and has no idea what to do with the block that follows, so skips it.</p>
",,39034558,2992
31631118,2,31630888,2015-07-25T21:04:07.037,1,,5047955,,2015-07-25T21:04:07.037,,0,,"<p>And i suggest this should do the job as good as the namespace option?</p>

<pre><code>struct motor
{
   int EN;
   /*some more ints*/
};
int drive (motor* mtr);
motor mot1;
motor mot2; /*this works with no compile error*/

  int drive (motor* mtr)
  {
   return 1;
  }


void setup()
{}

void loop()
{
  int a = drive(&amp;mot1);
}
</code></pre>
",,39139771,737
31644633,2,31634631,2015-07-27T03:43:55.140,0,,5047641,,2015-07-27T03:43:55.140,,0,,"<p>I <strong>do not assure</strong> you if this is <strong>bug-free</strong> but you can <strong>try this</strong> and post your restults here, so that <strong>I can debug</strong> it for you. Here you go:</p>

<pre><code>int motor;
int motorpwm = 11;
int x = 1;
int i;
int pwmValue;
void setup()
{
  pinMode(11, OUTPUT);
  pinMode(2, INPUT); //Button connected to Vcc and pulled down using a 10k resistor. 
  Serial.begin(9600);
}

void loop()
{
  if (digitalRead(2)) //if button is pressed it will read High signal
  {
    if (pwmValue &lt;= 255)
    {
      analogWrite(motorpwm, pwmValue++);
      Serial.print(""Going Up with value: "");
      Serial.println(pwmValue);
    }
    else
    {
      Serial.println(""PWM is maximum"");
    }
  }

  else
  {
    if (motorpwm &gt; 0)
    {
      analogWrite(motorpwm, pwmValue--);
      Serial.print(""Going down with value: "");
      Serial.print(pwmValue);
    }
    else
    {
      Serial.println(""PWM is minimum"");
    }
  }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/QMhNw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QMhNw.png"" alt=""This is how you will connect your switch to pin 2""></a></p>
",,39173766,1030
31708394,2,31707629,2015-07-29T18:28:41.390,3,,1971013,,2015-08-04T20:19:36.967,2015-08-04T20:19:36.967,0,,"<p>A simple technique is scaling up by multiplying the input value with for example <code>10000</code> and putting that result in an <code>int</code>, do the calculations in <code>int</code>, and then scale the output back into a <code>float</code> by dividing with the same factor.</p>

<p>In your function you then also need scale up everything with that same factor.</p>

<p>The choice of factor depends on the possible ranges of the values; you want to avoid overflow at the high end, and inaccuracy at the low end.  If you think about it, the factor determines where you put the decimal point: fixed point, instead of floating point.</p>

<p>The factor can be anything, it does not have to be <code>100</code>, <code>1000</code>, and so on, but <code>627</code> is fine too.</p>

<p>If you go down this route, you want to convert as much of your code to <code>int</code>, because the conversions described above of course also take time.</p>

<p>To illustrate my point, the following could be it:</p>

<pre><code>#define FACTOR 10000  // Example value.
int smooth(int data, int filterVal, int smoothedVal)
{ 
    if (filterVal &gt; FACTOR)
    {
        filterVal = FACTOR - 100;
    }
    else if (filterVal &lt;= 0)
    {
        filterVal = 0;
    }

    smoothedVal = (data * (FACTOR - filterVal)) + (smoothedVal * filterVal);

    return smoothedVal;
}
</code></pre>

<p>You may need/want to check for overflow, ...</p>
",,39182690,2986
31754875,2,31733726,2015-07-31T20:43:40.070,0,,1178454,,2015-07-31T20:43:40.070,,1,,"<p>Thanks David for your comment on my question.
I found the answer by myself. I used <code>serial.WriteData(""o"",1);</code></p>

<p>Here is the complete code of my main.cpp. Just in case it might be useful for others:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include ""SerialClass.h""    // Library described above
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;


bool weiter = true;
int dummy1 = 0;


int _tmain(int argc, _TCHAR* argv[]) {


cout &lt;&lt; ""*** This is my Arduino LED app! ***\n"" &lt;&lt; endl;
//Serial* SP = new Serial(""COM4"");
//Serial serial(""COM4"");
Serial serial(""COM4"");

if (serial.IsConnected())
//printf(""We are connected\n"");
cout &lt;&lt; ""We are connected!\n"" &lt;&lt; endl;



while (weiter == true) {

cout &lt;&lt; ""Press 1 for LED on; press 0 for LED off!"" &lt;&lt; endl;
cin &gt;&gt; dummy1;
if (dummy1 == 1) {



if (serial.IsConnected()){
    serial.WriteData(""o"",1);
    cout &lt;&lt; ""LED is on!"" &lt;&lt; endl;
    cout &lt;&lt; ""Do you want to continue? 1 for continue, 0 for exit!"" &lt;&lt; endl;
    //printf(""\nData sent successfully!\n"");
     cin &gt;&gt; weiter;
 }
 }


else {

    serial.WriteData(""p"", 1 );
    cout &lt;&lt; ""LED is off!"" &lt;&lt; endl;
    cout &lt;&lt; ""Do you want to continue? 1 for continue, 0 for exit!"" &lt;&lt; endl;
    cin &gt;&gt; weiter;
  }
  }

if (weiter == 1)
{
    weiter = true;
}

if (weiter == 0) {
    weiter = false;
return 0;
}
}
</code></pre>
",,39183873,73
31761691,2,31749615,2015-08-01T12:09:28.283,0,,5178283,,2015-08-01T12:09:28.283,,1,,"<p>I found the issue. I was assuming default options with the boost serial_port object. After setting more of the options the serial communication works reliably.
Here are the options that I ended up setting:</p>

<pre><code>port.set_option(asio::serial_port_base::baud_rate(9600));
port.set_option(asio::serial_port_base::character_size(8));
port.set_option(asio::serial_port_base::flow_control(asio::serial_port_base::flow_control::none));
port.set_option(asio::serial_port_base::parity(asio::serial_port_base::parity::none));
port.set_option(asio::serial_port_base::stop_bits(asio::serial_port_base::stop_bits::one));
</code></pre>

<p>where port is an asio::serial_port object.</p>
",,39194157,124
31763717,2,31756504,2015-08-01T16:26:43.090,2,,20862,,2015-08-01T16:26:43.090,2017-05-23T10:26:40.887,0,,"<p>You can't actually use ""unknown"" types in C/C++; you can use <em>arbitrary</em> types, but <em>someone</em> has to know how to deal with it properly.</p>

<p>Fortunately C++ offers a solution so long as someone does know how to deal with it: <strong>templates</strong>. We can define a function that takes an arbitrary type and the compiler will instantiate as many copies of the function as is required to handle all the types thrown at it (if possible):</p>

<pre><code>namespace
{
  template&lt;typename T&gt;
  void puts(char *explanation, T value){
    if (log){
      Serial.print(explanation);
      Serial.println(value); 
    }
  }
}

void loop() {
  puts(""hello"", 12);
  puts(""goodbye"", ""foo"");
  delay(1000);
}
</code></pre>

<p>(We use <code>namespace</code> in the sample above because <a href=""https://stackoverflow.com/questions/31630888/arduino-struct-out-of-scope-why"">LOL Arduino IDE</a>.)</p>

<p>The downside of course is that each function instantiation takes up additional flash, which is why you probably don't want to use more than 3 or 4 if you can help it.</p>
",,39196129,656
31839558,2,31791902,2015-08-05T17:55:52.630,0,,4156508,,2015-08-05T17:55:52.630,,2,,"<p>the CreateFile() function in your constructor requires a const WCHAR * so you somehow need to convert you const char * to const wchar* .</p>

<p><a href=""http://www.codeproject.com/Questions/172037/Convert-char-to-wchar"" rel=""nofollow"">here</a> is a post to do the conversion.</p>

<p>Although I don't have much info on this , the post describes several ways to do it One of them being :</p>

<pre><code>   char *p=""D:\\""; //just for proper syntax highlighting ...""
   const WCHAR *pwcsName;
   // required size
   int nChars = MultiByteToWideChar(CP_ACP, 0, p, -1, NULL, 0);
   // allocate it
   pwcsName = new WCHAR[nChars];
   MultiByteToWideChar(CP_ACP, 0, p, -1, (LPWSTR)pwcsName, nChars);
  // use it....

  // delete it
delete [] pwcsName;
</code></pre>

<p>}</p>
",,39208926,564
31865623,2,31865380,2015-08-06T20:53:21.117,1,,1687119,,2015-08-06T21:02:44.363,2015-08-06T21:02:44.363,4,,"<p>From your comment, you're doing this:</p>

<pre><code>unsigned int x;
...
read(port, &amp;x,1);
</code></pre>

<p>This won't work, since you're reading one byte but an <code>int</code> is at least 2 or 4 bytes on most systems.  So one byte of the <code>int</code> contains the value you want but the rest contain garbage.</p>

<p>If you're reading data a byte at a time, you should declare <code>x</code> as an <code>unsigned char</code> which is one byte.</p>

<p>If you want to read two or more bytes at a time, you'd define a character array to read into:</p>

<pre><code>char buffer[size];
int count, i;

count = read(port, buffer, size);
if (count == -1) {
    perror(""read failed"");
    exit(1);
}
for (i=0;i&lt;count;i++) {
    // process buffer[i]
}
</code></pre>
",,39216824,632
31881369,2,31881095,2015-08-07T15:24:57.507,3,,4765374,,2015-08-07T17:57:38.083,2015-08-07T17:57:38.083,0,,"<p>You could use a <a href=""https://en.wikipedia.org/wiki/Command_pattern"" rel=""nofollow"">Command Pattern</a>.</p>

<p>Basically, make your parser to put a different command object for each user input into some sort of queue. You can use a basic function object for this:</p>

<pre><code>struct Command {
    virtual ~Command() {}
    virtual void operator()(); // this will execute the command
};

class FirstCommand : public Command {
    // some private data + constructor
public:
    virtual void operator()() { /* do stuff for this user input */ }
};

class SecondCommand : public Command {
    // some private data + constructor
public:
    virtual void operator()() { /* do stuff for this user input */ }
};
</code></pre>

<p>A parser would create either <code>FirstCommand</code> or <code>SecondCommand</code>, and store them in the <code>std::queue&lt;Command*&gt;</code> or something more sophisticated. Your consumer code would then execute every command by doing something like:</p>

<pre><code>while (!q.empty() {
    Command* command = q.front();
    (*command)();
    q.pop();
}
</code></pre>

<p>With thread-safe queues, the consumer code can even be run in parallel to your parser. </p>

<p>You could use a queue of simple pointers to functions instead of command objects, but if you do, their signatures will have to be the same, while a constructor for a specific command can be arbitrary.</p>
",,39232634,8171
31935263,2,31933893,2015-08-11T07:04:44.673,0,,5190019,,2015-08-11T07:04:44.673,,4,,"<p>If I understood well, it should look like something like this:</p>

<pre><code>void insert(int* arr, int size, int value){
    int i = 0;
    for(int i=0; i &lt; size-1; i++){
        arr[i] = arr[i+1];
    }
    arr[size-1] = value;
}
</code></pre>

<p>With size, the size of you're array (10 for you). You should initialize you're array with 0 or -1 to be sure.
However I don't know the difference between ansi C and embedded C. Maybe ""for(int i = ;...)"" doesn't work and you'll have to create the variable i just before.
Not sure if that's what you wanted.</p>
",,39249701,156
31935355,2,31933893,2015-08-11T07:09:30.123,0,,2000036,,2015-08-11T07:26:49.700,2015-08-11T07:26:49.700,0,,"<p>Not sure what you mean exactly by 'Embedded C', but I write C for embedded systems, and I'd use something like the following. (The <code>GpioPrint()</code> function is really only for (my) debugging.)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Returns the size of a[].
#define ARRAY_SZ(a) (sizeof a / sizeof a[0])

// Holds MCU-GPIO pin values.
typedef struct
{
    unsigned a[10]; // replace unsigned with your 'pin value' type
    unsigned n;     // values are in a[0..n-1]
} Gpio_t;

// Initialise the pin value store.
static void GpioInit(Gpio_t *gpio)
{
    gpio-&gt;n = 0;
}

// Add the new value to the pin store, removing the oldest if the store
// is full.
static void GpioAdd(Gpio_t *gpio, unsigned newVal)
{
    if (gpio-&gt;n &lt; ARRAY_SZ(gpio-&gt;a))
    {
        gpio-&gt;a[gpio-&gt;n++] = newVal;
    }
    else
    {
        memmove(&amp;gpio-&gt;a[0], &amp;gpio-&gt;a[1], (gpio-&gt;n - 1) * sizeof gpio-&gt;a[0]);

        gpio-&gt;a[gpio-&gt;n - 1] = newVal;
    }
}

// Output the pin store contents.
static void GpioPrint(const Gpio_t *gpio)
{
    unsigned i;

    for (i = 0; i &lt; gpio-&gt;n; i++)
    {
        printf(""%2u: %10u\n"", i, gpio-&gt;a[i]);
    }
}

// Test the functions.
int main(void)
{
    Gpio_t   gpio;
    unsigned newVal;

    GpioInit(&amp;gpio);

    // Add 20 values to the pin store, checking the contents after each
    // addition.
    for (newVal = 0; newVal &lt; 20; newVal++)
    {
        printf(""add %u:\n"", newVal);

        GpioAdd(&amp;gpio, newVal);
        GpioPrint(&amp;gpio);
    }

    return 0;
}
</code></pre>
",,39252600,511
31938569,2,31933893,2015-08-11T09:51:48.143,1,,45552,,2015-08-11T10:17:41.303,2015-08-11T10:17:41.303,2,,"<p>Given that you're only storing 1 bit each time, an array isn't the only solution:</p>

<pre><code>static uint16_t buffer = 0;

void gpio_add(bool pin_value)
{
    buffer &gt;&gt;= 1;
    if(pin_value) {buffer |= 0x0200;}
}

bool gpio_get_entry(uint8_t index)
{
    return !!(buffer &amp; (1 &lt;&lt; index));
}
</code></pre>

<p>Note that if you're taking this approach, you may as well store either 8 or 16 values.</p>

<p>If the purpose of this is to implement a simple debouncer (i.e. to determine if the pin level has remained stable for a while), then we can simply see if <code>buffer</code> is zero or 0x3FF.</p>
",,39253901,118
31969322,2,31968397,2015-08-12T15:18:50.743,4,,3313064,,2015-08-12T15:30:06.307,2015-08-12T15:30:06.307,5,,"<p>Use a <a href=""https://en.wikipedia.org/wiki/Prepared_statement"" rel=""nofollow"">prepared statement</a>. See <a href=""https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-functions.html"" rel=""nofollow"">prepared statements documentation in the MySQL reference manual</a>.</p>

<p>Prepared statements are more correct, safer, possibly faster, and keep your code cleaner. You get all those benefits and don't need to escape anything. There is hardly a reason not to use them.</p>

<hr>

<p>Something like this might work. But take it with a grain of salt, because I have <strong>not tested or compiled</strong> it. It should just give you the general idea:</p>

<pre><code>MYSQL_STMT* const statement = mysql_stmt_init(&amp;mysql);
std::string const query = ""INSERT INTO tab values(?)"";
mysql_stmt_prepare(statement, query, query.size());
MYSQL_BIND bind[1] = {};
bind[0].buffer_type = MYSQL_TYPE_STRING;
bind[0].buffer = json_example.c_str();
bind[0].buffer_length = json_example.size();
mysql_stmt_bind_param(statement, bind);
mysql_stmt_execute(statement);
</code></pre>
",,39262108,1917
32026716,2,32026391,2015-08-15T16:20:04.873,0,,2031180,,2015-08-15T21:57:29.590,2015-08-15T21:57:29.590,2,,"<pre><code>#include &lt;unistd.h&gt; // for read &amp; write functions
#include &lt;sys/select.h&gt; // fd_set functions
#include &lt;stdio.h&gt; // for perror &amp; printf family
#include &lt;sys/types.h&gt; // for open related function
#include &lt;sys/stat.h&gt; // for open related function
#include &lt;fcntl.h&gt; // for open related function
#include &lt;termios.h&gt; // for terminal functions
#include &lt;errno.h&gt; // for error code

#define RFID ""path_to_rfid"" // FIXME &lt;- you should set this properly
char read_rfid(char* rfid_num, int fd)
{
    fd_set input_fdset;
    ssize_t length;
    int done;

    for(done=0; done &lt; 14; ) {
        FD_ZERO(&amp;input_fdset);
        FD_SET(fd,&amp;input_fdset);

        if(select(fd+1 ,&amp;input_fdset, NULL,NULL,NULL) == -1) {
            perror(""Terminal select() failed"");
            return -1;
        }

        if(FD_ISSET(fd,&amp;input_fdset)) {
            if((length = read(fd,rfid_num+done,14-done)) == -1) {
                perror(""Terminal: read() failed"");
                return -1;
            }
            write(STDOUT_FILENO,rfid_num+done,length);
            done += length;
        }
    }
    return 0;
}


int setupRS232()
{
    struct termios term_attr;
    int fd = 0;

    if((fd = open(RFID,O_RDWR)) == -1) {
        perror(""Can't open Device"");
        return(-1);
    }
    if(tcgetattr(fd,&amp;term_attr) != 0)
    {
        perror(""terminal: tcgetattr() failed"");
        close(fd);
        return(-1);
    }

    term_attr.c_cflag = CBAUD|CS8|CRTSCTS|CLOCAL|CREAD;
    term_attr.c_iflag = 0;
    term_attr.c_oflag = 0;
    term_attr.c_lflag = 0;
    if(tcsetattr(fd,TCSAFLUSH,&amp;term_attr) != 0) {
        perror(""terminal: tcsetattr() failed"");
        close(fd);
        return(-1);
    }
    return (fd);
}

int main(int argc, char** argv)
{

    char rfid_num[14];
    int i;
    int fd;

    if((fd = setupRS232()) == -1) {
        return(-1);
    }

    puts(""Waiting for transponder..."");
    read_rfid(rfid_num, fd);
    for(i=0;i&lt;20;i++) {
        printf(""%x\n"",rfid_num[i]);
    }

    return 0;
}
</code></pre>

<p>Now your code is ready to be compiled, at least in my machine I could compile with no errors.</p>
",,39353702,126
32043899,2,32037217,2015-08-17T06:20:57.753,0,,3704293,,2015-08-17T06:20:57.753,2017-05-23T12:00:37.810,1,,"<p>You can use non-blocking code patterns, which are executed in special frequencies or times. In the following, I give you an short example how you can replace a <code>delay(1000)</code> and a <code>delay(5000)</code> without blocking the main loop. In addition, you can check stackoverflow for similar posts (e.g. <a href=""https://stackoverflow.com/questions/31792093/pause-without-delay-arduino/31801686#31801686"">Pause without Delay() arduino</a>). </p>

   <pre class=""lang-c prettyprint-override""><code>// 1 sec. frequency
unsigned long interval=1000;    // the time we need to wait
unsigned long previousMillis=0; // millis() returns an unsigned long.

// 5 sec. frequency  
unsigned long interval1=5000;    // the time we need to wait
unsigned long previousMillis1=0; // millis() returns an unsigned long.

void setup() {
   //...
}

void loop() {

 // other CMD's...

 // replace delay(1000) 
 if ((unsigned long)(millis() - previousMillis) &gt;= interval) {
    previousMillis = millis();
    // every first second
    // ... 
 }

 // other CMD's...

 // replace delay(5000) 
 if ((unsigned long)(millis() - previousMillis1) &gt;= interval1) {
    previousMillis1 = millis();
    // every fifth second
    // ... 
 }

 // other CMD's...
}
</code></pre>
",,39353819,447
32081593,2,32037217,2015-08-18T20:00:02.937,0,,5154263,,2015-08-21T12:38:59.743,2015-08-21T12:38:59.743,8,,"<p>I see you're using NeoPixels! It just so happens that Adafruit has some great tutorials on using <code>millis()</code> and <code>micros()</code> for timing purposes instead of <code>delay()</code>. They also include good material on interrupts, if you're feeling ambitious and want to separate your timing from your main function entirely (a worthwhile undertaking, if you have the time and resources).</p>

<p>Part 1 (basics of using <code>millis()</code>):</p>

<p><a href=""https://learn.adafruit.com/multi-tasking-the-arduino-part-1/overview"" rel=""nofollow"">https://learn.adafruit.com/multi-tasking-the-arduino-part-1/overview</a></p>

<p>Part 2 (introduces interrupts):</p>

<p><a href=""https://learn.adafruit.com/multi-tasking-the-arduino-part-2/overview"" rel=""nofollow"">https://learn.adafruit.com/multi-tasking-the-arduino-part-2/overview</a></p>

<p>Part 3 (puts everything together):</p>

<p><a href=""https://learn.adafruit.com/multi-tasking-the-arduino-part-3/overview"" rel=""nofollow"">https://learn.adafruit.com/multi-tasking-the-arduino-part-3/overview</a></p>

<hr>

<h2>Edit 1:</h2>

<p>Alright, I edited your code, adding in a loop that checks for both delay periods to be done using <code>millis()</code>. I attempted to stick to the variable naming conventions that you've been using, for easy readability. There were also some other issues with your code syntax that I cleaned up. Make sure to effectively comment your code so that it's understandable, for yourself and for others!</p>

<p>Hopefully this works the way you want it to!</p>

<pre><code>/*The goal of the sketch is to run multiple strip where each dot could be 
controlled on/off one after the others but with different times on/off between each
pixel on each strip. All be independent and separate and automated and structured
already like FastLED library recommendation.*/

// Library include
#include &lt;FastLED.h&gt;

#define NUM_LEDS1 10
#define NUM_LEDS2 6

// Define pin (each strip be connected on)
#define DATA_PIN1 5
#define DATA_PIN2 6

// Declare some strip name and attribute (number of led per strip)
CRGB leds1[NUM_LEDS1];
CRGB leds2[NUM_LEDS2];

void setup() {
  FastLED.addLeds&lt;NEOPIXEL, DATA_PIN1&gt;(leds1, NUM_LEDS1);
  FastLED.addLeds&lt;NEOPIXEL, DATA_PIN2&gt;(leds2, NUM_LEDS2);
}

int dot_delay1[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
int dot_delay2[] = {100, 200, 300, 400, 500, 600};

void loop() {
  for (int dot1 = 0; dot1 &lt; NUM_LEDS1; dot1++) {
    for (int dot2 = 0; dot2 &lt; NUM_LEDS2; dot2++) {
      // LED turns blue
      leds1[dot1] = CRGB::Blue;
      leds2[dot2] = CRGB::Blue;
      // Show LED status
      FastLED.show();
      // LED turns black
      leds1[dot1] = CRGB::Black;
      leds2[dot2] = CRGB::Black;
      // Create timing variables
      unsigned long previousMillis = millis();
      unsigned long currentMillis = millis();
      // Create boolean variables to monitor if the delays have triggered yet
      bool delayFlag1 = false, delayFlag2 = false;
      // Loop continuously
      while (1) {
        currentMillis = millis();
        // If the first delay time has passed, delayFlag1 is true
        if ((unsigned long)(millis() - previousMillis) &gt;= dot_delay1[dot1]) {
          delayFlag1 = true;
        }
        // If the second delay time has passed, delayFlag2 is true
        if ((unsigned long)(millis() - previousMillis) &gt;= dot_delay2[dot2]) {
          delayFlag2 = true;
        }
        // If both delay times have passed (both delay flags are true), exit while loop
        if ((delayFlag1 &amp;&amp; delayFlag2) == true) {
          break;
        }
      }
    }
  }
}
</code></pre>

<p>This new code should work, I've tested it and it works as expected on my machine.</p>

<p>As a side note, your original question was ""How can I replace delay() by millis()?"". This question has been answered both by myself and by the previous answer author, user3704293. In the future it may be helpful to separate your questions to get higher quality answers and to better serve those who are searching for answers to the same questions. Once your question is answered, as I hope this question is now, you should accept the answer that is the best for you.</p>

<p>Let me know if it all works out!</p>

<hr>

<h2>Edit 2:</h2>

<p>To have LEDs change independently of each other, replace the <code>loop()</code> function in the previous code with this one.</p>

<pre><code>void loop() {
  // Create timing variable
  unsigned long previousMillis = millis();
  // Loop through all LEDs
  for (int dot = 0; dot &lt; NUM_LEDS1; dot++) {
    // If the first delay time has passed, change first LED strip
    if ((unsigned long)(millis() - previousMillis) &gt;= dot_delay1[dot1]) {
      leds1[dot - 1] = CRGB::Black;
      leds1[dot] = CRGB::Blue;
    }
    // If the second delay time has passed, change second LED strip
    if ((unsigned long)(millis() - previousMillis) &gt;= dot_delay2[dot2]) {
      leds2[dot - 1] = CRGB::Black;
      leds2[dot] = CRGB::Blue;
    }
    // Show LEDs
    FastLED.show();
  }
  // Turn last LED Black
  leds1[9] = CRGB::Black;
}
</code></pre>
",,39354004,2003
38317399,2,32063073,2016-07-11T22:49:41.383,0,,6576769,,2016-07-12T01:20:51.533,2016-07-12T01:20:51.533,0,,"<p>I had a different error with your code. It displayed Arduino.h as not being present. I fixed it after actually adding the INCLUDE variable to CFLAGS and CPPFLAGS (yours was defined but not added).</p>

<p>I also used CFLAGS and CPPFLAGS as per the <a href=""https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5-3rd-party-Hardware-specification"" rel=""nofollow"">Arduino Specification</a>. The code is:</p>

<pre><code>CC=avr-gcc
CPP=avr-g++
MCU=-mmcu=atmega328p
CPU_SPEED=-DF_CPU=16000000UL
INCLUDE=-I./

CFLAGS = -c -g -Os -w -ffunction-sections -fdata-sections -MMD $(MCU) $(CPU_SPEED) $(INCLUDE) 
CPPFLAGS = -c -g -Os -w -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -MMD $(MCU) $(CPU_SPEED)  $(INCLUDE)

CFILES=$(wildcard ./*.c)
CPPFILES=$(wildcard ./*.cpp)

OBJ=$(CFILES:.c=.o) $(CPPFILES:.cpp=.o)

default: $(OBJ)
    avr-ar rcs core.a $^

%.o : %.c
    $(CC) $&lt; $(CFLAGS) -c -o $@

%.o : %.cpp
    $(CPP) $&lt; $(CPPFLAGS) -c -o $@
</code></pre>

<p>Which creates the archive successfully (not tested, just created).</p>
",,39409124,5780
32149585,2,32149483,2015-08-21T21:33:53.447,1,,335858,,2015-08-21T22:12:21.300,2015-08-21T22:12:21.300,5,,"<p>You should be able to do it using string concatenation, like this:</p>

<pre><code>String part1 = ""Hello"";
String part2 = ""World"";
String separator = ""\xFF""; // That's character 255, in hex
String data = part1 + separator + part2 + separator;
</code></pre>

<p>You could also do the concatenation right in your <code>saveToE</code> function, like this:</p>

<pre><code>void saveTwoStringsToE(String one, String two) {
  int str_len1 = one.length(); 
  int str_len2 = two.length(); 
  // Add two bytes for 255 separators, and an extra byte for null terminator
  char char_array[str_len1+str_len2+3];
  one.toCharArray(char_array, str_len1);
  char_array[str_len1] = 255;
  two.toCharArray(char_array+str_len1+1, str_len2);
  char_array[str_len1+1+str_len2] = 255;
  for(int addr = 0; addr &lt; str_len1+str_len2; addr++) {
    EEPROM.write(addr, char_array[addr]);
  }
}
</code></pre>
",,39432682,1083
32193310,2,32193124,2015-08-24T23:28:50.163,3,,3887516,,2015-08-24T23:28:50.163,,9,,"<p>It's really much simpler than that, and closer to your java code (only showing relevant parts):</p>

<pre><code>class StrategyManager {

  private:
     IState *_states[3];          

  public:     
      StrategyManager(); 
};
</code></pre>

<p></p>

<pre><code>StrategyManager::StrategyManager(){    
    _states[0] = new StateImpl();
    _states[1] = new StateImpl();
    _states[2] = new StateImpl();
    };
}
</code></pre>

<p>Just remember, C/C++ is not java, there's no GC so cleanup your objects</p>
",,39443604,586
32285561,2,32254044,2015-08-29T11:30:48.463,2,,410847,,2015-08-29T11:30:48.463,,0,,"<p>Your code has a buffer overflow:</p>

<pre><code>     unsigned char usb_data[4]; // &lt;---
     int size = sizeof(unsigned int) *1280 *960;
     unsigned *data;  // &lt;-- not used!
     data = (unsigned int *)malloc(size);

    r = libusb_bulk_transfer(dev, LIBUSB_ENDPOINT_IN | 0x83, usb_data //&lt;
    ,sizeof(data), &amp;transfered, 0)
</code></pre>

<p>You probably wanted to use ""data"" as receiving buffer in the <code>libusb_bulk_transfer()</code> call, but you actually used <code>usb_data</code> which is only 4 bytes long.</p>
",,39457303,100
32325393,2,32277033,2015-09-01T06:58:34.027,3,,4327513,,2015-09-26T21:52:34.997,2015-09-26T21:52:34.997,1,,"<p>I recently managed to get SFML 2.0 to work on my raspi but it was not easy.
SFML 1.6 is available for raspberry pi with:</p>

<pre><code>sudo apt-get install libsfml-dev
</code></pre>

<p>but I found this not to be compatible with my program written with SFML 2.X. I also tried and failed to use the Linux 32bit binary package SFML provides. 
I believe the reason for this is because the raspi uses the ARM processor which was not what that build was built for.</p>

<p>I finally succeeded by downloading the Linux source from <a href=""http://www.sfml-dev.org/download.php"" rel=""nofollow"">the SFML download page</a>. I got SFML 2.0 because the instructions I found for building SFML from source were for that version and it was new enough to be functional although you may want to try a newer version. I downloaded all the dependencies and attempted to install using the script I got <a href=""http://en.sfml-dev.org/forums/index.php?topic=9808.0"" rel=""nofollow"">here</a>. This may work for you but I ran into problems with the freetype library. The solution I found was to copy all the freetype header files to the parent ""include"" directory. There may be a better way but that worked for me. I hope this helped.</p>

<p>Edit: I just had to do this again on a fresh Raspian install. This time I used SFML 2.3. I did not have the same problem with freetype but I did have to install the following dependencies:</p>

<pre><code>sudo apt-get install libx11-xcb-dev
sudo apt-get install libxcb-image0-dev
sudo apt-get install libxcb-randr0-dev
sudo apt-get install libudev-dev
</code></pre>

<p>here are the scripts I used:</p>

<p>to install dependencies:</p>

<pre><code>sudo apt-get install libpthread-stubs0-dev
sudo apt-get install libgl1-mesa-dev
sudo apt-get install libx11-dev
sudo apt-get install libxrandr-dev
sudo apt-get install libfreetype6-dev
sudo apt-get install libglew1.5-dev
sudo apt-get install libjpeg8-dev
sudo apt-get install libsndfile1-dev
sudo apt-get install libopenal-dev
sudo apt-get install cmake
sudo apt-get install g++
</code></pre>

<p>to build it:</p>

<pre><code>echo Starting SFML 2.0 install
echo see install.log for install output..
echo No.. Really.. Read it, this is my first
echo batch script for linux, so expect bugs
echo especially because I can\'t be stuffed
echo using regex to look for error output


echo building make for dynamic release
cmake -G""Unix Makefiles"" -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=TRUE &gt; install.log
echo Complete
echo making
make &gt;&gt; install.log
echo Complete
echo Installing
sudo make install &gt;&gt; install.log
echo Complete

echo building make for dynamic debug
cmake -G""Unix Makefiles"" -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=TRUE &gt;&gt; install.log
echo Complete
echo making
make &gt;&gt; install.log
echo Complete
echo Installing
sudo make install &gt;&gt; install.log
echo Complete


echo building make for static release
cmake -G""Unix Makefiles"" -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=FALSE &gt;&gt; install.log
echo Complete
echo making
make &gt;&gt; install.log
echo Complete
echo Installing
sudo make install &gt;&gt; install.log
echo Complete


echo building make for static debug
cmake -G""Unix Makefiles"" -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=FALSE &gt;&gt; install.log
echo Complete
echo making
make &gt;&gt; install.log
echo Complete
echo Installing
sudo make install &gt;&gt; install.log
echo Complete
</code></pre>

<p>to run these, simply</p>

<ol>
<li><p>copy them into a text file</p></li>
<li><p>save it with the file extension .sh</p></li>
<li><p>in properties, make it executable 
(or, in terminal : <code>sudo chmod +x yourfile.sh</code>)</p></li>
<li><p>open it and click 'execute in terminal'
(or, in terminal : <code>./yourfile.sh</code>)</p></li>
</ol>
",,39503414,185
32335070,2,32334757,2015-09-01T15:07:12.070,0,,1520617,,2015-09-01T15:07:12.070,,0,,"<p>When you declare a private member variable in a header file, as you do:</p>

<pre><code>class ScreenManager
{
  public:
    ...
  private:
    LiquidCrystal_I2C lcd;
};
</code></pre>

<p>C++ automatically tries to call that class's default constructor when your class is initialised. Since <code>LiquidCrystal_I2C</code> doesn't declare a default constructor, when it tries to do this default initialisation it throws the error you see.</p>

<p>An alternative would be to use a <em>pointer</em> to <code>LiquidCrystal_I2C</code>:</p>

<pre><code>class ScreenManager
{
  public:
    ...
  private:
    LiquidCrystal_I2C *lcd;
};
</code></pre>

<p>and then in your constructor you construct a <code>new</code> object with your parameters:</p>

<pre><code>ScreenManager::ScreenManager()
{
   lcd = new LiquidCrystal_I2C(0x27, 16, 2);
}
</code></pre>

<p>After that, you just need to add a destructor to your class so that your <code>LiquidCrystal_I2C</code> object gets disposed of when you're done:</p>

<pre><code>// in header
class ScreenManager
{
  public:
    ...
    ~ScreenManager();
    ...
  private:
    LiquidCrystal_I2C lcd;
};

// in source
ScreenManager::~ScreenManager()
{
    delete lcd;
}
</code></pre>
",,39555167,693
32414060,2,32413959,2015-09-05T14:14:28.777,7,,3477950,,2015-09-05T14:23:34.070,2015-09-05T14:23:34.070,3,,"<p>I recommend the following set of command line options for compiling:</p>

<pre><code>avr-gcc -c
        -std=gnu99
        -Os
        -Wall
        -ffunction-sections -fdata-sections
        -mmcu=m328p
        -DF_CPU=16000000
</code></pre>

<p>And for linking:</p>

<pre><code>avr-gcc -Os
        -mmcu=m328p
        -ffunction-sections -fdata-sections
        -Wl,--gc-sections
</code></pre>

<p>Where…</p>

<ul>
<li><code>-c</code> means ""compile to object file only, do not link""</li>
<li><code>-std=gnu99</code> means ""My code conforms to C99 and I use GNU extensions""</li>
<li><code>-Os</code> means ""optimize for executable size rather than code speed""</li>
<li><code>-Wall</code> means ""turn on (almost) all warnings""</li>
<li><code>-ffunction-sections -fdata-sections</code> is necessary for the <code>-Wl,--gc-sections</code> optimization</li>
<li><code>-mmcu=m328p</code> means ""the MCU part number is ATmega 328P""</li>
<li><code>-DF_CPU=16000000</code> means ""the clock frequency is 16 MHz"" (adjust for your actual clock frequency)</li>
<li><code>-Wl,--gc-sections</code> means ""tell the linker to drop unused function and data sections"" (this helps reduce code size).</li>
</ul>

<p>In order to actually compile your code, you would first issue the <code>avr-gcc</code> command with the ""compile only flags"", like this:</p>

<pre><code>avr-gcc -c -std=gnu99 &lt;etc.&gt; MyProgram.c -o MyProgram.o
</code></pre>

<p>Then you would repeat this for all of your source files. Finally, you would link the resulting object files together by invoking AVR-GCC in link mode:</p>

<pre><code>avr-gcc -Os &lt;etc.&gt; MyProgram.o SomeUtility.o -o TheExecutable.elf
</code></pre>

<p>This generates an ELF file, which isn't directly executable by your MCU. Thus, you'll need to extract the useful part (the raw machine code) from it in the Intel Hex format:</p>

<pre><code>avr-objcopy -O ihex -R .eeprom TheExecutable.elf TheExecutable.ihex
</code></pre>

<p>Finally, you will need AVRdude to upload the contents of the hex file to the MCU:</p>

<pre><code>avrdude -C /path/to/avrdude.conf
        -p m328p
        -c PROGRAMMER_NAME
        -b 19600
        -P PORT_NAME
        -U flash:w:TheExecutable.ihex:i
</code></pre>

<p>Where…</p>

<ul>
<li><code>-C /path/to/avrdude.conf</code> means ""use this file as the configuration file""</li>
<li><code>-c PROGRAMMER_NAME</code> means ""I am using a programmer of type PROGRAMMER_NAME"" (you will need to fill this in yourself depending on what kind of programmer you use).</li>
<li><code>-b 19600</code> is the baud rate (you may need to adjust this depending on the baud rate you set or have pre-programmed into the bootloader)</li>
<li><code>-P PORT_NAME</code> means ""the programmer is connected to port PORT_NAME"". On Linux, it will most often be something like <code>/dev/ttyusbN</code>, where N is some number.</li>
<li><code>-U flash:w:TheExecutable.ihex:i</code> means ""write to the Flash memory the contents of TheExecutable.ihex which is in Intel Hex format"".</li>
</ul>
",,39598039,39
41772266,2,32413959,2017-01-20T21:01:24.087,2,,5617509,,2017-01-20T21:01:24.087,,0,,"<p>If you just want to use C code with an Arduino that already has a boot loader installed. You can literally write the code in C in the Arduino IDE and compile it as usual. Sketch is effectively a bunch of header files and Macros.</p>

<p>Here's the blink sketch written in C:</p>

<pre><code>#include &lt;avr/io.h&gt; //defines pins, ports etc
#include&lt;util/delay.h&gt; //functions for wasting time

int main (void) {
//init
DDRB |= (1&lt;&lt;PB5); //Data Direction Register B:
//writing a 1 to the Pin B5 bit enables output
//Event loop
  while (1) {
    PORTB = 0b00100000; //turn on 5th LED bit/pin in PORT B (Pin13 in Arduino)
    _delay_ms (1000); //wait

    PORTB = 0b00000000; //turn off all bits/pins on PB    
    _delay_ms (1000); //wait
  } //end loop
  return(0); //end program. This never happens.
}
</code></pre>

<p>Paste this into the IDE and try it for yourself.</p>

<p>If you want to move away from the Arduino to programming AVR's without a bootloader, may I recommend an excellent webcast by Elliot Williams as an introduction. - <a href=""https://www.youtube.com/watch?v=ERY7d7W-6nA"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=ERY7d7W-6nA</a></p>

<p>Good luck and have fun :)</p>
",,39659117,1211
32436158,2,32417848,2015-09-07T10:12:16.347,2,,5304632,,2015-09-07T10:12:16.347,,0,,"<p>i did it !
All i have to do it was to write my own function ! =D</p>

<p>just add this to the Adafruit_GFX.ccp</p>

<pre><code>void Adafruit_GFX::drawRamBitmap(int pozXi, int pozYi, int h, int w, byte color, byte bg, byte bitmap[], int mapSize) {
  int pozX = pozXi;
  int pozY = pozYi;

  for (int x = 0; x &lt; mapSize; x++) {
    for (byte y = 0; y &lt; 8; y++) {
      byte dummy = bitmap[x] &lt;&lt; y;
      if (dummy &gt;= 128) {
        drawPixel(pozX, pozY, color);
      }
      else {
        drawPixel(pozX, pozY, bg);
      }
      pozX++;
      if (pozX == w + pozXi) {
        pozX = pozXi;
        pozY++;
      }
    }
  }
}

void Adafruit_GFX::drawRamBitmap(int pozXi, int pozYi, int h, int w, byte color, byte bitmap[], int mapSize) {
  int pozX = pozXi;
  int pozY = pozYi;

  for (int x = 0; x &lt; mapSize; x++) {
    for (byte y = 0; y &lt; 8; y++) {
      byte dummy = bitmap[x] &lt;&lt; y;
      if (dummy &gt;= 128) {
        drawPixel(pozX, pozY, color);
      }
      pozX++;
      if (pozX == w + pozXi) {
        pozX = pozXi;
        pozY++;
      }
    }
  }
}
</code></pre>

<p>and this for Adafruit_GFX.h</p>

<pre><code>drawRamBitmap(int pozXi, int pozYi, int h, int w, byte color, byte bg, byte bitmap[], int mapSize),
drawRamBitmap(int pozXi, int pozYi, int h, int w, byte color, byte bitmap[], int mapSize),
</code></pre>

<p>usage:</p>

<pre><code>drawRambitmap(x,y,h,w,color,byte_array_of_img, size_of_array);
</code></pre>

<p>or</p>

<pre><code>drawRambitmap(x,y,h,w,color,background_color,byte_array_of_img, size_of_array);
</code></pre>
",,39661055,704
32427631,2,32427630,2015-09-06T19:49:11.503,16,,1677656,,2020-02-09T18:11:00.930,2020-02-09T18:11:00.930,0,,"<p>Arduino can only detect the state of your button (pressed OR unpressed). </p>

<p>You could use a timer variable (based on <a href=""https://www.arduino.cc/en/Tutorial/ButtonStateChange"" rel=""nofollow noreferrer"">this example</a> from their docs) to save the exact time when you <strong>pressed</strong> or <strong>released</strong> the button, so you can check the difference between both variables to calculate how long it is on hold or idle.</p>

<p>The code should look something like this:</p>

<pre class=""lang-c prettyprint-override""><code>const int buttonPin = 2;  

int buttonState = 0;     // current state of the button
int lastButtonState = 0; // previous state of the button
int startPressed = 0;    // the moment the button was pressed
int endPressed = 0;      // the moment the button was released
int holdTime = 0;        // how long the button was hold
int idleTime = 0;        // how long the button was idle

void setup() {
  pinMode(buttonPin, INPUT); // initialize the button pin as a input
  Serial.begin(9600);        // initialize serial communication
}

void loop() {
  buttonState = digitalRead(buttonPin); // read the button input

  if (buttonState != lastButtonState) { // button state changed
     updateState();
  }

  lastButtonState = buttonState;        // save state for next loop
}

void updateState() {
  // the button has been just pressed
  if (buttonState == HIGH) {
      startPressed = millis();
      idleTime = startPressed - endPressed;

      if (idleTime &gt;= 500 &amp;&amp; idleTime &lt; 1000) {
          Serial.println(""Button was idle for half a second"");
      }

      if (idleTime &gt;= 1000) {
          Serial.println(""Button was idle for one second or more""); 
      }

  // the button has been just released
  } else {
      endPressed = millis();
      holdTime = endPressed - startPressed;

      if (holdTime &gt;= 500 &amp;&amp; holdTime &lt; 1000) {
          Serial.println(""Button was hold for half a second""); 
      }

      if (holdTime &gt;= 1000) {
          Serial.println(""Button was hold for one second or more""); 
      }

  }
}
</code></pre>

<p>However, if you want to trigger an event <strong>while</strong> the button is still pressed (or maybe you want to increment a counter in some display), you can still do the same math.</p>

<p>Change your condition in the loop function to be like this:</p>

<pre class=""lang-c prettyprint-override""><code>  if (buttonState != lastButtonState) { 
     updateState(); // button state changed. It runs only once.
  } else {
     updateCounter(); // button state not changed. It runs in a loop.
  }
</code></pre>

<p>And then implement your new function: </p>

<pre><code>void updateCounter() {
  // the button is still pressed
  if (buttonState == HIGH) {
      holdTime = milis() - startPressed;

      if (holdTime &gt;= 1000) {
          Serial.println(""Button is hold for more than a second""); 
      }

  // the button is still released
  } else {
      idleTime = milis() - endPressed;

      if (idleTime &gt;= 1000) {
          Serial.println(""Button is released for more than a second"");  
      }
  }
}
</code></pre>
",,39663789,271
32535468,2,32523589,2015-09-12T05:24:20.603,0,,1229656,,2015-09-12T05:24:20.603,,0,,"<p>Raspberry Pi is ARM, -msse* does it apply. Based on the CMakeFile, they detect ARM and disabled SSE flags. Maybe it is not working for you, perhaps due to a different cmake version</p>

<p>Try changing this</p>

<pre><code>IF(DEFINED ENV{ARM_ARCHITECTURE})
</code></pre>

<p>to </p>

<pre><code>IF(DEFINED $ENV{ARM_ARCHITECTURE})
</code></pre>

<p>This is line 34 in CMakeLists.txt</p>

<p>If the fix does not work, then you could manually enable ARM specified flags by editing CMakeLists.txt</p>

<p>Remove this:</p>

<pre><code>IF(DEFINED ENV{ARM_ARCHITECTURE})
  SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -mfpu=neon -march=armv7-a"")
ELSE()
  SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -mmmx -msse -msse -msse2 -msse3 -mssse3"")
ENDIF()
</code></pre>

<p>and replace with this</p>

<pre><code>SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -mfpu=neon -march=armv7-a"")
</code></pre>

<p>Maybe report an issue on github and tell the authors about it.</p>

<p><strong>EDIT</strong>: you want to do these edits in <a href=""https://github.com/uzh-rpg/fast/blob/master/CMakeLists.txt"" rel=""nofollow"">https://github.com/uzh-rpg/fast/blob/master/CMakeLists.txt</a></p>

<p>Also try setting export ARM_ARCHITECTURE=1 before compiling </p>
",,39666469,1565
32525218,2,32524483,2015-09-11T13:56:14.383,3,,4952137,,2015-09-11T13:56:14.383,,0,,"<p>As far as I know there are some libraries you can use to control the GPIO, but I prefer writing directly to /sys/...</p>

<p>In bash you can do it like this:</p>

<pre><code>echo ""out"" &gt; /sys/class/gpio/gpio17/direction
echo ""1"" &gt; /sys/class/gpio/gpio17/value
</code></pre>

<p>And finally to clean it up</p>

<pre><code>echo ""17"" &gt; /sys/class/gpio/unexport
</code></pre>

<p>You can yust ""translate"" this to C++ using e.g. ofstream:</p>

<pre><code>//Set pin direction
std::ofstream out(""/sys/class/gpio/gpio17/direction"");
out&lt;&lt;""out"";
out.close();

//Set pin value
out.open(""/sys/class/gpio/gpio17/value"");
out&lt;&lt;""1"";
out.close();

//Cleanup
out.open(""/sys/class/gpio/unexport"");
out&lt;&lt;""17"";
out.close();
</code></pre>
",,39683371,716
32530402,2,32528449,2015-09-11T18:59:18.847,0,,4605105,,2015-09-11T18:59:18.847,,3,,"<p><code>nodePtr</code> is not set</p>

<p>Try this:</p>

<pre><code>movingAverageNode movingAverage::refresh(float r, float p, float h) {

  //create pointers and new node
  movingAverageNode* newNode = new movingAverageNode;
  newNode-&gt;roll = r;
  newNode-&gt;pitch = p;
  newNode-&gt;heading = h;
  movingAverageNode* nodePtr;

  //append last node
  if(!head){
    head = newNode;
    numNodes++;
  }else{
    nodePtr = head;
    while(nodePtr-&gt;next){
      nodePtr = nodePtr-&gt;next;
    }
    nodePtr-&gt;next = newNode;
    numNodes++;
  }
</code></pre>
",,39685625,930
32535000,2,32534928,2015-09-12T03:55:31.447,0,,421195,,2015-09-13T19:49:06.930,2017-04-13T12:50:09.193,2,,"<p>Here is a good example of the kind of thing you need to ""parse"" your input (different I/O device than I2C; sample principle):</p>

<p><a href=""http://forum.arduino.cc/index.php?topic=48925.0"" rel=""nofollow noreferrer"">http://forum.arduino.cc/index.php?topic=48925.0</a></p>

<pre><code>char inData[80];
byte index = 0;

void loop() {
   while(Serial.available() &gt; 0) {
      char aChar = Serial.read();
      if(aChar == '\n') {
         // End of record detected. Parse this line
         ...
         // When you're done parsing, clear the array and reset the index    
         inData[index] = NULL;
         index = 0;
      }
      else  {
         inData[index] = aChar;
         index++;
         inData[index] = '\0'; // Keep the string NULL terminated
      }
   }
}
</code></pre>

<p>One option for ""parsing"" might be to use <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer"">strtok()</a>.  Here is a good example:</p>

<p><a href=""https://arduino.stackexchange.com/questions/1013/how-do-i-split-an-incoming-string"">https://arduino.stackexchange.com/questions/1013/how-do-i-split-an-incoming-string</a></p>

<pre><code>char* command = strtok(inData, ""&amp;"");
while (command != 0) {
    // Split the command in two values
    char* separator = strchr(command, ':');
    if (separator != 0) {
        // Actually split the string in 2: replace ':' with 0
        *separator = 0;
        int servoId = atoi(command);
        ++separator;
        int position = atoi(separator);

        // Do something with servoId and position
    }
    // Find the next command in input string
    command = strtok(NULL, ""&amp;"");
}
</code></pre>
",,39686632,263
32594687,2,32594585,2015-09-15T20:05:33.607,4,,225074,,2015-09-15T20:15:01.793,2015-09-15T20:15:01.793,1,,"<p>Try this:</p>

<pre><code>uint16_t value;
uint8_t msb = (value &amp; 0xFF00U) &gt;&gt; 8U;
uint8_t lsb = (value &amp; 0x00FFU);
</code></pre>

<p><strong>Edit 1:</strong><br>
You could complicate matters and use a structure:  </p>

<pre><code>struct MSB_LSB
{
  unsigned int MSB : 8;
  unsigned int LSB : 8;
};
uint16_t value = 0x55aa;
uint8_t msb = ((MSB_LSB)(value)).MSB;
uint8_t lsb = ((MSB_LSB)(value)).LSB;
</code></pre>

<p>BTW, decimal, hexadecimal and octal are examples of <em>representations</em>.  The representations are for humans to understand.  The computer internally stores numbers in a representation convenient for the processor.  So when you specify a decimal number, the compiler converts the decimal number into a value better suited for the processor.  We humans, can represent the number in a representation that is easiest for us to understand.  </p>
",,39693302,759
32594847,2,32594585,2015-09-15T20:16:05.383,0,,1169096,,2015-09-15T20:16:05.383,,1,,"<p>using a union:</p>

<pre><code>typedef union
{
 unsigned short s;
 unsigned char b[2];
} short2bytes_t;

unsigned short value=65535;
unsigned char  MSB, LSB;

short2bytes_t s2b;
s2b.s = value;
MSB=s2b.b[1];
LSB=s2b.b[0];

printf(""%d -&gt; 0x%02X 0x%02X\n"", value, MSB, LSB);
</code></pre>
",,39719768,136
34299497,2,32596006,2015-12-15T21:13:33.660,0,,4322488,,2015-12-15T22:01:00.433,2015-12-15T22:01:00.433,0,,"<p>I was looking at this issue myself, and found this:</p>

<p><a href=""https://gist.github.com/jcw/1985789#file-bootcheck-ino"" rel=""nofollow"">https://gist.github.com/jcw/1985789#file-bootcheck-ino</a></p>

<p>This is to look up the bootloader; but I'm thinking that something like this could be used for determining a signature of some sort for the code as a whole.</p>

<p>I did a quick experiment, where I added something like:</p>

<pre><code>Serial.print(""Other..."");
Serial.println(CalculateChecksum(0, 2048));
</code></pre>

<p>in void setup(), and <em>was</em> able to get different values for the CRC, based on changing a tiny bit of code (a string).</p>

<p>This is not an explicit solution; I tried CalculateChecksum(0, 32767), and so on, and if I defined an integer like int a=101; and changed it to int a=102; the checksum was the same.  Only when I changed a string (i.e., add a space) did this value change.</p>

<p>I'm not crystal clear on the way memory is allocated in the Arduino; I do know there is program memory (32,256 bytes) and global variable memory (2048 bytes), so I'm sure there is some way of doing this.</p>

<p>In another experiment, I used the pgm_read_byte() function, and if I create a simple memory dump function:</p>

<pre><code>void MemoryDump (word addr, word size) {
  word dataval = ~0;
  // prog_uint8_t* p = (prog_uint8_t*) addr;
  uint8_t* p = (uint8_t*) addr;
  for (word i = 0; i &lt; size; ++i)
    {
    dataval = pgm_read_byte(p++);
    Serial.print(i);
    Serial.print("" -&gt;"");
    Serial.print(dataval,HEX);
    Serial.print("" "");
    Serial.print(dataval);
    Serial.print("" "");
    if(dataval&gt;32)
    {
    Serial.print(char(dataval));
    }
    else
    {
    Serial.print(""***"");
    }
    Serial.print(""\n"");
    }
}
</code></pre>

<p>... and I put in a line like:
Serial.println(F(""12345fghijklmnopqrstuvwxyz""));</p>

<p>because the F() puts the string in program memory, you will see it there.</p>

<p>Reading the SRAM is a bit of an issue, as noted here:</p>

<p><a href=""http://forum.arduino.cc/index.php?topic=220125.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=220125.0</a></p>

<p>I'm not a compiler god, so I don't know how stuff like a=101; looks to the compiler/IDE, or why this doesn't look different to the program memory area.</p>

<p>One last note:</p>

<p><a href=""http://playground.arduino.cc/Code/AvailableMemory"" rel=""nofollow"">http://playground.arduino.cc/Code/AvailableMemory</a></p>

<p>Those functions access SRAM, so perhaps, with a bit of tweaking, you could do a CRC on <em>that</em> memory, but it would seem a bit of an issue, since you have to be doing a computation with a variable... in SRAM!   But if the code was identical, even if doing a computation like that, it might be possible.  Again, I'm in deep water here, so if an AVR god has issue with this, please destroy this theory with an ugly fact!</p>
",,39742003,407
32597149,2,32597021,2015-09-15T23:12:46.257,2,,4142924,,2015-09-16T08:08:50.593,2015-09-16T08:08:50.593,2,,"<p>Something like this?</p>

<pre><code>int hold = 1;

// ...

if (hold)
    functionA();
else
    functionB();
hold = !hold;
</code></pre>

<p><strong>EDIT</strong>
Here are two more ways to do it. The first is simpler, using the <code>switch</code> statement, which is really just another way of doing <code>if...else..</code></p>

<pre><code>#include &lt;stdio.h&gt;

#define NUMFUNCS    4

int funcA(void);
int funcB(void);
int funcC(void);
int funcD(void);

int main(void){
    int action = 0;
    int res;
    while(1) {
        switch(action) {
            case 0:  res = funcA();
                     break;
            case 1:  res = funcB();
                     break;
            case 2:  res = funcC();
                     break;
            default: res = funcD();
                     break;
        }
        printf (""Function returned %d\n"", res);
        action = (action + 1) % NUMFUNCS;
    }
    return 0;
}

int funcA(void) {
    return 1;
}
int funcB(void) {
    return 2;
}
int funcC(void) {
    return 3;
}
int funcD(void) {
    return 4;
}
</code></pre>

<p>A little more complex is by using an array of function pointers. If you want to pass arguments to the functions, you'll need to change the array declaration too. The drawback is that unless you have variadic functions, they must all have the same arguments.</p>

<pre><code>#include &lt;stdio.h&gt;

#define NUMFUNCS    4

int funcA(void);
int funcB(void);
int funcC(void);
int funcD(void);

int (*funcarry[NUMFUNCS])(void) = {     // array of function pointers
    funcA, funcB, funcC, funcD
};

int main(void){
    int action = 0;
    int res;
    while(1) {
        res = (*funcarry[action])();
        printf (""Function returned %d\n"", res);
        action = (action + 1) % NUMFUNCS;
    }
    return 0;
}

int funcA(void) {
    return 1;
}
int funcB(void) {
    return 2;
}
int funcC(void) {
    return 3;
}
int funcD(void) {
    return 4;
}
</code></pre>
",,39745765,127
32791028,2,32790982,2015-09-25T21:39:23.203,5,,434551,,2015-09-25T21:39:23.203,,1,,"<p>If you want to go through each item of <code>attractSequence</code> only once, you can use:</p>

<pre><code>void loop()
{
   int count = sizeof(attractSequence)/sizeof(attractSequence[0]);
   for (int i = 0; i &lt; count; ++i )
   {
     attractSequence[i].proc(attractSequence[i].delayMsec);
   }
}
</code></pre>
",,39788834,934
32867492,2,32867422,2015-09-30T13:32:37.913,2,,253056,,2015-09-30T16:30:18.747,2015-09-30T16:30:18.747,4,,"<p>The function you are looking for is <a href=""http://linux.die.net/man/3/strstr"" rel=""nofollow"">strstr</a>:</p>

<pre><code>if (strstr(packetBuffer, ""testing"") != NULL)
{
    // packetBuffer contains ""testing""
    // so do something...
}
</code></pre>

<p>Note: if you need to test for the substring just at the start of the string then you can do it like this:</p>

<pre><code>if (strstr(packetBuffer, ""testing"") == packetBuffer)
{
    // packetBuffer starts with ""testing""
    // so do something...
}
</code></pre>
",,39839796,346
32882514,2,32882361,2015-10-01T08:07:49.220,0,,440558,,2015-10-01T09:01:40.213,2017-05-23T12:22:23.407,4,,"<p>C++ is very much like Java in some regards, like you having to properly declare functions (member or non-members), including <em>return type</em> (which you don't do for the <code>init::camera</code> function).</p>

<p>In other regards C++ is very different from Java, like you not have to specify access/visibility for each member (like you do in the <code>ServoControl</code> class). </p>

<p>Also, both C++ and Java classes are <em>abstract descriptions</em>, not actual object instances, if you want to use a non-static member function in a class you need to create an instance of that class first.</p>

<p>You might want to check out <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">The Definitive C++ Book Guide and List</a> if you want to learn more about C++.</p>

<hr>

<p>As noted by zstewart in a comment, in C++ you don't need classes at all. Functions can be stand-alone in the global scope, and in this case it looks like the classes aren't needed at all. If one still want to use some kind of scoping, then using a <code>namespace</code> might be a better idea. Like for example</p>

<pre><code>namespace init
{
    void camera()
    {
        ...
    }
}
</code></pre>

<p>This can them be called like</p>

<pre><code>init::camera();
</code></pre>
",,39865734,608
32931148,2,32900314,2015-10-04T07:38:04.503,1,,3102264,,2015-10-04T08:55:21.637,2015-10-04T08:55:21.637,2,,"<p>There is 2 different variables called <code>queryString</code> :</p>

<ul>
<li>the global one declared in <code>WebServer.cpp</code></li>
<li>the member of WebServer declared in <code>WebServer.h</code>  </li>
</ul>

<p>In the callback <code>handleSomeData</code> you set the global one, but in the <code>loop</code> and <code>finishedProcessingData</code> you access to the member of WebServer.</p>

<p>To make the code works, you could remove the member of WebServer and use the global one (as you did for aNumberHere) like this :</p>

<pre><code>extern String queryString;

void loop(){
    delay(10);
    webServer.handleClient();

    // check if the query string has stuff in it, if it doesn't then WebServer.handleSomeData() never fired, thus no request yet
    if(queryString != """"){
        // do stuff that results in a string being returned
        processingResult = handWavyMagic();
        // then respond back to client
        webServer.finishedProcessingData(processingResult);
        queryString = """";
    }
}
</code></pre>
",,39866623,39
36793193,2,32900314,2016-04-22T11:55:07.720,6,,1711425,,2016-04-22T11:55:07.720,,0,,"<p>I know, this is a bit late for the OP to help with his problem, but maybe other readers will find this useful.</p>

<p>To avoid splitting parts of the logic/data inside and outside the class it would be more elegant to have everything <em>inside</em>. Using callbacks to non-static methods of a class instance is a bit tricky (I learned it the hard way for my current project), but here is the alternative:</p>

<pre><code>void WebServer::begin()
{
    // instead of server.on(""/data.html"", handleSomeData);
    server.on(""/data.html"", std::bind(&amp;WebServer::handleSomeData, this));
    server.begin();
}

void WebServer::handleSomeData()
{
    // do whatever you need
}
</code></pre>

<p>This uses std:bind() to bind the instance method and its <code>this</code> pointer to the callback. As a result, everything is contained inside the web server instance, which is a cleaner approach.</p>
",,39866771,201
32988850,2,32987397,2015-10-07T09:38:22.320,2,,2209511,,2015-10-07T11:24:04.147,2015-10-07T11:24:04.147,1,,"<p>Surprisingly this compiled in Visual Studio 2015.</p>

<blockquote>
  <ol>
  <li>Size of vClass is 8 bytes. But a 10 element vector of type vClass shows size of 12 bytes. Why is this ? I was expecting 8x10= 80 bytes.</li>
  </ol>
</blockquote>

<p>Well, a <code>vector</code> is just a handle. Its elements are stored in the heap. All the <code>vector</code> needs is a pointer to these elements in the heap (<code>data</code>), the current number of elements (<code>size</code>) and the maximum number of elements (<code>capacity</code>).
So if you grow/shrink the vector, the handle's size always remains the same and only the array in the heap will change.</p>

<pre><code>vector&lt; vClass &gt; myVect;

// Stack - vector
[ vector: data, size, capacity ]
            |
            |
            V
// Heap - array managed by vector
[ vClass0 ][ vClass1 ]...

// Each has completely unrelated addresses
</code></pre>

<blockquote>
  <ol start=""2"">
  <li>The expression: this - myVect.data() results in outputting the index of the elements. I expected I would need (this -
  myVect,data())/sizeof(vClass). Is this always the case with vectors ?
  I tried the same with an array : vClass myArray[10] and (this -
  myArray) but here i got a list of sequential hexadecimal numbers
  (addresses?). So the 'this' pointer is somehow linked to the vector,
  but not the array ?</li>
  </ol>
</blockquote>

<p>This works because <code>this</code> and <code>myVect.data()</code> are both pointers to <code>vClass</code> in the managed array. You don't need to divide by <code>sizeof(vClass)</code> because pointer arithmetics take into account the size of the type they point to.</p>

<p><code>sizeof(vClass) == sizeof(int)</code>, when you increment, decrement or subtract pointers they move in blocks the same size of the pointed type so you don't have to explicitly increment a pointer with the right size. You do get the indices 0,1,2,... but in other words that would also mean <em>2 vClass'es would fit between this address and this address</em>.</p>

<p>When you try this with an array of vectors, each vector is contiguous in memory (each handle). But also, each vector points to its own array in the heap so each array is completely unrelated. But I don't know exactly what code you tested with so I won't comment on that.</p>

<p>The <code>this</code> pointer, given that your <code>vClass</code> instances belong in the <code>vector</code>, is actually linked to the internal array of the <code>vector</code> and not to the <code>vector</code> handle itself.</p>

<hr>

<p>This works because your class is a POD-class. If you were to make a vector of pointers (each instance would be in unrelated addresses), or use a pointer to a base class (each instance in an unrelated address AND derived types would have different sizes), then this wouldn't work.</p>

<p>Although this example works, I won't encourage you to do this (besides this only works because your vector is a global variable). You're moving from C to C++, and I understand old habits die hard, but avoid pointer arithmetics unless you really must use it.</p>

<p>You can get the <code>vector</code>'s size by (you got it right) calling the <code>size()</code> method, and if you need to know an element's index you will know when you iterate the vector. (There are other ways sure, but that's up to you)</p>

<p><strong>EDIT: About indices and iteration</strong></p>

<p>When you iterate arrays or vectors, you can iterate by index (among other forms of iteration). So obviously, each iteration you know one index,</p>

<pre><code>for ( int i = 0; i &lt; myVect.size(); ++i ) {
    myVector[ i ]; // &lt;-- here's an object with index i, easy
}
</code></pre>

<p>Which is basically what you did when you printed your vector.</p>

<p>If you need to know a specific index without iterating (whether you need it to erase an element, or direct access, etc), you can, for example, have a separate container with relevant indices, or store it in the object as an ID, like,</p>

<pre><code>class vClass {
    // ...
    int ID; // Or index, but I think ID sounds better
    // ...
};
</code></pre>

<p>Then when you push elements into the vector you can set their IDs and they will know their index. Of course, you have to update the indices yourself if you sort the vector. They won't ""auto-update"" like when you used the pointers, but your instances had to know exactly which container they were in and had to use implementation details to find their index (specifically for vectors), and contained objects shouldn't need to do that.</p>

<p>As I said there are many solutions to this. It depends on what you want to do.</p>
",,39879324,84
32995000,2,32994710,2015-10-07T14:30:04.567,1,,450609,,2015-10-07T14:30:04.567,,1,,"<p>If you need any parameters to your function then they need to be passed in via the context pointer that's what it is there for.  So a simple example might be the following:</p>

<pre><code>void doAfter(void *my_param) {
     int x = *(int *)my_param;

     ..... your code here ...

}
</code></pre>

<p>And then to call it you would just do</p>

<pre><code>const int input_param = 5;
int afterEvent = t.after(10000, doAfter, (void *)&amp;input_param);
</code></pre>

<p>If you needed to pass more than one parameter then that can be done with a struct:</p>

<pre><code>struct param_list {
     int param1;
     double param2;
};

void doAfter2(void *context)
{
      struct param_list *params = context;

      .... code here can access params with params-&gt; ..

}

struct param_list p = {1, 2.0};
int afterEvent = t.after(10000, doAfter2, (void *)&amp;p);
</code></pre>
",,39925689,673
33040005,2,33039930,2015-10-09T13:50:23.637,5,,335858,,2015-10-09T13:53:30.793,2015-10-09T13:53:30.793,7,,"<p>What you are trying to do is not allowed, because the moment the <code>readWifDataAsSever</code> exits the <code>data</code> becomes invalid. Accessing it through any pointers that may be still pointing to it is undefined behavior.</p>

<p>However, your program is not even doing that: since you pass <code>reqData</code> pointer by value, any assignments to it have no effect in the caller, i.e.</p>

<pre><code>reqData=data;
</code></pre>

<p>does <em>not</em> change what the caller of your function sees.</p>

<p>In order to fix the problem you need to do one of two things:</p>

<ul>
<li>Pass a valid <em>buffer</em> to the function, along with its length, or</li>
<li>Make a dynamic allocation inside the function, and have the caller free the result.</li>
</ul>

<p>Since you are working on an embedded system with limited resources, the first approach is the most appropriate in your situation:</p>

<pre><code>size_t readWifDataAsSever(char* reqData, size_t maxLen) {
    if (len &gt; 0)  {
        size_t activeLength = len &lt; maxLen ? len : maxLen;
        for(size_t i = 0 ; i &lt; activeLength ; i++) {
            reqData[i]=(char)buffer[i];
        }
        return activeLength;
    } else {
        reqData[0] = '\0';
        return 0;
    }
}
</code></pre>
",,39985320,4520
33077997,2,33077354,2015-10-12T09:44:23.613,0,,794606,,2015-10-13T07:21:46.937,2015-10-13T07:21:46.937,3,,"<p><em>EDIT: original answer part before explanation:</em></p>

<p>Depends on compiler, compiler  options etc <code>char</code> can be <code>signed</code> or <code>unsigned</code>, cast via <code>(char)</code> can work different than You expect.</p>

<p>Example: </p>

<p>payload[i] is 0x81</p>

<p>unsigned char -> 129, then >0 </p>

<p>signed char -> -127, then &lt;0 </p>

<p>Your cast via (char) is redundant (and unstable like i said)</p>

<p>I don't give sample code because I don't understand Your goal. Code has contradictions.</p>

<p>Disclaimer: Your <code>byte</code> seems non standard type. I <strong>belive</strong> that is <code>unsigned char</code> a such type NEVER is &lt;0 .</p>

<p>What is main sense of this variable? In deep, it is signed or unsigned? You can cast <code>(unigned char)</code> but is never&lt;0 or <code>(signed char)</code> - up to You</p>

<p>EDIT:
after comment of asker, and interpretation from knolleary hot to interpret length (important: change of loop sense, maybe you understand author correctly) I give pure C conversion</p>

<pre><code> int val = 0;
  for (int i=0; i&lt;length; i++) {
      val = val*10 + payload[i]-'0';
  }
// If someone know end of number is marked in different way, need implement break of `for`
  fsrReading =val;
</code></pre>

<p>I believe my is few CPU cycles/RAM better.</p>

<p><strong>EDIT2:</strong> I have read few materials from Arduino community, problem with loop concatenation into String is like in many languages: many, many small allocations (while concatenation is totally not required here). Many good Arduino programmers are critical to overuse of <code>String</code>. It isn't ""secret knowledge"", it is general rule in programming.</p>

<p><a href=""http://forum.arduino.cc/index.php?topic=185469.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=185469.0</a> </p>

<p><a href=""http://www.gammon.com.au/concat"" rel=""nofollow"">http://www.gammon.com.au/concat</a></p>
",,39998247,49
33082161,2,33077354,2015-10-12T13:17:16.013,2,,2117239,,2015-10-12T13:17:16.013,,3,,"<p>The correct way to do this depends on exactly what representation of a number is being used.</p>

<p>I suspect the message is a string representation of a number: ""1234"", which is being received as an array of ascii byte values.</p>

<p>If that is the case, you can rebuild a String object and convert it to an int:</p>

<pre><code>int fsrReading;
void callback(char* topic, byte* payload, unsigned int length) {
  String value = """";
  for (int i=0;i&lt;length;i++) {
      value += (char)payload[i];
  }
  fsrReading = value.toInt();
  ...
</code></pre>

<p>There is an example of converting a String to an Int in the arduino tutorials here: <a href=""https://www.arduino.cc/en/Tutorial/StringToIntExample"" rel=""nofollow"">https://www.arduino.cc/en/Tutorial/StringToIntExample</a></p>
",,40045054,4490
33085396,2,33084754,2015-10-12T15:58:32.843,0,,3669613,,2015-10-13T11:06:48.550,2015-10-13T11:06:48.550,2,,"<p>In order to have the C++ program do the work it has to do you could call it from your python script, read its output and send some input when you need to do some more work. In order to achieve this you could use the <a href=""https://docs.python.org/2/library/subprocess.html"" rel=""nofollow"">subprocess</a> library provided by python.</p>

<p>Your C++ code would then need wait for some special input (e.g. a new-line-character '\n' or something like that), then calculate what needs to be calcualted and then write the data to <code>stdout</code> and then write a line that indicates the end of the dataset (e.g simply write 'end', or a blank line)</p>

<p>Your python code would look something like this:</p>

<pre><code>import subprocess

#Start the c++ program
process = subprocess.Popen(['&lt;path to the c++ executable&gt;', &lt;arg1&gt;, &lt;arg2], stdin=subprocess.PIPE)
#Grab its output
p_out = process.stdout
#Grab its input
P_in = p.stdin

while True:
    p_in.write('\n')
    lines = []
    line = p_out.readline().decode(""utf-8"").strip()
    while line:
      &lt;process the read data&gt;
      line = p_out.readline().decode(""utf-8"").strip() 
</code></pre>
",,40061836,770
33144008,2,33125117,2015-10-15T08:53:42.143,0,,5435628,,2015-10-15T08:53:42.143,2017-05-23T12:03:52.263,0,,"<p>Issue was resolved.</p>

<p>Thanks , got idea from this post.
<a href=""https://stackoverflow.com/questions/20870943/invalid-conversion-from-char-to-char"">invalid conversion from <code>char' to</code>char*'</a></p>

<p>How !  changed </p>

<pre><code>// read Host Name
if (param_number &gt;= 25 &amp;&amp; param_number &lt;= 35) {
 // eeprom_config.HostName[param_number - 25] = strtol(value, NULL, 10);
    eeprom_config.HostName[param_number - 25] =  value ; // Facing Issue here..
}
</code></pre>

<p>changed to </p>

<pre><code>// read Host Name
if (param_number &gt;= 25 &amp;&amp; param_number &lt;= 35) {
eeprom_config.HostName[param_number - 25] = value[0];

}
</code></pre>
",,40071375,1805
33158191,2,33158123,2015-10-15T20:43:37.413,6,,434551,,2015-10-15T20:48:46.993,2015-10-15T20:48:46.993,2,,"<blockquote>
  <p>How can I avoid typing this very long conditions, knowing that I'm always checking the same parameter, only the index of my structure is changing.</p>
</blockquote>

<p>Add a function to do the checks and use the function in the <code>while</code> statement.</p>

<pre><code>// MotorType is my contrived type. Use the right type.
bool doCheck(MotorType* motors, int count, int maxcycle)
{
   for (int i = 0; i &lt; count; ++i )
   {
      if ( !(motors[0].cycle &lt;= maxcycle) )
      {
         return false;
      }
   }
   return true;
}

while(doCheck(motors, count, maxcycle))
{
}
</code></pre>
",,40075468,351
33158197,2,33158123,2015-10-15T20:43:57.720,0,,202009,,2015-10-15T20:48:42.573,2015-10-15T20:48:42.573,2,,"<p>Abstract the condition into a method.</p>

<pre><code>while ( allMotorsLessThanMax( motors, countMotors )) {
 ...
}
</code></pre>

<p>Then define that method with its own iteration:</p>

<pre><code>bool allMotorsLessThanMax( Motor motors[], int countMotors ) {
   for ( int i = 0; i &lt; countMotors; ++i ) {
     if ( maxcycle &lt; motors[i].cycle ) {
         return false;
     }
  } 
  return true;
}
</code></pre>
",,40076037,217
33158222,2,33158123,2015-10-15T20:45:29.593,0,,5235574,,2015-10-15T20:45:29.593,,0,,"<p>You could do it in a loop:</p>

<pre><code>while(true)
{
  for(int i = 0, i &lt; number, i++)
  {
    if (motors[i].cycle &gt; maxcycle)
    {
      break;
    }
  }
  //Do something
}
</code></pre>
",,40093116,5373
33158294,2,33158123,2015-10-15T20:49:17.497,0,,4892076,,2015-10-15T20:54:34.057,2015-10-15T20:54:34.057,0,,"<p>Put it in a check in a lambda:</p>

<pre><code>#include &lt;algorithm&gt;

...
void myFunction(){

    auto allCycling = [&amp;]() -&gt; bool { // lambda function, capture by reference
        return std::all_of( // for every element in the given range
          motors.begin(), motors.end(), // given range is all of the motors container
          [](const decltype(motors[0])&amp; motor) -&gt; bool {
            return motor.cycle &lt;= maxcycle; // check
          });

    while(allCycling()){
        //do stuff
    }
}
</code></pre>

<p>The capture by reference <code>[&amp;]</code> for the lambda allows you to access all your function-wide variables in the lambda, without worrying about the costs of copying them.</p>
",,40137637,523
33158539,2,33158123,2015-10-15T21:05:52.163,0,,301883,,2015-10-15T21:05:52.163,,0,,"<p>I'll toss in the TMP version:</p>

<pre><code>template &lt; size_t I &gt;
struct check_it
{
    static bool call(motor_type * motors)
    {
       return check_it&lt;I-1&gt;::call(motors) &amp;&amp; motors[I].cycles &lt;= maxcycles;
    }
 }

 template &lt; &gt;
 struct check_it&lt;0&gt;
 {
     static bool call(motor_type * motors) { return motors[0].cycles &lt;= maxcycles; }
 };

 while (check_it&lt;42&gt;::call(motors)) { ... }
</code></pre>

<p>Edit: I'm not necessarily recommending this, but it should optimize into exactly what you wrote.  Hard to say if it's actually faster.  Would depend on how many of the instructions are within the cache, etc...  Maybe?  You'd want to profile if it's important.</p>
",,40141047,820
33178637,2,33178470,2015-10-16T19:58:15.453,1,,2864275,,2015-10-16T19:58:15.453,,0,,"<p>as it was said in comments - the main problem that you need pointer, but provide struct, one variant to work around this could be:</p>

<pre><code>struct CommandNode next = {.command = {.toBrightness = 50, .overTime = 0.5}, .next = NULL};
struct SequenceNode pattern = {.sequence = {
        .commands = {
                .command = {.toBrightness = 100, .overTime = 1.0},
                .next = &amp;next},
        .startTime = 0.0,
        .staggerTime = 1.0,
        .pins = {0, 1, 2, 3, 4, 5}
    },
    .next = NULL};
</code></pre>
",,40246601,3398
33190815,2,33188719,2015-10-17T19:40:39.057,1,,196844,,2015-10-17T19:40:39.057,,0,,"<p>The code as listed has a stack overflow issue.  Within <code>Wrapper::delay(unsigned long)</code>, <code>delay(t)</code> calls <code>Wrapper::delay</code> again rather than the <a href=""https://www.arduino.cc/en/Reference/Delay"" rel=""nofollow"">Arduino <code>delay()</code> routine</a>.</p>

<p>If you want to call the Arduino <code>delay()</code> routine within <code>Wrapper::delay</code>, you need to qualify the call like so:</p>

<pre><code>class Wrapper
{
public:
  void delay(unsigned long t)
  {
    ::delay(t);
  }
};
</code></pre>
",,40247793,81
33210675,2,33204808,2015-10-19T09:13:29.797,0,,849463,,2015-10-19T09:13:29.797,,0,,"<p>use Serial to debug your program</p>

<p>output every variable(id temp pin), then you will find out the answer</p>

<p>here is the example of Serial </p>

<pre><code>void setup() {
  pinMode(2, INPUT);
  pinMode(3, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  digitalWrite(3, digitalRead(2));
  int n = analogRead(A0);
  Serial.print(""analogRead from A0:"");
  Serial.print(n);
  Serial.print(""\n"");
  delay(100);
} 
</code></pre>
",,40249512,1838
34012539,2,33247615,2015-12-01T04:19:53.560,0,,4541045,,2015-12-01T04:19:53.560,2017-05-23T10:27:11.507,0,,"<p>Your question is rather unclear, so I've answered both interpretations I got from it.</p>

<h2>If you are referring to using a Teensy as an input device.</h2>

<p>Yes, this should be possible with all Teensy units if you use <a href=""https://www.pjrc.com/teensy/teensyduino.html"" rel=""nofollow noreferrer"">teensyduino</a> under the OS of your choice. Simply put in your code and set the <a href=""https://www.pjrc.com/teensy/td_keyboard.html"" rel=""nofollow noreferrer"">Teensy as a HID device</a> to use it.<br>
To restate good advice, be careful testing as a rogue keyboard can quickly cause a lot of trouble for you.</p>

<h2>If you are referring to getting a C program to emulate a keyboard.</h2>

<p>Yes, this is also possible.</p>

<p><strong>Linux Instructions</strong></p>

<p><a href=""http://www.doctort.org/adam/nerd-notes/x11-fake-keypress-event.html"" rel=""nofollow noreferrer"">Example Code</a> - <a href=""https://stackoverflow.com/a/4427801/4541045"">Found on SO</a><br>
The example uses <code>#define KEYCODE XK_Down</code>, which is ""safe"", but can be hard to show. Try adding <code>#define KEYCODE XK_A</code>, <code>#include &lt;unistd.h&gt;</code>, and <code>usleep(2000000); // 2 seconds</code> in appropriate places to control the behavior.<br>
Additionally, if you need C instead of C++, change <code>Window &amp;win</code> to <code>Window win</code> in <code>createKeyEvent</code></p>

<p>Modified code below <code>XFakeKey.c</code></p>

<pre><code>// Send a fake keystroke event to an X window.
// by Adam Pierce - http://www.doctort.org/adam/
// This is public domain software. It is free to use by anyone for any purpose.

// debug message, delay, and conversion to C by ti7
// original code found at http://www.doctort.org/adam/nerd-notes/x11-fake-keypress-event.html

#include &lt;X11/Xlib.h&gt;
#include &lt;X11/keysym.h&gt;

// The key code to be sent.
// A full list of available codes can be found in /usr/include/X11/keysymdef.h
//#define KEYCODE XK_Down
#define KEYCODE XK_A

// Function to create a keyboard event
XKeyEvent createKeyEvent(Display *display, Window win,
                           Window winRoot, int press,
                           int keycode, int modifiers)
{
   XKeyEvent event;

   event.display     = display;
   event.window      = win;
   event.root        = winRoot;
   event.subwindow   = None;
   event.time        = CurrentTime;
   event.x           = 1;
   event.y           = 1;
   event.x_root      = 1;
   event.y_root      = 1;
   event.same_screen = True;
   event.keycode     = XKeysymToKeycode(display, keycode);
   event.state       = modifiers;

   if(press)
      event.type = KeyPress;
   else
      event.type = KeyRelease;

   return event;
}

#define true 1
#define false 0

#include &lt;stdio.h&gt; // for printf
#include &lt;unistd.h&gt; // for time
main()
{
// Obtain the X11 display.
   Display *display = XOpenDisplay(0);
   if(display == NULL)
      return -1;
    printf(""it's working\n"");
// Get the root window for the current display.
   Window winRoot = XDefaultRootWindow(display);

    usleep(1000000);
// Find the window which has the current keyboard focus.
   Window winFocus;
   int    revert;
   XGetInputFocus(display, &amp;winFocus, &amp;revert);

// Send a fake key press event to the window.
   XKeyEvent event = createKeyEvent(display, winFocus, winRoot, true, KEYCODE, 0);
   XSendEvent(event.display, event.window, True, KeyPressMask, (XEvent *)&amp;event);

// Send a fake key release event to the window.
   event = createKeyEvent(display, winFocus, winRoot, false, KEYCODE, 0);
   XSendEvent(event.display, event.window, True, KeyPressMask, (XEvent *)&amp;event);

// Done.
   XCloseDisplay(display);
   return 0;
}
</code></pre>

<p>Compile with <code>gcc -o XFakeKey XFakeKey.c -L/usr/X11R6/lib -lX11</code></p>

<p><strong>Windows Example</strong></p>

<p><a href=""https://batchloaf.wordpress.com/2012/04/17/simulating-a-keystroke-in-win32-c-or-c-using-sendinput/"" rel=""nofollow noreferrer"">Example Code</a><br>
I'm feeling brave and have not tested this, so hold on to your pants.</p>
",,40253441,192
33257838,2,33257028,2015-10-21T11:12:14.607,0,,4487286,,2015-10-21T11:12:14.607,,2,,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int c1,c2,c3;

int n=0;
char sResult[20];

void PrintLevel(int lvl){
    if(n){
        printf(""d[%d][%d][%d] = \""%s\""\n"",c3,c2,c1,sResult);
        n=0;
    }
    switch(lvl){
        case 3:
            c3++;
            c2=c1=0;
            break;
        case 2:
            c2++;
            c1=0;
            break;
        case 1:
            c1++;
    }

    return ;
}

void addChar(char c){
    sResult[n]=c;
    n++;
    sResult[n]=c=0;
}
/*______________________________________________________________________
*/

int main(){
    char buff[]= ""0,1,2,4444444444;5,6,7,8888888888;.9,10,11,12121212;."";
    PrintLevel(0);
    char *p=buff;
    char c;
    int ret;
    int lvl;
    while(c=*p){

        lvl=(c==',')?1:((c==';')?2:((c=='.')?3:0) );

        if(lvl)
            PrintLevel(lvl);
        else
            addChar(c);
        p++;
    }
    PrintLevel(lvl);

}
</code></pre>
",,40260563,3057
33259668,2,33257028,2015-10-21T12:44:05.737,0,,2642059,,2015-10-21T12:44:05.737,,1,,"<p>First note that a <code>long</code> is too small to hold even: <code>4444444444</code> <a href=""https://msdn.microsoft.com/en-us/library/296az74e.aspx"" rel=""nofollow"">It's max size is: <code>2147483647</code></a></p>

<p>If a <code>long long</code> is used however the string can be eloquently parsed by a <a href=""http://en.cppreference.com/w/cpp/regex/regex_token_iterator"" rel=""nofollow""><code>regex_token_iterator</code></a>. The parsing function should take in the input <code>string</code> and the delimiter and return separated <code>strings</code>. These inputs enable reuse in a function similar to this one:</p>

<pre><code>auto parse(const string&amp; input, const string&amp; delimiter) {
    const regex re(""([^"" + delimiter + ""]+)"" + delimiter + '?');

    return vector&lt;string&gt;(sregex_token_iterator(input.begin(), input.end(), re, 1), sregex_token_iterator());
}
</code></pre>

<p>This will return the <code>input</code> in a partitioned <code>vector&lt;string&gt;</code>. This return can then be partitioned until the third dimension in which each partition will contain only numeric characters. At that point <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow""><code>stoll</code></a> can be used to convert the <code>string</code> to a <code>long long</code>. This partitioning can be accomplished in nested loops like this:</p>

<pre><code>vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; foo;

for (auto&amp; i : parse(str, ""\\."")) {
    foo.resize(foo.size() + 1);
    for (auto&amp; j : parse(i, "";"")) {
        foo.back().resize(foo.back().size() + 1);
        for (auto&amp; k : parse(j, "","")) {
            foo.back().back().push_back(stoll(k));
        }
    }
}
</code></pre>

<p>One key aspect of this is that each partition must contain a number. This is enforced by the <code>'+'</code> in <code>re</code> which will not match if consecutive delimiters occur. <code>stoll</code> is very robust and will eat whitespace if that is in the input <code>string</code>, however if a <code>string</code> containing only whitespace or generally does not contain a number is fed to it it will throw an error. If that is a concern be sure to check your inputs before calling <code>stoll</code>.</p>

<p>You can see a live example of this here: <a href=""http://ideone.com/4vjdBx"" rel=""nofollow"">http://ideone.com/4vjdBx</a></p>
",,40266499,58
33260205,2,33257028,2015-10-21T13:07:26.760,1,,4605105,,2015-10-21T14:10:23.757,2015-10-21T14:10:23.757,3,,"<p>With a dynamic flat array in pure C and then alloc the 3D array
The array size is double each time needed
You can set the first size with the define:</p>

<pre><code>#define DEFAULT_SIZE 8 
</code></pre>

<p>as said in my comment the format is strange <code>;.</code> should be <code>.</code> and the final <code>;.</code> should be removed</p>

<p>I add test to check if next line as the same size than the first one.</p>

<pre><code>int main(void) { 
    char *data = ""1,2,3,1445303228;4,5,6,1445303228;.7,8,9,1445303273;.""; 
    char *p; 
    int size = DEFAULT_SIZE; 
    int nb_element = 0; 
    int s1 = 0; 
    int s2 = 0; 

    int cur1 = 0; 
    int cur2 = 0; 
    int cur3 = 0; 

    int *d = malloc(sizeof(int) * DEFAULT_SIZE); 
    int ***d3; 

    if (!d) { 
        return -1; 
    } 

    p = data; 
    while (*p) { 
        if (nb_element == size) { 
            size *= 2; 
            d = realloc(d, size * sizeof(int)); 
            if (!d) { 
                return -1; 
            } 
        } 
        d[nb_element++] = strtol(p, &amp;p, 10); 
        switch (*p) { 
          case ',': 
            cur1++; 
            if (s1 &amp;&amp; cur1 &gt; s1) { 
                fprintf(stderr, ""Too many element for %d, %d:"" 
                        "" get %d, expect %d\n"", cur2, cur3, cur1, s1); 
                return -1; 
            } 
            break; 
          case ';': 
            cur1++; 
            cur2++; 
            if (s1 == 0) { 
                s1 = cur1; 
            } 
            cur1 = 0; 
            if (s2 &amp;&amp; cur2 &gt; s2) { 
                fprintf(stderr, ""Too many element for %d:"" 
                        "" get %d, expect %d\n"", cur3, cur2, s2); 
                return -1; 
            } 
            break; 
          case '.': 
          dot: 
            cur2++; 
            cur3++; 
            if (s2 == 0) { 
                s2 = cur2; 
            } 
            cur2 = 0; 
            cur1 = 0; 
            break; 
        } 
        p++; 
        /* XXX: ack due to strange format */ 
        if (*p == '.') 
            goto dot; 
    } 
    /*XXX! remove empty final line */ 
    cur3--; 

    d3 = malloc(sizeof(int **) * cur3); 
    for (int i = 0; i &lt; cur3; i++) { 
        d3[i] = malloc(sizeof(int *) * s2); 
        for (int j = 0; j &lt; s2; j++) { 
            d3[i][j] = malloc(sizeof(int) * s1); 
            for (int k = 0; k &lt; s1; k++) {  
                d3[i][j][k] = d[i * s2 + j * s1 + k]; 
            } 
        } 
    } 
    free(d); 
    for (int i = 0; i &lt; cur3; i++) { 
        for (int j = 0; j &lt; s2; j++) { 
            for (int k = 0; k &lt; s1; k++) { 
                fprintf(stdout, ""d[%d][%d][%d] = %d\n"", i,j,k, d3[i][j][k]); 
            } 
        } 
    } 
    return 0; 
} 
</code></pre>

<p>output:</p>

<pre><code>d[0][0][0] = 1
d[0][0][1] = 2
d[0][0][2] = 3
d[0][0][3] = 1445303228
d[0][1][0] = 4
d[0][1][1] = 5
d[0][1][2] = 6
d[0][1][3] = 1445303228
d[0][2][0] = 7
d[0][2][1] = 8
d[0][2][2] = 9
d[0][2][3] = 1445303273
</code></pre>
",,40287871,53
33262285,2,33257028,2015-10-21T14:38:43.257,0,,5470921,,2015-10-24T03:52:40.660,2017-05-23T12:03:50.797,0,,"<p>got it working with a code that is mainly based on <a href=""https://stackoverflow.com/a/33257838/5470921"">@milevyo's answer</a>.</p>

<pre><code>struct ds { int a = 0, b = 0, c = 0; long d = 0; };

struct data {
  struct ds array[32][8];
  int i, j[24];

  int n = 0, d1, d2, d3; char r[11];
  void get(String array) {
    if (array.length() + 1 != 1) {
      char buff[array.length() + 1];
      array.toCharArray(buff, array.length() + 1);
      char c; char *p = buff; int l;
      while (c = *p) {
        l = (c == ',') ? 1 : ((c == ';') ? 2 : ((c == '.') ? 3 : 0));
        if (l) a(l); else ch(c); p++;
      }
      a(l);
    }
  }
  void a(int l) {
    if (n) {
      if (d1 == 0) array[d3][d2].a = atoi(r);
      else if (d1 == 1) array[d3][d2].b = atoi(r);
      else if (d1 == 2) array[d3][d2].c = atoi(r);
      else if (d1 == 3) array[d3][d2].d = atol(r);
      i = d3 + 1; j[d3] = d2 + 1; n = 0;
    }
    switch (l) {
      case 3: d3++; d2 = d1 = 0; break;
      case 2: d2++; d1 = 0; break;
      case 1: d1++; break;
    }
  }
  void ch(char c) { r[n] = c; n++; r[n] = c = 0; }
} data;

void setup () {
  Serial.begin(19200); 
  Serial.println(""..""); 

  data.get(""1,2,3,1445433855;4,5,6,1445433855;.7,8,9,1445438763;."");

  for (int i = 0; i &lt; data.i; i++) {
    for (int j = 0; j &lt; data.j[i]; j++) {
      for (int k = 0; k &lt; 4; k++) {
        if (k == 0) Serial.print(data.array[i][j].a);
        else if (k == 1) Serial.print(data.array[i][j].b);
        else if (k == 2) Serial.print(data.array[i][j].c);
        else if (k == 3) Serial.print(data.array[i][j].d);
        Serial.print(""\t"");
      }
      Serial.println();
    }
    Serial.println();
  }
}

void loop () { }
</code></pre>

<p>from</p>

<pre><code>1,2,3,1445433855;4,5,6,1445433855;.7,8,9,1445438763;.
</code></pre>

<p>to</p>

<pre><code>..
1   2   3   1445433855  
4   5   6   1445433855  

7   8   9   1445438763  
</code></pre>

<p>via</p>

<pre><code>..
data.array[0][0].a  data.array[0][0].b  data.array[0][0].c  data.array[0][0].d
data.array[0][1].a  data.array[0][1].b  data.array[0][1].c  data.array[0][1].d

data.array[1][0].a  data.array[1][0].b  data.array[1][0].c  data.array[1][0].d
</code></pre>
",,40326502,179
33265128,2,33257028,2015-10-21T16:59:34.803,0,,4487286,,2015-10-24T02:37:17.963,2015-10-24T02:37:17.963,18,,"<p>i hope you saved the last post, this is an update to the last one, it handle 2D arrays as requested. hope you find it useful, if so send me a postcard :) </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;


/*__________________________________________________________________________
*/

struct DATA{
   char a;
   char b;
   char c;
   unsigned long d;
};


/*__________________________________________________________________________

  allocate DATA struct, and fill it.
  on error or no data, returns NULL
*/
struct DATA *ParseString(char **pstr){
    int val=0;
    char *p;
    struct DATA *data;
    if(!pstr) return NULL;

    char *str=*pstr;
    if(!str) return NULL;

    // can be ommited
    // skipping non digital chars
    while(*str &amp;&amp; !isdigit(*str))
        str++;

    //no digits?
    if(!*str) return NULL;

    p=str;
    //ok at least one
    data=(struct DATA*) calloc(1,sizeof(struct DATA));//calloc to initialize all to 0
    for(int n=0;n&lt;4;n++){
        val=0;
        while(isdigit(*p)){
            val*=10;
            val+=(*p)-'0';
            p++;
        }
        switch(n){
            case 0:
                data-&gt;a=val;
                break;
            case 1:
                data-&gt;b=val;
                break;
            case 2:
                data-&gt;c=val;
                break;
            case 3:
                data-&gt;d=val;
                break;
        }
        val=0;
        if(*p!=',')
            break;
        p++;

    }
    *pstr=p;
    return data;
}
/*__________________________________________________________________________

    calculate the size of DATA * arra[c1][c2]
*/
void countArrBoudaries(char *s,unsigned short *c1,unsigned short *c2){
    *c1=*c2=0;
    unsigned short _c1=0;
    while(*s){
        switch(*s){
            case ';':
                _c1++;
                break;
            case '.':
                if(_c1&gt;*c1)
                    *c1=_c1;
                _c1=0;
                *c2+=1;
                break;
        }
        s++;
    }
}
/*__________________________________________________________________________
*/
int main(void){

    struct DATA **pdata,*data;
    char buff[]=""1,2,3,1445303228;4,5,6,1445303228;.7,8,9,1445303273;."";
    char *p=buff;
    unsigned short c1,c2;
    countArrBoudaries(buff,&amp;c1,&amp;c2);
    pdata=(struct DATA**)calloc((c2*c1),sizeof(pdata));

    if(pdata){
        // loading
        for(int i=0;i&lt;c1;i++)
            for(int j=0;j&lt;c2;j++)
                pdata[i+(j*c1)]=ParseString(&amp;p);

        // printing:
        for(int i=0;i&lt;c1;i++)
            for(int j=0;j&lt;c2;j++){
                data=pdata[i+(j*c1)];
                if(data){
                    printf(""data[%u][%u]={%d,%d,%d,%u};\n"",i,j,data-&gt;a,data-&gt;b,data-&gt;c,data-&gt;d);
                }else{
                    printf(""data[%u][%u]=NULL;\n"",i,j);
                }
            }

        // freeing memory:
        for(int i=0;i&lt;(c1*c2);i++)
            free(pdata[i]);
        free(pdata);

    }
    printf(""\n\nDONE\n\n"");
    return 0;
}
</code></pre>
",,40331617,254
35244387,2,33323740,2016-02-06T17:55:54.817,0,,5655988,,2016-02-06T18:10:16.500,2016-02-06T18:10:16.500,0,,"<p>Please check with the code I have provided. It is identical to the sketch provided by <a href=""https://github.com/jcw/ethercard/blob/master/examples/backSoon/backSoon.ino"" rel=""nofollow noreferrer"">Jean-Claude Wipper's Github page</a> except, I always have to supply <strong>Chip Select Pin</strong> to the ""<em>ether.begin</em>"" function or else my ENC28J60 won't respond.</p>

<pre><code>// Present a ""Will be back soon web page"", as stand-in webserver.
// 2011-01-30 &lt;jc@wippler.nl&gt; http://opensource.org/licenses/mit-license.php
// Connection Diagram: http://i.stack.imgur.com/SvG7J.jpg

#include &lt;EtherCard.h&gt;

#define STATIC 1  // set to 1 to disable DHCP (adjust myip/gwip values below)
#define CS_PIN 10

#if STATIC
// ethernet interface ip address
static byte myip[] = { 192,168,1,200 };
// gateway ip address
static byte gwip[] = { 192,168,1,1 };
#endif

// ethernet mac address - must be unique on your network
static byte mymac[] = { 0x74,0x69,0x69,0x2D,0x30,0x31 };

byte Ethernet::buffer[500]; // tcp/ip send and receive buffer

const char page[] PROGMEM =
""HTTP/1.0 503 Service Unavailable\r\n""
""Content-Type: text/html\r\n""
""Retry-After: 600\r\n""
""\r\n""
""&lt;html&gt;""
  ""&lt;head&gt;&lt;title&gt;""
    ""Service Temporarily Unavailable""
  ""&lt;/title&gt;&lt;/head&gt;""
  ""&lt;body&gt;""
    ""&lt;h3&gt;This service is currently unavailable&lt;/h3&gt;""
    ""&lt;p&gt;&lt;em&gt;""
      ""The main server is currently off-line.&lt;br /&gt;""
      ""Please try again later.""
    ""&lt;/em&gt;&lt;/p&gt;""
  ""&lt;/body&gt;""
""&lt;/html&gt;""
;

void setup(){
  Serial.begin(9600);
  Serial.println(""\n[backSoon]"");

  if (ether.begin(sizeof Ethernet::buffer, mymac, CS_PIN) == 0) 
    Serial.println( ""Failed to access Ethernet controller"");
#if STATIC
  ether.staticSetup(myip, gwip);
#else
  if (!ether.dhcpSetup())
    Serial.println(""DHCP failed"");
#endif

  ether.printIp(""IP:  "", ether.myip);
  ether.printIp(""GW:  "", ether.gwip);  
  ether.printIp(""DNS: "", ether.dnsip);  
}

void loop(){
  // wait for an incoming TCP packet, but ignore its contents
  if (ether.packetLoop(ether.packetReceive())) {
    memcpy_P(ether.tcpOffset(), page, sizeof page);
    ether.httpServerReply(sizeof page - 1);
  }
}
</code></pre>

<blockquote>
  <p>Download: <a href=""https://github.com/jcw/ethercard/archive/master.zip"" rel=""nofollow noreferrer"">Arduino EtherCard Library</a></p>
</blockquote>

<p><br/>
<strong>Essential Task</strong><br/>
Before uploading your sketch, you first need to connect your ENC28J60 module to your PC using LAN cable or you can also connect to your router. Now the main part comes. The variable ""<strong>gwip</strong>"" must match with your gateway IP address.</p>

<ul>
<li><p>If you have connected with your PC, find your PC > Ethernet's IP address which may be look like ""169.254.x.x"":<br/>
<a href=""https://i.stack.imgur.com/Aicrb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Aicrb.png"" alt=""enter image description here""></a></p></li>
<li><p>If you have connected to your router, place router's IP in ""gwip"".</p></li>
</ul>

<p>Once you get Gateway IP, write it to ""gwip"" variable and upload your sketch :)</p>
",,40364467,157
33378901,2,33336698,2015-10-27T21:34:27.447,1,,3629249,,2015-10-27T21:57:03.187,2015-10-27T21:57:03.187,0,,"<p>I suspect the output on pin 24 needs to be a 'short' period of 'high' to cause the latch to reset, followed by a return to 'low' in preparation for the next time the latch needs to be reset.</p>

<p>the lines like: <code>while( !digitalRead(23) );</code> will burn a lot of CPU cycles, so may want to put some 'delay()' or <code>yield()</code> into a body for each of those loops</p>

<pre><code>using namespace std;
FILE *f;
struct timeval curTime;

int main(int argc, char *argv[]){
    char dateiname[256] = """";
    int i=0;
    int milli;
    int seconds_in_day;

    wiringPiSetupGpio();

    time_t t = time(0);
    struct tm * now = localtime(&amp;t);

    //Create and open file
    sprintf(dateiname, ""/home/raspbian/Desktop/%02d%02d%02d_%02d_%02d.txt"",
                           now -&gt; tm_year+1900,
                           now -&gt; tm_mon+1,
                           now -&gt; tm_mday,
                           now -&gt; tm_hour,
                           now -&gt; tm_min);

    if( NULL == (f = fopen(dateiname, ""w"") )
    { // then fopen failed
        perror( ""fopen failed for output file"");
        exit(EXIT_FAILURE);
    }

    // implied else, fopen successful

    //write heading to file before loop
    fprintf(f, ""Picture, system time\n"");
    fflush( f );

    //Set 23 &amp; 24 as input/ output
    pinMode(23, INPUT);
    pullUpDnControl(23, PUD_DOWN);
    pinMode(24, OUTPUT);

    // assure latch is reset
    digitalWrite(24, LOW);
    digitalWrite(24, HIGH);
    digitalWrite(24, LOW);

    while(1)
    {
        // wait while pin23 is low
        while( !digitalRead(23));

        // 23 is high
        i=i+1;
        gettimeofday(&amp;curTime, NULL);
        milli = curTime.tv_usec / 1000; //Get time in milliseconds
        seconds_in_day = curTime.tv_sec % 86400; //Get seconds since midnight
        fprintf(f, ""&amp;d &amp;d.%d\n"", i, seconds_in_day, milli); //Write to file
        fflush( f );

        // if a latch 'set' signal is received during the following
        // three instructions, then could get locked into 
        // the while pin23 high loop

        // reset latch
        digitalWrite(24, HIGH);
        digitalWrite(24, LOW);

        // wait for pin 23 to be low
        while( digitalRead(23) );
    } // end while

    fclose(f);
    return(0);
}
</code></pre>
",,40400384,3487
33359478,2,33359198,2015-10-27T03:27:40.647,2,,1667840,,2015-10-27T03:48:16.470,2015-10-27T03:48:16.470,2,,"<p>Try</p>

<pre><code>float ratio = (frontleft + frontright) / float((backleft + backright));
while ( ratio &lt;= 0.8  ||  ratio &gt; 1.2)  {
    //do your thing here

    ratio = (frontleft + frontright) / float((backleft + backright));
}
</code></pre>

<p>Then when you're trying to print</p>

<pre><code>Serial.println(ratio, 4) //prints four decimal places
</code></pre>
",,40412719,483
33459626,2,33373226,2015-11-01T05:53:12.137,1,,5494506,,2015-11-01T06:29:41.980,2015-11-01T06:29:41.980,0,,"<p>Thanks to all. I found the solution on their own:</p>

<ol>
<li>As autoreset on serial connection is activated by default on most boards, you need to disable this feature if you want to communicate directly with your board with the last command instead of a terminal emulator (arduino IDE, screen, picocom...). If you have a Leonardo board, you are not concerned by this, because it does not autoreset. If you have a Uno board, connect a 10 µF capacitor between the RESET and GND pins. If you have another board, connect a 120 ohms resistor between the RESET and 5V pins. See <a href=""http://playground.arduino.cc/Main/DisablingAutoResetOnSerialConnection"" rel=""nofollow"">http://playground.arduino.cc/Main/DisablingAutoResetOnSerialConnection</a> for more details.</li>
<li><p>Сhanged code</p>

<pre><code>memset( &amp;terminalOptions, 0, sizeof( struct termios ) );
tcgetattr(fd, &amp;terminalOptions);        //change
cfmakeraw(&amp;terminalOptions);
cfsetspeed(&amp;terminalOptions, baudRate);
terminalOptions.c_cflag = CLOCAL;                                            
terminalOptions.c_cflag |= CS8;        
terminalOptions.c_cc[VMIN] = 0;         
terminalOptions.c_cc[VTIME] = 10;      
terminalOptions.c_cflag = CLOCAL;                                             
terminalOptions.c_cflag &amp;= ~HUPCL;       //change (disable hang-up-on-close to avoid reset)

ret = tcsetattr(fd, TCSANOW, &amp;terminalOptions);  //change
if (ret == -1)
{
        this-&gt;setFail();
        this-&gt;setErrorStr( ""Failed to configure device: "" + (std::string)devicePath + "". "" + (std::string)strerror(errno) );

        return -1;
}

return fd;
</code></pre></li>
</ol>
",,40415081,299
33395761,2,33392427,2015-10-28T15:55:39.040,1,,1101001,,2015-10-29T14:45:56.747,2015-10-29T14:45:56.747,0,,"<p>There are quite a few issues with this code.  </p>

<ul>
<li>One of the first things that I notice is that you close out your <code>loop()</code> function with <code>}</code>, then you proceed to write more code that doesn't belong to any function at all.  </li>
<li>Also, as @Raul points out, you define an array <code>sevenseg[][]</code>, but you do not end the statement with a semicolon.</li>
<li>Your last <code>for()</code> loop is missing its closing brace, <code>}</code>.</li>
<li>Your last <code>for()</code> loop has a semicolon before the opening brace.  It shouldn't be there.</li>
<li>You use the variable <code>number</code> in your <code>loop()</code> function, but you define what <code>number</code> is after you use it.  You have to define a variable before you use it.</li>
<li>You call <code>SetTimer()</code> and <code>StartTimer()</code> in your <code>setup()</code> function, but those functions are not defined.  That's because either 1, you have not included the library where those functions are defined or 2, you did not define those functions yourself.  If your issue is 1, then I assume you intended to use <code>#include &lt;SimpleTimer.h&gt;</code>.  Note that you also have to install that library.  The instructions on how to download it and add it to your Arduino libraries are <a href=""http://playground.arduino.cc/Code/SimpleTimer"" rel=""nofollow"">here</a>.  Finally, you have to create a timer object like this: <code>SimpleTimer timer;</code> and then you can call the function like this, <code>timer.SetTimer(your-parameters-here);</code>.</li>
</ul>

<p>There are probably other things that I have missed, but that should give you a starting point.  It looks like you have created a lot of code without testing to see if any of it worked.  I would recommend taking this a step at a time... code one logical block and see if it works <strong>before</strong> you move on to coding your next idea.  It may seem like it takes more time but, in the end, it is usually a much faster way to program.</p>

<p>Another suggestion that I would make is to define variables within the function in which you use them.  Making all of your variables ""global"" like you have done is not a good way to write code.  For example:</p>

<pre><code>void loop()
{
    static int number = 0;

    number++;
    delay(1000);

    if (number &gt; 9)
    {
        number = 0;
    }
}
</code></pre>

<p>Note the use of the keyword <code>static</code>.  This will ensure that the value stored in <code>number</code> will not go away when the function ends.  In other words, the value will still be there the next time the <code>loop()</code> function is called.</p>

<p>Finally, if I had to guess at what you were trying to accomplish, I would think your code should look a little more like this.  It appears as though you were trying out different things so I left a number of code snippets in there from your original code that don't actually do anything:</p>

<pre><code>void setup() {
    Serial.begin(115200);

    for (int i = 0; i &lt; 9; ++i) 
    {
        pinMode (i, OUTPUT);
    }
    pinMode(9, INPUT);
}

void loop() {
    static int counter = 0;
    static int last_input_value = LOW;
    static bool go_by_switch = true;

    if(go_by_switch) 
    {
        int switch_input_value = digitalRead(9);
        if(last_input_value == LOW &amp;&amp; switch_input_value == HIGH) 
        {
            counter = (counter + 1) % 10;
        }

        last_input_value = switch_input_value;
    } 
    else 
    {
        delay(500);
        counter = (counter + 1) % 10;
    }

    writeNumber(counter);
}

void writeNumber (int count)
{
    #define PIN_COUNT           7
    #define NUM_OF_SEGMENTS     7
    #define NUM_OF_NUMBERS      10

                         //                0                   6
                         // pins           A   B  C  D  E   F  G
    static const int ledpins[PIN_COUNT] = {12, 10, 7, 4, 2, 13, 8};
    static const int sevenseg[NUM_OF_NUMBERS][NUM_OF_SEGMENTS] =
    {
      // A   B   C   D   E   F   G
        {1,  1,  1,  1,  1,  1,  0},  //0
        {0,  1,  1,  0,  0,  0,  0},  //1
        {1,  1,  0,  1,  1,  0,  1},  //2
        {1,  1,  1,  1,  0,  0,  1},  //3
        {0,  1,  1,  0,  0,  1,  1},  //4
        {1,  0,  1,  1,  0,  1,  1},  //5
        {1,  0,  1,  1,  1,  1,  1},  //6
        {1,  1,  1,  0,  0,  0,  0},  //7
        {1,  1,  1,  1,  1,  1,  1},  //8
        {1,  1,  1,  1,  0,  1,  1},  //9
    };
    static int number = 0;
    int i;

    number++;
    delay(1000);

    if(number &gt;= NUM_OF_NUMBERS)
    {
        number = 0;
    }

    /* Clear all segments of the 7-segment display. */
    for (i = 0; i &lt; PIN_COUNT; i++) 
    { 
        pinMode (ledpins[i], OUTPUT);
        digitalWrite(ledpins[i], LOW);
    }

    /* Set the 7-segment display with the current number. */
    for (i = 0; i &lt; PIN_COUNT; i++) 
    {
        if (sevenseg[number][i]) // sevenseg = 7-segment display
            digitalWrite (ledpins[i], HIGH); // If it is 1, then there will be light.
        else 
            digitalWrite (ledpins[i], LOW); // If it is 0, then there will not be light.
    }
}
</code></pre>
",,40416173,1005
33451369,2,33450659,2015-10-31T12:06:54.543,0,,5489645,,2015-10-31T16:25:31.303,2015-10-31T16:25:31.303,0,,"<p>You can create a tm struct (from &lt; time.h>/&lt; ctime>) and passing those parameters to it, then you can simple call the mktime() funtion or the timegm() funtion, which depends on you want to take the input as local time or GMT time. </p>

<p>One thing you should carefully remember is that the actual year stored in tm struct is (year-1990), and month should be (month-1). Don't forget to set the tm's tm_isdst flag. You can set is as -1 which can automatically detect whether daylight saving time is applied.</p>

<p>For example, you want to convert GMT 11/02/1990 00:16:50. </p>

<pre><code>tm* t;
t-&gt;tm_sec = 50;
t-&gt;tm_min = 16;
t-&gt;tm_hour = 0;
t-&gt;tm_mday = 11;
t-&gt;tm_mon = 1; // 2-1, not 2!
t-&gt;tm_year = 90; // 1990-1900, not 1990!
t-&gt;tm_isdst = -1;
</code></pre>

<p>Then you can call timegm(t) which will give you the result 634695410.</p>
",,40435159,465
33451645,2,33450659,2015-10-31T12:36:48.800,1,,1687119,,2015-10-31T12:36:48.800,,2,,"<p>As mentioned in the comments, <code>strptime</code> can do the parsing for you to create a <code>struct tm</code>.  Then you can call <code>mktime</code> to get a <code>time_t</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define _XOPEN_SOURCE
#include &lt;time.h&gt;


int main(void)
{
    struct tm mytm;
    time_t t;
    strptime(""31/10/2015 08:33:00"",""%d/%m/%Y %H:%M:%S"",&amp;mytm);
    t = mktime(&amp;mytm);
    printf(""t=%ld\n"",t);
    return 0;
}
</code></pre>

<p>Result:</p>

<pre><code>t=1446294780
</code></pre>
",,40450539,106
33453961,2,33450659,2015-10-31T16:39:57.253,0,,5470921,,2015-10-31T16:39:57.253,,0,,"<p>on arduino using the time library <a href=""http://github.com/PaulStoffregen/Time"" rel=""nofollow"">github.com/PaulStoffregen/Time</a></p>

<pre><code>#include &lt;Time.h&gt;

struct unix {
  long get(int y, int m = 0, int d = 0, int h = 0, int i = 0, int s = 0) {
    setTime(h, i, s, d, m, y);
    adjustTime(-10800); // +3
    return now();
  }
} unix;

void setup() {
  Serial.begin(19200);
  Serial.setTimeout(0);

  Serial.println("".."");
  //Serial.println(unix.get(2015));
  //Serial.println(unix.get(2015, 10));
  //Serial.println(unix.get(2015, 10, 31));
  //Serial.println(unix.get(2015, 10, 31, 18));
  //Serial.println(unix.get(2015, 10, 31, 18, 41));
  //Serial.println(unix.get(2015, 10, 31, 18, 41, 0));

  Serial.println(""Enter the date (dd/mm/yyyy hh:ii:ss am/pm). Example: \""31/10/2015 7:27 pm\""."");
}

void loop() {
  while (Serial.available() &gt; 0) {
    int dd = Serial.readStringUntil('/').toInt();
    int mm = Serial.readStringUntil('/').toInt();
    int yyyy = Serial.readStringUntil(' ').toInt();
    int hh = Serial.readStringUntil(':').toInt();
    int ii = Serial.readStringUntil(':').toInt();
    int ss = Serial.readStringUntil(' ').toInt();
    String pm = Serial.readStringUntil('\n');

    if (pm == 0) pm = ""am"";
    Serial.print(dd); Serial.print(""/"");
    Serial.print(mm); Serial.print(""/"");
    Serial.print(yyyy); Serial.print("" "");
    Serial.print(hh); Serial.print("":"");
    Serial.print(ii); Serial.print("":"");
    Serial.print(ss); Serial.print("" "");
    Serial.print(pm); Serial.print("" = "");

    if (pm == ""pm"") hh += 12;
    Serial.println(unix.get(yyyy, mm, dd, hh, ii, ss));
    Serial.println();

    Serial.println(""Enter the date (dd/mm/yyyy hh:ii:ss am/pm)."");
  }

  delay(50);
}
</code></pre>
",,40450692,304
56273152,2,33474070,2019-05-23T10:23:25.277,0,,608639,,2019-05-23T10:23:25.277,,0,,"<p>Regarding:</p>

<pre><code>./a.out 
./a.out: error while loading shared libraries: ../../lib-arm/libCustomLibrary.so: unexpected reloc type 0x03
</code></pre>

<p>I think you need to show the relevant source code for <code>libCustomLibrary.so</code>. You can see which symbol is causing the problem with:</p>

<pre><code>LD_DEBUG=all ./a.out
</code></pre>

<p>After the verbose output, the last symbol mentioned will be the problem. For example, testing <a href=""https://wiki.openssl.org/index.php/Cryptogams_SHA"" rel=""nofollow noreferrer"">Cryptogams SHA</a>, which is hand written asm, in a shared object results in:</p>

<pre><code>10419:     relocation processing: /home/test/libcryptopp-8.3.0.so.8 (lazy)
10419:     symbol=CRYPTOGAMS_armcaps;  lookup in file=/home/test/libcryptopp.so.8 [0]
10419:     binding file /home/test/libcryptopp.so.8 [0]: normal symbol `CRYPTOGAMS_armcaps'
/home/test/: error while loading shared libraries: /home/test/libcryptopp.so.8: unexpected reloc type 0x03
</code></pre>

<p>So I know the problem is with the <code>CRYPTOGAMS_armcaps</code> symbol. You can confirm with <code>objdump -r</code>. <code>R_ARM_REL32</code> is symbol type <code>0x03</code>.</p>

<pre><code>$ objdump -r sha1-armv4.o

sha1-armv4.o:     file format elf32-littlearm

RELOCATION RECORDS FOR [.text]:
OFFSET   TYPE              VALUE
000004d0 R_ARM_REL32       CRYPTOGAMS_armcaps
</code></pre>

<p>Then you can go back to the source file and fix the problem with the symbol.</p>

<p>Also, from Crypto++ Issue 846, <a href=""https://github.com/weidai11/cryptopp/issues/846"" rel=""nofollow noreferrer"">ARM and ""unexpected reloc type 0x03"" loading shared object</a>, I know it is not as simple as using <code>-fPIC</code>. Everything was built with <code>-fPIC</code> and the problem still surfaced.</p>
",,40454320,168
33559350,2,33559313,2015-11-06T04:09:42.710,2,,14860,,2015-11-06T05:03:12.880,2015-11-06T05:03:12.880,8,,"<p>It's not printing the altitude from within <code>loop()</code> because <code>loop()</code> is never actually being called.</p>

<p>Remember this about Arduino. The <code>setup()</code> function is called once at boot time and, once it returns, the <code>loop()</code> function is called over and over again.</p>

<p>With the way you have it, your <code>setup()</code> function calls <code>simulateAltitude()</code> which goes into an infinite loop, so it <em>never</em> returns. It does not run <code>simulateAltitude()</code> and <code>loop()</code> concurrently.</p>

<p>You might be better off looking at something like:</p>

<pre><code>void loop() {
    Serial.println(altitude);
    increaseAltitude();
}

int increaseAltitude() {
    altitude += 1;
    delay(1);
}
</code></pre>
",,40465477,2123
33610001,2,33602020,2015-11-09T13:18:27.597,2,,4062354,,2015-11-09T13:18:27.597,,0,,"<p>A simple implementation using some flags:</p>

<pre><code>int twoFlag, sevenFlag;

void loop(){
    if (digitalRead(2) == HIGH) {
        if (!twoFlag) {
            switchPos = 2;
            MsTimer2::start();
            delay(10); // to avoid errors from chattering or bouncing
            twoFlag = 1;
        }
    } else {
        twoFlag = 0;
    }
    if (digitalRead(7) == HIGH) {
        if (!sevenFlag) {
            switchPos = 7;
            MsTimer2::stop();
            delay(10); // to avoid errors from chattering or bouncing
            sevenFlag = 1;
        }
    } else {
        sevenFlag = 0;
    }
}
</code></pre>
",,40499594,383
33675068,2,33626480,2015-11-12T15:26:48.487,3,,1967890,,2015-11-12T15:26:48.487,,0,,"<p>You can use a device-tree overlay to activate the pull-ups and port direction at boot up. </p>

<p>You will have to modify and compile the dts (source), place it in /boot/overlays, and enable it in config.txt.  The instructions are in the source header. (Thanks to PhillE for his help!)</p>

<pre><code>/*
* Overlay for enabling gpio's to pull at boot time
* this overlay uses pincctrl to initialize the pull-up register for the the listed gpios
* the compatible=""gpio-leds"" forces a module probe so the pinctrl does something
*
* To use this dts:
* copy this to a file named gpio_pull-overlay.dts
* modify the brcm,pins, brcm,function, and brcm,pull values
* apt-get install device-tree-compiler
* dtc -@ -I dts -O dtb -o gpio_pull-overlay.dtb gpio_pull-overlay.dts
* sudo cp gpio_pull-overlay.dtb /boot/overlays
* add this line to the end config.txt: dtoverlay=gpio_pull
* reboot
*/

/dts-v1/;
/plugin/;
/ {
  compatible = ""brcm,bcm2835"", ""brcm,bcm2708"";
  fragment@0 {
    target = &lt;&amp;gpio&gt;;
    __overlay__ {
       gpio_pins: gpio_pins {
          brcm,pins = &lt;30 31 32 33&gt;; /* list of gpio(n) pins to pull */
          brcm,function = &lt;0 1 0 1&gt;; /* boot up direction:in=0 out=1 */
          brcm,pull = &lt;2 0 1 0&gt;; /* pull direction: none=0, 1 = down, 2 = up */
       };
    };
  };
  fragment@1 {
    target-path = ""/soc"";
    __overlay__ {
       gpiopull:gpiopull {
          compatible = ""gpio-leds"";
          pinctrl-names = ""default"";
          pinctrl-0 = &lt;&amp;gpio_pins&gt;;
          status = ""okay"";
       };
    };
  };
  __overrides__ {
     gpio_pull = &lt;&amp;gpiopull&gt;,""status"";
  };
};
</code></pre>
",,40533507,574
33653838,2,33627745,2015-11-11T15:24:58.077,1,,5445601,,2015-11-11T15:24:58.077,,0,,"<p>Inside EnergyCounter class, define countPulse as static method, as below:</p>

<pre><code>class EnergyCounter{
   //...
   static void countPulse();
   //...
};
</code></pre>

<p>Reason: ISR should be a function that returns void and has no parameters. Class member functions have a (hidden) parameter, that is a reference to the class instance.</p>

<p>Alternative solution is to move countPulse outside of EnergyCounter and make it just a regular method in the global namespace (not part of any class).</p>
",,40546270,144
33692017,2,33651753,2015-11-13T11:44:50.227,2,,702196,,2015-11-13T17:41:14.477,2015-11-13T17:41:14.477,0,,"<p>I found the solution, although not very elegant.
Instead of sending the whole JSON string, BLE will send a key/value pair in a single packet.
In C first:</p>

<pre><code>char passMsg(String akey, char* origMsg){
  // akey = object key must be 4 characters long
  // origMsg + akey must be shorter than 20 characters
  char* newmsg = origMsg;
  size_t prevlen = strlen(newmsg);  
  memset(newmsg + prevlen, ' ', 15 - prevlen);
  *(newmsg + 15) = '\0'; 
  String bleMsg = akey + "":""+newmsg;
  ble.print(""AT+BLEUARTTX="");            
  ble.println(bleMsg);  
}
</code></pre>

<p>This way I pass a string like this: <code>temp:20.45</code></p>

<p>Then in Android/Java:</p>

<pre><code>String[] rawString = data.replace("" "", """").split("":"");
if(rawString.length&gt;1){
  String apiCallKey = rawString[0];
  String apiCallVal = rawString[1];
  callAPI(apiCallKey,apiCallVal);
}
</code></pre>

<p>Where <code>data</code> is raw data from Bluetooth.</p>

<p>Phew...</p>
",,40548941,290
33667811,2,33667405,2015-11-12T09:10:09.797,0,,4776608,,2015-11-12T09:31:57.610,2015-11-12T09:31:57.610,0,,"<p>Try this:</p>

<pre><code>        using (TcpClient client = new TcpClient(""127.0.0.1"",22001))
        {
            using (StreamWriter writer = new StreamWriter(client.GetStream()))
            {
                writer.WriteLine(""string to write"");
            }
        }
</code></pre>

<p>Make sure you a have server running that TcpClient can connect to.
And clean up shop close the client and the writer. Memory issues and open connections. That why the using keyword is used.</p>

<p>This could be the server implementation:</p>

<pre><code>        TcpListener server = new TcpListener(IPAddress.Parse(""127.0.0.1""),22001);
        server.Start();
        while (true)
        {
            TcpClient client = server.AcceptTcpClient();
            using (StreamReader reader = new StreamReader(client.GetStream()))
            {
                while (reader.Read()&gt;0)
                {
                    Console.WriteLine(reader.ReadLine());
                }
            }
        }
</code></pre>
",,40577161,47
33676305,2,33675737,2015-11-12T16:23:07.113,3,,152948,,2015-11-12T18:57:33.083,2015-11-12T18:57:33.083,0,,"<p>Use a <code>char[16]</code> array, and write the critical shifting code in assembly, rather than C, because C doesn't have a good way to give you access to the carry-out from a shift.</p>

<p>You should be able to do something like</p>

<pre><code>ldi r29, hi8(array) ; Load Y register
ldi r28, lo8(array) ; (16 bits)
ldi r22, 16         ; Loop counter
ldd r23, Y+15       ; Get the last byte
lsl r23             ; And put the last bit into the carry flag
loop:               ;   so it will be shifted into the first bit
ld r23, Y           ; Load from array into r23
rol                 ; Rotate left through carry
st Y+, r23          ; Store it back and increment Y
dec r22             ; Decrement loop counter
brne loop           ; Loop if not done
</code></pre>

<p>to do the rotation, but this is untested and I'm not an AVR assembly whiz. <code>dec</code> is special and doesn't interfere with the carry flag, so it's preserved safely through the loop.</p>
",,40581092,1042
33693995,2,33692271,2015-11-13T13:36:43.460,0,,3368201,,2015-11-13T14:54:58.013,2015-11-13T14:54:58.013,5,,"<p>Ok, if I understood correctly you want a function that</p>

<p>1) you call once and it resets the counter
2) you call successively and tells you how much time passed
3) you can reset sometimes</p>

<p>If so, you have to ask yourself ""how can I reset the timer?"". IMHO the best solution is using a flag passed to the function.</p>

<p>And... avoid using the <code>millis</code> function twice ;)</p>

<p>And, BTW, I think you want to perform an action just once when you receive the serial data, so move the switch inside the test...</p>

<p>Here is a sample:</p>

<pre><code>void time(bool reset){
    unsigned long currMillis = millis();
    if (reset){
        sec_aux = 0;
        min_aux = 0;
        UtlTime = currMillis;
    }   
    while ((currMillis - UtlTime) &gt; 1000)
    {
        UtlTime += 1000;
        sec_aux++;
    }
    while(sec_aux &gt; 59){
        sec_aux -= 60;
        min_aux++;
    }
    // Why do you duplicate the data?
    sec = sec_aux;
    min = min_aux;
    Serial.println(""TIME"");
    Serial.print(min); Serial.print("":""); Serial.println(sec);
}

void loop() {
    if (Serial.available()) {
        inChar = Serial.read();
        switch(inChar){
        case '1':
            // Show time measure
            time(false);
            clock();
            break;
        case '2':
            clock();
            // Start time measure
            time(true);
            break;
        default:
            clock();
        }
    }
}
</code></pre>

<p>EDIT:</p>

<p>Ok, then you want a ""stoppable"" stopwatch. What I suggest you is to detach the update from the serial interface, so you always have updated values. Or at least that's the way my head works :P</p>

<p>I modified some things. You should</p>

<ol>
<li>init <code>lastMillis</code> to <code>millis()</code> in the <code>setup</code></li>
<li>init <code>timeIsRunning</code> to the proper value</li>
<li>call <code>resetTime()</code> inside the <code>setup</code></li>
</ol>

<p>Here is the code:</p>

<pre><code>void resetTime()
{
    msec = 0;
    sec = 0;
    min = 0;
}

void updateTime()
{
    unsigned long currStep = millis() - lastMillis;
    lastMillis += currStep;

    if (timeIsRunning)
    {
        msec += currStep;
        while (msec &gt; 1000)
        {
            msec -= 1000;
            sec++;
        }
        while(sec &gt; 59){
            sec -= 60;
            min++;
        }
    }
}

void printTime()
{
    Serial.println(""TIME"");
    Serial.print(min); Serial.print("":""); Serial.println(sec);
}

void loop()
{
    updateTime();

    if (Serial.available())
    {
        inChar = Serial.read();
        switch(inChar)
        {
        case '1':
            // Show time measure
            timeIsRunning = false;
            printTime();
            clock();
            break;
        case '2':
            clock();
            // Start time measure
            timeIsRunning = true;
            break;
        default:
            clock();
        }
    }
}
</code></pre>
",,40612562,1231
33705377,2,33704918,2015-11-14T05:18:53.667,0,,149341,,2015-11-14T05:18:53.667,,0,,"<p>Your code is clearly missing a number of curly braces in locations where they're required, e.g.</p>

<pre><code>  if (attValue == 0)
      Serial.println(noAttention);
      //Need to solder wires to left n right to have that happen if no connection
      digitalWrite(RIGHT, moveCar);
      digitalWrite(LEFT, moveIt);
</code></pre>

<p>(There needs to be a <code>{</code> at the end of the first line, and a <code>}</code> after the last line.)</p>

<p>By some stroke of bizarre luck, you happen to have the same number of open braces as close braces, so your code <em>might</em> compile, but it won't work as intended.</p>
",,40622427,55
33712831,2,33712802,2015-11-14T20:12:18.543,2,,511529,,2015-11-14T20:12:18.543,,0,,"<p>You can use the 'and' operator, <code>&amp;&amp;</code>, to combine multiple conditions:</p>

<pre><code>if (digitalRead(wire_BROWN) == LOW &amp;&amp;
    digitalRead(wire_ORANGE) == LOW &amp;&amp;
    digitalRead(wire_RED) == LOW &amp;&amp;
    digitalRead(wire_GREEN) == LOW &amp;&amp;
    digitalRead(wire_BLUE) == LOW &amp;&amp;
    digitalRead(wire_PURPLE) == LOW &amp;&amp;
    digitalRead(wire_GREY) == LOW &amp;&amp;
    digitalRead(wire_WHITE) == LOW &amp;&amp;
    digitalRead(wire_BLACK) == LOW){

  lcd.print(pass);
  delay(3000);
  lcd.clear();
  lcd.print(""Status: ARMED"");
  testPassed = true;
} 
else {
  lcd.print(fail);
}
</code></pre>
",,40636959,175
33712835,2,33712802,2015-11-14T20:12:45.173,2,,3963067,,2015-11-14T20:12:45.173,,0,,"<p>You could try</p>

<pre><code>if ( (digitalRead(wire_BROWN) == LOW) &amp;&amp; (digitalRead(wire_ORANGE) == LOW) &amp;&amp; ... /* other checks */)
{
   lcd.print(pass);
   delay(3000);
   lcd.clear();
   lcd.print(""Status: ARMED"");
   testPassed = true;
}else
{
   lcd.print(fail);
}
</code></pre>
",,40663189,301
33712860,2,33712802,2015-11-14T20:14:44.440,0,,3215739,,2015-11-14T20:14:44.440,,0,,"<p>You should probably use &amp;&amp; to shorten your code. Also if your wire vars are on the same PORT, you might be able to AND (&amp;) them.</p>

<p>Anyways:</p>

<pre><code>if(digitalRead(wire_BROWN) == LOW &amp;&amp; digitalRead(wire_ORANGE) == LOW &amp;&amp; ... ) {
   lcd.print(pass);
   delay(3000);
   lcd.clear();
   lcd.print(""Status: ARMED"");
   testPassed = true;
} else {
   lcd.print(fail);
}
</code></pre>
",,40667703,4408
33712879,2,33712802,2015-11-14T20:16:54.840,0,,1312406,,2015-11-14T20:16:54.840,,0,,"<p>Simply use the <code>and</code> operator <code>&amp;&amp;</code>, since it <em>short-circuits</em> the <code>if</code> <em>statement</em> becomes <code>false</code> as soon as any call to <code>digitalRead</code> fails to return <code>LOW</code>:</p>

<pre><code>if ((digitalRead(wire_BROWN) == LOW) &amp;&amp;
    (digitalRead(wire_ORANGE) == LOW) &amp;&amp;
    (digitalRead(wire_RED) == LOW) &amp;&amp;
    (digitalRead(wire_GREEN) == LOW) &amp;&amp;
    (digitalRead(wire_BLUE) == LOW) &amp;&amp;
    (digitalRead(wire_PURPLE) == LOW) &amp;&amp;
    (digitalRead(wire_GREY) == LOW) &amp;&amp;
    (digitalRead(wire_WHITE) == LOW) &amp;&amp;
    (digitalRead(wire_BLACK) == LOW)) {
                lcd.print(pass);
                delay(3000);
                lcd.clear();
                lcd.print(""Status: ARMED"");
                testPassed = true;
    } else {
        lcd.print(fail);
    }
</code></pre>
",,40674107,46
33712895,2,33712802,2015-11-14T20:18:21.857,6,,2721883,,2015-11-14T20:18:21.857,,0,,"<p>You can put it in a function to make it more readable:</p>

<pre><code>bool all_wires_low()
{
    return
        digitalRead(wire_BROWN) == LOW &amp;&amp;
        digitalRead(wire_ORANGE) == LOW &amp;&amp;
        digitalRead(wire_RED) == LOW &amp;&amp;
        digitalRead(wire_GREEN) == LOW &amp;&amp;
        digitalRead(wire_BLUE) == LOW &amp;&amp;
        digitalRead(wire_PURPLE) == LOW &amp;&amp;
        digitalRead(wire_GREY) == LOW &amp;&amp;
        digitalRead(wire_WHITE) == LOW &amp;&amp;
        digitalRead(wire_BLACK) == LOW;
}

// elsewhere:
if( all_wires_low() )
{
    lcd.print(pass);
    delay(3000);
    lcd.clear();
    lcd.print(""Status: ARMED"");
    testPassed = true;
}
else
{
    lcd.print(fail);
}
</code></pre>
",,40676459,184
33712944,2,33712802,2015-11-14T20:23:38.370,1,,5037458,,2015-11-14T20:39:14.510,2015-11-14T20:39:14.510,1,,"<p>Let's get a single signal that answer's question:
is all signals low or at-least one of them high.
This answer is provided by simple '&amp;' toggle is guaranteed to combine all signal's to produce one signal and provide a definite answer for the question - are all signals low?</p>

<p>The result of that signal is compared with LOW.</p>

<pre><code>  if((digitalRead(wire_BROWN)  &amp;
    digitalRead(wire_ORANGE) &amp; 
    digitalRead(wire_RED)    &amp;
    digitalRead(wire_GREEN)  &amp;
    digitalRead(wire_BLUE)   &amp;
    digitalRead(wire_PURPLE) &amp;
    digitalRead(wire_GREY)   &amp;
    digitalRead(wire_WHITE)  &amp;
    digitalRead(wire_BLACK) ) &amp; LOW)
    {
    ....
    ...
    }
</code></pre>
",,40686422,2472
33713079,2,33712802,2015-11-14T20:38:23.213,3,,2016408,,2015-11-14T21:16:36.717,2015-11-14T21:16:36.717,0,,"<p>When having multiple variables, it's always simpler to enumerate them in a way that allows you to loop through them instead of having to write repetitive code. I personally like to organize them in a separate file, it's much neater that way and easier to add new values -</p>

<pre><code>typedef enum {
#define DEF_WIRE(x) WIRE_ ## x,
#include ""wires.def""
} wire_types;

int main() {

    bool testPassed = true;
    for (int wire = 0; wire &lt; WIRE_MAX; ++wire) {
        testPassed &amp;= (digitalRead(wire) == LOW);
    }
    if (testPassed) {
        lcd.print(pass);
        delay(3000);
        lcd.clear();
        lcd.print(""Status: ARMED"");
    } else {
        lcd.print(fail);
    }
}
</code></pre>

<p>where wires.def has:</p>

<pre><code>DEF_WIRE(BROWN)
DEF_WIRE(ORANGE)
DEF_WIRE(RED)
DEF_WIRE(GREEN)
DEF_WIRE(BLUE)
DEF_WIRE(PURPLE)
DEF_WIRE(GREY)
DEF_WIRE(WHITE)
DEF_WIRE(BLACK)
DEF_WIRE(MAX)
#undef DEF_WIRE
</code></pre>

<p>A side benefit is that it allows you to do something cool like this:</p>

<pre><code>const char* wire_names[] = {
#define DEF_WIRE(x) #x,
#include ""wires.def""
};
</code></pre>

<p>and then </p>

<pre><code>printf(""wire %s is LOW\n"", wire_names[wire]);
</code></pre>
",,40700514,2775
33713489,2,33712802,2015-11-14T21:19:00.160,0,,225074,,2015-11-14T21:19:00.160,,1,,"<p>I suggest Boolean variables and logic:</p>

<pre><code>bool all_wires_connected = true;
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_BROWN) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_ORANGE) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_RED) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_GREEN) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_BLUE) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_PURPLE) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_GREY) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_WHITE) == LOW);
all_wires_connected = all_wires_connected &amp;&amp; (digitalRead(wire_BLACK) == LOW);
if (all_wires_connected)
{
    lcd.print(pass);
    delay(3000);
    lcd.clear();
    lcd.print(""Status: ARMED"");
    testPassed = true;
}
else
{
    lcd.print(fail);
}
</code></pre>

<p>This may encourage the compiler to use conditionally executed instructions.  </p>
",,40701003,118
33718235,2,33712802,2015-11-15T09:36:04.130,0,,3368201,,2015-11-15T09:36:04.130,,0,,"<p>IMHO the best solution would be to put them in an array: </p>

<pre><code>int allWires[] = { wire_BROWN, wire_ORANGE, wire_RED, wire_GREEN, wire_BLUE, wire_PURPLE, wire_GREY, wire_WHITE, wire_BLACK };
</code></pre>

<p>and then iterate through them:</p>

<pre><code>testPassed = true;
for (i = 0; i &lt; sizeof(allWires)/sizeof(int); i++)
{
    if (digitalRead(allWires[i]) == LOW)
        testPassed = false;
}

if (testPassed)
{
    lcd.print(pass);
    delay(3000);
    lcd.clear();
    lcd.print(""Status: ARMED"");
}
else
    lcd.print(fail);
</code></pre>
",,40710938,1777
33738579,2,33712802,2015-11-16T15:11:40.230,0,,1331076,,2015-11-16T15:11:40.230,,0,,"<p>Create a bit mask, and boolean AND it with your port:
<a href=""https://www.arduino.cc/en/Tutorial/BitMask"" rel=""nofollow"">https://www.arduino.cc/en/Tutorial/BitMask</a></p>

<p>btw. reading ports is:
<a href=""https://www.arduino.cc/en/Reference/PortManipulation"" rel=""nofollow"">https://www.arduino.cc/en/Reference/PortManipulation</a></p>

<hr>

<p>the mask will look like follows:
00011111
where the 0 is for all the bits connected to something else than the colored wires and 1 is what you want to test for...</p>

<p>you will be using two ports so:</p>

<pre><code>byte MASK2 = some bit pattern depending on wire arrangements;
byte MASK1 = some bit pattern depending on wire arrangements;
int PORTA = 
if(( MASK1 &amp; PIND + MASK2 &amp; PINB ) == 0)
{
    //code
}
</code></pre>

<p>this answer must be equal to 0.</p>
",,40712305,4631
33853089,2,33749216,2015-11-22T08:50:58.983,1,,4523580,,2015-11-22T10:08:25.267,2015-11-22T10:08:25.267,0,,"<p>As @berak, stated in the comment, I installed OpenCV Package for Cygwin using Cygwin Ports. (Without any src or requiring any build, simple install only).<br>
Had to tweak my <code>CMakeLists.txt</code> a little but it compiled well.  </p>

<pre><code>##### CMakeLists.txt ########
cmake_minimum_required(VERSION 2.8.4) 
PROJECT (test)
find_package(OpenCV REQUIRED )

set( NAME_SRC
    src/main.cpp    
    src/mytest.cpp    
)

set( NAME_HEADERS       
    include/mytest.hpp
)

set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
add_executable( test ${NAME_SRC} ${NAME_HEADERS} )
include_directories(/usr/include /usr/include/opencv2 /usr/include/opencv ${CMAKE_CURRENT_SOURCE_DIR}/include)
link_directories(/usr/lib ${CMAKE_BINARY_DIR}/bin)
target_link_libraries(test opencv_core opencv_highgui opencv_imgproc)
</code></pre>

<p>(Now, I have totally different trouble of runtime error : <code>Gtk-WARNING **: cannot open display</code>, but its another story of not having XServer on Cygwin)</p>
",,40749737,215
33758063,2,33758004,2015-11-17T13:23:42.480,2,,3963067,,2015-11-17T13:34:48.120,2015-11-17T13:34:48.120,4,,"<p>Something like this?</p>

<pre><code>    _missions[_missions_count] = mission;
    _missions_count += 1;

    return _missions[_missions_count-1];
}
</code></pre>

<p>Also you need to change function signature to</p>

<pre><code>  Mission&amp; Machine::create_mission(int num)
</code></pre>
",,40750984,40
33758263,2,33758004,2015-11-17T13:32:27.623,1,,1870760,,2015-11-17T13:32:27.623,,4,,"<p>You can either return by reference:</p>

<p>Declaration:</p>

<pre><code>Mission &amp; create_mission(int num);
</code></pre>

<p>Definition:</p>

<pre><code>  Mission&amp; Machine::create_mission(int num) {
        Mission mission = Mission();
        mission.setNumber(num);
        _missions[_missions_count] = mission;
        _missions_count += 1;

        return _missions[_missions_count - 1];
    }
</code></pre>

<p>Or by pointer:</p>

<p>Declaration:</p>

<pre><code>Mission* create_mission(int num);
</code></pre>

<p>Definition:</p>

<pre><code>Mission* Machine::create_mission(int num) {
            Mission mission = Mission();
            mission.setNumber(num);
            _missions[_missions_count] = mission;
            _missions_count += 1;

            return &amp;_missions[_missions_count - 1];
        }
</code></pre>

<p>You'd normally return by reference if you expect the object to be there, which is the case here.</p>

<p>Currently, you're returning the reference of a temporary (<code>mission</code>) which is not allowed. 
<code>_missions[_missions_count] = mission;</code>
Will copy your mission object to the map which will outlive the <code>create_mission</code> scope which is what you want. </p>
",,40906704,3917
33758362,2,33758004,2015-11-17T13:38:01.067,0,,3494744,,2015-11-17T13:38:01.067,,0,,"<p>Your code creates a new Mission object and assigns it to one in your list. Then this <em>temporary</em> object will be returned. Furthermore the <code>create_mission()</code> method is declared to return a <em>copy</em> of a <code>Mission</code>object.</p>

<p>You can circumvent this by working with references like this:</p>

<pre><code> Mission &amp;Machine::create_mission(int num) {
    // create a reference to one of the Missions in the array
    Mission &amp;mission = _missions[_missions_count];
    // work on that Mission
    mission.setNumber(num);
    _missions_count += 1
    // return the reference;
    return mission;
}
</code></pre>
",,40935080,1394
33838449,2,33837420,2015-11-21T00:53:17.253,0,,85371,,2015-11-21T01:04:41.897,2015-11-21T01:04:41.897,0,,"<p>Or if you can use boost, consider Boost Spirit:</p>

<p><strong><kbd><a href=""http://coliru.stacked-crooked.com/a/f867e2136d05bd17"" rel=""nofollow"">Live On Coliru</a></kbd></strong></p>

<pre><code>#include &lt;boost/spirit/home/x3.hpp&gt;
#include &lt;boost/fusion/adapted/std_tuple.hpp&gt;
#include &lt;boost/date_time/gregorian/greg_date.hpp&gt;
#include &lt;boost/date_time/gregorian/gregorian_io.hpp&gt;
#include &lt;boost/multiprecision/cpp_dec_float.hpp&gt;

int main() {
    using boost::gregorian::date;
    using Money = boost::multiprecision::number&lt;boost::multiprecision::cpp_dec_float&lt;20&gt;, boost::multiprecision::et_off&gt;;

    boost::gregorian::date expiry; // Expiry date
    Money balance;                 // Remaining balance
    std::string currency;          // Balance currency

    // The message will always look like this:
    for (std::string message : {
            ""+CUSD: 0,\""Your account balance is 49.10 USD and will expire on 04/03/16.\"",64"",
        })
    {
        using namespace boost::spirit::x3;

        real_parser&lt;Money&gt; money_;
        int_parser&lt;int, 10, 2, 2&gt; int2_;

        auto to_date = [](auto&amp; ctx) {
            using boost::fusion::at_c;
            auto&amp; t = _attr(ctx);
            _val(ctx) = date(2000+at_c&lt;2&gt;(t), at_c&lt;0&gt;(t), at_c&lt;1&gt;(t));
        };

        auto date_  = rule&lt;struct date_, date&gt; { ""date"" }
                    = (int2_ &gt;&gt; '/' &gt;&gt; int2_ &gt;&gt; '/' &gt;&gt; int2_) [ to_date ];

        auto tied = std::tie(balance, currency, expiry);

        bool ok = phrase_parse(message.begin(), message.end(),
                omit [ *(char_ - ""balance is"") ]
                &gt;&gt; lexeme[""balance is""] &gt;&gt; money_ &gt;&gt; lexeme[+graph]
                &gt;&gt; lexeme[""and will expire on""] &gt;&gt; date_ &gt;&gt; omit[*char_] &gt;&gt; eoi,
                space, tied);

        assert(ok);
        std::cout &lt;&lt; ""Balance: ""  &lt;&lt; balance  &lt;&lt; ""\n"";
        std::cout &lt;&lt; ""Currency: "" &lt;&lt; currency &lt;&lt; ""\n"";
        std::cout &lt;&lt; ""Expiry: ""   &lt;&lt; expiry   &lt;&lt; ""\n"";
    }
}
</code></pre>

<p>Prints</p>

<pre><code>Balance: 49.1
Currency: USD
Expiry: 2016-Apr-03
</code></pre>
",,40937980,470
33856736,2,33856680,2015-11-22T15:49:27.247,1,,3635467,,2015-11-23T16:24:49.433,2015-11-23T16:24:49.433,3,,"<p>You could put them in an array in the order that you want to check them in, and then loop through the array, running a check</p>

<p>Pseudocode:</p>

<pre><code>byte check(int a[]){ // Get's called on update of pins
    byte error = 0;
    for (byte i=1; i &lt; a.length - 1; a++);
    if (a[i] &lt; a[i-1]){
       error++;
    }
    return(error)
}

byte stateArray[] = {
  digitalRead(wire_BROWN),
  digitalRead(wire_BLUE),
  digitalRead(wire_BLACK),
  digitalRead(wire_YELLOW),
  digitalRead(wire_WHITE),
  digitalRead(wire_ORANGE),
  digitalRead(wire_PURPLE),
  digitalRead(wire_GREEN),
};
byte errorCount = check(stateArray);
if (errorCount &gt; 4) {
    // Error Handling
}
</code></pre>
",,40959004,559
34201176,2,33875583,2015-12-10T11:51:19.047,2,,5470638,,2015-12-10T11:51:19.047,,0,,"<p>Okay, so I solved it myself by piping. Thought I should share my solution:</p>

<p>C++ side:</p>

<pre><code>union pipe
{
    uint8_t image[height] [width] [colors];
    uint8_t data [height * width * colors];
} raw;

int main(){
    // Reads in the raw data
    fread(&amp;raw.image, 1, sizeof(raw.data), stdin);

    // Rebuild raw data to cv::Mat
    image = Mat(height, width, CV_8UC3, *raw.image);
}
</code></pre>

<p>Python side: (just added this at end of code above)</p>

<pre><code>sys.stdout.buffer.write(imgage.tostring())
</code></pre>

<p>Running it by typing this in terminal:</p>

<pre><code>python img.py | ./img
</code></pre>

<p>Works really well for me!</p>
",,41050308,454
33879477,2,33879391,2015-11-23T19:53:12.940,4,,3425536,,2015-11-23T19:55:17.023,2015-11-23T19:55:17.023,4,,"<p>Yes. Use a <a href=""http://en.cppreference.com/w/cpp/types/integer"" rel=""nofollow"">fixed width integer type</a> defined in <code>&lt;cstdint&gt;</code>, usually one of the following:</p>

<pre><code>int8_t
int16_t
int32_t
int64_t
uint8_t
uint16_t
uint32_t
uint64_t
</code></pre>

<p>There are also other ones for different use cases. They are available since C++11.</p>
",,41073027,659
33889284,2,33888794,2015-11-24T09:00:17.537,0,,3368201,,2015-11-24T09:00:17.537,,0,,"<p>Your code has a lot of things to fix. First of all what @Tom Mekken pointed out you make comparisons with <code>==</code>, not <code>=</code>. Then you access members with <code>.</code> instead of <code>,</code>. And you should read until <code>available</code> is greater than zero, not equal to. And the <code>setup</code> and <code>loop</code> functions are NOT <code>Setup</code> and <code>Loop</code>, like <code>PinMode</code> and <code>While</code> and <code>Void</code> (C is case sensitive). And you should initialize the serial communication with the baud rate. And <code>LEDPin</code> is not <code>LEDpin</code>. And <code>intParse</code> is not <code>ParseInt</code>.</p>

<p>And... Indent it properly. Here is your code fixed:</p>

<pre><code>int All;  

int LEDpin = 13;

void setup()
{
    Serial.begin(9600);
    pinMode(LEDpin, OUTPUT);
}  

void loop()
{
    while( Serial.available() &gt; 0)
        All = Serial.parseInt();
    if (All == 1)
    {
        digitalWrite(LEDpin,HIGH);
    }
    if (All == 0)
    {
        digitalWrite(LEDpin,LOW);
    }
    if (All == 2)
    {
        digitalWrite(LEDpin,HIGH);  
        delay(1000);  
        digitalWrite(LEDpin,LOW);  
    }
}
</code></pre>

<p>Now, that was just the core part. Your code, however, has also functional problems. Instead of a bunch of if I suggest you to use a switch. And instead of reading a whole integer, since your data is just single-digit, I suggest you to read just one char. This way you won't have problems with other chars and, moreover, you won't have problems when there are available non-printable chars.</p>

<p>Something like this should do the trick:</p>

<pre><code>int LEDpin = 13;

void setup()
{
    Serial.begin(9600);
    pinMode(LEDpin, OUTPUT);
}  

void loop()
{
    switch (Serial.read())
    {
        case '1':
            digitalWrite(LEDpin,HIGH);
            break;
        case '0':
            digitalWrite(LEDpin,LOW);
            break;
        case '2':
            digitalWrite(LEDpin,HIGH);
            delay(1000);
            digitalWrite(LEDpin,LOW);
            break;
    }
}
</code></pre>
",,41075482,1204
33939653,2,33930792,2015-11-26T13:13:09.263,1,,3368201,,2015-11-26T13:13:09.263,,0,,"<p>It should be something else. I tried now with an Arduino UNO this code:</p>

<pre><code>float some_float;

void setup() {
  Serial.begin(9600);
  some_float = 13.3558;
}

void loop() {
  Serial.println(String(""some float: "") + String(some_float, 2));
  delay(1000);
}
</code></pre>

<p>and the output is</p>

<pre><code>some_float: 13.35
some_float: 13.35
some_float: 13.35
...
</code></pre>
",,41093085,945
33978557,2,33978232,2015-11-29T01:53:17.933,0,,1461208,,2015-11-29T15:43:22.703,2015-11-29T15:43:22.703,0,,"<p>[missed the other answer, there's half my answer gone]</p>

<p>I was going to say use <code>Serial.readStringUntil('\n')</code> in order to read a line at a time.</p>

<p>To address the part:</p>

<blockquote>
  <p>how do I extract numbers from the string ""inByte"" to assign to ""val"" and ""addr""</p>
</blockquote>

<p>This is less trivial than it might seem and a lot of things can go wrong. For simplicity, let's assume the input string is always in the format <code>/^(Read|Write) (\d+)( \d+)?$/</code>.</p>

<p>A simple way to parse it would be to find the spaces, isolate the number strings and call <code>.toInt()</code>.</p>

<pre><code>...
int val, addr;

int addrStart = 0;
while(inByte[addrStart] != ' ' &amp;&amp; addrStart &lt; inByte.length())
  addrStart++;
addrStart++; //skip the space

int addrEnd = addrStart + 1;
while(inByte[addrEnd] != ' ' &amp;&amp; addrEnd &lt; inByte.length())
  addrEnd++;

String addrStr = inByte.substring(addrStart, addrEnd); //excludes addrEnd
addr = addrStr.toInt();

if (inByte.startsWith(""Write"")) {
  int valEnd = addrEnd+1;

  while(inByte[varEnd] != ' ' &amp;&amp; varEnd &lt; inByte.length())
      valEnd++;

  String valStr = inByte.substring(addrEnd+1, valEnd);
  val = valStr.toInt();

  EEPROM.write(addr, val);
}
else if (inByte.startsWith(""Read"")) {
 val = EEPROM.read(addr);
}
</code></pre>

<p>This can fail in all sorts of horrible ways if the input string has a double space or the numbers are malformed, or has any other subtle error.</p>

<p>If you're concerned with correctness, I suggest you look into a regex library, or even an standard format such as JSON - see <a href=""https://github.com/bblanchon/ArduinoJson"" rel=""nofollow"">ArduinoJson</a>.</p>
",,41189302,850
44698850,2,34010961,2017-06-22T12:00:06.197,1,,2413201,,2017-06-22T12:00:06.197,,0,,"<blockquote>
  <p>I think that my error is inside the algorithm reach_color</p>
</blockquote>

<p>Right. Consider e. g. <code>hsv[0]</code> is 0.005 and <code>hsv_final[0]</code> is 0; the line</p>

<pre><code>    if ( hsv[0] &gt;hsv_final[0]&amp;&amp;hsv[0]&gt;0 ) hsv[0] -= 0.01;
</code></pre>

<p>will set <code>hsv[0]</code> to −0.005 (which is outside the range [0, 1] assumed by <code>hsvToRgb()</code>, whatever that does with it). In the next loop cycle, the line</p>

<pre><code>    else if(hsv[0]&lt;hsv_final[0]&amp;&amp;hsv[0]&lt;1) hsv[0]+= 0.01;
</code></pre>

<p>will set <code>hsv[0]</code> to +0.005 anew - and so it goes on oscillating. In general, the repeated addition or subtraction of 0.01 is unlikely to yield exactly the same value that <code>rgbToHsv()</code> returned.<br>
Also you should be aware that 0.01 like most decimal fractions cannot be exactly represented in a <code>double</code> (it results in approximately 0.01000000000000000021).<br>
Moreover, the repeated calling of <code>rgbToHsv()</code> in the loop, recalculating <code>hsv[]</code> values based on the previous <code>rgb[]</code> values, makes the algorithm's behavior more difficult to predict.</p>

<p>So, we have to allow for a tolerance of the HSV values for the comparisons, and better use only the <code>hsv[]</code> values for the iteration:</p>

<pre><code>void reach_color(struct color *start, double hsv_final[])
{
  double hsv[3];
  byte rgb[3];

  converter.rgbToHsv(start-&gt;red, start-&gt;green, start-&gt;blue, hsv);
  while (true)
  {
         if (hsv[0] - 0.01 &gt;= hsv_final[0]) hsv[0] -= 0.01;
    else if (hsv[0] + 0.01 &lt;= hsv_final[0]) hsv[0] += 0.01;
    else if (hsv[1] - 0.01 &gt;= hsv_final[1]) hsv[1] -= 0.01;
    else if (hsv[1] + 0.01 &lt;= hsv_final[1]) hsv[1] += 0.01;
    else if (hsv[2] - 0.01 &gt;= hsv_final[2]) hsv[2] -= 0.01;
    else if (hsv[2] + 0.01 &lt;= hsv_final[2]) hsv[2] += 0.01;
    else return;

    converter.hsvToRgb(hsv[0], hsv[1], hsv[2], rgb);
    start-&gt;red   = rgb[0];
    start-&gt;green = rgb[1];
    start-&gt;blue  = rgb[2];
    display_color(*start);
    delay(30);
  }
}
</code></pre>
",,41218617,1425
34019269,2,34013075,2015-12-01T11:27:31.037,0,,2924323,,2015-12-01T11:27:31.037,,0,,"<p>Try this one.</p>

<pre><code>String data = """";
void loop() {
  if(Serial.available())
  {
    data += (char)Serial.read();
  }

  if(inputCommand == ""one"")
  {
    digitalWrite(3, HIGH);
    digitalWrite(5, LOW);
    digitalWrite(6, LOW);
    Serial.print("" Lights set to Low "");
    data = """";
  }

  if(inputCommand == ""two"")
  {
    digitalWrite(3, HIGH);
    digitalWrite(5, HIGH);
    digitalWrite(6, LOW);
    Serial.print("" Lights set to Medium "");
    data = """";
  }

  if(inputCommand == ""three"")
  {
    digitalWrite(3, HIGH);
    digitalWrite(5, HIGH);
    digitalWrite(6, HIGH);
    Serial.print("" Lights set to High "");
    data = """";
  }
}
</code></pre>

<p>What you meant by <code>jibberish</code> is not clear. If you meant that you get unwanted characters, check your baud rate. If you are getting another String that you typed, other than what you expected, check again your code. </p>

<p>This code will work if there is no problem in baud rate..</p>
",,41244560,640
34023680,2,34013075,2015-12-01T15:14:37.930,1,,3368201,,2015-12-03T09:58:01.850,2015-12-03T09:58:01.850,4,,"<p>Your second code is the most ""correct"", in my opinion, because you are using less chars.</p>

<p>As others have pointed out, the first one is wrong because you can't compare chars and strings. If you want to use strings use Ramesh-X's answer, even if I don't like variable size buffers.</p>

<p>Anyway, the second example prints, I think, a lot of lines because you also interprete the new line chars. Moreover I think a switch statement is more clean. So, just replace it with</p>

<pre><code>if (Serial.available() &gt; 0)
{
    char inputCommand = Serial.read();
    if ((inputCommand != '\r') &amp;&amp; (inputCommand != '\n'))
    {
        Serial.print(inputCommand);   
        Serial.print(""        "");      
        Serial.print(inputCommand);
        Serial.print(""       "");     
        Serial.print(char(inputCommand));
    }

    switch (inputCommand)
    {
    case '1':
        digitalWrite(3, HIGH);
        digitalWrite(5, LOW);
        digitalWrite(6, LOW);
        Serial.print("" Lights set to Low "");
        break;
    case '2':
        digitalWrite(3, HIGH);
        digitalWrite(5, HIGH);
        digitalWrite(6, LOW);
        Serial.print("" Lights set to Medium "");
        break;
    case '3':
        digitalWrite(3, HIGH);
        digitalWrite(5, HIGH);
        digitalWrite(6, HIGH);
        Serial.print("" Lights set to High "");
        break;
    }
}
</code></pre>

<p>EDIT: just to test the serial communication, use this sketch:</p>

<pre><code>void setup()
{
    Serial.begin(9600);
}

void loop()
{
    if (Serial.available() &gt; 0)
    {
        char inputCommand = Serial.read();
        if ((inputCommand &gt;= 'a') &amp;&amp; (inputCommand &lt;= 'z'))
            inputCommand = inputCommand + 'A' - 'a';
        Serial.print(inputCommand);
    }
}
</code></pre>

<p>This should print back what you type, but as soon as you write lowercase letters it will print uppercase (e.g. if you write <code>Hello there!</code> it should print <code>HELLO THERE!</code>)</p>

<p>Try this and let us know if it works</p>
",,41266450,574
34025654,2,34024437,2015-12-01T16:51:45.593,1,,5264491,,2015-12-01T16:51:45.593,,1,,"<pre><code>#define XSTR(s) STR(s)
#define STR(s) #s
....
#define THEVAL 12345
....
Serial.println(""The value of "" STR(THEVAL) "" is "" XSTR(THEVAL));
</code></pre>

<p>This would output:</p>

<pre><code>The value of THEVAL is 12345
</code></pre>
",,41279525,101
44723664,2,34024437,2017-06-23T14:18:06.327,1,,2413201,,2017-06-23T14:18:06.327,,0,,"<blockquote>
<pre><code>#define XSTR(s) STR(s)
#define STR(s) #s
....
#define THEVAL 12345
....
Serial.println(""The value of "" STR(THEVAL) "" is "" XSTR(THEVAL));
</code></pre>
  
  <p>But if THEVAL is set to 123,456 this fails.</p>
</blockquote>

<p>With a slight modification it also works:</p>

<pre><code>#define STR(...) #__VA_ARGS__
</code></pre>
",,41347474,776
44755360,2,34024437,2017-06-26T08:06:25.257,0,,2413201,,2017-06-26T08:06:25.257,,0,,"<blockquote>
  <p>I'm confused - why does one macro consider IP_ADDRESS to be a single
  argument, and the other macro sees it as 4 arguments, while the
  function works correctly: it sees 4 arguments?</p>
</blockquote>

<p>In the invocation <code>IP_ADDRESS_STRING(IP_ADDRESS)</code>, there is obviously only the one argument <code>IP_ADDRESS</code>, and this is true irrespective of how <code>IP_ADDRESS</code> is defined, because <em>argument substitution takes place</em> <strong>only after</strong> <em>the arguments for the invocation of a function-like macro have been identified</em> (ISO/IEC 9899:201x).</p>

<p>In the invocation <code>xstr(IP_ADDRESS)</code> with the definition <code>#define xstr(a) str(a)</code>, according to the above the parameter <code>a</code> is then replaced by the one argument <code>IP_ADDRESS</code> <em>after</em> that macro has <em>been expanded</em> (<em>macro replaced</em>), yielding <code>str(192,168,1,1)</code>, so <code>str</code> is passed 4 arguments.</p>

<p>In contrast to the first case, in a function call <code>ipAddressString(IP_ADDRESS)</code> the substitution of <code>IP_ADDRESS</code> takes place not after, but <strong>before</strong> the arguments for the function call are identified.</p>

<p>You can use the macro by the same two-stage technique that's utilized with <code>xstr()</code>/<code>str()</code>:</p>

<pre><code>#define IP_ADDRESS 192,168,1,1
#define XIP_ADDRESS_STRING(abcd) IP_ADDRESS_STRING(abcd)
#define IP_ADDRESS_STRING(a,b,c,d) xstr(a)"".""xstr(b)"".""xstr(c)"".""xstr(d)
#define xstr(a) str(a)
#define str(a) #a
debug(""IP Address is: "" XIP_ADDRESS_STRING(IP_ADDRESS));
</code></pre>
",,41376518,1820
34052464,2,34050119,2015-12-02T20:33:37.890,1,,5582897,,2015-12-02T20:33:37.890,,1,,"<p>I believe something like this addresses your 10 second delay issue. If you want the same 10 second delay to turn it off, you will need to do something similar.</p>

<pre><code>int Pin = 2;
const float baselineVoltage = 5.0;
int belowBaselineVoltage = false;
unsigned long turnOnAt;
const unsigned long turnOnDelay = 10 * 1000;

void setup() {
    Serial.begin(9600);
    pinMode(Pin, OUTPUT);
}

void loop() {
    int sensorValue = analogRead(A0);
    float voltage = sensorValue * (5.0 / 1023.0);
    Serial.println(voltage);

    if (voltage &lt; baselineVoltage)
    {
        if (belowBaselineVoltage == true)
        {
            if (millis() &gt;= turnOnAt)
            {
                digitalWrite(2, HIGH);
            }
        }
        else
        {
            belowBaselineVoltage = true;
            turnOnAt = millis() + turnOnDelay;
        }
    }
    else
    {
        belowBaselineVoltage = false;
    }
}
</code></pre>
",,41390824,773
53529315,2,34089453,2018-11-28T22:53:34.643,2,,10719633,,2018-11-28T22:53:34.643,,0,,"<p>Old question but posting my answers here for anyone who might stumble on it:</p>

<h2>Playing a ringtone</h2>

<p>Assuming your ringtone is a wav file, you need to create a wav player and connect its port to your output device. The wav file will loop until you disconnect the port, then start again when you reconnect it.</p>

<p>Calling <code>init_ringtone_player</code> should be done after calling <code>pjsua_init</code>. <code>ringtone_port_info</code> is a global struct to keep track of the port and ring state.</p>

<pre><code>typedef struct _ringtone_port_info {
    int ring_on;
    int ring_slot;
    pjmedia_port *ring_port;
    pj_pool_t *pool;
} ringtone_port_info_t;

static ringtone_port_info_t ringtone_port_info;

static void init_ringtone_player() {

    int file_slot;
    pj_pool_t *pool;
    pjmedia_port *file_port;
    pj_status_t status;

    pool = pjsua_pool_create(""wav"", 4000, 4000);

    status = pjmedia_wav_player_port_create(pool, ""ringtone.wav"", 
        0, 0, 0, &amp;file_port);

    if (status != PJ_SUCCESS) {
        error_exit(""Error creating WAV player port"", status);
        return;
    }

    status = pjsua_conf_add_port(pool, file_port, &amp;file_slot);

    if (status != PJ_SUCCESS) {
        error_exit(""Error adding port to conference"", status);
        return;
    }

    ringtone_port_info = (ringtone_port_info_t) { .ring_on = 0, 
        .ring_slot = file_slot, .ring_port = file_port , .pool = pool };

}
</code></pre>

<p>Then, make functions to start and stop the ringtone as needed (i.e. during <code>on_incoming_call</code>, <code>on_call_state</code> or wherever). The important function call to note here is <code>pjsua_conf_connect</code>.</p>

<pre><code>pj_status_t start_ring() {
    pj_status_t status;

    if (ringtone_port_info.ring_on) {
        printf(""Ringtone port already connected\n"");
        return PJ_SUCCESS;
    }

    printf(""Starting ringtone\n"");
    status = pjsua_conf_connect(ringtone_port_info.ring_slot, 0);
    ringtone_port_info.ring_on = 1;
    if (status != PJ_SUCCESS)
        error_exit(""Error connecting ringtone port"", status);
    return status;
}

pj_status_t stop_ring() {
    pj_status_t status;

    if (!ringtone_port_info.ring_on) {
        printf(""Ringtone port already disconnected\n"");
        return PJ_SUCCESS;
    }

    printf(""Stopping ringtone\n"");
    status = pjsua_conf_disconnect(ringtone_port_info.ring_slot, 0);
    ringtone_port_info.ring_on = 0;
    if (status != PJ_SUCCESS)
        error_exit(""Error disconnecting ringtone port"", status);
    return status;
}
</code></pre>

<p>Make sure you call <code>pjsua_destroy</code> when you're done to release the pool (or manually release it)</p>

<h2>SIP response codes</h2>

<p>See here for a list of status codes:</p>

<p><a href=""https://www.pjsip.org/pjsip/docs/html/group__PJSIP__MSG__LINE.htm#"" rel=""nofollow noreferrer"">https://www.pjsip.org/pjsip/docs/html/group__PJSIP__MSG__LINE.htm#</a></p>

<p>You can use 200 to accept and 603 to decline (using <code>pjsua_call_answer</code>)</p>
",,41393918,2253
34097173,2,34096172,2015-12-04T20:48:26.237,2,,452483,,2015-12-04T20:48:26.237,,0,,"<p>Looking at the code you can identify 4 different input buttons:</p>

<pre><code>pinMode(HOUR_BUTTON_PIN, INPUT);     
pinMode(MIN_BUTTON_PIN, INPUT);     
pinMode(ALARM_BUTTON_PIN, INPUT);     
pinMode(DET_BUTTON_PIN, INPUT);     
</code></pre>

<p>Obviously the red button is either ALARM or or DET button.</p>

<p>Let's look when the input for each button is read. The code that is responsible for the logic of this toy does not use <code>digitalRead</code> directly but rather through the <code>buttonPressed</code>, <code>buttonPressedNew</code> and <code>buttonHeld</code> functions. Each function receives a number that represents the button and returns true if the button is in the state suggested by the function name. The button numbers are defined at the beginning and mapped to the button pins through the <code>buttonPins</code> array.</p>

<pre><code>#define MIN_BUTTON 0
#define HOUR_BUTTON 1
#define DET_BUTTON 2
#define ALARM_BUTTON 3

...

byte buttonPins[4] = {MIN_BUTTON_PIN, HOUR_BUTTON_PIN, DET_BUTTON_PIN, ALARM_BUTTON_PIN};
</code></pre>

<p>Back to our problem, let's look that the locations where DET_BUTTON and ALARM_BUTTON are being queried. I will focus on setup and loop only as these are the most likely places where where the ""press red button to start"" logic would go.</p>

<pre><code> if (buttonPressed(DET_BUTTON)) {
    // enable silent mode for testing
    beep(3500, 50);
    silent = true;
    while (buttonPressed(DET_BUTTON)); // wait for release
  }
</code></pre>

<p>This is for power up testing of the buzzer - you hold the button while reseting and as long as you continue holding it, there will be a beep. </p>

<pre><code>// check input
  if ((buttonPressed(ALARM_BUTTON)) &amp;&amp; (!displayCountdown)) {
    displayAlarmTime = true;
    if (alarmpm) {
      digitalWrite(LED_PM, HIGH);
    } else {
      digitalWrite(LED_PM, LOW);
    }
    if (alarmMode == ALARM_OFF) {
      digitalWrite(LED_ALARM, LOW);
      digitalWrite(LED_DET, LOW);
    } else {
      digitalWrite(LED_ALARM, HIGH);
      if (alarmMode == ALARM_DET) {
    digitalWrite(LED_DET, HIGH);
      } else {
    digitalWrite(LED_DET, LOW);
      }
    }
  } else {
    displayAlarmTime = false;
    digitalWrite(LED_ALARM, LOW);
    digitalWrite(LED_DET, LOW);
  }
</code></pre>

<p>This is related to LED indicators. If the alarm button is pressed and countdown is not being displayed on the screen some LEDs will turn on otherwise they will be off. Also <code>displayAlarmTime</code> is a flag that indicates that alarm time should be displayed on the screen.</p>

<pre><code>  if (!buttonPressed(ALARM_BUTTON)) {
    if (countdownSeconds &lt; 5940) {
      countdownSeconds += 60;
      countdownDuration += 60;
    }
</code></pre>

<p>This code is inside <code>if (buttonPressedNew(HOUR_BUTTON) || buttonHeld(HOUR_BUTTON, 150))</code> blkock so not interesting. Similar verdict for the next snippet which I did not bother copying.</p>

<pre><code>if (buttonPressedNew(DET_BUTTON)) {
    if (displayAlarmTime) {
      alarmMode++;
      if (alarmMode &gt; ALARM_DET) {
    alarmMode = ALARM_OFF;
      }
      if (alarmMode == ALARM_OFF) {
    snoozeActivated = false;
      }
      return;
    }
    if ((displayZeros) || (isDefused)) {
      isDefused = false;
      displayZeros = false;
      displayCountdown = false;
      return;
    }
    // The DET button has been pressed but not released yet.
    detPressed = true;
    countdownSeconds = defaultCountdownSeconds;
    displayCountdown = true;
  }
</code></pre>

<p>First part related to alarm. It is a little puzzling to me since there are only three alarm modes and the mode with the highest number is actually <code>ALARM_DET</code> so the line <code>alarmMode &gt; ALARM_DET</code> must never be true. </p>

<p>Anyway it does not look like our candidate.</p>

<p>Now regarding the second part which looks more promising.
The flag <code>displayZeros</code> I assume is indicating that zeros are displayed on the display which means you did not defuse on time. The <code>isDefused</code> flag is indicating that you did defuse the bomb. Together, <code>if ((displayZeros) || (isDefused))</code> is indicating that you are at the end of a ""play"" ( you either won or lost), thus the action that should be taken is to reset the display.</p>

<p>The flag <code>detPressed</code> is used to remember that DET button was pressed. It will be reset lated in the code that checks that DET button is not pressed, so as long as the button is pressed it will stay ture. </p>

<p>The variable <code>countdownSeconds</code> holds the number os seconds left for end of countdown (obviously). And then the code also tells the display logic to display this count down on the screen.</p>

<pre><code>  if (!buttonPressed(DET_BUTTON)) {
    if (detPressed) {
      detPressed = false;
      defaultCountdownSeconds = countdownSeconds;
      writeEEPROM();
      countdown();
    }
  }
</code></pre>

<p>This is the last part. The inner logic will happen when you release the DET button. It will set the <code>defaultCountDown</code> seconds to the current countdown seconds, I guess this is because you can change the countdown while the button is pressed, write something (the default countdown?) to eeprom and ... initiate the countdown!</p>

<p>Now, I hope, you have enough information to figure out yourself how to change the program your desired way.</p>
",,41403974,71
34103770,2,34103553,2015-12-05T10:28:48.420,0,,1248008,,2015-12-05T10:28:48.420,,2,,"<p>You allocate two elements to the array <code>buttonState</code>, but you are accessing seven:</p>

<pre><code>[…]
int buttonState[] = {0,0};
[…]
    for (int z = 0; z &lt; 7; ++z)
    {
        buttonState[z] = digitalRead(z+30); 
[…]
</code></pre>

<p>You should increase the number of elements in the <code>buttonState</code> array to be as many as you actually need.</p>

<p>It might be better to define the size of the arrays at a single place:</p>

<pre><code>#define NUM_ZONES (7)
[…]
const int * zones[NUM_ZONES]={zone2,zone3,zone4,zone5,zone6,zone7,zone8};

int buttonState[NUM_ZONES] = {0,0,0,0,0,0,0};

int previousState[NUM_ZONES]={0,0,0,0,0,0,0};

[…]
    for (int z = 0; z &lt; NUM_ZONES; ++z)
[…]
</code></pre>

<p>This will also reveal that your <code>previousState</code> array is larger than needed (the compiler will complain that you have too many initialisers for that array). It is then important to re-use that constant everywhere instead of writing the <em>magic number</em> <code>7</code>.</p>
",,41411349,361
34111020,2,34110974,2015-12-05T21:17:35.950,2,,2877241,,2015-12-05T21:29:32.707,2015-12-05T21:29:32.707,3,,"<p>As it follows from the error message class <code>TFT</code> does not have the default constructor (a constructor that can be called without arguments).</p>

<p>Check the class definition.</p>

<p>The error occurs because there is called the default constructor of class <code>TFT</code></p>

<pre><code>class Menu {
  String menuTitle = ""Menu"";
  TFT TFTscreen;
  ^^^^^^^^^^^^^^
  public:
    Menu(String title, TFT screen)
    {
      menuTitle = title;
      TFTscreen = screen;
    }
    //...
</code></pre>

<p>You could write the Menu constructor the following way</p>

<pre><code>Menu( const String &amp;title, const TFT &amp;screen ) : menuTitle( title ), TFTscreen( screen )
{
}
</code></pre>

<p>(I am not sure whether String is a valid class name)</p>

<p>And because C++ is not C# you may not write</p>

<pre><code>Menu menu = new Menu(""Test Menu"", scrn);
</code></pre>

<p>You have to write</p>

<pre><code>Menu *menu = new Menu(""Test Menu"", scrn);
</code></pre>

<p>Or it seems you could write simply</p>

<pre><code>Menu menu(""Test Menu"", scrn);
</code></pre>
",,41419677,581
34113238,2,34111853,2015-12-06T02:18:58.997,1,,4100891,,2015-12-06T02:32:48.313,2015-12-06T02:32:48.313,6,,"<p>You can declare a packed <code>struct</code> to hold these two values:</p>

<pre><code>struct chan_value_t
{
  uint8_t  channel : 6;
  uint16_t value   : 10;
};
</code></pre>

<p>But to send it as two bytes, you'll need to either (1) ""union"" it with a two-byte array:</p>

<pre><code>union chan_value_t
{
  struct {
    uint8_t  channel : 6;
    uint16_t value   : 10;
  };
  uint8_t bytes[2];
};

chan_value_t cv;

void setup()
{
  Serial.begin( 9600 );

  cv.channel = 2;
  cv.value = 800;
  for (int i=0; i&lt;sizeof(cv.bytes); i++) {
    Serial.print( cv.bytes[i], HEX );
    Serial.print( ' ' );
  }
  Serial.println();
}

void loop() {}
</code></pre>

<p>(The <code>struct</code> is anonymous when nested in this union; the union has the name.)</p>

<p>Or (2) cast a pointer to the struct to a pointer to bytes:</p>

<pre><code>struct chan_value_t {
  uint8_t  channel : 6;
  uint16_t value   : 10;
};

chan_value_t cv;

void setup()
{
  Serial.begin( 9600 );

  cv.channel = 2;
  cv.value = 800;
  uint8_t *bytes = (uint8_t *) &amp;cv; // cast &amp;cv to a pointer to bytes
  for (int i=0; i&lt;sizeof(cv); i++) {
    Serial.print( bytes[i], HEX );
    Serial.print( ' ' );
  }
  Serial.println();
}

void loop() {}
</code></pre>

<p>They both print the hexadecimal value of the bytes: 0x02 and 0xC8.  800 is 0x320, shifted left by 6 bits is 0xC800.</p>

<p>To send this to the PC, you may want to start with a special character sequence and finish with a checksum of some sort (Fletcher checksum is easy).  Then it's easy to throw away garbage characters and know when there are transmission errors.</p>
",,41434820,97
40627835,2,34121110,2016-11-16T09:03:10.243,0,,1817345,,2016-11-16T09:03:10.243,,0,,"<p>You can also use the following code:</p>

<pre><code>uint8_t data[4];
data[0]=read4;
data[1]=read3;
data[2]=read2;
data[3]=read1;
unsigned long testint =*(unsigned long*)(&amp;data);
</code></pre>
",,41440245,6061
34122733,2,34122599,2015-12-06T21:04:39.100,1,,452483,,2015-12-06T21:04:39.100,,0,,"<p>In Arduino.h file, you can find the following preprocessor checks:</p>

<pre><code>#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
...
#else  
#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
...
#endif
</code></pre>

<p>I never tried these, but do not I see why you will not be able to use them in your code as well.</p>
",,41443720,6190
34261713,2,34261512,2015-12-14T07:26:08.007,9,,4737610,,2020-06-18T10:17:45.320,2020-06-18T10:17:45.320,3,,"<p>Here is a C code:</p>

<pre><code>#include &lt;stdio.h&gt;


int main()
{
    FILE *io,*iodir,*ioval;

    io = fopen(""/sys/class/gpio/export"", ""w"");
    fseek(io,0,SEEK_SET);
    fprintf(io,""%d"",39);
    fflush(io);

    iodir = fopen(""/sys/class/gpio/gpio39/direction"", ""w"");
    fseek(iodir,0,SEEK_SET);
    fprintf(iodir,""out"");
    fflush(iodir);

    ioval = fopen(""/sys/class/gpio/gpio39/value"", ""w"");
    fseek(ioval,0,SEEK_SET);

    while(1)
    {
        fprintf(ioval,""%d"",1);
        fflush(ioval);
        sleep(1);
        fprintf(ioval,""%d"",0);
        fflush(ioval);
        sleep(1);
    }

    fclose(io);
    fclose(iodir);
    fclose(ioval);
    return 0;
}
</code></pre>

<p>Be sure to do proper error checking.</p>

<p>Follow Derek Molloy's website on Beaglebone <a href=""http://derekmolloy.ie/beaglebone/"" rel=""nofollow noreferrer"">His site</a></p>
",,41457006,1945
34330599,2,34308740,2015-12-17T09:08:48.447,0,,4804941,,2015-12-17T09:10:28.567,2015-12-17T09:10:28.567,0,,"<p>I just used this line to compile and every thing went well!</p>

<pre><code>g++ main.cpp -o app $(pkg-config --cflags --libs opencv)
</code></pre>

<p>I was compiling using cmake with this CMakeList.txt</p>

<pre><code>cmake_minimum_required(VERSION 2.8)
project( App )
find_package( OpenCV REQUIRED )
add_executable( App main.cpp )
target_link_libraries( App${OpenCV_LIBS} )
</code></pre>
",,41484853,461
34420160,2,34317500,2015-12-22T16:20:39.257,0,,2410359,,2015-12-22T16:20:39.257,2017-05-23T12:31:10.713,0,,"<p>Problems:</p>

<ol>
<li><p><code>sscanf(buffer, ""%[^OK]"", buffer);</code> attempts to read and write to the same buffer.  This is undefined behavior.  Use different buffers.   <a href=""https://stackoverflow.com/questions/34317500/sscanf-parse-response-with-whitespaces#comment56377066_34317500"">@EOF</a></p></li>
<li><p><code>""%[^OK]""</code> Looks for all <code>char</code> that is not <code>'O'</code> and is not <code>'K'</code>, so it stops at <code>\r\n+CIPRX ... DATA C</code></p></li>
<li><p><code>""%*s""</code> in <code>sscanf(""%*s,%d...""</code> does 2 things 1) scan and not save all leading white-space characters.  2) scan and not save (because of <code>'*'</code>) all non-white-space characters.  There will never be a <code>','</code> following ""all non-white-space characters"", so <code>sccanf()</code> stops.</p></li>
</ol>

<p>When using <code>sscanf()</code> and having troubles, the first thing to code is a check of the return values of <code>sscanf()</code>.</p>

<p>Unclear as to OP overall goal, but perhaps the following will help.</p>

<pre><code>#include &lt;stdio.h&gt;

char *text = 
""\r\n+CIPRXGET:1\r\n+CIPRXGET: 2,1,3\r\nDATA COMPOSED BY A WHITESPACE AND MAYBE OTHER\r\nOK"";

int main(void) {
  char data[256];
  int bytesRead, bytesToRead;
  if (sscanf(text, ""%*[^,],%d,%d %255[^\r\n]"", &amp;bytesRead, &amp;bytesToRead, data) == 3) {
    printf(""bytesRead:%d\nbytesToRead:%d\ndata:'%s'\n"",bytesRead, bytesToRead, data);
  }
  return 0;
}
</code></pre>

<p>Output</p>

<pre><code>bytesRead:1
bytesToRead:3
data:'DATA COMPOSED BY A WHITESPACE AND MAYBE OTHER'
</code></pre>
",,41511494,599
34329274,2,34328414,2015-12-17T07:50:27.537,1,,4386427,,2015-12-17T07:50:27.537,,0,,"<p>The post-increment operator (i.e. variable++) will increment the variable but return the old value of the variable. It is equivalent to:</p>

<pre><code>SomeType PostIncrement(SomeType&amp; v)
{
    SomeType oldValue = v;
    v = v + 1;
    return oldValue;
}
</code></pre>

<p>Example:</p>

<pre><code>int x = 5;
int y = x++;
// Here x is 6 while y is 5 (i.e. the old value of x)
</code></pre>

<p>When you use post-increment on a variable you pass in a function call, the function will be called with the old value. Still the increment is done before the function call because the arguments will be fully evaluated before the call.</p>

<p>Example:</p>

<pre><code>void f(int y)
{
    // When execution arrives here, x is 6 while y is 5 (i.e. the old value of x)

}

int main()
{
    int x = 5;
    f(x++);
    return 0;
}
</code></pre>
",,41522943,2130
34342857,2,34342802,2015-12-17T19:37:12.083,0,,2296458,,2015-12-17T19:37:12.083,,1,,"<p>You did not copy the syntax correctly, it would actually be</p>

<pre><code>BTD::BTD(USB *p)
: connectToWii(false),
  pairWithWii(false),
  connectToHIDDevice(false),
  pairWithHIDDevice(false),
  pUsb(p) // Pointer to USB class instance - mandatory
{
  /*
   *Other unrelated Code
  */
}
</code></pre>

<p>Note the <code>:</code> before the constructor body. This is the <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">constructor member initializer list</a>, it is initializing the member variables of that class. Therefore this line</p>

<pre><code>pUsb(p)
</code></pre>

<p>Is taking the <code>USB*</code> argument <code>p</code> and copying it to the member variable <code>pUsb</code>. Long story short, it is just copying a pointer to its member variable.</p>
",,41537283,80
34390621,2,34390406,2015-12-21T07:16:26.470,1,,3133316,,2015-12-21T07:22:09.867,2015-12-21T07:22:09.867,1,,"<p>Your program produces undefined behavior due to a buffer overrun.</p>

<pre><code>char _int_char[2];
sprintf(_int_char, ""%d"", 37); // &lt;-- buffer overrun
</code></pre>

<p>Since the resulting string may occupy more than 2 characters, the excess characters overflow the <code>_int_char</code> array and will overwrite memory.  What is at the overwritten memory before the corruption may have something to do with the parameter <code>message</code>.  </p>

<p>Instead of creating a 2 character array, declare the array big enough to not produce a buffer overflow.  </p>

<pre><code>char _int_char[20];
sprintf(_int_char, ""%d"", some_integer);
</code></pre>

<p>Unless you have integers that have more than 19 digits, this should now not overflow the buffer.  </p>

<hr>

<p>A foolproof solution, since you're using C++, is to use C++ streams, namely <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow"">std::ostringstream</a>.  Then you need not worry about buffer overruns, regardless of the length of the data to be outputted:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
//...
std::string _int_char;
std::ostringstream strm;
strm &lt;&lt; some_integer;
_int_char &lt;&lt; strm.str();
</code></pre>
",,41549624,345
34391281,2,34390979,2015-12-21T08:05:49.523,6,,212107,,2015-12-21T09:26:29.397,2015-12-21T09:26:29.397,1,,"<p>Some things wrong with your code:</p>

<p><code>#</code> is not a comment in C. It starts a compiler directive, for instance <code>#define</code>. If you want to comment one out, add a comment before it like this: <code>//</code>:</p>

<pre><code>#define ARDUINO_MEGA
// #define ARDUINO_UNO
// #define ARDUINO_NANO
</code></pre>

<p>Without the comments you define all three values, so the last definition block will override the previous ones. The definition blocks itself should work, but <a href=""https://www.arduino.cc/en/Reference/Define"" rel=""nofollow"">the documentation recommends</a> to use <code>const</code> instead of <code>#define</code> if it's not directly compiler related.</p>

<p>That means the definition blocks should look like this:</p>

<pre><code>#ifdef ARDUINO_NANO
const int R 7 // Red led attached to pin 7
const int G 8 // Green led attached to pin 8
const int B 9 // Blue led attached to pin 9
#endif
</code></pre>

<p>This is the next error: You are providing a char instead of the expected integer. The compiler translates the char to the expected byte, but uses the <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a> value for this. An <code>R</code> becomes <code>82</code> instead of the <code>22</code> you expect for the Arduino Mega.</p>

<pre><code>void loop(){
    // blink('R', 5, 100);
    blink(R, 5, 100);
    blink(G, 3, 300);
    blink(B, 10, 80);
}
</code></pre>
",,41582825,533
34423602,2,34423244,2015-12-22T20:02:54.450,1,,3826372,,2015-12-22T20:02:54.450,,0,,"<p>If there are a lot of these <code>prog_</code> types then a simple solution would be to create a header file with the following in it and include in any file that uses these types:</p>

<pre><code>#include &lt;stdint.h&gt;

typedef void prog_void;
typedef char prog_char;
typedef unsigned char prog_uchar;
typedef int8_t prog_int8_t;
typedef uint8_t prog_uint8_t;
typedef int16_t prog_int16_t;
typedef uint16_t prog_uint16_t;
typedef int32_t prog_int32_t;
typedef uint32_t prog_uint32_t;
typedef int64_t prog_int64_t;
typedef uint64_t prog_uint64_t;
</code></pre>

<p>If there are only a few uses of the <code>prog_</code> types, or if you want to properly fix the code, then just replace them where they're used with appropriate type. For example:</p>

<pre><code>const PROGMEM uint16_t levels[NUM_LEVELS] = {...};
const PROGMEM unsigned char ledCharSet[20] = {...};
</code></pre>
",,41586035,69
34432545,2,34431412,2015-12-23T09:37:37.470,2,,3368201,,2015-12-23T09:37:37.470,,1,,"<p>Did you try to just print the data? I think no, because otherwise you would have noticed that.. You are not sending the integers one after the other.</p>

<p>The reason? You are adding one to data every iteration, but you are sending it away every second.</p>

<p>The way to fix it is really simple: this</p>

<pre><code>if (deltaTime &gt; 1000)
{  
    // Send the packet
    Serial.write(buff,2) ;
    oldTime = millis();
}

// increment the integer:
data++; 

if(data &gt;= 400 ) data = 0;
</code></pre>

<p>should become this</p>

<pre><code>if (deltaTime &gt; 1000)
{  
    // Send the packet
    Serial.write(buff,2) ;
    oldTime = millis();

    // increment the integer:
    data++; 

    if(data &gt;= 400 ) data = 0;
}
</code></pre>

<p>However I think you will experience some problems in the long run, especially if you are calling the slot with a 1s period.</p>

<p>I suggest you to use the unused bits (you send integers from 0 to 400, so 9 bits, but you are sending 16 of them) to provide a way to understand if the byte is the high one or the low one.</p>

<p>The easiest way would be to send the upper 7 bits in the first byte and set the highest bit to one, then send the lowest 7 bits and set the highest bit to zero. In the qt, then, read continuously. If the first bit is one then save the other part as the uppermost, if it is zero join the other part to the saved one and output it to the console.</p>
",,41647845,792
34463885,2,34463713,2015-12-25T15:01:48.060,1,,2877241,,2015-12-25T15:01:48.060,,0,,"<p>This definition</p>

<pre><code>TinyWebServer::PathHandler _handlers[] = {
    //Register the index_handler for GET requests on /
    {""/"", TinyWebServer::GET, &amp;ShutterWebserver::index_handler },
    {NULL}, // The array has to be NULL terminated this way
};
</code></pre>

<p>declares a global variable with name <code>_handlers</code></p>

<p>If you want to define a class data member then you have to specify a quakified name of a variable.</p>

<pre><code>TinyWebServer::PathHandler ShutterWebserver::_handlers[] = {
    //Register the index_handler for GET requests on /
    {""/"", TinyWebServer::GET, &amp;ShutterWebserver::index_handler },
    {NULL}, // The array has to be NULL terminated this way
};
</code></pre>

<p>Also it is better to specify explicitly the size of the array </p>

<pre><code>TinyWebServer::PathHandler ShutterWebserver::_handlers[2] = {
    //Register the index_handler for GET requests on /
    {""/"", TinyWebServer::GET, &amp;ShutterWebserver::index_handler },
    {NULL}, // The array has to be NULL terminated this way
};
</code></pre>

<p>because in the class definition it is already set explicitly</p>

<pre><code>//...
private:
  static TinyWebServer::PathHandler _handlers[2];
//...
</code></pre>

<p>Otherwise it is not clear whether indeed the array has two elements.</p>
",,41648117,1466
34467040,2,34466946,2015-12-25T22:41:28.237,2,,111143,,2015-12-25T22:56:16.617,2017-05-23T12:30:56.943,4,,"<p>You are using the function <code>sum</code> before you have declared it. You could either move the function sum above the use, or you could forward declare it:</p>

<pre><code>int sum();  // Forward declared
int number = 0;

int a() {
 for(int i = 0; i &lt; 20; i++) {
  if((i % 2) == 1) {
   number = sum();
  }  
 }
 return number;
}

int sum() {
 number = number + 100;
 return number;
}
</code></pre>

<p>Further explanation of the this problem, can be found elsewhere on Stack Overflow, such as the answers to this question: <a href=""https://stackoverflow.com/a/4757817/111143"">Why do functions need to be declared before they are used?</a> </p>

<p>Note: I never thoroughly tested your code, which I guess you never did either, so as LogicStuff pointed out it didn't even compile, I've made a few changes to make the code compile, as few changes as possible so that the original code should still be visible from it. Thanks for pointing it out LogicStuff.</p>
",,41667391,87
34467435,2,34466946,2015-12-25T23:54:37.477,0,,4404330,,2015-12-26T00:14:09.423,2015-12-26T00:14:09.423,0,,"<p>There are a number of errors in your code which will cause compiler errors:</p>

<p>If you're using the <code>sum()</code> function in <code>int a()</code>, then you need to forward-declare it. </p>

<pre><code>int sum();

int add() {
    //
}

int sum() {
    //
}
</code></pre>

<p>All <code>sum()</code> really does however, is add 100 to a variable. This can be incorporated into the <code>add()</code> function very easily via the <code>+=</code> operator, meaning your code is equivalent to this:</p>

<pre><code>int a() {
    int number = 0;        //Added a necessary ';'
    for(int i = 0; i &lt; 20; i++) { 
        if(i % 2 == 1) {   //Corrected this from if(i % 2 = 1)
            number += 100; //No need for the sum() function
        }  
    }
    return number;
}
</code></pre>

<p><strong>The crucial aspect:</strong></p>

<p>There are a <strong>lot</strong> of additional optimizations you could perform on your setup; Essentially, <code>int a()</code> could be simplified to </p>

<pre><code>int a() {
    return 1000;
} 
</code></pre>

<p>So, you could just as easily <i>not</i> have <code>a()</code> be a function at all:</p>

<pre><code>#define a() 1000
</code></pre>

<p>Or, (probably better):</p>

<pre><code>const int a = 1000;
</code></pre>

<p><strong>EDIT :</strong> 
For your updated code you need to write <code>int zmeratSonar28();</code> before <code>int zmeratSonar1()</code> starts: </p>

<pre><code>int zmeratSonar28();

int zmeratSonar1() {
    //Sonar code stuff
}

int zmeratSonar28() {
    //Other sonar code stuff
}
</code></pre>
",,41715726,266
34470137,2,34469728,2015-12-26T09:41:50.333,0,,1632887,,2015-12-29T06:56:02.740,2015-12-29T06:56:02.740,6,,"<p>First of all, I agree with @Thomas Padron-McCarthy. Sending character string instead of a byte array(11 bytes instead of 3 bytes, and the parsing process) is would<strike>simply</strike> be waste of resources. On the other hand, the approach you should follow depends on your sender:</p>

<ul>
<li>Is it periodic or not</li>
<li>Is is fixed size or not</li>
</ul>

<p>If it's periodic you can check in the time period of the messages. If not, you need to check the messages before the buffer is full.
<strong>If you think printable encoding is not suitable for you somehow;</strong> In any case i would add an checksum to the message. Let's say you have fixed size message structure:</p>

<pre><code>typedef struct MyMessage
{
    // unsigned char id; // id of a message maybe?
    unsigned char colors[3]; // or unsigned char r,g,b; //maybe
    unsigned char checksum; // more than one byte could be a more powerful checksum
};

unsigned char calcCheckSum(struct MyMessage msg)
{
    //...
}

unsigned int validateCheckSum(struct MyMessage msg)
{
    //...
    if(valid)
       return 1;
    else
       return 0;
}
</code></pre>

<p>Now, you should check every 4 byte (the size of MyMessage) in a sliding window fashion if it is valid or not:</p>

<pre><code> void findMessages( )
 {
     struct MyMessage* msg;
     byte size = Serial.readBytes(input, INPUT_SIZE);
     byte msgSize = sizeof(struct MyMessage);
     for(int i = 0; i+msgSize &lt;= size; i++)
     {
         msg = (struct MyMessage*) input[i];
         if(validateCheckSum(msg))
         {// found a message
             processMessage(msg);
         }
         else
         {
             //discard this byte, it's a part of a corrupted msg (you are too late to process this one maybe)
         }
     }
 }
</code></pre>

<p>If It's not a fixed size, it gets complicated. But i'm guessing you don't need to hear that for this case.</p>

<p><strong>EDIT (2)</strong> 
I've striked out this edit upon comments.
<strike>One last thing, i would use a circular buffer. First add the received bytes into the buffer, then check the bytes in that buffer.</strike> </p>

<p><strong>EDIT (3)</strong>
I gave thought on comments. I see the point of printable encoded messages. I guess my problem is working in a military company. We don't have printable encoded ""fire"" arguments here :) There are a lot of messages come and go all the time and decoding/encoding printable encoded messages would be waste of time. Also we use hardwares which usually has very small messages with bitfields. I accept that it could be more easy to examine/understand a printable message.</p>

<p>Hope it helps,
Gokhan.</p>
",,41726934,120
34470287,2,34469728,2015-12-26T10:04:39.823,2,,168986,,2015-12-26T10:04:39.823,,2,,"<p>It is not a matter of reading the serial port faster, it is a matter of not reading a fixed block of 11 characters when the input data has variable length. </p>

<p>You are telling it to read until 11 characters are received or the timeout occurs, but if the first group is fewer than 11 characters, and a second group follows immediately there will be no timeout, and you will partially read the second group. You seem to understand that, so I am not sure how you conclude that ""reading faster"" will help.</p>

<p>Using your existing data encoding of ASCII decimal space delimited triplets, one solution would be to read the input one character at a time until the entire triplet were read, however you could more simply use the Arduino <code>ReadBytesUntil()</code> function:</p>

<pre><code>#define INPUT_SIZE 3

void loop()
{
    if (Serial.available())
    {
        char rgb_str[3][INPUT_SIZE+1] = {{0},{0},{0}};

        Serial.readBytesUntil( "" "", rgb_str[0], INPUT_SIZE );
        Serial.readBytesUntil( "" "", rgb_str[1], INPUT_SIZE );
        Serial.readBytesUntil( "" "", rgb_str[2], INPUT_SIZE );

        for( int channelNumber = 0; channelNumber &lt; 3; channelNumber++)
        {
            color[channelNumber] = atoi(channel);
        }

        setColor(color);
    }
}
</code></pre>

<p>Note that this solution does not require the somewhat heavyweight <code>strtok()</code> processing since the <code>Stream</code> class has done the delimiting work for you.</p>

<p>However there is a simpler and even more efficient solution. In your solution you are sending ASCII decimal strings then requiring the Arduino to spend CPU cycles needlessly extracting the fields and converting to integer values, when you could simply send the byte values directly - leaving if necessary the vastly more powerful PC to do any necessary processing to pack the data thus.  Then the code might be simply:</p>

<pre><code>void loop()
{
    if( Serial.available() )
    {
        for( int channelNumber = 0; channelNumber &lt; 3; channelNumber++)
        {
            color[channelNumber] = Serial.Read() ;
        }

        setColor(color);
    }
}
</code></pre>

<p>Note that I have not tested any of above code, and the Arduino documentation is lacking in some cases with respect to descriptions of return values for example.  You may need to tweak the code somewhat.</p>

<p>Neither of the above solve the synchronisation problem - i.e. when the colour values are streaming, how do you know which is the start of an RGB triplet?  You have to rely on getting the first field value and maintaining count and sync thereafter - which is fine until perhaps the Arduino is started after data stream starts, or is reset, or the PC process is terminated and restarted asynchronously.   However that was a problem too with your original implementation, so perhaps a problem to be dealt with elsewhere.</p>
",,41727205,251
34472847,2,34472585,2015-12-26T15:51:10.277,1,,5629208,,2015-12-26T15:51:10.277,,0,,"<p>You can code as following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;map&gt;

int main()
{
    enum LedType {
      LedInvalid = 0,
      LedOne = 9,
      LedTwo = 6,
      LedThree = 5,
    };

    std::map&lt;LedType, int&gt; x = { { LedOne, 9 }, { LedTwo, 6 }, { LedThree, 5 } };
    printf(""%d %d %d\n"", x[LedOne], x[LedTwo], x[LedThree]);
}
</code></pre>
",,41754453,1753
34503416,2,34503358,2015-12-29T02:01:49.250,3,,14860,,2015-12-29T02:13:42.677,2015-12-29T02:13:42.677,1,,"<p>You have methods apparently being created <em>within</em> the constructor, which is not correct. Each should be its <em>own</em> method, such as:</p>

<pre><code>void ledControler::ledOn() {
    digitalWrite(pinNumber, HIGH);
}
</code></pre>

<p>Consider your code snippet within the constructor:</p>

<pre><code>ledOn();{
    digitalWrite(pinNumber, HIGH);
}
</code></pre>

<p>This is actually being treated as a call to the function <code>ledOn</code> followed by a block containing the <code>digitalWrite</code> call, both of which are perfectly valid (other than the fact there is no <code>ledOn</code> function being defined, of course, something you'd no doubt discover at link time if you could get past the compile errors).</p>

<p>The particular compile error that's preventing this is your attempted definition:</p>

<pre><code>ledStrobe(int time);{ ...
</code></pre>

<p>As stated, this is actually more of a <em>call</em> to <code>ledStrobe</code> and unfortunately it's not a valid one since you're not supposed to provide the data types in the call (it would normally be <code>ledStrobe(time);</code>).</p>

<p>So that's where the first error comes from. The second is because, since you're not actually defining a function receiving the <code>time</code> parameter, the code that uses it is complaining that it doesn't exist.</p>

<p>Defining the methods correctly should fix both those issues, and that can be done with something like:</p>

<pre><code>class ledControler {
    public:
        void ledOn();
        void ledOff();
        void ledStrobe();
        void ledFade();
        ledControler(int);
    private:
        int pinNumber = 0;
};

ledControler::ledControler(int pin) {
    pinNumber = pin;
    pinMode(pinNumber, OUTPUT);
}

void ledControler::ledOn() {
    digitalWrite(pinNumber, HIGH);
}

void ledControler::ledOff () {
    digitalWrite(pinNumber, LOW);
}

void ledControler::ledStrobe(int time) {
    digitalWrite(pinNumber, HIGH);
    delay(time);
    digitalWrite(pinNumber, LOW);
    delay(time);
}
</code></pre>
",,41754678,666
34527009,2,34526720,2015-12-30T09:50:30.113,1,,5470596,,2015-12-30T09:50:30.113,,2,,"<p>Since you get your characters one at a time, you'll have to remember a state: <kbd><a href=""http://coliru.stacked-crooked.com/a/95849de9974ad06f"" rel=""nofollow"">Demo</a></kbd></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

namespace
{
    const char uart_endl[] = ""\xff\xfe\xfa"";
    const size_t uart_endl_len = sizeof(uart_endl) - 1;
}

class DataReceiver
{
    const char* state;
    std::string buffer;
public:
    DataReceiver() : state(&amp;uart_endl[0]) {}
    void onDataCallback(char arrivedChar)
    {
        buffer.push_back(arrivedChar);
        if (*state == arrivedChar)
        {
            state++;
            if (*state == '\0')
            {
                state = &amp;uart_endl[0];
                buffer.erase(buffer.end() - uart_endl_len, buffer.end());
                std::cout &lt;&lt; buffer &lt;&lt; std::endl;
                buffer.clear();
            }
        }
        else
        {
            state = &amp;uart_endl[0];
        }
    }
};

int main()
{
    DataReceiver buffer;
    buffer.onDataCallback('a');
    buffer.onDataCallback('b');
    buffer.onDataCallback('\xff');
    buffer.onDataCallback('\xfe');
    buffer.onDataCallback('\xfa');
    buffer.onDataCallback('c');
    buffer.onDataCallback('\xff');
    buffer.onDataCallback('d');
    buffer.onDataCallback('\xff');
    buffer.onDataCallback('\xfe');
    buffer.onDataCallback('e');
    buffer.onDataCallback('\xff');
    buffer.onDataCallback('\xfe');
    buffer.onDataCallback('\xfa');
    return 0;
}
</code></pre>

<p><strong>Output</strong>:</p>

<pre><code>ab
c�d��e
</code></pre>

<p>I hope it helps.</p>
",,41757588,97
34559111,2,34559058,2016-01-01T19:05:03.013,-2,,3452627,,2016-01-01T19:05:03.013,,1,,"<p>In C++ language arrays are pointers to memory blocks. So, you can return a pointer to array. Notice, that you can't return pointers to arrays created in function, because this memory can be (and possibly will be) overwritten.</p>

<pre><code>byte a[100];
byte b[100];

byte* f(int x)
{
    if(x % 2 == 0)
        return a;
    else
        return b;
}
</code></pre>
",,41763658,295
34559137,2,34559058,2016-01-01T19:08:17.047,4,,1870760,,2016-01-01T19:08:17.047,,0,,"<p>A <em>lot</em> of this code is indeed unnecessary. You can rewrite all those arrays and functions for the arrays to just 1 function :</p>

<pre><code>void WriteBytes(byte* data, int length)
{
    for (int i = 0; i &lt; length; ++i)
        lc.setRow(0, i, data[i]);
}
</code></pre>

<p>Then you'd call it like this :</p>

<pre><code>byte data[] =
{
   0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
WriteBytes(data, sizeof(data) / sizeof(data[0]));
</code></pre>
",,41764016,54
34562207,2,34559058,2016-01-02T03:07:58.173,0,,4057102,,2016-01-02T03:07:58.173,,0,,"<p>Jamey D provided a nice answer. And Gernot1976 shows a good way of reducing your array declarations by dynamically generating the contents. </p>

<p>However, as your question refers to dealing with an actual array, I can show you how to do this using a reference to an array.</p>

<p>Using a template, you can easily pass in your arrays to a common function.
This method accepts a reference to an array. If you want to hard code the size <code>N</code> then you can remove the template altogether.</p>

<pre><code>template&lt; size_t N &gt;
void WriteBytes( byte (&amp;arr)[N] ){

    for (int i = 0; i &lt; N; ++i){
        lc.setRow(0, i, arr[i]);
    }
}

//Non template:
void WriteBytes( byte (&amp;arr)[8] ){

    for (int i = 0; i &lt; 8; ++i){
        lc.setRow(0, i, arr[i]);
    }
}
</code></pre>

<p>However your question asked for returning an array. So for sake of showing how, here is a small example. As I do not have <code>LedControl</code> &amp; <code>lc</code> in these examples, its line is commented out.</p>

<pre><code>//Use a typedef to make declarations simpler.
typedef byte (&amp;ArrRef)[8]; //A reference to an array which contains 8 elements (type not variable)

ArrRef func(); //A prototype to prevent the IDE adding one above the typedef.

ArrRef func(){

  static byte arr[8];

  //Dynamically generate contents of array in arr.

  //Return the array
  return arr;
}

//The equivalent to the non-template version, just using a typedef instead.
void WriteBytes( ArrRef arr ); //Prototype.

void WriteBytes( ArrRef arr ){

    for (int i = 0; i &lt; 8; ++i){
        //lc.setRow(0, i, arr[i]);
    }
}

void setup() {

  //Reference the array returned:
  ArrRef ref = func();

  //Use array
  for( byte el : ref ){

    //...
  }

  //Pass to function
  WriteBytes(ref);
}

void loop() {}
</code></pre>

<p>I have written a far more in depth <a href=""http://arduino.land/FAQ/content/6/32/en/passing-arrays-to-functions.html"" rel=""nofollow"">article here</a>, which covers the basics of passing arrays to functions using pointers and references to arrays. </p>
",,41811577,102
34582497,2,34570304,2016-01-03T22:43:58.343,0,,4561887,,2020-04-29T20:47:05.687,2020-04-29T20:47:05.687,0,,"<h2>My Answer:</h2>

<p>Sorry for the trouble, it turns out I was misusing the EEPROM.get function, and the problem wasn't my macro at all. The EEPROM library <code>get()</code> method is defined: <a href=""https://github.com/arduino/ArduinoCore-avr/blob/master/libraries/EEPROM/src/EEPROM.h#L130"" rel=""nofollow noreferrer"">https://github.com/arduino/ArduinoCore-avr/blob/master/libraries/EEPROM/src/EEPROM.h#L130</a>, and the documentation here: <a href=""https://www.arduino.cc/en/Reference/EEPROMGet"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Reference/EEPROMGet</a>.  </p>

<p>I was simply missing the 2nd argument, accidentally using this:</p>

<pre><code>EEPROM.get(address);
</code></pre>

<p>...instead of this:</p>

<pre><code>any_type val_in_EEPROM;
EEPROM.get(address, val_in_EEPROM);
</code></pre>

<hr>

<p>Here are 2 solutions I came up with that work.  </p>

<h2>1) Using a separate function:</h2>

<p>-I prefer this method. It turns out the word ""inline"" in this case is optional, and makes no difference.<br>
-This method makes my program 7610 bytes, with 472 bytes used for global variables. It takes 162 bytes less memory than option 2 below.</p>

<pre><code>inline void updateEEPROMVal(uint16_t address, uint16_t val)
{
  uint16_t val_in_EEPROM;
  EEPROM.get(address,val_in_EEPROM);
  if (val_in_EEPROM!=val)
    EEPROM.put(address,val);
}

void storeGlobalXYValsIntoEEPROM()
{
  updateEEPROMVal(0,x_low);
  updateEEPROMVal(2,x_ctr);
  updateEEPROMVal(4,x_high);
  updateEEPROMVal(6,y_low);
  updateEEPROMVal(8,y_ctr);
  updateEEPROMVal(10,y_high);
}
</code></pre>

<h2>2) Using a macro, as follows:</h2>

<p>-I prefer the above method.<br>
-This method takes 7772 bytes for program space, and 472 bytes for global variables. It takes 162 bytes more than the above method.</p>

<pre><code>uint16_t val_in_EEPROM;    
#define updateEEPROMVal(address,val)  EEPROM.get(address,val_in_EEPROM); \
                                      if (val_in_EEPROM!=val)            \
                                        EEPROM.put(address,val)
void storeGlobalXYValsIntoEEPROM()
{
  uint16_t val_in_EEPROM;

  updateEEPROMVal(0,x_low);
  updateEEPROMVal(2,x_ctr);
  updateEEPROMVal(4,x_high);
  updateEEPROMVal(6,y_low);
  updateEEPROMVal(8,y_ctr);
  updateEEPROMVal(10,y_high);
}
</code></pre>

<p>Thanks for everyone's help!  </p>

<h2>3) (Updated answer) <code>EEPROM.put(address,val)</code> already does the functionality I'm trying to achieve above to avoid unnecessary wear on the EEPROM, so just use the <code>.put()</code> function by itself, as-is!</h2>

<p>See <a href=""https://stackoverflow.com/questions/34570304/how-to-format-if-statement-in-c-macro-how-to-use-arduinos-new-eeprom-lib/34575140#34575140"">@Chris A's answer here</a>.</p>

<p>Yet again I have failed to fully read the documentation. The EEPROM library Put function documentation here (<a href=""https://github.com/arduino/Arduino/tree/master/hardware/arduino/avr/libraries/EEPROM"" rel=""nofollow noreferrer"">https://github.com/arduino/Arduino/tree/master/hardware/arduino/avr/libraries/EEPROM</a>) says, ""This function uses the update method to write its data, and therefore only rewrites changed cells."" Therefore, my update code is redundant. I just need to use the ""put"" function as-is. Refer to the EEPROM library's author's (Chris A) answer here too. </p>

<p><strong>So, I've learned a lot, and here's my final answer:</strong></p>

<h3>Get rid of my support function <em>and</em> macro, and just use the put function as-is. It already minimizes EEPROM wear and only writes if the contents are different. Nevertheless, I'll leave my above answers for completeness' sake for those who are looking for what the macro or function solution otherwise would have been.</h3>
",,41816834,51
34580282,2,34579873,2016-01-03T18:52:28.650,0,,5740956,,2016-01-03T19:03:15.770,2016-01-03T19:03:15.770,0,,"<p>I would do something like this:</p>

<pre><code>void loop() {

if (not yet displayed) {
[all the code to display the number on leds]
}

if (button pressed) { 
allowTimer = true;  // Start!
}

if (allowTimer) /* If timer started */ {
   while (millis() - previousMillis &lt;= 2000) /* The famous 2 sec */ {

      if (button pressed) {
      previousMillis = millis(); /* Update timing */
      teller++;
      }
   }
   if(teller == randomNumber) {
   [Hooray, you won or whatever message and stuff you like]
   }
   else {
   [Sorry, you lost]
   }

}
</code></pre>

<p>Of course you should replace my writings with your code.</p>

<p>TIP: For a single instruction in any statement you don't need parentheses:</p>

<pre><code>if (condition) {
onlyOneInstruction;
}
</code></pre>

<p>is the same as </p>

<pre><code>if (condition) onlyOneInstruction;
</code></pre>

<p>EDIT: Also, you try to compare <code>knopStatus</code> (undeclared, maybe you meant <code>buttonStatus</code>) with <code>lastButtonStatus</code>, which isn't initialised. This gives you an error.</p>
",,41853306,1424
34597599,2,34597189,2016-01-04T18:36:37.617,3,,2883245,,2016-01-04T18:44:33.587,2020-06-20T09:12:55.060,9,,"<h1>Difference between pass-by-value and pass-by-reference:</h1>
<p>Pass-by-value:</p>
<pre><code>void foo(int a) {
  a = 30; // passed in param is now 30 until end of scope
}

int main() {
  int b = 3;
  foo(b); // copy of b is made, copy is assigned value 30
  // b is still 3
}
</code></pre>
<p>Pass-by-reference:</p>
<pre><code>void foo(int&amp; a) {
  a = 30; // passed in param is now 30 because a reference was passed in
}

int main() {
  int b = 3;
  foo(b); // reference to b is assigned value 30
  // b is now 30
}
</code></pre>
<p>Passing a pointer is <em>similar</em> to pass-by-reference, with some differences <a href=""https://stackoverflow.com/questions/8571078/pass-by-pointer-pass-by-reference"">outlined here</a>.</p>
<p>The code you've written for <code>testVal</code> will perform manipulations <em>on a copy</em> of <code>kd</code>. This is not what you want.</p>
<p>For small structs, the <strong>speed</strong> of pass-by-value and pass-by-reference will be similar. <em>However</em>, the memory footprint will be very different. Passing-by-value will make copies each time something is passed, which will take a lot of memory.</p>
<h1>As for why it's faster:</h1>
<p><a href=""https://stackoverflow.com/questions/2448501/does-the-compiler-optimize-the-function-parameters-passed-by-value"">There are likely optimizations</a> because copies are being made instead of actual changes to the passed-in object that the compiler is making for you. This is done, however, at the cost of an <strong>incorrect algorithm</strong>.</p>
<p>After passing-by-values, the changes will not be reflected in <code>kd</code> that is passed in. The pointers' changes will be reflected and will be correct.</p>
",,41855327,90
34598101,2,34597189,2016-01-04T19:08:49.687,5,,5089383,,2016-01-04T19:12:44.760,2016-01-04T19:12:44.760,3,,"<p>This part of your code does absolutely nothing and the optimizer recognizes that:</p>

<pre><code>inline void Display::paintOnKitVal(KitData kd){
    for(int i = 0 ; i &lt; 100 ; i++){
        kd.yDataIdx++;
        kd.yOnScreenIdx++;
    }
}
</code></pre>

<p>You imagine you tested the performance of pass by value.  But you really tested the ability of the compiler to recognize the fact that the code does nothing.</p>

<p>When you pass by pointer (what a C programmers might call ""by reference"" but a C++ programmer would not ""by reference) the function alone cannot be said to do nothing.  An optimizer would need to take a wider understanding of the whole program to detect lack of effect.</p>
",,41858929,1005
34631426,2,34631256,2016-01-06T10:58:09.573,2,,1426626,,2016-01-06T10:58:09.573,,0,,"<p>you can always try to write a small structure like this:</p>

<pre><code>struct
{
uint32_t Signature;
uint32_t HighScore;
}EEPROMData;
</code></pre>

<p>you set signature to a known hardcoded value, set the highscore, and write the entire structure. On read, you would check the signature. It's highly unlikely it would be your value. </p>

<p>If you need even more insurance it's not just random data, you can do this:</p>

<pre><code>struct
{
uint32_t Signature;
uint32_t HighScore;
uint32_t XORRResult;
}EEPROMData;
</code></pre>

<p>and also write the XOR result between signature and highscore. when you read it, you'd compare the xor from signature and highscore with XORResult. If it matches, then you wrote that data, wasn't random.</p>
",,41864374,153
34672860,2,34672254,2016-01-08T08:51:22.920,0,,4557901,,2016-01-08T08:51:22.920,,0,,"<p>Working version is </p>

<pre><code>void debouncedAction(bool (* condition)(), void (* action)()) {
    if(condition()) {
        HAL_Delay(DEBOUNCE_TIME);
        if(condition()) {
            while(condition()) {
            }
            action();
        }
    }
}
</code></pre>

<p>or </p>

<pre><code>void debouncedAction(bool (* condition)(), void (* action)()) {
    if(!condition()) {
        return;
    }
    HAL_Delay(DEBOUNCE_TIME);
    if(!condition()) {
        return;
    }
    while(condition()) {
    }
    action();
}
</code></pre>
",,41868245,66
34681351,2,34681286,2016-01-08T16:10:23.173,7,,2642204,,2016-01-08T16:25:15.627,2017-05-23T12:04:06.037,10,,"<p><code>loop</code> must be declared as <code>virtual</code>:</p>

<pre><code>class Plugin {

// ...

virtual void loop();
</code></pre>

<p>Also, for the polymorphism to work, you need a pointer or a reference:</p>

<pre><code>Plugin* o = new OneWirePlugin(ONEWIRE_PIN);
o-&gt;loop();

// ...

delete o;
</code></pre>

<p><sup>(in your code, <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">slicing</a> occurs, as noted by <a href=""https://stackoverflow.com/users/635608/mat"">Mat</a> in the comments section)</sup></p>

<p>And then, consider using smart pointers (like <code>unique_ptr</code> or <code>shared_ptr</code>).</p>

<hr>

<p>If you're using C++11 you should also mark <code>loop</code> with the <code>override</code> specifier in subclasses:</p>

<pre><code>class OneWirePlugin : public Plugin {

// ...

void loop() override { 
</code></pre>
",,41896389,150
34682045,2,34681286,2016-01-08T16:47:57.520,0,,5763524,,2016-01-08T16:47:57.520,,0,,"<p>In your question - 
1. Plugin p = new Plugin();
2. Plugin o = OneWirePlugin(ONEWIRE_PIN);</p>

<ol>
<li>will call Plugin::loop() as it base class object . </li>
<li>will also call Plugin::loop() as you are creating Plugin object and this way object slicing occurs to form base class object from derived class object .</li>
</ol>

<p>Below example will help .</p>

<pre><code>class Base { int x, y; };

class Derived : public Base { int z, w; };

int main() 
{
    Derived d;
    Base b = d; // Object Slicing,  z and w of d are sliced off
}
</code></pre>

<p>Run on IDE
Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.</p>
",,41903047,79
34705024,2,34704778,2016-01-10T11:50:25.247,2,,2877241,,2016-01-10T13:22:39.640,2016-01-10T13:22:39.640,0,,"<p>You placed semicolons after each <code>for</code> loop. As result variable <code>i</code> (and some other variables) declared in the control statements of the loops is not alive outside these statements. For example</p>

<pre><code>void setup(){

    for (int i=0 ; i ;) ;      
                       ^^^
    pinMode( led_pins[i], OUTPUT ) ;
                     ^^^???
    //...
</code></pre>

<p>or</p>

<pre><code>void loop(){
    // need to keep track of button presses
    // so set the button state to 0 and overwrite
    // later upon button press
    boolean button_state = OFF ;

    // sequentially turn on each LED
    for ( int i=0 ; i        digitalWrite( led_pins[i], HIGH ) ;
                                                              ^^^
        // Check for a button press every 5 milliseconds
        for ( int t=0 ; t            button_state = digitalRead( button_pin ) ;
                                                                             ^^^
        //...
</code></pre>
",,41905648,160
34724288,2,34716017,2016-01-11T14:47:50.603,1,,5708620,,2016-01-11T16:48:59.683,2016-01-11T16:48:59.683,6,,"<p>You can store the pin states in a <code>byte array</code> like this:</p>

<pre><code>#define NUM_DIGIT_VALUES 11

// Segments:
// ..a..
// f   b
// . g .
// e   c
// ..d.. dot

static const byte digits[NUM_DIGIT_VALUES] = {
    // dot-abcdefg
    0b01111110, // = 0
    0b00110000, // = 1
    0b01101101, // = 2
    0b01111001, // = 3
    0b00110011, // = 4
    0b01011011, // = 5
    0b01011111, // = 6
    0b01110000, // = 7
    0b01111111, // = 8
    0b01111011, // = 9
    0b01001001  // = overflow
};
</code></pre>

<p>Then create an <code>array</code> with the corresponding pin numbers:</p>

<pre><code>byte PinLayout[] = {6,7,8,9,10,11,12,13};
</code></pre>

<p>Create some helper functions to display the digits:</p>

<pre><code>void SetByte(byte digit_bits) {

    // each bit in digit_bits = segment On/Off
    byte cur_pos = 1 &lt;&lt; 7;

    for (byte seg_num = 0; seg_num &lt; 8; ++seg_num) {
        digitalWrite(PinLayout[seg_num], digit_bits &amp; cur_pos);
        // In your case you may need:
        // digitalWrite(PinLayout[seg_num], (digit_bits &amp; cur_pos) ? LOW : HIGH);
        cur_pos &gt;&gt;= 1;
    }
}

// set value from 0-9 -- &gt; 10 shows 'overflow value'
void SetValue(byte value) {

    if(value &gt;= NUM_DIGIT_VALUES)
         value = NUM_DIGIT_VALUES - 1;

    SetByte(digits[value]);
}
</code></pre>

<p>Use as:</p>

<pre><code>SetValue(8);
</code></pre>

<p><strong>Note</strong>:</p>

<p>On a bigger MCU, we would normally write the full <code>digit byte</code> directly to an 8-bit <code>PORT</code>, unfortunately that is not an option on Arduino (Uno).</p>
",,41923609,484
34738617,2,34738446,2016-01-12T08:20:58.880,1,,404970,,2016-01-12T08:35:06.320,2016-01-12T08:35:06.320,0,,"<p>You're not accessing the array directly, this works exactly like if you had passed the element to a function:</p>

<pre><code>void readInput(ControlPin control)
{
     control.previousValue = analogRead(control.pin);   
}

void readControlInput(int channel, int multiplexer) {
    readInput(controls[channel][multiplexer]);
}
</code></pre>

<p>You can tell from the types - <code>ControlPin</code> means the same thing regardless of whether it is a local variable or a parameter.</p>

<p>In C++, variables that contain class instances always contain class instances and not some kind of ""reference"" to them, so just like when calling a function,</p>

<pre><code>ControlPin control = controls[channel][multiplexer];
</code></pre>

<p>creates a <em>copy</em> of the array element, and</p>

<pre><code>control.previousValue = analogRead(control.pin);
</code></pre>

<p>modifies that copy.</p>

<p>The simplest fix is to write it in one line:</p>

<pre><code>controls[channel][multiplexer].previousValue = analogRead(control.pin);
</code></pre>

<p>You can also use a reference variable (which is different from Java's ""references"") to refer to the array element itself:</p>

<pre><code>ControlPin&amp; control = controls[channel][multiplexer];
control.previousValue = analogRead(control.pin);
</code></pre>

<p>This is most useful if you need to do more than one thing with the same element - it's both more readable and more resilient to errors than duplicating the indexing.</p>
",,41925515,7369
34740944,2,34738835,2016-01-12T10:18:57.640,2,,3368201,,2016-01-12T10:18:57.640,,9,,"<p>As I already told you in the other thread, the easiest and fastest way to do this is to deal with PORTS rather than individual pins.</p>

<p>For example, on the arduino UNO pins 0..7 map to port D pins 0..7, so when you do something like</p>

<pre><code>uint8_t the_value_i_want = 0b01001000;
PORTD = the_value_i_want;
</code></pre>

<p>you write the pins 0..7 in a single instruction. Now, again with the uno, the complete mapping is</p>

<ul>
<li>PORTD maps to Arduino digital pins 0 to 7</li>
<li>PORTB maps to Arduino digital pins 8 to 13. The two high bits (6 &amp; 7) map to the crystal pins and are not usable</li>
<li>PORTC maps to Arduino analog pins 0 to 5. Bit 6 is the reset pin, so it's not usable, while bit 7 does not exist.</li>
</ul>

<p>So things are a bit more complicated for the other ports. Well, the easiest way to handle this is making a function to mask the relevant bits. Just note that the masking is the same for port B and C, but this is just a coincidence.</p>

<pre><code>#define PORT_B_C_MASK = 0x3F;
void write_with_mask(volatile uint8_t *p_register, uint8_t mask, uint8_t value)
{
    *register = (*register | (value &amp; mask)) &amp; (value | ~mask);
}
</code></pre>

<p>Now you can write easily the instructions to write the value you want on the port. For instance, if you want to turn on pins 3, 6, 8 and 10, you just have to provide two values (one for port D, i.e pins 0..7, and one for port B, pins 8..13):</p>

<pre><code>uint8_t the_value_i_want_8_13 = 0b000101;
uint8_t the_value_i_want_0_7 = 0b01001000;

write_with_mask(&amp;PORTB,PORT_B_C_MASK,the_value_i_want_8_13);
PORTD = the_value_i_want_0_7;
</code></pre>

<p>Now, if you want to make a const matrix with all the possible values (again, this applies for the UNO only), you can just make a three-columns uint8_t matrix. Something like</p>

<pre><code>int allvalues[][3] = { {0b001000, 0b001010, 0b00000001},
                    ...};
</code></pre>

<p>In this case, with the first configuration (the reported one) pins A3, 0, 9, 11 will be turned on, the others will be off.</p>

<p>A possible function to apply this is</p>

<pre><code>void apply_configuration(uint8_t index)
{
    write_with_mask(&amp;PORTC,PORT_B_C_MASK,allvalues[index][0]);
    write_with_mask(&amp;PORTB,PORT_B_C_MASK,allvalues[index][1]);
    PORTD = allvalues[index][2];
}
</code></pre>

<p>This way you just have to provide the index for the configuration (the row) you want to apply.</p>

<p>If, for some reasons, you want to exclude some pins (e.g. pin 0 and 1, since they are the serial interface) you just have to include it in the mask. For instance:</p>

<pre><code>#define PORT_B_MASK = 0x3F;
#define PORT_C_MASK = 0x0F;
#define PORT_D_MASK = 0xFC;
void apply_configuration(uint8_t index)
{
    write_with_mask(&amp;PORTC,PORT_C_MASK,allvalues[index][0]);
    write_with_mask(&amp;PORTB,PORT_B_MASK,allvalues[index][1]);
    write_with_mask(&amp;PORTD,PORT_D_MASK,allvalues[index][2]);
}
</code></pre>

<p>This way I excluded pins 0 and 1 (serial interface) and pins A4 and A5 (I2C interface).</p>

<p>Just one remark: I used the UNO as example, but you can use any board. Just look at the pin mapping to understand what is the association between ports and arduino pins.</p>
",,41926178,1002
34770421,2,34770031,2016-01-13T15:22:22.357,1,,5708620,,2016-01-13T15:48:24.780,2016-01-13T15:48:24.780,3,,"<p>There are several problems in the code:</p>

<ul>
<li><p>First, it would be better to declare <code>result</code> outside the function:</p>

<pre><code>static char result[MAX_CONCAT_LEN] = {0};
</code></pre></li>
<li><p>Declare the function with a default value for <code>str4</code>:</p>

<pre><code>const char *concat_strings(const char *str1, const char *str2, const char *str3,const char *str4 = NULL);
</code></pre></li>
<li><p>Don't compare <code>char*</code> with <code>TRUE</code>, use <code>NULL</code> instead:</p>

<pre><code>if (str4 != NULL){
</code></pre></li>
<li><p>Between <code>PREF</code>, <code>str1</code> and <code>str2</code>, there is no code to add the seperator:</p>

<pre><code>while(*PREF &amp;&amp; i &lt; MAX_CONCAT_LEN)
  {result[i++] = *PREF++;}
// loop until end of string 1 has reached or destination buffer is full
while(*str1 &amp;&amp; i &lt; MAX_CONCAT_LEN)
  {result[i++] = *str1++;}
// loop until end of string 2 has reached or destination buffer is full
while(*str2 &amp;&amp; i &lt; MAX_CONCAT_LEN)
  {result[i++] = *str2++;}
</code></pre></li>
<li><p>In <code>str4</code>, <code>slash</code> is pointing to the end of the string due to:</p>

<pre><code>  while(*slash &amp;&amp; i &lt; MAX_CONCAT_LEN)
    {result[i++] = *slash++;}
</code></pre>

<p>in the previous loop. (you normally don't need a loop here, unless the seperator could be more than one character in the future)</p></li>
<li><p><code>len</code> isn't adjusted when <code>str4</code> is present:</p>

<pre><code>size_t len = strlen(PREF)+strlen(str1)+strlen(str2)+strlen(str3);

result[len+1] = 0;
</code></pre>

<p>which cuts off <code>str4</code> anyway.</p></li>
</ul>

<p>When possible, it would be better to use the <a href=""https://www.arduino.cc/en/Reference/StringObject"" rel=""nofollow""><code>String</code> class</a>, or <a href=""http://www.cplusplus.com/reference/cstring/strcat/"" rel=""nofollow""><code>strcat()</code></a>.</p>

<p>For some examples of string concatenation with the Arduino <code>String</code> class, see <a href=""https://www.arduino.cc/en/Tutorial/StringAdditionOperator"" rel=""nofollow"">here</a>, <a href=""https://www.arduino.cc/en/Tutorial/StringAppendOperator"" rel=""nofollow"">here</a> and <a href=""https://www.arduino.cc/en/Tutorial/StringConstructors"" rel=""nofollow"">here</a>.</p>

<pre><code> // adding a constant integer to a string:
  stringThree = stringOne + 123;

  // adding a constant long interger to a string:
  stringThree = stringOne + 123456789;

  // adding a constant character to a string:
  stringThree = stringOne + 'A';

  // adding a constant string to a string:
  stringThree = stringOne +  ""abc"";

  // adding two Strings together:
  stringThree = stringOne + stringTwo;
</code></pre>
",,41940235,509
34771350,2,34770031,2016-01-13T16:02:07.040,1,,3765091,,2016-01-13T16:02:07.040,,1,,"<p>I assume you are hell-bent on sticking with C functionality and <code>const char*</code> strings. There are a couple more useful C string functions like <code>strlen</code> and <code>strcopy</code>. As you will notice from the C API, when dealing with raw <code>char*</code> strings, it is standard practice to issue a buffer into which the function should write its results, so it is clear whose responsibility it is to clean the string up (in that case: the caller's!). Therefore, you can do the following (tested <a href=""http://cpp.sh/8d3s"" rel=""nofollow"">here</a>):</p>

<pre><code>// Example program
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;

bool strconcat(char* result, unsigned int bufsize, const char* s1, const char* s2, const char* s3, const char* s4) {
    const char* strings[4] = {s1, s2, s3, s4};
    for(unsigned char i = 0; i &lt; 4; ++i) {
        const char* s = strings[i];
        if(!s)
            return true;
        unsigned int len = strlen(s);
        if(len &gt; bufsize)
            return false;
        strcpy(result, s);
        bufsize -= len * sizeof(char);
        result += len * sizeof(char);
        if(i &lt; 3 &amp;&amp; strings[i+1]) {
            if(bufsize &gt; 0) {
                result[0] = '/';
                --bufsize;
                ++result;
            }
            else
                return false;
        }
    }
    return true;
}

int main()
{
  char result[80] = {0};
  const char* a = ""ab"";
  const char* b = ""xyziuehfih"";
  const char* c = ""ihihfeih"";
  strconcat(result, 80, a, a, b, 0);
  std::cout &lt;&lt; result &lt;&lt; ""\n"";
}
</code></pre>
",,41990020,970
41769249,2,34776524,2017-01-20T17:27:48.913,0,,4932683,,2017-01-20T17:27:48.913,,0,,"<p>There is a working example <a href=""https://github.com/cyberponk/PWM_Signal_Analyzer_for_Arduino/blob/master/PWM_Signal_Analyzer_for_Arduino.ino"" rel=""nofollow noreferrer"">here</a>.
It uses native ISR functions (faster) instead of arduino interrupt handlers.
Uses Timer1 for best resolution and precision.</p>

<p>The code is big but the part that interests you is:</p>

<blockquote>
<pre><code>The ""// Setup Timer1 for precise timing"" portion of void setup()

ISR(TIMER1_OVF_vect) -&gt; for timer1 overflow counter

ISR(INT0_vect) // External Interrupt pin 2 [D2]

void PulseCaptureScheduler_callback()  // Starts a capture and flags a timeout

void PrintInfoScheduler_callback() // Processes the results
</code></pre>
</blockquote>
",,42024190,284
34783046,2,34782709,2016-01-14T06:31:28.053,2,,5787917,,2016-01-14T06:31:28.053,,0,,"<p>My guess would be that the String class resizes each time a text is appended, that could be improved.
Assuming you know the input size and it´s constant, you could try this:</p>

<pre><code>char outbuffer[numBytes*2+1];   
const char* pHexTable=""0123456789ABCDEF"";
int iPos=0;

for(int i=0; i&lt;numBytes; i++){
    //assume buffer contains some binary data at this point
    const char cHex=buffer[i];
    outbuffer[iPos++]=pHexTable[(cHex&gt;&gt;4)&amp;0x0f];
    outbuffer[iPos++]=pHexTable[cHex&amp;0x0f];
}
outbuffer[iPos]='\0';
</code></pre>
",,42038243,2014
34783144,2,34782709,2016-01-14T06:38:10.220,1,,5781248,,2016-01-14T06:38:10.220,,1,,"<p>There is stringstream class available in C++, it may be usable in this case. With C three bytes would be printed to a buffer with one sprintf-statement <code>sprintf(buffer, ""%02x%02x%02x"", bytes[0], bytes[1], bytes[2])</code> (preferably <code>snprintf</code>).</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main(void)
{
    std::stringstream ss;
    unsigned char bytes[] = {0xff, 0x00, 0xcc};

    ss &lt;&lt; std::hex;

    // This did not work, 00 was printed as 0
    // ss &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2)
    // ...
    // ss &lt;&lt; (unsigned int)bytes[i]

    for (int i=0; i&lt;3; i++) {
       unsigned int tmp = bytes[i];
       ss &lt;&lt; (tmp &gt;&gt; 4) &lt;&lt; (tmp &amp; 0xf);
    }
    std::cout &lt;&lt; ss.str();

    return 0;
}
</code></pre>
",,42049969,58
34783244,2,34782709,2016-01-14T06:45:36.747,1,,4460500,,2016-01-14T06:45:36.747,,0,,"<p>As understand <code>numBytes</code> can be bigger than 3 or 4 (otherwise why buffer size is 100?)
Also I prefer to use C++ classes when working with <code>string</code> (you need <code>string</code>, not <code>char[]</code>?).</p>

<p>Consider the following example with <code>stringstream</code> class (just include <code>sstream</code> and <code>iomanip</code> standard headers):</p>

<pre class=""lang-cpp prettyprint-override""><code>    string myString;
    stringstream myStringStream;
    myStringStream &lt;&lt; setbase(16);
    myStringStream &lt;&lt; uppercase;
    for (int i = 0; i &lt; numBytes; i++)
    {
        myStringStream &lt;&lt; (0xFF &amp; (unsigned int) buffer[i]);
    }
    myString = myStringStream.str();
</code></pre>

<p>I can not compare the speed of my example with other answers, but this solution is really C++ approach for <code>buffer</code> of any size.</p>
",,42079140,268
34812896,2,34812263,2016-01-15T14:10:16.580,0,,1417063,,2016-01-15T14:10:16.580,,0,,"<p>Declare the <strong>A::run</strong> method as <strong>static</strong> .</p>

<p>The following compiles and executes correctly.</p>

<pre><code>typedef unsigned long(*poFunc)();
poFunc T ;

void setupA(poFunc exFunc)
{
    T = exFunc;
}
class A{

    poFunc T ;
    private:
        static  unsigned long run();
    public:
        void start ();

};

unsigned long A::run()
{
    return 9929UL;
}

void A::start ()
{
    setupA(&amp;A::run);
}

int main()
{
    A _a;
    _a.start();

    printf(""END\n"");
}
</code></pre>

<p>Hope this helps out.</p>
",,42151118,5585
34838353,2,34833550,2016-01-17T12:35:06.373,0,,5767763,,2016-01-17T12:35:06.373,,0,,"<p>here we go, the answer !!!!
it is for all SSR with zero crossing function possible to change the speed in 10 steps (you can change it in the script to get up to 100000 :-) steps)</p>

<p>with SimpleTimer:</p>

<pre><code>#include &lt;SimpleTimer.h&gt;

SimpleTimer mot_off;

volatile int i;               // Variable to use as a counter of dimming steps. It is volatile since it is passed between interrupts
int AC_pin = 19;                 // Output to Opto Triac

int mot_speed = 50;                  // in % Speed level (0-100)  0 = off, 100 = full speed
                                //1 Second = 1.000
int freqStep = 20;              // Means 20ms ONE FULL wave. Every 20ms we check if we should switch SSR off to get the right speed
                                //if speed is 50 (50%) we set Pin HIGH every 200ms, but after 5x calling Timer (i=50)Time = 100ms we set PIN low for next 5x calling of timer)
                                //if speed is 10 (10%) we set Pin HIGH every 200ms, but after 1x calling Timer (i=10)Time = 20ms we set PIN low for next 9x calling of timer)

void setup()
{
   Serial.begin(115200);
   pinMode(AC_pin, OUTPUT);   
   mot_off.setInterval(freqStep, off_check);
}

void off_check() {

    if(i&gt;mot_speed) 
    {                     
      digitalWrite(AC_pin, LOW);  // turn off SSR 
//      Serial.println(""OFF"");
//      Serial.println(i);                 
    } 
    else 
    {
      digitalWrite(AC_pin, HIGH);
//      Serial.println(""ON"");
//      Serial.println(i);           
    } 
    i+=10;  
    if (i&gt;100) {i=0;}                                 
}

void loop()
{
  mot_off.run();
}
</code></pre>

<p>and with TimerOne:</p>

<pre><code>#include &lt;TimerOne.h&gt;           // Avaiable from http://www.arduino.cc/playground/Code/Timer1

volatile int i;               // Variable to use as a counter of dimming steps. It is volatile since it is passed between interrupts
int AC_pin = 19;              // Output to Opto Triac

int mot_speed = 50;           // in % Speed level (0-100)  0 = off, 100 = full speed

                                  //1 Second = 1.000.000
int freqStep = 20000;             // Means 20ms ONE FULL wave. Every 20ms we check if we should switch SSR off to get the right speed
                                  //if speed is 50 (50%) we set Pin HIGH every 200ms, but after 5x calling Timer (i=50)Time = 100ms we set PIN low for next 5x calling of timer)
                                  //if speed is 10 (10%) we set Pin HIGH every 200ms, but after 1x calling Timer (i=10)Time = 20ms we set PIN low for next 9x calling of timer)



void setup() {  // Begin setup
  Serial.begin(115200);   
  pinMode(AC_pin, OUTPUT);                          // Set the Triac pin as output
  Timer1.initialize(freqStep);                      // Initialize TimerOne library for the freq we need
  Timer1.attachInterrupt(off_check, freqStep);      // 
  // Use the TimerOne Library to attach an interrupt
}

void off_check() {

    if(i&gt;mot_speed) 
    {                     
      digitalWrite(AC_pin, LOW);  // turn off SSR 
//      Serial.println(""OFF"");
//      Serial.println(i);                 
    } 
    else 
    {
      digitalWrite(AC_pin, HIGH);
//      Serial.println(""ON"");
//      Serial.println(i);           
    } 
    i+=5;  
    if (i&gt;100) {i=0;}

}

void loop() 
{  

}
</code></pre>
",,42173716,663
34861508,2,34861462,2016-01-18T18:22:46.477,1,,4253229,,2016-01-18T18:22:46.477,,12,,"<p>The expression <code>0x80 | OUT_X_L_G</code> is returning a value of <code>OUT_X_L_G</code> with a bit number <code>7</code> set:</p>

<pre><code>OUT_X_L_G = xxxx xxxx
  bitwise or
0x80      = 1000 0000
---------------------
result    = 1xxx xxxx
</code></pre>

<p>The logic behind the whole function call should be determined by the context you are not providing.</p>
",,42180378,1169
34917678,2,34917638,2016-01-21T07:24:25.620,5,,1275169,,2016-01-21T07:24:25.620,,0,,"<p>You need to use <a href=""http://man7.org/linux/man-pages/man3/strcmp.3.html""><code>strcmp()</code></a> to compare C-strings. What you do is pointer comparison.</p>

<pre><code>if ( strcmp(frontOrBack, ""front"") == 0 ) {
   digitalWrite(frontEyes, LOW);}//end if   
  else if ( strcmp(frontOrBack, ""back"") == 0 ) {
    digitalWrite(backEyes, LOW);}//end else*/
}  
</code></pre>

<p>In this comparison,</p>

<pre><code>if (frontOrBack == ""front"") {
</code></pre>

<p>the pointer value <code>frontOrBack</code> is compared with the address of the string literal <code>""front""</code> (in an expression, a string literal gets converted to a pointer to its first element).</p>
",,42197185,92
34946053,2,34945811,2016-01-22T11:48:56.953,3,,126769,,2016-01-22T14:17:16.217,2016-01-22T14:17:16.217,3,,"<p>WiringPi sets up a separate thread and calls your isr function from that thread.</p>

<p>You can then use a pthread condition variable to block another thread, main() in this case,  and have the isr function wake it up when an interrupt occurs.</p>

<pre><code>#include &lt;pthread.h&gt;

pthread_cond_t isr_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t isr_mtx = PTHREAD_MUTEX_INITIALIZER;
unsigned int isr_count = 0;

void myInterrupt(void)
{
    pthread_mutex_lock(&amp;isr_mtx);
    isr_count++;
    pthread_cond_signal(&amp;isr_cond);    
    pthread_mutex_unlock(&amp;isr_mtx);

}

int main() 
{
    // register interrupt
    wiringPiISR( 18, INT_EDGE_BOTH, &amp;myInterrupt );

    for (;;) {
       pthread_mutex_lock(&amp;isr_mtx);
       while (isr_count == 0) {
          pthread_cond_wait(&amp;isr_cond, &amp;isr_mtx);
       }
       //add logic here to handle the ISR, isr_count
       //tells you how many ISRs occured.
       //heavy work should be moved outside the mutex.

      isr_count = 0;
      pthread_mutex_unlock(&amp;isr_mtx);
    }

    return 0;
}
</code></pre>

<p>You need to compile and link your code with the <code>-pthread</code> flag.</p>
",,42301711,2186
34946422,2,34945811,2016-01-22T12:11:16.303,3,,5413478,,2016-01-26T12:25:17.547,2016-01-26T12:25:17.547,2,,"<p>I recently had to do exactly this. My theory was <a href=""https://en.wikipedia.org/wiki/KISS_principle"" rel=""nofollow"">KISS</a>. <code>sleep</code> is written to use minimal resources by definition - and using it means I don't have to care about threads.</p>

<p>Simple, readable and no measurable performance hit on an original Raspberry Pi B:</p>

<pre><code>int main() 
{
    // register interrupt
    wiringPiISR( 18, INT_EDGE_BOTH, &amp;myInterrupt );

    for (;;) {
        sleep(UINT_MAX);
    }
    return 0;
}
</code></pre>

<p>Note the use of UINT_MAX to minimise number of for loop calls - this assumes an unsigned 32-bit timer delay, which is what WiringPi uses.</p>
",,42314723,54
34947390,2,34945811,2016-01-22T13:03:08.517,2,,4756299,,2016-01-22T13:03:08.517,,0,,"<p>You can also use a <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"" rel=""nofollow"">semaphore</a>.  <code>sem_post()</code> <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html"" rel=""nofollow"">must be async-signal-safe</a>:</p>

<pre><code>#include &lt;semaphore.h&gt;

static sem_t staticSem;

void myInterupt( void )
{
    sem_post( &amp;staticSem );
}

int main() 
{
    sem_init( &amp;staticSem, 0, 0 );

    // register interrupt
    wiringPiISR( 18, INT_EDGE_BOTH, &amp;myInterrupt );

    for (;;) {
        sem_wait( &amp;staticSem );
        ...
    }
    return 0;
}
</code></pre>

<p>Error checking and handling potential spurious wakeups from <code>sem_wait()</code> aren't included.</p>
",,42333338,475
34948605,2,34945811,2016-01-22T14:05:36.010,0,,1145760,,2016-01-22T14:05:36.010,,1,,"<p>I would (and <a href=""https://github.com/MiroslavVitkov/micli/blob/e9ae7d35ed53c61715323e8e19f30323476cda93/src/zcd.c#L155"" rel=""nofollow"">do</a>, when coding embedded) rather use a spinlock <code>while(1) ;</code>. It is straightforward and expresses intent - never go past this point. </p>

<p>Not only does sleep have an expiration time, which might not be a problem right away, but become a problem after years. It also has to perform some computations to actually count the time.</p>

<p>Here is a comparison between <code>sleep(0xFFFFFFFF);</code> on a Intel Core i3-4330TE:</p>

<pre><code>        .file   ""test.c""
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $-1, %edi
        movl    $0, %eax
        call    sleep
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  ""GCC: (Debian 4.9.2-10) 4.9.2""
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>and a <code>while(1);</code> approach:</p>

<pre><code>        .file   ""test.c""
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
.L2:
        jmp     .L2
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  ""GCC: (Debian 4.9.2-10) 4.9.2""
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>So less work is done if time is not kept track of. I am not sure if the linux scheduler can recognise this pattern until an ISR arrives.</p>

<hr>

<p>Having said this, the proper way to ""keep the program running, using minimal resources"" is to look into <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.ddi0464d/DDI0464D_cortex_a7_mpcore_r0p3_trm.pdf"" rel=""nofollow"">the sleep modes (page 2-14 or 36)</a>, that the processor provides.</p>
",,42336734,586
35024024,2,35015264,2016-01-26T21:11:00.773,3,,618352,,2016-01-27T19:15:33.933,2016-01-27T19:15:33.933,5,,"<p>Here is an example using plain C (gcc):</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


typedef uint8_t byte;

void print_bin(byte x) {
    printf(""B"");
    for (int i = 0; i &lt; 8; i++) {
        printf(""%s"", (x &gt;&gt; (7-i)) % 2 ? ""1"" : ""0"");
    }
    printf(""\n"");
}

void reverse(byte* in, byte* out, int width, int height) {
    int width_bytes = (width + 7) / 8;
    int height_bytes = (height + 7) / 8;
    // init *out. You can skip the next line if you are sure that *out is clear.
    memset (out, 0, width * height_bytes);
    for (int y = 0; y &lt; height; y++) {
        for (int x = 0; x &lt; width; x++) {
            if (in[(y * width_bytes + x / 8)] &amp; (1 &lt;&lt; (7 - x % 8))) {
                out[(x * height_bytes + y / 8)] |= (1 &lt;&lt; (7 - y % 8));
            }
        }
    }
}

#define WIDTH  13
#define HEIGHT  4
#define IN_SIZE  (((WIDTH + 7) / 8) * HEIGHT)
#define OUT_SIZE (((HEIGHT + 7) / 8) * WIDTH)

int main() {
    byte in[IN_SIZE] = {
        0b00111100, 0b01001000,
        0b00100100, 0b01010000,
        0b00111100, 0b01110000,
        0b00100100, 0b01001000
    };

    byte* out = calloc(OUT_SIZE, 1);
    reverse (in, out, WIDTH, HEIGHT);
    for (int i = 0; i &lt; OUT_SIZE; i++) {
        print_bin(out[i]);
    }

}
</code></pre>

<p>And this is the result:</p>

<pre class=""lang-none prettyprint-override""><code>B00000000
B00000000
B11110000
B10100000
B10100000
B11110000
B00000000
B00000000
B00000000
B11110000
B00100000
B01100000
B10010000
</code></pre>

<p>If speed is an issue, you can do the following optimisation:</p>

<pre class=""lang-c prettyprint-override""><code>void reverse(byte* in, byte* out, int width, int height) {
    int width_bytes = (width + 7) / 8;
    int height_bytes = (height + 7) / 8;
    // init *out. You can skip the next line if you are sure that *out is clear.
    memset (out, 0, width * height_bytes);
    for (int y = 0; y &lt; height; y++) {
        for (int x = 0; x &lt; width; x++) {
            int t; // optimisation
            if ((x % 8) == 0) t = in[(y * width_bytes + x / 8)];
            if (t &amp; (1 &lt;&lt; (7 - x % 8))) {
                out[(x * height_bytes + y / 8)] |= (1 &lt;&lt; (7 - y % 8));
            }
        }
    }
}
</code></pre>
",,42370554,233
35058146,2,35043482,2016-01-28T09:56:03.707,2,,4050262,,2016-01-28T09:56:03.707,,0,,"<p>You are initializing the UART in the main and that could be ok, but you are not catching the way HAL libraries want you to initialize the peripheral's pin.
You should do that in the HAL_UART_MspInit() function you can find in stm32f4_hal_msp.c file.</p>

<p>Your main should look like this</p>

<pre><code>HAL_Init(); // HAL Init

configure_system_clock(); // Configure Clock

huart2.Instance = USART2;
huart2.Init.BaudRate = 9600;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
HAL_UART_Init(&amp;huart2); 

 HAL_UART_Transmit(&amp;huart2, (uint8_t*)msg, 15, 0xFFFF);
</code></pre>

<p>Then in your HAL_UART_MspInit(UART_HandleTypeDef* huart) you should have something like this:</p>

<pre><code>GPIO_InitTypeDef GPIO_InitStruct;
if(huart-&gt;Instance==USART2)
{
 /* Peripheral clock enable */
 __USART2_CLK_ENABLE();
 __GPIOD_CLK_ENABLE();

/**USART2 GPIO Configuration  */
GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStruct);

    HAL_NVIC_SetPriority(USART2_IRQn, 0, 1);
    HAL_NVIC_EnableIRQ(USART2_IRQn);
}
</code></pre>

<p>Pay attention to ""GPIO_PULLUP"", I suggest you to config GPIO like this for UART.
You also have to define the UART Handler in your stm32f4_it.c file:</p>

<pre><code>void USART2_IRQHandler(void)
{
 HAL_UART_IRQHandler(&amp;huart2);
}
</code></pre>
",,42385227,306
35069230,2,35068592,2016-01-28T18:28:24.903,0,,17833,,2016-01-28T18:28:24.903,,0,,"<p>This is most likely caused because the LXDE terminal not updating the utmp information which records all logged in users and <a href=""https://fossies.org/dox/glibc-2.22/sysdeps_2unix_2getlogin_8c_source.html"" rel=""nofollow""><code>getlogin</code></a> determines the username from that information.</p>

<p>You should accept that it is possible for <code>getlogin</code> to return a null pointer and deal with it gracefully, e.g. by using <code>getpwuid</code> if <code>getlogin</code> fails:</p>

<pre><code>#include &lt;pwd.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

std::string get_username() {
    struct passwd *pwd = getpwuid(getuid());
    if (pwd)
        return pwd-&gt;pw_name;
    else
        return ""(?)"";
}
</code></pre>
",,42423562,46
35075441,2,35075178,2016-01-29T01:36:16.217,0,,3959454,,2016-01-29T03:13:04.800,2016-01-29T03:13:04.800,2,,"<p>Something like this:</p>

<pre><code>unsigned int index;
unsigned long nextMillis;
int prevFuzzy = 0;
int fuzzy = 0;

void setup()
{
    //...
    nextMillis = millis();
}

void loop()
{
    if (millis() &gt;= nextMillis)
    {
        fuzzy = random(-75, 76);
        // compensate for previous deviation and add new one
        nextMillis += sequence[index] - prevFuzzy + fuzzy;
        fuzzy = prevFuzzy;

        // or just:
        // fuzzy = random(-75, 76) - fuzzy
        // nextMillis += sequence[index] + fuzzy;

        index++;
        if (index &gt;= sizeof(sequence) / sizeof(sequence[0]))
        {
            index = 0;
        }

        // Do stuff
    }
}
</code></pre>
",,42433671,916
35078320,2,35075178,2016-01-29T06:37:30.023,0,,2591595,,2016-01-29T07:12:43.297,2016-01-29T07:12:43.297,0,,"<p>First you have to use unsigned long for milliseconds to properly account for the overflow.</p>

<p>Then I also initialized the variables at different places and startMillis with a different value</p>

<pre><code>int sequence[] = {1000, 750, 950, 1150, 1200, 1500, 1000, 1900, 2000};
unsigned int index = 0;
unsigned long startMillis;
unsigned int fuzzy = sequence[0] + random(-75, 76);

#include &lt;limits.h&gt;

void setup()
{
  Serial.begin(9600);
  pinMode(13, OUTPUT);
  randomSeed(analogRead(0));
  startMillis = millis();
}

void loop()
{
  long MilliDiff;
  if (startMillis &lt;= millis())
    MilliDiff = millis() - startMillis;
  else
    MilliDiff = ULONG_MAX - startMillis + millis();

  if (MilliDiff &gt;= fuzzy)
    {
      digitalWrite(13, !digitalRead(13));
      startMillis += sequence[index];   // advance startMillis by the last interval used

      index++;
      if (index &gt;= sizeof(sequence) / sizeof(sequence[0]))
      {
        index = 0;
        Serial.println(""Restarted Sequence"");
      }

      fuzzy = sequence[index] + random(-75, 76); // arbitrary offset needs to be positive or negative
      Serial.print(""startMillis = "");
      Serial.print(startMillis);
      Serial.print("",  sequence = "");
      Serial.print(sequence[index]);
      Serial.print("",  fuzzy = "");
      Serial.println(fuzzy);
    }
}
</code></pre>

<p>This code seems to be working on my Uno</p>
",,42444307,305
35096355,2,35096267,2016-01-30T00:11:24.223,1,,2475059,,2016-01-30T00:55:48.983,2016-01-30T00:55:48.983,12,,"<p>Strictly speaking, you can't. Making a union or a special struct just for passing around might give you what you want. Whether that's a good idea or not depends on what your caller is doing.</p>

<p><strong>Edit:</strong> Here's one way:</p>

<pre><code>String wyslij(String cmd, boolean parse = false, JsonObject * obj = NULL) {
  wifi.println(cmd);
  String response = """";
  bool beg = false;
  if(parse == true &amp;&amp; obj != NULL){
    (*obj) = jsonBuffer.parseObject(response);
  }
  return wifi.readString();
}

void Caller() {
    JsonObject root;
    String ret_val = wyslij(cmd, true, &amp;root);
    /* do things with root */
}
</code></pre>

<p>It may not work, depending on the side effects involved with making a <code>JsonObject</code> (among other things), but it'll give you the gist.</p>
",,42452407,830
35138071,2,35106904,2016-02-01T18:52:17.423,0,,3370876,,2016-02-01T18:52:17.423,2017-05-23T12:31:01.433,0,,"<p>I have finally resolved this.
I decided to look at other logical steps to find a solution.
I considered the issue could be having different strings that did different things which may be conflicting in some way.
In my research I found reference to the fact that the Bluetooth module HC-05 has 2 pins that in my case were not being utilised, the key pin and the state pin, in this stack overflow discussion <a href=""https://stackoverflow.com/questions/16005454/tell-when-bluetooth-module-connects-on-arduino"">Tell when Bluetooth module connects on Arduino</a> and decided this logic of using the ""State pin"" to signify Bluetooth connection would negate the possibility of any conflicts within the String logic.
Once I had figured out the best way to place and order the ""where"" statements I managed to get the functionality at this point in my project which then allows me to move on to the next step in the development.</p>

<p>The code I have now arrived at:</p>

<pre><code>const int ledPin1 = 11;
const int ledPin2 = 4;

String readString;

boolean BTconnected = false;

void setup() {
  Serial.begin(9600);
  pinMode (ledPin1, OUTPUT);
  pinMode (ledPin2, INPUT);
}

void loop() {  

      while (!BTconnected)
    {
      if ( digitalRead(ledPin2)==HIGH)  { BTconnected = true;};
    }
    digitalWrite(ledPin1, HIGH);
    Serial.println(""HC-05 is now connected"");
    Serial.println("""");


       while (BTconnected)
              {
        if ( digitalRead(ledPin2)==LOW)  { BTconnected = false;
        digitalWrite(ledPin1, LOW);
        Serial.println(""HC-05 is now disconnected"");
        Serial.println("""");
                };

        while (Serial.available()) 
              {
            delay(3);
            char c = Serial.read();
            readString  += c;
              }

   if (readString.length() &gt;0) {

      //Serial.println(readString);
      //readString="""";

    String first  = Serial.readStringUntil(',');
    Serial.read(); //next character is comma, so skip it using this
    Serial.println(first);
    //readString="""";

    String second = Serial.readStringUntil(',');
    Serial.read();
    Serial.println(second);
    Serial.println(""""); 
    //readString="""";
    }
  }
 }
</code></pre>
",,42460381,57
35109452,2,35108622,2016-01-31T01:51:36.183,0,,995714,,2019-12-12T12:41:25.713,2019-12-12T12:41:25.713,0,,"<p>In 2's complement, a simple cast between signed and unsigned works, because it wraps the value modulo 2<sup>n</sup>, i.e. treats the same bit pattern as the other type. For example <code>(long)0xFFFFFFFFu</code> returns -1</p>

<p>However, the thing is that both <em>addition and subtraction produce 1 more carry/borrow bit</em>. That extra bit has to be stored some where along with the low 32 bits. So simply casting the values to <code>signed</code> and subtract doesn't work for all the cases, although it'll work for values that aren't very far from each other. Try <code>LONG_MAX - LONG_MIN</code> or <code>LONG_MIN - LONG_MAX</code> to see how the result can't be stored in a <code>long</code> even when both operands are <code>long</code>s</p>

<p>To get over this, the only ways are using a wider type</p>

<pre><code>return static_cast&lt;long long&gt;(time4) - static_cast&lt;long long&gt;(currTimeLo);
</code></pre>

<p>or handle the big int arithmetic manually</p>

<pre><code>unsigned long timeDiff;
if (time4 &gt; rcurrTimeLo) // time hasn't overflowed and time4 is later than rcurrTimeLo
{
    timeDiff = time4 - rcurrTimeLo;
    // do something, for example set overflow/later flag:
    later = 1;
}
else
{
    timeDiff = rcurrTimeLo - time4;
    // set ""earlier"" flag
    later = 0;
}
</code></pre>

<p>If you use it in a function, you must return both the overflow carry and the low 32-bit difference, so the first solution seems to be easier on a 32 or 64-bit computer, and the second will be faster on a 8-bit MCU like ATmega</p>

<p>If you can guarantee that the 2 operands are never more than <code>LONG_MAX</code> far from each other then a simple <code>static_cast</code> to long will work</p>

<pre><code>return static_cast&lt;long&gt;(time4) - static_cast&lt;long&gt;(currTimeLo);
</code></pre>
",,42470112,324
35150417,2,35150262,2016-02-02T10:08:51.523,4,,3100312,,2016-02-02T10:08:51.523,,2,,"<p>The following is a basic CSV parser:</p>

<pre><code>void readCSVline(char *line);
char *readCSVfield(char *line, char *buf);
void readCSVdemo(void)
{
    char line[]= ""0,,10004,10004,\""Albany Hwy After Galliers Av\"",\""\"",-32.13649428,116.0176090070,3"";
    readCSVline(line);

}
/* readCSVline is where you put your ""intelligence"" about fields to read
 * and what to do with them
 */
void readCSVline(char *line)
{
    char field1[80], *lineptr=line;
    int nfields=0;

    while (*lineptr) {
        lineptr= readCSVfield(lineptr, field1);
        printf(""%s\n"", field1);
        nfields++;
    }
    printf(""%d fields read.\n"", nfields);
}
/* readCSVfield reads a field from a CSV line until the next comma or end-of-line.
 * It returns where the reading stopped.
 */
char *readCSVfield(char *line, char *buf)
{
    int instr= FALSE;   // track whether we are in a string
    char *cptr= line;

    while (*cptr)
    {
        if (instr) {
            if (*cptr=='""') {
                char cc= *++cptr;
                if (cc=='""')        // escaped double quote
                    *buf++ = '""';
                else {
                    *buf='\0';
                    cptr--;
                    instr= FALSE;
                }
            }
            else *buf++ = *cptr;
        }
        else switch (*cptr) {
        case '""': instr= TRUE; break;
        case ',': cptr++; *buf= '\0'; return(cptr);
        case ' ': case '\t': case '\n': case '\r': break;
        default: *buf++ = *cptr;
        }
        cptr++;
    }
    *buf= '\0';
    return(cptr);
}
</code></pre>
",,42499339,313
35153813,2,35150262,2016-02-02T12:41:17.850,2,,5871187,,2016-02-03T08:55:06.857,2016-02-03T08:55:06.857,4,,"<p>You can split string as below and get whatever you want.</p>

<pre><code>int split(char *result[], const char *str, char tok) {
    char buff[1024]; // it's better to use length of str instead of 1024
    int idx = 0;
    int len = 0;
    int ent_cnt = 0;
    int st = 0;

    // parse string
    while(1) {
        char ch = str[len++]; // need checking len to avoid overflow

        // end of string?
        if (ch == '\0')
            break;

        switch(st) {
            case 0: {
                if (ch == tok)
                    st++;
                else
                    buff[idx++] = ch;

                break;
            }

            case 1: {
                if (idx) {
                    char *entry = malloc(idx + 1);
                    int i;

                    for (i = 0; i &lt; idx; i++)
                        entry[i] = buff[i];

                    entry[i] = '\0';
                    result[ent_cnt++] = entry;
                    idx = 0;
                }

                // normal char?
                if (ch != tok)
                    buff[idx++] = ch;

                st--;
                break;
            }

            default:
                break;
        }
    }

    // process last part if any
    if (idx) {
        char *entry = malloc(idx + 1);

        int i = 0; 
        for (i = 0; i &lt; idx; i++)
            entry[i] = buff[i];

        entry[i] = '\0';
        result[ent_cnt++] = entry;
    }

    return ent_cnt;
}

int main(int argc, char *argv[]) {
    char *result[10];
    int cnt = split(result, ""s,this,is,a,test,"", ',');
    int i = 0;

    for (i = 0; i &lt; cnt; i++) {
        printf(""%s\n"", result[i]);
    }

    if (cnt != 5) {
        printf(""Fail!\n"");
    }

    return 0;
}
</code></pre>
",,42526098,3741
35157663,2,35153377,2016-02-02T15:39:03.227,0,,2410359,,2016-02-03T04:06:34.780,2016-02-03T04:06:34.780,4,,"<p>OP is trying to work with 24 elements, but is looping 25 times in two places.  Certainly leading to an invalid array access.</p>

<pre><code>char SendArray[24] = ...

// for(i =0 ; i&lt;= 24 ; i++)
for(i = 0; i &lt; 24; i++) {
  Serial.write(SendArray[i]); 
  SendArray[i] = 0;
}

// for(k=0 ; k&lt;=24 ; k++)
for(k = 0; k &lt; 24; k++)
  RecieveArray[k] = Serial.read();  // Receive spelled wrong
</code></pre>
",,42538987,185
35188247,2,35187006,2016-02-03T21:38:09.913,1,,4581301,,2016-02-03T21:38:09.913,,0,,"<p>This is a non-answer, but comments have so-far been unable to explain what's going on to OP, so here's a longer, more detailed shot at it.</p>

<p>The actual output looks something like this</p>

<pre><code>C:\Users\mwhit_000\Desktop\Capstone\Security_System\Security_System2\Security_Sy‌​stem2.ino:27:38: warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings] 
Password password = Password( ""1234"" ); 
                                      ^ 

Sketch uses 11,850 bytes (4%) of program storage space. Maximum is 253,952 bytes. Global variables use 1,022 bytes (12%) of dynamic memory, leaving 7,170 bytes for local variables. Maximum is 8,192 bytes. 
</code></pre>

<p>From ""sketch"" on isn't an error message, its build status. </p>

<p>Let's break that down.</p>

<pre><code>file name:line number:character on that line:type of error: error description 
problem line
^ marking where on the above line the compiler thinks the problem is
</code></pre>

<p>File name: C:\Users\mwhit_000\Desktop\Capstone\Security_System\Security_System2\Security_Sy‌​stem2.ino</p>

<p>Line number: 27</p>

<p>Column: 38</p>

<p>Type of error: Warning</p>

<p>Description: deprecated conversion from string constant to 'char*' [-Wwrite-strings] </p>

<p>Error line: <code>Password password = Password( ""1234"" );</code></p>

<p>So this is quite literally telling you you are converting a constant string into a non-constant string right the freak here: <code>Password password = Password( ""1234"" );</code></p>

<p>Why is this bad? ""1234"" is a constant string. the ""1234"" cannot be changed. Password takes a non-constant string and makes no promises that it won't try to change the string's value. If Password tries to change ""1234"" into something else, the results are undefined. The program may crash. It could keep running and crash later. It could eat a cat.</p>
",,42575182,1132
35236734,2,35227449,2016-02-06T02:41:47.807,6,,5775424,,2016-02-10T18:04:03.247,2016-02-10T18:04:03.247,2,,"<p>If you are trying to get from a string like <code>""100.150.200.250""</code> to a byte array like <code>{ 100, 150, 200, 250 }</code>, you need to extract the string representation for each number and convert (parse) them into a binary representation before storing them in the byte array.</p>

<p>The way you are trying to do this, you are just converting the first four bytes from the string, i.e. <code>""100.""</code>, to the binary representation of each character, which turns out to be <code>{ 49, 48, 48, 0 }</code>. You can look that up in an <a href=""https://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart"" rel=""nofollow"">ASCII table</a>.</p>

<p>Also remember that, as you are storing this on a byte array, it will only support values from 0 to 255.</p>

<p>As you are programming on small microcontroller, I would advise against using the <code>String</code> class. You might run into trouble when your programs get bigger and you start using lots of strings. Try to learn how to use character arrays instead and you will avoid running into memory issues. Remember the Arduino has just 2KB of RAM!</p>

<p>Here is a function you can use to make that conversion using the <code>strtoul()</code> function:</p>

<pre><code>void parseBytes(const char* str, char sep, byte* bytes, int maxBytes, int base) {
    for (int i = 0; i &lt; maxBytes; i++) {
        bytes[i] = strtoul(str, NULL, base);  // Convert byte
        str = strchr(str, sep);               // Find next separator
        if (str == NULL || *str == '\0') {
            break;                            // No more separators, exit
        }
        str++;                                // Point to next character after separator
    }
}
</code></pre>

<p>You can then call it like this to convert an IP address (base 10):</p>

<pre><code>const char* ipStr = ""50.100.150.200"";
byte ip[4];
parseBytes(ipStr, '.', ip, 4, 10);
</code></pre>

<p>Or like this to convert a MAC address (base 16):</p>

<pre><code>const char* macStr = ""90-A2-AF-DA-14-11"";
byte mac[6];
parseBytes(macStr, '-', mac, 6, 16);
</code></pre>
",,42578515,516
39390514,2,35227449,2016-09-08T12:08:50.130,2,,1815209,,2016-09-08T12:08:50.130,,0,,"<p>You could also use <code>sscanf</code>, and by the way detect invalid inputs using <a href=""http://www.cplusplus.com/reference/cstdio/sscanf/#return"" rel=""nofollow"">its return value</a>:</p>

<pre><code>byte ip[4];
if (sscanf(mString.c_str(), ""%hhu.%hhu.%hhu.%hhu"", ip, ip+1, ip+2, ip+3) != 4) {
  Serial.print(""invalid IP: "");
  Serial.println(mString);
}
</code></pre>

<p>However, <code>sscanf</code> may not be implemented in the library for all boards, for example on esp8266 it's <a href=""https://github.com/esp8266/Arduino/issues/488#issuecomment-195364848"" rel=""nofollow"">yet to be released</a> in version 2.4.0.</p>

<p>Also, the <code>%hhu</code> specifier for <code>unsigned char</code> may be not supported in some versions, but you can use <code>%u</code>, read it to an <code>unsigned long</code> and check if the value isn't greater than 255.</p>
",,42655059,1197
35932650,2,35249727,2016-03-11T05:06:52.687,0,,6038692,,2016-03-11T05:06:52.687,,0,,"<p>Remove if condition and try.</p>

<pre><code>#include &lt;Keypad.h&gt;
#include &lt;LiquidCrystal.h&gt; // initialize the library with the numbers of the

LiquidCrystal lcd(8, 9, 4, 5, 6, 7); 


const byte ROWS = 4; //four rows
const byte COLS = 4; //four columns
char hexaKeys[ROWS][COLS] = {
{'1','2','3','A'},
{'4','5','6','B'}, //define the cymbols on the buttons of the keypads
{'7','8','9','C'},
{'*','0','#','D'}
};   
byte rowPins[ROWS] = {13, 12, 11, 10}; //connect to the row pinouts of the         keypad
byte colPins[COLS] = {9, 8, 7, 6}; //connect to the column pinouts of the     keypad


Keypad customKeypad = Keypad( makeKeymap(hexaKeys), rowPins, colPins, ROWS,    COLS); //initialize an instance of class NewKeypad

void setup()
{
lcd.begin(16, 2);
Serial.begin(9600);
}

void loop()
{
char customKey = customKeypad.getKey();
//lcd.setCursor(1,1); 
lcd.print(customKey);
delay(500);
Serial.print(customKey);

}
</code></pre>
",,42670630,85
35262694,2,35262377,2016-02-08T05:10:18.210,0,,5043289,,2016-02-08T05:35:50.000,2016-02-08T05:35:50.000,1,,"

<p>You want to shuffle the pin numbers, but you want to do that before the constructor is called, is that it?</p>

<p>Much more simply, just call <code>Adafruit_NeoPixel::setPin</code> in setup, once you have shuffled the pins. So you can just pass any old pin numbers in the constructor, and then just change them.</p>

<blockquote>
  <p>I'm going to have a read through this: Call a function before main</p>
</blockquote>

<p>Don't go down that path, it is unnecessarily complicated.</p>

<hr>

<blockquote>
  <p>Can you toss an example up for Adafruit_NeoPixel::setPin in setup?</p>
</blockquote>

<p>Something like this:</p>

<pre class=""lang-C++ prettyprint-override""><code>  Strip1.begin();
  Strip2.begin();
  Strip3.begin();

  Strip1.setPin (3);  // or whatever
  Strip2.setPin (4);
  Strip3.setPin (5);
</code></pre>

<p>I just gave a simple example, you can do your shuffling and stuff the resulting pins into those three function calls. Now you don't have to worry about shuffling before you make Strip1/Strip2/Strip3.</p>
",,42673101,1015
35273671,2,35264733,2016-02-08T15:50:36.710,0,,241013,,2016-02-08T15:50:36.710,,0,,"<pre><code>for (int i= 1; i &lt;10; ++i) {
    for (int j= 1; j &lt;= i; ++j) {
        output(j);
    }
    // This is the break between sequences.
    sequence_clear();
}
</code></pre>
",,42720526,870
35324360,2,35324295,2016-02-10T19:35:59.197,5,,1606345,,2016-02-10T19:41:43.027,2016-02-10T19:41:43.027,5,,"<p>You can't compare strings using <code>==</code></p>

<pre><code>if (wordoftheday == ""1""){email = true;}
</code></pre>

<p>should be</p>

<pre><code>if (strcmp(wordoftheday, ""1"") == 0){email = true;}
</code></pre>

<p>And (as pointed out by @chux), it seems that you forget an <code>else</code>:</p>

<pre><code> if (strcmp(wordoftheday, ""1"") == 0)
     email = true;
 else
 if (strcmp(wordoftheday, ""0"") == 0)
     email = false;
 else { 
     lcd.clear();
     lcd.print(wordoftheday);
 }
</code></pre>
",,42726502,1459
35324483,2,35324295,2016-02-10T19:43:30.593,2,,3169961,,2016-02-10T19:43:30.593,,0,,"<p>Besides the previous answer about the compare, you are setting up the ifs incorrectly. When the first if is true, you fall into the else of the second if.</p>

<pre><code>if (Serial.available())
{
    wordoftheday = Serial.readString();
    if (strcmp(wordoftheday, ""1"")) {email = true;}
    else if ((strcmp(wordoftheday, ""0"")){email = false;}
    else { 
        // Enters here only if both of the above are false
        lcd.clear();
        lcd.print(wordoftheday);
    }
}
</code></pre>
",,42736250,281
35386238,2,35383873,2016-02-13T22:46:02.460,0,,5880678,,2016-02-14T03:24:22.307,2016-02-14T03:24:22.307,1,,"<p>In order to improve the performance of your code you can <strong>remove the delay</strong> and use the <strong>maximum Baud Rate</strong> (115200). For the sake of simplicity I compacted your Arduino code below:</p>

<pre><code>#include &lt;Servo.h&gt; 

// create 2 servos x and y
Servo x;   
Servo y;

void setup() {
    Serial.begin(115200);
    x.attach(6);   
    y.attach(7);
}

void loop() {
    //empty
}

void serialEvent() {
   //set servo position.
   if (Serial.available()&gt;0) { 
       //Receives 2 angles separated per a comma
       x.write(Serial.parseInt()); //Returns first angle
       y.write(Serial.parseInt()); //Returns second angle
       Serial.read(); //Read the '\n'. I am not sure if it is necessary.
   } 
}
</code></pre>

<p>Increase the Baud Rate also in the C# source code:</p>

<pre><code>port.BaudRate = 115200;   
</code></pre>

<p>In addition, I suggest you send the angles separated by a comma through the serial. So, instead of:</p>

<pre><code>while(valx.Length &lt; 3) {
    valx = '0' + valx;
}
while(valy.Length &lt; 3) {
    valy = '0' + valy;
}
string valsum = valx+valy;
label3.Text = valsum.ToString();
if (port.IsOpen) {
    port.WriteLine(valsum);
}     
</code></pre>

<p>Replace with:</p>

<pre><code>if (port.IsOpen) {
    port.WriteLine(valx + ',' + valy); //Note that WriteLine appends a '\n' character in the end.
}  
</code></pre>
",,42747716,729
35399276,2,35399223,2016-02-14T23:23:25.347,1,,4143855,,2016-02-14T23:23:25.347,,2,,"<p>You're making a <em>copy</em> of your Players:</p>

<pre><code>// The actual players
Player p1 = {5, false, 1, ""P1 mins: "", 0};
Player p2 = {5, false, 2, ""P2 mins: "", 0};

// A COPY of player 1
Player menuPlayer = p1;
</code></pre>

<p>When you make calls like</p>

<pre><code>menuPlayer.IncrementMinutes(); 
</code></pre>

<p>You are simply changing <code>menuPlayer</code>, not <code>p1</code> or <code>p2</code>. So when you do the following</p>

<pre><code>menuPlayer = p2;
</code></pre>

<p>All the changes made to <code>menuPlayer</code> are lost, and you make a new copy.</p>

<p>You could fix this by copying <code>menuPlayer</code> into <code>p1</code> before swapping:</p>

<pre><code>p1 = menuPlayer;
menuPlayer = p2;
</code></pre>

<p>Or by making <code>menuPlayer</code> a <code>Player*</code>:</p>

<pre><code>// Point to p1:
Player* menuPlayer = &amp;p1;

// Changes p1
menuPlayer-&gt;IncrementMinutes();
</code></pre>
",,42759434,754
35415155,2,35414530,2016-02-15T17:11:04.637,0,,5880678,,2016-02-15T17:39:09.560,2016-02-15T17:39:09.560,3,,"<p>The problem is that you need to concatenate the variable <code>var</code> with the SQL command. In order to do that you can use an auxiliar variable <code>query</code> in combination with the <code>sprintf</code> function for building the correct INSERT command.</p>

<p>Replace this:</p>

<pre><code>char INSERT_SQL[] = ""INSERT INTO Meter.consumption VALUES (""d"");"";
MySQL_Cursor *cur_mem = new MySQL_Cursor(&amp;conn);
cur_mem-&gt;execute(INSERT_SQL);
</code></pre>

<p>With:</p>

<pre><code>char INSERT_SQL[] = ""INSERT INTO Meter.consumption VALUES (%d);"";
char query[255];
sprintf(query, INSERT_SQL, var);
MySQL_Cursor *cur_mem = new MySQL_Cursor(&amp;conn);
cur_mem-&gt;execute(query);
</code></pre>

<p>Note that although <code>sprintf</code> is an undocumented function in Arduino, it works similar to the one available in C. You can see more details <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow"">here</a>. Since it is a built-in function, there is no need to include any additional header in your code.</p>
",,42790459,66
35580649,2,35451657,2016-02-23T14:50:50.183,4,,4100891,,2016-02-26T15:29:30.283,2016-02-26T15:29:30.283,9,,"<p>There's no way that <code>ReadWriteRegister</code> will work.  At 115200, each character takes about 87us to be sent or received.  In that time, the Arduino can execute about 100 lines of code!</p>

<p>Look at this snippet:</p>

<pre><code>  Serial1.write(command, 5);

  // Read response
  if(Serial1.available() == 3) {
</code></pre>

<p>The <code>write</code> function only puts the command in the output buffer and starts sending the first character.  It returns <em>before</em> all the characters have been transmitted.  That will take 500us!</p>

<p>Then, you look to see if there a 3-character response has been received.  But the command hasn't finished being transmitted, and you certainly didn't wait 258us (3 times 86us).  It could even take longer if the device needs time to execute your command.</p>

<p>You have to do two things: wait for the command to be sent, and wait for the response to be received.  Try this:</p>

<pre><code>  Serial1.write(command, 5);
  Serial1.flush(); // wait for command to go out

  // Wait for response to come back
  while (Serial1.available() &lt; 3)
    ; // waitin'....

  // Read response
  response[0] = (byte)Serial1.read();
  response[1] = (byte)Serial1.read();
  response[2] = (byte)Serial1.read();
</code></pre>

<p>This is called ""blocking"", because the Arduino won't do anything else while you're waiting for the response.</p>

<p>However, if a character is missed, your program could ""hang"" there, waiting for a 4th character if the 2nd character is not sent/received correctly (it happens).  So you should put a 500us timeout in that while loop:</p>

<pre><code>  // Wait for response
  uint32_t startTime = micros();
  while ((Serial1.available() &lt; 3) &amp;&amp; (micros() - startTime &lt; 500UL))
    ; // waitin'...
</code></pre>

<p>... or longer, if you know how quickly the device will respond.  Then you can determine whether you actually got a response:</p>

<h3>UPDATED with complete program (v2):</h3>

<pre><code>/* DEFINITIONS */
#include &lt;math.h&gt;

/* INTEGERS */

byte deviceId = 0x17;
uint8_t command[5];
uint8_t response[3];

/* FLOATS */

double  throttleOut     = 0.0;
double  voltage         = 0.0;
double  rippleVoltage   = 0.0;
double  current         = 0.0;
double  power           = 0.0;
double  throttle        = 0.0;
double  pwm             = 0.0;
double  rpm             = 0.0;
double  temp            = 0.0;
double  becVoltage      = 0.0;
uint8_t safeState       = 0;
uint8_t linkLiveEnabled = 0;
bool    eStopStatus     = 0;
double  rawNTC          = 0.0;

/* SETUP */
void setup() {
  Serial1.begin(115200);
  Serial.begin(115200);
  Serial.println( F(""---------------------------"") );

  // According to the spec, you can synchronize with the device by writing
  // five zeroes.  Although I suspect this is mostly for the SPI and I2c
  // interfaces (not TTL-level RS-232), it won't hurt to do it here.
  Serial1.write( command, 5 );
  delay( 250 ); // ms
  while (Serial1.available())
    Serial1.read(); // throw away

  // Set the throttle just once
  ReadWriteRegister(128, 1000);//_throttleOut is 0[0%] to 65535[100%]
}

//  For 12-bit A/D conversions, the range is 0..4096.  Values at
//  the top and bottom are usually useless, so the value is limited
//  to 6..4090 and then shifted down to 0..4084.  The middle of this
//  range will be the ""1.0"" value: 2042.  Depending on what is being 
//  measured, you still need to scale the result.
const double ADC_FACTOR = 2042.0;

void loop() {

  uint32_t scanTime = millis(); // mark time now so we can delay later

  voltage             = ReadWriteRegister(  0, 0 ) / ADC_FACTOR * 20.0;
  rippleVoltage       = ReadWriteRegister(  1, 0 ) / ADC_FACTOR * 4.0;
  current             = ReadWriteRegister(  2, 0 ) / ADC_FACTOR * 50.0;
  power               = voltage * current;
  throttle            = ReadWriteRegister(  3, 0 ) / ADC_FACTOR * 1.0;
  pwm                 = ReadWriteRegister(  4, 0 ) / ADC_FACTOR * 0.2502;
  rpm                 = ReadWriteRegister(  5, 0 ) / ADC_FACTOR * 20416.66;
  const int poleCount = 20;//Motor pole count
  rpm                 = rpm / (poleCount / 2);
  temp                = ReadWriteRegister(  6, 0 ) / ADC_FACTOR * 30.0;
  becVoltage          = ReadWriteRegister(  7, 0 ) / ADC_FACTOR * 4.0;
  safeState           = ReadWriteRegister( 26, 0 );
  linkLiveEnabled     = ReadWriteRegister( 25, 0 );
  eStopStatus         = ReadWriteRegister( 27, 0 );
  rawNTC              = ReadWriteRegister(  9, 0 ) / ADC_FACTOR * 63.1825;

  const double R0 =  1000.0;
  const double R2 = 10200.0;
  const double B  =  3455.0;
  rawNTC          = 1.0 / (log(rawNTC * R2 / (255.0 - rawNTC) / R0 ) / B + 1.0 / 298.0) - 273.0;

  Serial.print( F(""Voltage: "") );
  Serial.println(voltage);
  Serial.print( F(""Current: "") );
  Serial.println(current);
  Serial.print( F(""Throttle: "") );
  Serial.println(throttle);
  Serial.print( F(""RPM: "") );
  Serial.println(rpm);

  // These prints do not actually send the characters, they only queue
  // them up to be sent gradually, at 115200.  The characters will be
  // pulled from the output queue by a TX interrupt, and given to the
  // UART one at a time.
  //
  // To prevent these interrupts from possibly interfering with any other
  // timing, and to pace your program, we will wait *now* for all the
  // characters to be sent to the Serial Monitor.
  Serial.flush();

  // Let's pace things a little bit more for testing: delay here until
  // it's time to scan again.
  const uint32_t SCAN_INTERVAL = 1000UL; // ms
  while (millis() - scanTime &lt; SCAN_INTERVAL)
    ; // waitin'
}

int16_t ReadWriteRegister(int reg, int value) {
  // Flush input, as suggested by Gee Bee
  while (Serial1.available() &gt; 0)
    Serial1.read();

  // Send command (register number determines whether it is read or write)

  command[0] = (byte)(0x80 | deviceId);
  command[1] = (byte)reg;
  command[2] = (byte)((value &gt;&gt; 8) &amp; 0xFF);
  command[3] = (byte)(value &amp; 0xFF);
  command[4] = (byte)(0 - command[0] - command[1] - command[2] - command[3]);
  Serial1.write(command, 5);

  // The command bytes are only queued for transmission, they have not
  // actually gone out.  You can either wait for command to go out
  // with a `Serial1.flush()`  *OR*  add the transmission time to the
  // timeout value below.  However, if anything else has queued bytes
  // to be sent and didn't wait for them to go out, the calculated 
  // timeout would be wrong.  It is safer to flush now and guarantee
  // that *all* bytes have been sent: anything sent earlier (I don't 
  // see anything else, but you may change that later) *plus* 
  // these 5 command bytes.

  Serial1.flush();

  // Now wait for response to come back, for a certain number of us
  //   The TIMEOUT could be as short as 3 character times @ the Serial1
  //   baudrate: 3 * (10 bits/char) / 115200bps = 261us.  This is if
  //   the device responds immediately.  Gee Bee says 20ms, which would 
  //   be 20000UL.  There's nothing in the spec, but 1ms seems generous
  //   for reading the raw NTC value, which may require an ADC conversion.
  //   Even the Arduino can do that in 100us.  Try longer if you get
  //   timeout warnings.

  const uint32_t TIMEOUT = 2000UL;

  uint32_t startTime = micros();
  while ((Serial1.available() &lt; 3) &amp;&amp; (micros() - startTime &lt; TIMEOUT))
    ; // waitin'...

  int16_t result;

  if (Serial1.available() &gt;= 3) {
    response[0] = (byte)Serial1.read();
    response[1] = (byte)Serial1.read();
    response[2] = (byte)Serial1.read();

    // Verify the checksum
    if (response[0] + response[1] + response[2] != 0) {
      Serial.print( reg );
      Serial.println( F("" Checksum error!"") );
      Serial.flush(); // optional, use it for now to stay synchronous
    }

    //  Cast to 16 bits *first*, then shift and add
    result = (((int16_t) response[0]) &lt;&lt; 8) + (int16_t) response[1];

  } else {
    //  Must have timed out, because there aren't enough characters
    Serial.print( reg );
    Serial.println( F("" Timed out!"") );
    Serial.flush(); // optional, use it for now to stay synchronous

    result = 0;
  }

  return result; // You must always return something
}
</code></pre>

<p>Comments:</p>

<ul>
<li>There was an error in your result calculation that is (probably) fixed in the answer above.  Casting to <code>double</code> outside the addition caused you to lose the top 8 bits, I think.  Calculating as above should give the correct answer.</li>
<li>After a little googling, I see this is for a <a href=""http://www.castlecreations.com/support/documents/castle_serial_link_v1.3.pdf"" rel=""nofollow"">Castle Serial Link controller</a>.  That would have been useful to know.  It describes the checksum, which I used in the <code>ReadWriteRegister</code> function above.  The function can tell you if it timed out or if the checksum was wrong.  This would also imply that longer timeouts may be required.  It's not clear if your device waits up to 480ms to get the latest value, or if it is continuously cacheing them and responds immediately with the last value recevied from the ESC.  <em>Writes</em>, however, will not be reflected in the read values for up to 480ms, because of the time it takes the ESC to receive a command and then send the new values.  See <a href=""http://www.castlecreations.com/support/documents/castle_link_live_2.0.pdf"" rel=""nofollow"">ESC Castle Link protocol</a>.</li>
<li>The <code>ReadWriteRegister</code> function returns a 16-bit integer, which will be more efficient.  Comparing floating-point numbers is never good.  BTW, <code>double</code> is just single <code>float</code> on the 8-bit Arduinos.</li>
<li>The <code>ReadWriteRegister</code> function doesn't need the <code>writemode</code> argument, because the register number determines whether you are writing or reading the device.</li>
<li>Writing the <code>throttle</code> value is only performed in setup.</li>
</ul>

<p><hr></p>

<h3>UPDATE 2</h3>

<p>Your <strong>L</strong>ogic <strong>A</strong>nalyzer shots appear to show a ""scan"" for ESCs.  It is trying each device ID, and some of them reply with a non-zero voltage.  Also, it appears to be running at 9600, <strong>NOT</strong> 115200.  Is this from a different setup?</p>

<p>Regardless, it confirms what the controller spec said: write 5 bytes, read 3.  The checksum values are as expected.  However, it is running 10 times slower than your program, so it doesn't provide much new information regarding timeouts.  It may imply there <em>is</em> a small delay before the device responds, perhaps ~1 bit time, or about 100us.</p>

<p>Have you read the controller spec?  You should compare the program to the spec to make sure you understand how the controller works.</p>

<p>I have modified the program above to:</p>

<ul>
<li>sync with the controller in <code>setup</code> (write 5 zero bytes and wait 250ms),</li>
<li>use scaling numbers from the spec (instead of their reciprocals?),</li>
<li>use meaningful constants instead of ""magic"" numbers (e.g. 2042), </li>
<li>use integer or boolean types for a few registers instead of <code>double</code> (see <code>safeState</code>, <code>linkLiveStatus</code>, and <code>eStopStatus</code>),</li>
<li>increase the timeout to 2ms (keep increasing it if you continue to get frequent timeouts), and</li>
<li>output the <code>reg</code> number when an error occurs.</li>
</ul>

<p>If you want to be successful in this area, you must learn to read a specification and translate its requirements into code that <em>conforms</em>.  The program you started with is non-conformal at worst, or misleading at best.  I am particularly amused by the comments that say ""INTEGERS"" and ""FLOATS"", yet those sections contain the opposite.</p>

<p>Perhaps this is a lesson in fixing someone else's code?  It truly has many problems that you will encounter.  If I had a nickel for every time I said:</p>

<ul>
<li>""What's that number for?""</li>
<li>""That comment is wrong!""</li>
<li>""The spec says you're supposed to...""</li>
<li>""Why is this so hard to read?  I'll just add some spacing.""</li>
</ul>

<p>...I would be a very rich man.  :)</p>

<p>(end of updates)
<hr></p>

<h3>P.S.</h3>

<p>This also matches the symptoms you describe:  Because you didn't wait for the transmission to complete, 0 bytes are read the first time through (<code>read</code> will return a -1 or 0xFF byte).</p>

<p>After you've called this routine several times (and queued up several command into the output buffer), 500us have elapsed and the first command has finally been sent.  The device responds by starting to send 3 characters.  87us later, the Arduino has finally received the first character.  It gets read by <em>one</em> of your <code>read</code> statements, but who knows which one?  It will be random, based on the elapsed time.</p>

<p>More commands get sent, and individual characters are received and read by one of those statements, until 64 bytes of commands <strong>OR Serial.println chars</strong> are queued up.  Then the <code>write</code> command <strong>OR Serial.print</strong> blocks until the output has room for the newest command.  (This addresses the title of your question.)</p>

<p>When enough command bytes or debug message chars are finally transmitted, the <code>Serial1.write</code> or <code>Serial.print</code> returns.  In the meantime, received characters are going into the input buffer.  (That's where they are stored until you call <code>read</code>.)</p>

<p>At this point, three <code>read</code> statements in a row will actually get characters that the device sent.  But because of the random consumption of characters earlier, it could be the last character of one response, followed by the first two characters of the next response.  You're ""out-of-sync"" with the 3-byte responses.</p>

<p>To stay ""in synch"" with the device, you have to wait for the send to complete with <code>flush</code>, and wait for the response to come back with <code>while</code>.</p>
",,42806715,428
35582769,2,35451657,2016-02-23T16:24:32.190,-1,,5903395,,2016-02-23T19:35:41.813,2016-02-23T19:35:41.813,4,,"<p>Sorry, but this code has some issues. You assume that </p>

<ul>
<li>No trash is getting received while your code runs</li>
<li>The hardware connected to Serial1 answers 3 bytes in 0.00ns </li>
</ul>

<p>Use the following pattern in ReadWriteRegister:</p>

<ul>
<li>discard any pending input from Serial1</li>
<li>send out the command</li>
<li>wait until <em>at least</em> 3 bytes have been received, or some resonable timeout occurs (see slash-dev's detailed answer)</li>
<li>read 3 bytes (if there was something received)</li>
</ul>

<p>In the code:</p>

<pre><code>double ReadWriteRegister(int reg, int value, bool writeMode) {
  // Send read command

  command[0] = (byte)(0x80 | deviceId);
  command[1] = (byte)reg;
  command[2] = (byte)((value &gt;&gt; 8) &amp; 0xFF);
  command[3] = (byte)(value &amp; 0xFF);
  command[4] = (byte)(0 - command[0] - command[1] - command[2] - command[3]);

  // discard any input
  while (Serial1.available() &gt; 0) {
    Serial1.read();
  }

  // write out command
  Serial1.write(command, 5);

  // wait for 3 bytes
  uint32_t startTime = micros();
  while ((Serial1.available() &lt; 3) &amp;&amp; (micros() - startTime &lt; 20000UL))
    ; // waiting for 20 ms for the answer

  // Read response
  if(Serial1.available() &gt;= 3) {  // &gt;=3 accept also more bytes
      response[0] = (byte)Serial1.read();
      response[1] = (byte)Serial1.read();
      response[2] = (byte)Serial1.read();
  }

  if ((byte)(response[0] + response[1] + response[2]) == 0)
  {
    return (double)((response[0] &lt;&lt; 8) + (response[1]));
  }
  else
  {
    Serial.println(""Error communicating with device!"");
    return 0;
  }
}
</code></pre>
",,42818372,143
35484971,2,35461155,2016-02-18T15:01:40.840,2,,5946557,,2016-02-18T15:01:40.840,,1,,"<p>The SHT31 uses 16bit read and write, rather than using 2 8bit writes you might be better off using wiringpi's 16bit write. wiringPiI2CWriteReg16(). Same thing applies to the read.</p>

<p>Below is a very early copy of what I've done to read the sht31-d on a PI. It has no dependencies except i2c-dev.   Heater enable/disable is not working, but softreset, clearstatus, getserial &amp; get temp/humid are all fine.</p>

<pre><code>/*
 * Referances
 * https://www.kernel.org/doc/Documentation/i2c/dev-interface
 * https://github.com/adafruit/Adafruit_SHT31
 * https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/Humidity_and_Temperature_Sensors/Sensirion_Humidity_and_Temperature_Sensors_SHT3x_Datasheet_digital.pdf
 *
 * This depends on i2c dev lib
 * sudo apt-get install libi2c-dev
 *
 * Below is also a good one to have, but be careful i2cdump from the below cause the sht31 interface to become unstable for me
 * and requires a hard-reset to recover correctly.
 * sudo apt-get install i2c-tools
 *
 * on PI make sure below 2 commands are in /boot/config.txt
 * dtparam=i2c_arm=on
 * dtparam=i2c1_baudrate=10000
 * I know we are slowing down the baurate from optimal, but it seems to be the most stable setting in my testing.
 * add another 0 to the above baudrate for max setting, ie dtparam=i2c1_baudrate=100000
 */

#include &lt;linux/i2c-dev.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;elf.h&gt;
#include &lt;unistd.h&gt;

#define SHT31_INTERFACE_ADDR       1
#define SHT31_DEFAULT_ADDR         0x44
#define SHT31_READ_SERIALNO        0x3780
#define SHT31_MEAS_HIGHREP_STRETCH 0x2C06 // Doesn't work on PI
#define SHT31_MEAS_MEDREP_STRETCH  0x2C0D // Seems to work on PI but shouldn't
#define SHT31_MEAS_LOWREP_STRETCH  0x2C10 // Seems to work on PI but shouldn't
#define SHT31_MEAS_HIGHREP         0x2400 // Doesn't work on PI
#define SHT31_MEAS_MEDREP          0x240B
#define SHT31_MEAS_LOWREP          0x2416
#define SHT31_READSTATUS           0xF32D
#define SHT31_CLEARSTATUS          0x3041
#define SHT31_SOFTRESET            0x30A2
#define SHT31_HEATER_ENABLE        0x306D
#define SHT31_HEATER_DISABLE       0x3066

#define CHECK_BIT(var,pos) (((var)&gt;&gt;(pos)) &amp; 1)

/*
 * delay:
 *  Wait for some number of milliseconds
 *********************************************************************************
 */

void delay (unsigned int howLong)
{
  struct timespec sleeper, dummy ;

  sleeper.tv_sec  = (time_t)(howLong / 1000) ;
  sleeper.tv_nsec = (long)(howLong % 1000) * 1000000 ;

  nanosleep (&amp;sleeper, &amp;dummy) ;
}

/*
*
* CRC-8 formula from page 14 of SHT spec pdf
*
* Test data 0xBE, 0xEF should yield 0x92
*
* Initialization data 0xFF
* Polynomial 0x31 (x8 + x5 +x4 +1)
* Final XOR 0x00
*/
uint8_t crc8(const uint8_t *data, int len)
{
  const uint8_t POLYNOMIAL = 0x31;
  uint8_t crc = 0xFF;
  int j;
  int i;

  for (j = len; j; --j ) {
    crc ^= *data++;

    for ( i = 8; i; --i ) {
      crc = ( crc &amp; 0x80 )
            ? (crc &lt;&lt; 1) ^ POLYNOMIAL
            : (crc &lt;&lt; 1);
    }
  }
  return crc;
}


/*
 * 
 * buffer should return with data read, size defined by readsize
 *********************************************************************************
*/

int writeandread(int fd, uint16_t sndword, uint8_t *buffer, int readsize)
{
  int rtn;
  uint8_t snd[3];
  // Split the 16bit word into two 8 bits that are flipped.
  snd[0]=(sndword &gt;&gt; 8) &amp; 0xff;
  snd[1]=sndword &amp; 0xff;

  rtn = write(fd, snd, 2);
  if ( rtn != 2 ) {
    return 1;
  } 

  if (readsize &gt; 0) {
    delay(10);
    rtn = read(fd, buffer, readsize);
    if ( rtn &lt; readsize) {
      return 2;
    }
  }

  return 0;
}

void printserialnum(int file)
{
  uint8_t buf[10];
  int rtn;

  rtn = writeandread(file, SHT31_READ_SERIALNO, buf, 6);
  if (rtn != 0)
    printf(""ERROR:- Get serial i2c %s failed\n"",(rtn==1?""write"":""read""));
  else {
    if (buf[2] != crc8(buf, 2) || buf[5] != crc8(buf+3, 2))
      printf(""WARNING:- Get serial CRC check failed, don't trust result\n"");

    uint32_t serialNo = ((uint32_t)buf[0] &lt;&lt; 24)
    | ((uint32_t)buf[1] &lt;&lt; 16)
    | ((uint32_t)buf[3] &lt;&lt; 8)
    | (uint32_t)buf[4];
    printf(""Serial# = %d\n"",serialNo);
  }
}

void printtempandhumidity(int file)
{
  uint8_t buf[10];
  int rtn;

    rtn = writeandread(file, SHT31_MEAS_MEDREP_STRETCH, buf, 6);

  if (rtn != 0)
    printf(""ERROR:- Get temp/humidity i2c %s failed\n"",(rtn==1?""write"":""read""));
  else {
    if ( buf[2] != crc8(buf, 2) || buf[5] != crc8(buf+3, 2))
      printf(""WARNING:- Get temp/humidity CRC check failed, don't trust results\n"");

    uint16_t ST, SRH;
    ST = buf[0];
    ST &lt;&lt;= 8;
    ST |= buf[1];

    SRH = buf[3];
    SRH &lt;&lt;= 8;
    SRH |= buf[4];

    double stemp = ST;
    stemp *= 175;
    stemp /= 0xffff;
    stemp = -45 + stemp;

    double stempf = ST;
    stempf *= 315;
    stempf /= 0xffff;
    stempf = -49 + stempf;

    printf(""Temperature %.2fc - %.2ff\n"",stemp,stempf);

    double shum = SRH;
    shum *= 100;
    shum /= 0xFFFF;

    printf(""Humidity %.2f%%\n"",shum);
  }
}

void printBitStatus(uint16_t stat)
{
  printf(""Status\n"");
  printf(""    Checksum status %d\n"", CHECK_BIT(stat,0));
  printf(""    Last command status %d\n"", CHECK_BIT(stat,1));
  printf(""    Reset detected status %d\n"", CHECK_BIT(stat,4));
  printf(""    'T' tracking alert %d\n"", CHECK_BIT(stat,10));
  printf(""    'RH' tracking alert %d\n"", CHECK_BIT(stat,11));
  printf(""    Heater status %d\n"", CHECK_BIT(stat,13));
  printf(""    Alert pending status %d\n"", CHECK_BIT(stat,15));
}

void printstatus(int file)
{
  uint8_t buf[10];
  int rtn;

  rtn = writeandread(file, SHT31_READSTATUS, buf, 3);
  if (rtn != 0)
    printf(""ERROR:- readstatus %s failed\n"",(rtn==1?""write"":""read""));
  else {
    if ( buf[2] != crc8(buf, 2))
      printf(""WARNING:- Get status CRC check failed, don't trust results\n"");

    uint16_t stat = buf[0];
    stat &lt;&lt;= 8;
    stat |= buf[1];  
    printBitStatus(stat);
  }
}



void clearstatus(int file)
{
  if( writeandread(file, SHT31_CLEARSTATUS, NULL, 0) != 0)
    printf(""ERROR:- sht31 clear status failed\n"");
  else 
    printf(""Clearing status - ok\n"");
}

void softreset(int file)
{
  if( writeandread(file, SHT31_SOFTRESET, NULL, 0) != 0)
    printf(""ERROR:- sht31 soft reset failed\n"");
  else  
    printf(""Soft reset - ok\n"");
}

void enableheater(int file)
{
  if( writeandread(file, SHT31_HEATER_ENABLE, NULL, 0) != 0)
    printf(""ERROR:- sht31 heater enable failed\n"");
  else 
    printf(""Enabiling heater - ok\n"");
}

void disableheater(int file)
{
  if( writeandread(file, SHT31_HEATER_DISABLE, NULL, 0) != 0)
    printf(""ERROR:- sht31 heater enable failed\n"");
  else  
    printf(""Disableing heater - ok\n"");
}

int main()
{

  int file;
  char filename[20];

  snprintf(filename, 19, ""/dev/i2c-%d"", SHT31_INTERFACE_ADDR);
  file = open(filename, O_RDWR);
  if (file &lt; 0) {
    printf(""ERROR:- Can't open %s\n"",filename);
    exit(1);
  }

  if (ioctl(file, I2C_SLAVE, SHT31_DEFAULT_ADDR) &lt; 0) {
    printf(""ERROR:- Connecting to sht31 I2C address 0x%02hhx\n"", SHT31_DEFAULT_ADDR);
    exit(1);
  }

  softreset(file);
  printtempandhumidity(file);
  printstatus(file);

  close(file);

  return 0;
}
</code></pre>
",,42826405,1133
35472406,2,35472216,2016-02-18T03:42:05.910,1,,4439794,,2016-02-18T03:42:05.910,2020-06-20T09:12:55.060,0,,"<p><strong>What happen with your code ?</strong></p>
<p><code>Serial.println(2 + &quot;1&quot;)</code> won't give you <code>21</code> in C (in this case used for Arduino).</p>
<p>You are trying to concatenate an integer and a string directly and it is not valid in <code>C</code> (or almost programming language).</p>
<p><strong>Solution:</strong></p>
<pre><code>void loop() {
  char pin_display;
  for(int i = 2; i&lt;12; i++){
    if(digitalRead(i) == HIGH){
      pin_display = i + 0x30 //convert to Ascii
      Serial.print(pin_display);
      Serial.print(&quot;1&quot;);
    }
    ...
</code></pre>
",,42840931,637
35495137,2,35472216,2016-02-19T00:24:17.267,1,,5880678,,2016-02-19T00:24:17.267,,0,,"<p>As mentioned in the other answer, the problem happens in <code>Serial.println(i + ""1"")</code>. This expression is evaluated as <em>int + pointer</em> that results in a corrupted <em>pointer</em>. A short way to fix that is creating a <em>String</em> from the integer variable: <code>Serial.println(String(i)+""1"")</code>. This expression is evaluated as <em>String  + pointer</em> that results in a valid <em>String</em> object.</p>

<p><strong>Corrected code:</strong></p>

<pre><code>void loop() {
    for(int i = 2; i&lt;12; i++){
       if(digitalRead(i) == HIGH){
          Serial.println(String(i) + ""1"");
       }
       if(digitalRead(i) == LOW){
         Serial.println(String(i) + ""0"");
       }
    }
}
</code></pre>
",,42852317,178
35486669,2,35482878,2016-02-18T16:12:26.380,1,,3368201,,2016-02-18T16:12:26.380,,0,,"<blockquote>
  <p>'maze' does not name a type</p>
</blockquote>

<p>In fact, 'maze' DOES NOT name a type. It is, indeed, an object.</p>

<p>In other languages you can write instructions outside the functions, since the whole file body is considered a ""function"". In C, however, outside functions you can only write declarations and definitions of global variables. You should have written:</p>

<pre><code>#include ""Arduino.h""
#include ""cell.h""
#include &lt;cell.h&gt;

cell maze[16][16];
cell * current = new cell(1, 1, 0, false, 0);
cell * end_pt = new cell(1,1,1,true);

void setup()
{
    maze[15][15] = end_pt;
}
</code></pre>

<p>Now, as the other answer pointed out, you can't assign a pointer to the value. If you want to keep maze as a cell matrix, you have to copy the values hand by hand:</p>

<pre><code>void copyCell(cell *dst, cell src)
{
    dst-&gt;right = src.right;
    dst-&gt;left = src.left;
    dst-&gt;forw = src.forw;
    dst-&gt;info = src.info;
    dst-&gt;value = src.value;
}

void setup()
{
    copyCell(&amp;(maze[15][15]), end_pt);
}
</code></pre>

<p>(or better just include a copy function in the class)</p>

<p>OR declare maze as a cell pointers matrix:</p>

<pre><code>cell *maze[16][16];
</code></pre>

<p>This depends on how you want to implement the program</p>
",,42865343,43
35508454,2,35486045,2016-02-19T15:08:26.987,13,,5880678,,2016-02-19T15:08:26.987,,0,,"<p>Actually, your code returns only the <strong>last</strong> line of the text file because it is printing the buffer only after reading the whole data. The code is printing repeatedly because the file is being opened inside the loop function. Usually, reading a file should be done in the <code>setup</code> function that is executed only one time. </p>

<p>Instead of reading the data char by char into the buffer, you could read until find the delimiter and assign that to a <code>String</code> buffer. This approach keep your code simple. My suggestion to fix your code is right below:</p>

<pre><code>#include &lt;SD.h&gt;
#include &lt;SPI.h&gt;

File printFile;
String buffer;
boolean SDfound;


void setup() {
  Serial.begin(9600);

  if (SDfound == 0) {
    if (!SD.begin(53)) {
      Serial.print(""The SD card cannot be found"");
      while(1);
    }
  }
  SDfound = 1;
  printFile = SD.open(""Part1.txt"");

  if (!printFile) {
    Serial.print(""The text file cannot be opened"");
    while(1);
  }

  while (printFile.available()) {
    buffer = printFile.readStringUntil('\n');
    Serial.println(buffer); //Printing for debugging purpose         
    //do some action here
  }

  printFile.close();
}

void loop() {
   //empty
}
</code></pre>
",,42904053,429
35530101,2,35530025,2016-02-20T22:52:33.030,1,,1141471,,2016-02-20T22:59:16.090,2016-02-20T22:59:16.090,7,,"<p>Your mistake most likely is to use <code>==</code> comparison instead of <code>=</code> assignment.</p>

<pre><code>class A {
    bool ena;  // doesn't have to be public so far
public:
    void function(int x)
    {
        if(x == 0) // x could equal anything
        {
            ena = true;
            //  ^   not ==
        }
    }
};
</code></pre>

<p>Usage:</p>

<pre><code>A a;
a.function(0);
// now A.ena is true
</code></pre>
",,42908594,946
35536989,2,35533665,2016-02-21T13:54:55.483,2,,5880678,,2016-02-21T14:04:02.310,2016-02-21T14:04:02.310,4,,"<p>Assuming you know how to set a single pixel in the LCD screen and have a linux shell access, I can think in a way to hard code the image in your Arduino source. Although this approach is not so practical, it is certainly feasible and fun. So, lets do it!   </p>

<p>Suppose you want to display this icon <img src=""https://i.stack.imgur.com/LIIuY.png"" alt=""Nuclear icon""> named as <code>nuclear.png</code>. </p>

<p>By using the <code>convert</code> tool from the <a href=""http://www.imagemagick.org/"" rel=""nofollow noreferrer"">ImageMagick package</a> you can obtain a text file that lists each pixel in the image through this command:  </p>

<pre><code>convert nuclear.png nuclear.txt
</code></pre>

<p>The command above has as output the file <code>nuclear.txt</code> below:</p>

<pre><code># ImageMagick pixel enumeration: 16,16,255,rgba
0,0: (255,255,255,0)  #FFFFFF00  rgba(255,255,255,0)
1,0: (6,6,6,0.556863)  #0606068E  rgba(6,6,6,0.556863)
2,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
3,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
4,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
5,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
6,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
7,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
8,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
9,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
10,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
11,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
12,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
13,0: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
14,0: (6,6,6,0.556863)  #0606068E  rgba(6,6,6,0.556863)
15,0: (255,255,255,0)  #FFFFFF00  rgba(255,255,255,0)
0,1: (6,6,6,0.556863)  #0606068E  rgba(6,6,6,0.556863)
1,1: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
2,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
3,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
4,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
5,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
6,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
7,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
8,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
9,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
10,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
11,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
12,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
13,1: (26,26,26,1)  #1A1A1A  rgba(26,26,26,1)
14,1: (6,6,6,0.94902)  #060606F2  rgba(6,6,6,0.94902)
15,1: (6,6,6,0.556863)  #0606068E  rgba(6,6,6,0.556863)
0,2: (5,5,5,0.94902)  #050505F2  rgba(5,5,5,0.94902)
1,2: (25,25,25,1)  #191919  rgba(25,25,25,1)
2,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
3,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
4,2: (17,17,15,1)  #11110F  rgba(17,17,15,1)
5,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
6,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
7,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
8,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
9,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
10,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
11,2: (17,17,15,1)  #11110F  rgba(17,17,15,1)
12,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
13,2: (15,15,15,1)  #0F0F0F  rgba(15,15,15,1)
14,2: (25,25,25,1)  #191919  rgba(25,25,25,1)
15,2: (5,5,5,0.94902)  #050505F2  rgba(5,5,5,0.94902)
0,3: (5,5,5,0.94902)  #050505F2  rgba(5,5,5,0.94902)
1,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
2,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
3,3: (30,26,14,1)  #1E1A0E  rgba(30,26,14,1)
4,3: (181,133,13,1)  #B5850D  rgba(181,133,13,1)
5,3: (32,29,14,1)  #201D0E  rgba(32,29,14,1)
6,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
7,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
8,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
9,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
10,3: (30,26,14,1)  #1E1A0E  rgba(30,26,14,1)
11,3: (171,125,13,1)  #AB7D0D  rgba(171,125,13,1)
12,3: (26,23,14,1)  #1A170E  rgba(26,23,14,1)
13,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
14,3: (14,14,14,1)  #0E0E0E  rgba(14,14,14,1)
15,3: (5,5,5,0.94902)  #050505F2  rgba(5,5,5,0.94902)
0,4: (4,4,4,0.94902)  #040404F2  rgba(4,4,4,0.94902)
1,4: (13,13,13,1)  #0D0D0D  rgba(13,13,13,1)
2,4: (19,18,13,1)  #13120D  rgba(19,18,13,1)
3,4: (184,134,13,1)  #B8860D  rgba(184,134,13,1)
4,4: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
5,4: (163,119,13,1)  #A3770D  rgba(163,119,13,1)
6,4: (14,14,13,1)  #0E0E0D  rgba(14,14,13,1)
7,4: (13,13,13,1)  #0D0D0D  rgba(13,13,13,1)
8,4: (13,13,13,1)  #0D0D0D  rgba(13,13,13,1)
9,4: (14,14,13,1)  #0E0E0D  rgba(14,14,13,1)
10,4: (151,112,13,1)  #97700D  rgba(151,112,13,1)
11,4: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
12,4: (170,124,13,1)  #AA7C0D  rgba(170,124,13,1)
13,4: (16,16,13,1)  #10100D  rgba(16,16,13,1)
14,4: (13,13,13,1)  #0D0D0D  rgba(13,13,13,1)
15,4: (4,4,4,0.94902)  #040404F2  rgba(4,4,4,0.94902)
0,5: (4,4,4,0.94902)  #040404F2  rgba(4,4,4,0.94902)
1,5: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
2,5: (84,65,13,1)  #54410D  rgba(84,65,13,1)
3,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
4,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
5,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
6,5: (72,56,12,1)  #48380C  rgba(72,56,12,1)
7,5: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
8,5: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
9,5: (65,51,12,1)  #41330C  rgba(65,51,12,1)
10,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
11,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
12,5: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
13,5: (72,56,12,1)  #48380C  rgba(72,56,12,1)
14,5: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
15,5: (4,4,4,0.94902)  #040404F2  rgba(4,4,4,0.94902)
0,6: (3,3,3,0.94902)  #030303F2  rgba(3,3,3,0.94902)
1,6: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
2,6: (184,133,13,1)  #B8850D  rgba(184,133,13,1)
3,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
4,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
5,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
6,6: (101,74,8,1)  #654A08  rgba(101,74,8,1)
7,6: (5,4,2,1)  #050402  rgba(5,4,2,1)
8,6: (4,4,3,1)  #040403  rgba(4,4,3,1)
9,6: (115,85,8,1)  #735508  rgba(115,85,8,1)
10,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
11,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
12,6: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
13,6: (164,121,12,1)  #A4790C  rgba(164,121,12,1)
14,6: (12,12,12,1)  #0C0C0C  rgba(12,12,12,1)
15,6: (3,3,3,0.94902)  #030303F2  rgba(3,3,3,0.94902)
0,7: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
1,7: (13,12,10,1)  #0D0C0A  rgba(13,12,10,1)
2,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
3,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
4,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
5,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
6,7: (7,6,2,1)  #070602  rgba(7,6,2,1)
7,7: (188,136,11,1)  #BC880B  rgba(188,136,11,1)
8,7: (179,128,11,1)  #B3800B  rgba(179,128,11,1)
9,7: (7,6,2,1)  #070602  rgba(7,6,2,1)
10,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
11,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
12,7: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
13,7: (218,156,13,1)  #DA9C0D  rgba(218,156,13,1)
14,7: (10,10,10,1)  #0A0A0A  rgba(10,10,10,1)
15,7: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
0,8: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
1,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
2,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
3,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
4,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
5,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
6,8: (3,3,2,1)  #030302  rgba(3,3,2,1)
7,8: (188,136,11,1)  #BC880B  rgba(188,136,11,1)
8,8: (184,133,11,1)  #B8850B  rgba(184,133,11,1)
9,8: (4,3,2,1)  #040302  rgba(4,3,2,1)
10,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
11,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
12,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
13,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
14,8: (9,9,9,1)  #090909  rgba(9,9,9,1)
15,8: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
0,9: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
1,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
2,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
3,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
4,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
5,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
6,9: (7,6,5,1)  #070605  rgba(7,6,5,1)
7,9: (5,4,2,1)  #050402  rgba(5,4,2,1)
8,9: (5,4,2,1)  #050402  rgba(5,4,2,1)
9,9: (7,7,6,1)  #070706  rgba(7,7,6,1)
10,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
11,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
12,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
13,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
14,9: (8,8,8,1)  #080808  rgba(8,8,8,1)
15,9: (2,2,2,0.94902)  #020202F2  rgba(2,2,2,0.94902)
0,10: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
1,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
2,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
3,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
4,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
5,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
6,10: (73,56,10,1)  #49380A  rgba(73,56,10,1)
7,10: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
8,10: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
9,10: (79,60,10,1)  #4F3C0A  rgba(79,60,10,1)
10,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
11,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
12,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
13,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
14,10: (8,8,8,1)  #080808  rgba(8,8,8,1)
15,10: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
0,11: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
1,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
2,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
3,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
4,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
5,11: (12,11,7,1)  #0C0B07  rgba(12,11,7,1)
6,11: (208,149,12,1)  #D0950C  rgba(208,149,12,1)
7,11: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
8,11: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
9,11: (216,156,13,1)  #D89C0D  rgba(216,156,13,1)
10,11: (17,15,8,1)  #110F08  rgba(17,15,8,1)
11,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
12,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
13,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
14,11: (7,7,7,1)  #070707  rgba(7,7,7,1)
15,11: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
0,12: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
1,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
2,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
3,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
4,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
5,12: (84,64,9,1)  #544009  rgba(84,64,9,1)
6,12: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
7,12: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
8,12: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
9,12: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
10,12: (108,80,10,1)  #6C500A  rgba(108,80,10,1)
11,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
12,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
13,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
14,12: (6,6,6,1)  #060606  rgba(6,6,6,1)
15,12: (1,1,1,0.94902)  #010101F2  rgba(1,1,1,0.94902)
0,13: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
1,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
2,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
3,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
4,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
5,13: (70,53,9,1)  #463509  rgba(70,53,9,1)
6,13: (179,130,12,1)  #B3820C  rgba(179,130,12,1)
7,13: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
8,13: (226,163,13,1)  #E2A30D  rgba(226,163,13,1)
9,13: (175,127,12,1)  #AF7F0C  rgba(175,127,12,1)
10,13: (63,48,8,1)  #3F3008  rgba(63,48,8,1)
11,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
12,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
13,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
14,13: (6,6,6,1)  #060606  rgba(6,6,6,1)
15,13: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
0,14: (0,0,0,0.556863)  #0000008E  rgba(0,0,0,0.556863)
1,14: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
2,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
3,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
4,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
5,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
6,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
7,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
8,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
9,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
10,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
11,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
12,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
13,14: (5,5,5,1)  #050505  rgba(5,5,5,1)
14,14: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
15,14: (0,0,0,0.556863)  #0000008E  rgba(0,0,0,0.556863)
0,15: (255,255,255,0)  #FFFFFF00  rgba(255,255,255,0)
1,15: (0,0,0,0.556863)  #0000008E  rgba(0,0,0,0.556863)
2,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
3,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
4,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
5,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
6,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
7,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
8,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
9,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
10,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
11,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
12,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
13,15: (0,0,0,0.94902)  #000000F2  rgba(0,0,0,0.94902)
14,15: (0,0,0,0.556863)  #0000008E  rgba(0,0,0,0.556863)
15,15: (255,255,255,0)  #FFFFFF00  rgba(255,255,255,0)
</code></pre>

<p>You can see easily that, except for the first line, each line presents a pixel coordinate followed by the corresponding RGBA color value. You can obtain more information about this format in the <a href=""http://www.imagemagick.org/Usage/files/#txt"" rel=""nofollow noreferrer"">official documentation</a>.</p>

<p>By using some piped shell commands over <code>nuclear.txt</code>, we can generated a hard-coded array of integers in <code>nuclear.cpp</code>:</p>

<pre><code>(echo ""int pixels[] = {""; \
tail -n +2 nuclear.txt | tr -cs '0-9.\n'  ' ' | \
while read x y r g b junk; do echo ""   $x,$y,$r,$g,$b,"";done; \
echo ""-1};"") &gt; nuclear.cpp
</code></pre>

<p>The <code>nuclear.cpp</code> content:</p>

<pre><code>int pixels[] = {
   0,0,255,255,255,
   1,0,43,43,43,
   2,0,43,43,43,
   3,0,43,43,43,
   4,0,43,43,43,
   5,0,43,43,43,
   6,0,43,43,43,
   7,0,43,43,43,
   8,0,43,43,43,
   9,0,43,43,43,
   10,0,43,43,43,
   11,0,43,43,43,
   12,0,43,43,43,
   13,0,43,43,43,
   14,0,43,43,43,
   15,0,255,255,255,
   0,1,42,42,42,
   1,1,42,42,42,
   2,1,90,90,90,
   3,1,90,90,90,
   4,1,90,90,90,
   5,1,90,90,90,
   6,1,90,90,90,
   7,1,90,90,90,
   8,1,90,90,90,
   9,1,90,90,90,
   10,1,90,90,90,
   11,1,90,90,90,
   12,1,90,90,90,
   13,1,90,90,90,
   14,1,42,42,42,
   15,1,42,42,42,
   0,2,40,40,40,
   1,2,89,89,89,
   2,2,69,69,69,
   3,2,69,69,69,
   4,2,74,73,69,
   5,2,69,69,69,
   6,2,69,69,69,
   7,2,69,69,69,
   8,2,69,69,69,
   9,2,69,69,69,
   10,2,69,69,69,
   11,2,73,72,69,
   12,2,69,69,69,
   13,2,69,69,69,
   14,2,89,89,89,
   15,2,40,40,40,
   0,3,37,37,37,
   1,3,67,67,67,
   2,3,67,67,67,
   3,3,96,90,66,
   4,3,219,191,64,
   5,3,100,94,66,
   6,3,67,67,67,
   7,3,67,67,67,
   8,3,67,67,67,
   9,3,67,67,67,
   10,3,96,90,66,
   11,3,214,186,64,
   12,3,90,85,66,
   13,3,67,67,67,
   14,3,67,67,67,
   15,3,37,37,37,
   0,4,35,35,35,
   1,4,65,65,65,
   2,4,77,75,65,
   3,4,221,192,63,
   4,4,242,209,63,
   5,4,209,182,63,
   6,4,67,67,65,
   7,4,65,65,65,
   8,4,65,65,65,
   9,4,67,67,65,
   10,4,202,177,63,
   11,4,242,209,63,
   12,4,213,185,63,
   13,4,71,70,65,
   14,4,65,65,65,
   15,4,35,35,35,
   0,5,32,32,32,
   1,5,62,62,62,
   2,5,155,138,63,
   3,5,242,209,63,
   4,5,242,209,63,
   5,5,242,209,63,
   6,5,145,129,62,
   7,5,62,62,62,
   8,5,62,62,62,
   9,5,138,124,62,
   10,5,242,209,63,
   11,5,242,209,63,
   12,5,242,209,63,
   13,5,145,129,62,
   14,5,62,62,62,
   15,5,32,32,32,
   0,6,28,28,28,
   1,6,60,60,60,
   2,6,221,191,63,
   3,6,242,209,63,
   4,6,242,209,63,
   5,6,242,209,63,
   6,6,169,147,49,
   7,6,37,34,25,
   8,6,34,33,26,
   9,6,179,156,51,
   10,6,242,209,63,
   11,6,242,209,63,
   12,6,242,209,63,
   13,6,210,183,62,
   14,6,60,60,60,
   15,6,28,28,28,
   0,7,25,25,25,
   1,7,64,62,57,
   2,7,242,209,63,
   3,7,242,209,63,
   4,7,242,209,63,
   5,7,242,209,63,
   6,7,46,42,21,
   7,7,223,193,59,
   8,7,218,188,58,
   9,7,46,41,22,
   10,7,242,209,63,
   11,7,242,209,63,
   12,7,242,209,63,
   13,7,238,205,63,
   14,7,57,57,57,
   15,7,25,25,25,
   0,8,22,22,22,
   1,8,54,54,54,
   2,8,54,54,54,
   3,8,54,54,54,
   4,8,54,54,54,
   5,8,54,54,54,
   6,8,29,27,20,
   7,8,223,193,59,
   8,8,221,191,58,
   9,8,32,30,22,
   10,8,54,54,54,
   11,8,54,54,54,
   12,8,54,54,54,
   13,8,54,54,54,
   14,8,54,54,54,
   15,8,22,22,22,
   0,9,18,18,18,
   1,9,51,51,51,
   2,9,51,51,51,
   3,9,51,51,51,
   4,9,51,51,51,
   5,9,51,51,51,
   6,9,45,44,40,
   7,9,38,35,20,
   8,9,37,34,20,
   9,9,47,45,41,
   10,9,51,51,51,
   11,9,51,51,51,
   12,9,51,51,51,
   13,9,51,51,51,
   14,9,51,51,51,
   15,9,18,18,18,
   0,10,15,15,15,
   1,10,48,48,48,
   2,10,48,48,48,
   3,10,48,48,48,
   4,10,48,48,48,
   5,10,48,48,48,
   6,10,146,129,56,
   7,10,242,209,63,
   8,10,242,209,63,
   9,10,151,133,56,
   10,10,48,48,48,
   11,10,48,48,48,
   12,10,48,48,48,
   13,10,48,48,48,
   14,10,48,48,48,
   15,10,15,15,15,
   0,11,12,12,12,
   1,11,46,46,46,
   2,11,46,46,46,
   3,11,46,46,46,
   4,11,46,46,46,
   5,11,62,59,47,
   6,11,233,201,62,
   7,11,242,209,63,
   8,11,242,209,63,
   9,11,237,205,63,
   10,11,74,69,48,
   11,11,46,46,46,
   12,11,46,46,46,
   13,11,46,46,46,
   14,11,46,46,46,
   15,11,12,12,12,
   0,12,9,9,9,
   1,12,43,43,43,
   2,12,43,43,43,
   3,12,43,43,43,
   4,12,43,43,43,
   5,12,155,137,54,
   6,12,242,209,63,
   7,12,242,209,63,
   8,12,242,209,63,
   9,12,242,209,63,
   10,12,174,152,56,
   11,12,43,43,43,
   12,12,43,43,43,
   13,12,43,43,43,
   14,12,43,43,43,
   15,12,9,9,9,
   0,13,6,6,6,
   1,13,41,41,41,
   2,13,41,41,41,
   3,13,41,41,41,
   4,13,43,42,41,
   5,13,143,126,52,
   6,13,218,189,60,
   7,13,242,209,63,
   8,13,242,209,63,
   9,13,216,187,60,
   10,13,136,120,51,
   11,13,43,43,41,
   12,13,41,41,41,
   13,13,41,41,41,
   14,13,41,41,41,
   15,13,6,6,6,
   0,14,4,4,4,
   1,14,4,4,4,
   2,14,39,39,39,
   3,14,39,39,39,
   4,14,39,39,39,
   5,14,39,39,39,
   6,14,39,39,39,
   7,14,39,39,39,
   8,14,39,39,39,
   9,14,39,39,39,
   10,14,39,39,39,
   11,14,39,39,39,
   12,14,39,39,39,
   13,14,39,39,39,
   14,14,4,4,4,
   15,14,4,4,4,
   0,15,255,255,255,
   1,15,2,2,2,
   2,15,2,2,2,
   3,15,2,2,2,
   4,15,2,2,2,
   5,15,2,2,2,
   6,15,2,2,2,
   7,15,2,2,2,
   8,15,2,2,2,
   9,15,2,2,2,
   10,15,2,2,2,
   11,15,2,2,2,
   12,15,2,2,2,
   13,15,2,2,2,
   14,15,2,2,2,
   15,15,255,255,255,
-1};
</code></pre>

<p>Note that each line of the <code>pixels</code> array is formatted as <code>row,col,r,g,b</code> and the last element <code>-1</code> is included intentionally. Once you have pasted this array in your source code, you can use the snippet below for iterating through pixels and showing them on the screen using a custom function:</p>

<pre><code>int i = 0;
while (pixels[i]&gt;-1) {
   int row = pixels[i++];
   int col = pixels[i++];
   int r = pixels[i++];
   int g = pixels[i++];
   int b = pixels[i++];

   //Show the pixel 
   //showPixel(row,col,r,g,b); You need to implement that.
}
</code></pre>

<p>That's it!</p>
",,42968302,144
35601820,2,35601089,2016-02-24T12:09:17.670,0,,5808727,,2016-02-24T12:10:59.333,2016-02-24T12:10:59.333,9,,"<p>Just a wild guess that stdin maybe redirected to something else and you need to read from keyboard directly. try the following code:</p>

<pre><code>FILE *tty = fopen(""/dev/tty"", ""r"");
if (!tty) {
    exit(1);
}
int n=0;
while (n != 'q'){
    n=fgetc(tty); //tried to use scanf() here as well
    printf(""%c"",(char)n);
}
</code></pre>
",,42980922,1282
35618806,2,35617216,2016-02-25T05:05:52.197,1,,5621671,,2016-02-25T05:05:52.197,,1,,"<p>Those symbols are defined in the Arduino.h (<code>hardware/cores/arduino</code>) file:</p>

<pre><code>#ifdef ARDUINO_MAIN
  #define PA 1
  #define PB 2
  #define PC 3
  #define PD 4
  #define PE 5
  #define PF 6
  #define PG 7
  #define PH 8
  #define PJ 10
  #define PK 11
  #define PL 12
#endif
</code></pre>

<p>There are also other things defined in Arduino.h that are used in pins_arduino.h so you may want to take a look at it.</p>
",,42991034,263
35708699,2,35689780,2016-02-29T20:11:16.400,0,,5043289,,2016-02-29T22:24:34.820,2016-02-29T22:24:34.820,2,,"<pre><code>  LT_printf(test_string);                       // doesn't need a cast
  LT_printf((const char *)F(""F TESTING!\r\n"")); // these need a cast
  LT_printf((const char *)&amp;test_struct);
</code></pre>

<p>You can't just cast away a different data type and expect it to work. Presuming that <code>test_string</code> works then it expects to print from RAM and not PROGMEM which is in a separate address space. </p>

<p>The simple solution in your case is to derive the class that <code>LT_printf</code> is in (whatever that is) from <code>Print</code> and then <code>print</code>, <code>println</code> etc. will just work.</p>

<p>For example, I have a library that prints to an I2C LCD. I derive it from <code>Print</code> like this:</p>

<pre><code>class I2C_graphical_LCD_display : public Print
</code></pre>

<p>Now all your class has to do is implement <code>write</code> in your class (ie. writing a single byte) and the <code>Print</code> class takes care of the rest: both writing from RAM and PROGMEM via the <code>F()</code> macro.</p>

<p>My answer doesn't address how to get <code>printf</code> to work, although you could look at <a href=""http://playground.arduino.cc/Main/Printf"" rel=""nofollow"">this</a>.</p>

<p>You might be better off looking at the <a href=""http://arduiniana.org/libraries/streaming/"" rel=""nofollow"">Streaming</a> library which lets you stream output in a C++ style, rather than using printf-style outputting.</p>

<hr>

<p>Here is a simple way of implementing printf (however from RAM only) by adding a couple of helper functions:</p>

<pre><code>int getChar (FILE *fp)
  {
  while (!(Serial.available()));
  return (Serial.read());
  }  // end of getChar

int putChar (char c, FILE *fp)
  {
  Serial.write (c);
  return c;
  }  // end of putChar

void setup ()
  {
  Serial.begin(115200);
  fdevopen (putChar, getChar);
  }  // end of setup

void loop ()
  {
  int temp = 30;

  printf (""The temperature is %d degrees C.\n"", temp);
  delay (100);
  }  // end of loop
</code></pre>

<p><code>fdevopen</code> tells the Standard IO library how to get and put characters. In this particular case I am using <code>Serial</code>, but it could be <code>Serial1</code> or SoftwareSerial, etc.</p>

<hr>

<p>If you want to use PROGMEM constants (ie. <code>F()</code>) then I think the easiest is to use the Streaming library. eg.</p>

<pre><code>#include &lt;Streaming.h&gt;

void setup ()
  {
  Serial.begin (115200);
  }  // end of setup

void loop ()
  {
  int temp = 30;    
  Serial &lt;&lt; F(""The temperature is "") &lt;&lt; temp &lt;&lt; F("" degrees C"") &lt;&lt; endl;
  delay (100);
  }  // end of loop
</code></pre>

<p>That is even more compact, and saves RAM by using the <code>F()</code> macro. It's pretty readable too.</p>
",,43025720,52
35705058,2,35704878,2016-02-29T16:53:35.867,0,,1460794,,2016-02-29T16:56:01.773,2017-05-23T12:23:25.097,2,,"<p>I'm not sure there is a problem with the code posted. The following works for me:</p>

<pre><code>struct ControllerPosition {
    int y,x;

    ControllerPosition(int _y = 0x7FFF,int _x = 0x7FFF) : y(_y),x(_x) {}
};

ControllerPosition mapPosition(int input)
{
    return ControllerPosition((input % 10) * 2 + 1,(input / 10) * 2 + 1);
}

int main()
{
    auto testvar = mapPosition(4);
    return 0;
}
</code></pre>

<p>Have a look at <a href=""https://stackoverflow.com/questions/18635465/arduino-error-does-not-name-a-type"">this post</a> discussing a similar error in more generic terms.</p>
",,43026807,937
35706756,2,35704878,2016-02-29T18:24:10.633,0,,1772477,,2016-02-29T19:09:41.553,2016-02-29T19:09:41.553,0,,"<p>I have found the source of the issue. Arduino IDE finds the functions in a given file puts the prototypes of them at the beginning of a file, which means it puts the prototypes before the struct definition and the function uses the struct as its return type. Therefore the solution was to explicitly declare the prototypes after the definition of the struct. </p>

<p>i.e.
</p>

<pre><code>struct ControllerPosition 
{
  int y;
  int x;
};

ControllerPosition mapPosition(int input);

ControllerPosition mapPosition(int input)
{
  return ControllerPosition((input % 10) * 2 + 1, (input / 10) * 2 + 1);
}
</code></pre>

<p>PS: It is possible to declare the prototypes before the struct by making a class forward declaration <code>struct ControllerPosition;</code>.</p>
",,43052026,42
35723128,2,35723025,2016-03-01T12:36:38.397,3,,597607,,2016-03-01T12:36:38.397,,0,,"<p>Look at this code:</p>

<pre><code>Ctrl (int a1, int a2, int a3, int a4, int a5)
{
  /* 
    b1 = a4; b2 = a5;
    Num1 = F1(a1); Den1 = F2(a1);
    .
    some kind of functions to generate numerators and denominators (arrays)
    .
    Num3 = F1(a3); Den1 = F2(a3);
  */
  TF Block1(Num1, Den1);
  TF Block2(Num2, Den2);
  TF Block3(Num3, Den3);
}
</code></pre>

<p>Here <code>Block1</code>, <code>Block2</code>, and <code>Block3</code> are local variables inside the constructor. As soon as the constructor ends, they are destroyed again.</p>

<p>If they are to persist, they have to be member variables, like <code>b1</code> and <code>b2</code>.</p>
",,43063071,6693
35728425,2,35727864,2016-03-01T16:38:49.027,0,,53089,,2016-03-01T16:38:49.027,,2,,"<p>You are parsing a 32 bit little endian value, not a big endian value. The first byte ends up in the least significant bits; the last byte ends up in the most significant bytes.</p>

<p>If you were converting a buffer which contained a big endian value, the code would look like:</p>

<pre><code>uint8_t a[4];
int value = 0;
for ( int i = 0; i &lt; 4; ++i )
{
    value &lt;&lt; 8 * i;  // shift everything over one byte
    value += a[ i ]; // add the next byte to the LSByte
}
</code></pre>

<p>You see the difference?</p>
",,43088480,39
35754855,2,35740038,2016-03-02T18:06:18.007,2,,5880678,,2016-03-02T18:19:22.833,2016-03-02T18:19:22.833,1,,"<p>You just need to define an appropriate command convention to control your board. In order to keep it simple, I would suggest you always send the value of <code>n</code> adopting the following convention:</p>

<ul>
<li><code>n=0</code>: turn the power off</li>
<li><code>n&gt;0</code>: turn the power on and use the value of <code>n</code> to do your stuff</li>
</ul>

<p>In addition, instead of parsing the received data in Arduino char by char, use the <a href=""https://www.arduino.cc/en/Reference/ParseInt"" rel=""nofollow""><code>Serial.parseInt</code></a> function that is more robust.</p>

<blockquote>
  <p><code>parseInt()</code> returns the first valid (long) integer number from the serial buffer. Characters that are not integers (or the minus sign) are skipped.</p>
</blockquote>

<p>Here is the modified loop function in the Arduino code:</p>

<pre><code>void loop() {
    if (Serial.available() == 1) {

        //Read first int until the comma
        received = Serial.parseInt();

        if (received == 0) { //Power off
            digitalWrite(2, HIGH);
        } else { //Power on and set n
            n = received;
            digitalWrite(2, LOW);
            for(i=0; i&lt;n;i++) {
                delayMicroseconds(300);
                digitalWrite(10, LOW);
                delayMicroseconds(600);
                digitalWrite(10, HIGH);
                delayMicroseconds(300);
            }
            delay(1000);  
        }
    }
}
</code></pre>

<p>Here is the modified C# code: </p>

<pre><code>private void button2_Click(object sender, EventArgs e) {
    string n =  tbgoc.Text.ToString();
    string t = cbPORT.Text.ToString();
    serial(t, n+"",""); //Include a comma as data separator
}
</code></pre>
",,43127524,68
35807180,2,35740112,2016-03-04T22:23:39.270,0,,,user285594,2016-03-04T22:23:39.270,,0,,"<p><strong>it WORKS.</strong></p>

<pre><code>#include &lt;Bridge.h&gt;
#include &lt;HttpClient.h&gt;
String result = String("""");
void setup() {
  delay(5000);
  pinMode(2, OUTPUT);
  Bridge.begin();
  digitalWrite(2, HIGH);

}
boolean was_on = false;
void loop() {
  HttpClient client;

  // PIN 2
  client.get(""http://ok.example.com/ajax/light"");
  delay(500);
  result = """";
  while (client.available()) {
    char c = client.read();
    result = result + c;
  }


  if(result.indexOf(""reboot"") &gt;= 0) {
    digitalWrite(2, LOW);
    delay(2000);
    was_on = true;
  } else {
    if(was_on) {
      digitalWrite(2, HIGH);
      delay(1000);
      was_on = false;
    }
  }

  delay(3000);
}
</code></pre>
",,43194587,797
35759510,2,35755329,2016-03-02T22:32:09.400,1,,5386374,,2017-01-04T22:15:08.260,2017-01-04T22:15:08.260,1,,"<p>Assuming that <code>channelList</code> is null-terminated, and that <code>_channelList</code> is supposed to be a class member, you could try this:</p>

<pre><code>#include &lt;algorithm&gt; // For std::copy().

// ...

template&lt;size_t N&gt; Node::Node(bool isBase, const int (&amp;channelList)[N]) : _isBase(isBase)
{
    std::copy(std::begin(channelList), std::end(channelList), std::begin(_channelList));
}
</code></pre>

<p>Unless I'm missing something, that should take a C-style int array of any size, and copy it into <code>_channelList</code>.  If the passed array is larger than <code>_channelList</code>, it may cause issues.  If possible, you would be better off using a <code>std::array</code> if the size is predetermined, or a <code>std::vector</code> if it isn't.</p>

<hr>

<p>If the size is fixed:</p>

<pre><code>#include &lt;array&gt;
#include &lt;algorithm&gt;  // For std::copy() and std::fill().

const size_t _sz = [whatever];
// Simple way of setting size, but not the best.  See below.

class Node
{
    bool _isBase;
    std::array&lt;int, _sz&gt; _channelList;

    public:
        Node(bool isBase, const int (&amp;channelList)[_sz]);
        Node(bool isBase, const std::array&lt;int, _sz&gt;&amp; channelList);
        // ...
};

/* Alternatively, you can code the size into the class as a magic number (not a good idea),
 * or better yet, make it a template parameter for the class:
 *     template&lt;size_t _sz&gt; class Node
 *     {
 *         bool _isBase;
 *         std::array&lt;int, _sz&gt; _channelList;
 *
 *         public:
 *             Node(/ * parameters * /);
 *
 *             template&lt;size_t N&gt;
 *             Node(/ * parameters * /);
 *         // ...
 *     };
 * When using the class, you would declare an instance as ""Node&lt;SIZE&gt;"", where ""SIZE"" is the
 * desired size.
 *
 * Note that if you make the size a template parameter, and define the member functions
 * outside of the class' definition, you have to put the same template at the start of each
 * member function:
 *     template&lt;size_t _sz&gt; Node&lt;_sz&gt;::Node(/ * parameters * /)
 *     {
 *         // ...
 *     }
 * This also applies to templated member functions, which will have two sets of template
 * parameters.
 *     template&lt;size_t _sz&gt; template&lt;size_t N&gt; Node&lt;_sz&gt;::Node(/ * parameters * /)
 *     {
 *         // ...
 *     }
 */

// Constructor initialising from C array, if you need to work with preexisting code.
Node::Node(bool isBase, const int (&amp;channelList)[_sz]) : _isBase(isBase)
{
    std::copy(std::begin(channelList), std::end(channelList), std::begin(_channelList));
}

// Constructor using std::array.
Node::Node(bool isBase, const std::array&lt;int, _sz&gt;&amp; channelList)
  : _isBase(isBase), _channelList(channelList)
{
    // Initialisation list handles everything.
}

// Note, however, that this will cause issues if the size of channelList doesn't
// necessarily match the size of _channelList.  To solve this, we can change Node as
// follows:
// (Note that delegation requires a C++11-compatible compiler.)

#include &lt;type_traits&gt;  // For std::integral_constant, std::true_type, and std::false_type.

class Node {
    bool _isBase;
    std::array&lt;int, _sz&gt; _channelList;

    // Actual constructors (C-style array):
    template&lt;size_t N&gt;
    Node(std::true_type x, bool isBase, const int (&amp;channelList)[N]);

    template&lt;size_t N&gt;
    Node(std::false_type x, bool isBase, const int (&amp;channelList)[N]);

    // Actual constructors (std::array):
    template&lt;size_t N&gt;
    Node(std::true_type x, bool isBase, const std::array&lt;int, N&gt;&amp; channelList);

    template&lt;size_t N&gt;
    Node(std::false_type x, bool isBase, const std::array&lt;int, N&gt;&amp; channelList);

    public:
        // Public constructors, delegate to one of the actual constructors.
        // C-style array:
        template&lt;size_t N&gt;
        Node(bool isBase, const int (&amp;channelList)[N]);

        // std::array:
        template&lt;size_t N&gt;
        Node(bool isBase, const std::array&lt;int, N&gt;&amp; channelList);

        // ...
};

/* Now, these constructors are easy enough to make.
 * I'll provide an example using C-style arrays.  To make versions that take a
 * std::array instead, change the parameter:
 *     const int (&amp;channelList)[N]
 * to:
 *     const std::array&lt;int, N&gt;&amp; channelList
 * The constructors should work properly with either kind of array.
 */

// Check if passed array is smaller than or equal to _sz, or if it's larger..
template&lt;size_t N&gt; Node::Node(bool isBase, const int (&amp;channelList)[N])
  : Node(std::integral_constant&lt;bool, N &lt;= _sz&gt;{}, isBase, channelList) { }

// N is smaller than or equal to _sz.
template&lt;size_t N&gt; Node::Node(std::true_type x, bool isBase, const int (&amp;channelList)[N])
  : _isBase(isBase)
{
    // Copy channelList into _channelList.
    std::copy(std::begin(channelList), std::end(channelList), std::begin(_channelList));
    // Fill empty space at the end of _channelList.
    std::fill(&amp;(_channelList[N]), std::end(_channelList), '\0');
}

// N is larger than _sz.
template&lt;size_t N&gt; Node::Node(std::false_type x, bool isBase, const int (&amp;channelList)[N])
{
    // Handle appropriately.
}
</code></pre>

<p>This should allow you to get the functionality you want.  [Note that you can also use the above delegation, <code>true_type</code>, and <code>false_type</code> constructors to fill C-style arrays as well as <code>std::array</code>s, if you need to use them.]</p>

<hr>

<p>If the size isn't fixed:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Node {
    bool _isBase;
    std::vector&lt;int&gt; _channelList;

    public:
        template&lt;size_t N&gt;
        Node(bool isBase, const int (&amp;channelList)[N]);

    // ...
};

template&lt;size_t N&gt; Node::Node(bool isBase, const int (&amp;channelList)[N]) : _isBase(isBase)
{
    _channelList.assign(std::begin(channelList), std::end(channelList));
}

// You can also define a constructor that takes a std::array&lt;int, N&gt;, if you
// so desire.  Again, the only change needed is the parameter itself.
</code></pre>

<p>As a vector's length can be changed at runtime, we can use <code>vector::assign</code> to allocate space and store the entirety of <code>channelList</code>.</p>

<hr>

<p>Regardless of whether <code>_channelList</code> is stored as a C array, <code>std::array</code>, or <code>std::vector</code>, it's relatively easy to define getters and setters.</p>

<p>Getter (entire thing):</p>

<pre><code>// All of the following use this class definition, with comments identifying which
// functions use which parts.
// Note that the trailing ""const"" in each getter signature indicates that the function
// cannot be used to modify the instance.  It's optional, but useful to include.
class Node {
    // Return C array (either way).
    int _channelListC[_sz];
    // Return std::array.
    std::array&lt;int, _sz&gt; _channelListSArr;
    // Return std::vector.
    std::vector&lt;int&gt; _channelListSVec;

    // Return C array the readable way.
    typedef int _channelListC_t[_sz];
    // C++11 alternative typedef:
    using _channelListC_t = decltype(_channelList);
    // The C++11 version is safer, as ""decltype(_channelList)"" won't break if you change
    // _channelList's implementation.
    // If you need to return the entire array, it may be a good idea to make this a public
    // typedef, so it's easier &amp; safer to declare a variable you can return it to.

    public:
        // Return C array the ugly way.
        const int (&amp;getChannelListCUgly() const)[_sz];

        // Return C array the readable way.
        const _channelListC_t&amp; getChannelListCReadable() const;

        // Return C array the readable C++11 way.
        auto getChannelListCReadableCPP11() const -&gt; const int(&amp;)[_sz];

        // Return std::array.
        const std::array&lt;int, _sz&gt;&amp; getChannelListSArr() const;

        // Return std::vector.
        const std::vector&lt;int&gt;&amp; getChannelListSVec() const;
};

// Return C array:
/* Note that you can't return an array from a function.  However, you can return a pointer
 * or reference to an array, depending on whether you use * or &amp; in the signature.
 */
// The ugly way:
const int (&amp;Node::getChannelListCUgly() const)[_sz]
{
    return _channelList;
}

// The readable way:
const Node::_channelListC_t&amp; Node::getChannelListCReadable() const
{
    return _channelList;
}

// The new readable way, as of C++11:
auto getChannelListCReadableCPP11() const -&gt; const int(&amp;)[_sz]
{
    return _channelList;
}

// Return std::array:
const std::array&lt;int, _sz&gt;&amp; Node::getChannelListSArr() const
{
    return _channelList;
}

// Return std:;vector:
const std::vector&lt;int&gt;&amp; getChannelListSVec() const
{
    return _channelList;
}
</code></pre>

<p>Note that to my knowledge, a C-style array returned in this manner must be stored in a reference variable.</p>

<pre><code>Node::_channelListC_t&amp; arr = nodeInstance.getChannelListCUgly();
</code></pre>

<p>Getter (single element):</p>

<pre><code>// C array or std::array:
int Node::getChannelListArrElement(int index) const
{
    if (index &lt; _sz)
    {
        // index is valid, return element.
        return _channelList[index];
    }
    else
    {
        // index &gt;= _sz, and is invalid.
        // Handle accordingly.
    }
}

// std::vector:
int Node::getChannelListVecElement(int index) const
{
    if (index &lt; _channelList.size())
    {
        // index is valid.
        return _channelList[index];
    }
    else
    {
        // index is invalid.
        // Handle accordingly.
    }
}
</code></pre>

<p>You can define a setter for the entire thing using the constructors above.  I would suggest using <code>std::fill()</code> to erase the contents of <code>_channelList</code> first, then copying the new array into <code>_channelList</code>.  You can define a setter for single elements using the single-element getter as a basis.</p>

<p>Setter (entire thing):</p>

<pre><code>// Array (either type):
//   ""CHANNEL_LIST_TYPE[N] channelList"" is either ""const int (&amp;channelList)[N]"" or
//   ""std::array&lt;int, N&gt;&amp; channelList"".  Remember to replace it with the correct one in the
//   actual code.

// Public function.
template&lt;size_t N&gt;
void Node::setChannelListArr(CHANNEL_LIST_TYPE[N] channelList)
{
    setChannelListArr(std::integral_constant&lt;bool, N &lt;= _sz&gt;{}, channelList);
}

// Private function, N &lt;= _sz.
template&lt;size_t N&gt;
void Node::setChannelListArr(std::true_type x, CHANNEL_LIST_TYPE[N] channelList)
{
    std::fill(std::begin(_channelList), std::end(_channelList), '\0');
    std::copy(std::begin(channelList), std::end(channelList), std::begin(_channelList));
}

// Private function, N &gt; _sz.
template&lt;size_t N&gt;
void Node::setChannelListArr(std::false_type x, CHANNEL_LIST_TYPE[N] channelList)
{
    // channelList is too large.  Handle appropriately.
}


// std::vector:
//   ""CHANNEL_LIST_TYPE[N]"" is used as above, and should be replaced in your actual code.
//   Also note that you can easily modify this function to accept another vector, by
//   removing the template, making the parameter ""const std::vector&lt;int&gt;&amp; channelList"", and
//   using ""channelList.size()"" in place of ""N"" when calling resize().
template&lt;size_t N&gt;
void Node::setChannelListVec(CHANNEL_LIST_TYPE[N] channelList)
{
    _channelList.resize(N); // Resize _channelList to have N elements.
    std::fill(std::begin(_channelList), std::end(_channelList), '\0');
    std::copy(std::begin(channelList), std::end(channelList), std::begin(_channelList));
}
</code></pre>

<p>Setter (single element):</p>

<pre><code>// Array (either type):
void Node::setChannelListArrElement(int index, int value)
{
    if (index &lt; _sz)
    {
        _channelList[index] = value;
    }
    else
    {
        // index is invalid.  Handle accordingly.
    }
}

// std::vector:
void Node::setChannelListVecElement(int index, int value)
{
    if (index &lt; _channelList.size())
    {
        _channelList[index] = value;
    }
    else
    {
        // index is invalid.  Handle accordingly.
    }
}

// Alternative std::vector setter:
void Node::setChannelListVecElement2(int index, int value)
{
    if (index &gt;= _channelList.size())
    {
        // index is out of bounds.  Resize vector to fit it.
        _channelList.resize(index + 1, '\0');
    }

    // Modify element.
    _channelList[index] = value;
}
</code></pre>

<hr>

<p>Note that this answer assumes that <code>channelList</code> is null-terminated, as it appears to be.  If <code>channelList</code> isn't null-terminated, but you want to stop filling <code>_channelList</code> at the first null element, then you'll have to do a bit more work, likely using your <code>while</code> loop.</p>

<hr>

<p>You can find working examples of most of the above <a href=""http://ideone.com/liO6pN"" rel=""nofollow noreferrer"">here</a>.  It's a bit of a mess, since it's just a quick program I used to test various things while typing up this answer.</p>

<hr>

<p>[My apologies for any typoes and/or errors I may have missed.  I believe I caught them, but there may still be some there.]</p>

<p>[Edit: Added a note about using fixed-size template constructors with C arrays.  Added the C++11 trailing return type way of returning a reference to an array.  Added a simple, working example.]
[Edit: Added an additional single-element setter for a vector.]</p>
",,43200966,676
35768838,2,35755329,2016-03-03T09:59:05.677,1,,3368201,,2016-03-03T09:59:05.677,,0,,"<p>Justin Time's answer is the correct way to implement this in C++ (using arrays and vectors natively handled by C++)</p>

<p>I just have to add this solution, which is the correct way to implement what you tried to do in C (i.e. using char arrays).</p>

<p>There are two problems in your code</p>

<ol>
<li><code>_channelList</code> is NOT tied to the <code>Node</code> object, but is a somewhat static member.</li>
<li><code>_channelList</code> is never allocated, so it points to nothing.</li>
<li>not a real problem, but usually <code>'\0'</code> is the string terminator. Ok, it maps to <code>0</code>, but you should just use a <code>0</code> here</li>
</ol>

<p>There are two solutions here. The first one is to give <code>_channelList</code> a fixed MAXIMUM size (maximum means that if the passed <code>channelList</code> is shorter you will get a shorter list, ok, but the allocated memory will still be the maximum one).</p>

<pre><code>// File Node.h
#define MAXIMUM_CHANNELS    10
class Node {
    public:
        Node(boolean isBase, int *channelList);
        boolean isBase();
        int* getChannelList();

    private:
        int _channelList[MAXIMUM_CHANNELS + 1]; // Last one is the terminator
};

// File Node.cpp
include ""Arduino.h""
#include ""Node.h""
#include &lt;ESP8266WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;

Node::Node(boolean isBase, int *channelList)
{
    _isBase = isBase;
    int channelListLength;
    // Get channel list lenght
    for (channelListLength = 0; channelList[channelListLength] != 0; channelListLength++);

    if (channelListLength &gt; MAXIMUM_CHANNELS)
        channelListLength = MAXIMUM_CHANNELS;

    int i;
    for (i = 0; i &lt; channelListLength; i++)
        _channelList[i] = channelList[i];
    _channelList[channelListLength] = 0; // Enforce the last one to be a 0
}

boolean Node::isBase(){
    return _isBase;
}

int* Node::getChannelList(){
    return _channelList;
}
</code></pre>

<p>The second method dynamically allocates the memory for the array. You should, however, dispose it when you are done with the object (in the destructor). This means that if you create the <code>Node</code> variable you are ok (for instance, <code>Node mynode;</code>). If, however, you dynamically allocate it (with <code>Node *p_mynode = new Node();</code> you will need to call a <code>delete</code> on it when you are done.</p>

<pre><code>// File Node.h
class Node {
    public:
        Node(boolean isBase, int *channelList);
        ~Node(); // destructor (called at object destruction)
        boolean isBase();
        int* getChannelList();

    private:
        int *_channelList;
};

// File Node.cpp
include ""Arduino.h""
#include ""Node.h""
#include &lt;ESP8266WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;

Node::Node(boolean isBase, int *channelList)
{
    _isBase = isBase;
    int channelListLength;
    // Get channel list lenght
    for (channelListLength = 0; channelList[channelListLength] != 0; channelListLength++);

    _channelList = (int*)malloc((channelListLength+1)*sizeof(int));
    if (_channelList != NULL)
    {
        int i;
        for (i = 0; i &lt;= channelListLength; i++)
            _channelList[i] = channelList[i];
        // No need to enforce the last one to be a 0
    }
}

~Node()
{
    free(_channelList);
}

boolean Node::isBase(){
    return _isBase;
}

int* Node::getChannelList(){
    return _channelList;
}
</code></pre>

<p>Note, however, that if the <code>malloc</code> fails you will have a <code>NULL</code> pointer. In theory it should not fail, unless you run out of ram...</p>

<p>Just one more thing. Using a 0-terminated int array is not a good idea, because if you have something like this <code>{ 15, 3, 0, 5, 10 }</code> and then the terminator you will just get the first two numbers. It would be MUCH better to explicitely tell the array size (and save it in the object)</p>

<pre><code>// File Node.h
class Node {
    [...]
    private:
        int *_channelList;
        int _channelListLength;
};

// File Node.cpp
Node::Node(boolean isBase, int *channelList, int channelListLength)
{
    _isBase = isBase;

    _channelListLength = channelListLength;
    _channelList = (int*)malloc((_channelListLength)*sizeof(int));
    if (_channelList != NULL)
    {
        int i;
        for (i = 0; i &lt;= _channelListLength; i++)
            _channelList[i] = channelList[i];
    }
}

...

int Node::getChannelListLength(){
    return _channelListLength;
}
</code></pre>
",,43205485,180
40213585,2,35784700,2016-10-24T08:13:44.117,3,,5492179,,2016-10-24T08:13:44.117,,0,,"<p>The reason is you have used two version of cmake to generate the Makefile.</p>

<pre><code>cd /path/to/opencv
rm -rf build
mkdir build
cd build
cmake ..
</code></pre>

<p>that will be work fine.</p>

<ul>
<li>Installing OpenCV 2.4.9 in Ubuntu 14.04 LTS
<a href=""http://www.samontab.com/web/2014/06/installing-opencv-2-4-9-in-ubuntu-14-04-lts/"" rel=""nofollow"">http://www.samontab.com/web/2014/06/installing-opencv-2-4-9-in-ubuntu-14-04-lts/</a></li>
</ul>
",,43218883,188
35902215,2,35793246,2016-03-09T20:44:41.330,1,,5552095,,2016-03-09T20:44:41.330,,0,,"<p>You would have to either declare the <code>MqttClient</code> as a pointer, and initialise it after mounting SPIFFS, or put the SPIFFS mounting code inside the constructor of the client class (Which probably isn't what you want).</p>

<p>To do the former, your code would look something like this:</p>

<pre><code>MqttClient *mqtt;

void init()
{
   spiffs_mount(); // Mount file system, in order to work with files
   AppSettings.load();
   mqtt = new MqttClient(AppSettings.MQTTUWL, 1883, msgRev);
   //...
}
</code></pre>

<p>This will only create the client after mounting has completed. </p>
",,43219965,3353
35836781,2,35835070,2016-03-07T05:30:27.403,2,,4100891,,2016-03-07T05:30:27.403,,2,,"<p>TL;DR - see Nick's Answer.  :-)</p>

<p>Without the complete code, I can only guess at a few things:</p>

<p><strong>1)</strong> You shouldn't wait in an ISR.  Even calling <code>millis()</code> is discouraged, as it depends on the Timer0 ISR getting called, which will be prevented as long as you're in your <code>openadoor</code> ISR.</p>

<p><strong>2)</strong> In general, the ISR should only do things that are very quick... think microseconds.  That's tens to hundreds of instructions, which can be just a few lines of code.  Even <code>digitalWrite</code> is almost too slow.  If there's more to do, you should just set a <code>volatile</code> flag that is watched in <code>loop</code>.  Then <code>loop</code> can do the time-consuming work.</p>

<p><strong>3)</strong> Calculating elapsed time <em>must</em> be in this form:</p>

<pre><code>if (millis() - startTime &gt;= DESIRED_TIME)
</code></pre>

<p>where <code>startTime</code> is the same type as <code>millis()</code>, a <code>uint32_t</code>:</p>

<pre><code>uint32_t startTime;
</code></pre>

<p>You set <code>startTime</code> whereever it's appropriate:</p>

<pre><code>startTime = millis();
</code></pre>

<p>This avoids the rollover problem, when <code>millis()</code> rolls over from <strong>2<sup>32</sup>-1</strong>  to <strong>0</strong>.</p>

<p><strong>4)</strong> It looks like you know how to ""block"" until a certain amount of time has elapsed: the <code>while</code> loop will keep your sketch at that point.  If you just change it to an <code>if</code> statement, the Arduino can continue on its way to handle other things.</p>

<p>Because <code>loop</code> happens so quickly, the <code>if</code> statement will check the time very frequently... unless you <code>delay</code> or block somewhere else, like <code>wait_for_esp_response</code>.  :-(  That while loop should change to an <code>if</code> statement as well.  The routine is more like <code>check_for_esp_response</code>.</p>

<p><strong>5)</strong> You have to track the state of the door opening and closing process.  This is a <a href=""https://en.wikipedia.org/wiki/Finite-state_machine"" rel=""nofollow"">Finite-State machine</a> problem.  Nick has a good description <a href=""http://www.gammon.com.au/statemachine"" rel=""nofollow"">here</a>, too.  You can use the <code>enum</code> type to define the states that the door can be in: CLOSED, OPENING, OPENED and CLOSING.</p>

<p>When the OPEN button is pressed, you can look at the state and see if you should start opening it.  Then start a timer, turn on the relay and, most importantly, set the state to OPENING.  Next time through <code>loop</code>, you can test the state (a <code>switch</code> statement), and for the OPENING case, look at the time to see if it has been long enough.  If it has set the state to OPENED.  And so on.</p>

<p>If I incorporate all these things into your sketch, it should start to look like this:</p>

<pre><code>volatile bool doorOpenPressed = false;
volatile bool doorClosePressed = false;

static const uint32_t DOOR_OPEN_TIME  = 30000UL; // ms
static const uint32_t DOOR_CLOSE_TIME = 30000UL; // ms
static const uint32_t DATA_SAMPLE_TIME = 60000UL; // ms

static uint32_t lastDataTime, sentTime, relayChanged;

static bool waitingForResponse = false;
static uint8_t responseLen = 0;

enum doorState_t { DOOR_CLOSED, DOOR_OPENING, DOOR_OPENED, DOOR_CLOSING };
doorState_t doorState = DOOR_CLOSED;

void setup()
{
  attachInterrupt(4 , openadoor, FALLING);
}

void loop()
{
  //  Is it time to take another sample?

  if (millis() - lastDataTime &gt; DATA_SAMPLE_TIME) {
    lastDataTime = millis();
    gathersomedata();

    //  You may want to read all Serial2 input first, to make
    //  sure old data doesn't get mixed in with the new response.
    senddatatoESP();
    sentTime = millis();

    waitingForResponse = true;
    responseLen = 0; // ready for new response
  }

  //  If we're expecting a response, did we get it?

  if (waitingForResponse) {
    if (check_for_esp_response(""OK"")) {
      // Got it!
      lightGreenLED();
      waitingForResponse = false;

    } else if (millis() - sentTime &gt; 2000UL) {
      // Too long!
      lightRedLED();
      waitingForResponse = false;

    } // else, still waiting
  }

  // Check and handle the door OPEN and CLOSE buttons,
  //   based on the current door state and time

  switch (doorState) {

    case DOOR_CLOSED:
      if (doorOpenPressed) {
        digitalWrite(DoorOpenRelay, LOW);
        relayChanged = millis();
        doorState = DOOR_OPENING;
      }
      break;

    case DOOR_OPENING:
      //  Has the door been opening long enough?
      if (millis() - relayChanged &gt; DOOR_OPEN_TIME) {
        digitalWrite(DoorOpenRelay, HIGH);
        doorState = DOOR_OPENED;

      } else if (!doorOpenPressed &amp;&amp; doorClosePressed) {
        // Oops, changed their mind and pressed the CLOSE button.

        // You may want to calculate a relayChanged time that
        //   is set back from millis() based on how long the
        //   door has been opening.  If it just started opening,
        //   you probably don't want to drive the relay for the
        //   full 30 seconds.
           ...
      }
      break;

    case DOOR_OPENED:
      if (doorClosePressed) {
        ...
      }
      break;

    case DOOR_CLOSING:
      if (millis() - relayChanged &gt; DOOR_CLOSE_TIME) {
        ...
      }
      break;
  }
}

void openadoor()
{
  doorOpenPressed = true;
}

bool check_for_esp_response(const char* term)
{
  bool found = false;

  if (Serial2.available()) {
      // You should make sure you're not running off the end
      //   of ""buffer"" here!
      buffer[responseLen++] = Serial2.read();

      int len = strlen(term);
      if (responseLen &gt;= len) {
          if (strncmp(buffer + responseLen - len, term, len) == 0) {
              found = true;
          }
      }
  }

  return found;
}
</code></pre>

<p>The key is that you don't block or delay anywhere.  <code>loop</code> gets called over and over, and it just checks a few variables.  Most of the time, there's nothing to do.  But sometimes, based on the state or the current time, it gathers some data, sends it, reads the response, and opens or closes the door.  These actions do not interfere with each other, because there are no blocking <code>while</code> loops, only quick checks with <code>if</code> statements.</p>
",,43251424,110
35838145,2,35837910,2016-03-07T07:15:59.290,0,,1891266,,2016-03-07T10:20:15.720,2016-03-07T10:20:15.720,1,,"<p>This should work for you:</p>

<p>Function <code>recieveNum</code> should return <code>-1</code> to indicator invalid input:</p>

<pre><code>int recieveNum(int inputDeg) 
{
  inputDeg = Serial.parseInt();
  if (inputDeg &gt;= 0 &amp;&amp; inputDeg &lt;= 180) {
    Serial.println(""You did great!"");
    return degree;
  } else {
    Serial.println(""Hey! Try giving me a number between 0 and 180 this time."");
  }
  return -1; 
  ^^^^^^^^^
}

void loop() 
{
  if (Serial.available() != 0) 
  {
     if(-1 != recieveNum(deg))
     { // Valid 'deg'
       int finalAng = servoTranslate(degree);
       Serial.print(""  Servo moved "");
       Serial.print(degree);
       Serial.print("" tick(s) to "");
       Serial.print(finalAng);
       Serial.println(""º"");
     }
  } 
  myServo.write(finalAng);
}
</code></pre>
",,43262647,259
35843044,2,35842994,2016-03-07T11:52:45.360,2,,4062354,,2016-03-07T11:52:45.360,,1,,"<p>You should call constructor of <code>SoftwareSerial</code> via initializer list.</p>

<p>The constructor of class <code>pH</code> should be like this:</p>

<pre><code>public: pH(uint8_t tx, uint8_t rx, long pHgap)
  : SerialPort(rx, tx) // this is initializer list
{
  Gap = pHgap;
}
</code></pre>
",,43285966,54
35843096,2,35842994,2016-03-07T11:55:05.290,1,,3111051,,2016-03-07T11:55:05.290,,0,,"<pre><code>class pH
{
  int Stable;
  unsigned long previousMillis;
  long Gap;
  //SoftwareSerial pHrs(100,100);
  //SoftwareSerial portOne(100, 100);
  //SoftwareSerial pHrs = new SoftwareSerial(90,90);
  SoftwareSerial SerialPort;

  // Constructor - creates a pH
  // and initializes the member variables and state
  public: 
    pH(uint8_t tx, uint8_t rx, long pHgap)
      : SoftwareSerial(/* You should initalize your base class */) // &lt;---
    {
      Gap = pHgap;
      //SerialPort(rx, tx);
    }
};
</code></pre>

<p>You should initialize your base class in your constructor.</p>
",,43286860,958
35845588,2,35842994,2016-03-07T13:55:22.607,0,,3925839,,2016-03-07T13:55:22.607,,0,,"<p>Both suggestions are right.</p>

<pre><code>public: pH(uint8_t tx, uint8_t rx, long pHgap)
  : SerialPort(rx, tx) // this is initializer list
{
  Gap = pHgap;
}
</code></pre>

<p>is what i needed.Thank You.</p>
",,43291522,44
35848272,2,35843869,2016-03-07T15:58:46.327,0,,3861548,,2016-03-07T15:58:46.327,,4,,"<p>Declare a string in loop():</p>

<pre><code>String number ="""";
</code></pre>

<p>Concat the character read from file:</p>

<pre><code>while (myFile.available()) {

  number.concat(myFile.read());

}
</code></pre>

<p>Concat number to <code>AT-comand</code>:</p>

<pre><code>serialSIM800.write(""AT+CMGS=\""+44""+number+""\""\r\n"");
</code></pre>

<p>That's the idea but could you do it in many ways.</p>
",,43347331,123
35892297,2,35879948,2016-03-09T12:57:59.353,0,,2836621,,2016-03-26T15:05:47.763,2016-03-26T15:05:47.763,1,,"<p><strong>Updated Answer</strong></p>

<p>I have been doing some further tests on this. Using the <code>iperf</code> tool and my own simple TCP connection code as well, I connected two Raspberry Pis directly to each other over wired Ethernet and measured the TCP performance.</p>

<p>Using the standard, built-in 10/100 interface on a Raspberry Pi 2 and a Raspberry Pi 3, you can achieve 94Mbits/s.</p>

<p>If, however, you put a TRENDnet USB3 Gigabit adaptor on each Pi, and repeat the test, you can get 189Mbits/s and almost 200 if you set the MTU to 4088.</p>

<p><strong>Original Answer</strong></p>

<p>I made a quick test - not a full answer - but more than I can add as a comment or format correctly!</p>

<p>I set up 2 Raspberry Pi 2s with a wired Ethernet connection. I took a 640x480 picture on one as a JPEG - and it came out at 178,000 bytes.</p>

<p>Then, on the receiving Pi, I set up to receive 1,000 frames. Like this:</p>

<pre><code>#!/bin/bash
for ((i=0;i&lt;1000;i++)); do
   echo $i
   nc -l 1234 &gt; pic-${i}.jpg
done
</code></pre>

<p>On the sending Pi, I set up to transit the picture 1,000 times:</p>

<pre><code>for ((i=0;i&lt;1000;i++)) ; do nc 192.168.0.65 1234 &lt; pipic1.jpg ;done
</code></pre>

<p>That took 34 seconds, so it does 33 fps roughly but it stuttered a lot because of writing to the filesystem and therefore SD card. So, I removed the </p>

<p>nc -l 1234 > pic-${i}.jpg</p>

<p>and didn't write the data to disk - which is what you will need as you are writing to the screen, as follows:</p>

<pre><code>nc -l 1234 &gt; /dev/null
</code></pre>
",,43413718,61
35901011,2,35898926,2016-03-09T19:36:35.870,2,,421195,,2016-03-09T19:36:35.870,,0,,"<p>This snippet compiles fine under GCC/Linux and MSVS 2015/Windows.</p>

<p>Q: Does it work for you?  Is it OK with the Arduino IDE?  </p>

<p>Q: Does it fail with ""error: 'T' does not name a type"" with Arduino (Visual Micro)?  Have you contacted Visual Micro?</p>

<pre><code>#include &lt;stdio.h&gt;

typedef unsigned char byte;

class A {
public:
  void write(int &amp; ee, const byte &amp;p) { }
};

A EEPROM;

template &lt;class T&gt; int EEPROM_writeAnything(int ee, const T&amp; value)
{
    const byte* p = (const byte*)(const void*)&amp;value;
    unsigned int i;
    for (i = 0; i &lt; sizeof(value); i++)
          EEPROM.write(ee++, *p++);
    return i;
}

int main (int argc, char *argv[]) {
  printf (""Hello world\n"");
}
</code></pre>
",,43416844,68
35901148,2,35898926,2016-03-09T19:43:02.163,6,,866670,,2016-03-09T19:43:02.163,,0,,"<p>I think i got the answer. You need to add declaration for the functions in Visual Studio manually. </p>

<pre><code>template &lt;class T&gt; int EEPROM_writeAnything(int ee, const T&amp; value);
template &lt;class T&gt; int EEPROM_readAnything(int ee, T&amp; value);
</code></pre>

<p>but whereas Arduino IDE preprocess your source code and adds these automatically for you behind the scene. So it works in Arduino IDE.</p>

<p>Hint : When you enable verbose output in your arduino IDE, refer to the temporary path in which the intermediate files generated during compilation is saved. It should be something like %temp%\build0094e6ca87558f1142f08e49b0685193.tmp\sketch . It should have the following statements .</p>

<pre><code>#line 2 ""C:\\Users\\Sound\\Documents\\Arduino\\sketch_mar10d\\sketch_mar10d.ino""
template &lt;class T&gt; int EEPROM_writeAnything(int ee, const T&amp; value);
#line 11 ""C:\\Users\\Sound\\Documents\\Arduino\\sketch_mar10d\\sketch_mar10d.ino""
template &lt;class T&gt; int EEPROM_readAnything(int ee, T&amp; value);
#line 21 ""C:\\Users\\Sound\\Documents\\Arduino\\sketch_mar10d\\sketch_mar10d.ino""
</code></pre>

<p>To know more about this, read <a href=""https://www.arduino.cc/en/Hacking/BuildProcess"" rel=""noreferrer"">here</a>. </p>
",,43417444,1320
35904873,2,35904556,2016-03-09T23:39:52.377,1,,5082337,,2016-03-10T09:33:51.153,2016-03-10T09:33:51.153,1,,"<p><code>telNo = (myFile.read());</code> does that compile? What is the type of <code>telNo</code>? If it's an <code>int</code> or some other numerical, you won't get that result you want because <code>read()</code> reads characters and not numbers.. The 10 that you see is the ascii code for the <code>newline</code> character ('\n') which is the first character in the file (that's why you get your number below the <code>CONFIG.DAT:</code>). </p>

<p><code>read()</code> reads a byte at a time and returns -1 if none is available. To get the whole content, you should use a loop to read one character at a time and append those characters to a <code>char[]</code>: </p>

<pre><code>unsigned int MAX_SIZE = 100; 
char string[MAX_SIZE];
unsigned int index = 0;
char next_char;
while (next_char = myfile.read()) string[index++] = next_char;
string[index] = '/0'; // terminate with the null character
</code></pre>

<p>Now, if you really want an <code>int</code>, you need to filter out the <code>newline</code>, the <code>+</code> and any other non-valid digit and then cast your number to <code>int</code>:</p>

<pre><code>char new_string[MAX_SIZE];
unsigned int i = 0, unsigned int j = 0;
while (i &lt; MAX_SIZE) {  
    if ((string[i] &gt;= 48) &amp;&amp; (string[i] &lt;= 57)) 
        new_string[j++] = string[i++];  
    else i++;  
}  
int number = atoi(new_string);
</code></pre>
",,43427063,119
35906232,2,35904556,2016-03-10T01:58:50.700,0,,3370876,,2016-03-10T01:58:50.700,,0,,"<p>I think I found an answer as follows</p>

<pre><code>// read from the file until there's nothing else in it:
while (myFile.available()) {

            char ltr = myFile.read();
            number += ltr;      

} 
</code></pre>

<p>This was found at <a href=""http://forum.arduino.cc/index.php?topic=87524.0"" rel=""nofollow"">Text file on SD to String</a></p>
",,43441730,820
35952489,2,35952105,2016-03-12T01:03:15.953,-1,,4254365,,2016-03-12T18:08:50.880,2016-03-12T18:08:50.880,2,,"<p>There are many questions here. You are probably better off using processing or python for this cause you need to use it on the raspberry pi which is linux. Any header files or libraries you use that are windows based will not work in linux and unless your running ubuntu setting up opencv in linux can be a real pain. Processing is cross platform and has opencv libraries that run and are also seen as an extension of arduino code as the syntax is very similar. This is where I would start. </p>

<p>as for the red light here are some simple steps</p>

<p>pick a region of intrest ""roi"" for the stop sign in the center of the camera a square that is about 25-50 percent of the center of the frame then search through the roi pixel by pixel for the color red. if x percent of the roi is red there is a stop sign in front of the camera. </p>

<p>yes downvote the guy with working code </p>

<p><a href=""https://www.facebook.com/photo.php?fbid=913451218754261&amp;set=a.138550599577664.26406.100002681733815&amp;type=3&amp;theater"" rel=""nofollow"">https://www.facebook.com/photo.php?fbid=913451218754261&amp;set=a.138550599577664.26406.100002681733815&amp;type=3&amp;theater</a></p>

<pre><code> /**
   * MultipleColorTracking
   * Select 2 colors to track them separately
   *
   * It uses the OpenCV for Processing library by Greg Borenstein
   */


import gab.opencv.*;
import processing.video.*;
import java.awt.Rectangle;

Capture video;
OpenCV opencv;
PImage src;
ArrayList&lt;Contour&gt; contours;

int maxColors = 2;
int[] hues;
int[] colors;
int rangeWidth = 10;

PImage[] outputs;

int colorToChange = -1;

void setup() {
  video = new Capture(this, 640, 480);
  opencv = new OpenCV(this, video.width, video.height);
  contours = new ArrayList&lt;Contour&gt;();

  size(opencv.width + opencv.width/4 + 30, opencv.height, P2D);

  // Array for detection colors
  colors = new int[maxColors];
  hues = new int[maxColors];

  outputs = new PImage[maxColors];

  video.start();
}

void draw() {

  background(150);

  if (video.available()) {
    video.read();

  }

  // &lt;2&gt; Load the new frame in to OpenCV
  opencv.loadImage(video);

  // Tell OpenCV to use color information
  opencv.useColor();
  src = opencv.getSnapshot();

  // &lt;3&gt; Tell OpenCV to work in HSV color space.
  opencv.useColor(HSB);

  detectColors();

  // Show images
  image(src, 0, 0);
  for (int i=0; i&lt;outputs.length; i++) {
    if (outputs[i] != null) {
      image(outputs[i], width-src.width/4, i*src.height/4, src.width/4, src.height/4);

      noStroke();
      fill(colors[i]);
      rect(src.width, i*src.height/4, 30, src.height/4);
    }
  }

  // Print text if new color expected
  textSize(20);
  stroke(255);
  fill(255);

  if (colorToChange &gt; -1) {
    text(""click to change color "" + colorToChange, 10, 25);
  } else {
    text(""press key [1-2] to select color"", 10, 25);
  }

  displayContoursBoundingBoxes();
}

//////////////////////
// Detect Functions
//////////////////////

void detectColors() {

  for (int i=0; i&lt;hues.length; i++) {

    if (hues[i] &lt;= 0) continue;

    opencv.loadImage(src);
    opencv.useColor(HSB);

    // &lt;4&gt; Copy the Hue channel of our image into 
    //     the gray channel, which we process.
    opencv.setGray(opencv.getH().clone());

    int hueToDetect = hues[i];
    //println(""index "" + i + "" - hue to detect: "" + hueToDetect);

    // &lt;5&gt; Filter the image based on the range of 
    //     hue values that match the object we want to track.
    opencv.inRange(hueToDetect-rangeWidth/2, hueToDetect+rangeWidth/2);

    //opencv.dilate();
    opencv.erode();

    // TO DO:
    // Add  some image filtering to detect blobs better

    // &lt;6&gt; Save the processed image for reference.
    outputs[i] = opencv.getSnapshot();
  }

  if (outputs[0] != null) {

    opencv.loadImage(outputs[0]);
    contours = opencv.findContours(true,true);
  }
}

void displayContoursBoundingBoxes() {

  for (int i=0; i&lt;contours.size(); i++) {

    Contour contour = contours.get(i);
    Rectangle r = contour.getBoundingBox();

    if (r.width &lt; 20 || r.height &lt; 20)
      continue;

    stroke(255, 0, 0);
    fill(255, 0, 0, 150);
    strokeWeight(2);
    rect(r.x, r.y, r.width, r.height);
  }
}

//////////////////////
// Keyboard / Mouse
//////////////////////

void mousePressed() {

  if (colorToChange &gt; -1) {

    color c = get(mouseX, mouseY);
    println(""r: "" + red(c) + "" g: "" + green(c) + "" b: "" + blue(c));

    int hue = int(map(hue(c), 0, 255, 0, 180));

    colors[colorToChange-1] = c;
    hues[colorToChange-1] = hue;

    println(""color index "" + (colorToChange-1) + "", value: "" + hue);
  }
}

void keyPressed() {

  if (key == '1') {
    colorToChange = 1;

  } else if (key == '2') {
    colorToChange = 2;

  }
}

void keyReleased() {
  colorToChange = -1; 
}
</code></pre>

<p>after you detect the color you compare it with your roi if enough of your roi has detected the color then there is a stop sign! create a bool value for seeing a stop sign and when it's true process the rest of your code. </p>
",,43506217,83
35961578,2,35952105,2016-03-12T18:23:27.300,0,,4254365,,2016-03-12T18:23:27.300,,0,,"<p>example explaining roi using opencv processing library. You just download processing 2.0 or higher and import the library using the easy import tool opencv for processing. I'm not going to do your whole project for you. Create a static roi in the center of the frame and if detect color is with in the roi you have a stop sign in front of you see the working code below to detect threshold colors.      </p>

<pre><code>import gab.opencv.*;

PImage src;
OpenCV opencv;

int roiWidth = 300;
int roiHeight = 300;

boolean useROI = true;

void setup() {
  src = loadImage(""test.jpg"");
  opencv = new OpenCV(this, src);
  size(opencv.width, opencv.height);
}

void draw() {
  opencv.loadImage(src);

  if (useROI) {
    opencv.setROI(mouseX, mouseY, roiWidth, roiHeight);
  }

  opencv.findCannyEdges(20,75);
  image(opencv.getOutput(), 0, 0);
}

// toggle ROI on and off
void keyPressed() {
  useROI = !useROI;

  if (!useROI) {
    opencv.releaseROI();
  }
}
</code></pre>
",,43555829,4425
38493750,2,35966790,2016-07-21T02:12:27.993,0,,3179963,,2016-07-21T02:12:27.993,,0,,"<p>I suggest you use the i2c-tools(i2cdetect) to test the hardware connection first.</p>

<p>Before your run the i2cdetect, you need to config these gpio pins for Edison:</p>

<pre><code>echo 28 &gt; /sys/class/gpio/export
echo 27 &gt; /sys/class/gpio/export
echo 204 &gt; /sys/class/gpio/export
echo 205 &gt; /sys/class/gpio/export
echo 236 &gt; /sys/class/gpio/export
echo 237 &gt; /sys/class/gpio/export
echo 14 &gt; /sys/class/gpio/export
echo 165 &gt; /sys/class/gpio/export
echo 212 &gt; /sys/class/gpio/export
echo 213 &gt; /sys/class/gpio/export
echo 214 &gt; /sys/class/gpio/export
echo low &gt; /sys/class/gpio/gpio214/direction
echo low &gt; /sys/class/gpio/gpio204/direction
echo low &gt; /sys/class/gpio/gpio205/direction
echo in &gt; /sys/class/gpio/gpio14/direction
echo in &gt; /sys/class/gpio/gpio165/direction
echo low &gt; /sys/class/gpio/gpio236/direction
echo low &gt; /sys/class/gpio/gpio237/direction
echo in &gt; /sys/class/gpio/gpio212/direction
echo in &gt; /sys/class/gpio/gpio213/direction
echo mode1 &gt; /sys/kernel/debug/gpio_debug/gpio28/current_pinmux
echo mode1 &gt; /sys/kernel/debug/gpio_debug/gpio27/current_pinmux
echo high &gt; /sys/class/gpio/gpio214/direction
</code></pre>
",,43572367,37
35984789,2,35981302,2016-03-14T10:17:50.227,0,,5668691,,2016-03-14T10:17:50.227,,7,,"<p>Okay as it is little tricky, I will tell you what are the steps required to do that.As it is really a tricky one many would not prefer to give the appropriate answer, never the less these are the step you can follow.</p>

<p>1.what you have to do is you can first write  a kernel module. Then You can compile that to generate the <code>.ko</code> file. Which is a loadable kernel module. Write a loadable kernel module in which you can keep an ISR(Interrupt Service Routine) that gets executed when there is an interrupt comes to any particular GPIO. For your information ISR is also a function that automatically gets executed when there is an interrupt received to a particular GPIO.</p>

<p>Keep a provision in your kernel module, to accept the application layer <code>Process ID</code>, so that as soon as there comes an interrupt to the <code>GPIO</code>, the module can send a <code>SIGNAL</code> from Kernel layer to application Layer.</p>

<p>2.Copy that to your <code>ARM target processor</code> and then insert the module to the kernel. You can insert the module by typing</p>

<pre><code>             `insmod &lt;your_module.ko&gt;`
</code></pre>

<ol start=""3"">
<li>Check if the Module has inserted or not by typing <code>lsmod</code> Command on to the terminal of your <code>AM335x</code> target board.</li>
</ol>

<p>3.Then you can write the user level application, where you can send the <code>processID</code> of the process from the application layer to the kernel layer as soon as your process starts running. SO that the kernel module you have written can get the application layer <code>ProcessID</code> to send the <code>SIGNAL</code>.</p>

<p>NOTE: As Linux by default uses the first <code>32</code> <code>SIGNAL</code> so you can use the <code>SIGNAL</code> number from <code>33 to 64</code> for your purpose. Here we are using <code>SIGNAL Number 44</code>.</p>

<p>Example of the Kernel Module:</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/gpio.h&gt;                 //! &lt;&lt; Required for the GPIO functions
#include &lt;linux/interrupt.h&gt;            //! &lt;&lt; Required for the IRQ code

#include &lt;asm/siginfo.h&gt;            //! &lt;&lt; siginfo
#include &lt;linux/rcupdate.h&gt;         //! &lt;&lt; rcu_read_lock
#include &lt;linux/sched.h&gt;            //! &lt;&lt; find_task_by_pid_type
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/uaccess.h&gt;


MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Sudipta Kumar Sahoo"");
MODULE_DESCRIPTION(""A SPI GPIO Interrupt driver for the Sitara"");
MODULE_VERSION(""1.0"");

#define SIG_TEST 44             //! &lt;&lt; we choose 44 as our signal number
                    //! &lt;&lt; (real-time signals are in the range of 33 to 64)
struct dentry *file;

int gPID = 0;
int Return = 0;
struct siginfo stGInfo;
struct task_struct *stGTask;

//static unsigned int resetGPIOInterrupt = 115;   //! &lt;&lt; hard coding the Delphino Interrupt gpio for this in BB P9_27 (GPIO115)
static unsigned int resetGPIOInterrupt = 54;
static unsigned int irqNumber;                 //! &lt;&lt; Used to share the IRQ number within this file
static unsigned int numberPresses = 0;         //! &lt;&lt; For information, store the number of times the SIGNAL is high.

/********************************************************************************/
/**
 * \fn    write_pid(struct file *file, const char __user *buf,
 *                                                  size_t count, loff_t *ppos)
 *
 * @brief The LKM write_pid function
 *        The static keyword restricts the visibility of the function
 *        to within this C file.
 *  
 * @return returns 0 if successful
 */
/********************************************************************************/
static ssize_t write_pid(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
        char mybuf[10];
        int pid = 0;
        int ret;
        struct siginfo info;
        struct task_struct *stTask;
        /* read the value from user space */
        if(count &gt; 10)
    {
        return -EINVAL;
    }

        copy_from_user(mybuf, buf, count);      //! &lt;&lt; Copy the Process ID from the Application Process

    /* For Global variables value assignment starts */
    /******************************************************************************************/
    //! Copy the required information to Global variables to send SIGNAL from ISR
    sscanf(mybuf, ""%d"", &amp;gPID);         //! &lt;&lt; Copy to global PID
    memset(&amp;stGInfo, 0, sizeof(struct siginfo));
    stGInfo.si_signo = SIG_TEST;
        //! &lt;&lt; this is bit of a trickery: SI_QUEUE is normally used by sigqueue from user space,
        //! &lt;&lt; and kernel space should use SI_KERNEL. But if SI_KERNEL is used the real_time data
        //! &lt;&lt; is not delivered to the user space signal handler function.
    stGInfo.si_code = SI_QUEUE;
    stGInfo.si_int = 1024;
    /*For Global variables value assignment Ends */
    /******************************************************************************************/

        /* send a SIGNAL to the process to intimate that it received the corresponding PID. */
        sscanf(mybuf, ""%d"", &amp;pid);
        printk(""pid = %d\n"", pid);
        memset(&amp;info, 0, sizeof(struct siginfo));
        info.si_signo = SIG_TEST;
        //! &lt;&lt; this is bit of a trickery: SI_QUEUE is normally used by sigqueue from user space,
        //! &lt;&lt; and kernel space should use SI_KERNEL. But if SI_KERNEL is used the real_time data
        //! &lt;&lt; is not delivered to the user space signal handler function.
        info.si_code = SI_QUEUE;
        info.si_int = 1234;                     //! &lt;&lt; real time signals may have 32 bits of data.

        rcu_read_lock();                //! &lt;&lt; Get the RCU Read lock
    //t = find_task_by_pid_type(PIDTYPE_PID, pid);  //! &lt;&lt; find the task_struct associated with this pid
        stTask = pid_task(find_pid_ns(pid, &amp;init_pid_ns), PIDTYPE_PID);
        if(stTask == NULL)
        {
                printk(""no such pid\n"");
                rcu_read_unlock();
                return -ENODEV;
        }
        rcu_read_unlock();              //! &lt;&lt; Make the RCU Read unlock

        ret = send_sig_info(SIG_TEST, &amp;info, stTask);    //! &lt;&lt;send the signal
        if (ret &lt; 0)
        {
                printk(""error sending signal\n"");
                return ret;
        }
        return count;
}

/********************************************************************************/
/**
 * @brief The LKM mapping user defiend functions to file_operations structure.
 */
/********************************************************************************/
static const struct file_operations my_fops = {
        .write = write_pid,
};

/********************************************************************************/
/**
 * @brief Function prototype for the custom IRQ handler function
 *        see below for the implementation.
 */
/********************************************************************************/
static irq_handler_t  ebbgpio_irq_handler(unsigned int irq, void *dev_id, struct pt_regs *regs);

/********************************************************************************/
/**
 * \fn    __init ebbgpio_init(void)
 *
 *  @brief The LKM initialization function. The static keyword restricts the
 *         visibility of the function to within this C file. The __init macro
 *         means that for a built-in driver (not a LKM) the function is only used
 *         at initialization time and that it can be discarded and its memory
 *         freed up after that point. In this example this function sets up the
 *         GPIOs and the IRQ
 *
 *  @return returns 0 if successful
 */
/********************************************************************************/
static int __init ebbgpio_init(void)
{
   int result = 0;
   printk(KERN_INFO ""GPIO_TEST: Initializing the GPIO_TEST LKM\n"");
   // Is the GPIO a valid GPIO number (e.g., Sitara has 4x32 but not all available)
   if (!gpio_is_valid(resetGPIOInterrupt))
   {
      printk(KERN_INFO ""GPIO_TEST: invalid Button GPIO\n"");
      return -ENODEV;
   }
   //Going to set up the Button. It is a GPIO in input mode and will be zero  by default
   //gpio_set_value(gpioLED, ledOn);                   //! Not required as set by line above (here for reference)
   gpio_request(resetGPIOInterrupt, ""sysfs"");       //! Set up the gpioButton
   gpio_direction_input(resetGPIOInterrupt);        //! Set the resetGPIOInterrupt GPIO to be an input
   gpio_set_debounce(resetGPIOInterrupt, 200);      //! Debounce the resetGPIOInterrupt with a delay of 200ms
   gpio_export(resetGPIOInterrupt, false);          //! Causes gpio115 to appear in /sys/class/gpio
                                           //! the bool argument prevents the direction from being changed

   // Perform a quick test to see that the resetGPIOInterrupt is working as expected on LKM load
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt state is currently: %d\n"", gpio_get_value(resetGPIOInterrupt));

   // GPIO numbers and IRQ numbers are not the same! This function performs the mapping for us
   irqNumber = gpio_to_irq(resetGPIOInterrupt);
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt is mapped to IRQ: %d\n"", irqNumber);

   // This next call requests an interrupt line
   result = request_irq(irqNumber,                       //! The interrupt number requested
                        (irq_handler_t) ebbgpio_irq_handler, //! The pointer to the handler function below
                        IRQF_TRIGGER_RISING,             //! Interrupt on rising edge (When The Signal is High-1 not at Low-0)
                        ""ebb_gpio_handler"",              //! Used in /proc/interrupts to identify the owner
                        NULL);                           //! The *dev_id for shared interrupt lines, NULL is okay

   printk(KERN_INFO ""GPIO_TEST: The interrupt request result is: %d\n"", result);

   /* we need to know the pid of the user space process
   * -&gt; we use debugfs for this. As soon as a pid is written to 
   * this file, a signal is sent to that pid
   */
   /* only root can write to this file (no read) */
   file = debugfs_create_file(""signalconfpid"", 0200, NULL, NULL, &amp;my_fops);

   return result;
}


/********************************************************************************/
/**
 *  \fn    __init ebbgpio_init(void)
 *
 *  @brief The LKM cleanup function Similar to the initialization function,
 *         it is static. The __exit macro notifies that if this code is used for
 *         a built-in driver (not a LKM) that this function is not required. Used
 *         to release the GPIOs and display cleanup messages.
 *
 *  @return returns NULL
 */
/********************************************************************************/
static void __exit ebbgpio_exit(void)
{
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt state is currently: %d\n"", gpio_get_value(resetGPIOInterrupt));
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt was received %d times\n"", numberPresses);

   free_irq(irqNumber, NULL);                          //! &lt;&lt; Free the IRQ number, no *dev_id required in this case.
   gpio_unexport(resetGPIOInterrupt);               //! &lt;&lt; Unexport the resetGPIOInterrupt GPIO.
   gpio_free(resetGPIOInterrupt);                   //! &lt;&lt; Free the resetGPIOInterrupt GPIO.

   debugfs_remove(file);                   //! &lt;&lt;  Remove the debugfs file.
   printk(KERN_INFO ""GPIO_TEST: Unloading the GPIO_TEST LKM module!\n"");
}

/********************************************************************************/
/**
 *  \fn    ebbgpio_irq_handler(void)
 *  @brief The GPIO IRQ Handler function. This function is a custom interrupt
 *         handler that is attached to the GPIO above. The same interrupt handler
 *         cannot be invoked concurrently as the interrupt line is masked out
 *         until the function is complete. This function is static as it should
 *         not be invoked directly from outside of this file.
 *
 *  @param irq    the IRQ number that is associated with the GPIO--useful for logging.
 *
 *  @param dev_id the *dev_id that is provided -- can be used to identify which
 *                                                device caused the interrupt
 *                                      (Not used in this case as NULL is passed.)
 *
 *  @param regs   h/w specific register values -- only really ever used for debugging.
 *
 *  @return returns IRQ_HANDLED if successful -- should return IRQ_NONE otherwise.
 */
/********************************************************************************/
static irq_handler_t ebbgpio_irq_handler(unsigned int irq, void *dev_id, struct pt_regs *regs)
{
   printk(KERN_INFO ""GPIO_TEST: Interrupt! (resetGPIOInterrupt state is %d)\n"", gpio_get_value(resetGPIOInterrupt));
   numberPresses++;                         // Global counter, will be outputted when the module is unloaded

   /* Sending The Signal to Process Starts */
   rcu_read_lock();
   stGTask = pid_task(find_pid_ns(gPID, &amp;init_pid_ns), PIDTYPE_PID);
   printk(""sending signal From ISR\n"");
   if(stGTask == NULL)
   {
      printk(""no such pid\n"");
      rcu_read_unlock();
      return -ENODEV;
   }
   rcu_read_unlock();

   //This is the Line Important for You. Where we are sending the Signal to the Application layer
   Return = send_sig_info(SIG_TEST, &amp;stGInfo, stGTask);    //send the signal

   if (Return &lt; 0)
   {
      printk(""error sending signal\n"");
      return Return;
   }
   /* Sending The Signal to Process Ends */

   return (irq_handler_t) IRQ_HANDLED;      // Announce that the IRQ has been handled correctly
}

/********************************************************************************/
/// This next calls are  mandatory -- they identify the initialization function
/// and the cleanup function (as above).
/********************************************************************************/
module_init(ebbgpio_init);
module_exit(ebbgpio_exit);
</code></pre>

<p>You can straight forward take the code and generate .ko file for that. Just take care to configure the <code>appropriate GPIO</code> Number as per your requirement. I have configured <code>GPIO-54</code> The code has been written for <code>AM335x</code> processor Only. If you do not know how to create <code>.ko</code> file then just be cool and google <code>""HOW TO BUILD A KERNEL MODULE""</code>, you will get it easily.</p>

<p>Finally you can write a dummy application to test it, The application looks as follow:</p>

<pre><code>/********************************************************************************/
/**
 * @file   userApplication.c
 *
 * @author Sudipta Kumar Sahoo
 *
 * @brief  An Application layer programm implementation to connect with the
 *     kernel layer, That receives the interrupt from the kernel space
 *     once the particular interrupt is received at configured GPIO pin.
 *
 *     NOTE:: Before executing the program first mount the debugfs if it has
 *     not already mounted to the file system and then execute the application
 *     to receive the interrupt Signal in applicatio layer.
 *
 *  The copyright notice does not evidence any actual or intended publication.
*/
/********************************************************************************/

#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

#define SIG_TEST    44 /* we define our own signal, hard coded since SIGRTMIN
                is different in user and in kernel space */ 
#define RUNNING     1
/********************************************************************************/
/**
 * \fn    void signalHandler(int n, siginfo_t *info, void *unused)
 *
 * @brief The receiveData function
 *        The function has been registered to the kernel layer debugfs file system
 *        When GPIO gets the interrupt it intimates to appliation process via
 *    signalHandler() function and the appropriate action is taken afterwards.
 *  
 * @return NULL
 */
/********************************************************************************/
void signalHandler(int n, siginfo_t *info, void *unused)
{
    printf(""Application received value %i\n"", info-&gt;si_int);
    /* Do what ever you want to do inside this Function upon the receival of the Interrupt */
}

int main ( int argc, char **argv )
{
    int configfd;
    char buf[10];

    /* setup the signal handler for SIG_TEST 
     * SA_SIGINFO -&gt; we want the signal handler function with 3 arguments
     */
    struct sigaction sig;

    sig.sa_sigaction = signalHandler;
    sig.sa_flags = SA_SIGINFO;
    sigaction(SIG_TEST, &amp;sig, NULL);

    /* kernel needs to know our pid to be able to send us a signal -&gt;
     * we use debugfs for this -&gt; do not forget to mount the debugfs!
     */
    configfd = open(""/sys/kernel/debug/signalconfpid"", O_WRONLY);
    if(configfd &lt; 0)
    {
        printf(""Could not Open the File\n"");
        perror(""open"");
        return -1;
    }

    sprintf(buf, ""%i"", getpid());               //! &lt;&lt; Get the process ID.

    if (write(configfd, buf, strlen(buf) + 1) &lt; 0)      //! &lt;&lt; Write the details to Kernel Space.
    {
        perror(""fwrite""); 
        return -1;
    }

    /*
     * Making the Application to run independently
     */
    while(RUNNING)
    {
        printf(""Waiting for Interrup Signal...\n"");
        sleep(1);
    }

    return 0;
}
</code></pre>

<p><code>signalHandler()</code> is the function in your application layer that gets executed when there an interrupt comes to the particular configured <code>GPIO</code>. Now you can run your application independently and also you will be able to receive the interrupt with out polling</p>

<p><em>""The examples are self explanatory and appropriate comments has been given for your understanding""</em></p>

<p>Hope this Helps.</p>
",,43594815,66
35991568,2,35991092,2016-03-14T15:27:36.040,1,,98328,,2016-03-14T15:34:21.913,2016-03-14T15:34:21.913,7,,"<p>If you want to add an item to the end of the vector, use the push_back method you've quoted above. If you want to add an item somewhere else in the vector, you'll need to add your own method which re-sizes if necessary, shifts the elements above the insert location up one place and then copies the new element into the correct slot. Something like this (untested):</p>

<pre><code>void insert_at(size_t idx, Data const &amp;data) {
    assert(idx &lt; d_size);
    if (d_capacity == d_size) {
        resize();
    }
    for (size_t i = d_size; i &gt; idx; --i) {
        d_data[i] = std::move(d_data[i - 1]);
    }
    d_data[idx] = data;
    ++d_size;
}
</code></pre>

<p>As Nacho points out, you might be better off with a linked list if you're going to do a lot of these insert operations, especially if the data you're storing is large and/or has a complex move operator.</p>
",,43654042,2113
36000723,2,36000243,2016-03-15T00:39:11.250,2,,1443182,,2016-03-15T01:09:59.237,2016-03-15T01:09:59.237,0,,"<p>As pointed out in the comments above it was the URLEncoder that was changing the String. I have now changed this method to</p>

<pre><code>private void writeCommand(String command)
{
    for (BluetoothGattCharacteristic characteristic : characteristics)
    {
        if ((characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) &gt;0)
        {
            characteristic.setValue(command);
            gatt.writeCharacteristic(characteristic);
        }else{
            Log.i(TAG,""non write able"");
        }
    }
}
</code></pre>
",,43655520,57
36045292,2,36044770,2016-03-16T19:31:17.313,1,,6024122,,2016-03-16T20:00:24.877,2016-03-16T20:00:24.877,1,,"<p>The function printing numbers in Arduino is defined in <strong>/arduino-1.0.5/hardware/arduino/cores/arduino/Print.cpp</strong></p>

<pre><code>size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &amp;buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base &lt; 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
    char c = m - base * n;
    *--str = c &lt; 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
</code></pre>

<p>All other functions rely on this one, so yes your <strong>int</strong> gets promoted to an <strong>unsigned long</strong> when you print it, not when you shift it. </p>

<p>However, the library is correct. By shifting left 8 positions, the negative bit in the integer number becomes '1', so when the integer value is promoted to unsigned long the runtime correctly pads it with 16 extra '1's instead of '0's. </p>

<p>If you are using such a value not as a number but to contain some flags, use <strong>unsigned int</strong> instead of <strong>int</strong>.</p>

<hr>

<p>ETA: for completeness, I'll add further explanation for the second shifting operation.</p>

<p>Once you touch the 'negative bit' inside the <strong>int</strong> number, when you shift towards right the runtime pads the number with '1's in order to preserve its negative value. Shifting to the left <strong>k</strong> positions corresponds to dividing the number by <strong>2^k</strong>, and since the number is negative to start with then the result must remain negative.</p>
",,43666376,48
36059758,2,36058764,2016-03-17T11:50:50.080,0,,3248493,,2016-03-17T11:50:50.080,,0,,"<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  int nHex = 0xC697C63B;
  char pHexStr[100];
  sprintf(pHexStr,""%x"",nHex);
  fprintf(stdout, ""%s"", pHexStr);

  return 0;
}
</code></pre>
",,43682584,277
36097896,2,36097861,2016-03-19T04:37:11.693,3,,951890,,2016-03-19T04:43:46.557,2016-03-19T04:43:46.557,1,,"<p>It looks like this line is intended to be an assignment statement:</p>

<pre><code>rd = new RetirementDisplay(&amp;update_lcd);
</code></pre>

<p>but statements must be inside functions, like this:</p>

<pre><code>#include ""RetirementDisplay.h""

void myfunction()
{
    RetirementDisplay* rd;
    rd = new RetirementDisplay(&amp;update_lcd);
}
</code></pre>

<p>However, variable declarations can be outside functions, so that is why you don't get an error on this line:</p>

<pre><code>RetirementDisplay* rd = new RetirementDisplay(&amp;update_lcd);
</code></pre>
",,43687487,120
36141775,2,36116398,2016-03-21T21:17:21.577,0,,877375,,2016-03-21T21:17:21.577,,5,,"<p>If you use this example for the Arduino Serial documentation do you receive the chars you send?</p>

<pre><code>int incomingByte = 0;   // for incoming serial data

void setup() {
    Serial.begin(9600); // opens serial port, sets data rate to 9600 bps
}

void loop() {

    // send data only when you receive data:
    if (Serial.available() &gt; 0) {
        // read the incoming byte:
        incomingByte = Serial.read();

        // say what you got:
        Serial.print(""I received: "");
        Serial.println(incomingByte, DEC);
    }
}
</code></pre>
",,43693115,477
36385636,2,36116398,2016-04-03T12:51:26.223,0,,877375,,2016-04-03T19:57:28.920,2016-04-03T19:57:28.920,1,,"<p>Grasping at straws here, replace my comments below a one second delay. Editing on iPhone messed with the format a little, but I believe you can see my intent.</p>

<p>Edit: Also, I think you should not do serial->close inside your loop. I would also try sending a single character repeatedly until we have that working.</p>

<pre><code>void myThread::run()
{
    QSerialPort *serial = new QSerialPort();
    serial-&gt;setPortName(""COM3"");
    serial-&gt;setBaudRate(QSerialPort::Baud9600);
    serial-&gt;setDataBits(QSerialPort::Data8);
    serial-&gt;open(QIODevice::WriteOnly);

if (serial-&gt;isOpen() &amp;&amp; serial-&gt;isWritable())
{
    QByteArray    ba(QString::number(depth_).toStdString().c_str());
    serial-&gt;write(""x"");
            delay 1 second here
    serial-&gt;flush();
            delay 1 second here
}

serial-&gt;close();
            delay 1 second here
delete serial;
}
</code></pre>
",,43695121,1178
36172545,2,36149942,2016-03-23T07:56:38.667,2,,6097521,,2016-03-23T07:56:38.667,,0,,"<p>Problem solved, I've modified the make file by adding the CAN and arduPi libraries and linked them to the main file.</p>

<p>This is how it looks like the file:</p>

<pre><code>#Ref http://stackoverflow.com/questions/30114662/clion-cmake-and-poco
cmake_minimum_required(VERSION 3.3)
project(WebSocketServerCPP)
# define the project
set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -std=c++11 -lrt -lpthread"")
set(SOURCE_FILES main.cpp)
add_executable(WebSocketServerCPP ${SOURCE_FILES})
# set the POCO paths and libs
set(POCO_PREFIX ""/usr/local"") # the directory containing ""include"" and ""lib""
set(POCO_INCLUDE_DIR""${POCO_PREFIX}/include"")
set(POCO_LIB_DIR ""${POCO_PREFIX}/lib"")
set(POCO_LIBS
        ""${POCO_LIB_DIR}/libPocoNet.so""
        ""${POCO_LIB_DIR}/libPocoUtil.so""
        ""${POCO_LIB_DIR}/libPocoFoundation.so"")
add_library(libcan STATIC CAN.cpp)
add_library(libardupi STATIC arduPi.cpp)
# set the include path for the app
target_include_directories(WebSocketServerCPP PRIVATE $(POCO_INCLUDE_DIR))
# link the app against POCO
target_link_libraries(libcan libardupi)
target_link_libraries(WebSocketServerCPP libcan)
target_link_libraries(WebSocketServerCPP libardupi)
target_link_libraries(WebSocketServerCPP ""${POCO_LIBS}"")
</code></pre>

<p>Thank you  Tsyvarev.</p>

<p>Best regards,
Matei</p>
",,43705519,377
36174060,2,36170616,2016-03-23T09:19:27.760,3,,5043289,,2016-03-24T10:15:06.527,2016-03-24T10:15:06.527,8,,"<pre><code>class LedCube {
  private:
  int _x, _y, _z;
  byte _lPins[_y];
  byte _cPins[_z][_x];
</code></pre>

<p>The above code doesn't make any sense, Arduino or not. (Bear in mind Arduino uses C++).</p>

<p>You are trying to define arrays <code>_lPins</code> and <code>_cPins</code> which have lengths <code>_x, _y, _z</code> which are uninitialized. A class has to have a fixed size, so that when you instantiate it, the compiler knows how much memory to allocate it (before calling the constructor). How can it allocate memory for unknown sized arrays?</p>

<hr>

<p><em>(Edited to add)</em></p>

<blockquote>
  <p>I think StackOverflow has a constructive answers policy. Please do give a solution if you think I did something wrong (which is why I am here).</p>
</blockquote>

<p>I'm interested to know why you accept an answer which says ""Your code: ... is wrong."" but take offence at mine. The accepted answer posts no solution code, just some guidelines.</p>

<p>This code of yours, not in the class definition, also makes the same mistake:</p>

<pre><code>int _x, _y, _z;
//bool frame[y][z][x] = {0};
byte _lPins[_y];
byte _cPins[_z][_x];
</code></pre>

<p>That also generates an error. You can't declare a static array like that, with bounds of <code>x, _y, _z</code> where <code>x, _y, _z</code> are not constants. The array won't redefine its length in the future when you change <code>x, _y, _z</code>.</p>

<hr>

<p>In your constructor you are passing as an argument, a name _x which is also a class variable.</p>

<pre><code>LedCube::LedCube(int x, int y, int z, byte lPins[], byte cPins[][_x]) {
</code></pre>

<hr>

<p>C++ doesn't let you assign arrays like this:</p>

<pre><code> _lPins = lPins;
 _cPins = cPins;
</code></pre>

<hr>

<p>You have a lot of errors, not just one, eg.</p>

<pre><code>LedCube:20: error: 'frame' was not declared in this scope
LedCube:21: error: '_lPins' was not declared in this scope
</code></pre>

<p>You really should go through and clean them all up. </p>

<hr>

<blockquote>
  <p>Likewise, IIRC, new and delete are also not provided on your platform </p>
</blockquote>

<p>Actually the Arduino provides <code>new</code> and <code>delete</code>, as well as <code>malloc</code> and <code>free</code>.</p>

<hr>

<p>I'm trying to be constructive, but there is no one-line fix. A rework is needed, sorry to tell you. And you might want to do some C++ tutorials. The code you are writing (although I can see what you are trying to do) is you <em>hoping</em> that the language works in a certain way, when it just doesn't.</p>

<hr>

<h3>Possible implementation</h3>

<p>Below is a possible way of allocating the pin structures in the constructor, based on supplied array sizes. I don't think this is a great implementation, but at least it works. The <code>showPins</code> function shows that the data has been correctly retained.</p>

<pre><code>class LedCube {
  private:
    const int x_, y_, z_;
    byte * lPins_;
    byte * cPins_;
  public:
    LedCube(const int x, const int y, const int z, byte *lPins, byte *cPins);  // constructor

    void showPins () const;
};

byte lPins [3] = { 5, 6, 7 };
byte cPins [2] [4] = {
    { 1, 2, 3, 4 },    // 0
    { 8, 9, 10, 11 },  // 1
};

LedCube::LedCube (const int x, const int y, const int z, byte *lPins, byte *cPins)
    : x_ (x), y_ (y), z_ (z)
  {
  lPins_ = new byte [y];
  cPins_ = new byte [x * z];
  if (lPins_ == NULL || cPins_ == NULL)
    exit (1);
  memcpy (lPins_, lPins, sizeof (byte) * y);
  memcpy (cPins_, cPins, sizeof (byte) * x * z);
  }

void LedCube::showPins () const
  {
  Serial.println (F(""lPins:""));
  for (int i = 0; i &lt; y_; i++)
    Serial.println (lPins_ [i]);
  Serial.println (F(""cPins:""));
  for (int j = 0; j &lt; x_; j++)
    {
    Serial.print (F(""z = ""));
    Serial.println (j);
    for (int k = 0; k &lt; z_; k++)
      Serial.println (cPins_ [j * z_ + k]);
    } 
  }

LedCube foo (2, 3, 4, (byte *) lPins, (byte *) cPins);

void setup() 
{
  Serial.begin (115200);
  Serial.println ();
  foo.showPins ();
}

void loop() 
{

}
</code></pre>

<p>Output:</p>

<pre><code>lPins:
5
6
7
cPins:
z = 0
1
2
3
4
z = 1
8
9
10
11
</code></pre>
",,43708927,479
36190693,2,36188155,2016-03-23T23:32:49.777,3,,6047952,,2017-04-24T15:07:40.360,2017-04-24T15:07:40.360,10,,"<p>The answer to the question really depends on what is receiving the data being sent by the Serial class.</p>

<p>If it's human eyes reading, then you apparently are looking to actually print a decimal number.</p>

<p>If you are trying to pass it to another program who will reassemble two or more messages into a 64bit number, that's a different problem.</p>

<p>But if it's for a human to read, from the arduino forums comes this example sketch on how to print a <code>long long</code></p>

<pre><code>long long x = 999999999999LL;  // note the double LL

void setup()
{
  Serial.begin(115200);
  Serial.println(""I am Arduino"");
  char buffer[100];
  sprintf(buffer, ""%0ld"", x/1000000L);
  Serial.print(buffer); 
  sprintf(buffer, ""%0ld"", x%1000000L);
  Serial.println(buffer); 
}

void loop() {}
</code></pre>

<p><a href=""http://forum.arduino.cc/index.php?topic=58697.msg422207#msg422207"" rel=""nofollow noreferrer"">http://forum.arduino.cc/index.php?topic=58697.msg422207#msg422207</a></p>

<p>EDIT
The observation in the comments that the modulus of 1,000,000,000 (a billion) can be used instead of 1,000,000 (a million) to allow a larger range is correct. But since an unsigned 64 bit number can represent up to 18446744073709551615, that is still more than 18 times a billion squared.   So even a modulus of a billion isn't perfect, After dividing by a billion, the result will not fit into a 32 bit integer.  A billion billion can fit into a 60 bit number</p>

<p>[ACADEMIC ANNEX because the question does not seem to be coming off hold ]</p>

<p>Three ways it can be done, geared more to look how, rather than optimized
The third one is probably good enough to be a real answer</p>

<pre><code>// Here is the totally unoptimized version to help you understand
// the low level of what needs to be done.   Lots of leading zeros
// because its easier that way.
// no one would do it this way except to learn the basic idea
void PrintNumberV1(unsigned long long num)
{
    Serial.print((unsigned)((num / 10000000000000000000LL) % 10));
    Serial.print((unsigned)((num /  1000000000000000000LL) % 10));
    Serial.print((unsigned)((num /   100000000000000000LL) % 10));
    Serial.print((unsigned)((num /    10000000000000000LL) % 10));
    Serial.print((unsigned)((num /     1000000000000000LL) % 10));
    Serial.print((unsigned)((num /      100000000000000LL) % 10));
    Serial.print((unsigned)((num /       10000000000000LL) % 10));
    Serial.print((unsigned)((num /        1000000000000LL) % 10));
    Serial.print((unsigned)((num /         100000000000LL) % 10));
    Serial.print((unsigned)((num /          10000000000LL) % 10));
    Serial.print((unsigned)((num /           1000000000LL) % 10));
    Serial.print((unsigned)((num /            100000000LL) % 10));
    Serial.print((unsigned)((num /             10000000LL) % 10));
    Serial.print((unsigned)((num /              1000000LL) % 10));
    Serial.print((unsigned)((num /               100000LL) % 10));
    Serial.print((unsigned)((num /                10000LL) % 10));
    Serial.print((unsigned)((num /                 1000LL) % 10));
    Serial.print((unsigned)((num /                  100LL) % 10));
    Serial.print((unsigned)((num /                   10LL) % 10));
    Serial.print((unsigned)((num /                    1LL) % 10));
}

// This is the way they'll show you in CompSci 101 when they want to
// to teach you about recursion, neglecting to mention how much stack
// and time it takes.  No leading zeros, because it's easier that way
void PrintNumberV2(unsigned long long num)
{
    int digit = num % 10;

    // do any more significant digits
    if (num &gt; 9) PrintNumberV2(num / 10);

    // Print the digit this level of recursion has decided on
    Serial.print(digit);
}

// The way a C programmer might do it if he didn't have printf right there
// For extra fun you can use any base between 2 and 16
// No leading zeros because its easier
void PrintNumberV3(int base, unsigned long long num )
{
    const static char toAscii[] = ""0123456789ABCDEF"";

    if ((base &lt; 2) || (base&gt;16))
    {
        Serial.print(""[DON'T USE THAT BASE!!!]"");
        return;
    }

    char buffer[65];            //because you might be doing binary
    char* p = &amp;buffer[64];      //this pointer writes into the buffer, starting at the END

    // zero to terminate a C type string
    *p = 0;

    // do digits until the number reaches zero
    do
    {
        // working on the least significant digit
        //put an ASCII digit at the front of the string
        *(--p) = toAscii[(int)(num % base)];

        //knock the least significant digit off the number
        num = num / base;
    } while (num != 0);

    //print the whole string
    Serial.print(s);
}
</code></pre>

<p>Warning:  None of these have been tried on an actual Arduino</p>
",,43711313,1310
36192873,2,36192067,2016-03-24T03:40:40.567,0,,1556820,,2016-03-24T03:48:23.947,2016-03-24T03:48:23.947,1,,"<p>how about trying this:</p>

<pre><code>    byte myData[20];

((long int*)myData)[0] = count;
((long int*)myData)[1] = microSec;
((short int*)myData)[4] = ax;
((short int*)myData)[5] = ay;
((short int*)myData)[6] = az;
((short int*)myData)[7] = gx;
((short int*)myData)[8] = gy;
((short int*)myData)[9] = gz;

myFile3.write(myData, sizeof(myData));
</code></pre>
",,43711548,75
36213716,2,36192067,2016-03-25T03:49:38.057,0,,5859808,,2016-03-25T03:49:38.057,,0,,"<p>Thanks guys! The problem is solved with hundreds tests (lack of C coding skill level really bothers me on Arduino coding...) </p>

<p>Here is new code (edit by @frarugi87 's suggestion)</p>

<pre><code>byte myData[20];
  *((long int *)(myData+0)) = count;
  *((long int *)(myData+4)) = microSec;
  *((short int *)(myData+8)) = ax;
  *((short int *)(myData+10)) = ay;
  *((short int *)(myData+12)) = az;
  *((short int *)(myData+14)) = gx;
  *((short int *)(myData+16)) = gy;
  *((short int *)(myData+18)) = gz;
</code></pre>

<p>it's really works and Data is right, for example </p>

<p>data: 0C 6A 30 00</p>

<p>answer : 3172876</p>

<p>and I also find another way to do it:</p>

<pre><code>  myFile3.write( (byte*)&amp;count, sizeof(long));
  myFile3.write( (byte*)&amp;microSec, sizeof(long));
  myFile3.write( (byte*)&amp;ax, sizeof(short));
  myFile3.write( (byte*)&amp;ay, sizeof(short));
  myFile3.write( (byte*)&amp;az, sizeof(short));
  myFile3.write( (byte*)&amp;gx, sizeof(short));
  myFile3.write( (byte*)&amp;gy, sizeof(short));
  myFile3.write( (byte*)&amp;gz, sizeof(short));
</code></pre>

<p>it works too and the data format is same as the first coding way.</p>

<p>Regards!</p>
",,43713008,9576
36205031,2,36200295,2016-03-24T16:19:23.597,2,,4057102,,2016-03-24T17:32:47.627,2016-03-24T17:32:47.627,0,,"<blockquote>
  <p>The idea is to create a wrapper for function that will call said function when the object destructs. That way I can for example ensure some cleanup happens after exiting some function.</p>
</blockquote>

<p>The code you are trying to use seems like something that has been a little over thought, or at least tailored to some other specific uses. For the quote above, here is how I would accomplish the task using lambdas and simple functions.</p>

<p>Now the calls can be as custom as you like, and the implementation stays nice and simple:</p>

<pre><code>template&lt; typename T &gt; struct TRef{
  TRef(T &amp;in) : t(in) {}
  ~TRef(){ t(); }
  T t;
};

template&lt; typename T &gt; TRef&lt;T&gt; RunOnExit(T t){
    return TRef&lt;T&gt;( t );
}

void setup() {
  Serial.begin(9600);
}

void loop() {
  int a = 3, b = 4;
  auto test = RunOnExit( [](){ func(1, 2); } );
  {
    auto test1 = RunOnExit( [&amp;a, &amp;b](){ func(a, b); } );

  }
}

void func( int a, int b){
  auto pause = RunOnExit( wait );
  Serial.print( a, HEX );
  Serial.print( "", "" );
  Serial.println( b, HEX );
}

void wait(){ delay(500); }
</code></pre>
",,43715499,2654
36208035,2,36200295,2016-03-24T18:59:43.273,0,,6022656,,2016-03-24T19:53:20.717,2016-03-24T19:53:20.717,0,,"<p>Hoping this helps</p>

<pre><code>#include &lt;tuple&gt; 
#include &lt;iostream&gt;

using namespace std;

template&lt;int...&gt; struct seq {};

template&lt;int N, int... S&gt; struct gens : gens&lt;N - 1, N - 1, S...&gt; {};

template&lt;int... S&gt; struct gens&lt;0, S...&gt; { typedef seq&lt;S...&gt; type; };

// NEW
template &lt;int N, typename ... Args&gt;
struct typeCont;

template &lt;typename A0, typename ... Args&gt;
struct typeCont&lt;0, A0, Args...&gt;
 { using  type = A0; };

template &lt;int N, typename A0, typename ... Args&gt;
struct typeCont&lt;N, A0, Args...&gt;
 { using  type = typename typeCont&lt;N-1, Args...&gt;::type; };

// NEW
template &lt;typename X, typename ... Args&gt;
class packCont;

template &lt;typename X, typename A0, typename ... Args&gt;
class packCont&lt;X, A0, Args...&gt;
 {
   public:

      X                      x;
      packCont&lt;A0, Args...&gt;  n;

   public:

      packCont (X const &amp; x0, A0 const &amp; a0, Args const &amp; ... args)
        : x(x0), n(a0, args...)
         { }

      X const &amp; getX () const
       { return x; }

      packCont&lt;A0, Args...&gt; const &amp; getN () const
       { return n; }
 };



template &lt;typename X&gt;
class packCont&lt;X&gt;
 {
   private:

      X  x;

   public:

      packCont (X const &amp; x0)
         : x(x0)
          { }

      X const &amp; getX () const
       { return x; }
 };

// NEW
template &lt;int N&gt;
struct getPc
 {
   template &lt;typename ... Args&gt;
      static typename typeCont&lt;N, Args...&gt;::type const &amp;
      func (packCont&lt;Args...&gt; const &amp; pc)
       { return getPc&lt;N-1&gt;::func(pc.getN()); }
 };

template &lt;&gt;
struct getPc&lt;0&gt;
 {
   template &lt;typename A0, typename ... Args&gt;
      static A0 const &amp; func (packCont&lt;A0, Args...&gt; const &amp; pc)
       { return pc.getX(); }
 };

template&lt;typename Return, typename... Args&gt; class CallOnExit
 {
   Return(*_func)(Args...);
   packCont&lt;Args...&gt; _args; // MODIFIED

   // MODIFIED
   template&lt;int... S&gt; Return call_func(seq&lt;S...&gt;)
    {
      return _func( getPc&lt;S&gt;:: template func&lt;Args...&gt;(this-&gt;_args) ... );
    }
   Return call()
    {
      return call_func(typename gens&lt;sizeof...(Args)&gt;::type());
    }
   public:
   // MODIFIED
   CallOnExit(Return(*func)(Args...), Args&amp;&amp;... args)
      : _func(func), _args(args...)
    { }
   ~CallOnExit()
    {
      if (_func != nullptr)
         call();
    }
 };

void f(int i, double d)
 {
   cout &lt;&lt; i &lt;&lt; endl &lt;&lt; d &lt;&lt; endl;
 }

int main()
 {
    {
      CallOnExit&lt;void, int, double&gt; c(f, 1, 2);
    }
   cin.get();
   return 0;
 }
</code></pre>
",,43717639,850
36211304,2,36211171,2016-03-24T22:50:30.897,9,,4200638,,2016-03-26T02:31:43.303,2016-03-26T02:31:43.303,4,,"<p>Given the equation of a circle and the equations of the midpoints:</p>

<pre><code>q = sqrt((x2-x1)^2 + (y2-y1)^2)

y3 = (y1+y2)/2

x3 = (x1+x2)/2
</code></pre>

<p>One answer will be:</p>

<pre><code>x = x3 + sqrt(r^2-(q/2)^2)*(y1-y2)/q 

y = y3 + sqrt(r^2-(q/2)^2)*(x2-x1)/q  
</code></pre>

<p>The other will be:</p>

<pre><code>x = x3 - sqrt(r^2-(q/2)^2)*(y1-y2)/q

y = y3 - sqrt(r^2-(q/2)^2)*(x2-x1)/q  
</code></pre>

<p>Assuming the variables for the points have been declared already, your code should look like this:</p>

<pre><code>double q = Math.Sqrt(Math.Pow((x2-x1),2) + Math.Pow((y2-y1),2));

double y3 = (y1+y2)/2;

double x3 = (x1+x2)/2;

double basex = Math.Sqrt(Math.Pow(r,2)-Math.Pow((q/2),2))*(y1-y2)/q; //calculate once
double basey = Math.Sqrt(Math.Pow(r,2)-Math.Pow((q/2),2))*(x2-x1)/q; //calculate once

double centerx1 = x3 + basex; //center x of circle 1
double centery1 = y3 + basey; //center y of circle 1
double centerx2 = x3 - basex; //center x of circle 2
double centery2 = y3 - basey; //center y of circle 2
</code></pre>

<p>source: <a href=""http://mathforum.org/library/drmath/view/53027.html"" rel=""noreferrer"">http://mathforum.org/library/drmath/view/53027.html</a></p>
",,43789757,1356
36211852,2,36211171,2016-03-24T23:43:32.033,5,,3931261,,2016-03-24T23:43:32.033,,0,,"<p>In c#:</p>

<pre><code> private double CenterX(double x1,double y1, double x2, double y2,double radius)
    {
        double radsq = radius * radius;
        double q = Math.Sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
        double x3 = (x1 + x2) / 2;


     return x3 + Math.Sqrt(radsq - ((q / 2) * (q / 2))) * ((y1 - y2) / q);


    }

    private double CenterY(double x1, double y1, double x2, double y2, double radius)
    {
    double radsq = radius * radius;
    double q = Math.Sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

     double y3 = (y1 + y2) / 2;

      return y3 + Math.Sqrt(radsq - ((q / 2) * (q / 2))) * ((x2-x1) / q);


    }
</code></pre>
",,43800172,1479
38396251,2,36211171,2016-07-15T12:34:20.480,0,,2679022,,2016-07-15T12:34:20.480,,0,,"<p>This the ruby version of the same code, should someone need it, (thanks to C# code by rookie1024)</p>

<pre><code>def chord
  @chord ||= begin
    a =  (point_1.x.to_f - point_2.x.to_f).abs ** 2
    b =  (point_1.y.to_f - point_2.y.to_f).abs ** 2
    Math.sqrt(a + b)
  end
end

def radius
  @radius ||= begin
    s = (chord / 2) * bulge
    ((chord/2) ** 2 + (s ** 2))/(2*s)
  end.to_f
end

def center
  x1 = point_1.x
  y1 = point_1.y

  x2 = point_2.x
  y2 = point_2.y

  x3 = (x1+x2)/2
  y3 = (y1+y2)/2

  basex = Math.sqrt((radius ** 2) - ((chord/2) ** 2)) * (y1-y2)/chord

  basey = Math.sqrt((radius ** 2) - ((chord/2) ** 2)) * (x2-x1)/chord

  centerx1 = x3 + basex
  centery1 = y3 + basey
  centerx2 = x3 - basex
  centery2 = y3 - basey

  bulge &gt; 0 ? [centerx1, centery1] : [centerx2, centery2]
end
</code></pre>
",,43804222,387
54967203,2,36231302,2019-03-03T09:03:50.970,0,,8522931,,2019-03-03T09:03:50.970,,0,,"<p>You might have found the answer to this already, but if you didn't I found a workaround:</p>

<p>When the connection opens, the open() function waits for an ACK byte as @t-johnson pointed out.</p>

<p>I modified your Arduino code to this:</p>

<pre><code>void setup() {
    Serial.begin(9600);
    Serial.write(0x01); // I just send back 0x01 as a ACK byte
}
void loop() {
    if (Serial.available() &gt; 0) {
        Serial.println(""Hello"");
        Serial.read();
    }
}
</code></pre>

<p>I also had to add the <code>O_NONBLOCK</code> flag to the open function.</p>

<p>I hope it can help!</p>
",,43813180,69
41205091,2,36234735,2016-12-18T03:03:13.830,1,,5781454,,2017-04-04T04:43:12.920,2017-04-04T04:43:12.920,0,,"<p>I use the mcp3008 all the time which is the 8 ADC version in SPI  from Windows and I do not have any problem.</p>

<p>First are you really reading the port 100 from the mcp3008.</p>

<pre><code>wart=analogRead(100);
</code></pre>

<p>You need to provide the code from mcp3004.cpp</p>

<p>The is the C# code to read a value from the MCP3008</p>

<pre><code>private List&lt;int&gt; _channelInSingleMode = new List&lt;int&gt;() {
            0x08,
            0x09,
            0x0A,
            0x0B,
            0x0C,
            0x0D,
            0x0E,
            0x0F
        };

        public int Read(int port)
        {
            if ((port &gt; 7) || (port &lt; 0))
                throw new ArgumentException(string.Format(""Invalid analog port {0}"", port));

            const byte junk = (byte)0;
            var port2       = (byte)((_channelInSingleMode[port] &lt;&lt; 4));
            var r1          = this._spiEngine.Transfer(new List&lt;Byte&gt;() { 0x1, port2, junk });

            return ValidateOperation(r1);
        }
</code></pre>
",,43821090,1007
36271271,2,36242308,2016-03-28T21:11:52.030,0,,2369817,,2016-03-28T21:19:51.383,2016-03-28T21:19:51.383,3,,"<p>Aha, found the actual problem: you need to start magnetometer single measurement for every new reading:</p>

<pre><code>  // Create 16 bits values from 8 bits data

  // Magnetometer
  int16_t mx=-(Mag[3]&lt;&lt;8 | Mag[2]);
  int16_t my=-(Mag[1]&lt;&lt;8 | Mag[0]);
  int16_t mz=-(Mag[5]&lt;&lt;8 | Mag[4]);


  // Magnetometer
  Serial.print(""MAG:\t"");
  Serial.print (mx+200,DEC); 
  Serial.print (""\t"");
  Serial.print (my-70,DEC);
  Serial.print (""\t"");
  Serial.print (mz-700,DEC);  
  Serial.print (""\t"");

  // Request first magnetometer single measurement !!!!!
  I2CwriteByte(MAG_ADDRESS,0x0A,0x01);
</code></pre>

<p>This is from the end of your code, I added a line that initiates a new reading. Seems to be working.</p>
",,43824128,204
36254456,2,36242505,2016-03-28T00:58:18.043,1,,467366,,2016-03-28T00:58:18.043,,1,,"<p><strong>The Problem</strong></p>

<p>The problem you are having is that your <code>Serial.available()</code> block is only reading one byte from the Serial buffer in each iteration of the loop. As a consequence, when your servo sends the word <code>""right""</code>, the Serial buffer is ""right"". The first iteration through <code>loop()</code> gives <code>""r""</code> as the value for <code>kontrolstr</code>.</p>

<p>Without the <code>else</code> block, on the second loop, <code>kontrolstr</code> is set to <code>ri</code>, then <code>rig</code>, then <code>righ</code>, etc, and is only reset when <code>left</code> or <code>right</code> are found. This is also what causes the problem of <code>left</code> and <code>right</code> not being reached if another word has been recognized - <code>kontrolstr</code> would have been set to , e.g. <code>""horse""</code>, this is not recognized, so then when it sends <code>""right""</code>, you get <code>""horseright""</code>, etc.</p>

<p>With the <code>else</code> block, on the first loop, <code>kontrolstr</code> is <code>""r""</code>, so it hits the <code>else</code> block, and resets the string. On the second loop, <code>kontrolstr</code> is <code>""i""</code>, it hits the <code>else</code> block and resets the string, etc, never reaching the relevant control block.</p>

<p><strong>Possible solutions</strong></p>

<p>The start of the solution is to read the entire <code>Serial</code> buffer before processing it, so replace the block starting with <code>if(Serial.available()</code> to:</p>

<pre><code>while(Serial.available())
  {
    kontrol = Serial.read();
    kontrolstr.concat(kontrol);
  }
</code></pre>

<p>This will read the entire buffer in the first loop, so as long as all the data has been sent between iterations of the loop, your problem will be solved. However, it takes a non-zero amount of time to send data over a Serial port, so it's possible that your <code>loop()</code> iteration triggers in the middle of a send, in which case the Serial buffer might be something like <code>""rig""</code>, which won't match <code>""right""</code> or <code>""left""</code>, will be reset, then in the next loop you'll get <code>""ht""</code>, and again it will be reset - the trigger will be missed.</p>

<p>If possible, I think the best solution would be to have your servo send the control words with a delimiter between them, e.g. <code>\n</code>. If your servo sends <code>""right\nanother word\nleft\n""</code>, then you can wait for entire words to come in before processing them. You can do this by changing your <code>loop()</code> to:</p>

<pre><code>void loop()
{
  kontrolstr = """";    // Reset on each iteration of the loop
  while(Serial.available())
  {
    kontrol = Serial.read();
    // If we reach the delimiter, stop reading from the Serial buffer
    if (control == '\n') {
      break;
    }
    kontrolstr.concat(kontrol);
  }
  if(kontrolstr== ""right"") {
    pos += 30;
  } else if(kontrolstr== ""left"") {
    pos -= 30; 
  }

  myservo.write(pos);
  delay(100);
}
</code></pre>

<p>Of course, this assumes that you're OK with allowing extra words to accumulate in the Serial buffer (seems fine since the buffer wasn't filling up even when you were reading only 1 character every 100ms). However, if it does happen that the Serial buffer is overflowing, then you can create a second string <code>bufferstring</code> and always append whatever is in the Serial buffer to that string, then on each iteration of the loop, pull out the oldest command, giving:</p>

<pre><code>#include &lt;Servo.h&gt; 

Servo myservo;  // create servo object to control a servo 

int pos = 90;
String kontrolstr = """";
String bufferstring = """";
char kontrol;

void setup() 
{ 
  Serial.begin(9600);
  myservo.attach(9);// attaches the servo on pin 9 to the servo object 
} 

void loop()
{
  // Read whatever's in the Serial port into the buffer string
  while(Serial.available())
  {
    kontrol = Serial.read();
    // If we reach the delimiter, stop reading from the Serial buffer
    bufferstring.concat(kontrol);
  }

  // Split the string by the delimiter
  int delimiter_loc = bufferstring.indexOf('\n');
  if (delimiter_loc != -1) {
    // Get the first delimiter_loc characters (doesn't include the delimiter)
    kontrolstr = bufferstring.substring(0, delimiter_loc);

    // Remove all the characters up to and including the delimiter_loc
    bufferstring.remove(0, delimiter_loc + 1);
  }

  if(kontrolstr== ""right"") {
    pos += 30;
  } else if(kontrolstr== ""left"") {
    pos -= 30;
  }

  // Reset on each iteration of the loop
  kontrolstr = """";

  myservo.write(pos);
  delay(100);
}
</code></pre>
",,43832180,367
36270201,2,36269847,2016-03-28T20:04:19.347,3,,4100891,,2016-03-28T20:04:19.347,2017-05-23T11:50:38.727,0,,"<p>Duplicate of <a href=""https://stackoverflow.com/questions/8285040/reference-as-class-member-initialization"">this</a>.</p>

<p>References can only be initialized, not changed.  To use it in the constructor like you have shown means that the reference member has to be <em>initialized</em> in the constructor:</p>

<pre><code>class TempController
{
  Thermistor &amp; member;
public:
  TempController( Thermistor &amp; t ) { member = t; }; // assignment not allowed
  TempController( Thermistor &amp; t ) : member(t) { }; // initialization allowed
}
</code></pre>
",,43861435,1411
36309859,2,36308733,2016-03-30T13:10:01.193,0,,404970,,2016-03-30T13:10:01.193,,0,,"<p>If we ""unroll"" the <code>loop</code> function, we get:</p>

<pre><code>// Loops is 1 on the first call.
digitalWrite(13, LOW);
Loops = Loops + 1;
// Loops is now 2
if (Loops &lt; 3)
{
    // So, we enter here...
    digitalWrite(13, HIGH);
    delay(2000);  
}
else
{
    // but not here
    digitalWrite(13, LOW);      
    exit(0);  
}
// Next call:
// Turn off the light.
digitalWrite(13, LOW);
Loops = Loops + 1;
// Loops is now 3
if (Loops &lt; 3)
{
    // So we don't enter here
    digitalWrite(13, HIGH);
    delay(2000);  
}
else
{
    // but we enter here
    digitalWrite(13, LOW);      
    // Which exits
    exit(0);  
}
</code></pre>

<p>So you turn on the LED once, then turn it off and exit.<br>
If you adjust the loop counter, you will turn off the LED and then immediately turn it on again, which will just look like it's on for a longer period.</p>

<p>You probably want to do a whole on/off cycle on each loop - something like this:</p>

<pre><code>int LedPin = 13;
int Loops = 0;

void setup() {
    pinMode(LedPin, OUTPUT);
    digitalWrite(LedPin, LOW);
}

void loop() {
    Loops = Loops + 1;
    if (Loops &lt;= 3)
    {
        digitalWrite(LedPin, HIGH);
        delay(2000);
        digitalWrite(LedPin, LOW);
        delay(2000);
    }
    else
    {
        exit(0);  
    }
}
</code></pre>
",,43870751,3858
36309881,2,36308733,2016-03-30T13:10:54.117,0,,5540037,,2016-03-30T13:10:54.117,,0,,"<pre><code>void setup() {
  // initialize digital pin 13 as an output.


  for (int i=0; i &lt; 4 ; i++) 
  {
    pinMode(13, OUTPUT);
    digitalWrite(13, HIGH); 
     delay(1000); 
     digitalWrite(13, LOW);    // turn the LED off by making the voltage LOW
      delay(1000);    

  }

}

// the loop function runs over and over again forever
void loop() {

}
</code></pre>
",,43882816,70
45788535,2,36308733,2017-08-21T02:15:23.303,-1,,8492680,,2017-08-21T02:15:23.303,,0,,"<pre><code>int LedPin = 13;

void setup() {
pinMode(LedPin, OUTPUT);
function() ;       //call this function whatever you want
}

void function()
{
digitalWrite(LedPin, HIGH);
delay(1000)       //add the desired delay
digitalWrite(LedPin, LOW);
delay(1000)     //add the desired delay
digitalWrite(LedPin, HIGH);
delay(1000)       //add the desired delay
digitalWrite(LedPin, LOW);
delay(1000)     //add the desired delay
digitalWrite(LedPin, HIGH);
delay(1000)       //add the desired delay
digitalWrite(LedPin, LOW);
delay(1000)     //add the desired delay

}
</code></pre>
",,43905188,62
36328569,2,36326399,2016-03-31T08:53:12.880,1,,794606,,2016-03-31T08:58:20.670,2016-03-31T08:58:20.670,0,,"<p>By the sources </p>

<pre><code>String::String(const char *cstr)
{
    init();
    if (cstr) copy(cstr, strlen(cstr));
}
...
inline void String::init(void)
{
    buffer = NULL;
    capacity = 0;
    len = 0;
}
...
String &amp; String::copy(const char *cstr, unsigned int length)
{
    if (!reserve(length)) {
        invalidate();
        return *this;
    }
    len = length;
    strcpy(buffer, cstr);
    return *this;
}
...
void String::invalidate(void)
{
    if (buffer) free(buffer);
    buffer = NULL;
    capacity = len = 0;
}
...
unsigned char String::reserve(unsigned int size)
{
    if (buffer &amp;&amp; capacity &gt;= size) return 1;
    if (changeBuffer(size)) {
        if (len == 0) buffer[0] = 0;
        return 1;
    }
    return 0;
}
</code></pre>

<p>Your one line assignment </p>

<pre><code> in = buff; 
</code></pre>

<p>Makes all allocation too. </p>

<p>It must be done, original <code>String</code> cannot hold <code>buffer</code>in different memory model, only one 'dynamic - allocated' has sense.</p>

<p>In wide perspective many C memory models (stack, static, allocated by <code>new</code>, allocated by <code>calloc</code> if they are different) must be reduced in real life library - mixing is dangerous. For example stack variable cannot live longer - must be copied to 'allocated'.</p>

<p>You check new possibilities, that's good, but I agree with Aconcagua trust in implementation and not replace original memory model.</p>

<p>Sources: <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/WString.cpp"" rel=""nofollow"">https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/WString.cpp</a></p>

<p>EDIT: agree with <code>const</code> arguments etc ...</p>
",,43914915,1119
36374225,2,36373870,2016-04-02T14:01:17.427,4,,4443423,,2016-04-02T14:16:02.127,2016-04-02T14:16:02.127,1,,"<p>Here is an <a href=""https://ideone.com/4f5VAX"" rel=""nofollow"">example</a>. Translate it to any C-Dialect you need.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

const char* haystack = ""\""weather\"":[{\""id\"":800,\""main\"":\""Clear\"","";
const char* needle   = ""\""main\"":"";

int main()
{
    std::cout &lt;&lt; ""Parsing string: '"" &lt;&lt; haystack &lt;&lt; ""'\n"";

    if (const char* cursor = strstr(haystack, needle)) {
        char buffer[100];
        if (sscanf(cursor, ""\""main\"":\""%99[^\""]\"","", buffer))
            std::cout &lt;&lt; ""Parsed string: '"" &lt;&lt; buffer &lt;&lt; ""'\n"";
        else 
            std::cout &lt;&lt; ""Parsing error!\n"";
    } else {
        std::cout &lt;&lt; ""Could not find '"" &lt;&lt; needle &lt;&lt; ""' in '"" &lt;&lt; haystack &lt;&lt; ""'\n"";
    }
}
</code></pre>
",,43934882,130
39693278,2,36381932,2016-09-26T00:47:57.053,2,,4561887,,2020-09-29T23:40:47.303,2020-09-29T23:40:47.303,0,,"<p>Ok, the answer to &quot;Why is incrementing/decrementing a single byte variable NOT atomic?&quot; is answered very well here by <a href=""https://stackoverflow.com/a/36381968/4561887"">Ishamael here</a>, and <a href=""https://stackoverflow.com/a/36382183/4561887"">Michael Burr here</a>.</p>
<p>Now that I got my answer that <code>--</code> decrement and <code>++</code> increment operations are never atomic, even when done on byte values (see answers above and <a href=""http://www.gammon.com.au/interrupts"" rel=""nofollow noreferrer"">Nick Gammon's link here</a>), I'd like to ensure the follow-up question of <em>how</em> do I force atomicity on Atmel AVR microcontrollers is also answered so this question becomes somewhat of a resource:</p>
<h2><strong>Here are all techniques I am aware of to force atomicity in Atmel AVR microcontrollers, such as Arduino:</strong></h2>
<p><strong>1) Option 1 (the preferred method):</strong></p>
<pre><code>uint8_t SREG_bak = SREG; //save global interrupt state
noInterrupts(); //disable interrupts (for Arduino only; this is an alias of AVR's &quot;cli()&quot;)
//atomic variable-access code here
SREG = SREG_bak; //restore interrupt state
</code></pre>
<p><strong>2) Option 2 (the less-safe, not recommended method, since it can cause you to inadvertently enable nested interrupts if you accidentally use this approach in a code block or library which gets called inside an ISR):</strong></p>
<pre><code>noInterrupts(); //disable interrupts (Arduino only; is an alias to AVR's &quot;cli()&quot; call)
//atomic variable-access code here
interrupts(); //enable interrupts (Arduino only; is an alias to AVR's &quot;sei()&quot; call)
</code></pre>
<p>Alternative option 2:</p>
<pre><code>cli(); //clear (disable) interrupts flag; noInterrupts() is simply a macro for this
//atomic variable-access code here
sei(); //set (enable) interrupts flag; interrupts() is simply a macro for this
</code></pre>
<p><strong>3) Option 3 (essentially the same as option 1; just using a macro held in an avr-libc library instead, and with variable scope applied within the braces of course)</strong><br />
source: <a href=""http://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html"" rel=""nofollow noreferrer"">http://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html</a></p>
<pre><code>#include &lt;util/atomic.h&gt; //(place at top of code)
ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
{
  //atomic access code here
}
</code></pre>
<h1>Related:</h1>
<ol>
<li>[My Q&amp;A] <a href=""https://stackoverflow.com/questions/52784613/which-variable-types-sizes-are-atomic-on-stm32-microcontrollers/52785864"">Which variable types/sizes are atomic on STM32 microcontrollers?</a></li>
<li><a href=""https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/"" rel=""nofollow noreferrer"">https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/</a></li>
<li>***** [My answer] <a href=""https://arduino.stackexchange.com/questions/77494/which-arduinos-support-atomic-block/77579#77579"">Which Arduinos support ATOMIC_BLOCK? [and how can I duplicate this concept in C with <code>__attribute__((__cleanup__(func_to_call_when_x_exits_scope)))</code> and in C++ with class constructors and destructors?]</a></li>
</ol>
",,43939631,102
36404068,2,36392527,2016-04-04T13:28:24.537,0,,4479909,,2016-04-04T13:28:24.537,,13,,"<p>I don't have Arduino installed in the PC I 'm using right now, so I hope I get this right...</p>

<p>For one thing, your code is way more complex than necessary
You can simplify</p>

<pre><code>num = strtok(message, "":"");
String numstr(num);
Serial.println(numstr);

num = strtok(NULL, "":"");
String numstr2(num);
Serial.println(numstr);
</code></pre>

<p>as</p>

<pre><code>Serial.println(strtok(input.c_str(), "":""));
Serial.println(strtok(NULL, "":""));
</code></pre>

<p>Also,</p>

<pre><code>String input = String(Serial.Serial.readStringUntil((char)13));
</code></pre>

<p>Will probably be closer to what you want (assuming your input strings are terminated with CR)</p>

<pre><code>if (Serial.available()) {
   String input = String(Serial.Serial.readStringUntil((char)13));
   Serial.println(""original: "" + input);
   Serial.println(atoi(input.c_str()) ;
   Serial.println(strtok(input.c_str(), "":""));
   Serial.println(strtok(NULL, "":""));
}
</code></pre>

<p>Will hopefully do what you want.</p>
",,43939860,1000
36402029,2,36401027,2016-04-04T11:59:41.743,3,,1549060,,2016-04-04T12:29:18.477,2016-04-04T12:29:18.477,3,,"<p>Consider the following 'psuedo-c++'</p>

<p>The code works as follows: </p>

<ul>
<li>take the highest, or lowest bit in the word by AND-ing with all zero's except the MSB or LSB, depending on the MSBFIRST flag</li>
<li>write it to the output pin</li>
<li>shift the command one step in the right direction</li>
<li>pulse the clock pin</li>
<li>repeat 8 times, for each bit in the command</li>
</ul>

<p>It is fairly trivial to expand this to an arbitrary number of bits upto 32 by adding a parameter for the number of repetitions</p>

<pre><code>void shiftOut(GPIO dataPin, GPIO clockPin, bool MSBFIRST, uint8_t command)
{
   for (int i = 0; i &lt; 8; i++)
   {
       bool output = false;
       if (MSBFIRST)
       {
           output = command &amp; 0b10000000;
           command = command &lt;&lt; 1;
       }
       else
       {
           output = command &amp; 0b00000001;
           command = command &gt;&gt; 1;
       }
       writePin(dataPin, output);
       writePin(clockPin, true);
       sleep(1)
       writePin(clockPin, false);
       sleep(1)
    }
}
</code></pre>
",,43963019,836
36954599,2,36421213,2016-04-30T11:55:21.570,2,,3079756,,2016-04-30T11:55:21.570,,0,,"<p>As Aeldred said you have just to cast you String to <strong>char*</strong>.</p>

<p>so your sketch will looks like :</p>

<pre><code>#include ""SoftwareSerial.h""
SoftwareSerial esp(10, 11);// RX, TX
void setup() {
  esp.begin(9600);
  Serial.begin(9600);
  delay(100);
  Serial.println(""Started..."");
  reset();
  connectWifi();
}

//reset the esp8266 module
void reset() {
  esp.println(""AT+RST"");
  delay(1000);
  if (esp.find((char*)""OK"")) Serial.println(""Module Reset""); //error
}
</code></pre>
",,43983535,2814
36437247,2,36431493,2016-04-05T21:19:05.557,1,,1329652,,2016-04-05T21:26:13.923,2016-04-05T21:26:13.923,2,,"<p>This minimal test case works for me on an Arduino on both Windows and OS X, using latest Qt 5.5.</p>

<p>This kind of minimization is what belongs in your question. Multiple files (and a missing .ui) aren't necessary to demonstrate such simple failures.</p>

<pre><code>// https://github.com/KubaO/stackoverflown/tree/master/questions/miniserial-36431493
#include &lt;QtWidgets&gt;
#include &lt;QtSerialPort&gt;

int main(int argc, char ** argv) {
   QApplication app(argc, argv);
   QWidget w;
   QFormLayout layout(&amp;w);
   QPushButton ping(""Send"");
   QTextBrowser output;
   layout.addRow(&amp;ping);
   layout.addRow(&amp;output);
   w.show();

   QSerialPort port(""COM6"");
   port.setBaudRate(QSerialPort::Baud9600); // these are guaranteed to return true
   port.setDataBits(QSerialPort::Data8);
   port.setParity(QSerialPort::NoParity);
   port.setStopBits(QSerialPort::OneStop);
   port.setFlowControl(QSerialPort::NoFlowControl);
   if (!port.open(QIODevice::ReadWrite))
      output.append(""! Can't open the port :(&lt;br/&gt;"");

   QObject::connect(&amp;ping, &amp;QPushButton::clicked, &amp;port, [&amp;]{
      if (port.isOpen()) {
         port.write(""1"");
         output.append(""&gt; 1&lt;br/&gt;"");
      } else
         output.append(""! Write failed :(&lt;br/&gt;"");
   });
   QObject::connect(&amp;port, &amp;QIODevice::readyRead, &amp;output, [&amp;]{
      auto data = port.readAll();
      output.append(QStringLiteral(""&lt; %1&lt;br/&gt;"")
                    .arg(QString::fromLatin1(data).toHtmlEscaped()));
   });

   return app.exec();
}
</code></pre>
",,44003765,193
36432872,2,36432350,2016-04-05T17:11:54.097,0,,10593,,2016-04-08T14:44:11.940,2016-04-08T14:44:11.940,1,,"<p>C++ doesn't have reflection, so you're limited to using macros, such as:</p>

<pre><code>#include &lt;iostream&gt;
#define STRINGIFY_IMPL(X) #X
#define STRINGIFY(X) STRINGIFY_IMPL(X)
#define VARIABLE_NAME(X) STRINGIFY(X)
#define VARIABLE_VALUE(X) X

int main()
{
    double d = 3.141;
    std::cout &lt;&lt; VARIABLE_NAME(d) &lt;&lt; "": "" &lt;&lt; VARIABLE_VALUE(d) &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>(<code>VARIABLE_NAME</code> and <code>VARIABLE_VALUE</code> aren't truly needed, you could also use <code>std::cout &lt;&lt; STRINGIFY(d) &lt;&lt; "": "" &lt;&lt; d &lt;&lt; '\n';</code>).</p>

<hr>

<p>You can, of course, combine this all into a super macro (with macros from above):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#define STREAM_NAME_VALUE(str, X) str &lt;&lt; '{' &lt;&lt; STRINGIFY(X) &lt;&lt; ':' &lt;&lt; X &lt;&lt; '}'

int main()
{
    int myInt =34;
    float myFloat = 944.5555f;
    std::string myString = "" this string"";

    STREAM_NAME_VALUE(std::cout, myInt);
    std::cout &lt;&lt; '\n';
    STREAM_NAME_VALUE(std::cout, myFloat);
    std::cout &lt;&lt; '\n';
    STREAM_NAME_VALUE(std::cout, myString);
    std::cout &lt;&lt; '\n';
    return 0;
}
</code></pre>
",,44004422,282
36435715,2,36432350,2016-04-05T19:47:32.770,1,,1483604,,2016-04-05T19:47:32.770,,0,,"<p>You can use macro to do that combined with <a href=""https://gcc.gnu.org/onlinedocs/cpp/Stringification.html"" rel=""nofollow"">stringify preprocessor</a>:</p>

<h2>Code:</h2>

<pre><code>#include &lt;stdio.h&gt;

#define PRINT_NAME(name) print_name(#name, (name))

void print_name(char *name, char* value) {
    printf(""name: %s ---&gt; value: %s\n"", name, value);
}

int main (int argc, char* argv[]) {
    char* var1 = 'my var 1';
    char* var2 = 'my new var 2';

    PRINT_NAME(var1);
    PRINT_NAME(var2);

    return 0;
}
</code></pre>

<h2>Output:</h2>

<pre><code>name: var1 --&gt; value: my var 1
name: var2 --&gt; value: my new var 2 
</code></pre>

<p>I hope this helps :)</p>
",,44004939,1046
36490462,2,36475331,2016-04-08T02:23:52.080,1,,2305399,,2016-04-08T02:23:52.080,,0,,"<p>As you've been told, terminate your AT commands with a carriage return character <code>\r</code>. Also you current code will read only a byte of the response, and thats if the response has even arrived since you included no delay at all. To communicate with the ESP interactively with the Serial monitor, I'd recommend using this:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

SoftwareSerial esp(10, 11);
void setup(){
  Serial.begin(9600);
  esp.begin(9600);
}

void loop()
{
  while (Serial.available())  // forward data from monitor to esp
    esp.write(Serial.read());
  while (esp.available())  // forward data from esp to monitor
    Serial.write(esp.read());
}
</code></pre>

<p>This basically makes your Arduino a conduit for communication between your PC and the ESP. You can send commands to the ESP with the Serial monitor and get their results immediately. Its great for testing commands. Just remember to set the serial monitor to <code>BOTH NL &amp; CR</code>; this will serve you well for commands as well as any HTTP requests you send, as it appends <code>\r\n</code> to everything you send. </p>

<p>If you do want to write a sketch to talk to the ESP, you must provide some delay after sending a command to wait for the module to process the command and respond. The delay varies depending on the command, at least 500ms. The usual procedure is to define a timeout period for each command, depending on how long its expected to take, after which you 'give up' if there's no response yet. There are lots of libraries on GitHub that involve talking to some device using AT commands; study them to learn their techniques.</p>
",,44021219,1202
36529768,2,36524425,2016-04-10T12:32:58.020,0,,2410359,,2016-04-10T12:39:23.573,2017-05-23T11:59:43.910,0,,"<p>To calculate the the difference in seconds in C, use <code>difftime()</code>, it returns the difference expressed in seconds.</p>

<pre><code>double difftime(time_t time1, time_t time0);
</code></pre>

<p>If needed, to get the present time, use <code>time()</code>.  It determines the current calendar time.</p>

<pre><code>time_t time(time_t *timer);
</code></pre>

<p>So all that is left is how to take strings like ""2016-04-10T02:36:00+02:00"" into <code>time_t</code>.</p>

<ol>
<li><p>Covert the string into numeric parts.</p>

<pre><code>if (8 == sscanf(buf, ""%d-%d-%dT%d:%d:%d%d:%d"", &amp;y, &amp;m, ..., &amp;tzh, &amp;tzm)) Success();
</code></pre></li>
<li><p>Convert the <code>y,m,d ...</code> into <code>struct tm</code></p>

<pre><code>struct tm tm = {0};  // Important to first zero fill
tm.tm_year = y - 1900;
tm.tm_mon = m - 1;
tm.tm_mday = d;
...
tm.tm_hour = H + tzh;
tm.tm_min = M + tzm*sign(tzh);
tm.tm_sec = S;
</code></pre></li>
<li><p>Convert <code>struct tm</code> (in universal time) to <code>time_t</code>.  This step is hard as C provides no clear standard way to do it.  <a href=""https://stackoverflow.com/a/15301457/2410359"">This</a> this a reasonable portable method. See the rest of the post for alternate approaches.</p></li>
</ol>

<p>Notice no assumption is made (or needed) about <code>time_t</code> being seconds since 1970 nor that <code>struct tm</code> has only 9 fields.</p>
",,44051517,1002
36533019,2,36529100,2016-04-10T17:24:05.407,0,,6162078,,2016-04-10T17:24:05.407,,0,,"<p>I also had that problem when I wantet to transfer data from VB.net on Windows to my arduino with Serial. I fixed it by sending a ""Line ends here (!)""</p>

<pre><code>void serialEvent() {
    while (Serial.available() &gt; 0) {
    char ch = (char) Serial.read();
    if (ch == '!') { //This is where it checks if the incomming (char / byte is the End of line
      stringComplete = true;
    }else if (ch == '0' || ch == '1') { //Im Sending 0 and 1 here to turn un / off LED's
      inputString += ch; 
    }
    if (stringComplete) {
      Serial.flush();
      Serial.println(""&lt;--"" + inputString);
      inputString = """";
      stringComplete = false;
    }
  } 
}
</code></pre>

<p>I hope that helped you a bit. Feel free to use that code. </p>
",,44123055,200
36531270,2,36531137,2016-04-10T14:52:44.570,0,,1313573,,2016-04-10T14:52:44.570,,0,,"<p>Your current code isn't working since it calls <code>dir()</code> and <code>stepper()</code> sequentially, ie, it only calls <code>stepper()</code> after waiting the two seconds for a full cycle of <code>dir()</code>.</p>

<p>To simulate calling both at once you should do it the following:</p>

<pre><code>void stepForOneSecond(){
    for(int i = 0; i &lt; 500; ++i){
        digitalWrite(stepPin,HIGH);
        delay(1);
        digitalWrite(stepPin,LOW);
        delay(1);
    }
}

void loop(){
    digitalWrite(dirPin,HIGH);
    stepForOneSecond();
    digitalWrite(dirPin,HIGH);
    stepForOneSecond();
}
</code></pre>

<p>The call to <code>stepForOneSecond</code> will last (approximately) 1 second, after which it will toggle the value of the 'dirPin'. </p>
",,44183281,610
36548408,2,36548206,2016-04-11T12:14:27.607,1,,335858,,2016-04-11T12:14:27.607,,0,,"<p>You have already figured out the desired range of temperatures, so all you need to do is scaling the values 0..255 to and from that range.</p>

<p>To get from float [-30..97] to integral [0..255] in half-degree steps you need to add 30 to the number, multiply it by two, truncate the fraction, apply limits on both sides (negative numbers become zero; numbers above 255 become 255)</p>

<pre><code>float temp;
float x = temp+30;
if (x &lt; 0) return 0; // Apply lower limit
x *= 2;
return x &gt; 255 ? 255 : (byte)x; // Apply upper limit and truncate
</code></pre>

<p>To get from integral [0..255] to float [-30..97], convert the value to <code>float</code>, divide by 2, and subtract 30:</p>

<pre><code>float res = ((float)x)/2 - 30;
</code></pre>
",,44191981,264
36549113,2,36548206,2016-04-11T12:47:11.713,1,,5821248,,2016-04-11T13:03:44.953,2016-04-11T13:03:44.953,0,,"<p>Alright, I'll bite if only because of always being asked how to round to specific values and how to type cast. </p>

<p>Assuming you start at byte value 0 being equal to temperature value -30, and you have byte value 255 equal to temperature value 97 degrees and you want every byte value to increment the temperature value by 0.5 degrees Celsius, your maximum would actually be at CurrentTemp = LowestTemp + (ByteVal*IncrementTemp) = -30 + (255*0.5) = 97.5 degrees and this will be your equation. Therefore:</p>

<pre><code>const int LowestTemp       -30
const float MaxTemp        97.5
const float IncrementTemp  0.5
bool retry_flag;


float ConvertFromByte(byte b)
{
  /*returns CurrentTemp*/

  return ((float)(LowestTemp + (b*IncrementTemp)));
}

byte ConvertFromFloat(float f)
{
  /*returns ByteVal*/
  float CurrentTemp = (int)(f/IncrementTemp);
  CurrentTemp *= IncrementTemp;
  if((CurrentTemp&lt;LowestTemp)||(CurrentTemp&gt;MaxTemp)) retry_flag = 1;
  return ((byte)((CurrentTemp - LowestTemp)/IncrementTemp));
}
</code></pre>

<p>The method of rounding can be found <a href=""https://en.wikipedia.org/wiki/Rounding#Rounding_to_a_specified_increment"" rel=""nofollow"">here</a> and makes use of the method of first dividing the number by the increment, rounding to a whole number and then multiplying by the increment again. </p>

<p>The method of typecasting is merely telling value x to be of a type <em>cast</em> by writing <em>(cast) x</em> as above. Here I use the fact that <em>int</em> does not contain fractions to quickly round CurrentTemp to the nearest whole number.</p>

<p>Note also that your code will need to check if the retry flag is set before using the value to pass via RF. There will be no errors, however the value passed will be completely wrong.</p>
",,44223824,42
36561669,2,36560828,2016-04-12T00:38:38.083,1,,814662,,2016-04-13T00:23:08.450,2017-05-23T12:31:19.003,1,,"<p>Danger Danger, you're returning a pointer to a local variable, Binary, that is on the stack, once the function returns it is out of scope and no longer valid.  This will cause weirdness, it will work some times and then it will stop working, don't do it!</p>

<p>See <a href=""https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"">Can a local variable&#39;s memory be accessed outside its scope?</a></p>

<p>You need to pass in the storage.</p>

<p>eg.</p>

<pre><code>void loop() {
// put your main code here, to run repeatedly:
 if (Serial.available() &gt; 0){
    char BinaryNum[33]; // allows for 32 bits plus null terminator
    int Decimal = Serial.parseInt();
    dec2bin(Decimal, BinaryNum);
    Serial.println (BinaryNum);

 }

}

void dec2bin (int Decimal, char* Binary){

  int Remainder; // Remainder of Decimal%2
  int x = 0;

  while (Decimal != 0 ){
    Remainder = Decimal%2; 
    Decimal = Decimal/2;
    Binary[x] = Remainder; 
    x+=1;
  }
  Binary[x] = '\0';
}
</code></pre>

<p>On a ""real"" computer with an operating system there are many more memory management options than on a little arduino.  You could allocation from the heap and use something fancy like an auto_ptr to manage it (see <a href=""https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one/106614#106614"">What is a smart pointer and when should I use one?</a>).</p>

<p>This just isn't possible on something as small as an arduino.   You could however allocate it as a static.  This isn't appropriate for a fancy computer because it is not re-entrant and thus not thread safe.  Static allocation is done at program linking or startup and persistent across calls.</p>

<pre><code>void loop() {
// put your main code here, to run repeatedly:
 if (Serial.available() &gt; 0){
    int Decimal = Serial.parseInt();
    char* BinaryNum  = dec2bin(Decimal);
    Serial.println (BinaryNum);

 }

}

void dec2bin (int Decimal) {
  static Binary[33]; // allows for 32 bits plus null terminator

  int Remainder; // Remainder of Decimal%2
  int x = 0;

  while (Decimal != 0 ){
    Remainder = Decimal%2; 
    Decimal = Decimal/2;
    Binary[x] = Remainder; 
    x+=1;
  }
  Binary[x] = '\0';

  return Binary;
}
</code></pre>
",,44229409,321
46344105,2,36571454,2017-09-21T12:35:34.430,1,,6622777,,2017-09-21T12:35:34.430,,0,,"<p>The default size of <code>raspicam::RaspiCam_Cv</code> is 1280*960,you can use <code>get</code> to get: </p>

<pre><code>double RaspiCam_Cv::get ( int propId );
</code></pre>

<p>for example:</p>

<pre><code>Camera.get(CV_CAP_PROP_FRAME_WIDTH);
Camera.get(CV_CAP_PROP_FRAME_HEIGHT);
</code></pre>

<p>If you want other size,you can use <code>set</code> to set:</p>

<pre><code>bool RaspiCam_Cv::set ( int propId, double value );
</code></pre>

<p>for example:</p>

<pre><code>Camera.set(CV_CAP_PROP_FRAME_WIDTH,640);
Camera.set(CV_CAP_PROP_FRAME_HEIGHT,480);
</code></pre>

<p>The other properties can get/set include:</p>

<pre><code> * CV_CAP_PROP_FRAME_WIDTH,CV_CAP_PROP_FRAME_HEIGHT,
 * CV_CAP_PROP_FORMAT: CV_8UC1 or CV_8UC3
 * CV_CAP_PROP_BRIGHTNESS: [0,100]
 * CV_CAP_PROP_CONTRAST: [0,100]
 * CV_CAP_PROP_SATURATION: [0,100]
 * CV_CAP_PROP_GAIN: (iso): [0,100]
 * CV_CAP_PROP_EXPOSURE: -1 auto. [1,100] shutter speed from 0 to 33ms
 * CV_CAP_PROP_WHITE_BALANCE_RED_V : [1,100] -1 auto whitebalance
 * CV_CAP_PROP_WHITE_BALANCE_BLUE_U : [1,100] -1 auto whitebalance
 * CV_CAP_PROP_MODE : [1,7] 0 auto mode
</code></pre>

<p>PS:The FPS and size of <code>cv::VideoWriter</code> must be same with <code>raspicam::RaspiCam_Cv</code>,otherwise,<code>cv::VideoWriter</code> will never work.</p>
",,44234119,1767
36578471,2,36577523,2016-04-12T15:59:41.273,2,,6194193,,2016-04-12T15:59:41.273,,4,,"<p>You have to send it AT commands to create a HTTP request.
This would connect to a server at 192.168.88.35 on port 80</p>

<pre><code>// Connect to the server
esp8266.write(""AT+CIPSTART=\""TCP\"",\""192.168.88.35\"",80\r\n""); //make this command: AT+CPISTART=""TCP"",""192.168.88.35"",80

//wait a little while for 'Linked'
delay(300);

//This is our HTTP GET Request change to the page and server you want to load.
String cmd = ""GET /status.html HTTP/1.0\r\n"";
cmd += ""Host: 192.168.88.35\r\n\r\n"";

//The ESP8266 needs to know the size of the GET request
esp8266.write(""AT+CIPSEND="");
esp8266.write(cmd.length());
esp8266.write(""\r\n"");

esp8266.write(cmd);
esp8266.write(""AT+CIPCLOSE\r\n"");
</code></pre>

<p>This link should help if you need more details:
<a href=""http://blog.huntgang.com/2015/01/20/arduino-esp8266-tutorial-web-server-monitor-example/"" rel=""nofollow"">http://blog.huntgang.com/2015/01/20/arduino-esp8266-tutorial-web-server-monitor-example/</a></p>
",,44266860,104
36590723,2,36589009,2016-04-13T06:53:41.690,0,,5785362,,2016-04-13T11:12:58.233,2016-04-13T11:12:58.233,5,,"<p>On a PIC, you wouldn't necessarily jump directly from something as simple as busy-waiting loops to something as complicated as multithreading libraries, as proposed in some of the comments.</p>

<p>Let's assume you blink your LED every second in a loop - That gives code in that loop (or called from inside that loop) nearly 1 second to execute on something different. If you can slice those tasks into such small slices that they fit into the interval ""when you need to be back"" to blink the LED, that's a start.</p>

<p>Obviously, if you execute arbitrary code in the blinking loop, the frequency of your blinking will be affected by the time those other code parts use up and you can no longer use the CPU as a time base - You need something different to check whether blinking is due. Most MCUs have a timer that allows you to do that - Reading a free-running timer to check whether you ""need to blink"" would be the first simple step. See below pseudo-code:</p>

<pre><code>while (1){
  if (((time = readTimer()) - oldTime) &gt; INTERVAL){
     /* Timer run-around ignored for reasons of simplicity */
     oldTime = time;
     blink();
  }
  else
     doSomethingElse();
}
</code></pre>

<p>Note the <code>somethingElse()</code> must be finished in the least possible time as its run-time affects the precision of your blinking.</p>

<p>If you still want the blinking to be at exact intervals, you should be looking into interrupt service routines. Find out how you make the timer trigger an interrupt with the frequency of your blinking, and do the blinking in the interrupt service routine. That releases your main loop from doing that and you can do whatever long-running tasks you want there. The timer will trigger an interrupt at your wanted frequency, and the interrupt service routine will switch the lights.</p>
",,44308401,452
36591553,2,36589009,2016-04-13T07:34:15.310,1,,6192747,,2016-04-13T09:06:22.867,2016-04-13T09:06:22.867,1,,"<p>Most microcontrollers have available hardware timers that can be used for such purposes. So your code in the timer will toggle the blinking, and the main software can set variables that tells the timer code if it should blink or not</p>

<pre><code>int shouldblink = 0;
int ledstatus = 0;
void OnTimer(void) /* configure your microcontroller to call this on timer */
{
    if (ledstatus)
    {
        turnoffLED();
        ledstatus = 0;
    }
    else {
        if (shouldblink)
        {
            turnonLED();
            ledstatus = 1;
        }
    }
}

int main()
{
    configure_timer();
    shouldblink = 1;
    do_slow_work();
    shouldblink = 0;
}
</code></pre>
",,44354908,841
36610254,2,36589454,2016-04-13T21:52:27.897,0,,1599004,,2016-04-13T21:59:27.663,2017-05-23T10:28:13.400,2,,"<p>Your primary bug involves the statements:</p>

<pre><code>    char buf[1]={0};
...  
       ssize_t res=read(fd, buf, 1);
...
       buf[res]=0;  
</code></pre>

<p>The array <strong>buf[]</strong> is declared to be only <em>one</em> element long, i.e. <strong>buf[0]</strong> is the only element of the array.<br>
The <strong>read()</strong> syscall will have a return value of 1 on success, since that is the specified count.<br>
Then you try to null terminate the received text by writing to <strong>buf[1]</strong>, but that is an element that has not been allocated.<br>
The array <strong>buf[]</strong> needs to be at least 2 elements long. </p>

<p>The symptoms of this bug will vary according to the compiler and host system.  On an x86 laptop using gcc 4.8.4, your original program produces no output at all.</p>

<p>For the preferred method of terminating the buffer data see <a href=""https://stackoverflow.com/questions/32526576/linux-serial-read-throws-error/32572202#32572202"">Linux Serial Read throws Error</a></p>

<hr>

<p><strong>Code Review</strong></p>

<ol>
<li><p>All syscalls, including <strong>tc[gs]etattr()</strong> and <strong>read()</strong>, should be checked for error return codes, especially when your program does not behave as you expect.</p></li>
<li><p>Your <strong>termios</strong> configuration is incomplete.  Your program will execute with whatever previous canonical or non-canonical mode that was configured.  That can produce unexpected results.</p></li>
<li><p>Reading just one character at a time (nested in several while loops) is inefficient.  A canonical read could return a line per each syscall.  Study <a href=""http://www.chemie.fu-berlin.de/chemnet/use/info/libc/libc_12.html#SEC233"" rel=""nofollow noreferrer"">""Two Styles of Input: Canonical or Not""</a></p></li>
<li><p>Program delays such as <code>usleep(70000)</code> are superfluous.  The file/device has been opened for blocking reads, so the <strong>read()</strong> will not return until data is available.</p></li>
</ol>
",,44361329,563
36593143,2,36589676,2016-04-13T08:48:24.580,2,,3368201,,2016-04-13T08:48:24.580,,0,,"<p>It's ALWAYS a bad idea messing up with the files and then hoping that the compiler does some magic. What I suggest you is to use the files as they are meant to be used, so</p>

<ul>
<li>Header files (<code>*.h</code>, <code>*.hpp</code>) shall contain class definitions (but not implementations), global variables defined as <code>extern</code>, function prototypes. They shall use the common <code>ifndef...</code> to prevent multiple inclusions</li>
<li>Source files (<code>*.c</code>, <code>*.cpp</code>, <code>*.ino</code>) shall contain the actual function implementations, the methods implementations, and the global variables definitions.</li>
</ul>

<p>You should not avoid using this, otherwise you will enter a lot of possible troubles.</p>

<p>In your case, you should then have three files:</p>

<p><strong>main.ino</strong></p>

<pre><code>#include ""oldFunctions.h""

#define BLAHBLAH
setup(){
  //....
}
loop(){
  //....
}

void newFunctionA(void){
//....
}
</code></pre>

<p><strong>oldFunctions.h</strong></p>

<pre><code>#ifndef OLD_FUNCTIONS_H
#define OLD_FUNCTIONS_H

void newFunctionA();
void test();

#endif
</code></pre>

<p><strong>oldFunctions.cpp</strong></p>

<pre><code>#include ""oldFunctions.h""

void test(void){
    newFunctionA();
}
</code></pre>

<p>Please note, however, that in the cpp file you should not use the <code>BLAHBLAH</code> you defined in <code>main.ino</code>. If you need it, move it to the <code>oldfunctions.h</code> file.</p>

<p>In <code>newFunctionA</code> is a new function you want to keep separated from the oldfunctions, just create a new header file and include it. The important part is that you do not rely on arduino joining the source files, because this can lead to unexpected behavior.</p>
",,44365468,59
36599795,2,36595115,2016-04-13T13:22:27.763,0,,4100891,,2016-04-13T13:22:27.763,,6,,"<p>You probably have a low RAM condition.</p>

<p>Also, you shouldn't use the <code>String</code> class for <code>firstLine</code>.  It causes many problems, some of which can occur at random times.</p>

<p>Just use a character array like you did for <code>received</code>.  Store each character in the array until the newline character arrives, and increment the length for each character:</p>

<pre><code>void checkForClient(int loading){
  char    firstLine[60];
  uint8_t firstLineLen = 0;

  MP3player.pauseDataStream ();
  EthernetClient client = server.available();
  MP3player.resumeDataStream();
  if (client) {
    if(!loading){
      Serial.println(F(""new client"")); // CRASH HERE
      bool endLn(false);
      char chr;
      int i(0);
      while (clientConnected(client)) {
        char received[clientAvailable(client)+2];
        while (clientAvailable(client)) {
          MP3player.pauseDataStream ();
          char c = client.read();
          MP3player.resumeDataStream ();
          received[i] = c;
          Serial.print(c); // OR HERE
          if (!endLn) {
            if (firstLineLength &lt; sizeof(firstLine)-2)
              firstLine[ firstLineLength++ ] = c;
            if (c == '\n') {
              endLn = true;
              firstLine[ firstLineLength ] = '\0'; // NUL-terminate
            }
          }
          ++i;
        }
        received[i+1] = '\0';
        i = 0;
        if(endLn){
          Serial.println();
          endLn = false;
          Serial.print(F(""first line : ""));
          Serial.println(firstLine);
        }
</code></pre>

<p>This will also save about 1600 bytes of program space.  There are many reasons to avoid String, and many people have written about the pitfalls.  If you use <code>String</code> elsewhere in your program, you should use a similar approach to eliminate it.</p>

<p>Another technique to reduce RAM is to avoid storing the data when it comes in, and then using it later.  Instead, use it immediately:</p>

<pre><code>void checkForClient(int loading){

  MP3player.pauseDataStream ();
  EthernetClient client = server.available();
  MP3player.resumeDataStream();
  if (client) {
    if(!loading){
      Serial.println(F(""new client"")); // CRASH HERE

      Serial.print(F(""first line : ""));
      bool endLn(false);

      char chr;
      int i(0);
      while (clientConnected(client)) {
        char received[clientAvailable(client)+2];
        while (clientAvailable(client)) {
          MP3player.pauseDataStream ();
          char c = client.read();
          MP3player.resumeDataStream ();
          received[i] = c;
          if (!endLn) {
            Serial.print(c); // printed now instead of saved for later
            if (c == '\n') {
              endLn = true;
            }
          }
          ++i;
        }
        received[i+1] = '\0';
        i = 0;
        if (endLn) {
          Serial.println();
          endLn = false;
          //Serial.println(firstLine); // NOT NEEDED, already printed!
        }
</code></pre>

<p>That saves all the RAM you would have used for <code>firstLine</code>.</p>

<p>You didn't post your entire program for our review, so you'll have to look for other variables that are too big, or that could be declared <em>inside</em> a routine (i.e., a local variable) instead of at file scope (i.e., a global variable, declared outside of any routines).</p>
",,44386831,141
36632210,2,36631942,2016-04-14T19:25:57.903,2,,6178493,,2016-04-14T19:25:57.903,,0,,"<p>The code shoud by:</p>

<pre><code> //time displayed on lcd
lcd.setCursor(4, 0);
lcd.print(now.hour(), DEC);
lcd.print(':');
lcd.print(now.minute(), DEC);
lcd.print(':');
if(now.second() &gt;= 10){
   lcd.setCursor(10,0);
   lcd.print(now.second(), DEC);
}
else if(now.second() &lt; 10){
  lcd.setCursor(11,0);
  lcd.print(now.second(), DEC);
  lcd.setCursor(10,0);
  lcd.print("" "");
} 
</code></pre>

<p>Remove Serial.print inside the if
Serial.print(now.second(), DEC) returns the number of bytes sended to the serial port. <a href=""https://www.arduino.cc/en/Serial/Print"" rel=""nofollow"">https://www.arduino.cc/en/Serial/Print</a>
It is not usefull here.</p>
",,44392618,102
36648410,2,36646395,2016-04-15T13:23:17.640,2,,4100891,,2016-04-15T13:23:17.640,,5,,"<p>The main problem is that these short ""messages"" (just a number) don't have any framing.  A delay or sleep doesn't count as framing, because the two system's times are not synchronized.  </p>

<p>I would suggest putting a newline between numbers so you can tell where one number ends and the next begins.  And watch out for differences in '\n' on the two systems... you could explicitly send a <code>(char)10</code> or <code>(char)13</code> and watch for the same byte in the receiver.  If a character gets dropped, the framing will allow you to resync to the message boundaries.  This also lets you eliminate the <code>delay</code> on the Arduino side, a very good thing.</p>

<p>A potential problem is here:</p>

<pre><code>if (index &lt; MaxChars&amp;&amp; isDigit(ch))
{
  inData[index++] = ch;
}
else
{
  inData[index] = 0;
</code></pre>

<p>The test should be <code>index &lt; MaxChars-1</code> because you add one more char for NUL termination.</p>

<p>When printing the received bytes on the xbox, you should put a delimiter between array elements: <code>printf(""%i,"",inData[i])</code>  The numbers you're looking at could be a 2 and a 3, or a 23, or a 238.</p>

<p>I minor change I would suggest: You are sending a floating-point value, but then you are converting the received string (after stopping at non-digits) to an integer with <code>atoi</code>.  The next time through the loop, you will get whatever characters you didn't read yet.  You might as well send the value as an integer: <code>(int)(speed*100.0)</code>.  This also avoids two other problems: %f3.3 will pad with spaces when speed &lt; 100.0 (the Arduino doesn't look for these); and fractional parts of the speed get truncated.</p>
",,44394619,153
36650624,2,36650547,2016-04-15T15:01:19.163,5,,557445,,2016-04-16T01:03:05.527,2016-04-16T01:03:05.527,5,,"<p>Integers cannot and do not recognize formatting like leading zeros. </p>

<p>The only way to store this type of information would be to use a string (like a <code>char[]</code> instead of an integer, however it looks like you are simply writing out the value so you shouldn't need a variable for it (as <code>printf()</code> will handle that for you).</p>

<pre><code>// %04d% will pad your number to 4 digits
printf(""%04d"", number);
</code></pre>

<p>If you do actually need to store your value, you can use <code>sprintf()</code> and declare your <code>result</code> as seen below :</p>

<pre><code>int number;
char *result = malloc(5);
</code></pre>

<p>and then set it within your <code>setup()</code> function as such :</p>

<pre><code>sprintf(result, ""%04d"", number);
</code></pre>

<p>Using both of these changes, your updated code might look like :</p>

<pre><code>int number;
char *result = malloc(5);

void setup() {
    number = 12;
    Serial.begin(9600);
    sprintf(result, ""%04d"", number);
}

void loop() {
    Serial.println(result);
}
</code></pre>

<p>Consider formatting your values when you are outputting them, otherwise you can use the integer values to perform any arithmetic and calculations with.</p>
",,44395231,1096
36658958,2,36650547,2016-04-16T00:47:25.537,3,,6211619,,2016-04-16T00:47:25.537,,0,,"<p>What's wrong with the code is that you are printing the return value of the 'printf' call. It returns the number of characters printed. Since it looks like stdio hasn't been setup yet, it returns -1 as an error flag. Read the manual page again, carefully.</p>

<p>On this line:</p>

<pre><code>result = printf(""%03d"", number);
</code></pre>

<p>we want to use 'sprintf' and not 'printf'.</p>

<p>'sprintf' needs to put its output string somewhere. Maybe pre-allocate it, making sure it is larger than your longest output string plus one (to hold the terminating nul character). Do not allocate it inside of 'setup', but put it outside of any routine (since you initialize it in one routine, and use it in another).</p>

<pre><code>char buf[6];

r = sprintf(buf, ""%04d"", number);

// now print the string inside of 'buf'
Serial.println(buf);
</code></pre>
",,44416941,397
36652774,2,36651114,2016-04-15T16:52:13.593,1,,4479909,,2016-04-15T16:52:13.593,,0,,"<p>assuming your number is unsigned, you could try the following:</p>

<pre><code>unsigned int i = 1234 ;
char array[5] ;

for(int j=0 ; i&gt;0 ; j++, i/=10)
   array[5-j] = (char)(i%10) ;
</code></pre>

<p>If your integer is signed, you would need an extra element in the array and some minor modifications to the code to account for the sign.</p>

<p>If what you want is in fact an array containing the ASCII representations of the digits (e.g. 1234 -> {'1','2','3','4'}), you should replace the last line above with</p>

<pre><code>   array[5-j] = (char)(i%10)+'0' ;
</code></pre>
",,44454300,236
36652920,2,36652840,2016-04-15T17:00:32.253,1,,253056,,2016-04-15T17:24:16.267,2016-04-15T17:24:16.267,8,,"<p>I would get rid of the duplication and do it more like this:</p>

<pre><code>#if defined(ARDUINO)
   #define K1 0xF0F0F0F0A2ULL
   #define K2 0xF0F0F0F0A1ULL
   #define K3 0xF0F0F0F0B2ULL
   #define K4 0xF0F0F0F0B1ULL
#else
   #define K1 0xF0F0F0F0A1ULL
   #define K2 0xF0F0F0F0A2ULL
   #define K3 0xF0F0F0F0B1ULL
   #define K4 0xF0F0F0F0B2ULL
#endif

const Channel channel1{ 1, K1, K2 };
const Channel channel2{ 2, K3, K4 };
</code></pre>

<p>You might also be able to consolidate the constants somewhat, if there is some kind of pattern.</p>
",,44472740,1969
36690790,2,36690492,2016-04-18T09:59:48.260,5,,4498831,,2016-04-18T15:42:15.087,2016-04-18T15:42:15.087,9,,"<p>You can make your own implementation :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;ctype.h&gt;

uint64_t getUInt64fromHex(char const *str)
{
    uint64_t accumulator = 0;
    for (size_t i = 0 ; isxdigit((unsigned char)str[i]) ; ++i)
    {
        char c = str[i];
        accumulator *= 16;
        if (isdigit(c)) /* '0' .. '9'*/
            accumulator += c - '0';
        else if (isupper(c)) /* 'A' .. 'F'*/
            accumulator += c - 'A' + 10;
        else /* 'a' .. 'f'*/
            accumulator += c - 'a' + 10;

    }

    return accumulator;
}

int main(void)
{
    printf(""%llu\n"", (long long unsigned)getUInt64fromHex(""43a2be2a42380""));
    return 0;
}
</code></pre>
",,44488382,3884
36691088,2,36690492,2016-04-18T10:14:55.937,0,,2638371,,2016-04-18T14:59:28.130,2016-04-18T14:59:28.130,7,,"<p>And more shorter convert:</p>

<pre><code>void str2hex(uint8_t * dst, uint8_t * str, uint16_t len)
{
    uint8_t byte;
    while (len) {
        byte = *str-(uint8_t)0x30;
        if (byte &gt; (uint8_t)0x9) byte -= (uint8_t)0x7;
        *dst = byte &lt;&lt; 4;
        str++;
        byte = *str-(uint8_t)0x30; 
        if (byte &gt; (uint8_t)0x9) byte -= (uint8_t)0x7;
        *dst |= byte;
        str++; dst++;
        len -= (uint16_t)0x1;
    }
}
</code></pre>

<p>And than for get uint64_t from unsigned char buffer:</p>

<pre><code>uint64_t hex2_64(uint8_t * ptr)
{
    uint64_t ret;
    ret = (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)56); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)48); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)40); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)32); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)24); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)16); ptr++;
    ret |= (uint64_t)((uint64_t)(*ptr) &lt;&lt; (uint64_t)8); ptr++;
    ret |= (uint64_t)(*ptr);
    return ret;
}
</code></pre>
",,44511623,967
36701626,2,36699535,2016-04-18T18:27:08.120,0,,6022656,,2016-04-18T18:27:08.120,,0,,"<p>It' not clear, for me, what you can use and what you can't.</p>

<p>Supposing that you can't use <code>std::vector</code>, but you can use good old C string (char *) function and input/output functions, I've prepared the following C-style example</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;


char * convertToEnglish (char *                      output,
                         std::size_t                 dimOut,
                         char const * const          input,
                         char const * const * const  morseCode,
                         std::size_t                 numMorseCodes)
 {
   if ( (nullptr == output) || (0U == dimOut) || (nullptr == input)
       || (nullptr == morseCode) || (0U == numMorseCodes) )
      throw std::runtime_error(""invalid input in cTE()"");

   std::size_t   posOut = 0U;
   std::size_t   index;
   char const *  ptrI0;
   char const *  ptrI1;
   char          currentLetter[5];

   std::memset(output, 0, dimOut);

   for ( ptrI0 = input ; nullptr != ptrI0 ; ptrI0 = ptrI1 )
    {
      ptrI1 = std::strpbrk(ptrI0, "" \n"");

      if ( nullptr == ptrI1 )
       {
         // last character if the string isn't cr terminated
         if ( sizeof(currentLetter) &lt;= strlen(ptrI0) )
            throw std::runtime_error(""to length last char in cTE()"");

         std::strcpy(currentLetter, ptrI0);
       }
      else
       {
         if ( sizeof(currentLetter) &lt;= (ptrI1 - ptrI0) )
            throw std::runtime_error(""to length char in cTE()"");

         std::memset(currentLetter, 0, sizeof(currentLetter));
         std::strncpy(currentLetter, ptrI0, (ptrI1 - ptrI0));

         if ( '\n' == *ptrI1 )
             ptrI1 = nullptr;
         else 
            ++ptrI1;
       }

      for ( index = 0U
           ;    (index &lt; numMorseCodes)
             &amp;&amp; strcmp(currentLetter, morseCode[index])
           ; ++index )
       ; 

      if ( numMorseCodes &lt;= index )
         throw std::runtime_error(""no morse code in cTE()"");

      output[posOut] = 'A' + index;

      if ( ++posOut &gt;= dimOut )
         throw std::runtime_error(""small out buffer in cTE()"");
    }

   return output;
 }


int main ()
 {
   constexpr char const * morseCode[] = {"".-"", ""-..."", ""-.-."",
      ""-.."", ""."", ""..-."", ""--."", ""...."", "".."", "".---"", ""-.-"", "".-.."",
      ""--"", ""-."", ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"",
      ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""};

   constexpr std::size_t  numMorseCodes
      = sizeof(morseCode)/sizeof(morseCode[0]);

   char *       input = nullptr;
   std::size_t  dim   = 0U;

   if ( getline(&amp;input, &amp;dim, stdin) == -1 )
      throw std::runtime_error(""error reading input"");

   char  output[1024];

   std::cout &lt;&lt; convertToEnglish(output, sizeof(output), input,
                                 morseCode, numMorseCodes) &lt;&lt; std::endl;

   return EXIT_SUCCESS;
 }
</code></pre>

<p>If you can use <code>std::vector</code> or <code>std::string</code>, can be made really simpler.</p>

<p>p.s.: sorry for my bad English</p>
",,44530390,122
36719511,2,36701979,2016-04-19T13:12:32.033,0,,959663,,2016-04-19T13:12:32.033,,0,,"<p>The solution was to, of course, move the problem code to a header file. So I moved this code to a new header file and included it in the main program and now it builds.</p>

<pre><code>// ModelRRCrossing.h

#ifndef _MODELRRCROSSING_h
#define _MODELRRCROSSING_h

#if defined(ARDUINO) &amp;&amp; ARDUINO &gt;= 100
    #include ""arduino.h""
#else
    #include ""WProgram.h""
#endif
#pragma once
// Arduino Digital I/O pin numbers for MEGA
//note: digital pins 30-45
//MEGA is a MUST for this project
enum {
    Relay1 = 30, Relay2 = 31, Relay3 = 32, Relay4 = 33, Relay5 = 34, Relay6 = 35,
    Relay7 = 36, Relay8 = 37, Relay9 = 38, Relay10 = 39, Relay11 = 40,
    Relay12 = 41, Relay13 = 42, Relay14 = 43, Relay15 = 44, Relay16 = 45
};

enum RelayState { RELAY_OFF = HIGH, RELAY_ON = LOW };
enum class CrossingZoneState : uint8_t {
    CROSSINGZONE_CLEAR = 0, // no train in crossing area, also initialized state
    CROSSINGZONE_OCCUPIED = 1, // train detected by the entry sensor
    CROSSINGZONE_EXITING = 2  // train detected by the exit sensor, when sensor clears, state= Clear
};
#endif
</code></pre>
",,44555949,610
36703923,2,36703831,2016-04-18T20:42:48.513,5,,225757,,2016-04-18T21:03:58.373,2016-04-18T21:03:58.373,0,,"<p>The problem in your code is:</p>

<pre><code>int *a;
readAcc(a); 

…

*a = (int16_t)(block[0] | block[1] &lt;&lt; 8);
</code></pre>

<p>In the first line, you declare a pointer to an <code>int</code>. This pointer points <em>somewhere</em>, since it is not initialized. Then, in the last line, you write to this <em>somewhere</em> in memory.</p>

<p>Instead, you should write this:</p>

<pre><code>int16_t a[3];
readAcc(a);
</code></pre>

<p>That way, you define the storage where the function <code>readAcc</code> can write to. The parameter to the <code>readAcc</code> function should not be a pointer to <code>int</code>, but a pointer to <code>int16_t</code>, since you use it as such.</p>

<p>Inside <code>readAcc</code>, you can then write:</p>

<pre><code>a[0] = …;
a[1] = …;
a[2] = …;
</code></pre>

<p>Instead of the array, you could also define a <code>struct xyz { int16_t x, y, z; }</code>, which describes more accurately what the code does.</p>

<p>I would write it like this:</p>

<pre><code>struct xyz {
    int16_t x, y, z;
};

void readACC(struct xyz *coord)
{
    printf(""entered readACC\n"");
    selectDevice(file, ACC_ADDRESS);

    uint8_t block[6];
    readBlock(0x80 | OUT_X_L_A, sizeof(block), block);

    coord-&gt;x = (int16_t)(block[0] | block[1] &lt;&lt; 8);
    coord-&gt;y = (int16_t)(block[2] | block[3] &lt;&lt; 8);
    coord-&gt;z = (int16_t)(block[4] | block[5] &lt;&lt; 8);        

    printf(""X axis: %4.2f, Y axis: %4.2f, Z axis: %4.2f\n"", 
        coord-&gt;x / 256.0, coord-&gt;y / 256.0, coord-&gt;z / 256.0);
}
</code></pre>

<ul>
<li>I defined the <code>struct xyz</code> to make the code self-explaining.</li>
<li>I moved the <code>selectDevice</code> call above the <code>block</code> declaration, since the <code>block</code> is not needed for that.</li>
<li>I replaced the <code>a</code> parameter with a better name, <code>coord</code>, which has an appropriate data type.</li>
<li>I corrected the arguments to the <code>printf</code> call to match the <code>%f</code> conversion specifier. (I hope the factor 256.0 is correct.) When you try to print an <code>int</code> using <code>%f</code>, the <em>behavior is undefined</em> (which is the worst thing that can happen in a C program).</li>
<li>I added newlines to the end of the <code>printf</code> format strings.</li>
</ul>
",,44572943,2030
36744053,2,36743680,2016-04-20T12:37:51.253,1,,1771055,,2016-04-20T12:37:51.253,,2,,"<pre><code>class web {
  private:
    Client&amp; _client;
};
</code></pre>

<p><code>_client</code> is a reference to <code>Client</code> object. Unlike a pointer, you cannot change where the reference ""points to"". So you have to initialize it with a value. </p>

<pre><code>  web::web(WiFiClient* client){
    _client = client;
  }
</code></pre>

<p>In your constructor you don't initialize your <code>_client</code> variable, but you try to assign it a value. Thats is why you get an error </p>

<blockquote>
  <p>error: uninitialized reference member 'web::_client'</p>
</blockquote>

<p>To initialize a reference you have to use initialize list in the constructor. Here is a simplified version, that also uses just one constructor, since you don't have to have both overloads.</p>

<pre><code>class web {
  public:
    web(Client&amp; client);
    void makeCall();
  private:
    Client&amp; _client;
    String getRequest(String server, int port, String url);
};

web::web(Client&amp; client)
: _client(client)
{
}
</code></pre>

<p>Then you can create a <code>web</code> object:</p>

<pre><code>WiFiClient client;
web webClient(client);
</code></pre>

<p>I suggest you read about references and pointers if you want to use them effectively. Otherwise you will continually have problems with them.</p>
",,44587611,790
36813368,2,36812818,2016-04-23T16:26:41.017,1,,6022656,,2016-04-23T16:26:41.017,,0,,"<p>I suspect that can be a problem of definition order: you first use <code>pulseUp()</code> and then you define it; you first use <code>pulseDown()</code> and then you define it.</p>

<p>My suggestion: try to invert the order: define <code>pulseDown()</code> first, <code>pulseUp()</code> next and, last, <code>pulser()</code></p>

<pre><code>void HookNinja::pulseDown() {
  digitalWrite(2, HIGH);
  _ticker2.detach();
}

void HookNinja::pulseUp(float onTime) {
  digitalWrite(2, LOW);
  _ticker2.attach(onTime, HookNinja::pulseDown);
}

void HookNinja::pulser(float period, float onTime) {
  _ticker1.attach(period, HookNinja::pulseUp, onTime);
}
</code></pre>

<p>p.s.: sorry for my bad English</p>
",,44597305,514
36826249,2,36826078,2016-04-24T17:03:58.080,7,,,user3995702,2016-04-24T17:03:58.080,,3,,"<p>It appears that on Arduino, pointers are 16 bit. I believe your confusion stems from what <code>*</code> means in this context.</p>

<p><code>sizeof(*byteptr)</code> is equivalent to the <code>sizeof(byte)</code>. The <code>*</code> does not indicate a pointer <em>type</em>, it indicates <em>dereferencing</em> the pointer stored in byteptr. Ergo, it is 1 byte, which you would expect from the type <code>byte</code>.</p>

<p><code>sizeof(byteptr)</code> does not dereference the pointer, and as such, is the size of the pointer itself, which on this system seems to be 2 bytes/16 bits.</p>

<p>Consider the following:</p>

<pre><code>#include ""iostream""

using namespace std;

int main()
{
    char a = 1;
    char* aP = &amp;a;

    cout &lt;&lt; ""sizeof(char): "" &lt;&lt; sizeof(char) &lt;&lt; endl;
    cout &lt;&lt; ""sizeof(char*): "" &lt;&lt; sizeof(char*) &lt;&lt; endl;
    cout &lt;&lt; ""sizeof(a): "" &lt;&lt; sizeof(a) &lt;&lt; endl;
    cout &lt;&lt; ""sizeof(aP): "" &lt;&lt; sizeof(aP) &lt;&lt; endl;
    cout &lt;&lt; ""sizeof(*aP): "" &lt;&lt; sizeof(*aP) &lt;&lt; endl;
}
</code></pre>

<p>Output (on a 64 bit OS/compiler):</p>

<pre><code>sizeof(char): 1
sizeof(char*): 8
sizeof(a): 1
sizeof(aP): 8
sizeof(*aP): 1
</code></pre>
",,44638938,4080
36832256,2,36826078,2016-04-25T04:55:01.843,2,,4256748,,2016-04-25T05:23:42.367,2016-04-25T05:23:42.367,3,,"<p>@Maseb I think you've gotten a good discussion of the differences between the size of a dereferenced pointer and the actual size of the pointer itself.  I'll just add that the <code>sizeof(byte_pointer)</code> must be large enough so that every address of memory space where a byte value could potentially be stored will fit into the pointer's memory width.  For example, if there 32,000 bytes of storage on your Arduino then you could potentially have a pointer that needs to point to the address 32,000.  Since 2^15 is about 32,000 you need 14 or 15 bits to create a unique address for each memory storage location.  We set pointer address space length to blocks of four bits.  Therefore, your Arduino has a 16bit address space for pointers and sizeof(byte_pointer) is 2 bytes, or 16 bits.</p>

<p>With that said, I'll go ahead an answer your other question too.  If you need to pass an array and a size, just create your own struct that includes both of those data elements.  Then you can pass the pointer to this templated struct which includes the size (This is the basic implementation for the C++ Array container).</p>

<p>I've written the short code sample below to demonstrate how to create your own template for an array with a size element and then use that size element to iterate over the elements.</p>

<pre><code>template&lt;int N&gt;
struct My_Array{
    int size = N;
    int elem[N];
};

//create the pointer to the struct
My_Array&lt;3&gt;* ma3 = new My_Array&lt;3&gt;;

void setup() {
    //now fill the array element
    for(int i=0; i &lt; ma3-&gt;size; i++) {
      ma3-&gt;elem[0]=i;
    }

    Serial.begin(9600);

    //now you can use the size value to iterate over the elements
    Serial.print(""ma3 is this big: "");
    Serial.println(ma3-&gt;size);

    Serial.println(""The array values are:"");
    Serial.print(""\t["");
    for(int i=0; i&lt;ma3-&gt;size; i++) {
         Serial.print(ma3-&gt;elem[i]);
         if(i &lt; ma3-&gt;size-1) Serial.print("", "");
    }
    Serial.println(""]"");
}

void loop() {
    while(true) { /* do nothing */ }
}
</code></pre>
",,44642165,383
36851557,2,36848295,2016-04-25T21:39:47.500,1,,1320881,,2016-04-25T21:39:47.500,,0,,"<p>Since the constructor arguments are meant to set the IO pin configuration for the LCD and those are compile time constants, I don't see a reason why the global object can't be initialised immediately:</p>

<pre><code>LiquidCrystal lcd(1, 2, 3, 4, 5, 6);
</code></pre>

<p>If it MUST be done in the function <code>void Crystal::begin()</code> then the only option is to create the object dynamically.</p>

<pre><code>LiquidCrystal *lcd;

void Crystal::begin()
{
    lcd = new LiquidCrystal(1, 2, 3, 4, 5, 6);
}
</code></pre>

<p>Just make sure to delete the object when you're done with it. Of course, if the object has to live forever, which is possible since it is global and this is a embedded project so the program never really ends, then you don't ever have to delete it.</p>
",,44664865,248
36849084,2,36848967,2016-04-25T19:08:18.340,1,,5508296,,2016-04-25T19:08:18.340,,1,,"<p>Just have a conditional expression:</p>

<pre><code>while(1) {
    wait(5);
    msensor.getAxis(mData);
    float mX = mData.x;
    float mY = mData.y;
    float mZ = mData.z;
    if (mX &gt;= mX_threshold &amp;&amp; mY &gt;= mY_threshold &amp;&amp; mZ &gt;= mZ_threshold)
        xbee.printf(""%.2f,%.2f,%.2f \r\n"",mX,mY,mZ);
}
</code></pre>

<p>where <code>mX_threshold</code> (and similarly for Y and Z) are the threshold constraints you want.</p>
",,44683769,358
37116283,2,36871334,2016-05-09T12:49:33.213,0,,3574571,,2016-05-09T12:49:33.213,,0,,"<p>Ok, 
It's look like no one has an answer, so I did a workaround that works for me and I will happy if it works for you.</p>

<p>at the time to execute qmake I aggregate one flag, for example</p>

<pre><code>qmake CONFIG+=MQ_ARM -r
</code></pre>

<p>It will execute qmake recursive and pass the flag to each .pro file.</p>

<p>In the .pro file you can add this:</p>

<pre><code>MQ_ARM {
    LIBS +=bla bla
    message(USING ARM LIBRARY)
} else:MQ_i686 {
    LIBS +=bla bla
    message(USING 32bits LIBRARY)
}
else {
    LIBS +=bla bla bla
    message(qmake configurated as x86_64 if you want another conf use qmake CONFIG+=MQ_ARM project.pro -
}
</code></pre>

<p>You can separate into another file project.pri and include in all subproject .pro files with include(project.pri)</p>

<p>Hope it helps!</p>
",,44727004,138
39792865,2,36871334,2016-09-30T13:36:10.810,4,,6877363,,2016-09-30T13:36:10.810,,2,,"<p>This worked for me:</p>

<pre><code>linux {
    contains(QMAKE_HOST.arch, arm.*):{
        raspberry's bla bla bla

    }else{
        ...
    }
}
</code></pre>

<p>I hope it works for you.</p>

<p><a href=""http://doc.qt.io/qt-5/qmake-variable-reference.html#qmake-host"" rel=""nofollow"">http://doc.qt.io/qt-5/qmake-variable-reference.html#qmake-host</a></p>
",,44729722,120
36915291,2,36913723,2016-04-28T12:53:06.573,0,,4854929,,2016-04-28T12:53:06.573,2017-05-23T10:33:58.780,4,,"<pre><code>char inChar(HANDLE port){
        char output = 0;
        DWORD noOfBytesRead = 0;
        int retval = ReadFile(port, &amp;output, 1, &amp;noOfBytesRead, NULL);
        if (retval == NULL) {
            return (NULL);
        }
        return(output);
    }
</code></pre>

<p>This is not correct since you are comparing retval (which is int) to NULL, and your function returns NULL as return value of char function. Although I don't believe that this causes reported issue it should be changed. </p>

<p>Take a look on accepted answer <a href=""https://stackoverflow.com/questions/6036716/serial-comm-using-writefile-readfile"">here</a>. I would suggest you to start from a working example on PC side and then to reduce it to your needs.</p>
",,44733265,281
36963881,2,36960748,2016-05-01T06:45:27.640,1,,4661589,,2016-05-03T19:59:38.693,2016-05-03T19:59:38.693,7,,"<p>You need change your code. Move <code>println</code> into <code>if</code> statement. </p>

<p>Try increase timeout interval, 2ms is not enough, good value (at 9600) lies above 10ms. Theoretically timeout should be at least 3.5 characters long and for current speed this equals ~0,4 ms. But in practice higher values are used.</p>

<pre><code>String test;
void setup(){
  Serial.begin(9600);
  Serial.setTimeout(10);// or more
  test = ""null"";
}
void loop(){
  if(Serial.available()){
    test = Serial.readString();
    Serial.println(test);// moved into if
  }
}
</code></pre>

<hr>

<p>Update: Another simple solution to return characters back looks like:</p>

<pre><code>void loop(){
      if(Serial.available()) Serial.write(Serial.read());
}
</code></pre>

<hr>

<p>Update 2: Had similar issue with BLE module HM10 (clone, not official). It was sending about 15 dummy bytes prior to any array. And i didn't solve it. But if weired bytes always the same you can make a simple trick using <a href=""https://www.arduino.cc/en/Reference/StringRemove"" rel=""nofollow"">String.remove()</a>: </p>

<pre><code>if(Serial.available()){
        test = Serial.readString();
        test.remove(0,5);
        // test.remove - add code to remove last character
        Serial.println(test);
 }
</code></pre>

<p>Also try another terminal. </p>
",,44735630,1827
36970452,2,36961326,2016-05-01T18:37:34.197,0,,1338603,,2016-05-01T18:37:34.197,,3,,"<p>Try something like this:</p>

<pre><code>void setup()
{
 Serial.begin(9600);
 randomSeed(analogRead(0));
 pinMode(led1, OUTPUT);      // sets the digital pin as output
 pinMode(led2, OUTPUT);
}

long interval2 = random(100,1500);

void loop()
{
 unsigned long m = millis();

 if (m - time1 &gt; interval1){
   time1 = m;

   if (value1 == LOW)
     value1 = HIGH;
   else
     value1 = LOW;

   digitalWrite(led1, value1);
 }

 if (m - time2 &gt; interval2){
   time2 = m;

   if (value2 == LOW) {
     value2 = HIGH;
     interval2 = random(100, 1500);
   } else {
     value2 = LOW;
     interval2 = random(100, 200);
   }

   digitalWrite(led2, value2);
 }
</code></pre>
",,44737252,94
36986791,2,36961326,2016-05-02T16:06:10.087,0,,6004486,,2016-05-02T16:39:24.403,2016-05-02T16:39:24.403,4,,"<p>This will always take less than a second to run so you can get back to your main loop and ensure that you don't miss the 1 second on/off for the other LED:</p>

<pre><code>void flicker(){
    boolean state = false;
    int r = random(20, 175);
    for(int i = 0; i &lt; 5; i++){
        digitalWrite(led2, state);
        state = !state;
        delay(r);
        r = random(20, 175);
    }
    digitalWrite(led2, HIGH);
}
</code></pre>

<p>Btw. I'm replacing this toggle code:</p>

<pre><code>if (value2 == LOW)
  value2 = HIGH;
else
  value2 = LOW;

digitalWrite(led2, value2);
</code></pre>

<p>with this:</p>

<pre><code>state = !state;
digitalWrite(led2, state);
</code></pre>

<p>Now, call <code>flicker()</code> at random intervals; maybe every 15-45 seconds or whatever you find appropriate/realistic. </p>
",,44748034,145
36976461,2,36973568,2016-05-02T06:47:42.677,3,,11654,,2016-05-02T06:47:42.677,,1,,"<p>Use some up-to-date example, like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;alsa/asoundlib.h&gt;

static const char *device = ""default"";

unsigned short buffer[2 * 24000];

int main(void)
{
    int err;
    snd_pcm_t *handle;

    if ((err = snd_pcm_open(&amp;handle, device, SND_PCM_STREAM_PLAYBACK, 0)) &lt; 0) {
        printf(""open error: %s\n"", snd_strerror(err));
        exit(EXIT_FAILURE);
    }
    if ((err = snd_pcm_set_params(handle,
                                  SND_PCM_FORMAT_S16,
                                  SND_PCM_ACCESS_RW_INTERLEAVED,
                                  2,              /* channels */
                                  48000,          /* rate */
                                  1,
                                  500000)) &lt; 0) { /* buffer: 0.5 sec */
        printf(""open error: %s\n"", snd_strerror(err));
        exit(EXIT_FAILURE);
    }

    for (;;) {
        for (int i = 0; i &lt; 24000; i++) {
            buffer[2 * i + 0] = 32767 * sin(...); /* left channel */
            buffer[2 * i + 1] = 32767 * sin(...); /* right channel */
        }

        snd_pcm_sframes_t frames = snd_pcm_writei(handle, buffer, 24000);
        if (frames &lt; 0)
            frames = snd_pcm_recover(handle, frames, 0);
        if (frames &lt; 0) {
            printf(""snd_pcm_writei failed: %s\n"", snd_strerror(err));
            break;
        }
    }

    snd_pcm_close(handle);
    return 0;
}
</code></pre>
",,44754077,1419
36981895,2,36981513,2016-05-02T11:58:26.317,1,,5636775,,2016-05-02T11:58:26.317,,2,,"<p>You can cast the functions explicitly to the correct type:</p>

<pre><code>typedef ssize_t (*I2CCMD)(int, void *, size_t);

cthis-&gt;WR = (I2CCMD)write;

cthis-&gt;WR = (I2CCMD)read;
</code></pre>

<p>This should eliminate the error.</p>
",,44842834,211
36983726,2,36982362,2016-05-02T13:32:40.517,1,,1329652,,2016-05-02T13:46:20.340,2016-05-02T13:46:20.340,0,,"<p>There are several problems:</p>

<ol>
<li><p>You're appending to <code>serialBuffer</code>, but you never empty it out. The <code>QIODevice</code> already maintains an internal, resizable circular buffer for you, so a second one is not necessary.</p></li>
<li><p>You're going from binary representation to a <code>QString</code> via a <code>std::string</code>. That is completely unnecessary.</p></li>
<li><p>You're not explicit about what character encoding is used in the binary data.</p></li>
<li><p>The UI is updated repeatedly, instead of at most once per <code>readyRead</code> signal.</p></li>
<li><p>You're using magic constants. You should UTF-8 encode your source instead, or use a named <code>QChar</code> constant.</p></li>
<li><p>You're manually building strings using string operators, this impedes internationalization and maintainability.</p></li>
<li><p>You're using spaces as a mechanism to align the display in your UI. Perhaps you should design your UI in a different manner, so that such hacks won't be necessary.</p></li>
</ol>

<p>I presume that your strings are separated somehow - perhaps each is in a separate line? In any case, you should keep reading the complete delimited strings from the device as long as they are available. The <code>QIODevice::readLine</code> method makes it easy in case of line-delimited data:</p>

<pre><code>void Dolle::serialReceived() {
  QString validLine;
  while (serial-&gt;canReadLine()) {
    auto binLine = serial-&gt;readLine();
    auto line = QString::fromLatin1(binLine);
    if (line.length() &lt; 8)
      continue;
    validLine = line;
  }
  if (validLine.isEmpty()) return;
  auto hum = line.left(2);
  auto temp = line.mid(2, 2);
  auto gas = line.mid(4, 4);
  ui-&gt;humLabel-&gt;setText(QStringLiteral(""Humidity: %1%"").arg(hum));
  ui-&gt;tempLabel-&gt;setText(QStringLiteral(""Temperature: %1°C"").arg(temp));
  ui-&gt;gasLabel-&gt;setText(QStringLiteral(""Gas level: %1"").arg(gas));
}
</code></pre>

<p>Suppose that instead of line-separated data, your data arrives in fixed-size chunks. You'd process them in a similar fashion:</p>

<pre><code>void Dolle::serialReceived() {
  QString validPacket;
  while (serial-&gt;bytesAvailable() &gt;= 8) {
    auto bin = serial-&gt;read(8);
    auto packet = QString::fromLatin1(bin);
    if (packet.length() &lt; 8)
      continue;
    validPacket = packet;
  }
  ...
}
</code></pre>
",,44856599,389
37002253,2,37002058,2016-05-03T10:58:10.710,0,,6022656,,2016-05-05T14:56:19.773,2016-05-05T14:56:19.773,7,,"<p>In this call</p>

<pre><code>for(i = 0; i &lt; sizeof(y); i++){
  EEPROM.write(addr+i, y);
}
</code></pre>

<p><code>y</code> is (if I'm not wrong) of type <code>char[]</code> (more or less <code>char *</code>) and the second argment of <code>EEPROM.write()</code> should be (according to the error message) a <code>uint8_t</code> (similar to a <code>char</code>)</p>

<p>I suppose you should write something like</p>

<pre><code>for(i = 0; i &lt; sizeof(y); ++i){
  EEPROM.write(addr+i, y[i]);
}
</code></pre>

<p>or (using the union)</p>

<pre><code>for(i = 0; i &lt; sizeof(b); ++i){
  EEPROM.write(addr+i, b[i]);
}
</code></pre>

<p>like in <code>EEPROMReadAny()</code>.</p>

<p>Unrelated suggestion: taking in count that you confront it with an unsigned value (<code>sizeof(y)</code>), it's better if you define <code>i</code> (in <code>EEPROMReadAny()</code> and in <code>EEPROMWriteAny()</code>) <code>unsigned</code> or <code>std::size_t</code>.</p>

<p>p.s.: sorry for my bad English.</p>

<p><strong>--- EDIT ---</strong></p>

<p>Second question: error ""invalid conversion from 'char*' to 'char' [-fpermissive] eepBLEtoothchar.EEPROMReadAny(readaddrSSID, readSSID);""</p>

<p>I don't understand this error, but... I see a couple of other problems.</p>

<p><strong>I problem</strong></p>

<p>You define <code>eepblueString</code></p>

<pre><code> EEPROMAnyType&lt;char*&gt; eepblueString;
</code></pre>

<p>as a <code>EEPROMAnyType&lt;char*&gt;</code>. So, in <code>EEPROMAnyType&lt;E&gt;</code>, the type <code>E</code> is a <code>char *</code>. And <code>sizeof(E)</code> is 4 (or 8, if you are in a 64 bit platform).</p>

<p>When you pass <code>readPASS</code> and <code>readSSID</code>, they are <code>char[80]</code> so, I suppose, your intention is read 80 chars. But your object try to read only 4 (or 8) chars. </p>

<p><strong>II problem</strong></p>

<p>The second argument to <code>EEPROMReadAny()</code> is passed by <strong>value</strong>; so you can read 4 (or 8) chars but they are loose when you exit from the method. To save the readed chars, you should pass the second argument by reference.</p>

<p>You really need the <code>EEPROMAnyType</code>?</p>

<p>I mean: if <code>EEPROMReadAny()</code> can be a simple function, you can deduce the <code>E</code> type from the second argument, avoiding the first problem.</p>

<p>I propose the following solution (should solve the II problem to, passing the second argument by reference)</p>

<pre><code>template &lt;class E&gt;
int EEReadAny (unsigned int add, E &amp; x)
 {
   char * b = (char *)&amp;x;

   for ( unsigned ui = 0U ; ui &lt; sizeof(E) ; ++ui )
      b[ui] = EEPROM.read(addr+i);

   return sizeof(E);
 }
</code></pre>
",,44868823,82
37441369,2,37013039,2016-05-25T15:18:45.617,1,,2836621,,2016-06-03T10:43:58.567,2016-06-03T10:43:58.567,41,,"<p><strong>Updated Answer</strong></p>

<p>I have updated my original answer here to show how to copy the acquired data into a <code>CImg</code> structure and also to show 2 worker threads that can then process the image while the main thread continues to acquire frames at the full speed. It achieves 60 frames per second. </p>

<p>I have not done any processing inside the worker threads because I don't know what you want to do. All I did was save the last frame to disk to show that the acquisition into a CImg is working. You could have 3 worker threads. You could pass one frame to each thread on a round-robin basis, or you could have each of 2 threads process half the frame at each iteration. Or each of 3 threads process one third of a frame. You could change the polled wakeups to use condition variables.</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;raspicam/raspicam.h&gt;

// Don't want any X11 display by CImg
#define cimg_display 0

#include &lt;CImg.h&gt;

using namespace cimg_library;
using namespace std;

#define NFRAMES     1000
#define NTHREADS    2
#define WIDTH       1280
#define HEIGHT      960

// Commands/status for the worker threads
#define WAIT    0
#define GO      1
#define GOING   2
#define EXIT    3
#define EXITED  4
volatile int command[NTHREADS];

// Serialize access to cout
std::mutex cout_mutex;

// CImg initialisation
// Create a 1280x960 greyscale (Y channel of YUV) image
// Create a globally-accessible CImg for main and workers to access
CImg&lt;unsigned char&gt; img(WIDTH,HEIGHT,1,1,128);

////////////////////////////////////////////////////////////////////////////////
// worker thread - There will 2 or more of these running in parallel with the
//                 main thread. Do any image processing in here.
////////////////////////////////////////////////////////////////////////////////
void worker (int id) {

   // If you need a ""results"" image of type CImg, create it here before entering
   // ... the main processing loop below - you don't want to do malloc()s in the
   // ... high-speed loop
   // CImg results...

   int wakeups=0;

   // Create a white for annotating
   unsigned char white[] = { 255,255,255 };

   while(true){
      // Busy wait with 500us sleep - at worst we only miss 50us of processing time per frame
      while((command[id]!=GO)&amp;&amp;(command[id]!=EXIT)){
         std::this_thread::sleep_for(std::chrono::microseconds(500));
      }
      if(command[id]==EXIT){command[id]=EXITED;break;}
      wakeups++;

      // Process frame of data - access CImg structure here
      command[id]=GOING;

      // You need to add your processing in HERE - everything from
      // ... 9 PIXELS MATRIX GRAYSCALE VALUES to
      // ... THRESHOLDING CONDITION

      // Pretend to do some processing.
      // You need to delete the following ""sleep_for"" and ""if(id==0...){...}""
      std::this_thread::sleep_for(std::chrono::milliseconds(2));

      if((id==0)&amp;&amp;(wakeups==NFRAMES)){
         // Annotate final image and save as PNG
         img.draw_text(100,100,""Hello World"",white);
         img.save_png(""result.png"");
      }
   }

   cout_mutex.lock();
   std::cout &lt;&lt; ""Thread["" &lt;&lt; id &lt;&lt; ""]: Received "" &lt;&lt; wakeups &lt;&lt; "" wakeups"" &lt;&lt; std::endl;
   cout_mutex.unlock();
}

int main ( int argc,char **argv ) {

   raspicam::RaspiCam Camera;
   // Allowable values: RASPICAM_FORMAT_GRAY,RASPICAM_FORMAT_RGB,RASPICAM_FORMAT_BGR,RASPICAM_FORMAT_YUV420
   Camera.setFormat(raspicam::RASPICAM_FORMAT_YUV420);

   // Allowable widths: 320, 640, 1280
   // Allowable heights: 240, 480, 960
   // setCaptureSize(width,height)
   Camera.setCaptureSize(WIDTH,HEIGHT);

   std::cout &lt;&lt; ""Main: Starting""  &lt;&lt; std::endl;
   std::cout &lt;&lt; ""Main: NTHREADS:"" &lt;&lt; NTHREADS &lt;&lt; std::endl;
   std::cout &lt;&lt; ""Main: NFRAMES:""  &lt;&lt; NFRAMES  &lt;&lt; std::endl;
   std::cout &lt;&lt; ""Main: Width: ""   &lt;&lt; Camera.getWidth()  &lt;&lt; std::endl;
   std::cout &lt;&lt; ""Main: Height: ""  &lt;&lt; Camera.getHeight() &lt;&lt; std::endl;

   // Spawn worker threads - making sure they are initially in WAIT state
   std::thread threads[NTHREADS];
   for(int i=0; i&lt;NTHREADS; ++i){
      command[i]=WAIT;
      threads[i] = std::thread(worker,i);
   }

   // Open camera
   cout&lt;&lt;""Opening Camera...""&lt;&lt;endl;
   if ( !Camera.open()) {cerr&lt;&lt;""Error opening camera""&lt;&lt;endl;return -1;}

   // Wait until camera stabilizes
   std::cout&lt;&lt;""Sleeping for 3 secs""&lt;&lt;endl;
   std::this_thread::sleep_for(std::chrono::seconds(3));

   for(int frame=0;frame&lt;NFRAMES;frame++){
      // Capture frame
      Camera.grab();

      // Copy just the Y component to our mono CImg
      std::memcpy(img._data,Camera.getImageBufferData(),WIDTH*HEIGHT);

      // Notify worker threads that data is ready for processing
      for(int i=0; i&lt;NTHREADS; ++i){
         command[i]=GO;
      }
   }

   // Let workers process final frame, then tell to exit
   std::this_thread::sleep_for(std::chrono::milliseconds(50));

   // Notify worker threads to exit
   for(int i=0; i&lt;NTHREADS; ++i){
      command[i]=EXIT;
   }

   // Wait for all threads to finish
   for(auto&amp; th : threads) th.join();
}
</code></pre>

<p><strong>Note on timing</strong></p>

<p>You can time code like this:</p>

<pre><code>#include &lt;chrono&gt;

typedef std::chrono::high_resolution_clock hrclock;

hrclock::time_point t1,t2;

t1 = hrclock::now();
// do something that needs timing
t2 = hrclock::now();

std::chrono::nanoseconds elapsed = t2-t1;
long long nanoseconds=elapsed.count();
</code></pre>

<p><strong>Original Answer</strong></p>

<p>I have been doing some experiments with <strong>Raspicam</strong>. I downloaded their code from SourceForge and modified it slightly to do some simple, capture-only tests. The code I ended up using looks like this:</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;raspicam/raspicam.h&gt;
#include &lt;unistd.h&gt; // for usleep()
using namespace std;

#define NFRAMES 1000

int main ( int argc,char **argv ) {

    raspicam::RaspiCam Camera;
    // Allowable values: RASPICAM_FORMAT_GRAY,RASPICAM_FORMAT_RGB,RASPICAM_FORMAT_BGR,RASPICAM_FORMAT_YUV420
    Camera.setFormat(raspicam::RASPICAM_FORMAT_YUV420);

    // Allowable widths: 320, 640, 1280
    // Allowable heights: 240, 480, 960
    // setCaptureSize(width,height)
    Camera.setCaptureSize(1280,960);

    // Open camera 
    cout&lt;&lt;""Opening Camera...""&lt;&lt;endl;
    if ( !Camera.open()) {cerr&lt;&lt;""Error opening camera""&lt;&lt;endl;return -1;}

    // Wait until camera stabilizes
    cout&lt;&lt;""Sleeping for 3 secs""&lt;&lt;endl;
    usleep(3000000);
    cout &lt;&lt; ""Grabbing "" &lt;&lt; NFRAMES &lt;&lt; "" frames"" &lt;&lt; endl;

    // Allocate memory
    unsigned long bytes=Camera.getImageBufferSize();
    cout &lt;&lt; ""Width: ""  &lt;&lt; Camera.getWidth() &lt;&lt; endl;
    cout &lt;&lt; ""Height: "" &lt;&lt; Camera.getHeight() &lt;&lt; endl;
    cout &lt;&lt; ""ImageBufferSize: "" &lt;&lt; bytes &lt;&lt; endl;;
    unsigned char *data=new unsigned char[bytes];

    for(int frame=0;frame&lt;NFRAMES;frame++){
       // Capture frame
       Camera.grab();

       // Extract the image
       Camera.retrieve ( data,raspicam::RASPICAM_FORMAT_IGNORE );

       // Wake up a thread here to process the frame with CImg
    }
    return 0;
}
</code></pre>

<p>I dislike <code>cmake</code> so I just compiled like this:</p>

<pre><code>g++ -std=c++11 simpletest.c -o simpletest -I. -I/usr/local/include -L /opt/vc/lib -L /usr/local/lib -lraspicam -lmmal -lmmal_core -lmmal_util
</code></pre>

<p>I found that, regardless of the dimensions of the image, and more or less regardless of the encoding (RGB, BGR, GRAY) it achieves 30 fps (frames per second).</p>

<p>The only way I could get better than that was by making the following changes:</p>

<ul>
<li><p>in the code above, use RASPICAM_FORMAT_YUV420 rather than anything else</p></li>
<li><p>editing the file <code>private_impl.cpp</code> and changing line 71 to set the framerate to 90.</p></li>
</ul>

<p>If I do that, I can achieve 66 fps.</p>

<p>As the Raspberry Pi is only a pretty lowly 900MHz CPU but with 4 cores, I would guess you would want to start 1-3 extra threads at the beginning outside the loop and then wake one, or more of them up where I have noted in the code to process the data. The first thing they would do is copy the data out of the acquisition buffer before the next frame started - or have multiple buffers and use them in a round-robin fashion.</p>

<p><strong>Notes on threading</strong></p>

<p>In the following diagram, green represents the <code>Camera.grab()</code> where you acquire the image, and red represents the processing you do after the image is acquired. At the moment, you are acquiring the data (green), and then processing it (red) before you can acquire the next frame. Note that 3 of your 4 CPUs do nothing.</p>

<p><a href=""https://i.stack.imgur.com/NfPhc.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NfPhc.gif"" alt=""enter image description here""></a></p>

<p>What I am suggesting is that you offload the processing (red) to the other CPUs/threads and keep acquiring new data (green) as fast as possible. Like this:</p>

<p><a href=""https://i.stack.imgur.com/6pKKN.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6pKKN.gif"" alt=""enter image description here""></a></p>

<p>Now you see you get more frames (green) per second.</p>
",,44894184,139
39689074,2,37041961,2016-09-25T16:18:37.453,0,,4513509,,2016-09-25T16:18:37.453,,0,,"<p>If you open up the Arduino IDE, under the menu, look at:</p>

<p><code>File &gt; Examples &gt; 08.Strings &gt; CharacterAnalysis</code></p>

<p>Here I think you'll find something very close what you're looking for. To sum up, it opens a Serial connection (USB) and reads input from the computer. (You'll need to make sure you match the baud rate and use the ""send"" button.) It's up to you do program the Arduino as you'd like. In the example's case, it simply sends feedback back to the the Serial Monitor. Run it for yourself and see what happens :)</p>

<p>A [MCVE] snippet from the example:</p>

<pre><code>void setup() {
    // Open serial communications and wait for port to open:
    Serial.begin(9600);
    while (!Serial) {
        ; // wait for serial port to connect. Needed for native USB port only
    }

    // send an intro:
    Serial.println(""send any byte and I'll tell you everything I can about it"");
    Serial.println();
}

void loop() {
    // get any incoming bytes:
    if (Serial.available() &gt; 0) {
        int thisChar = Serial.read();

        // say what was sent:
        Serial.print(""You sent me: \'"");
        Serial.write(thisChar);
}
</code></pre>
",,44940440,76
37106239,2,37106198,2016-05-09T00:20:45.410,2,,1621391,,2016-05-09T00:50:13.900,2016-05-09T00:50:13.900,1,,"<p>That error means you have those variables appearing in multiple translation units. By default, non-<code>const</code> global variables have external linkage.</p>

<p>To make it internal, you can qualify it with <code>static</code>. Or you can simply move the definitions to your translation unit (.cpp file)</p>

<hr>

<p>Qualify with <code>static</code> in Work.h</p>

<pre><code>static int ledPin;      // the number of the LED pin
static unsigned long OnTime;     // milliseconds of on-time
static unsigned long OffTime;    // milliseconds of off-time

static int ledState;                   // ledState used to set the LED
static unsigned long previousMillis;   // will store last time LED was updated
class Work {

public:
    Work(int pin, long on, long off);
    void Update();
};
</code></pre>

<p>Preferably, move them to your .cpp files since you aren't using them in your Work.h file.</p>

<p><strong>EDIT</strong></p>

<p>The error resulted from your <code>Update()</code> function in the .cpp file.</p>

<pre><code>void Update() { ....
</code></pre>

<p>^^ that defined a new function, and is using those global variables... I believe you wanted to do</p>

<pre><code>void Work::Update() {....
</code></pre>
",,44966525,444
37156341,2,37134896,2016-05-11T07:53:53.573,0,,6311142,,2016-07-29T08:36:13.573,2016-07-29T08:36:13.573,2,,"<p>Ok so it was a bit adiot...</p>

<p>I tried to read a answer that finihed with \r but the real answer don't finish with it...</p>

<p>I change with :</p>

<pre><code>do {
    rd = read(fd, &amp;buff, 1);
    sprintf(&amp;resp[spot], ""%c"", buff);
    spot += rd;
} while (buff != 0x13 &amp;&amp; rd &gt; 0);
</code></pre>

<p>And now it works fine. It as just trying to read non-existent characters.</p>

<p>EDIT :</p>

<p>@VenushkaT asked me a question about some problems in this code. Since I did something that works prerry well now, I post my new code :</p>

<pre><code>void R1logger::listenPort()
{
// Creation of a buffer to store data from radio module

fill_n(buff, 2048, '\0');

this-&gt;ind = 0;

while(this-&gt;fd &gt; 0)
{
    // Creation of a buffer that stores data from serial port
    char mes[1024];
    fill_n(mes, 1024, '0');
    // read is a blocking call so this function will not return until it effectively reads some data or if there is a problem
    int rd = read(this-&gt;fd, &amp;mes, sizeof(mes));

    /*struct timeval tv;
    gettimeofday(&amp;tv, NULL);
    unsigned long long check1 = (unsigned long long)(tv.tv_sec) * 1000 + (unsigned long long)(tv.tv_usec) / 1000;*/
    if (rd &gt; 0)
    {
        storeInBuff(mes, rd);
        fill_n(mes, 1024, '0');

        // If some data are read, we can have only a part of the frame so we call ""poll"" to wait for the rest of the data with a 10ms timeout
        struct pollfd fds;
        fds.fd = this-&gt;fd;
        fds.events = POLLIN | POLLPRI;
        int slct = 1;

        while (slct &gt; 0)
        {
            slct = poll(&amp;fds, 1, 10);
            if (slct &gt; 0)
            {
                rd = read(this-&gt;fd, &amp;mes, sizeof(mes));
                if (rd &gt; 0)
                {
                    storeInBuff(mes, rd);
                }
                else
                {
                    close(this-&gt;fd);
                    serialConfig();
                }
            }
        }

        /*gettimeofday(&amp;tv, NULL);
        unsigned long long check2 = (unsigned long long)(tv.tv_sec) * 1000 + (unsigned long long)(tv.tv_usec) / 1000;
        unsigned long tmps = check2 - check1;
        cout &lt;&lt; ""Temps de lecture : "" &lt;&lt; tmps &lt;&lt; endl;*/

        /*gettimeofday(&amp;tv, NULL);
        check1 = (unsigned long long)(tv.tv_sec) * 1000 + (unsigned long long)(tv.tv_usec) / 1000;*/

        // Once the message is entirely read, we extract the radio frames
        findFrame(0);

        /*gettimeofday(&amp;tv, NULL);
        check2 = (unsigned long long)(tv.tv_sec) * 1000 + (unsigned long long)(tv.tv_usec) / 1000;
        tmps = check2 - check1;
        cout &lt;&lt; ""Temps calcul + ecriture sur disque : "" &lt;&lt; tmps &lt;&lt; endl;*/


        this-&gt;ind = 0;
        fill_n(buff, 2048, '\0');
    }
    else
    {
        close(this-&gt;fd);
        serialConfig();
    }
}
}
</code></pre>

<p>This code uses less CPu since there are blocking call (read, select), and there is no O_NONBLOCKING option set.
I also consider the case where read fails.</p>

<p>In another post, some people game me advice for serial configuration (there was some bugs on some options and they gave me advice to be more POSIX compliant so here it is :</p>

<pre><code>void R1logger::serialConfig()
{

// Open Serial Port

this-&gt;fd = open(""/dev/ttyUSB0"", O_RDWR | O_NOCTTY);

if (this-&gt;fd &lt; 0 )
{
    cout &lt;&lt; ""Error "" &lt;&lt; errno &lt;&lt; "" opening /dev/ttyUSB0: "" &lt;&lt; strerror(errno) &lt;&lt; endl;
}
else
{
    //Configure Serial Port
    struct termios tty;

    if (tcgetattr (this-&gt;fd, &amp;tty) != 0)
    {
        cout &lt;&lt; ""Error "" &lt;&lt; errno &lt;&lt; "" from tcgetattr: "" &lt;&lt; strerror (errno) &lt;&lt; endl;
    }

    cfsetispeed(&amp;tty, B57600);
    cfsetospeed(&amp;tty, B57600);

    tty.c_cflag &amp;= ~PARENB;
    tty.c_cflag &amp;= ~CSTOPB;
    tty.c_cflag &amp;= ~CSIZE;
    tty.c_cflag |= CS8;
    tty.c_cc[VMIN] = 1;
    tty.c_cc[VTIME] = 50;

    tty.c_cflag |= CREAD | CLOCAL;

    cfmakeraw(&amp;tty);

    tcflush(this-&gt;fd, TCIFLUSH);

    if (tcsetattr(this-&gt;fd, TCSANOW, &amp;tty) != 0) 
    {
        cout &lt;&lt; ""Error "" &lt;&lt; errno &lt;&lt; "" from tcsetattr"" &lt;&lt; endl;
    }
}
}
</code></pre>
",,44989366,3225
37152091,2,37151109,2016-05-11T02:26:26.993,0,,4466202,,2016-05-11T12:06:24.807,2016-05-11T12:06:24.807,2,,"<p>Its telling you the truth.   </p>

<pre><code> 'string' does not name a type
</code></pre>

<p>Instead of </p>

<pre><code> `string code` use  `String code`



 void setup() {
      // put your setup code here, to run once:
    String code = ""10101010010010100101000101010101111100"";

    }
</code></pre>

<p><strong>Update</strong>
we dont need any to include anything for this</p>
",,45033498,87
37710969,2,37191164,2016-06-08T19:11:44.990,1,,5712501,,2016-06-10T10:20:34.560,2016-06-10T10:20:34.560,1,,"<p>Aprox folder structure:</p>

<pre><code>aws_iot
 | - embedded C sdk folders
 | - .... 
sample
 | - include
     | - aws_iot_config.h
 | - src
     | - subscribe_publish_sample.c
</code></pre>

<p>Original Makefile (updated version)</p>

<pre><code>.prevent_execution:
    exit 0
#This target is to ensure accidental execution of Makefile as a bash script will not execute commands like rm in unexpected directories and exit gracefully.

CC = gcc

#remove @ for no make command prints
DEBUG=@

APP_DIR = .
APP_INCLUDE_DIRS += -I $(APP_DIR)
APP_NAME=subscribe_publish_sample
APP_SRC_FILES=$(APP_NAME).c

#IoT client directory
IOT_CLIENT_DIR=../../aws_iot_src
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/utils

PLATFORM_DIR = $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
PLATFORM_COMMON_DIR = $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
IOT_SRC_FILES += $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/aws_iot_mqtt_embedded_client_wrapper.c
IOT_SRC_FILES += $(shell find $(PLATFORM_DIR)/ -name '*.c')
IOT_SRC_FILES += $(shell find $(PLATFORM_COMMON_DIR)/ -name '*.c')

#MQTT Paho Embedded C client directory
MQTT_DIR = ../../aws_mqtt_embedded_client_lib
MQTT_C_DIR = $(MQTT_DIR)/MQTTClient-C/src
MQTT_EMB_DIR = $(MQTT_DIR)/MQTTPacket/src

MQTT_INCLUDE_DIR += -I $(MQTT_EMB_DIR)
MQTT_INCLUDE_DIR += -I $(MQTT_C_DIR)

MQTT_SRC_FILES += $(shell find $(MQTT_EMB_DIR)/ -name '*.c')
MQTT_SRC_FILES += $(MQTT_C_DIR)/MQTTClient.c


#TLS - openSSL
TLS_LIB_DIR = /usr/lib/
TLS_INCLUDE_DIR = -I /usr/include/openssl
EXTERNAL_LIBS += -L$(TLS_LIB_DIR)
LD_FLAG := -ldl -lssl -lcrypto
LD_FLAG += -Wl,-rpath,$(TLS_LIB_DIR)

#Aggregate all include and src directories
INCLUDE_ALL_DIRS += $(IOT_INCLUDE_DIRS) 
INCLUDE_ALL_DIRS += $(MQTT_INCLUDE_DIR) 
INCLUDE_ALL_DIRS += $(TLS_INCLUDE_DIR)
INCLUDE_ALL_DIRS += $(APP_INCLUDE_DIRS)

SRC_FILES += $(MQTT_SRC_FILES)
SRC_FILES += $(APP_SRC_FILES)
SRC_FILES += $(IOT_SRC_FILES)

# Logging level control
LOG_FLAGS += -DIOT_DEBUG
LOG_FLAGS += -DIOT_INFO
LOG_FLAGS += -DIOT_WARN
LOG_FLAGS += -DIOT_ERROR


COMPILER_FLAGS += -g
COMPILER_FLAGS += $(LOG_FLAGS)
#If the processor is big endian uncomment the compiler flag
#COMPILER_FLAGS += -DREVERSED

MAKE_CMD = $(CC) $(SRC_FILES) $(COMPILER_FLAGS) -o $(APP_NAME) $(LD_FLAG) $(EXTERNAL_LIBS) $(INCLUDE_ALL_DIRS)

all:
    $(PRE_MAKE_CMD)
    $(DEBUG)$(MAKE_CMD)
    $(POST_MAKE_CMD)

clean:
    rm -f $(APP_DIR)/$(APP_NAME)    
</code></pre>

<p>Converted CMakeLists.txt</p>

<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(sample)


# Setup appropriate path to C SDK
set(AWS_IOT_ROOT_DIR ../aws_iot)

#IoT client directory
#&gt; IOT_CLIENT_DIR=../../aws_iot_src
set(IOT_CLIENT_DIR ${AWS_IOT_ROOT_DIR}/aws_iot_src)

#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt
#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper
#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux
#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
#&gt; IOT_INCLUDE_DIRS += -I $(IOT_CLIENT_DIR)/utils
include_directories(
    ${IOT_CLIENT_DIR}/protocol/mqtt
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
    ${IOT_CLIENT_DIR}/utils
)


#&gt; PLATFORM_DIR = $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
set(PLATFORM_DIR ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl)

#&gt; PLATFORM_COMMON_DIR = $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
set(PLATFORM_COMMON_DIR ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common)

#&gt; IOT_SRC_FILES += $(IOT_CLIENT_DIR)/protocol/mqtt/aws_iot_embedded_client_wrapper/aws_iot_mqtt_embedded_client_wrapper.c
#&gt; IOT_SRC_FILES += $(shell find $(PLATFORM_DIR)/ -name '*.c')
#&gt; IOT_SRC_FILES += $(shell find $(PLATFORM_COMMON_DIR)/ -name '*.c')
file(GLOB IOT_SRC_FILES
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/aws_iot_mqtt_embedded_client_wrapper.c
    ${PLATFORM_DIR}/*.c
    ${PLATFORM_COMMON_DIR}/*.c
)

#MQTT Paho Embedded C client directory
#&gt; MQTT_DIR = ../../aws_mqtt_embedded_client_lib
set(MQTT_DIR ${AWS_IOT_ROOT_DIR}/aws_mqtt_embedded_client_lib)

#&gt; MQTT_C_DIR = $(MQTT_DIR)/MQTTClient-C/src
set(MQTT_C_DIR ${MQTT_DIR}/MQTTClient-C/src)

#&gt; MQTT_EMB_DIR = $(MQTT_DIR)/MQTTPacket/src
set(MQTT_EMB_DIR ${MQTT_DIR}/MQTTPacket/src)


#&gt; MQTT_SRC_FILES += $(shell find $(MQTT_EMB_DIR)/ -name '*.c')
#&gt; MQTT_SRC_FILES += $(MQTT_C_DIR)/MQTTClient.c
file(GLOB MQTT_SRC_FILES
    ${MQTT_EMB_DIR}/*.c
    ${MQTT_C_DIR}/MQTTClient.c
)

#TLS - openSSL
#&gt; TLS_LIB_DIR = /usr/lib/
#&gt; TLS_INCLUDE_DIR = -I /usr/include/openssl
set(TLS_INCLUDE_DIR /usr/include/openssl)
find_package(OpenSSL REQUIRED openssl)

# this just for debug purpose
message(""OPENSSL_ROOT_DIR is  ${OPENSSL_ROOT_DIR}"")
message(""OPENSSL_LIBRARIES is  ${OPENSSL_LIBRARIES}"")


#Aggregate all include and src directories
#&gt; MQTT_INCLUDE_DIR += -I $(MQTT_EMB_DIR)
#&gt; MQTT_INCLUDE_DIR += -I $(MQTT_C_DIR)
#&gt; INCLUDE_ALL_DIRS += $(IOT_INCLUDE_DIRS) 
#&gt; INCLUDE_ALL_DIRS += $(MQTT_INCLUDE_DIR) 
#&gt; INCLUDE_ALL_DIRS += $(TLS_INCLUDE_DIR)
#&gt; INCLUDE_ALL_DIRS += $(APP_INCLUDE_DIRS)
include_directories(
    include
    ${TLS_INCLUDE_DIR}
    ${MQTT_EMB_DIR}
    ${MQTT_C_DIR}
) 


#&gt; SRC_FILES += $(MQTT_SRC_FILES)
#&gt; SRC_FILES += $(APP_SRC_FILES)
set(SOURCE_FILES
    ${IOT_SRC_FILES}
    ${MQTT_SRC_FILES}
)


#&gt; MAKE_CMD = $(CC) $(SRC_FILES) $(COMPILER_FLAGS) -o $(APP_NAME) $(LD_FLAG) $(EXTERNAL_LIBS) $(INCLUDE_ALL_DIRS)
add_executable(subscribe_publish_sample src/subscribe_publish_sample.c ${SOURCE_FILES})
target_link_libraries(subscribe_publish_sample ${OPENSSL_LIBRARIES} )
</code></pre>

<p>Take a look at this CMakeLists.txt</p>

<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(sample)

# Define correct path to embedded C sdk
set(AWS_IOT_ROOT_DIR  ../aws_iot)
set(IOT_CLIENT_DIR  ${AWS_IOT_ROOT_DIR}/aws_iot_src)
include_directories(
    ${IOT_CLIENT_DIR}/protocol/mqtt
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl
    ${IOT_CLIENT_DIR}/utils
)

set(MQTT_DIR ${AWS_IOT_ROOT_DIR}/aws_mqtt_embedded_client_lib)
set(MQTT_C_DIR ${MQTT_DIR}/MQTTClient-C/src)
set(MQTT_EMB_DIR ${MQTT_DIR}/MQTTPacket/src)

include_directories(
    ${MQTT_EMB_DIR}
    ${MQTT_C_DIR}
)


set(TLS_INCLUDE_DIR /usr/include/openssl)
include_directories(
    include
    ${TLS_INCLUDE_DIR}
)

set(PLATFORM_DIR ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/openssl)
set(PLATFORM_COMMON_DIR ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/platform_linux/common)
file(GLOB IOT_SRC_FILES
    ${IOT_CLIENT_DIR}/protocol/mqtt/aws_iot_embedded_client_wrapper/aws_iot_mqtt_embedded_client_wrapper.c
    ${PLATFORM_DIR}/*.c
    ${PLATFORM_COMMON_DIR}/*.c
    )

file(GLOB MQTT_SRC_FILES
    ${MQTT_EMB_DIR}/*.c
    ${MQTT_C_DIR}/MQTTClient.c
    )

set(SOURCE_FILES
    ${IOT_SRC_FILES}
    ${MQTT_SRC_FILES})

find_package(OpenSSL REQUIRED openssl)

add_executable(subscribe_publish_sample src/subscribe_publish_sample.c ${SOURCE_FILES})
target_link_libraries(subscribe_publish_sample ${OPENSSL_LIBRARIES} )
</code></pre>
",,45113885,549
37227980,2,37226299,2016-05-14T14:40:59.403,1,,4057102,,2016-05-14T14:40:59.403,,2,,"<p>The objects are being passed by reference, however the library does make copies of them.</p>

<p>You could change:</p>

<pre><code>MuxShield _muxShieldIn;
MuxShield _muxShieldOut;
</code></pre>

<p>To references:</p>

<pre><code>MuxShield &amp;_muxShieldIn;
MuxShield &amp;_muxShieldOut;
</code></pre>

<p>However the constructor will need to be modified so it uses an initializer list.</p>

<p>At the moment, it does a copy here:</p>

<pre><code>ToggleMux::ToggleMux(MuxShield &amp; muxShieldIn, int inRow, int inBit, MuxShield &amp; muxShieldOut, int outRow, int outBit)
{
    _muxShieldIn = muxShieldIn;
    _muxShieldOut = muxShieldOut;
//...
</code></pre>

<p>You'll need to change it look like this:</p>

<pre><code>ToggleMux::ToggleMux(MuxShield &amp; muxShieldIn, int inRow, int inBit, MuxShield &amp; muxShieldOut, int outRow, int outBit) : _muxShieldIn(muxShieldIn), _muxShieldOut(muxShieldOut)
{
//...
</code></pre>

<hr>

<p>Also the arrays in the <code>MuxShield</code> class <code>_shiftReg1</code>, <code>_shiftReg2</code> and <code>_shiftReg3</code> can be chars, as they only store a 1 or 0, this will halve their usage.</p>

<p>Or you could use my BitBool library (download from library manager) to make each one take only two bytes. All you'd need to do (after including it to your sketch and lib) is:</p>

<p>Change the declarations to:</p>

<pre><code>BitBool&lt;16&gt; _shiftReg1, _shiftReg2 _shiftReg3; 
</code></pre>

<p>And the initializations to:</p>

<pre><code>BitBool&lt;16&gt; _shiftReg1 = {0};
BitBool&lt;16&gt; _shiftReg2 = {0};
BitBool&lt;16&gt; _shiftReg3 = {0};
</code></pre>

<p>Then all three variables take 6 bytes instead of 96. My class is designed to be used like an array, so you shouldn't need to change any other code.</p>
",,45143314,95
37227094,2,37227015,2016-05-14T13:12:13.433,1,,2009616,,2016-05-14T13:12:13.433,,2,,"<p><code>WiFi.RSSI</code> takes a network index, not an SSID string:</p>

<pre><code>char ssid[] = ""GreenNET""
uint8_t available_networks = WiFi.scanNetworks();
for (uint8_t net = 0; net &lt; available_networks; ++net)
{
  if (strcmp(WiFi.SSID(net), ssid) == 0)
  {
    rssi = WiFi.RSSI(net);
    Serial.print(rssi);
    Serial.print("" dBm"");
    Serial.println();
    break;
 }
}
</code></pre>
",,45238773,1767
37228487,2,37228351,2016-05-14T15:28:13.507,1,,121747,,2016-05-14T15:33:20.000,2016-05-14T15:33:20.000,3,,"<p>If I understand it correctly you just want to convert a <code>unsigned long</code> value into an hex string, you can use <code>sprintf</code> for this purpose (<a href=""http://ideone.com/FgFTFZ"" rel=""nofollow"">ideone</a>):</p>

<pre><code>const unsigned int BUFFER_LENGTH = 16;
char buffer[BUFFER_LENGTH];
unsigned long value = 0xE0E040BF;
sprintf(buffer, ""0x%08X"", value);
printf(""%s\n"", buffer); // printString(buffer)
</code></pre>

<p>so that you can pass <code>buffer</code> to the <code>printString</code> method of the oled screen.</p>

<p>The format specifier <code>%08X</code> instructs printf to <a href=""http://en.cppreference.com/w/cpp/io/c/fprintf"" rel=""nofollow"">format</a> the value as an hexadecimal number, with capital letters always showing all 8 hex values for the 4 bytes and padding it with 0s.</p>
",,45241524,71
37260342,2,37258537,2016-05-16T18:04:29.050,0,,1330595,,2016-05-16T18:04:29.050,,5,,"<p>There are multiple issues with this:</p>

<p>1) Your first check for ""65 0 1 1 ffff ffff ffff"" is only toggling the button on your Nextion screen, it isn't actually doing anything with the <code>relayaPin</code>.  Once that check has completed, then your code, regardless of the check, will toggle your relay a because it isn't encapsulated in the <code>if</code> statement.  What you want to do is this:</p>

<pre><code>  if (message == ""65 0 1 1 ffff ffff ffff"") {
    myNextion.buttonToggle(button1State, ""b0"", 0, 2);

    val = digitalRead(relayaPin);
    Serial.print(val);

    if (val == HIGH) {
      // turn Relay on:
      digitalWrite(relayaPin, HIGH);
    } else {
      // turn Relay off:
      digitalWrite(relayaPin, LOW);
    }
 }
</code></pre>

<p>This will only toggle the relayA if you've pressed the button.</p>

<p>2) For all the other relay check statements, you aren't checking its current state like you do in the above point.  Just setting it HIGH again won't toggle it, if it is already on, it'll only ever stay on at that point.  There is no exit criteria.  You need to do the check like you do for the first one.</p>

<p>3) For the love of god, use some <code>#define RELAY_A_MESSAGE ""65 0 1 1 ffff ffff ffff""</code> kind of deal to improve readability.  Then you can just use <code>if( message == RELAY_A_MESSAGE )</code> statement instead of this weird ascii garbage.</p>
",,45266556,70
37277932,2,37273326,2016-05-17T13:43:15.973,1,,2819922,,2016-05-17T13:50:40.430,2016-05-17T13:50:40.430,1,,"<blockquote>
  <p>a spam of a ton of lows and highs</p>
</blockquote>

<p>... happens if the GND of the two Arduinos are not connected.</p>

<p>Also, your reading arduino prints at every loop cycle, which were a few microseconds only, if the Serial buffer would not overflow.</p>

<p>Better printout changes only, or use a led to show what's happening.</p>

<pre><code>void loop(){
    static bool oldState;
    bool sensorState = digitalRead(sensorPin);
    if (sensorState != oldState) {
       Serial.println(sensorState);
       oldState = sensorState;
    }
}
</code></pre>
",,45272529,48
37323847,2,37311903,2016-05-19T12:54:58.797,0,,6022656,,2016-05-19T12:54:58.797,,0,,"<p>I suppose that the problem is that you have declared a class <code>IWCRW</code>, in ""i2crw.h"", with some methods (<code>writeByte()</code> and two different <code>readBytes()</code>), but you haven't implemented they.</p>

<p>If you look at the cpp file (""i2crw.cpp"", I suppose), you have implemented the constructor</p>

<pre><code>I2CRW::I2CRW()
</code></pre>

<p>and three function that aren't related with <code>I2CRW</code> class</p>

<pre><code>void writeByte(uint8_t address, uint8_t subAddress, uint8_t data)

uint8_t readByte(uint8_t address, uint8_t subAddress)

void readBytes(uint8_t address, uint8_t subAddress, uint8_t count, uint8_t * dest)
</code></pre>

<p>I suppose your intention was to implement the three <code>IWCRW</code> method but you have forgot the <code>I2CRW::</code> part before the name of the functions.</p>

<p>Solution: correct, in cpp class file, the function implementation in method implementation </p>

<pre><code>void IWCRW::writeByte(uint8_t address, uint8_t subAddress, uint8_t data)

uint8_t IWCRW::readByte(uint8_t address, uint8_t subAddress)

void IWCRW::readBytes(uint8_t address, uint8_t subAddress, uint8_t count, uint8_t * dest)
</code></pre>

<p>p.s.: sorry for my bad English.</p>
",,45301141,156
37327035,2,37326215,2016-05-19T14:57:51.907,1,,4328606,,2016-05-19T15:06:02.970,2016-05-19T15:06:02.970,10,,"<p>It actually looks correct. Both temperature and humidity are encoded in two bytes and if you do all the calculations by hand it looks ok (in this case temperature only):</p>

<pre><code>ST = readbuffer[0]; // 100
ST &lt;&lt;= 100; // 100 &lt;&lt; 8 = 25600
ST |= readbuffer[1]; // 25600 | 1 = 25601

double stemp = ST; // 25601
stemp *= 175; // 25601 * 175 = 4480000
stemp /= 0xffff; // 4480000 / 65535 = 68,36
stemp = -45 + stemp; // -45 + 68,36 = 23,36
</code></pre>

<p>So it have nothing to do with ASCII encoding. Just give your sensor a bit of time.</p>

<p>Also if you look at the <a href=""https://cdn-shop.adafruit.com/product-files/2857/Sensirion_Humidity_SHT3x_Datasheet_digital-767294.pdf"" rel=""nofollow"">sensor datasheet</a> you can see that its response time lies between 2 and 8 seconds.</p>
",,45327750,750
37332650,2,37332466,2016-05-19T19:43:37.283,1,,5245033,,2016-05-19T19:45:59.043,2016-05-19T19:45:59.043,6,,"<p>I would revisit your design. I would do it like following:</p>

<pre><code>class ntp_client {
public:
  template&lt;class UDP_IMPL, ARGS...&gt;
  ntp_client(ARGS&amp;&amp;... args) : udp_(my::make_unique&lt;UDP_IMPL&gt;(std::forward(ARGS)args...))
                               { }

private:
  my::unique_ptr&lt;UDP&gt; udp_ptr;
};
</code></pre>

<p>Implementation of <code>my::unique_ptr</code> and <code>my::make_unique</code> is left as an excercise, since it is trivial.</p>

<p>Explanation - do not keep the references to something you do not really want to own. Instead, construct the proper implementation and keep it.</p>
",,45376629,140
37333268,2,37332466,2016-05-19T20:20:50.870,1,,2015579,,2016-05-19T20:20:50.870,,0,,"<p>If you want to construct the ntp_client with an r-value reference (i.e. a temporary) you need to give the temporary somewhere to live.</p>

<p>The logical place would be inside the ntp_client, or something derived from it.</p>

<p>This starts to argue for a factory function that makes either an ntp_client with an encapsulated wifi or ethernet UDP, or a reference to one. </p>

<blockquote>
  <p>Is it possible to do this without using smart pointers or templates?</p>
</blockquote>

<p>yes, but templates make it easier with less typing...</p>

<pre><code>#include &lt;utility&gt;

struct UDP {};

struct WiFiUDP : UDP {};
struct EthernetUDP : UDP {};


class ntp_client {
public:
  ntp_client(UDP&amp; udp) : udp_(udp) {}

  // ...

private:
  UDP&amp; udp_;
};

class Wifi_ntp_client : public ntp_client
{
  // take care - the base class reference is initialised before the stored
  // object. You must not use it in the base class constructor
  // or destructor!
  Wifi_ntp_client(WiFiUDP&amp;&amp; w)
    : ntp_client(_store)
    , _store(std::move(w))
  {}

  WiFiUDP _store;
};

class Ethernet_ntp_client : public ntp_client
{
  // take care - the base class reference is initialised before the stored
  // object. You must not use it in the base class constructor
  // or destructor!
  Ethernet_ntp_client(EthernetUDP&amp;&amp; e)
    : ntp_client(_store)
    , _store(std::move(e))
  {}

  EthernetUDP _store;
};

int main()
{
  WiFiUDP a;
  ntp_client aa(a);

  EthernetUDP b;
  ntp_client bb(b);

  Wifi_ntp_client c(WiFiUDP());
  Ethernet_ntp_client d(EthernetUDP());

}
</code></pre>
",,45379362,382
37345508,2,37343447,2016-05-20T11:27:34.250,1,,1866300,,2016-05-20T11:27:34.250,,0,,"<p>In my opinion it is better to style to go for the local approach, also on the generally smaller Arduino programs. Once you have a lot globals you can them in a struct and pass the address of the struct to the functions. </p>

<p>Especially useful in the setup function, the memory is not occupied anymore once setup is done. In your version x will still take up 4 bytes during the lifetime of the program. With just 2k memory you can reach the limit fast.</p>

<p>I would do something like this:</p>

<pre><code>typedef struct {
  int a, b;
} entity_t;

void foo(entity_t *e) { foo2(e); foo3(e); /* do stuff */ }

void setup()
{
  entity_t e = { 1, 2};

  foo(&amp;e);

  Serial.println(e.a);
  // automatic memory of e is released
}
</code></pre>
",,45391453,145
37361655,2,37355134,2016-05-21T10:23:53.273,0,,1460665,,2016-05-21T10:23:53.273,,0,,"<p>Place the following makefile in the <em>iotivity/resource/examples</em> directory :</p>

<pre><code>IDIR=-I../include -I./../csdk/stack/include/ -I./../c_common/ -I./../oc_logger/include
CC=g++
CFLAGS=-Wall -std=c++11 $(IDIR) -loc -loctbstack -loc_logger -lpthread
SERV_OBJ = simpleserver.o
CLIENT_OBJ = simpleclient.o

%.o: %.cpp
    $(CC) -c -o $@ $^ $(CFLAGS)

#Build the simpleserver executable
all:simpleserver simpleclient
simpleserver:$(SERV_OBJ)
    $(CC) -o $@ $^ $(CFLAGS)

#Build the simpleclient executable
simpleclient:$(CLIENT_OBJ)
    $(CC) -o $@ $^ $(CFLAGS)
</code></pre>

<p>and then hit <code>make</code> on the terminal. Then execute <code>simpleclient</code> and <code>simpleserver</code> on two different terminals. In case you get the error : </p>

<pre><code>./simpleclient: error while loading shared libraries: liboc.so: cannot open shared object file: No such file or directory
</code></pre>

<p>type the following:</p>

<pre><code>export LD_LIBRARY_PATH=../../out/linux/x86_64/release
</code></pre>
",,45396221,2751
40556478,2,37355134,2016-11-11T21:28:10.620,-2,,149841,,2017-08-28T15:17:35.350,2017-08-28T15:17:35.350,0,,"<p>Check this page about IoTivity supported (and unsupported) examples :</p>

<p><a href=""https://wiki.iotivity.org/examples#"" rel=""nofollow noreferrer"">https://wiki.iotivity.org/examples#</a></p>

<pre><code>cd ${project_dir}/out/${TARGET_OS}/${TARGET_ARCH}/${BUILD_MODE}/resource/examples/
killall simpleserver simpleclient # make sure none are running

./simpleserver 2&gt;&amp;1 | tee simpleserver.log.txt &amp;
./simpleclient 2&gt;&amp;1 | tee simpleclient.log.txt 
</code></pre>

<p>Some c++ examples are not working in 1.3.0 while 1.2.1 should be ok</p>

<p>But if you want to build other examples from outside the main tree, I made a dedicated project that use gnu make.</p>

<p>Hope this helps</p>
",,45409990,325
37368026,2,37367878,2016-05-21T21:07:15.310,3,,1621391,,2016-05-21T21:39:39.083,2016-05-21T21:39:39.083,0,,"<p>You can use <a href=""https://github.com/maniacbug/StandardCplusplus/blob/master/README.md"" rel=""nofollow"">Standard C++ For Arduino</a>. It <a href=""https://github.com/maniacbug/StandardCplusplus/blob/master/vector"" rel=""nofollow"">implements</a> a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a></p>

<p>With that, you can use a vector of vectors</p>

<pre><code>struct Number
{
  int x;
  int y;
};

using MultiNum = std::vector&lt;std::vector&lt;Number&gt;&gt;;
</code></pre>

<p>However, it is of a worthy note that, Arduino's memory is really small, and you should really have upper bounds to your memory usage. A <code>vector</code> of a <code>vector</code> without smartly using <code>reserve</code> may waste some memory...</p>

<p>Another option is:</p>

<pre><code>Number x[][4] =
    {
    { {0,0}, {0,1} },
    { {0,0}, {0,1}, {1,0}, {0,0} },
    { {0,0}, },
    { {0,0}, {4,0} }
    };
</code></pre>

<p>Of cause, that dictates the <em>fixed</em> memory <em>consumed</em> at compile time. (A 4x4 Matrix of <code>Number</code>).</p>
",,45530229,75
37381389,2,37381320,2016-05-23T01:24:12.477,1,,3943312,,2016-05-23T01:24:12.477,,1,,"<p><code>MyClass</code> does not implement the pure virtual method declared in the <code>MyContract</code> superclass. Just because it also inherits from <code>TraitClass</code> doesn't mean that <code>TraitClass</code>'s <code>foo()</code> is going to implement it.</p>

<p>You need to connect the dots:</p>

<pre><code>class MyClass : public virtual MyContract, public TraitClass {


    void foo() override
    {
         TraitClass::foo();
    }
};
</code></pre>
",,45537419,187
37383159,2,37383063,2016-05-23T05:25:49.277,0,,3804420,,2016-05-23T08:39:40.513,2016-05-23T08:39:40.513,9,,"<p>Your requirement seems to be a question of task multithreading. It is not possible in bare arduinos. The arduino is single threaded.</p>

<p><code>analogRead()</code> does not set the pin to be readable, but it returns the value in that pin.</p>

<p>Use analog <code>A0</code> instead of digital pin <code>0</code></p>

<pre><code>const int sensorPin = A0;      // Pin that SENSOR uses
boolean isOn = false; 
int sensorValue = 0, pinValue = 0; 

void loop() 
{
  buttonState = digitalRead(buttonPin);
  if(buttonState != lastbuttonState &amp;&amp; buttonState == HIGH) {
     pushCounter++;
     lastbuttonState = buttonState;
  }
  if (pushCounter % 2 == 0){
    Serial.println(""Power ON"");
    isOn = true;
  } else {
    Serial.println(""OFF"");
    isOn = false;
  }
  if(isOn) {
    pinValue = analogRead(sensorPin);
    Serial.println(pinValue);
    if(pinValue &gt; 500) { Serial.println(""Alarm triggered""); }
    delay(1000);
  }
}
</code></pre>
",,45538674,227
37409559,2,37409395,2016-05-24T09:31:20.207,1,,26095,,2016-05-24T10:10:48.317,2016-05-24T10:10:48.317,4,,"<p>Use pointers to the values:</p>

<pre><code>uint8_t *msg_1;
uint8_t *msg_2;
uint8_t *msg_3;
uint8_t *msg_4;

uint8_t first_1[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t first_2[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t first_3[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t first_4[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};  

uint8_t second_1[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t second_2[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t second_3[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF};
uint8_t second_4[] = {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}; 


void loop (void){

  if(input1 == HIGH &amp;&amp; input2 == LOW){
    msg_1 = first_1; 
    msg_2 = first_2; 
    msg_3 = first_3; 
    msg_4 = first_4; 
  }
  else if (input1 == LOW &amp;&amp; input2 == HIGH) {
    msg_1 = second_1;
    msg_2 = second_2;
    msg_3 = second_3;
    msg_4 = second_4;
  }

  serial.write(msg_1,8)
  serial.write(msg_2,8)
  serial.write(msg_3,8)
  serial.write(msg_4,8)
}
</code></pre>
",,45556886,259
37410779,2,37409395,2016-05-24T10:22:47.170,1,,3436922,,2016-05-24T15:47:23.683,2016-05-24T15:47:23.683,0,,"<p>You can define a struct for the message and then define a matrix of that struct.</p>

<p>Example:</p>

<pre><code>#define MESSAGE_SIZE 8

struct message
{
    uint8_t body[MESSAGE_SIZE];
};

struct message msg[4][2] = {
                            { {{0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}}, {{0x89, 0x81, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}} },
                            { {{0x89, 0x82, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}}, {{0x89, 0x83, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}} },
                            { {{0x89, 0x84, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}}, {{0x89, 0x85, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}} },
                            { {{0x89, 0x86, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}}, {{0x89, 0x87, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}} }
                           };

void loop (void)
{
    int index = 0;

    if(input1 == HIGH &amp;&amp; input2 == LOW)
    {
        index = 0;
    }
    else if (input1 == LOW &amp;&amp; input2 == HIGH)
    {
        index = 1;
    }

    int i = 0;
    for (i=0; i&lt; 4; i++)
    {
       serial.write(msg[i][index].body,MESSAGE_SIZE);
    }
}
</code></pre>

<p>The best is to add requested signal status for each message:</p>

<pre><code>#define MESSAGE_SIZE 8

struct message
{
    uint8_t input1;
    uint8_t input2;
    uint8_t body[MESSAGE_SIZE];
};

struct message msg[] = {
                            { HIGH, LOW , {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { LOW , HIGH, {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { HIGH, LOW , {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { LOW , HIGH, {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { HIGH, LOW , {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { LOW , HIGH, {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { HIGH, LOW , {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}},
                            { LOW , HIGH, {0x89, 0x80, 0xF8, 0x73, 0x00, 0x00, 0xCF, 0xFF}}
                       };

#define MESSAGE_COUNT sizeof(msg)/sizeof(msg[0])

void loop (void)
{
    int i = 0;
    for (i=0; i&lt;MESSAGE_COUNT; i++)
    {
        if ((input1 == msg[i].input1) &amp;&amp;
            (input1 == msg[i].input1))
        {
            serial.write(msg[i].body,MESSAGE_SIZE);
        }
    }
}
</code></pre>
",,45578320,397
37424512,2,37423262,2016-05-24T21:50:15.483,1,,6022656,,2016-05-24T23:56:53.087,2016-05-24T23:56:53.087,10,,"<p>If you need only a <code>sensor</code> for all instances of <code>motorIR</code>, I suppose that it could be a static member of the class.</p>

<p>Or a static variable in a static method; like this</p>

<pre><code>class motorIR
{
public:     // Funciones públicas

    motorIR(int PWM, int MI, int MD);

    void beginner();

    void control(int i);


private:    // Variables privadas
    int _PWM= STANDBY;
    int _MI;
    int _MD;
    int pin_IR;
    unsigned long IRcode;

    static NECIRrcv &amp; getSensor()    //  &lt;---  getSensor() added
     { static NECIRrsv sensor(4); return sensor; }
};
</code></pre>

<p>You can use it in this way</p>

<pre><code>void motorIR::control(int i)
{
    // NECIRrcv sensor(4) ; no more here
    getSensor().begin();

    Serial.println(""Checkpoint"");     
    while (getSensor().available())
     {
        Serial.print(""Detection"");
        IRcode= getSensor().read();
        Serial.print(IRcode, DEC);
        Serial.print(IRcode, HEX);
        Serial.print(IRcode, BIN);
     }
}
</code></pre>

<p>p.s.: caution: not tested</p>

<p>p.s.2: sorry for my bad English</p>

<p><strong>--- EDIT ---</strong></p>

<p>The error is ""'NECIRrcv' does not name a type"" or ""'NECIRrcs' does not name a type""?</p>

<p>In my example I've written, by mistake ""NECIRrcs"" instead of ""NECIRrcv""; sorry.</p>

<p>About your need to <code>begin()</code> only one time the sensor, you can modify the <code>getSensor()</code> method in this way</p>

<pre><code>static NECIRrcv &amp; getSensor()
 {
   static NECIRrsv sensor(4);
   static bool firstRun(true);

   if ( firstRun )
    {
      sensor.begin();
      firstRun = false;
    }

   return sensor;
 }
</code></pre>

<p>Caution: not tested.</p>
",,45584601,166
37425426,2,37423262,2016-05-24T23:17:49.677,0,,5459321,,2016-05-24T23:17:49.677,2017-05-23T11:51:26.903,0,,"<p>I loved the idea of declaring the object <code>NECIRrcv::sensor</code> as part of class <code>motorIR</code> though, but trying to define <code>NECIRrcv sensor(4)</code> anywhere in motorIR.h leads <em>to error: 'NECIRrcv' does not name a type</em>; so it would be interesting to solve this problem in order to be able to implement @max66 's idea (or eve just to figure out why motorIR.h doesn't recognize <code>NECIRrcv</code> properly).</p>

<p>In spite of that, I think I've run into an alternative solution: using an extern object (as it's described <a href=""https://stackoverflow.com/questions/8910047/issue-declaring-extern-class-object"">here</a>).</p>

<p>It can be implemented as it follows:</p>

<p>In NECIRrcv header:</p>

<pre><code>#ifndef NECIRrcv_h
#define NECIRrcv_h

#include &lt;Arduino.h&gt;

// (...)

class NECIRrcv
{
  public:
    NECIRrcv(int irpin);

// (...)

  private:
} ;

extern NECIRrcv sensor; // &lt;-------- declaring object as extern

#endif
</code></pre>

<p>In motorIR source file:</p>

<pre><code>#include ""Arduino.h""
#include ""motorIR.h""
#include &lt;string.h&gt;

NECIRrcv sensor(4); // &lt;--------- defining object

motorIR::motorIR(int PWM, int MI, int MD)
{
    _MI=    MI      +A0;
    _PWM=   PWM     +A0;
    _MD=    MD      +A0;
}

void motorIR::beginner()
{
    Serial.begin(9600);
    Serial.print(""Begin"");
    sensor.begin(); //  &lt;-------- now I can initialize sensor here
}


void motorIR::control(int i)
{
    // NECIRrcv sensor(4) ;
    // sensor.begin();

    Serial.println(""Checkpoint"");     
     while (sensor.available()) // &lt;-- method 1
     {
        Serial.print(""Detection"");
        IRcode= sensor.read(); // &lt;-- method 2
        Serial.print(IRcode, DEC);
        Serial.print(IRcode, HEX);
        Serial.print(IRcode, BIN);
     }
}
</code></pre>
",,45591955,253
37424432,2,37424070,2016-05-24T21:44:46.967,1,,4950659,,2016-05-24T21:44:46.967,,1,,"<p>If you want to change a variable you passed to a function, you must use <a href=""http://www.tutorialspoint.com/cprogramming/c_pointers.htm"" rel=""nofollow"">pointers</a>.</p>

<p>Basically it's used like this:</p>

<pre><code>void f(int* x){
  *x = 5;
}

int main() {
  int y = 7;
  f(&amp;y);
  printf(""%i\n"", y);
  return 0;
}
</code></pre>

<p>In short, <code>&amp;</code> get the address of the variable and <code>*</code> get the value at the address</p>
",,45600202,4798
37427127,2,37427046,2016-05-25T03:08:34.680,4,,1816718,,2016-05-25T03:08:34.680,,1,,"<p>Your if statement has mismatched parentheses.</p>

<p>Your code:</p>

<pre><code>if(
    value[j-1]-value[j]&gt;=2 and 
    value[j-1]-value[j]&lt;=30) and // &lt;- Paren here closes the if(
    value[j-2]-value[j-1]&gt;=2 and 
    value[j-2]-value[j-1]&lt;=30 and 
    value[j+1]-value[j]&gt;50 and 
    value[j+2]&gt;value[j+1]){ 
    lights = true; 
}
else{
    lights=false;
}
</code></pre>

<p>Notepad is nice but take advantage of an IDE!</p>
",,45623729,407
37518157,2,37517042,2016-05-30T05:28:00.027,1,,3555525,,2016-05-30T05:28:00.027,,2,,"<p>You need to introduce a delay between the two digits. This can be done by having
a simple software delay in between the two digits. </p>

<pre><code>     if(stateButton == 0 &amp;&amp; stateButton2 == 1) 
     {
        stateLED = HIGH;
        digitalWrite(LED, HIGH); 

        // Write digit 1
        delay(50);
        // Write digit 2
        delay(50);
     }
</code></pre>

<p>The above approach has the property that once you press the button, it will cycle from 1-9 or from 9-1, without stopping.</p>
",,45641206,484
37570279,2,37569079,2016-06-01T13:33:38.177,0,,2548319,,2016-06-01T16:47:28.270,2016-06-01T16:47:28.270,7,,"<p>If <code>j</code> keeps its old value, it is likely that the attempt to read it is failing.  Try checking the stream state, and checking for possible error conditions.  For example:</p>

<pre><code>if(arduino &gt;&gt; j)
    cout &lt;&lt; ""Value received: "" &lt;&lt; j &lt;&lt; '\n';
else if(arduino.eof())
    cerr &lt;&lt; ""Premature EOF.\n"";
else if(arduino.bad())
    cerr &lt;&lt; ""Attempt to read from device failed.\n"";
else
    cerr &lt;&lt; ""Logical I/O error.\n"";
</code></pre>
",,45645087,747
37580771,2,37580655,2016-06-02T00:17:10.160,3,,28128,,2016-06-02T00:17:10.160,,1,,"<p>It's time to make a state machine.  Every time <code>rx_data</code> is called, you would update the state of your state machine, and eventually at some point you will know that you have received the string ""+IPD,"".</p>

<p>The simplest thing that could work would be something like this, assuming that the byte received from the UART is passed as an argument to <code>rx_data</code>:</p>

<pre><code>void rx_data(uint8_t byte)
{
    static uint8_t state = 0;
    if (byte == '+') { state = 1; }
    else if (state == 1 &amp;&amp; byte == 'I') { state = 2; }
    else if (state == 2 &amp;&amp; byte == 'P') { state = 3; }
    else if (state == 3 &amp;&amp; byte == 'D') { state = 4; }
    else if (state == 4 &amp;&amp; byte == ',') {
      state = 0;
      handleIPDMessage();  // we received ""+IPD,""
    }
    else { state = 0; }
}
</code></pre>

<p>You can see that <code>handleIPDMessage()</code> is called if and only if the last characters received were ""+IPD,"".</p>

<p>However, you should consider writing a more general state machine that would operate on lines instead of just looking for this one string.  That would probably be easier to write and more robust.  When a complete line is received, you would call a function named <code>handleLineReceived()</code> to handle that line.  That function would have access to a buffer with the entire line, and it could parse it in whatever way it wants to.  (Just be careful that you never write beyond the end of that buffer.)</p>

<p>By the way, I wouldn't be putting logic like that in an ISR.  It's generally best to keep ISRs simple and fast.  If you are not doing so already, store the byte to a circular buffer in the ISR and then read from the circular buffer in your main loop, and every time you read a byte from the circular buffer then call a function like the <code>rx_data</code> function described above to process the byte.</p>
",,45662049,3586
37585008,2,37581925,2016-06-02T07:12:32.833,0,,1466201,,2016-06-02T07:12:32.833,,1,,"<p>Just shift 0 or 1 to its position in binary format :) </p>

<pre><code>char lineChars[8] = {1,1,0,0,0,1,0,1}; 
    char lineChar = 0;
    for(int i=0; i&lt;8;i++)
    {
        lineChar |= lineChars[i] &lt;&lt; (7-i);
    }
</code></pre>

<p>Example 2. But is not tested!</p>

<pre><code>void abs()
{
  char* charData = new char;
  *charData = 'h';
  BYTE* byteData = new BYTE;
  *byteData = *(BYTE*)charData; 
}
</code></pre>
",,45703261,91
37585356,2,37581925,2016-06-02T07:30:06.390,0,,3985859,,2016-06-02T07:30:06.390,,0,,"<p>Assuming you want to parse the hex values in your string, and two letters always make up one byte value (so you use leading zeros), you can use <code>sscanf</code> like this:</p>

<pre><code>char input[] = ""fff2bdf1""; 
unsigned char output[4];
for (int i=0; i&lt;4; i++) {
  sscanf(&amp;input[i*2], ""%02xd"", &amp;data[i]);
}
</code></pre>
",,45726974,1416
37586121,2,37581925,2016-06-02T08:08:44.693,4,,4057102,,2016-06-05T02:17:41.390,2016-06-05T02:17:41.390,3,,"<p>Here is a little Arduino sketch illustrating one way to do this:</p>

<pre><code>void setup() {
  Serial.begin(9600);

  char arr[] = ""abcdef98"";
  byte out[4];
  auto getNum = [](char c){ return c &gt; '9' ? c - 'a' + 10 : c - '0'; };
  byte *ptr = out;

  for(char *idx = arr ; *idx ; ++idx, ++ptr ){
    *ptr = (getNum( *idx++ ) &lt;&lt; 4) + getNum( *idx );
  }


  //Check converted byte values.
  for( byte b : out )
    Serial.println( b, HEX );  
}

void loop() {
}
</code></pre>

<p>The loop will keep converting until it hits a null character. Also the code used in <code>getNum</code>only deals with lower case values. If you need to parse uppercase values its an easy change. If you need to parse both then its only a little more code, I'll leave that for you if needed (let me know if you cannot work it out and need it).</p>

<p>This will output to the serial monitor the 4 byte values contained in <code>out</code> after conversion.</p>

<blockquote>
  <p>AB<br>
  CD<br>
  EF<br>
  98 </p>
</blockquote>

<p><strong>Edit: How to use different length inputs.</strong></p>

<p>The loop does not care how much data there is, as long as there are an even number of inputs (two ascii chars for each byte of output) plus a single terminating null. It simply stops converting when it hits the input strings terminating null.</p>

<p>So to do a longer conversion in the sketch above, you only need to change the length of the output (to accommodate the longer number). I.e:</p>

<pre><code>char arr[] = ""abcdef9876543210"";
byte out[8];
</code></pre>

<p>The <code>4</code> inside the loop doesn't change. It is shifting the first number into position.</p>

<p>For the first two inputs (<code>""ab""</code>) the code first converts the 'a' to the number <code>10</code>, or hexidecimal <code>A</code>. It then shifts it left 4 bits, so it resides in the upper four bits of the byte: <code>0A</code> to <code>A0</code>. Then the second value <code>B</code> is simply added to the number giving <code>AB</code>.</p>
",,45744631,2016
37593562,2,37584133,2016-06-02T13:39:17.103,0,,4100891,,2016-06-02T14:29:36.020,2016-06-02T14:29:36.020,0,,"<p>If you want all the data fields, try using my GPS library, <a href=""https://github.com/SlashDevin/NeoGPS"" rel=""nofollow"">NeoGPS</a>.  It really simplifies the parsing of all the data fields.  Here's your sketch, modified to use NeoGPS:</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NeoSWSerial.h&gt;
#include ""NMEAGPS.h""

NeoSWSerial gps_port( 4, 5 );
NMEAGPS gps;
File    Cordinates;

bool smsflag = false;
bool snd     = false;

//--------------------------

void setup()
{
  Serial.begin(9600);
  while (!Serial)
    ;
  gps_port.begin(9600);

  while (!SD.begin(9)) {
    Serial.println( F(""SD Card Initialization failed!"") );
    return;
  }
  Serial.println( F(""SD Card Initialized"") );

  Serial.print( F(""AT\r\n"") );                // Initialization command
  delay(1000); 
  Serial.print( F(""ATE0\r\n"") );              // Turn echo off 
  delay(1000);
  Serial.print( F(""AT+CMGF=1\r\n"") );         // Text mode
  delay(1000); 
  Serial.print( F(""AT+CNMI=2,1,0,0,0\r\n"") ); // Set message format
  delay(1000);
}

//--------------------------

void loop()
{
  while (gps.available( gps_port )) {
    gps_fix fix = gps.read();

    if (fix.valid.location &amp;&amp; !snd) {

      if (!smsflag) {
        Serial.print( F(""AT+CMGS=\""+91xxxxxxxxxx\""\r\n"") );
      } else {
        Serial.print( F(""Latitude:"") );  
        Serial.print( fix.latitude(), 6 ); // floating-point format
        Serial.print( F(""\r\n"") );
        Serial.print( F(""Longitude:"") );
        Serial.print( fix.longitude(), 6 ); // floating-point format
        Serial.print( '\x1A' );   /* Send Ctrl+Z after the message */
        snd     = true;

        Cordinates = SD.open(""GPS.txt"", FILE_WRITE); // (O_APPEND | O_WRITE | O_CREAT) ?

        if (Cordinates) {
          Serial.print( F(""Writing to GPS.txt..."") );
          Cordinates.print( F(""Latitude:"") );
          Cordinates.print( fix.latitude(), 6 ); // floating-point format
          Cordinates.print( F""Longitude:"") );
          Cordinates.print( fix.longitude(), 6 ); // floating-point format
          Cordinates.close();
          Serial.println( F(""done."") );
        } else {
          Serial.println( F(""Error opening GPS.txt"") );
        }

        smsflag = false;
      }
    }
  }

  while (Serial.available()) {
    char c = Serial.read();
    if (c == '&gt;') { /* Set flag for response to ""AT+CMGS=\""+91xxxxxxxxxx\""""    */
      smsflag = true;
    } 
  }
}
</code></pre>

<p>The NeoGPS <a href=""https://github.com/SlashDevin/NeoGPS/blob/master/doc/Data%20Model.md"" rel=""nofollow"">Data Model</a> page shows how to get the other fields.</p>

<p>Other notes:</p>

<ul>
<li>The lat/lon is displayed in floating-point degrees, not the funky DDMM.MMMM of the original NMEA sentences (two digits of degrees, and 6 or more digits of floating-point minutes :P ).</li>
<li>If <code>snd</code> and <code>smsflag</code> can only have the values 0 and 1, use the <code>bool</code> type instead.  They can only have values <code>true</code> and <code>false</code>.</li>
<li>Are you sure you only want to send 1 report?  <code>snd</code> never gets cleared.</li>
<li>Are you sure you want to send the AT+CMGS command every second?  Maybe it should be sent once before the coords are sent?</li>
<li>Using <code>delay</code> in <code>loop()</code> is generally bad, so the AT+CMGS is sent after the coords.  The next GPS data won't be available for about 1 second, providing a similar delay.</li>
<li>The <a href=""https://github.com/SlashDevin/NeoSWSerial"" rel=""nofollow"">NeoSWSerial</a> library is <em>much</em> more reliable than the built-in SoftwareSerial library.  AltSoftSerial is even better, if you could use pins 8 &amp; 9.</li>
<li>What Arduino and GPS device are you using?  There may be other NeoGPS or serial settings to consider.  For example, the <strong>F</strong> macro is used on 8-bit AVRs to save lots of RAM.</li>
</ul>
",,45746518,1972
37638711,2,37625357,2016-06-05T05:16:40.640,0,,3833261,,2016-06-05T05:16:40.640,,0,,"<p>After some research, it turns out that a certain assortment of characters are sent across the serial stream when it is first opened by the program, which was happening on every read for me because the program only read from the echoing arduino once per program execution.  I fixed the ?'s at the beginning, which were of a negative value by just selectively taking out the negative values waiting in the UART buffer. Since ascii values range from 0 to 127, so they are technically signed, and that, I believe, is why I was even able to get negative character values.  I cleaned the UART buffer by adding a while loop that looked for negative character values, and if the value of the incoming char was negative, the program removed the char from the buffer.  Here is the updated code on the arduino side, which is where the problems were:</p>

<pre><code>#include &lt;StackArray.h&gt;

boolean isSerial = false;
int num = 0;
StackArray&lt;char&gt; serialOut;
void setup() {
  pinMode(13, OUTPUT);
  Serial.begin(115200);
}

void cleanSerial(){
  char junk = Serial.peek();
  while(int(junk) &lt; 0 || int(junk) &gt; 127){
    Serial.read();
    junk = Serial.peek();
  }
}

void loop() {
  isSerial = false;
  while(Serial.available() &gt; 0){
    cleanSerial();
    char byteRead = 0;
    isSerial = true;
    while(byteRead != 126){
      if(Serial.available() &gt; 0){      
        byteRead = Serial.read();
        serialOut.push(byteRead);   
     }
    }
  } 
  if(isSerial){
     writeFromStack();
  }
  num++;
}
void blink(int times, int duration){
  for(int i = 0; i &lt; times; i++){
    digitalWrite(13, HIGH);
    delay(duration);
    digitalWrite(13, LOW);
    delay(duration);
  }
}
void writeFromStack(){
  int arrayLen = serialOut.count();
  char tempBuf[arrayLen];
  for(int i = 0; i &lt; arrayLen; i++){
    tempBuf[arrayLen - 1 - i] = serialOut.pop();
  }
  for(int i = 0; i &lt; arrayLen; i++){
    Serial.print(tempBuf[i]);
  }
  Serial.print('\n');
}
</code></pre>

<p>Thank you all. Keep calm and code on.</p>
",,45747495,40
37673354,2,37670643,2016-06-07T07:42:35.130,2,,4057102,,2016-06-07T07:42:35.130,,0,,"<p>As your function is taking a pointer you'll need to get the address of <code>root</code> before you pass it. This is done using the <code>&amp;</code> (addressof) operator.</p>

<pre><code>JsonObject&amp; root = jsonBuffer.parseObject(json);

test( &amp;root );  //Get address of root, then pass that pointer to function.

void test(JsonObject* root) {  //Pass pointer by value
   int flag = (*root)[""success""]; 
}
</code></pre>

<p>However, you should use a reference, then your code will be a bit simpler, and also look a lot cleaner (no addressof and no dereferenced pointers).</p>

<pre><code>JsonObject&amp; root = jsonBuffer.parseObject(json);

test( root );

void test(JsonObject &amp;root) {  // Pass by reference.
   int flag = root[""success""];
}
</code></pre>
",,45783033,808
37684769,2,37670899,2016-06-07T16:36:48.487,0,,168986,,2016-06-07T16:42:50.317,2016-06-07T16:42:50.317,2,,"<p>You should read the documentation of <a href=""https://www.arduino.cc/en/Reference/AttachInterrupt"" rel=""nofollow"">AttachInterrupt()</a> - in the section ""About Interrupt Service Routines"" it gives information on how certain functions behave when called from an interrupt.  For <code>micros()</code> it states:</p>

<blockquote>
  <p>micros() works initially, but will start behaving erratically after 1-2 ms. </p>
</blockquote>

<p>I believe that means after the ISR has been running for more than 1ms, rather than just 1 ms in general, so may not apply in this case, but you might need to consider how you are doing the timing in the ISR.  That's a problem with Arduino - terrible documentation!</p>

<p>One definite problem which may be a cause is the fact that <code>unSteeringInShared</code> is non-atomic.  It is a 16 bit value on 8 bit hardware so requires multiple instructions to read and write and the process can be interrupted.  It is therefore possible to read one byte of the value in the <code>loop()</code> context and then have both bytes changed by the interrupt context before you read the second byte, so you then up with two halves of two different values.</p>

<p>To resolve this problem you could either disable interrupts while reading:</p>

<pre><code>noInterrupts() ;
unSteeringIn = unSteeringInShared ;
interrupts() ;
</code></pre>

<p>Or you can spin-lock the read:</p>

<pre><code>do
{
    unSteeringIn = unSteeringInShared ;

} while( unSteeringIn != unSteeringInShared ) ;
</code></pre>

<p>You should do the same for <code>unThrottleInShared</code> too, although why you do not see any problem with that is unclear - this is perhaps not the problem you are currently observing, but is definitely a problem in any case.</p>

<p>Alternatively if 8 bit resolution is sufficient you could encode the input as an atomic 8 bit value thus:</p>

<pre><code>uint8_t unSteeringInShared ;


...


int32_t timeus = micros() - ulSteeringStart - 1000 ;
if( timeus &lt; 0 )
{
    unSteeringInShared = 0 ;
}
else if( timeus &gt; 1000 )
{
    unSteeringInShared = 255;
}
else
{
    unSteeringInShared = (uint8_t)(time * 255 / 1000) ;
}
</code></pre>

<p>Of course changing your scale from 1000 to 2000 to 0 to 255 will need changes to the rest of the code.  For example to convert a value <code>x</code> in the range 0 to 255 to a a servo pulse width:</p>

<pre><code> pulsew = (x * 1000 / 256) + 1000 ;
</code></pre>
",,45795619,2636
37678615,2,37674722,2016-06-07T11:50:55.810,2,,898348,,2016-06-07T11:50:55.810,,1,,"<p>Your code is almost correct.</p>

<p>The problem is here:</p>

<pre><code>disp = strstr(msg,""\r\n\r\n"");
disp = disp+4;  // now disp points to the string ""11"" (correct)

// what follows is wrong
a = disp[1];    // this is the second char element if the disp string
b = disp[2];    // this is the zero terminator of the disp string
</code></pre>

<p>You need this because in C arrays indexes start with 0:</p>

<pre><code>a = disp[0];
b = disp[1];
</code></pre>

<p>Small test program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char *disp;
  char msg[] = ""Fake Header\r\n\r\n12"";
  char a;
  char b;

  disp = strstr(msg,""\r\n\r\n"");
  disp = disp+4;
  a = disp[0];
  b = disp[1]; 

  printf(""a = %c\nb = %c\n"", a, b);
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>a = 1
b = 2
</code></pre>
",,45867379,23171
39832846,2,37694440,2016-10-03T13:28:38.677,1,,6695476,,2016-10-03T13:28:38.677,,0,,"<p>if you need only one-two easy(out of param) nodes, you can use my function :)</p>

<pre><code>String xmlTakeParam(String inStr,String needParam)
{
  if(inStr.indexOf(""&lt;""+needParam+""&gt;"")&gt;0){
     int CountChar=needParam.length();
     int indexStart=inStr.indexOf(""&lt;""+needParam+""&gt;"");
     int indexStop= inStr.indexOf(""&lt;/""+needParam+""&gt;"");  
     return inStr.substring(indexStart+CountChar+2, indexStop);
  }
  return ""not found"";
}
</code></pre>

<p>I tried to find a solution for a long time, leave it here for clarity.
The complex xml with repeating nodes already so will not succeed.</p>
",,45872139,878
37698294,2,37698164,2016-06-08T09:19:42.507,3,,440558,,2016-06-08T09:19:42.507,,0,,"<p>Red two characters at a time, convert them to a number corresponding to the hexadecimal value. Do in a loop. Skip the <code>'-'</code> character when you encounter it. Set the ""current"" element in the array to the value. Set ""current"" to the next element in the array.</p>

<p>Something like this <em>pseudo</em> code</p>

<pre><code>while (not at end of string)
{
    char1 = get next character from string;
    char2 = get next character from string;
    value = make int from hex characters(char1, char2);
    array[current++] = value;
}
</code></pre>
",,45903613,51
37698546,2,37698164,2016-06-08T09:29:36.653,1,,748115,,2016-06-09T02:33:10.453,2016-06-09T02:33:10.453,2,,"<p>This should work for your problem</p>

<pre><code>char *uuid = ""3bdb098f-b8b0-4d1b-baa2-0d93eb7169c4"";
static uint8_t adv_data[32];  //your uuid has 32 byte of data

// This algo will work for any size of uuid regardless where the hypen is placed
// However, you have to make sure that the destination have enough space.

int strCounter=0;      // need two counters: one for uuid string (size=38) and
int hexCounter=0;      // another one for destination adv_data (size=32)
while (i&lt;strlen(uuid))
{
     if (uuid[strCounter] == '-') 
     {
         strCounter++;     //go to the next element
         continue;
     }

     // convert the character to string
     char str[2] = ""\0"";
     str[0] = uuid[strCounter];

     // convert string to int base 16
     adv_data[hexCounter]= (uint8_t)atoi(str,16);

     strCounter++;
     hexCounter++;
}
</code></pre>
",,45906205,75
37717642,2,37698164,2016-06-09T05:37:16.170,1,,3422102,,2016-06-09T05:47:43.393,2016-06-09T05:47:43.393,0,,"<p>An alternative to using a library function to convert to numeric form, you can simply subtract <code>'0'</code> for characters <code>0 - 9</code> and <code>'a' - 10</code> (or simply <code>'W'</code>) for characters <code>a - f</code> to preform the conversion. For example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

#define MAXC 32

int main (int argc, char **argv) {

    char *uuid = argc &gt; 1 ? argv[1] : ""3bdb098f-b8b0-4d1b-baa2-0d93eb7169c4"";
    uint8_t data[MAXC] = {0};

    size_t i, ui = 0, di = 0, ulen = strlen (uuid);

    for (;di &lt; MAXC &amp;&amp; ui &lt; ulen; ui++, di++) {
        if (uuid[ui] == '-') ui++;    /* advance past any '-'  */
                                      /* convert to lower-case */
        if ('A' &lt;= uuid[ui] &amp;&amp; uuid[ui] &lt;= 'Z') uuid[ui] |= (1 &lt;&lt; 5);
        data[di] = ('0' &lt;= uuid[ui] &amp;&amp; uuid[ui] &lt;= '9') ? uuid[ui] - '0' :
                    uuid[ui] - 'W';   /* convert to uint8_t */
    }

    if (di == MAXC &amp;&amp; ui != ulen) {  /* validate all chars fit in data */
        fprintf (stderr, ""error: uuid string exceeds storage.\n"");
        return 1;
    }

    printf (""\n original: %s\n unsigned: "", uuid);
    for (i = 0; i &lt; di; i++)
        putchar (data[i] + (data[i] &lt; 10 ? '0' : 'W'));
    putchar ('\n');

    return 0;
}
</code></pre>

<p><strong>Example Output</strong></p>

<pre><code>$ ./bin/uuid_to_uint8_t

 original: 3bdb098f-b8b0-4d1b-baa2-0d93eb7169c4
 unsigned: 3bdb098fb8b04d1bbaa20d93eb7169c4
</code></pre>

<p>(<strong>note:</strong> you can add a further check that <code>uuid[ui]</code> is a valid <em>hexadecimal</em> character or <code>'-'</code> before attempting the conversion for additional validation).</p>
",,45956343,195
37701746,2,37700321,2016-06-08T11:52:40.527,0,,6022656,,2016-06-08T12:04:07.040,2016-06-08T12:04:07.040,0,,"<p>I don't know the library you're using but...</p>

<p>The error you get is ""was not declared in this scope"", so the compiler don't know the symbol <code>emxCreateWrapper_real_T</code> in the point you use it.</p>

<p>You should include the header of the file where <code>emxCreateWrapper_real_T()</code> is defined; or call it with the right namespace... I don't know exactly.</p>

<p>I've found <a href=""http://www.gomatlab.de/matlab-coder-implementierung-in-cundund-t34416.html"" rel=""nofollow"">an example</a> of use where the included files are</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include ""arcl3d.h""
#include ""arcl3d_initialize.h""
#include ""arcl3d_terminate.h""
#include ""arcl3d_emxAPI.h""
#include ""arcl3d_emxutil.h"" 
</code></pre>

<p>so I suppose that <code>emxCreateWrapper_real_T()</code> is defined in ""arcl3d_emxAPI.h"" or in ""arcl3d_emxutil.h"".</p>

<p>My suggestion is: try including both of they.</p>

<p>If this doesn't work, try showing us the full code; including included files.</p>

<p>p.s: sorry for my bad English.</p>
",,45974514,5869
37705269,2,37700321,2016-06-08T14:24:46.690,0,,6439790,,2016-06-08T16:26:50.877,2016-06-08T16:26:50.877,0,,"<p>thanks, I found a file named ""_coder_NeuralNetwork_api.c"" and a header file. In the header file the struct emxArray_real_T is declared but in the .c file is no emxCreateWrapper_real_T function but I found: </p>

<pre><code>static void emxInit_real_T(const emlrtStack *sp, emxArray_real_T **pEmxArray,
  int32_T numDimensions, boolean_T doPush)
{
  emxArray_real_T *emxArray;
  int32_T i;
  *pEmxArray = (emxArray_real_T *)emlrtMallocMex(sizeof(emxArray_real_T));
  if (doPush) {
    emlrtPushHeapReferenceStackR2012b(sp, (void *)pEmxArray, (void (*)(void *))
      emxFree_real_T);
  }

  emxArray = *pEmxArray;
  emxArray-&gt;data = (real_T *)NULL;
  emxArray-&gt;numDimensions = numDimensions;
  emxArray-&gt;size = (int32_T *)emlrtMallocMex((uint32_T)(sizeof(int32_T)
    * numDimensions));
  emxArray-&gt;allocatedSize = 0;
  emxArray-&gt;canFreeData = true;
  for (i = 0; i &lt; numDimensions; i++) {
    emxArray-&gt;size[i] = 0;
  }
} 
</code></pre>

<p>can I also use that function,if yes, what are the input arguements??</p>

<p>But there is the next problem.... whithin that included header file another .h named ""_coder_NeuralNetwork_mex.h"" is included and that one needs a ""mex.h"" but the matlab coder didn't create such a file. </p>

<p>The content of _coder_NeuralNetwork_mex.h is:</p>

<pre><code>#ifndef _CODER_NEURALNETWORK_MEX_H
#define _CODER_NEURALNETWORK_MEX_H

/* Include Files */
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include ""tmwtypes.h""
#include ""mex.h""
#include ""emlrt.h""
#include ""_coder_NeuralNetwork_api.h""

/* Function Declarations */
extern void mexFunction(int32_T nlhs, mxArray *plhs[], int32_T nrhs, const
  mxArray *prhs[]);
extern emlrtCTX mexFunctionCreateRootTLS(void);

#endif
</code></pre>

<p>I don't know if I have to use this files, beacuse they are created in the separte folder from the matlab coder.</p>
",,46006325,1524
37710900,2,37700321,2016-06-08T19:07:44.703,0,,6439790,,2016-06-08T19:07:44.703,,0,,"<p>I found something the coder generated what might help:</p>

<pre><code>//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: main.cpp
//
// MATLAB Coder version            : 3.1
// C/C++ source code generated on  : 07-Jun-2016 19:17:39
//

//***********************************************************************
// This automatically generated example C main file shows how to call
// entry-point functions that MATLAB Coder generated. You must customize
// this file for your application. Do not modify this file directly.
// Instead, make a copy of this file, modify it, and integrate it into
// your development environment.
//
// This file initializes entry-point function arguments to a default
// size and value before calling the entry-point functions. It does
// not store or use any values returned from the entry-point functions.
// If necessary, it does pre-allocate memory for returned values.
// You can use this file as a starting point for a main function that
// you can deploy in your application.
//
// After you copy the file, and before you deploy it, you must make the
// following changes:
// * For variable-size function arguments, change the example sizes to
// the sizes that your application requires.
// * Change the example values of function arguments to the values that
// your application requires.
// * If the entry-point functions return values, store these values or
// otherwise use them as required by your application.
//
//***********************************************************************
// Include Files
#include ""rt_nonfinite.h""
#include ""NeuralNetwork.h""
#include ""main.h""
#include ""NeuralNetwork_terminate.h""
#include ""NeuralNetwork_emxAPI.h""
#include ""NeuralNetwork_initialize.h""

// Function Declarations
static emxArray_real_T *argInit_d7351x5_real_T();
static double argInit_real_T();
static void main_NeuralNetwork();

// Function Definitions

//
// Arguments    : void
// Return Type  : emxArray_real_T *
//
static emxArray_real_T *argInit_d7351x5_real_T()
{
  emxArray_real_T *result;
  static int iv0[2] = { 2, 5 };

  int idx0;
  int idx1;

  // Set the size of the array.
  // Change this size to the value that the application requires.
  result = emxCreateND_real_T(2, *(int (*)[2])&amp;iv0[0]);

  // Loop over the array to initialize each element.
  for (idx0 = 0; idx0 &lt; result-&gt;size[0UL]; idx0++) {
    for (idx1 = 0; idx1 &lt; 5; idx1++) {
      // Set the value of the array element.
      // Change this value to the value that the application requires.
      result-&gt;data[idx0 + result-&gt;size[0] * idx1] = argInit_real_T();
    }
  }

  return result;
}

//
// Arguments    : void
// Return Type  : double
//
static double argInit_real_T()
{
  return 0.0;
}

//
// Arguments    : void
// Return Type  : void
//
static void main_NeuralNetwork()
{
  emxArray_real_T *Data;
  double activity_data[7351];
  int activity_size[2];
  double percent;

  // Initialize function 'NeuralNetwork' input arguments.
  // Initialize function input argument 'Data'.
  Data = argInit_d7351x5_real_T();

  // Call the entry-point 'NeuralNetwork'.
  NeuralNetwork(Data, activity_data, activity_size, &amp;percent);
  emxDestroyArray_real_T(Data);
}

//
// Arguments    : int argc
//                const char * const argv[]
// Return Type  : int
//
int main(int, const char * const [])
{
  // Initialize the application.
  // You do not need to do this more than one time.
  NeuralNetwork_initialize();

  // Invoke the entry-point functions.
  // You can call entry-point functions multiple times.
  main_NeuralNetwork();

  // Terminate the application.
  // You do not need to do this more than one time.
  NeuralNetwork_terminate();
  return 0;
}

//
// File trailer for main.cpp
//
// [EOF]
//
</code></pre>

<p>But I am not sure how to use the function ""static emxArray_real_T *argInit_d7351x5_real_T()"" it says change the size to the value that the application requires but what do I have to change? For example I want to use a 10x5 Array, do I have to change the first value in iv0[] to 10??? 
To get the input values (in my first post the variable input[][]) can I replace the function call of ""argInit_real_T()"" to input[idx0][idx1] if I create that variable within that function or as global?</p>
",,46006883,905
37710794,2,37709237,2016-06-08T19:01:13.720,0,,6024122,,2016-06-08T19:18:15.430,2017-04-13T12:40:36.833,0,,"<p><strong>Notes</strong>: others have already pointed out the reasons why your code does not compile in the comments to your question.</p>

<p>More in detail, you <strong>declare</strong> neither <em>total</em> nor <em>readIndex</em> to be <strong>arrays</strong>, there is a <strong>typo</strong> (<em>readIntex</em> instead of <em>readIndex</em> at line <em>44</em>) and two <strong>missing semi-columns</strong> (lines <em>41</em> and <em>42</em>). </p>

<p><strong>However</strong>, after carefully reading your code I think that even by applying those <em>syntactic</em> fixes you will not obtain a piece of code that does what you want. </p>

<p>Thus, I will provide here with my <em>interpretation</em> of your <em>desired</em> source code based on the description of your problem and your attempt.</p>

<p>I could verify that it compiles, however <em>-since I lack the hardware-</em> I could not test it.</p>

<blockquote>
  <p>(<strong>disclaimer:</strong> I am rather <em>rusty</em> with <em>Arduino</em>'s <em>style guide</em> so
  I apologise in advance for adopting a <em>personal</em> code styling.)</p>
</blockquote>

<hr>

<pre><code>#include&lt;Arduino.h&gt;

#define NUM_SENSORS  4
#define NUM_READINGS 5
#define LOWER_LIMIT 24
#define UPPER_LIMIT 31
#define PRINT_PERIOD 1000
#define TEMPERATURE_FACTOR 9.31

/* global variables */

const byte tempPin[] = {A1, A2, A3, A4};
const byte relayPin[] = {6, 7, 8, 9};

word readings[NUM_SENSORS][NUM_READINGS] = {};
word totals[NUM_SENSORS] = {};
float averages[NUM_SENSORS] = {};

unsigned long time_elapsed = 0;
word num_readings = 0;
word j = 0;

/* setup */

void setup()
{
  analogReference(INTERNAL);

  Serial.begin(115200);

  for (int i = 0; i &lt; 4; i++)
  {
    pinMode(relayPin[i], INPUT_PULLUP);
    pinMode(relayPin[i], OUTPUT); // defaults HIGH, relay OFF
  }
}

/* main loop */

void loop()
{
  // keep track of actual readings:
  // (prevents under-estimation of initial values
  // due to a too large smoothing window)
  if (num_readings &lt; NUM_READINGS)
  {
    num_readings++;
  }

  for (int i = 0; i &lt; NUM_SENSORS; i++)
  {
    // subtract the last reading:
    totals[i] = totals[i] - readings[i][j];
    // read from the sensor:
    readings[i][j] = analogRead(tempPin[i]);
    // add the reading to the total:
    totals[i] = totals[i] + readings[i][j];

    // update average
    averages[i] = ((float) totals[i] / TEMPERATURE_FACTOR) / (float) num_readings;

    // uncomment to optionally delay action on relays
    // up until when the smooth window has been filled up
    // if (num_readings == NUM_READINGS) {
      if (averages[i] &lt; LOWER_LIMIT)
      {
        digitalWrite(relayPin[i], LOW);   // relay OFF
      } else if (averages[i] &gt; UPPER_LIMIT) {
        digitalWrite(relayPin[i], HIGH);  // relay ON
      }
    // }
  }

  // advance the reading index:
  j = (j + 1) % NUM_READINGS;

  unsigned long curr_time = millis();
  static unsigned long start_time = curr_time; // initialized only once

  if ((curr_time - start_time) &gt;= PRINT_PERIOD)
  {
    for (int i = 0; i &lt; 4; i++)
    {
      Serial.print(""tempC"");
      Serial.print(i + 1);
      Serial.print("" "");
      Serial.println(averages[i]);
    }
    Serial.println();
    start_time = curr_time; // not really best solution, but
                            // i don't want to bloat the code
  }

  delay(1); // waste some time
}
</code></pre>

<p><strong>Note</strong>: I kept <em>totals</em> and <em>readings</em> of type <em>word</em> so as to avoid the typical hindrances of <em>floating point</em> operations. </p>

<hr>

<p><strong>Additional Notes</strong>: </p>

<ol>
<li><p>having a smooth window of <em>50</em> readings sounds very suspicious to me, in my experience the last 3-5 readings should suffice, perhaps with a larger <em>delay</em> in-between.</p></li>
<li><p>since you're still learning, I suggest you to share your <em>working</em> (small) projects on <a href=""https://codereview.stackexchange.com/"">https://codereview.stackexchange.com/</a> from time to time, so as to get some <em>very nice</em> feedback. (:</p></li>
</ol>
",,46028764,3308
37776056,2,37751051,2016-06-12T15:36:17.173,0,,472495,,2016-06-21T21:08:58.577,2016-06-21T21:08:58.577,0,,"<p><em>(Posted answer on behalf of the OP):</em></p>

<p>I figured it out; the problem were the settings of the serial port. For future reference, here is the working version.</p>

<pre><code>bufferTemp=new char [1000];
    bufferDEF = new char[1000];
    const char* _portNameSensorsBT=""/dev/rfcomm0"";

    struct termios options;
    SerialHandleSensorsFoot=open(_portNameSensorsBT, O_RDWR ); //SerialHandleSensors=open(_portNameSensors, O_RDWR | O_NOCTTY | O_NDELAY); non blocking
    if (SerialHandleSensorsFoot == -1 )
    {
        cout&lt;&lt;endl&lt;&lt;""......ERROR: Unable to open: ""&lt;&lt;_portNameSensorsBT&lt;&lt;endl;
        return 0;
    }
    else
    {
        fcntl(SerialHandleSensorsFoot, F_SETFL,0);
        cout&lt;&lt;""......OPENED PORT: Succesfully opened: ""&lt;&lt;_portNameSensorsBT&lt;&lt;endl;
    }

    //GET THE OPTIONS, MODIFY AND SET
    tcgetattr(SerialHandleSensorsFoot,&amp;options);
    cfsetispeed(&amp;options,B115200); //BAUD RATE IN
    cfsetospeed(&amp;options,B115200); //BAUD RATE OUT
    // options.c_lflag |= (ICANON | ECHO | ECHOE);

    options.c_iflag = IGNBRK | IGNPAR;
    options.c_oflag = 0; 
    options.c_lflag = 0; 

    options.c_cflag |= (CLOCAL | CREAD);
    options.c_cflag &amp;= ~PARENB;
    options.c_cflag |= CSTOPB;
    options.c_cflag &amp;= ~CSIZE;
    options.c_cflag |= CS8;
    tcsetattr(SerialHandleSensorsFoot,TCSAFLUSH,&amp;options);

    usleep(5000000);
</code></pre>

<p>with these setting I'm able to communicate with bluetooth even though there might be some velocity problem.</p>
",,46128464,834
37758779,2,37758512,2016-06-11T00:21:49.857,0,,717523,,2016-06-11T22:47:14.890,2016-06-11T22:47:14.890,8,,"<blockquote>
  <p>how could I solve this problem</p>
</blockquote>

<p>In C,C++,JavaScript,Java: </p>

<p>Number 10^5 has to be represented in program as 1e5</p>

<p>and number 10^-6 as 1e-6</p>

<p>The use of '^' forces program to perform bit wise operation 10^5 = (10)^(5)</p>

<p>See: <a href=""https://msdn.microsoft.com/en-us/library/3akey979.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/3akey979.aspx</a>  </p>

<p><strong>Solution</strong></p>

<p>Change </p>

<pre><code>double t = (0.8*0.8*(10^5)*599*(10^-6)*1388.888889)/(287*(25+273)*14.7*3*(10^-3)*4);
</code></pre>

<p>To:</p>

<pre><code>double t = (0.8*0.8*(1e5)*599*(1e-6)*1388.888889)/(287*(25+273)*14.7*3*(1e-3)*4);
</code></pre>

<p>Now you get the correct result:</p>

<pre><code>t = 3.5292104651726235
</code></pre>

<p>The int on arduino has very limited range: 32767 to -32768.
The long is 2147483647 to -2147483648</p>

<p>Avoid mixing int and double to avoid rounding error. </p>

<p>Use only double or you can use cast:</p>

<pre><code> double d = (double)(0.8*0.8*(1e5)*(double)599*(1e-6)*1388.888889)/(((double)287)*((double)(‌​25+273))*((14.7*((double)3)))*(1e-3)*(double)4);
</code></pre>

<p>Note on the Arduino</p>

<pre><code>Serial.print(1.23456); //gives ""1.23""
</code></pre>

<p>To get more numbers convert double variable to the string and print the string.</p>

<p>The example: </p>

<pre><code>double num = (double)(0.8*0.8*(1e5)*(double)599*(1e-6)*1388.888889)/(((double)287)*((double)(25+273))*((14.7*((double)3)))*(1e-3)*(double)4);
char output[50];

snprintf(output, 50, ""%f"", num);

Serial.print(output); // should give you at least 3.529210
</code></pre>
",,46231706,56
47744163,2,37769451,2017-12-10T22:29:56.360,1,,565244,,2017-12-10T22:29:56.360,,1,,"<p>After a long time I discover how the Arduino compiler compiles the code. It is not a C/C++ issue, actually <strong>it is an error in the Arduino compiler</strong>, the combine and compile order. Also the compiler add some specific code before compiling. </p>

<hr>

<p><strong>Workaround:</strong></p>

<p>Include your libraries/independencies with use of an exra project h-file. Defines before includes will not work because the compile method includes h-files before the defines (in your ino file) will be applied. When using defines, to change a library for example, requires a separated h-file. For example ""myproject.inc.h"" which includes all libraries you want to use. </p>

<p>Now all defines you specify before including a library will be applied.</p>

<p><strong>Example:</strong></p>

<hr>

<p><strong>myproject.ino</strong></p>

<hr>

<pre><code>#include ""myproject.inc.h""

void setup()
{
  TrinketHidCombo.begin(); 
}

void loop() // Main program - main()
{
  // do nothing, check if USB needs anything done
  TrinketHidCombo.poll();  
}
</code></pre>

<hr>

<p><strong>myproject.inc.h</strong></p>

<hr>

<pre><code>#define USB_CFG_VENDOR_NAME     'm', 'y', 'C', 'o', 'm', 'p', 'a', 'n', 'y', 'n'
#define USB_CFG_VENDOR_NAME_LEN 10

#include ""TrinketHidCombo.h""
</code></pre>
",,46270236,343
37780213,2,37780177,2016-06-12T23:47:05.737,2,,1621391,,2016-06-12T23:47:05.737,,1,,"<p>The first lambda was called because you called it, the second wasn't called... Add the call <code>()</code> to the very end of the lambda.</p>

<pre><code>void loop() 
{
  [&amp;timerVal](unsigned long currentTime){if(currentTime - timerVal &gt; 1000UL) {Serial.println(""Hello World""); timerVal += 1000UL;}}
   (millis());  //&lt;--call

  [&amp;timerVal](){if(millis() - timerVal &gt; 1000UL) {Serial.println(""Why Not Me?""); timerVal += 1000UL;}}
     (); /// now, we call... :-)
}
</code></pre>
",,46277313,361
37860126,2,37829430,2016-06-16T13:04:31.147,3,,5895811,,2016-06-16T14:58:23.247,2016-06-16T14:58:23.247,0,,"<p>check the function: <code>HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</code>;</p>

<ol>
<li>make a size enough longer like 16bytes for example;</li>
<li><p>call your  <code>HAL_UART_RxCpltCallback</code> routine into the function <code>HAL_UART_Receive_IT(...)</code>. I suggest to you to add an end character (<code>\n</code>) detection like this: </p>

<pre><code>if ( (*huart-&gt;pRxBuffPtr) == '\n') {
    HAL_UART_RxCpltCallback(huart);  //-------------------------------------------/////////
} else {
    huart-&gt;pRxBuffPtr++;
}
</code></pre></li>
</ol>
",,46279057,1123
37986410,2,37975604,2016-06-23T08:41:51.423,1,,1016246,,2016-06-23T08:41:51.423,,0,,"<p>In general, when doing communication on any given line, file or media, you risk breaking up the data. Ethernet actually has a package size (MTU) that can/will be delivered unbroken. But that's another story. It'll be better if you deal with the issue, no matter protocol, hardware or platform. (Or at least be aware of it.)</p>

<p>When you read your ModbusTCP, you should make something like the following pseudo:</p>

<pre><code>//read all ModbusTCP header
while less than 6 bytes received and not timed out and not error
   read bytes

//read data
data_length = modbustcp_header position 5 and 6
while less than data_length and not timed out and not error
   read bytes
</code></pre>

<p>The above function will collect the whole package, before ""releasing"" it to your engine. The algorithm will work for both sides of your setup. (Both the Texas hw and the PC.)</p>

<p>You could also (most likely) fiddle with the TI TCP stack and make it return bigger blocks. And I guess this was what you were asking for. But again, I wouldn't recommend going down that road. </p>
",,46315757,323
47323207,2,37979863,2017-11-16T06:41:18.063,0,,8878680,,2017-11-16T06:41:18.063,,0,,"<p>You did not add any sensor pin in <strong><em>setup()</em></strong> function. Edit you function just like it. </p>

<pre><code>void setup() {

  pinMode(redSensorpin,INPUT);
  pinMode(greenSensorpin,INPUT);
  pinMode(blueSensorpin,INPUT);

  pinMode(greenLEDpin,OUTPUT);
  pinMode(redLEDpin,OUTPUT);
  pinMode(blueLEDpin,OUTPUT);
  Serial.begin(9600);

}
</code></pre>
",,46426172,247
38021279,2,38021241,2016-06-24T20:04:02.007,6,,955273,,2016-06-24T20:04:02.007,,0,,"<p>You have 2 problems.</p>

<p>The first is you don't have the correct <strong>syntax for a function pointer</strong>.</p>

<p>The syntax for a function pointer is</p>

<pre><code>return_type(*name)(arguments)
</code></pre>

<p>Since your function has <code>void</code> return type and doesn't take any arguments, it's</p>

<pre><code>void(*f)()
</code></pre>

<p>The second is in trying to <strong>pass the function pointer <code>f</code> to the base class constructor</strong></p>

<p>Here you're passing the <em>type</em> to the base class, when in fact you just want to pass the variable</p>

<p>Incorrect (both in terms of the syntax and passing the type of the argument)</p>

<pre><code>Stepper(x,y,z,void(*f)) 
</code></pre>

<p>Correct (just pass <code>f</code>, the function pointer variable itself</p>

<pre><code>Stepper(x,y,z,f)
</code></pre>

<p><strong>Here is the code with the fixes:</strong></p>

<pre><code>class Stepper
{
public:
  Stepper(int en,int dir, int clk, void(*f)())
  {

  }
};
class Turret : public Stepper
{
public:
  Turret(int x,int y, int z,void (*f)()):Stepper(x,y,z,f)
  {
  }
};
void TurretStep()
{

}
Turret t(2,3,4,TurretStep);
</code></pre>
",,46428396,863
38021340,2,38021241,2016-06-24T20:09:19.463,1,,4685116,,2016-06-24T20:09:19.463,,1,,"<p>I use to do this way:</p>

<pre><code>typedef void (TURRETSTEP)();

class Stepper
{
public:
    Stepper(int en,int dir, int clk, TURRETSTEP* f)
    {

    }
};


class Turret : public Stepper
{
public:
    Turret(int x,int y, int z, TURRETSTEP* f): Stepper(0, 0, 0, f)
    {
    }
};

void TurretStep()
{

}
</code></pre>

<p>I declare a typedef defining a ""function template"", is easy to do:</p>

<p>if your function is (for example):</p>

<pre><code>char* ReadString(int a, short b, int etc);
</code></pre>

<p>simply surround function name with parenthesis, and make it uppercase like this:</p>

<pre><code>char* (READSTRING)(int a, short b, int etc);
</code></pre>

<p>and add typedef declaration:</p>

<pre><code>typedef char* (READSTRING)(int a, short b, int etc);
</code></pre>
",,46428903,200
38602231,2,38063578,2016-07-27T01:17:02.180,2,,3290848,,2016-07-27T01:17:02.180,,0,,"<p>I suppose you are using libgps and libgpsmm. Your problem may be caused by a version incompatibility between gpsd daemon and libgps.
I.e. the client (libgps) may speak a different version of the ""API protocol"" <a href=""http://catb.org/gpsd/gpsd_json.html"" rel=""nofollow"">gpsd_json</a> than the gpsd daemon.
This may happen if you decided to build/link a static version of libgps -- which does not <em>exactly</em> match the version number of gpsd. Or if your client runs on a diffent machine than gpsd server.</p>

<p>I ran into same problem and it took me valuable time to figure out the reason:<br>
JSON parser in libgps is designed badly. It ignores/discards JSON objects which contain name/value pairs, which are not known a priori.<br>
So whole TPV messages from gpsd may be discarded and your client implementation shows no error message, neither libgps functions return an error code. Too bad.</p>

<p>Here it is (<a href=""http://git.savannah.gnu.org/cgit/gpsd.git/tree/json.c"" rel=""nofollow"">json.c</a>, line 296+, @2016-07-27):</p>

<blockquote>
<pre><code>  if (cursor-&gt;attribute == NULL) {
      json_debug_trace((1,
                ""Unknown attribute name '%s' (attributes begin with '%s').\n"",
                attrbuf, attrs-&gt;attribute));
      /* don't update end here, leave at attribute start */
      return JSON_ERR_BADATTR;
  }
</code></pre>
</blockquote>

<p>And here (<a href=""http://git.savannah.gnu.org/cgit/gpsd.git/tree/libgps_json.c"" rel=""nofollow"">libgps_json.c</a>, line 27+, @2016-07-27):</p>

<blockquote>
<pre><code>static int json_tpv_read(const char *buf, struct gps_data_t *gpsdata, const char **endptr)
{
    const struct json_attr_t json_attrs_1[] = {
      {""class"",  t_check,   .dflt.check = ""TPV""},
      {""device"", t_string,  .addr.string = gpsdata-&gt;dev.path, .len = sizeof(gpsdata-&gt;dev.path)},
      {""time"",   t_time,    .addr.real = &amp;gpsdata-&gt;fix.time, .dflt.real = NAN},
      ...
</code></pre>
</blockquote>

<p>Use <code>_gpsmm-&gt;enable_debug( level, stderr )</code> with <code>level&gt;=6</code> and compile libgps, libgpsmm with <code>define CLIENTDEBUG_ENABLE</code> to get the debug trace output.</p>

<p>git repositiory of gpsd sources tells us dates of recent incompatible changes on the gpsd_json protocol:<br></p>

<blockquote>
  <p>git commits:<br>
  2016-04-07  Add ""status"" to TPV for DGPS notification<br>
  2016-01-04  Address Savannah bug #46804: JSON satellite view parsing is somewhat broken.<br>
  2015-04-04  Add client-library parsing of PPS precision.<br>
  2015-01-24  In client library, ""dip"" member was missing from ATT parsing.<br><br>
  Releases:<br>
  3.11  23-Aug-2014<br>
  3.12  22-Feb-2015  <em>incompatible</em><br> 
  3.13  26-Feb-2015<br>
  3.14  14-Mar-2015<br>
  3.15  03-Jun-2015  <em>incompatible</em><br>
  3.16  08-Jan-2016  <em>incompatible</em><br>
  3.17  xx-xxx-xxxx  <em>incompatible</em><br></p>
</blockquote>

<p>Do gpsd developers not care about client-server compatibility across versions? What about shared libgps library binary API/ABI stability then?
It is missing versioning functions. Very unsafe also.<br>
(Look at the comment git comment on the 2015-04-04 change mentioned above: <em>Data is currently discarded, pending the next gps_data_t structure break.</em>)</p>
",,46429388,1165
38081660,2,38081575,2016-06-28T16:32:44.730,1,,5024654,,2016-06-28T16:32:44.730,,0,,"<pre><code>class Button
{
public:
  Button(int pin, int debounce)
  {

  }
};

class TransferTable
{
public:
  TransferTable() : a(1, 1)
  {

  }
private:
  Button a;
};
</code></pre>
",,46466441,1212
38107835,2,38097160,2016-06-29T18:49:25.107,0,,5621671,,2016-06-29T18:49:25.107,,0,,"<p>You can send separately using <a href=""https://www.arduino.cc/en/Serial/Print"" rel=""nofollow"">print()</a> like:</p>

<pre><code>int n_decimals = 3;
float PHValue = Value/10;
float DOValue= 12.22;

gprsSerial.print(""AT+HTTPPARA=\""URL\"",\""http://itempurl.com/smartpond/AddTemprature?WaterTemperature="");
gprsSerial.print(celsius, n_decimals);
gprsSerial.print(""&amp;PHValue="");
gprsSerial.print(PHValue, n_decimals);
gprsSerial.print(""&amp;DOValue="");
gprsSerial.print(DOValue, n_decimals);
gprsSerial.println(""&amp;currentTime=06-30-2016\"""");
</code></pre>

<p>With <code>n_decimals</code> the number of decimal places that you want to be printed.</p>

<p>Or as @stark says in the comments you can use <code>snprintf</code> to generate your AT command:</p>

<pre><code>char command[256];
float PHValue = Value/10;
float DOValue= 12.22;

snprintf(command, sizeof(command), ""AT+HTTPPARA=\""URL\"",\""""
          ""http://itempurl.com/smartpond/AddTemprature?""
          ""WaterTemperature=%f&amp;PHValue=%f&amp;DOValue=%f""
          ""&amp;currentTime=06-30-2016\"""", celsius, PHValue, DOValue);
gprsSerial.println(command);
</code></pre>

<p>Note: I wasn't sure if you want the values in the url to go between quotes, so I left them without.</p>
",,46467934,717
39323690,2,38111272,2016-09-05T03:52:29.927,0,,5692347,,2016-09-05T05:12:17.257,2016-09-05T05:12:17.257,0,,"<p>So as I read the description.
Download the file as described in the <a href=""https://sourceforge.net/projects/raspicam/files/?"" rel=""nofollow"">link</a>. Choose the file which is the newest Version.
Then do as follow:</p>

<pre><code>cd &lt;Directory where you downloaded the file&gt;  //probably cd  ~/Downloads
tar xvzf raspicamxx.tgz //extract file replace xx with version number
cd raspicamxx //seitch to newly created directory
mkdir build // make new directory calle build
cd build // switch into build 
cmake .. // compile it
make
sudo make install
sudo ldconfig
</code></pre>

<p>If you get errors post them here.</p>
",,46472894,556
39972303,2,38116924,2016-10-11T07:28:43.430,0,,3118401,,2016-10-11T07:28:43.430,,0,,"<p>As you state that you use linux: man 2 open:</p>

<pre>
       O_LARGEFILE
              (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented
              in  an  off64_t)  to  be opened.  The _LARGEFILE64_SOURCE macro must be defined (before
              including any header files) in order to obtain this definition.  Setting the _FILE_OFF-
              SET_BITS  feature  test  macro  to  64 (rather than using O_LARGEFILE) is the preferred
              method of accessing large files on 32-bit systems (see feature_test_macros(7)).
</pre>

<p>Otherwise, file operations are limited to 2GiB.</p>
",,46514258,739
38145750,2,38145266,2016-07-01T12:42:00.620,3,,6478256,,2016-07-01T15:53:05.957,2016-07-01T15:53:05.957,4,,"<p>Look at <code>millis</code> function. Be careful of 2 issues:</p>

<ol>
<li>it returns 32-bit values, they overflow every 2^32 milliseconds;</li>
<li>ensure you write integer constants correct (e.g. <code>0xAABBCC</code> is compiled to a 16-bit <code>0xBBCC</code> signed int, there must be <code>0xAABBCCul</code>).</li>
</ol>

<p>The first one follows that you need to operate with time difference, not absolute values. Like this:</p>

<pre><code>unsigned long passedTime = millis() - prevWatchTime;
if (passedTime &gt; 1UL * 24UL * 60UL * 60UL * 1000UL) // 1 day
    ...
prevWatchTime = millis();
</code></pre>

<hr>

<p>It should be combined with flags:</p>

<pre><code>const unsigned long sleepTime = 1UL * 24UL * 60UL * 60UL * 1000UL;  // 1 day
bool messageIsSent = false;
unsigned long sendTime;

void loop()
{
    unsigned long passedTime = millis() - sendTime;
    if (passedTime &gt; sleepTime)
        messageIsSent = false;

    if (&lt;must send message&gt; &amp;&amp; !messageIsSent) {
        &lt;send message&gt;
        messageIsSent = true;
        sendTime = millis();
    }
}
</code></pre>

<p>This can correctly prevent messages send up to almost 25 days. As you can check, overflow doesn't affect to difference less than 2^31. E.g. if <code>x = 2^32 - 1</code>, <code>y = x + 101 ~ 100</code>, then <code>y - x = 101</code> even after overflow.</p>

<p>Note that the flag is necessary and cannot be exchanged to direct <code>millis() - sendTime</code> check.</p>
",,46624337,1033
38145897,2,38145266,2016-07-01T12:49:59.830,3,,5078576,,2016-07-04T09:20:32.353,2016-07-04T09:20:32.353,0,,"<p>Following you can find your code.
What I did is to measure the temperature. The first time that the temperature is too high it gives an allarm. You can have a second allarm only after {Period_ms_1day}. So you can set this variable as you prefer to achieve your purposes:</p>

<pre><code>unsigned long Period_ms_1day = 86400000; //time in milliseconds = (60s * 60m *24h*1000) = 1 day
unsigned long prec_event = millis()-Period_ms_1day; 
unsigned long counter;


void  loop() 
{
    temp = request.temp();
    if (temp &gt; 30) 
    { // Do this once every 24 hours or every some long time if it is true
    counter = millis();
        if(counter - prec_event &gt; Period_ms_1day)
        {
           send_sms(6985XXXXXX, ""Temp is over 30C"");
           call(6985XXXXXX);
           prec_event=millis();

        }
    }
}
</code></pre>
",,46626201,1456
48491986,2,38147929,2018-01-28T22:22:55.107,0,,6783666,,2018-01-28T22:22:55.107,,0,,"<p>A more convenient method of sending data to InfluxDB from an ESP8266 or ESP32 is the use of the HTTPclient library instead of the WiFiClient. The following code sets the header and the payload and then sends it to InfluxDB via its <a href=""https://docs.influxdata.com/influxdb/v1.4/guides/writing_data/"" rel=""nofollow noreferrer"">REST API</a>.</p>

<pre><code>#include &lt;ESP8266HTTPClient.h&gt;

const char* influxUrl = ""http://localhost:8086/write?db=mydb"";
const char* influxUser = ""username"";
const char* influxPassword = ""password"";

// Add your own sensors here, e.g., read from OneWire or ADC
id[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
value[10] = {22, 25, 24, 21, 22, 26, 22, 25, 24, 21};

// Send to InfluxDB
Serial.println(""Sending data to InfluxDB"");

String influxData = """";
for(int i = 0; i &lt; 10; i++){
  // Set data type and add tags
  influxData += ""air_temperature,house=hydroponic,id="" + id[i];
  // Add temperature value and delimiter for next measurement
  influxData += "" value="" + String(value[i]) + ""\n"";
}

// Create POST message
http.begin(influxUrl);
http.addHeader(""Content-Type"", ""application/x-www-form-urlencoded"");
http.setAuthorization(influxUser, influxPassword);

// The first attempt to send returns -1
int httpCode = -1;
while(httpCode == -1){
  httpCode = http.POST(influxData);
  http.writeToStream(&amp;Serial);
}
http.end();
</code></pre>

<p>As a bonus, it makes sense to combine it with ESP's <a href=""https://www.losant.com/blog/making-the-esp8266-low-powered-with-deep-sleep"" rel=""nofollow noreferrer"">deep sleep</a> functionality to reduce the power usage from 80mA to less than 10mA (according to my measurements which are limited to 0.01A).</p>

<p><em>Note: the code above has been extracted from a larger project, so may have a bug or two from the transcription.</em> </p>
",,46630884,396
38161157,2,38161060,2016-07-02T14:22:27.690,6,,6462432,,2016-07-02T14:27:18.510,2016-07-02T14:27:18.510,1,,"<p>You can't break like that, so no way. Just balance out what each method does:</p>

<pre><code>while (i &lt; 256)
{
      if (Serial.available() &gt; 0)
      {
             setThoseStrings();
             break;
      }
      i++;
}
</code></pre>

<p>Alternatively</p>

<pre><code>while (i &lt; 256)
{
        if (checkSerialAndSetStrings())
        {
               break;
        }
        i++;
}
</code></pre>

<p>This looks shorter but if you ever need to set strings in other situations (e.g. setting them when a timer runs out), you'll just waste time removing the serial check from <code>checkSerialAndSetStrings</code> and updating your code. I'd go with #1.</p>
",,46631256,72
38162099,2,38161060,2016-07-02T16:17:24.757,1,,3203765,,2016-07-02T16:22:37.280,2016-07-02T16:22:37.280,1,,"<p>You can do similar tricks with <code>return</code>, though it might look little less obvious for some old-school programmers.
Assuming <code>Serial.avaiable()</code> returns unsigned integer, you <em>don't</em> want to check it <em>before</em> your calculations, and you <em>do</em> actually need the updated <code>i,j</code> counters as the post-effects when you update your strings, I would do it this way:</p>

<pre><code>// Obviously this function somehow has
// access to the strings being modified
// And possibly to some other state affected by calculations #1 and #2
// I'm leaving it similar to how you've written it
// for the sake of clarity
bool checkAndBreak()
{
    if (!Serial.available())
        return false;

    setStringOne   = ""string one"";
    setStringTwo   = ""string two"";
    setStringThree = ""string three"";
    setStringFour  = ""string four"";

    return true;
}

size_t i = 0, j = 0;

do {
    // calculations #1
} while (++i, !checkAndBreak() &amp;&amp; i &lt; 256);

do {
    // calculations #2
} while (++j, !checkAndBreak() &amp;&amp; j &lt; 256);
</code></pre>

<p>Note that in the end <code>i,j</code> yield the same values as in your example.
Another funny way is:</p>

<pre><code>// define `i,j` outside of the loops if you need their final values
// !i and !j checks are to make sure checkAndBreak() 
// won't execute before the loop body
for (size_t i = 0; (!i || !checkAndBreak()) &amp;&amp; i &lt; 256; ++i)
    // calculations #1
for (size_t j = 0; (!j || !checkAndBreak()) &amp;&amp; j &lt; 256; ++j)
    // calculations #2
</code></pre>

<p>You can also extract your calculations into functions:</p>

<pre><code>void calc1(size_t i) { ... }
void calc2(size_t j) { ... }

for (size_t i = 0; i &lt; 256 &amp;&amp; (calc1(i++), !checkAndBreak()); );
for (size_t j = 0; j &lt; 256 &amp;&amp; (calc2(j++), !checkAndBreak()); );
</code></pre>

<p>This way you get your <code>&lt; 256</code> check first, then <code>calc1/calc2</code> are executed with the old <code>i/j</code> values, afterwards the <code>i/j</code> value gets incremented, and then the check is performed. If the check returns true, the whole <code>for</code> loop terminates.</p>

<p>Beware that those practices are not aligned with the KISS principle, so may you adjust your code, pre-conditions and post-effects to simply write</p>

<pre><code>for (size_t i = 0; i &lt; 256; ++i)
{
    // do the calculations #1
    // now check the side effects of those calculations
    if (serialCheckedAndStateChanged())
        break;
}
// The same for #2
</code></pre>
",,46632608,131
38163743,2,38161060,2016-07-02T19:28:23.787,1,,869656,,2016-07-02T19:28:23.787,,4,,"<p>This is a perfect example why you should not use ""break"", ""continue"" or multiple return statements within a method/procedure. You are not able to extract methods to reduce redundancies. My advice is to reformulate your code to work without break-statements.</p>

<p>I would try following approach:</p>

<pre><code>do {
    // some calculations #1
    i++;
} while (i &lt; 256 &amp;&amp; Serial.available() == 0)

if (Serial.available() &gt; 0)
{
    setStringOne = ""string one""
    setStringTwo = ""string two""
    setStringThree = ""string three""
    setStringFour = ""string four""
}

do {
    // some calculations #2
    j++;

} while (j &lt; 256 &amp;&amp; Serial.available() == 0)

if (Serial.available() &gt; 0)
{
    setStringOne = ""string one""
    setStringTwo = ""string two""
    setStringThree = ""string three""
    setStringFour = ""string four""
}
</code></pre>

<p>Now you are able to improve the the code:</p>

<p>Extract methods and apply the template pattern to the calculation code (as far as possible in Arduino) to reduce redundancy.</p>

<p>Example of extracted method:</p>

<pre><code>void determineString()
{
    if (Serial.available() &gt; 0)
    {
        setStringOne = ""string one""
        setStringTwo = ""string two""
        setStringThree = ""string three""
        setStringFour = ""string four""
    }
}
</code></pre>
",,46695060,175
38174086,2,38172993,2016-07-03T20:33:37.587,2,,4789526,,2016-07-04T16:07:33.163,2016-07-04T16:07:33.163,5,,"<p>Well, if you take a look a the code of the <code>isCallActive()</code> function, you'll see that it returns a boolean (0 or 1) not 2, 3, 4.</p>

<p>What actually returns these numbers, depending on the status of the call, is the AT command <code>AT+CPAS</code>. And the library doesn't take under consideration all the returns of <code>AT+CPAS</code>.</p>

<p><code>isCallActive()</code>, as it is implemented, will return <code>1</code> if the phone is ringing.</p>

<p>You can write your own and parse the return value.</p>

<hr>

<p>After reading the code carefully I found out that I was actually mistaken about the return of the function. I edited my answer, the function should return <code>1</code> if the phone is ringing.</p>

<p>However you've got a serious problem on how you are calling the function. </p>

<p>The function tries to get the number too and store it in the parameter you send (<code>isCallActive(char *number)</code>), however you are sending a <strong><em>string literal</em></strong>, then the function tries to modify it, and <em>attempting to modify a string literal results in an undefined behavior</em>.</p>

<p>That's what's happening when you call <code>isCallActive</code> with <code>PHONE_NUMBER</code></p>

<p>Try to call it properly.</p>

<p>That should give something like this:</p>

<pre><code>#define MAX_LEN_NUMBER 10 // or whatever the max number is.

....

char numberToCallActive[MAX_LEN_NUMBER] = """";

void setup()
{
  ....
}

void loop()
{
 ...
 isCallActive(numberToCallActive);
 ....
}
</code></pre>

<p>You can then use this variable to check if actually the number ringing is the number you called.</p>
",,46701115,3046
38320533,2,38174727,2016-07-12T05:16:54.883,0,,2419128,,2016-07-12T05:16:54.883,,0,,"<p>Doesn't look like there's much interest in this, but I thought I'd post my answer for future, in case anyone else tries to delve into this type of project.</p>

<p>Findings:</p>

<ul>
<li>arecord is just a linked copy of aplay </li>
<li>you can use the incredible wiringPi c library to add a thread to the C code</li>
<li>by adding a static volatile int variable to the code - it becomes shared with between thread and main program</li>
<li>setting the variable to the perc value means it's updated immediately in the threaded program</li>
</ul>

<p>I was able to simulate a <strong>6 level audio level meter</strong> with LEDs using this code:</p>

<p>I used a button on the breadboard to toggle between LED levels being displayed and not.</p>

<p><strong>setAudioLEDS threaded function:</strong></p>

<pre><code>PI_THREAD (setAudioLEDs)
{
    // Only update LEDS if button is pressed
    // Gets Audio Level from global var: globalAudioLevel

    // Wiring Pi Constants for led and button
    // Pin number declarations. We're using the Broadcom chip pin numbers.

#define CYCLE_UPDATE '0'
#define CYCLE_STEADY '1'

    int last_button;
    int last_cycle;
    int this_cycle;

    // Button is released if this returns 1
    // HIGH or LOW (1 or 0)
    last_button = digitalRead(butPin);
    last_cycle = CYCLE_STEADY;
    this_cycle = last_cycle;

    while (1)
    {
        if (digitalRead(butPin) != last_button) {
            if (last_cycle == CYCLE_UPDATE)
                this_cycle = CYCLE_STEADY;
            else
                this_cycle = CYCLE_UPDATE;
            last_cycle = this_cycle;
        }

        switch (this_cycle) {

        case CYCLE_UPDATE:

            // Set LEDS based on audio level
            if (globalAudioLevel &gt; 20)
                digitalWrite(led1, HIGH); // Turn LED ON
            else
                digitalWrite(led1, LOW); // Turn LED OFF

            if (globalAudioLevel &gt; 40)
                digitalWrite(led2, HIGH); // Turn LED ON
            else
                digitalWrite(led2, LOW); // Turn LED OFF

            if (globalAudioLevel &gt; 60)
                digitalWrite(led3, HIGH); // Turn LED ON
            else
                digitalWrite(led3, LOW); // Turn LED OFF

            if (globalAudioLevel &gt; 70)
                digitalWrite(led4, HIGH); // Turn LED ON
            else
                digitalWrite(led4, LOW); // Turn LED OFF

            if (globalAudioLevel &gt; 80)
                digitalWrite(led5, HIGH); // Turn LED ON
            else
                digitalWrite(led5, LOW); // Turn LED OFF

            if (globalAudioLevel &gt; 90)
                digitalWrite(led6, HIGH); // Turn LED ON
            else
                digitalWrite(led6, LOW); // Turn LED OFF

            break;

        default:
            /* Button hasn't been pressed */
            digitalWrite(led1, LOW); // Turn LED OFF
            digitalWrite(led2, LOW); // Turn LED OFF
            digitalWrite(led3, LOW); // Turn LED OFF
            digitalWrite(led4, LOW); // Turn LED OFF
            digitalWrite(led5, LOW); // Turn LED OFF
            digitalWrite(led6, LOW); // Turn LED OFF
        }
    }
}
</code></pre>
",,46755747,819
38209942,2,38176121,2016-07-05T18:10:46.900,1,,6549302,,2016-07-05T18:10:46.900,,0,,"<p>I think your program should be like this:</p>

<pre><code>//(I don't explain IRremote implementations, since yours is good)
#define xor(a,b) (( a &amp;&amp; (!b)) || ((!a) &amp;&amp; b))
#define n_ports 6 //not to waste memory
#define input_pin 28
byte ports[n_ports] = {22, 23, 24, 25, 26, 27}; //you can also use int if you prefer
int i=0; // counter variable
bool b_pattern[7]; 

void setup() {
  for(i=0;i&lt;n_ports;i++)
    pinMode(ports[i], OUTPUT);
  //IRremote initialization
}

void loop() {
  time = millis();

  //(IRremote implementations)

  switch(chooseOption) { //for different patterns
    case 0:  //here some examples
      time = time%5000;//notice the ""time%5000"": it's to get 5 seconds periods, you can set it as you want
      b_pattern[0] = time&lt;2500; //that's a weird boolean, shall be the same as HIGH and LOW
      //if it doesnt work, just put an if construct
      for(i=0;i&lt;3;i++)
        digitalWrite(ports[i], b_pattern[0] ); 
      for(;i&lt;6;i++) //yes, I'm ignoring n_ports checking *_*
        digitalWrite(ports[i], !b_pattern[0] );
    break;
    case 1:
      time = time%5000;
      b_pattern[0] = time&lt;1666; // 1/3 of 5 second-pattern
      b_pattern[1] = time&lt;2500; // 1/2
      b_pattern[2] = time&lt;3333; // 2/3
      for(i=0;i&lt;3;i++)
        digitalWrite(ports[i], xor(b_pattern[0], b_pattern[2]) );
      for(;i&lt;4;i++)
        digitalWrite(ports[i], !xor(b_pattern[0], b_pattern[2]) );
      for(;i&lt;6;i++)
        digitalWrite(ports[i], b_pattern[1]);
    break;
    case 2:
      time = time%6000;
      b_pattern[0] = time&lt;1000;
      b_pattern[1] = time&lt;1500;
      b_pattern[2] = time&lt;2000;
      b_pattern[3] = time&lt;3000;
      b_pattern[4] = time&lt;4000;
      b_pattern[5] = time&lt;4500;
      b_pattern[6] = time&lt;5000; //VERY weird but logic, let's simplify
      b_pattern[1] = xor(b_pattern[1], xor(b_pattern[3], b_pattern[5]));
      b_pattern[0] = xor(xor(xor(b_pattern[0], b_pattern[2]),xor(b_pattern[3], b_pattern[4])), b_pattern[6]);
      for(i=0;i&lt;3;i++)
        digitalWrite( ports[i], b_pattern[1]);
      for(;i&lt;6;i++)
        digitalWrite( ports[i], b_pattern[0]);
    break;
  }
}
</code></pre>

<p>To change the triggered ports group, change the order in <strong>ports</strong> array. I also suggest you to check the program first with leds.</p>
",,46795446,148
38434759,2,38183840,2016-07-18T10:46:53.850,2,,5283481,,2016-07-18T10:46:53.850,,0,,"<p>The problem was about differences in address byte in UART mode and SPI mode, as you can see in this 
<a href=""http://i.stack.imgur.com/K7doW.jpg"" rel=""nofollow"">picture</a>
new modified read /write functions act very well:</p>

<pre><code>unsigned char ucAddr;
unsigned char ucValu;
uint8_t IncomingData;

    /////////////////////////////////////////////////////////////////////
    //@ Function: Reading RC522 register
    //@ Parameter Description: Address [IN]: register address
    //@ Return: The value read
    /////////////////////////////////////////////////////////////////////
    unsigned char ReadRawRC(unsigned char Address)
    {

         ucAddr = Address | 0x80;

             dataSign=false;
         Chip_UART_SendBlocking(LPC_USART0, &amp;ucAddr, 1);
             StopWatch_DelayMs(3);

             if(dataSign==true)
             return IncomingData;

             return 0;
    }

    /////////////////////////////////////////////////////////////////////
    //@ Function: write RC522 register
    //@ Parameter Description: Address [IN]: register address
    //Value [IN]: write value
    /////////////////////////////////////////////////////////////////////
    void WriteRawRC(unsigned char Address, unsigned char value)
    {
            ucAddr = Address &amp; 0x7F;
            ucValu = value;
        Chip_UART_SendBlocking(LPC_USART0, &amp;ucAddr, 1);
        Chip_UART_SendBlocking(LPC_USART0, &amp;value, 1);
    }
</code></pre>
",,46867766,408
38190034,2,38189676,2016-07-04T17:52:34.743,0,,4271923,,2016-07-04T19:54:24.490,2016-07-04T19:54:24.490,8,,"<p>I think you are confused by the output? <code>std::cout &lt;&lt; (char)&lt;char_code&gt;;</code> is probably displaying the char_code as number (so for the char 65 (ASCII 'A') it will run number formatter and display '6' and '5' (""65"") instead of ""A"")?</p>

<p>You should probably allocate some reasonably huge char buffer like <code>char uartInput[1024];</code>, then read the characters into it till it's either full, or some termination mark is reached. Let's say you will send string <code>""Hello""</code> from android as ASCII bytes terminated by zero, that means that over the wire will go these bytes: <code>72, 101, 108, 108, 111, 0</code> (any internal UART protocol bits removed).</p>

<p>So those values will be read by the <code>serialGetchar</code>, stored into <code>uartInput</code>, and then you can show them as ASCII string, for that a mere <code>std::cout &lt;&lt; uartInput;</code> should work (as cout can handle ASCII char[] zero terminated string well), or <code>printf(""%s"", uartInput);</code> is other option with the <code>*printf</code> functions family (I like these a tad more, although they are not C++ like).</p>

<p>Make sure the bytes sent from Android are in expected format (i.e. ASCII encoded, zero terminated, in order you expect them). For more robust application probably add some checksums and error handling, some data structure markers and protocol version numbers can be handy too, etc...</p>

<hr>

<p>Edit (on new code version):
You look to be still confused what is ASCII, string, character and number in computer. I will try to show it with some code examples.</p>

<pre><code>printf(""%d "", 65);
// will output three glyphs from font forming visually ""65 ""
//first is ""6"" (ASCII code 0x36 = 54)
//second is ""5"" (ASCII code 0x35 = 53)
//third is space "" "" (ASCII code 0x20 = 32)
//               (^^ usually a font glyph consisting of zero pixels drawn :))

printf(""%c "", 65);
// will output two glyphs from font forming visually ""A ""
//first is ""A"" (ASCII code 0x41 = 65)
//second is space "" "" (ASCII code 0x20 = 32)

char charZeroTerminatedString[] = ""Hello"";
// will allocate somewhere in memory 6 bytes, with values set to:
// 72, 101, 108, 108, 111, 0
// symbol charZeroTerminatedString itself is an address of byte containing the value 72
// so 'H' == 72 == charZeroTerminatedString[0], 111 == charZeroTerminatedString[4]
// or 72 == *charZeroTerminatedString, 111 == *(charZeroTerminatedString+4)

printf(""%s\n"", charZeroTerminatedString);
// will output six (five+one control) glyphs from font forming visually ""Hello"" + newline
// First is ""H"" (value 0x48 = 72 in memory)
// ...
// Sixth ""\n"" glyph is not as much as glyph,
// as control character just moving virtual cursor to new line
</code></pre>

<p>So finally your loop can look like this:</p>

<pre><code>#include &lt;cstring&gt;

//...

    constexpr int UART_INPUT_MAX_SIZE = 1024;
    char uartInput[UART_INPUT_MAX_SIZE+1];
    //^^ +1 to have zero terminator even for 1024+ chars sent

    //...

    while (true) {
        // clear the buffer for next receiving.
        int uartInputIndex = 0;
        memset(uartInput, 0, UART_INPUT_MAX_SIZE+1);
        // now receive data, till they are available
        // Or whole string is received
        while (serialDataAvail(conexion) &gt; -1 &amp;&amp;
                uartInputIndex &lt; UART_INPUT_MAX_SIZE) {
            uartInput[uartInputIndex] = serialGetchar(conexion);
            if (0 == uartInput[uartInputIndex]) break; //zero terminator received
            ++uartInputIndex;
        }
        if (0 == uartInputIndex) break; //No more strings received

        printf(""%s\n"", uartInput); // some string received
        // Either terminated by zero in byte stream
        // or by serialDataAvail reporting no more data
    }
</code></pre>

<p>Please bear in mind, that sending data over serial port takes some time, so exiting your loop while serialDataAvail reports zero available bytes may be too soon, as the rest of the data may be still on it's way trough the wire. So you should have some structural protocol designed to recognize ending of transmission, or have some delays along with time-out mechanism to wait for whole transmission.</p>

<p>The example code works well for me, when I was feeding it with instant fake complete data (in <code>serialDataAvail</code> and <code>serialGetchar</code>), but it will fail on real serial port communication to wait for whole data transmission.</p>
",,46875890,128
38219457,2,38218887,2016-07-06T08:28:36.753,1,,775806,,2016-07-06T12:37:25.643,2016-07-06T12:37:25.643,7,,"<p><strong>Edit</strong> this answer is no longer relevant since the question has been changed considerably. (End edit)</p>

<p>A function that computes a median of 5 values needs to get 5 values as an argument. This could be a standard container or a plain pointer to a legacy array or a pair of iterators. The function doesn't need to be concerned with storage of these values. The caller stores them.</p>

<pre><code>template &lt;typename T&gt;
T median_of_5 (const std::array&lt;T, 5&gt;&amp;); // a standard no-overhead container

template &lt;typename T&gt;
T median_of_5 (const T*); // a legacy array

template &lt;typename Iter&gt;
decltype(*std::declval&lt;Iter&gt;())
median_of_5 (Iter first, Iter last); // two iterators

// or another way
template &lt;typename Iter&gt;
typename std::iterator_traits&lt;Iter&gt;::value_type
median_of_5 (Iter first, Iter last); // two iterators
</code></pre>

<p>If a function template needs temporary storage for some data of type T, just declare it in the function:</p>

<pre><code>template &lt;typename T&gt;
T median_of_5 (const std::array&lt;T, 5&gt;&amp;)
{
    T values[5]; // no problem here
    ...
}
</code></pre>

<p>On the off chance you need to actually store five values outside of any function template using a generic type T, and you can use C++14, you can use a variable template:</p>

<pre><code> template &lt;typename T&gt;
 T values[5] { 2,6,8,9,11 };
</code></pre>

<p>But this is most probably not what you need.</p>
",,46895781,858
38221442,2,38218887,2016-07-06T10:10:35.067,1,,3388944,,2016-07-06T11:49:02.353,2016-07-06T11:49:02.353,6,,"<p>Do you mean something like this?</p>

<pre><code>template&lt;typename T&gt;
class medianbuffer{
public:
    // Should work like this
    medianbuffer() { /**/ }
    ~medianbuffer() { /**/ } // ""~"" = destructor , no expecting to happen
    T getFirst (){
        T result = getPos(0);
        return result;
    }
    private:
    T getPos (byte index){
        T result = values[index];
        return result;
    }
    T values[5]={2,6,8,9,11};
};
</code></pre>

<p>All function using the template typename will have to be defined in the header file AFAIK. </p>

<p>You will then have one medianbuffer class per type that you use. All functions still need a definition. </p>
",,46908301,1948
38233587,2,38218887,2016-07-06T20:52:17.147,0,,4018172,,2016-07-06T20:52:17.147,,0,,"<p>So, here are some findings that I have now.</p>

<ul>
<li>before trying everything you can find online, first create new class, and play with it. Trying to use type of <code>&lt;T&gt;</code> works better or only this way (do not know when).</li>
<li>do not use separate files for .h and .cpp. I'm not sure why is this a problem, since compiler is after all ""merging"" all of the files together anyway, but it turns out that if you do not follow this advide you will get errors that smart people can understand - but you will not, and there goes - two days are wasted.</li>
</ul>

<p>At the moment of writing this, this is all that I know. My guess that in following years, a lot of people may stumble here, and that the ones who know better try to give some better explaned anwsers, or at least fill the gaps.</p>

<pre><code>/*Before class with prototypes, indicate that Template T will be used
   not sure when to use first or second line, seems that both work in this scenario*/
    //template&lt;class  T&gt;
    template&lt;typename  T&gt;
    class medianbuffer{
        public:    
        medianbuffer() { /**/ } //since no cpp will be used, do not forget to create proper functions {} in this file
        ~medianbuffer() { /**/ } 
        T getFirst();
        //you may also try to define it here
        //T getFirst();{
           // T result = getPos(1);
           // return result;
        //}
        private:
        T getPos (byte index){
            T result = values[index];
            return result;
        }
        T values[5]={2,6,8,9,11};
    };

    //Here is one of your bigest time waste, and it's not an obvious one - put all in one file!
    /*The following part is usually in cpp files, but you will see a lot of ""undefined"" or similar warnings
    Because templates are compiled when required, this forces a restriction for multi-file projects:
    the implementation (definition) of a template class or function must be in the same file as its declaration.
    That means that we cannot separate the interface in a separate header file,
    and that we must include both interface and implementation in any file that uses the templates.
    http://www.cplusplus.com/doc/oldtutorial/templates/
    */
    //if writing methods here, remember that every method must have ""template"" in front,
    //do not forget to put &lt;T&gt;, since you will get a lot of cryptic errors
    template&lt;typename  T&gt;
    T medianbuffer&lt;T&gt;::getFirst(){
        T result = getPos(1);
        return result;
    }

    //type of T is actually passed to its class this way
    medianbuffer &lt;double&gt;mb_d;
    medianbuffer &lt;int&gt; mb_i;

    void setup() {
        Serial.begin(57600);
        debug();
    }

    void debug(){

        //class instantiated as double, you can use it normaly
        double first_d=mb_d.getFirst();
        Serial.print(""\n double type --&gt; "");
        Serial.print(first_d);

        //class instantiated as int
        int first_i=mb_i.getFirst();
        Serial.print(""\n int type    --&gt; "");
        Serial.print(first_i);
    }
    void loop() {
        // put your main code here, to run repeatedly:

    }
</code></pre>

<p>Thanks n.m. and FredyKay, your help was very appreciated.</p>
",,46979992,137
38235868,2,38235645,2016-07-07T00:23:13.753,1,,225074,,2016-07-07T00:23:13.753,,0,,"<p>I believe the most compatible method is to use a <code>struct</code> (or <code>class</code>) to describe the array:  </p>

<pre><code>struct Array_Attributes
{
  int8_t * array_memory;
  unsigned int maximum_rows;
  unsigned int maximum_columns;
};
</code></pre>

<p>You can treat the <code>array_memory</code> as a multidimensional array by converting from 2d to 1d indices:  </p>

<pre><code>unsigned index = row * maximum_columns + column;
</code></pre>

<p>You could also make an array out of linked lists.  This would allow dimensions of different sizes.</p>

<pre><code>+-------+     +----------+     +----------+  
| row 0 | --&gt; | column 0 | --&gt; | column 1 | ...  
+-------+     +----------+     +----------+  
    |  
    |
    V  
+-------+     +----------+     +----------+  
| row 1 | --&gt; | column 0 | --&gt; | column 1 | ...  
+-------+     +----------+     +----------+  
</code></pre>
",,47001618,399
38236989,2,38235645,2016-07-07T03:07:38.307,0,,4561887,,2016-07-07T03:33:04.490,2016-07-07T03:33:04.490,0,,"<p>Alright, I'd like to answer my own question too. There are many good ideas here, but let me post this simple and low-memory-cost solution. For devices of minimal memory (ex: an ATTiny AVR microcontroller with 512 bytes of RAM and a few kB program flash memory), I think this may be the best solution. I've tested it; it works. Use an array of pointers to int8_t's--ie: an array of pointers to 1D arrays, as follows:</p>

<pre><code>int8_t intArray10[][2] = {-2, -1,
                            0, 1,
                            2, 3,
                            4, 5,
                            6, 7};

int8_t intArray11[][3] = {10, 9, 8,
                           7, 6, 5, 
                           4, 3, 2,
                           1, 0, -1};

int8_t intArray12[][2] = {100, 101,
                          102, 103};

//get some array specs we need about the arrays
byte arrayLengths[] = {sizeof(intArray10)/sizeof(int8_t), sizeof(intArray11)/sizeof(int8_t), 
                        sizeof(intArray12)/sizeof(int8_t)}; //redundant division since int8_t is 1 byte, but I want to leave it for verboseness and extension to other types 
byte arrayCols[] = {2, 3, 2};

//make pointers to int8_t's and point each pointer to the first element of each 2D array, as though each 2D array was a 1D array
//-this works because the arrays use contiguous memory 
int8_t *intArray10_p = &amp;(intArray10[0][0]); 
int8_t *intArray11_p = &amp;(intArray11[0][0]);
int8_t *intArray12_p = &amp;(intArray12[0][0]);

//make an array of those pointers to 1D arrays 
int8_t *intArrayOfnDimArray[] = {intArray10_p, intArray11_p, intArray12_p};

//print the 3 arrays via pointers to (contiguous) 1D arrays:
//-Note: this concept and technique should work with ANY contiguous array of ANY number of dimensions
for (byte i=0; i&lt;sizeof(intArrayOfnDimArray)/sizeof(intArrayOfnDimArray[0]); i++) //for each 2D array 
{
  for (byte j=0; j&lt;arrayLengths[i]; j++) //for all elements of each 2D array 
  {
    Serial.print(intArrayOfnDimArray[i][j]); Serial.print(""/""); //now read out the 2D array values (which are contiguous in memory) one at a time; STANDARD ARRAY ACCESS TECHNIQUE 
    Serial.print(*(intArrayOfnDimArray[i] + j)); Serial.print(""/""); //ARRAY/POINTER TECHNIQUE (extra teaching moment)
    Serial.print((*(intArrayOfnDimArray + i))[j]); Serial.print(""/""); //POINTER/ARRAY TECHNIQUE
    Serial.print(*(*(intArrayOfnDimArray + i) + j)); //POINTER/POINTER TECHNIQUE 

    //add a comma after every element except the last one on each row, to present it in 2D array form 
    static byte colCount = 0; //initialize as being on ""Column 1"" (0-indexed)
    if (colCount != arrayCols[i]-1) //if not on the last column number 
      Serial.print("", "");
    else //colCount==arrayCols[i]-1 //if we *are* on the last column number 
      Serial.println();
    colCount++;
    if (colCount==arrayCols[i])
      colCount = 0; //reset 
  }
  Serial.println(F(""-----"")); //spacer 
}
</code></pre>

<p>Output:</p>

<pre><code>-2/-2/-2/-2, -1/-1/-1/-1
0/0/0/0, 1/1/1/1
2/2/2/2, 3/3/3/3
4/4/4/4, 5/5/5/5
6/6/6/6, 7/7/7/7
-----
10/10/10/10, 9/9/9/9, 8/8/8/8
7/7/7/7, 6/6/6/6, 5/5/5/5
4/4/4/4, 3/3/3/3, 2/2/2/2
1/1/1/1, 0/0/0/0, -1/-1/-1/-1
-----
100/100/100/100, 101/101/101/101
102/102/102/102, 103/103/103/103
-----
</code></pre>

<p>Note: as Thomas Matthews teaches in his answer, to access a specific 2D array, row, and column, use the following:</p>

<pre><code>byte index = row * maximum_columns + column;
</code></pre>

<p>which in my above example would be: </p>

<pre><code>byte rowColIndex = desiredRow * arrayCols[desired2DArrayIndex] + desiredColumn;
int8_t val = intArrayOfnDimArray[desired2DArrayIndex][rowColIndex];
</code></pre>

<p>Note: <code>byte</code> is equivalent to <code>uint8_t</code>.</p>
",,47007018,283
38293755,2,38267072,2016-07-10T15:58:01.890,3,,2614364,,2018-01-25T16:53:54.093,2018-01-25T16:53:54.093,5,,"<p>Using BlueZ, you can trigger a BLE scan using <code>hci_le_set_scan_parameters</code> and <code>hci_le_set_scan_enable</code>.</p>

<p><a href=""https://github.com/carsonmcdonald/bluez-experiments/blob/master/experiments/scantest.c"" rel=""nofollow noreferrer"">Here is an experiment written in C</a></p>

<pre><code>if (hci_le_set_scan_parameters(current_hci_state.device_handle, 0x01, htobs(0x0010), htobs(0x0010), 0x00, 0x00, 1000) &lt; 0)
{
    current_hci_state.has_error = 1;
    snprintf(current_hci_state.error_message, sizeof(current_hci_state.error_message), ""Failed to set scan parameters: %s"", strerror(errno));
    return;
}

if (hci_le_set_scan_enable(current_hci_state.device_handle, 0x01, 1, 1000) &lt; 0)
{
    current_hci_state.has_error = 1;
    snprintf(current_hci_state.error_message, sizeof(current_hci_state.error_message), ""Failed to enable scan: %s"", strerror(errno));
    return;
}
</code></pre>

<p>I've made a port of this example in C++ <a href=""https://gist.github.com/bertrandmartel/1ffb4db727733647da89203db0454b52"" rel=""nofollow noreferrer"">here</a></p>
",,47007151,247
38280591,2,38278755,2016-07-09T09:58:33.180,0,,4057102,,2016-07-09T10:04:36.700,2016-07-09T10:04:36.700,2,,"<p>I notice you are checking <code>Serial.available()</code> but using Serial<strong>1</strong> to read from :)</p>

<p>As you have a Mega, you wouldn't get an error as there is <code>Serial</code> and <code>Serial1</code>. I'd say this is your culprit!</p>

<p>The <code>Stream</code> read function will return -1 when there is no data. Also you could lessen the load on your Arduino and do the operation all at once (not open/close for each byte) and purge all available data (<code>Serial.read()</code> only reads a single byte in case you did not know).</p>

<pre><code>void loop() {

  File OpenFile = SD.open(""test.txt"", FILE_WRITE);

  if(OpenFile){
    while(Serial.available()){
      OpenFile.println(Serial.read());
    }
    OpenFile.close();
  }
}
</code></pre>

<p>You may want to check if the SD lib supports appending by default or a flag like <code>FILE_APPEND</code> as you will overwrite the file on the next loop if more data becomes available (Serial data isn't instant, your code may loop while receiving the rest of the data). </p>
",,47015224,75
38375019,2,38292164,2016-07-14T13:03:13.500,0,,3284313,,2016-07-14T13:09:20.027,2016-07-14T13:09:20.027,1,,"<p>Ok it's work ! :D
In fact to compile/push the blinky.c i was using a makefile ( i found it on a tuto ). 
So now i just take the .hex and use "" make install "", as i did with the first blinky but without the compilation as i get the .hex and not the .c
So here the makefile :)</p>

<pre><code>MCU=attiny85
AVRDUDEMCU=t85
CC=/usr/bin/avr-gcc
CFLAGS=-g -Os -Wall -mcall-prologues -mmcu=$(MCU)
OBJ2HEX=/usr/bin/avr-objcopy
AVRDUDE=/usr/local/bin/avrdude
TARGET=arduiblinky
# target = name of your file you want upload on the attiny

all : 
# no need this part if you have the .hex :D
    #$(CC) $(CFLAGS) $(TARGET).c -o $(TARGET)
    #$(OBJ2HEX) -R .eeprom -O ihex $(TARGET) $(TARGET).hex
    #rm -f $(TARGET)

install : all
    sudo gpio -g mode 22 out
    sudo gpio -g write 22 0
    sudo $(AVRDUDE) -p $(AVRDUDEMCU) -P /dev/spidev0.0 -c linuxspi -b 9600 - U flash:w:$(TARGET).hex
    sudo gpio -g write 22 1

noreset : all
    sudo $(AVRDUDE) -p $(AVRDUDEMCU) -P /dev/spidev0.0 -c linuxspi -b 10000 -U flash:w:$(TARGET).hex

fuse :
    sudo gpio -g mode 22 out
    sudo gpio -g write 22 0
    sudo $(AVRDUDE) -p $(AVRDUDEMCU) -P /dev/spidev0.0 -c linuxspi -b 10000 -U lfuse:w:0x62:m -U hfuse:w:0xdf:m -U efuse:w:0xff:m 
    sudo gpio -g write 22 1

clean :
    rm -f *.hex *.obj *.o
</code></pre>

<p>But does someone can explain me why it's work when i use the make file and why it's does not work when i do that :</p>

<pre><code>sudo gpio -g mode 22 out
sudo gpio -g write 22 0
sudo /usr/local/bin/avrdude -p t85 -P /dev/spidev0.0 -c linuxspi -b 10000 -U flash:w:blinky.hex
</code></pre>

<p>Thanks and i hope it could help someone :)</p>
",,47021714,337
38382822,2,38372030,2016-07-14T19:36:29.770,5,,5552095,,2016-07-14T19:36:29.770,,0,,"<p>So, the problem here is all about timing. You know that you have a limit on your buffer size for the software serial (Which is also true for any hardware UART, too), which is 256 bytes, at a baud rate of 9600 bits per second. </p>

<p>Since there is a start bit, 8 data bits, and a stop bit (Assuming you use 9600 8N1 here as it's the most common), you will be receiving a byte of data every (1 / 9600) * 10 - seconds, or 1.04 milliseconds. Therefore, to receive 256 bytes, it should take about 266 milliseconds. This means after 266 milliseconds, your buffer will be completely full, and anything you receive afterwards will start removing previously received data. </p>

<p>And there in lies the crux of your problem - You are sending a command to the ESP to receive data from a server, and then going to sleep for 5 seconds, meaning nothing is pulling data from the buffer, so it wraps around, leading to data loss. The point of a serial buffer isn't to hold the entire dataset you will receive at a single point, but, to hold it just long enough until you can read it out, which is why they're generally quite small. </p>

<p>What you need to do is send the command, and have your Arduino immediately run code to retrieve data as fast as it can from the buffer until it finds an expected end or times out.</p>

<p>Something basic like this would get you going:</p>

<pre><code>char espBuffer[1024] = {0};
int readCount = 0;
long startTime = millis();

ESPserial.println(""AT+CIPSTART=\""TCP\"",\""domainname\"",80"");

while (millis() - startTime &lt; 5000) { // Run for at least 5 seconds 
  // Check to make sure we don't exceed espBuffer's boundaries
  if (ESPserial.available() &gt; readCount + sizeof espBuffer - 1) 
    break;
  readCount += ESPserial.readBytes(espBuffer + readCount, ESPserial.available());
}

Serial.println(espBuffer);
</code></pre>

<p>Now, you'd want to modify this code to end when it has received all the data it expects. Additionally, this simple setup limits you to a maximum size of 1023 bytes for the response, which isn't too helpful either. Ideally you'd keep reading until you find, say, the HTTP body, and discard everything else, meaning the buffer to find the data is small, and the buffer to actually store the body can be much larger. </p>
",,47024738,85
38447699,2,38381521,2016-07-19T00:09:01.873,0,,56778,,2016-07-19T00:09:01.873,,0,,"<p>I'll assume that this is an exercise in creative thinking, rather than a real-world problem. Although something like this might have been a real-world problem back in the day of tape drives and limited memory.</p>

<p>If all you can do is use the queue's <code>pop</code> and <code>push</code> methods, then you can do what is essentially a really inefficient bubble sort. This requires O(n^2) operations and O(1) extra space.</p>

<p>Pseudocode:</p>

<pre><code>size = queue.Count

for i = 0 to size-1
    largest = queue.pop()
    for j = 1 to size-1
        temp = queue.pop()
        if temp &gt; largest
            queue.push(largest)
            largest = temp
        else
            queue.push(temp)
        end if
    end for
    queue.push(largest)
end for
</code></pre>

<p>So the first time through the loop, it makes sure that the largest item is at the end of the queue. The next time through, it will put the second-largest in its place, etc.</p>

<p>There are some minor optimizations possible, but they don't affect the running time very much because you still have to pop and push every item every time through the loop.</p>

<p>There is a possible early-out, just like there is for bubble sort. If in every iteration of the inner loop, <code>temp &gt; largest</code>, then you know the queue is in order. That could be a useful optimization, and it's not hard to implement:</p>

<pre><code>size = queue.Count
isInOrder = false
while isInOrder == false
    isInOrder = true
    largest = queue.pop()
    for j = 1 to size-1
        temp = queue.pop()
        if temp &gt; largest
            queue.push(largest)
            largest = temp
        else
            queue.push(temp)
            isInOrder = false
        end if
    end for
    queue.push(largest)
end while
</code></pre>

<p>Given that you can also call the queue's <code>get</code> method, there's probably a faster way to do this. Still O(n^2) complexity, but real-world running time could potentially be better. I'd have to think on that one.</p>
",,47057966,656
38429076,2,38417516,2016-07-18T05:21:14.950,0,,266392,,2016-07-18T05:21:14.950,,0,,"<p>In your statement:</p>

<pre><code>ReadFile (hSerial2, &amp;oneChar, 1, &amp;dwBytesRead, NULL);
</code></pre>

<p>You need to check the value of <code>dwBytesRead</code> to see if you actually read any bytes.  Maybe on one side of the connection you want a simple program to send a byte every second.  On the other end, you want to check for available bytes and dump them as they come in.</p>

<p>What's likely happening in your program is that you're filling an outbound serial buffer in a short amount of time, not waiting long enough to read any data back, and then exiting the loop and closing the serial port, likely before it finishes sending the queued data.  For example, write before your <code>CloseHandle()</code> call, you could add:</p>

<pre><code>COMSTAT stat;

if (ClearCommError(hCom, NULL, &amp;stat))
{
    printf(""%u bytes in outbound queue\n"", (unsigned int) stat.cbOutQue);
}
</code></pre>

<p>And see whether your closing the handle before it's done sending.</p>
",,47095300,40
38430698,2,38425750,2016-07-18T07:19:23.023,3,,4057102,,2016-07-18T07:19:23.023,,0,,"<p>The problem is in the .cpp file.</p>

<p>The two functions giving you a problem are here: </p>

<pre><code>boolean available(){
    return true;
}

byte read(){
    return 0;
}
</code></pre>

<p>As these are, they are free/global functions. You need to make them part of the class:</p>

<pre><code>boolean BlueHartwin::available(){
    return true;
}

byte BlueHartwin::read(){
    return 0;
}
</code></pre>

<p>Note: you'll also have to modify a few others also:</p>

<pre><code>void BlueHartwin::setDataLength(byte dataLength) {
    mDataLength=dataLength;
}

byte BlueHartwin::getDataLength(){
    return mDataLength;
} 
</code></pre>

<p>These can be fixed the same way.</p>
",,47095769,562
38499572,2,38497603,2016-07-21T08:58:56.940,1,,2819922,,2016-07-21T08:58:56.940,,0,,"<pre><code>int freeRam () {
  extern int __heap_start, *__brkval;
  int v;
  return (int) &amp;v - (__brkval == 0 ? (int) &amp;__heap_start : (int) __brkval);
}
</code></pre>

<p>call this function e.g.<pre> Serial.println(freeRam()); </pre>at the deepest level of your functions or wherever you want.</p>

<p>And don't use malloc() or c++ new, to avoid ""stability problems"", because there's no exception handling or other error checking in dynamic memory allocation.</p>
",,47095927,816
38502209,2,38501650,2016-07-21T10:48:32.870,0,,6488611,,2016-07-21T10:48:32.870,,6,,"<p>Look at this example code:</p>

<pre><code>char incomingByte;
int led=3;

void setup() {
   Serial.begin(9600);
   pinMode(led,OUTPUT);
   Serial.println(""LED control"");
   Serial.println(""0 = LED off)"");
   Serial.println(""1 = LED on"");
}

void loop(){
  if(Serial.available()&gt;0){
    incomingByte = Serial.read();
    if(incomingByte == '0'){
       digitalWrite(led,LOW);
    }
    if(incomingByte == '1'){
       digitalWrite(led,HIGH);
    }
  }
}
</code></pre>

<p>So the only thing you probably need to do is to change your <code>int bite</code> to <code>char bite</code> because of the Serial.read()!</p>
",,47147491,486
38573709,2,38533480,2016-07-25T17:08:48.780,0,,5383622,,2016-07-25T17:08:48.780,,0,,"<p>I found a solution, how to communicate with the Arduino via serial Port (USB). I don't use libserial.</p>

<p>I improved the Arduino code (display only, if there is a new line):</p>

<pre><code>// include the library code:
#include &lt;LiquidCrystal.h&gt;
#include &lt;SoftwareSerial.h&gt;

// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

String inputString = """";         // a string to hold incoming data
boolean stringComplete = false;  // whether the string is complete

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(""connecting..."");

  inputString.reserve(200);

  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  lcd.setCursor(0, 0);
  lcd.print(""successful connected"");

}

void loop() {
  lcd.setCursor(0, 1);

  if (stringComplete) {
  // print the string when a newline arrives:

    lcd.setCursor(0, 1);
    lcd.print(""                "");

    lcd.setCursor(0, 1);
    lcd.print(inputString);

    inputString = """";
    stringComplete = false;

  }
}

void serialEvent() {

  if (Serial.available()) {
    while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
  }
}
</code></pre>

<p>C++ code:</p>

<pre><code>//to compile use: g++ serial_success.cpp -o serial -std=c++11

//you might not need every inclusion
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

#include &lt;stdio.h&gt; // standard input / output functions
#include &lt;string.h&gt; // string function definitions
#include &lt;unistd.h&gt; // UNIX standard function definitions
#include &lt;fcntl.h&gt; // File control definitions
#include &lt;errno.h&gt; // Error number definitions
#include &lt;termios.h&gt; // POSIX terminal control definitionss
#include &lt;time.h&gt;   // time calls

using namespace std;

#define BAUDRATE B9600


int main(int argc, char** argv)
{  

    int fileDescriptor = open(""/dev/ttyACM0"", O_RDWR | O_NOCTTY);

    struct termios newtio;
    bzero(&amp;newtio, sizeof(newtio));
    newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;

    // set to 8N1
    newtio.c_cflag &amp;= ~PARENB;
    newtio.c_cflag &amp;= ~CSTOPB;
    newtio.c_cflag &amp;= ~CSIZE;
    newtio.c_cflag |= CS8;

    newtio.c_iflag = IGNPAR;

    // output mode to
    //newtio.c_oflag = 0;
    newtio.c_oflag |= OPOST;

    /* set input mode (non-canonical, no echo,...) */
    newtio.c_lflag = 0;

    newtio.c_cc[VTIME] = 10; /* inter-character timer 1 sec */
    newtio.c_cc[VMIN] = 0; /* blocking read disabled  */

    tcflush(fileDescriptor, TCIFLUSH);
    if (tcsetattr(fileDescriptor, TCSANOW, &amp;newtio)) {
        perror(""could not set the serial settings!"");
        return -99;
    }

    int i = 0;
    string test = ""&gt;123,456,7890;"";

    while(i &lt; 10) {

        usleep(100000);

        string res = test + std::to_string(i) + ""\n"";
        long wrote = write(fileDescriptor, res.c_str(), sizeof(char)*res.size() );

        cout &lt;&lt; res &lt;&lt; endl;


        i++;
    }


    cout &lt;&lt; ""ready"" &lt;&lt; endl;

    return 0;
}
</code></pre>
",,47189881,2831
38550415,2,38548926,2016-07-24T09:11:34.757,0,,6631077,,2016-07-24T09:11:34.757,,1,,"<p>you have to add pinMode() to setup.</p>

<pre><code>void setup() {
    pinMode(ledPinR, OUTPUT);
    pinMode(ledPinG, OUTPUT);
    pinMode(ledPinB, OUTPUT);
}
</code></pre>
",,47244709,1126
38558383,2,38548926,2016-07-25T01:02:31.747,0,,127269,,2016-07-25T02:29:22.710,2016-07-25T02:29:22.710,6,,"<p>You have to delay the operations, before your turn the next light on or off like so:</p>

<p>EDIT: a complete fader for your case, you might want to skip 4 in the loop, but I will let you handle that.</p>

<pre><code>int ledPinR = 5;
int ledPinG = 6;
int ledPinB = 3;

int brightness = 0;
int fade = 5;

void setup() {
  pinMode(ledPinR, OUTPUT);
  pinMode(ledPinG, OUTPUT);
  pinMode(ledPinB, OUTPUT);
}

void loop() {
  for(int LED_PIN = 3; LED_PIN&lt;=6; LED_PIN++) {
    analogWrite(LED_PIN, brightness); //setting the brightness at LED pin
    brightness += fade; //brightness increasE
    if(brightness == 0 || brightness == 255){
      fade = -fade;
    }
    delay(30); //time of delay is in miliseconds
  }
}
</code></pre>

<p>EDIT2: OK, saw your setup, I was way off on what you wanted to do with the colors, don't know if I should delete the answer, it is misguiding now. Hope the delay helped though.</p>
",,47357656,418
38558513,2,38548926,2016-07-25T01:24:41.557,1,,2218328,,2016-07-25T02:11:08.813,2016-07-25T02:11:08.813,24,,"<p>I think you misunderstood my last comment under @Secko's answer, so here is what I meant:</p>

<pre><code>int r = 5;
int g = 6;
int b = 3;

void setup() {
    pinMode(r, OUTPUT);
    pinMode(g, OUTPUT);
    pinMode(b, OUTPUT);
}

void loop() {
    analogWrite(r, 128);
    delay(50);
    analogWrite(r, 0);
    analogWrite(g, 128);
    delay(50);
    analogWrite(g, 0);
    analogWrite(b, 128);
    delay(50);
    analogWrite(b, 0);
    delay(50);
}
</code></pre>

<p>You need to turn off the last color you turned on in order to get a red, green and blue blink light. Otherwise if you turn on green after red, the strip will be yellow for a short time. If you then turn on blue it will be white and stay white, since no colors are ever turned off.</p>

<p>The second parameter is the voltage applied to your pins. It ranges from 0 - 255, where 0 is 0V and 255 is 5V. 128 is right in the middle with 2.5V.</p>

<p>If your strip is large (=>3 LEDs with power efficient LEDs. Otherwise >1), I hope you use transistors to offload the current draw from the arduino to the transistor. Otherwise you will blow the arduino very soon.</p>

<p><strong>EDIT:</strong>
You probably blew the arduino already by pulling too much current (too much LEDs) from it's pins.</p>

<p>You will need a PNP transistor in between each color and the arduino that can handle a large current (since you drive a lot of LEDs), which means a darlington transistor array integrated circuit.</p>

<p>Something like the TIP125 comes to mind. (<a href=""https://www.fairchildsemi.com/datasheets/TI/TIP125.pdf"" rel=""nofollow noreferrer"">https://www.fairchildsemi.com/datasheets/TI/TIP125.pdf</a>)</p>

<p>It has a maximum collector current of 5A. Put this right in the middle of your VCC and the strip (VCC to collector, the strip to emitter) and connect the arduino to the base of the transistor. You will need 3, one for each color.</p>

<p><strong>EDIT2:</strong>
Here is a very quickly made schematic to show you the basics. It should be fully functional for a 12V LED strip with an individual color current draw of up to 5A (so 15A total).</p>

<p>You may want to add resistors on the transistor base to sink current though.</p>

<p><a href=""https://i.stack.imgur.com/dZsYa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dZsYa.png"" alt=""tip125/arduino transistor schematic""></a></p>

<p><strong>EDIT3:</strong>
Since you are probably new to electronics: A PNP transistor will enable the connection between collector and emitter if the base is low. Meaning: <code>analogWrite(r, 0)</code> will turn the color on the strip on and <code>analogWrite(r, 255)</code> will turn it off. It is inverted with the transistor in between.</p>

<p>Also, and I hope this is obvious, <strong>DO NOT ROUTE 5A PER COLOR THROUGH A BREADBOARD OR THROUGH TINY WIRES. THEY WILL GO UP IN SMOKE.</strong></p>
",,47392427,914
38552867,2,38552359,2016-07-24T14:03:45.283,0,,2819922,,2016-07-24T14:03:45.283,,0,,"<p>Twodimensional arrays are only the scond best choice in most cases.
I prefer to have a one-dimensional array of dedicated items.</p>

<pre><code>struct Tone {unsigned int freq; byte duration;};
Tone mySong[] {
           {G2, 2}, 
           {B2, 1}, 
           {D3, 1}, 
           {G3, 2}
 };
</code></pre>

<p>Of course Joachim's reply about the unknown size, when supplying a Tone song[] parameter, is true as well.
Either supply number of elements as an extra parameter, or define a</p>

<p>const Tone EndOfSong {0,0};</p>
",,47400913,316
38638208,2,38638045,2016-07-28T13:40:53.710,0,,4271923,,2016-07-28T13:52:29.850,2016-07-28T13:52:29.850,0,,"<p>you can't add anything to POINTER, pointer is just pointing to some memory.
You need first to have some instance, like in your second example <code>String temp[3];</code> you are creating three instances of <code>String</code>.</p>

<p>So <code>String temp;</code> will create local instance of <code>String</code>, then to get it's pointer you can use <code>String * tempPtr = &amp;temp;</code>, but I don't see why you would want that, as you can use <code>temp</code> as is... like <code>temp.clear();</code> or whatever functions the class <code>String</code> has (see it's API).</p>

<hr>

<p>Edit about returning String pointer.</p>

<p>That's sort of unfortunate C++ API design. So who will own the memory of that instance?</p>

<p>For example:</p>

<pre><code>String* SomeClass::toArray(String str) {
    String result;
    // BUG, DO NOT DO THIS!
    return &amp;result; // returns pointer to local stack variable
    // which gets released *here*, invalidating the pointer
}

String* SomeClass::toArray(String str) {
    String *result = new String;
    return result; // returns pointer to global heap
    // now if the upper layer of code will not call ""delete"" on it
    // you have memory leak
}
</code></pre>

<p>BTW, from the ""toArray"" name it looks like you want array of String instances, not String pointer. So that functions should be rather defined as <code>String[] SomeClass::toArray(String str)</code>, still having the same problem with memory ownership.</p>

<hr>

<p>What I would do is not return an array.
maybe <code>void SomeClass::toArray(const String &amp; str, std::vector&lt;String&gt; &amp; array)</code>, filling up the data into <code>array</code> vector.</p>

<p>I do not know how much you use C++ on arduino, if std::vector is OK, or not, but having a class for String feels like vector&lt;> will be OK too, especially if you are wasting your stack by passing copy instance of String instead of reference. (unless <code>String</code> is some macro/typedef for <code>char[]</code>, please, don't tell me that... I mean, even C++ can be written in low memory footprint way, you don't have to hardwire arrays everywhere, if you avoid unnecessary allocation of temporary instances of C++ classes).</p>
",,47410236,470
38638702,2,38638421,2016-07-28T14:00:25.517,1,,794606,,2017-03-17T18:38:57.357,2017-03-17T18:38:57.357,0,,"<p>It's Illegal: </p>

<pre><code> sscanf(buf, ""%x"", /* byte*/ &amp;val ) 
</code></pre>

<p>sscanf family is not typesafe. the Programmer must control the code (printf family is dangerous too - sscanf is even more).</p>

<p>The 3rd argument (and those following, if there's more than one %d or %X) must be an adress(es) of integer(s). Integer in the sense of ""natural on the platform"", here 2 byte. </p>

<p>Your idea can be written as follows:</p>

<pre><code>int someInt, wrkInt;
byte someByte;

void setup() {
  Serial.begin(9600);

  sscanf(""10000 10"", ""%d %d"", &amp;someInt, &amp;wrkInt);  // %X too, rule is the same
  someByte = wrkInt;
...
}
</code></pre>
",,47420121,3399
38643797,2,38643407,2016-07-28T18:08:42.590,0,,6600109,,2016-07-28T18:29:58.123,2016-07-28T18:29:58.123,2,,"<p>Just a guess (I don't do much embedded programming), but according to C standard the number literal <code>1</code> has type <code>int</code>. In embedded programming <code>int</code> can be 16 bits, in which case your left shift will have undefined behaviour, since right operand is too large.</p>

<p>So try using <code>1L</code> to make this of type <code>long</code>.</p>

<p>Also, as mentioned by Olaf in comments, do not use <code>(volatile uint32_t)</code> cast unless you are sure that you need it. Some googling suggests that this is about Arduino 101, and <a href=""https://github.com/01org/corelibs-arduino101/blob/master/variants/arduino_101/variant.cpp#L193"" rel=""nofollow"">source code</a> I found does use both <code>READ_ARC_REG</code> and <code>WRITE_ARC_REG</code> without any cast.</p>

<pre><code>creg = READ_ARC_REG(AR_IO_CREG_MST0_CTRL);

if((creg &amp; (1L &lt;&lt; CREG_CLK_CTRL_I2C0)) == 0){
     creg |= (1L &lt;&lt; CREG_CLK_CTRL_I2C0);
     WRITE_ARC_REG(creg, AR_IO_CREG_MST0_CTRL);
}
</code></pre>
",,47423859,841
38644087,2,38643407,2016-07-28T18:25:04.003,3,,6651174,,2016-07-28T18:25:04.003,,0,,"<p>Personally, I would use the data type given: uint32_t.  That will guarantee alignment regardless of context.  That is <em>(factored for clarity, and assuming shift doesn't yield different size-type)</em>:</p>

<pre><code>uint32_t mask = ((uint32_t)1) &lt;&lt; CREG_CLK_CTRL_I2C0;
if((creg &amp; mask) == 0){
     creg |= mask;
     WRITE_ARC_REG(creg, (volatile uint32_t)(AR_IO_CREG_MST0_CTRL));
}
</code></pre>
",,47473644,126
38661450,2,38659146,2016-07-29T14:33:59.443,0,,5344725,,2016-07-29T14:33:59.443,,0,,"<p>First, make sure you conceptually understand what it means for a robot to drive in a straight line. You will not get a robot that moves perfectly in a straight line. You may get one to move straight-enough (perhaps more perfect than humans can determine) but there will always be error.</p>

<p>A gyroscope may not be able to determine you're going off course if it's gradual enough and depending on the quality of your gyro it may have a buildup of drift, causing it to think it's turning ever-so-slightly when it's sitting perfectly still. The more expensive of a gyro you get, the less this will be, but still.</p>

<p>Even if you assume perfect sensors, there is still a difference between ""driving straight"" and ""keeping on the straight and narrow"". Imagine you had coded a robot to drive such that it tried to keep its bearing as consistent as possible (drive straight). If, while it was moving you knocked it a bit, it would swerve to the side some and then correct itself to the original angle. However, it would be on a different path. Sure, the path would be parallel to the original one, but it would not be the same path.</p>

<p>Then there's the option of having it try to figure out just how far off the beaten path it was pushed and try to get back on it. That'll either take a constant reference (as a line follower robot would do) or more sensors (like a 3D gyro and 3D accelerometer).</p>

<p>That second option sounds a bit more than what you're doing, so here's the first option done in no particular robotics framework:</p>

<pre><code>//initialize
double angle = gyro.get_heading_degrees();
//...
//logic code that may be looped or fired by events
{
  //this is our error; how far off we are from our target heading
  double error = angle - gyro.get_heading_degrees() - 360;

  drive_system.drive_arcade(error / 180, 1);
}
</code></pre>

<p>This assumes driving in an arcade fashion; you can adapt it to tank drive or swerve drive or mecanum drive or H-drive or...</p>

<p>The '1' is just a speed</p>

<p>The '-360' and '180' are values to reduce the angle to a value between -1 and 1. If your drive method uses a different range to determine angle, that'll have to be adapted.</p>

<p>Finally, this example isn't foolproof, but it should get you thinking about how to correct for errors when you've detected them.</p>
",,47490481,284
38668211,2,38667981,2016-07-29T22:13:24.193,1,,4151599,,2016-07-29T22:29:04.940,2016-07-29T22:29:04.940,2,,"<p>It's likely that your data is being cached such that it isn't actually written to your serial device until <code>CloseHandle</code> is called in <code>~Serial</code>.  You can avoid this caching behavior by specifying <code>FILE_FLAG_WRITE_THROUGH</code> in your call to <code>CreateFile</code>, so that the file creation would look something like:</p>

<pre><code>//Try to connect to the given port throuh CreateFile
this-&gt;hSerial = CreateFile(portName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL);
</code></pre>

<p>If that doesn't work, there's also <code>FILE_FLAG_NO_BUFFERING</code>, but that may impose limitations on the alignment of the data you write to the device.</p>

<hr>

<p>If you would like to retain the normal buffering behavior, you could add a <code>Serial::Flush</code> method that calls <code>FlushFileBuffers</code> to force Windows to write any data it has cached out to the device:</p>

<pre><code>void Serial::Flush()
{
    FileFlushBuffers(this-&gt;hSerial);
}
</code></pre>

<p>You would then call <code>SP-&gt;Flush()</code> after <code>SP-&gt;WriteData(...)</code> to ensure that Windows' buffers are flushed to the device.  This would allow you to make multiple small writes without having to flush each one, possibly improving performance.</p>

<hr>

<p>As a side note, I would question your use of <code>new</code> here.  It doesn't seem like it's really needed, and <code>SP</code> could just be constructed locally:</p>

<pre><code>Serial SP(argv[1]);
</code></pre>
",,47503285,296
38675256,2,38670667,2016-07-30T14:55:36.893,1,,6447563,,2016-07-30T14:55:36.893,,0,,"<p>Yes, you can. You should use <code>File</code> class methods to do that. Tsadak's method works for Windows only. More universal method is this:</p>

<p>NumberFormat numFormat= NumberFormat.getNumberInstance();
for (Path fsRoot : FileSystems.getDefault().getRootDirectories()) {</p>

<pre><code>System.out.print(root + "": "");
try {
    FileStore store = Files.getFileStore(root);
    System.out.println(""available space"" + numFormat.format(store.getUsableSpace()));
System.out.println("", total="" + numFormat.format(store.getTotalSpace()));
} catch (IOException e) {
    System.out.println(""error: "" + e.toString());
}
}
</code></pre>
",,47514938,53
38682708,2,38673748,2016-07-31T09:45:56.523,1,,678093,,2016-07-31T15:17:24.767,2016-07-31T15:17:24.767,2,,"<p>In your specific use case you can simply iterate over the string and convert the hex substrings to numbers like this:</p>

<ul>
<li>each substring consists of exactly two hex characters; let a substring be denoted by <code>XY</code></li>
<li><code>X</code> and <code>Y</code> are either within <code>[0-9]</code> or within <code>[A-F]</code> where <code>A</code> <em>means</em> <code>10</code>, <code>B</code> means <code>11</code>, etc. (in decimal)</li>
<li><p>the transformation from an ASCII value to the numerical meaning of one of those characters depends on which character set a char is from:</p></li>
<li><p>if a char <code>c</code> is from <code>[0-9]</code>, its decimal meaning is <code>c-'0'</code>, i.e. substracting the offset so that the following mapping applies <code>'0'=&gt;0, '1' =&gt; 1, ...</code>   </p></li>
<li><p>if a char <code>c</code> is from <code>[A-F]</code>, the mapping can be expressed as <code>c-'A'+10</code></p></li>
<li><p>the numeric, decimal value <code>v</code> of each substring <code>XY</code> is then calculated as follows: <code>v=X*16 + Y</code> </p></li>
<li>the substrings are separated by a single char (here a <code>:</code>, but this does not matter)</li>
</ul>

<p>The following code implements those ideas:</p>

<hr>

<pre><code>#include &lt;string&gt;
#include &lt;cstdlib&gt;

std::uint8_t getNum(char hexChar)
{
    if(hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9')
    {
        return hexChar - '0';
    }
    return (hexChar-'A'+10);
}

int main()
{
    std::uint8_t mac[6];
    std::string str = ""01:23:45:AB:CD:EF"";

    std::uint8_t j = 0;
    for(std::uint8_t i = 0; i&lt;6; ++i)
    {
        mac[i] = getNum(str[j])*16 + getNum(str[j+1]);
        j+=3; // get to the next substring
    }
}
</code></pre>
",,47574054,366
38687234,2,38673748,2016-07-31T18:37:26.950,0,,24334,,2016-08-04T20:34:59.500,2016-08-04T20:34:59.500,4,,"<p>I am too late, and m.s.'s answer is correct. </p>

<p>My answer is a bit different as it is using the  to compute the hexadecimal from a string of characters and the  to make it more c++11.
While I am not certain if it's supported on your ESP8266 module I hope it helps.</p>

<pre><code>#include &lt;string&gt;
#include &lt;array&gt;

std::array&lt; uint8_t, 6&gt; MAC_fromStringToArray(const std::string&amp; str)
{
    std::array&lt; uint8_t, 6&gt; ret ;

    for (auto i = 0; i &lt; 6; i++)
    {
        ret[i] = std::stoi(str.substr((i * 3), 2), nullptr, 16);
    }

    return ret;
}

int main()
{
    std::string str = ""01:23:45:AB:CD:EF"";

    std::array&lt; uint8_t, 6&gt; mac = MAC_fromStringToArray(str);

    return 0;
}
</code></pre>

<p>EDIT: since the  does not seems to be available I changed it the traditional array.</p>

<pre><code>uint8_t * MAC_fromStringToArray(const std::string&amp; str, uint8_t arr[])
{
    for (int i = 0; i &lt; 6; i++)
    {
        arr[i] = std::stoi(str.substr((i * 3), 2), nullptr, 16);
    }

    return arr;
}
</code></pre>

<p>It needs to be called differently:</p>

<pre><code>uint8_t arr[6]; 

MAC_fromStringToArray(str, arr);
</code></pre>

<p>Hope it helps, I am afraid that without access to the same compiler as you it is diffcult to resolve your situation.</p>
",,47617637,194
38696460,2,38696032,2016-08-01T10:24:27.800,1,,3932569,,2016-08-01T14:37:57.793,2016-08-01T14:37:57.793,6,,"<p>As already mention, you want put 5 bytes inside a <code>long</code> which can store only 4 bytes. Also, you have to use structure:</p>

<pre><code>struct RFIDTagId
{
    unsigned long low;
    unsigned long high; // can also be unsigned char
};
</code></pre>

<p>And use something like that:</p>

<pre><code>unsigned int hex2int(char c)
{
    if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
        return (c - 'A' + 0x0A);
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
        return c - '0';
    return 0;
}

void char2Id(char *src, RFIDTagId *dest)
{
    int i = 0;

    dest-&gt;low = 0;
    for(i = 0; i &lt; 8; ++i)
    {
        dest-&gt;low |= hex2int(src[i]) &lt;&lt; (i*4);
    }

    dest-&gt;high = 0;
    for(i = 8; i &lt; 10; ++i)
    {
        dest-&gt;high |= hex2int(src[i]) &lt;&lt; ((i-8)*4);
    }
}
</code></pre>

<p>And to compare 2 ids:</p>

<pre><code>int isRFIDTagIdIsEqual(RFIDTagId * lhs, RFIDTagId * rhs)
{
    return lhs-&gt;low == rhs-&gt;low &amp;&amp; lhs-&gt;high == lhs-&gt;high;
}
</code></pre>

<p>or if you really have c++:</p>

<pre><code>bool operator==(RFIDTagId const &amp; lhs, RFIDTagId const &amp; rhs)
{
    return lhs.low == rhs.low &amp;&amp; lhs.high == lhs.high;
}
</code></pre>
",,47716719,52
38708913,2,38708837,2016-08-01T22:12:52.163,0,,3323096,,2016-08-01T23:13:19.180,2016-08-01T23:13:19.180,14,,"<p><strong>C++ does not support runtime sized arrays.</strong> Therefore if you do not know at compile time what size of memory you will need an array is the wrong tool for the job. I would instead suggest having your object contain only a pointer, and then use new to dynamically allocate the data block based on some runtime value.</p>

<p>Note the following code is just to demonstrate the idea expressed above and is not tested, and probably does not compile.</p>

<pre><code>class myClass {
private:
    byte *myData;
public:
    myClass(std::size_t dataSize) :
            myData(new byte[dataSize])
    {}
    myClass(const myClass&amp;) = delete;
    myClass(myClass&amp;&amp;) = delete;
    myClass&amp; operator=(const myClass&amp;) = delete;
    myClass&amp; operator=(myClass&amp;&amp;) = delete;
    ~myClass()
    {
        delete[] myData;
    }
};
</code></pre>

<p>If on the other hand, the size is known at compile time, but you dont wish to edit the header file every time you need to change the size you could instead use a template class, these allow users to provide compile time parameters when they use the class. For example:</p>

<pre><code>template&lt;size_t dataSize&gt;
class myClass {
private:
    byte myArray[dataSize];
};
</code></pre>

<p>The class can then be created with a custom size known at compile time as follows:</p>

<pre><code>auto foo = myClass&lt;128&gt;();
</code></pre>
",,47823215,1187
38709045,2,38708837,2016-08-01T22:26:13.143,4,,3723423,,2016-08-01T22:26:13.143,,2,,"<p><strong>Compile-time</strong></p>

<p>If your size is defined at compile time, you could use a template class, with the size as template argument.  </p>

<pre><code>template&lt;int EXAMPLE&gt;
class myClass{
        ...
    private:
        byte myArray[EXAMPLE];  
};
</code></pre>

<p>or you could use the <a href=""http://www.cplusplus.com/reference/array/array/"" rel=""nofollow""><code>std::array</code></a> container. </p>

<p><strong>vs. Run time</strong></p>

<p>However fixed sized arrays are not very flexible. I'd therefore strongly advise to use <a href=""http://www.cplusplus.com/reference/vector/"" rel=""nofollow"">vectors</a> instead.  Not only can you set a default size for your vector, but this size can be adapted dynamically without you having to worry about memory management, copy constructors, assignment operators, etc... </p>

<pre><code>class myClass {
    public: 
        myClass(int mysize=64) : myVector(mysize) {}       
    private:
        std::vector&lt;byte&gt; myVector;  // no size needed here
};
</code></pre>
",,47834740,212
38709058,2,38708837,2016-08-01T22:27:09.427,0,,6398057,,2016-08-01T22:27:09.427,,0,,"<p>Why not substitute the use of an array for a vector and define methods to manipulate the max size of the vector. So something like:</p>

<pre><code>#include &lt;vector&gt;


myClass{

private:
    vector&lt;int&gt; v;
    int maxSize
public:
  myClass(int size){
      v.reSize(size);
      maxSize = size;

  }
  void add(int byte){
      if(v.size()&lt;maxSize){
          v.push_back
      }
  }
}
</code></pre>
",,47873551,1723
41272703,2,38724187,2016-12-21T22:05:56.093,1,,7327833,,2016-12-21T22:05:56.093,,1,,"<p>yes red and blue channels are reversed you have to process the buffer:</p>

<pre><code>void interchange_colors(unsigned char *data, int tam)
{
  unsigned char cR;
  for(int i=0; i &lt;= tam; i+=3){
    cR = data[i];
    data[i]=data[i+2];
    data[i+2]=cR;
  }
}
</code></pre>
",,47889506,247
38730032,2,38729657,2016-08-02T20:38:27.383,1,,4065269,,2016-08-02T21:49:38.210,2016-08-02T21:49:38.210,7,,"<p>Your code compiles if you change:</p>

<p><code>typedef tt_point tt_figure[4][4];</code> to </p>

<p><code>typedef struct tt_point tt_figure[4][4];</code>. </p>

<p>For example this code below compiles and runs fine.</p>

<pre><code>#include&lt;stdio.h&gt;
struct tt_point
{
    int x;
    int y;
};

/* typedef tt_point tt_figure[4][4]; /*  /* Issue here */
typedef struct tt_point tt_figure[4][4]; /* add `struct' to typedef */

void tt_drawFigure(tt_figure figure);

tt_figure tt_T = { {{0,0}, {0,1}, {0,2}, {1,1}},
                   {{0,1}, {1,0}, {1,1},{2,1}},
                   {{0,1}, {1,0}, {1,1},{1,2}},
                   {{0,0}, {1,0},{1,1}, {2,0}}
                 };

int main(void)
{
    tt_drawFigure(tt_T);
    return 0;
}

void tt_drawFigure(tt_figure figure)
{ 
    int i, j;

    for (i = 0; i &lt; 4; i++) {
            for (j = 0; j &lt; 4; j++)
                    printf(""%d, %d --- "", figure[i][j].x, figure[i][j].y);
            printf(""\n"");
    }
    /* Do your drawing */
}
</code></pre>

<hr>

<p>You can also do </p>

<pre><code>typedef struct tt_point
{
    int x;
    int y;
} tt_figure[4][4];
</code></pre>

<p>so that you don't accidentally miss <code>struct</code> - like you missed when you did a <code>typedef</code> separately.</p>
",,47900395,1243
38731450,2,38730611,2016-08-02T22:26:06.417,0,,2709093,,2016-08-04T18:55:37.363,2016-08-04T18:55:37.363,1,,"<p>Can you work at a lower level, using the <a href=""https://docs.python.org/3.5/library/socket.html"" rel=""nofollow""><code>socket</code> module</a>?</p>

<pre><code>import socket
s = socket.socket(
    socket.AF_INET, socket.SOCK_STREAM)
s.connect((""192.168.0.101"", 23))

while True:
    data = str(s.recv(1024),encoding='utf-8')
    print(data)
</code></pre>

<p>Why this should work: It seems that your server is not a full telnet server (requiring a login etc) but a socket that waits for a connection, and then returns data.  </p>

<p>Since the server is just a socket, you can connect to it with a simple socket, which is what the above does.  I tested this in two ways. First with the Star wars telnet server at <code>towel.blinkenlights.nl</code>, and secondly with a simple python server that waits for a connection and then returns a line of text every second (to simulate your server). </p>
",,47913591,113
38741842,2,38741577,2016-08-03T11:06:31.113,1,,4593267,,2016-08-03T19:53:57.107,2016-08-03T19:53:57.107,1,,"<p>I you want <code>things</code> to point to a allocated array of size 2, you must write 3 statements:</p>

<pre><code>things = new Thing*[2];
things[0] = MakeThing();
things[1] = NULL;
</code></pre>

<p>The new style C99 compound literal syntax is not supported in C++, or only as an extension by some C++ compilers, but this would still not fit your purpose as the array would have automatic or static life span, not dynamic.</p>

<p><strong>EDIT:</strong> Given the rephrasing done on the question, the answer is quite simple:  The global <code>things</code> array must be defined as having 2 elements and can be initialized in <code>setup</code> with 2 statements:</p>

<pre><code>struct Thing {
  int i;
};
Thing *MakeThing(void) {
    Thing *t = calloc(sizeof(t));
    return t;
}
Thing *things[2];  // implicitly initialized to { NULL, NULL };
void setup(void) {
    things[0] = MakeThing();
    things[1] = NULL;
}
</code></pre>

<p>Or if you absolutely insist on using the C99 compound literals at the expense of readability you could use this:</p>

<pre><code>void setup(void) {
    memcpy(things, (Thing*[]){ MakeThing(), NULL }, sizeof things);
}
</code></pre>

<p>But I am not sure the Arduino compiler supports this syntax.  Arduino-C is neither C nor C++.</p>
",,47959824,43
38752736,2,38741577,2016-08-03T20:08:53.530,0,,905902,,2016-08-03T20:58:23.703,2016-08-03T20:58:23.703,2,,"<p>You can do a lot with static initialisation only, for instance (this is a doubly linked list):</p>

<pre><code>struct list {
        struct list *prev;
        struct list *next;
        int val;
        };

struct list arr[] =
{ {arr+1, arr+2, 1} 
, {arr+3, arr+4, 2} 
, {arr+5, arr+6, 3} 
, {arr+3, arr+4, 4} 
, {arr+3, arr+5, 5} 
, {arr+4, arr+6, 6} 
, {arr+5, arr+6, 7} 
        };
</code></pre>

<p>If you want extra space in the array you could use a sentinel to enable your code to fined the start of the unused space:</p>

<pre><code>struct list arr[ 100] =
{ {arr+1, arr+2, 1}
, {arr+3, arr+4, 2}
, {arr+5, arr+6, 3}
, {arr+3, arr+4, 4}
, {arr+3, arr+5, 5}
, {arr+4, arr+6, 6}
, {arr+5, arr+6, 7}
, { NULL, NULL, -1}
        };
</code></pre>

<p>... Or abuse the preprocessor as a line counter:</p>

<pre><code>struct list arr[ 100] =
# /* reset preprocessor line counter */
# 0 ""omg""
{ {arr+1, arr+2, 1}
, {arr+3, arr+4, 2}
, {arr+5, arr+6, 3}
, {arr+3, arr+4, 4}
, {arr+3, arr+5, 5}
, {arr+4, arr+6, 6}
, {arr+5, arr+6, 7}
        };
unsigned watermark = (__LINE__ -1);
</code></pre>

<p>... and of course the above could be changed,using the designated initialiser syntax.</p>

<p>BTW: This is not a DoublyLinkedList, (the offsets look wrong), but you get the idea...</p>
",,47969304,422
38742578,2,38742326,2016-08-03T11:41:04.247,1,,186193,,2016-08-03T11:46:35.820,2017-05-23T12:34:31.827,0,,"<p>Something like this should do it:</p>

<pre><code>const char* s[] = {""3"", ""238""};

int result = (std::stoi(std::string(s[0])) &lt;&lt; 8)
          + std::stoi(std::string(s[1]));
std::cout &lt;&lt; result;
</code></pre>

<p>Please note that I use <code>std::stoi</code>, if you don't like it, please see for more conversion possibilities at: <a href=""https://stackoverflow.com/questions/7663709/convert-string-to-int-c"">Convert string to int C++</a></p>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/da8037d62110db1a"" rel=""nofollow noreferrer"">live example</a></kbd></p>
",,47984333,1266
38742786,2,38742326,2016-08-03T11:50:13.897,0,,6478256,,2016-08-03T11:50:13.897,,4,,"<p>As Arduino's <code>String</code> cannot process hex representations, you should do it manually or with another libraries (e.g. using <code>sprintf</code> from standard C library, if it is possible). Here is a manual way:</p>

<pre><code>int decBytesToInt(const String &amp;msByte, const String &amp;lsByte)
{
    int res = 0;
    res |= (msByte.toInt() &amp; 0xFF) &lt;&lt; 8;
    res |= (lsByte.toInt() &amp; 0xFF);
}
</code></pre>

<p><code>msByte</code> and <code>lsByte</code> are most significant and least significant bytes decimal representations correspondingly.</p>

<p>Supposed that <code>int</code> is 16-bit, of course.</p>
",,48067283,656
38761955,2,38759247,2016-08-04T08:14:20.760,0,,1485311,,2016-08-04T08:14:20.760,,1,,"<p>If you want your code to keep doing something after a button has been pressed you need a ""toggle"" variable that is set once the button is pressed and reset when the button is pressed again.</p>

<p>In your global declarations you can put <code>bool mustDoIt = false;</code> and in your <code>main()</code>:</p>

<pre><code>if (keyPressed) {
  mustDoIt = !mustDoIt;
}

if (mustDoIt) {
  ...
}
</code></pre>

<p>Quite a few things that I notice:</p>

<ul>
<li>You have a big <code>if ... else</code> for <code>temp</code> (which by the way is not a good name, it could mean either <code>temperature</code> or <code>temporary</code>), on which you call another function, inside of which you make the same check. Why not passing the temperature to the function and checking it inside of it?</li>
<li>You repeat code a few times,</li>
</ul>

<p>Consider writing a function for this:</p>

<p>Something like:</p>

<pre><code>void displayMessage(char *first_row, char *second_row) {
  lcd.setCursor(0, 0);
  lcd.print(first_row);
  lcd.setCursor(0, 1);
  lcd.print(second_row);
  digitalWrite(led, HIGH);
  delay(200);
  beep(150);
  digitalWrite(led, LOW);
  delay(200);
}
</code></pre>

<ul>
<li>You basically only check on <code>temp</code>, <code>state</code> and <code>lightReading</code>, so as I said, move the checks where you actually need them. Pass those three variables to <code>doSomething</code> and do the checks in there.</li>
</ul>

<p>Something like this:</p>

<pre><code>void doSomething(float temp, int state, int lightReading) {
  if (temp &gt;= 35 &amp;&amp; temp &lt; 50)
  {
    displayMessage(""   Room Hot!!   "", """");
  } else if (temp &gt;= 34 &amp;&amp; temp &lt; 35)
  {
    displayMessage(""   Room Warm!   "", """");
  } else if (temp &gt;= 50)
  {
    displayMessage(""    Warning     "", ""    Danger!!    "");
  } //...Add rest of the checks here

  switch (state) {
    case 1: //Motor
      digitalWrite(motor1Pin1, HIGH);
      digitalWrite(motor1Pin2, LOW);
      digitalWrite(motor2Pin1, LOW);
      digitalWrite(motor2Pin2, HIGH);
    break;
    case 2:
      digitalWrite(motor1Pin1, HIGH);
      digitalWrite(motor1Pin2, LOW);
      digitalWrite(motor2Pin1, LOW);
      digitalWrite(motor2Pin2, LOW);
    break;
  //...Add rest of the checks here
  }
</code></pre>

<p>And the same goes for <code>lightReading</code>.</p>

<p>Also, the <code>digitalClockDisplay</code> function can be written as:</p>

<pre><code>void digitalClockDisplay() {
  char time_string[32];
  char date_string[32];

  memset(time_string, 0, 32);
  sprintf(time_string, ""Time: %02d:%02d:%02d     "", hour(), minute(), second());
  memset(date_string, 0, 32);
  sprintf(date_string, ""date: %02d.%02d.%02d     "", day(), month(), year());

  displayMessage(time_string, date_string);

  Serial.println(time_string);
}
</code></pre>

<p>I can't test the code right now, but I hope this gives you a few ideas.</p>
",,48113637,1513
38767266,2,38766190,2016-08-04T12:24:30.870,0,,721925,,2016-08-04T12:24:30.870,,0,,"<p>Thanks to the help of <code>oreubens</code> , I found a solution - just to pass directly from the main to the sub, a pointer for the function , so :</p>

<pre><code>void Main::setDelegate( float(*fp)(char*))
{
    fpAction=fp;
    sub-&gt;setDelegate(fpAction);



}
</code></pre>

<p>works great. thanks again .</p>
",,48135954,488
38835419,2,38834502,2016-08-08T17:41:25.577,2,,4100891,,2016-08-08T17:41:25.577,,0,,"<p>As dfri said, you were making another HardwareSerial instance, with disastrous results.</p>

<p>Just use a <em>reference</em>.  It's like a pointer, except the dot notation is used instead of having to use the arrow notation:</p>

<pre><code>HardwareSerial &amp; SerialB = Serial; // an alias, not a new instance

void setup() {
  SerialB.begin(115200);
  SerialB.print(0x33, HEX);
</code></pre>

<p>Note the ampersand.</p>
",,48137670,68
38837980,2,38837859,2016-08-08T20:29:17.697,6,,4342498,,2018-11-30T21:08:03.407,2018-11-30T21:08:03.407,2,,"<p>Neither of your code blocks work.</p>

<p>The first one compiles but introduces undefined behavior as you return a pointer to an array that no longer exist.  For a very detailed answer on this please see <a href=""https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"">Can a local variable&#39;s memory be accessed outside its scope?</a></p>

<p>The second code block fails to compile as <code>{p, r, y}</code> is not a valid initializer for a <code>double*</code>.</p>

<p>What you really need here is a <code>std::vector&lt;double&gt;</code>, <code>std::array&lt;double, some_constant_size&gt;</code> or <code>std::unique_ptr&lt;double[]&gt;</code>.  If you cannot use any of those then you need to dynamically create the array and then you need to remember to delete that array when you are don with it like</p>

<pre><code>double* getArray() {
    double * arr = new double[3]{1,2,3};
    return arr;
}

int main() {
    double* foo = getArray();
    // use array here
    delete [] foo;
}
</code></pre>
",,48169949,122
38844250,2,38842747,2016-08-09T07:07:53.800,0,,4297146,,2016-08-09T07:07:53.800,,0,,"<p>A few years ago, i do something like that using <a href=""http://qwt.sourceforge.net/"" rel=""nofollow"">QWT</a> and <a href=""https://github.com/qextserialport/qextserialport"" rel=""nofollow"">QextSerialPort</a>. You have to connect your Arduino using a serial por (in Windows COM1, COM2...), and you will be able to read/write data from the buffer.</p>

<p>Now, Qt, integrates a native support for this task, check <a href=""http://doc.qt.io/qt-5/qtserialport-index.html"" rel=""nofollow"">QtSerialPort Support</a>, to configure your port check this class <a href=""http://doc.qt.io/qt-5/qserialport.html"" rel=""nofollow"">QSerialPort</a>. How to read the data? Use QByteArray, an example:</p>

<pre><code> QByteArray responseData = serial-&gt;readAll();
 while(serial-&gt;waitForReadyRead(100))
       responseData += serial-&gt;readAll();
</code></pre>

<p>Now store all the bytes in a <a href=""http://doc.qt.io/qt-5/qvector.html"" rel=""nofollow"">QVector</a> of type double.</p>

<pre><code>QVector&lt;double&gt; data;
QDataStream stream(line);
stream &gt;&gt; data;
</code></pre>

<p>This data will be ploted by <a href=""http://qcustomplot.com/"" rel=""nofollow"">QCustomPlot</a>. Example:</p>

<pre><code>int numSamples = data.size();
QVector&lt;double&gt; x(numSamples), y(numSamples); // initialize with entries 0..100
for (int i=0; i&lt;numSamples; ++i)
{
  x[i] = i/50.0 - 1; // x goes from -1 to 1
  y[i] = data[i]; // In this line copy the data from your Arduino Buffer and apply what you want, maybe some signal processing
}
// create graph and assign data to it:
customPlot-&gt;addGraph();
customPlot-&gt;graph(0)-&gt;setData(x, y);
// give the axes some labels:
customPlot-&gt;xAxis-&gt;setLabel(""x"");
customPlot-&gt;yAxis-&gt;setLabel(""y"");
// set axes ranges, so we see all data:
customPlot-&gt;xAxis-&gt;setRange(-1, 1);
customPlot-&gt;yAxis-&gt;setRange(0, 1);
customPlot-&gt;replot();
</code></pre>

<p>Enjoy!</p>
",,48193700,1051
38905441,2,38905366,2016-08-11T20:20:59.857,2,,3980929,,2016-08-11T21:15:31.937,2016-08-11T21:15:31.937,4,,"<p><code>Encoder</code> doesn't have a default constructor, and it is implicitly call here</p>

<pre><code>MIDIEncoder::MIDIEncoder(uint8_t pin1, uint8_t pin2, byte midiChannel, byte midiCCNumber) 
    /*Implicit constructor call*/ 
{ 
    //...
}
</code></pre>

<p>You tried to call it the the constructor body, but by then ""it is too late"" :) What I mean is, <code>_enc</code> has to be already initialized when the constructor body executes, but <code>_enc</code> can't be default initialized, so the compiler complains.</p>

<p>That's what the constructor initializer list is for:</p>

<pre><code>MIDIEncoder::MIDIEncoder(uint8_t pin1, uint8_t pin2, byte midiChannel, byte midiCCNumber)
    : _enc(pin1, pin2) //Calls appropriate constructor for _enc, not default
{
    //...
}
</code></pre>
",,48193931,148
38956001,2,38952729,2016-08-15T13:28:49.200,0,,3595315,,2016-08-15T13:28:49.200,,0,,"<p>I would check first if the file exists in your current directory:</p>

<pre><code>if ( 0 != access( ""./tes02.sh"", F_OK ) )
{ 
    fprintf ( stderr, ""File tes02.sh does NOT exist in curdir\n"" );
    return -1; // return code - normally I return negative codes for errors
}
/* Get a pipe where the output from the scripts comes in */
pipe = popen(""./tes02.sh"", ""r"");
if (pipe == NULL) {  /* check for errors */
    perror(argv[0]); /* report error message */
    return 1;        /* return with exit code indicating error */
}
</code></pre>

<p>(... Rest of program ...) </p>
",,48194617,766
38963958,2,38958849,2016-08-15T22:25:43.593,1,,5382650,,2016-08-15T22:40:43.043,2016-08-15T22:40:43.043,1,,"<p><code>saveConfig</code> is binary data but you need to send the <em>hex</em> representation so:</p>

<pre><code>temp_buf [0] = saveConfig [i]
</code></pre>

<p>will not work.</p>

<p>What you need is something like:</p>

<pre><code>unsigned int
gethex(unsigned int val,int shf)
{

    val &gt;&gt;= shf;
    val &amp;= 0x0F;
    val = ""0123456789ABCDEF""[val];

    return val;
}

temp_buf[0] = gethex(saveConfig[i],4);
temp_buf[1] = gethex(saveConfig[i],0);
</code></pre>
",,48207893,789
38983328,2,38958849,2016-08-16T19:51:31.923,2,,3476780,,2016-08-16T19:51:31.923,,0,,"<p>you said/asked in the comments </p>

<blockquote>
  <p>I am essentially trying to send the following: 0xff 0xaa 0x1b 0x00
  0x00 one byte at a time. Do you think the NULL (byte of zeros) are
  causing the issue? How would I indicate the end of the buffer if I am
  not to use it?</p>
</blockquote>

<p>From your code, however, you are sending a NULL byte in-between each of these data bytes.  <code>temp_buf</code> contains 2 bytes, you are hard-coding the second byte to <code>\0</code> and setting the first byte to the data byte.  Then the <code>sendto(fd, temp_buf, sizeof (temp_buf), 0, (struct sockaddr *)&amp;remaddr, addrlen</code> line sends the contents of this buffer.  If you trapped your network traffic in wireshark, you would see that you are sending <code>0xff 0x00 0xaa 0x00 0x1b 0x00 0x00 0x00 0x00 0x00</code> rather than what you intended to send.</p>

<p>To answer your questions, <code>c</code> strings aside, there is nothing universal about a NULL byte terminator for a buffer.  Valid data bytes can be 0x00 all the time.  If I email someone a black picture, I'll be sending a whole stream of 0x00 bytes.  Your gyroscope must have some kind of protocol that should be described in its documentation.  In my experience, this has been a fixed message length, a start/end sequence of ""magic"" bytes, or even an application-defined header.  In your comments, you indicate the gyroscope simply wants one byte at a time, so there you go, just send it one byte at a time!  I imagine you changed your code to something like the following:</p>

<pre><code>// really no need for temp_buf
for (int i = 0; i &lt; 5 ; i++)
{
  if (sendto(fd, &amp;saveConfig[i] /* or saveConfig+i */, sizeof(char), 0, (struct sockaddr *)&amp;remaddr, addrlen) &lt; 0)
  {
    perror(""sendto"");
    // I'm guessing from your indentation you want this wait inside the if-statement. Note that in the code you posted, the if-statement doesn't have any brackets so this will execute each time through the loop whether there is an error or not
    waitFor (0.05);
  }
  waitFor (0.45);
}
</code></pre>

<p>In general, any time you're dealing with network problems like this, I would strongly recommend using wireshark (or equivalent) to see exactly what you are sending,, it is extremely helpful!</p>
",,48212593,2897
38972359,2,38970132,2016-08-16T10:21:22.980,0,,5271927,,2016-08-16T10:28:27.793,2016-08-16T10:28:27.793,0,,"<p>Updated version can't work in this way - you can't change const class and definitely not outside of any function.</p>

<p>However something like this works (arduino.cc Arduino IDE 1.6.9):</p>

<p><em>libraries/Melodies/Melodies.h:</em></p>

<pre><code>#ifndef Melodies_h
#define Melodies_h

#include ""Arduino.h""
#include &lt;StandardCplusplus.h&gt;
#include &lt;vector&gt;

struct Note {
  int note;
  int duration;

  Note(int a, int b) : note(a), duration(b) {}
};

using Melody = std::vector&lt;Note&gt;;

extern const Melody NONE;
extern const Melody BILL;
extern const Melody COIN;

#endif
</code></pre>

<p><em>libraries/Melodies/Melodies.cpp:</em></p>

<pre><code>#include ""Melodies.h""
#include ""Notes.h""

const Melody NONE;
const Melody BILL;
const Melody COIN = {{NOTE_C4,20},{NOTE_E2,10}}; // whatever
</code></pre>

<p><em>melodies_sketch/melodies_sketch.ino</em></p>

<pre><code>#include &lt;Melodies.h&gt;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(57600);

}

void loop() {
  Serial.println(COIN.size()); // just print size of Melodies vector
  delay(1000);
}
</code></pre>
",,48219079,192
38973318,2,38973171,2016-08-16T11:07:36.540,1,,6451573,,2016-08-16T11:07:36.540,,0,,"<p>Pure C solultion:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
const unsigned char bytes[] = {0x04, 0x55, 0x56, 0xce , 0xdf };
int i;
int sz = sizeof(bytes);
char *result = (char*)malloc(sz*4+1);
char *current = result;

for (i = 0; i &lt; sz; i++)
{
    sprintf(current,""%02x"",bytes[i]);
    current += 2;
}
printf(""Result : %s\n"",result);
free(result);
}
</code></pre>

<p>result:</p>

<pre><code>045556cedf
</code></pre>

<p>You can also change <code>""%02x""</code> format by <code>""%02X""</code> to get uppercase hex-digits.</p>
",,48266329,445
38973323,2,38973171,2016-08-16T11:07:53.440,1,,4062354,,2016-08-16T11:07:53.440,,0,,"<p>Simply convert each digits.</p>

<pre><code>static char digits[] = ""0123456789abcdef""; // characters used to represent digits

static uint16_t index = 0;
static char buffer[1600]; //contains binary data 0x11, 0x22, 0x1, 0xa ...

static char msg[3201]; // 2 digits for each bytes and 1 terminating null-character

for (i=0; i &lt; index; i++)
{
    //Produce a zero in front for single digits. Examples, 0x5 transforms into 05, 0xa transforms into 0a
    msg[i * 2] = digits[((unsigned char)buffer[i] &gt;&gt; 4) &amp; 0xf];

    msg[i * 2 + 1] = digits[(unsigned char)buffer[i] &amp; 0xf]; //msg contains the ASCII equivalent of buffer
}

msg[index * 2] = '\0'; // terminate the string
</code></pre>

<p>Arduino may not be capable to store 4KB data (SRAM on ATmega328P is only 2KB), so reduce the buffer size if they are too much.</p>
",,48278201,408
38973324,2,38973171,2016-08-16T11:07:55.333,1,,28169,,2016-08-16T11:07:55.333,,0,,"<p>You can use something like this:</p>

<pre><code>char * append_hex(char *out, uint8_t value)
{
  static const char digits[] = ""0123456789abcdef"";
  *out++ = digits[value &gt;&gt; 4];
  *out++ = digits[value &amp; 0xf];
  return out;
}
</code></pre>

<p>Then just call that in a loop, passing the returned value from it on each successive call. You can add separators between the calls, if desired.</p>

<p>Remember to 0-terminate the string when done.</p>
",,48300192,136
39019361,2,39016997,2016-08-18T13:21:10.620,2,,4386427,,2016-08-20T04:52:40.087,2016-08-20T04:52:40.087,5,,"<p>A common way to do what you are asking is to ""hunt for framing"" at start up and require N consecutive good packets before accepting any packets. This can be implemented using a state machine with 3 states: HUNT, LOF (loss of frame), SYNC</p>

<p>It could be something like:</p>

<pre><code>#define GOOD_PACKETS_REQUIRED_BEFORE_SYNC 8
int state = HUNT;
int good_count = 0;

Packet GetPacket(void)
{
    unsigned char fb = 0;
    unsigned char sb = 0;

    while (1)
    {
        if (state == HUNT)
        {
            fb = sb;
            sb = GetNextByteFromUART();

            if (IsValidCRC(fb, sb))
            {
                state = LOF;
                good_count = 1;
            }
        }
        else if (state == LOF)
        {
            fb = GetNextByteFromUART();
            sb = GetNextByteFromUART();

            if (IsValidCRC(fb, sb))
            {
                good_count++;
                if (good_count &gt;= GOOD_PACKETS_REQUIRED_BEFORE_SYNC)
                {
                    state = SYNC;
                }
            }
            else
            {
                state = HUNT;
                good_count = 0;
            }
        }
        else if (state == SYNC)
        {
            fb = GetNextByteFromUART();
            sb = GetNextByteFromUART();

            if (IsValidCRC(fb, sb))
            {
                return packet(fb, sb);;
            }

            // SYNC lost! Start a new hunt for correct framing
            state = HUNT;
            good_count = 0;
        }
    } 
}
</code></pre>

<p>You can find several standard communication protocols which use this (or similar) technique, e.g. ATM and E1 (<a href=""https://en.wikipedia.org/wiki/E-carrier"" rel=""nofollow"">https://en.wikipedia.org/wiki/E-carrier</a>). There are different variants of the principle. For instance you may want to go from SYNC to LOF when receiving the first bad packet (decrementing good_count) and then go from LOF to HUNT on the second consecutive bad packet. That would cut down the time it takes to re-frame. The above just shows a very simple variant.</p>

<p>Notice: In real world code you probably can't accept a blocking function like the one above. The above code is only provided to describe the principle. </p>

<p>Whether you need a CRC or can do with a fixed frame-word (e.g. 0xB) depends on your media.</p>
",,48310713,413
39035008,2,39034558,2016-08-19T08:59:43.013,10,,584518,,2016-08-19T08:59:43.013,,0,,"<p>Any half-decent optimizing compiler will remove the whole code inside the if statement, if it can tell at compile-time that the condition always evaluates to false. Similarly, any half-decent compiler would skip the check itself if the condition is always true.</p>

<p>Indeed this is completely equivalent to ""compiler switches"" such as:</p>

<pre><code>#define DEBUG


#ifdef DEBUG
...
#endif
</code></pre>

<p>The ""compiler switch"" syntax with <code>#ifdef</code> is to prefer, as it makes the intent clearer to other C programmers. But that's just a matter of coding style - it will result in the same binary as your original code.</p>
",,48313690,1042
39035324,2,39034558,2016-08-19T09:14:46.887,1,,2466431,,2016-08-19T15:39:43.117,2016-08-19T15:39:43.117,3,,"<p>The code you wrote should never be executed, however, it could be available in the executable.</p>

<p>I would say that the compiler would be required on keeping this code when you would disable optimizations (like adding <code>-O0</code> to Clang and GCC).
In all other cases, I would hope that the compiler would remove the code as this is a very simple optimization with a remarkable code size effect. For instance, GCC eliminates this at <code>-O</code> and higher. (See the <a href=""https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""nofollow"">manual</a>)</p>

<p>Though, there are 2 other ways of writing your code, which will enforce this code to not be included:</p>

<ul>
<li>Preprocessor conditionals</li>
<li>constexpr if</li>
</ul>

<p>By making use of the preprocessor conditionals, you will be able to remove the code before it reaches the actual compiler. It might be a bit intrusive for your indenting, though it will work with all compilers and versions from the C and C++ standards.</p>

<pre><code>#ifdef DEBUG
   { // Optional: Adding extra scope to prevent usage of local variables after the endif
   // Code to eliminate
   }
#endif
</code></pre>

<p>However, if you are using C++17, you could also use <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r1.html"" rel=""nofollow"">constexpr if</a>. This will be less intrusive in your code and although the code in the if-statement has to be syntactic correct, it doesn't have to compile (so not semantically correct).</p>

<p>This can be written as:</p>

<pre><code>if constexpr (DEBUG)
{
    // Code to eliminate
}
</code></pre>
",,48339770,78
39037463,2,39034558,2016-08-19T11:04:54.963,0,,4514970,,2016-08-19T11:04:54.963,,1,,"<p>I do not like answering my own question, because I would not figure it out without your help, guys.</p>

<p>Anyway, first option is to use:</p>

<pre><code>#if DEBUG == true
#endif
</code></pre>

<p>or</p>

<pre><code>#ifdef DEBUG
#endif
</code></pre>

<p>the compiler does not get the code in #if / #ifdef (preprocessor removes it), so if there is a problem in this part of code, no one would know about it if DEBUG is set to <em>false</em> or is not defined at all (thanks @Klaus).</p>

<p>Second option:</p>

<pre><code>#define DEBUG false    

...

if (DEBUG)
{
  ...
}
</code></pre>

<p>Any newer compiler should remove the 'if' block if the condition is false or remove the 'if' statement and leave body if the condition is true.</p>

<p>So I would say it is on programmer which approach suites better the needs of application.</p>

<p>The first approach is better if you need to be sure the code would not be included in binary.</p>

<p>The second approach is better if you want the compiler to check the whole code each time you compile the program.</p>

<p>If you like this answer, vote for it and I will accept it - if no one provides a better one.</p>
",,48353981,777
43378367,2,39139771,2017-04-12T19:46:58.627,1,,6801924,,2017-04-12T19:46:58.627,,1,,"<p>I have updated this code to run under opencv2 and 3 per code snippet below.  Rather than test for opencv3, I just do a try except and use alternate syntax if there is an error.  This works OK but may slow code a little due to continually having to perform check.  This is the price of adapting to code differences.  I also thought of putting in a boolean variable to indicate if code is running under opencv2 or 3 but the code would still need to check the boolean for the proper syntax.  The code below adapts without user intervention.</p>

<pre><code>    differenceimage = cv2.absdiff(grayimage1, grayimage2)
    differenceimage = cv2.blur(differenceimage,(BLUR_SIZE,BLUR_SIZE))
    # Get threshold of difference image based on THRESHOLD_SENSITIVITY variable
    retval, thresholdimage = cv2.threshold( differenceimage, THRESHOLD_SENSITIVITY, 255, cv2.THRESH_BINARY )         
    try:
        thresholdimage, contours, hierarchy = cv2.findContours( thresholdimage, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE )        
    except:       
        contours, hierarchy = cv2.findContours( thresholdimage, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE )         
</code></pre>
",,48366479,116
39181892,2,39173766,2016-08-27T13:52:09.253,1,,6040632,,2016-08-27T14:11:30.097,2016-08-27T14:11:30.097,0,,"<p>I managed to fix it, I had several problems , one of which was that I was adressing the wrong adress to send commands, it has to be 0xa0 instead of 0x80.</p>

<pre><code>#include &lt;bcm2835.h&gt;
#include &lt;stdio.h&gt;



int main(void)
{
    /*
    DATA0LOW    Ch  7:0 ADC channel 0 lower byte    
    DATA0HIGH   Dh  7:0 ADC channel 0 upper byte
    */

    /*
    enum    bcm2835I2CReasonCodes { BCM2835_I2C_REASON_OK = 0x00, BCM2835_I2C_REASON_ERROR_NACK = 0x01, BCM2835_I2C_REASON_ERROR_CLKT = 0x02, BCM2835_I2C_REASON_ERROR_DATA = 0x04 }
    */

      if (!bcm2835_init())
    return 1;
    char uitgelezenTempWaarde[1];           
    int totalTemp[2];
    int error =0;


    bcm2835_i2c_begin();                    // start i2c
    bcm2835_i2c_setSlaveAddress(0x29);      // slave address
    bcm2835_i2c_set_baudrate(1000);         // default

    //----------- turn channels on for measurement ------

    uitgelezenTempWaarde[0] = 0xa0;             
    error = bcm2835_i2c_write(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }

    uitgelezenTempWaarde[0] = 0x03;             
    error = bcm2835_i2c_write(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }

    bcm2835_delay(500);
    error = bcm2835_i2c_read(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }

    //----------- read data ------

        uitgelezenTempWaarde[0] = 0xac;             //DATA0LOW  Ch  7:0 ADC channel 0 lower byte
    error = bcm2835_i2c_write(uitgelezenTempWaarde,1);      
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }
    error = bcm2835_i2c_read(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }

        totalTemp[1]= (int)uitgelezenTempWaarde[0];

        uitgelezenTempWaarde[0] = 0xad;             //DATA0HIGH Dh  7:0 ADC channel 0 upper byte
    error = bcm2835_i2c_write(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }
    error = bcm2835_i2c_read(uitgelezenTempWaarde,1);
    if(error != 0x00)
    {
        printf(""i2c error! : 0x%02X \n"",error);
    }   

        totalTemp[0] = (int)uitgelezenTempWaarde[0]; //

        totalTemp[0] *= 256; //hex conversion for the highest byte so it is seen as a high number (16 bits)
        printf(""The light value is :%d\n"",totalTemp[0]+totalTemp[1]);


    bcm2835_i2c_end();
    bcm2835_close();

    return 0;
}
</code></pre>
",,48373705,378
39194228,2,39182690,2016-08-28T17:57:24.310,0,,4491740,,2016-08-28T17:57:24.310,,0,,"<p>with assumption that you've already installed mosquitto library.
You can call the mqtt class as, </p>

<pre><code>try {

    class myMqtt *qr2sp;
    //int rc;
    mosqpp::lib_init();

    qr2sp = new myMqtt (""qr2sp"", ""pcktatDoor"", ""192.168.178.100"", 1883);

    while (1){

        /// call camera [qrcam()], read QR and send to publish()
        qr2sp-&gt;send_msg(qr2sp-&gt;qrcam().c_str());

        rc = qr2sp-&gt;loop();

        if (rc){
            qr2sp-&gt;reconnect();
}
</code></pre>

<p>and can declare the myMqtt class as, </p>

<pre><code>class myMqtt : public mosqpp::mosquittopp
{
  private:
   const char * host;
   const char * id;
   const char * topic;
   int      port;
   int      keepalive;

   void on_connect(int rc);
   void on_disconnect();
   void on_publish(int mid);

  public:
   myMqtt(const char *id, const char * _topic, const char *host, int port);
   ~myMqtt();
   bool send_msg(const char *message);
   std::string qrcam();

};
</code></pre>

<p>I wrote a little application with openCV and Mqtt using C++ - here [https]://github[.]com/meAbab/qrMqtt</p>

<p>Probably will help you to understand</p>
",,48380286,302
39183958,2,39183873,2016-08-27T17:37:14.287,1,,3983756,,2016-08-27T17:37:14.287,,0,,"<p>Use struct that holds 2 <code>int</code>s and make an array out of it:</p>

<pre><code>struct pair {int a; int b;} arr[100];
void setup() {
  //creating simple [(5,6), (1,2)]
 arr[0].a = 5;
 arr[0].b = 6;

 arr[1].a = 1;
 arr[1].b = 2;
}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>
",,48430316,276
39194192,2,39194157,2016-08-28T17:52:44.130,2,,440558,,2016-08-28T17:52:44.130,2017-05-23T12:00:31.513,2,,"<p>If you <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">read a good beginners book</a> it will tell you that arrays decays to pointers to their first element, which means you can have an array of pointers, and populate it with the pointers to the other arrays.</p>

<p>Something like</p>

<pre><code>const unsigned char* array[] PROGMEM = {
    one,
    two,
    // And so on...
};
</code></pre>
",,48474509,52
39322237,2,39196129,2016-09-04T23:09:44.427,8,,1053944,,2016-09-04T23:09:44.427,,0,,"<p>Ok, finally found my problem. The thing is that the espressif SDK needs some software bits on certain addresses of the flash. What initially happened is that I erased the flash as soon as I got the board, assuming all those binaries would have already been stored in flash. </p>

<p>The next thing I did is that I tried putting all the other binaries, but I was putting them in the wrong addresses, so the software wouldn't work. </p>

<p>Finally, after many many hours of reading forums and reading documentation, I found the correct addresses and it worked. </p>

<p>The addresses are:</p>

<pre><code>0x00000  - boot_v1.6.bin

0x01000  - firmware application (I set the makefile to BOOT=new, APP=1, SIZE_MAP=6)

0x3fc000 - esp_init_data_default.bin

0xfe000  - blank.bin 

0x3fe000 - blank.bin
</code></pre>
",,48503330,158
39234101,2,39208926,2016-08-30T17:55:40.917,0,,3102264,,2016-08-30T18:49:09.227,2016-08-30T18:49:09.227,0,,"<p>In order to point to the sub-object, you can simply use :</p>

<pre><code>JsonObject&amp; tmpJson = root[""ESP_IN_PC_OUT""][""track""][""2""][""mute""];
</code></pre>

<p>Next you can check if this sub-object exists comparing it to <code>JsonObject::invalid</code> like this :</p>

<pre><code>bool success = (tmpJson != JsonObject::invalid());

if(success == true){
    Serial.println((const char*)tmpJson[""type""]);
} else {
    Serial.println(""Address not found"");
}
</code></pre>

<p>If a part of the path doesnot exists, <code>operator[]</code> will return a reference to <code>JsonObject::invalid</code> then accessing to its child will also return a reference to <code>JsonObject::invalid</code>, then it is safe to iterate to unexisting child.</p>
",,48509755,1044
40935222,2,39216824,2016-12-02T15:05:04.093,0,,7169176,,2016-12-02T15:05:04.093,,0,,"<p>try this :</p>

<pre><code>  Serial.print(""element_arr[alpha]: ""); 
  Serial.println(element_arr[alpha]); 
  Serial.print(""Patterns : ""); 
  arrayA = ((element_arr[alpha] -1)/ 10); 
  Serial.println(arrayA); 
  colourA = (element_arr[alpha]) % 10 == 0 ? 9:(element_arr[alpha]) % 10 -1; 
  Serial.print(""ColourA is : ""); 
  Serial.println(colourA); 

  if (arrayA == 0){
     tft.drawBitmap(x + j, y + i, array[0], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==1){
     tft.drawBitmap(x + j, y + i, array[1], 120, 120, pgm_read_word( &amp;colour[colourA] )); 
  }else if (arrayA==2){
    tft.drawBitmap(x + j, y + i, array[2], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==3){
    tft.drawBitmap(x + j, y + i, array[3], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==4){
    tft.drawBitmap(x + j, y + i, array[4], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==5){
    tft.drawBitmap(x + j, y + i, array[5], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==6){
    tft.drawBitmap(x + j, y + i, array[6], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==7){
    tft.drawBitmap(x + j, y + i, array[7], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==8){
    tft.drawBitmap(x + j, y + i, array[8], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }else if (arrayA==9){
    tft.drawBitmap(x + j, y + i, array[9], 120, 120, pgm_read_word( &amp;colour[colourA] ));
  }
</code></pre>
",,48590787,482
39233163,2,39232634,2016-08-30T16:58:27.290,1,,985442,,2016-08-30T16:58:27.290,,0,,"<p>To <em>store 4 digit values</em>,  the easiest and naive way to do it is probably to use an array of size 4. Assuming <code>keypad.getKey</code> returns an int, you could do something like this: <code>int input[4] = {0};</code>.<br>
You will need a cursor variable to know into which slot of the array you need to write when the next key is pressed so you can do some kind of loop like this:</p>

<pre><code>int input[4] = {0};
for (unsigned cursor = 0; cursor &lt; 4; ++cursor) {
    input[cursor] = keypad.getKey();
}
</code></pre>

<p>If you want to use a terminating character (lets say your keyboard have 0-9 and A-F keys, we could say the F is the terminating key), the code changes for something like:</p>

<pre><code>bool checkPassword() {
    static const int expected[4] = {4,8,6,7}; // our password
    int input[4] = {0};

    // Get the next 4 key presses
    for (unsigned cursor = 0; cursor &lt; 4; ++cursor) {
        int key = keypad.getKey();

        // if F is pressed too early, then it fails
        if (key == 15) {
            return false;
        }

        // store the keypress value in our input array
        input[cursor] = key;
    }

    // If the key pressed here isn't F (terminating key), it fails
    if (keypad.getKey() != 15)
        return false;

    // Check if input equals expected
    for (unsigned i = 0; i &lt; 4; ++i) {
        // If it doesn't, it fails
        if (expected[i] != input[i]) {
            return false;
        }
    }

    // If we manage to get here the password is right :)
    return true;
}
</code></pre>

<p>Now you can use the checkPassword function in your main function like this:</p>

<pre><code>int main() {
    while (true) {
        if (checkPassword())
            //unlock the thing
    }
    return 0;
}
</code></pre>

<p><strong>NB</strong>: Using a timer sounds possible too (and can be combined with the terminating character option, they are not exclusive). The way to do this is to set a timer to the duration of your choice and when it ends you reset the cursor variable to 0.</p>

<p>(I never programmed on arduino and don't know about its keypad library but the logic is here, its up to you now)</p>
",,48603627,428
39233236,2,39232634,2016-08-30T17:02:31.557,0,,4142924,,2016-08-30T17:02:31.557,,2,,"<p>In comment OP says a single number is wanted. The typical algorithm is that for each digit entered you multiply an accumulator by 10 and add the digit entered. This assumes that the key entry is ASCII, hence subtracting '0' from it to get a digit <code>0..9</code> instead of <code>'0'..'9'</code>.</p>

<pre><code>#define MAXVAL 9999
int value = 0;                                  // the number accumulator
int keyval;                                     // the key press
int isnum;                                      // set if a digit was entered
do {
    keyval = getkey();                          // input the key
    isnum = (keyval &gt;= '0' &amp;&amp; keyval &lt;= '9');   // is it a digit?
    if(isnum) {                                 // if so...
        value = value * 10 + keyval - '0';      // accumulate the input number
    }
} while(isnum &amp;&amp; value &lt;= MAXVAL);              // until not a digit
</code></pre>

<p>If you have a backspace key, you simply divide the accumulator <code>value</code> by 10.</p>
",,48612546,9957
39267054,2,39249701,2016-09-01T08:58:44.990,1,,6575931,,2017-02-06T18:09:38.513,2017-02-06T18:09:38.513,2,,"<p>You can implement it using a <code>map</code> object, instead of creating a limited array. Use the indexes as <em>keys</em> and the value in that cell as a <em>value</em> (delete it if it equal to zero, and create a new entry in the map if the value of that cell now rises to 1 or more, or decreases to less than zero.</p>

<p>That way you store only the values that are not 0 (<strong>saves memory and allocation considerations</strong>), and you have a theoretically unlimited tape (<strong>more pure implementation</strong>).</p>

<pre><code>operation    map
----------------------------
#code_start  &lt;&gt;
+            &lt;0 : 1&gt;
+            &lt;0 : 2&gt;
-            &lt;0 : 1&gt;
-            &lt;&gt;
-            &lt;0 : -1&gt;
&gt;+           &lt;0 : -1, 1 : 1&gt;
&lt;&lt;-          &lt;-1 : -1, 0 : -1, 1 : 1&gt;
</code></pre>

<p>Maps can be used by including <code>#include &lt;map&gt;</code> and created by <code>std::map&lt;int, int&gt; map_name</code> or whatever types you want to use.</p>

<p>See documentation here: <a href=""http://www.cplusplus.com/reference/map/map/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/map/map/</a></p>
",,48713066,85
39285526,2,39252600,2016-09-02T06:18:58.430,0,,6721865,,2016-09-02T06:18:58.430,,0,,"<p>In dmpmpu.cpp file I have added return </p>

<pre><code>    #ifdef OUTPUT_READABLE_REALACCEL

    mpu.dmpGetQuaternion(&amp;q, fifoBuffer);
    mpu.dmpGetAccel(&amp;aa, fifoBuffer);
    mpu.dmpGetGravity(&amp;gravity, &amp;q);
    mpu.dmpGetLinearAccel(&amp;aaReal, &amp;aa, &amp;gravity);

    return 3;
    #endif

    printf(""\n"");
</code></pre>

<p>For calculating the Accelero value without number count </p>

<pre><code>        accelX = accelerometer-&gt;Loop_Accelx();
    accelY = accelerometer-&gt;Loop_Accely();
    accelZ = accelerometer-&gt;Loop_Accelz();

    for(int i = 0; i&lt;2; i++) //averaging of accelerometer data upto 3 readings
    {
        float accelX1 = accelerometer-&gt;Loop_Accelx(); //storing the Accelx value from DmpMPU6050_Demo class
        float accelY1 = accelerometer-&gt;Loop_Accely(); //storing the Accely value from DmpMPU6050_Demo class
        float accelZ1 = accelerometer-&gt;Loop_Accelz(); //storing the Accelz value from DmpMPU6050_Demo class

        accelX = accelX + accelX1;
        accelY = accelY + accelY1;
        accelZ = accelZ + accelZ1;

        delay(1);
    }

    accelX = accelX/ 0.16384;
    accelY = accelY/ 0.16384;
    accelZ = accelZ/ 0.16384;
</code></pre>

<p>Finally I got the output like </p>

<pre><code>yaw :8.3854  pitch :8.3854  roll :8.3854
Accelx :54.9316  Accely :54.9316  Accelz :54.9316
yaw :-5.5964  pitch :-5.5964  roll :-5.5964
Accelx :42.7246  Accely :36.6211  Accelz :30.5176
yaw :-129.255  pitch :-129.255  roll :-91.2928
Accelx :36.6214  Accely :48.8281  Accelz :30.5176
</code></pre>
",,48754533,1927
39254222,2,39253901,2016-08-31T16:01:20.903,4,,771073,,2016-08-31T16:01:20.903,,2,,"<blockquote>
  <p>I'm not sure exactly what is going on here but it appears like the object is being created on the spot, looking for a default constructor that has no parameters. I don't have such a default constructor, hence the error.</p>
</blockquote>

<p>That is <em>exactly</em> what is going on here.  If you declare a variable like that, it is created immediately.  If the constructor needs arguments - just supply them in the declaration:</p>

<pre><code>   Class o(arg);
</code></pre>

<p>If you haven't got the value of <code>arg</code> yet - just put off declaring the variable until you have.  If you really must put off the creating the object until much later, use:</p>

<pre><code>    std::unique_ptr&lt;Class&gt; o;     // This declare a unique ptr and
                                  // initializes it to empty.

    ....
    o = make_unique&lt;Class&gt;(arg);  // Create the object on the heap,
                                  // and store the pointer in 'o'.
</code></pre>

<p>When <code>o</code> goes out of scope the object will be destroyed (deterministically).</p>

<p>For a beginner, just don't use raw pointers.  They are too easy to get wrong.</p>
",,48795429,198
39266296,2,39262108,2016-09-01T08:20:53.233,0,,5271927,,2016-09-01T09:03:17.607,2016-09-01T09:03:17.607,0,,"<p>I'd go in opposite way by using <code>map</code> to decode <code>IR Code</code> to handler function or by using <code>enum</code>. Something like this:</p>

<pre><code>#include &lt;StandardCplusplus.h&gt;
#include &lt;map&gt;
#include &lt;functional&gt;

void power_key();
void num_key0();
void num_key1();
void num_key2();
void num_key3();
void num_key4();
void num_key5();
void num_key6();
void num_key7();
void num_key8();
void num_key9();
void num_key(int8_t);

typedef void(*handler_t)();

std::map&lt;uint32_t, handler_t&gt; keys;


void setup() {
  keys[16753245UL] = power_key;
  keys[16738455UL] = num_key0;
  keys[16724175UL] = num_key1;
  keys[16718055UL] = num_key2;
  keys[16743045UL] = num_key3;
  keys[16716015UL] = num_key4;
  keys[16726215UL] = num_key5;
  keys[16734885UL] = num_key6;
  keys[16728765UL] = num_key7;
  keys[16730805UL] = num_key8;
  keys[16732845UL] = num_key9;


  Serial.begin(57600);
}

void loop() {

  uint32_t recvd_code = 16753245UL; // literal value, for testing purpose without IR receiver and remote

  auto iter = keys.find(recvd_code); // find received code and execute it
  if (iter != keys.end()) {
    iter-&gt;second();
  } else {
    Serial.print(F(""IR Code ""));
    Serial.print(recvd_code);
    Serial.println(F(""not found""));
  }

  delay(1000);
}

void power_key() {
    Serial.println(F(""Power key pressed""));  
}

void num_key0() { num_key(0); }
void num_key1() { num_key(1); }
void num_key2() { num_key(2); }
void num_key3() { num_key(3); }
void num_key4() { num_key(4); }
void num_key5() { num_key(5); }
void num_key6() { num_key(6); }
void num_key7() { num_key(7); }
void num_key8() { num_key(8); }
void num_key9() { num_key(9); }

void num_key(int8_t num) {
   Serial.print(F(""Numeric key pressed: ""));
   Serial.println(num);
}
</code></pre>

<p>Initializer list somehow didin't work, so initialization must be done in setup and <code>map</code> can't be <code>const</code>.</p>
",,48798902,427
39353766,2,39353702,2016-09-06T16:28:33.563,8,,1816262,,2016-09-06T16:34:34.593,2016-09-06T16:34:34.593,1,,"<p>Behold, the mighty lambda!</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt;
void myFunction(T t) {
    t();
}

int main() {
    myFunction([](){ std::cout &lt;&lt; ""Hi!"" &lt;&lt; std::endl; });
}
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/language/lambda"" rel=""noreferrer"">If you'd like to learn more about them, take a look here</a></p>

<p>To decrypt this a little, here's a breakdown:</p>

<ul>
<li>You have a function that takes another function via a template argument.</li>
<li>That function does nothing other than call its argument.</li>
<li>Inside of main, you call that function with a lambda as its argument.</li>
<li>The lambda can be broken into three parts <code>[]</code> (the capture, don't worry too much about that for now) <code>()</code> the function arguments, in this case there are none) and <code>{ ... }</code> (the body, just like any other function).</li>
</ul>

<p>So the lambda part is just this:</p>

<pre><code>[](){ std::cout &lt;&lt; ""Hi!"" &lt;&lt; std::endl; }
</code></pre>

<p>Here's another example of a lambda that takes an int and returns double its value:</p>

<pre><code>[](int value){ return value * 2; }
</code></pre>
",,48848435,105
39354052,2,39353819,2016-09-06T16:46:01.140,-1,,4621872,,2016-09-06T16:46:01.140,,1,,"<p>the following code should work: </p>

<pre><code>// Example program
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  int8_t matt = 0;
  matt += 1;
  char string[1]; 
  sprintf(string, ""%ld"", matt);
  std::cout &lt;&lt; string &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>it prints ""1"". </p>
",,48905062,281
39355347,2,39354004,2016-09-06T18:12:48.970,0,,5271927,,2016-09-07T19:12:44.743,2016-09-07T19:12:44.743,5,,"<p>The <code>Wire.onReceive()</code> handler is called from <code>ISR</code> handler and therefore all other ISRs are blocked. Including the one counting <code>millis</code> and without it, <code>delay()</code> can't work as it's relying on <code>millis</code>.</p>

<p>For example some <code>volatile</code> variable should be updated by this event and handled in <code>loop()</code>, as <code>ISR</code> handlers must be as short as possible.</p>

<p>For example this one will light if received byte LSB is 1.</p>

<pre><code>#include &lt;Wire.h&gt;

volatile byte recv = 0;

void setup() {
  Wire.begin(0x23);               // join i2c bus with address #8
  Wire.onReceive(receiveEvent); // register event
  //Serial.begin(57600);          // start serial for output
  pinMode(13,OUTPUT);
}

void loop() {
  delay(10);
  digitalWrite(13, recv);
}

void receiveEvent(int howMany) {
  while (Wire.available()) { 
    byte c = Wire.read();
    recv = c &amp; 1; // just last character and its LSB will be used
  }
}
</code></pre>

<p>On the other side is another arduino (as I just don't have RPi) sending incrementing byte sequence. One value every 500ms. This makes the first arduino blink: </p>

<pre><code>#include &lt;Wire.h&gt;

void setup() {
  Serial.begin(57600);
  Wire.begin(); // join i2c bus (address optional for master)
}

byte x = 0;

void loop() {
  Wire.beginTransmission(0x23); // transmit to device #8
  Wire.write(x);              // sends one byte
  byte error = Wire.endTransmission();     // stop transmitting

  Serial.print(""Sent: "");
  Serial.print(x,DEC);
  Serial.print("" "");
  Serial.println(error, DEC);

  x++;
  delay(500);
}
</code></pre>

<p>But basically only 0 or 1 value can be sent to turn off or turn on the led.</p>
",,48931886,1212
39411931,2,39409124,2016-09-09T12:45:24.813,4,,4902709,,2016-09-09T13:04:49.013,2016-09-09T13:04:49.013,1,,"<p>You might need to understand the basic of i2c.</p>

<p><a href=""http://www.ti.com/lit/an/slva704/slva704.pdf"" rel=""nofollow noreferrer"">http://www.ti.com/lit/an/slva704/slva704.pdf</a></p>

<p>3.2 Reading From a Slave On The I2C Bus</p>

<p><a href=""https://i.stack.imgur.com/FHPKk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FHPKk.png"" alt=""enter image description here""></a></p>

<p>to read I2C register, you need to write slave addr, register addr and again slave addr and then read the data from the bus.
but it is done by the driver.
and the slave address is set in fd by ioctl.
but you still need to write register addr.</p>

<p>from your link..</p>

<pre><code>/* Using SMBus commands */
  res = i2c_smbus_read_word_data(file, reg);
  if (res &lt; 0) {
    /* ERROR HANDLING: i2c transaction failed */
  } else {
    /* res contains the read word */
  }
</code></pre>

<p><code>i2c_smbus_read_word_data</code> has <code>reg</code> which contains register addr.
but read() is not.
you need to <code>write(reg)</code> and then can <code>read()</code>.</p>

<p>and you need to only read 1 byte unless using burst mode or something.
it reads 1 byte since <code>size</code> is 1. but meaningless while and p++.</p>

<p>you are writing 3b before reading by <code>command(0x3b, pfd-&gt;fd);</code>.
but it will be like writing</p>

<pre><code>68 &gt; 3B , 68 &gt; 00 , 68 &lt;
</code></pre>

<p>and trying to read. (where > for the read bit, 0, &lt; for 1)
maybe you need just <code>write(pfd-&gt;fd, 0x3b, 1)</code> instead of <code>command</code>.</p>
",,48936208,140
39433399,2,39432682,2016-09-11T06:17:05.647,0,,5271927,,2016-09-12T06:59:09.967,2016-09-12T06:59:09.967,3,,"<p>This error means that function <code>baseevent</code> wasn't declared BEFORE <code>CallBackDef f[] = ...</code>. You need function prototype before it's used, or function definition (= complete function before it's used).</p>

<p>There is also another preprocessor in the Arduino, that takes care of these definitions and it puts them somewhere around sketch beggining. But anything more complex is usually destroyed (generated prototypes are completely wrong), so even legal c++ code can't be compiled. And it sometimes change it's behavior between Arduino versions.</p>

<p>Example CmdCallBack_example_minimum is not working by default in 1.6.9 but, if you add function prototype:</p>

<pre><code>#include &lt;CallBack.h&gt;

// Compile and upload to arduino. Run the serial monitor and type command
// :help;

// Values for initiation of cmd/response interface. 
// After initial boot, id, gid and del are stored in eeprom.
// Change values by command. Make sure each device has a unique id.
String descr=""Command/response test program v0.1"";
String id=""a1"";
String gid=""a"";
int    del=0; //delayed response
byte   echo=1; // command back to host

// ------------------------------------------------
// Function Prototype for add:
void add(String argv[]);

// List of commands defined by keyword, funtion pointer, number of arguments 
// and description used in ""help"" command.
CallBackDef f[] = {
  {(String)""add"",   (FunctionPointer)&amp;add,  (int)2, (String)"":num1:num2""}
};

// initiate command handler: function array, number of functions and intial values
CallBack cmd(f, sizeof(f) / sizeof(*f), id, gid, descr, del, echo);

void setup() {
  Serial.begin(9600);
  cmd.ok(); // say hello
}

void loop() {
  // Don't forget this line. Parse command if serial data is available.
  cmd.cmdCheck();

  // Put code here. Use timers instead of delay if possible as not to disrupt
  // command/response interaction with host


}

//   --------- command initiated callback functions below ---------
// callback functions all need to be defined void and with String argv
// argument list. The command parser will validate the number of input
// parameters but any additional validation has to be perfomed by each
// callback function. As the argument list is passed as strings, type
// casting to other types is the responsibility of the function.

void add(String argv[]) {
  int a = cmd.stoi(argv[0]);
  int b = cmd.stoi(argv[1]);
  cmd.respond(String(a + b));
}
</code></pre>

<p>Without explicit function prototype Arduino preprocessor takes care of it, but it gets inserted AFTER the line where it is used. So there is still error.</p>

<p>Your version however is broken even after that fix (some incorrect parameter type in CallBack cmd...)</p>
",,48942615,1011
40487473,2,39443604,2016-11-08T12:52:58.307,0,,,user5902391,2016-11-08T12:52:58.307,,0,,"<p>The gyro returns a value indicating the number of degrees positive or negative the robot deviated from its initial heading. As long as the robot continues to go straight, the heading will be zero.
For ex.</p>

<pre><code>    class GyroSample : public SampleRobot
{
 RobotDrive myRobot; // robot drive system
 AnalogGyro gyro;
 static const float kP = 0.03;

public:
 GyroSample():
  myRobot(1, 2), // initialize the sensors in initilization list
  gyro(1)
 {
  myRobot.SetExpiration(0.1);
 }

 void Autonomous()
 {
  gyro.Reset();
  while (IsAutonomous())
  {
   float angle = gyro.GetAngle(); // get heading
   myRobot.Drive(-1.0, -angle * kP); // turn to correct heading
   Wait(0.004);
  }
  myRobot.Drive(0.0, 0.0); // stop robot
 }
};
</code></pre>
",,48961265,337
39781492,2,39457303,2016-09-29T23:23:04.477,1,,6823776,,2016-09-29T23:23:04.477,,0,,"<p>Thankfully I was able to find a solution.</p>

<p>The working code:</p>

<pre><code>void loop()
{
        if (vw_get_message(message, &amp;messageLength))
    {
        for (int i = 0; i &lt; messageLength; i++)
        {
             const char *p = reinterpret_cast&lt;const char*&gt;(message);
             if(p[0] == 'Y')
             {
                  Serial.print("" - Yes"");
                  break;
             }
             else if(p[0] == 'N')
             {
                  Serial.print("" - No"");
                  break;
             }
        }
        Serial.println();
    }
}
</code></pre>

<p>The point of <code>const char *p = reinterpret_cast&lt;const char*&gt;(message);</code> was to turn <code>message</code>, which is a byte, into a char. Yes <code>p</code> is a pointer, but it's pointing to a char, so with that, I can get the data in the char that <code>p</code> is pointing to by simply doing <strong>p[#]</strong>. A simple if statement can now be made</p>

<pre><code>if(p[0] == 'M')
{
     ...
} 
</code></pre>
",,48970911,227
39503439,2,39503414,2016-09-15T05:02:30.910,2,,10897,,2016-09-15T05:02:30.910,2017-05-23T10:33:51.997,0,,"<p>The trick is to make a list of pins and then pick an entry from the list at random</p>

<pre><code>int pins[]={3,5,6,11,10,9}

int choice = rnd() //in range 0-5 

pin = pins[choice]
</code></pre>

<p>see <a href=""https://stackoverflow.com/questions/5008804/generating-random-integer-from-a-range"">Generating random integer from a range</a> to get number in range</p>
",,48974656,82
39503503,2,39503414,2016-09-15T05:08:10.597,3,,14860,,2016-09-15T07:09:50.033,2016-09-15T07:09:50.033,0,,"<p>Well, there are at least two way to do it.</p>

<p>The first (and probably best) way is to load those values into an array of size six, generate a number in the range zero through five and get the value from that position in the array.</p>

<p>In other words, psedo-code such as:</p>

<pre><code>values = [3, 5, 6, 9, 10, 11]
num = values[randomInclusive(0..5)]
</code></pre>

<p>In terms of actually implementing that pseudo-code, I'd look at something like:</p>

<pre><code>int getRandomPwmPin() {
    static const int candidate[] = {3, 5, 6, 9, 10, 11};
    static const int count = sizeof(candidate) / sizeof(*candidate);
    return candidate[TrueRandom.random(0, count)];
}
</code></pre>

<hr>

<p>There's also the naive way of doing it, which is to generate numbers in a range and simply throw away those that don't meet your specification (i.e., go back and get another one). This is actually an inferior method as it may take longer to get a suitable number under some circumstances. Technically, it could even take an infinitely<sup>(a)</sup> long time if suitable values don't appear.</p>

<p>This would be along the lines of (psedo-code):</p>

<pre><code>num = -1  // force entry into loop
while num is not one of 3, 5, 6, 9, 10, 11:
    num = randomInclusive(3..11)
</code></pre>

<p>which becomes:</p>

<pre><code>int getRandomPwmPin() {
    int value;
    do {
        value = TrueRandom.random(3, 12);
    } while ((value == 4) || (value == 7) || (value == 8));
    return value;
}
</code></pre>

<p>As stated, the former solution is probably the best one. I include the latter only for informational purposes.</p>

<hr>

<p><sup>(a)</sup> Yes, I know. Over an long enough time frame, statistics pretty much guarantees you'll get a useful value. Stop being a pedant about my hyperbole :-)</p>
",,49104206,50
39555757,2,39555167,2016-09-18T08:46:34.253,0,,173388,,2016-09-18T08:46:34.253,,0,,"<p>Serial.read() only returns a single byte, so you're not going to get ""on"". You'll get ""o"" the first time, and if you read it again, you'll get ""n."" </p>

<p>If you follow the ""on"" with a ""\n"" (new line character), you can do something like this:</p>

<pre><code>char command[3];
if (Serial.available() &gt; 0) {
   int bytesRead = Serial.readBytesUntil('\n', command, 2);
   command[2] = '\0';
   if strcmp(command, ""on"") == 0) {
      servoMotor.write(40);
   }
}
</code></pre>
",,49119236,301
39598422,2,39598039,2016-09-20T15:42:20.440,2,,6849246,,2016-09-20T15:47:56.900,2016-09-20T15:47:56.900,1,,"<p>This is because of where you place your </p>

<p><code>n++;</code></p>

<p>In your code, it is placed inside the innermost scope.</p>

<p>Since n=10 at the start, n%2!=0 is false, and all the contents within that scope, including n++; is never called. Hence, n is never incremented, since n%2!=0 is repeatedly false. Hence, the code never reaches the printing of total, since it is stuck in the infinite while loop.</p>

<p>One possible correction to the code could be as follows below. And the answer will be 21. However, since you are already using the while loop, you can probably put it in the setup() method, otherwise the Arduino will just keep printing 21 infinitely.</p>

<pre><code>int n = 10;
int total = 0;

void setup() {
    Serial.begin(9600);
}

void loop() {
 while (n &lt; 100) {
  if (n % 2 != 0) {
   if (n % 3 != 0) {
    if (n % 4 != 0) {
     if (n % 5 != 0){
      if (n % 6 != 0) {
       if (n % 7 != 0) {
        if (n % 8 != 0) {
         if (n % 9 != 0) {
          total++;
         }
        }
       }
      }
     }
    }
   }
  }
  n++;
 }
 Serial.println(total);
}
</code></pre>

<p><br /><br />
<strong>Starting with your Objective / Purpose..</strong></p>

<p>If you are finding numbers between 10 and 100 that cannot be divided by 2 to 9, a possible way to code could be:</p>

<pre><code>int n = 10;
int total = 0;

void setup() {
 Serial.begin(9600);
 while (n &lt; 100) {
  if (n % 2 != 0) {
   if (n % 3 != 0) {
    if (n % 4 != 0) {
     if (n % 5 != 0){
      if (n % 6 != 0) {
       if (n % 7 != 0) {
        if (n % 8 != 0) {
         if (n % 9 != 0) {
          Serial.println(n);
          total++;
         }
        }
       }
      }
     }
    }
   }
  }
  n++;
 }
 Serial.print(""Total: "");
 Serial.println(total);
}

void loop() {
 //Serial.println(total);
}
</code></pre>

<p>Personally, I prefer fewer nested IFs</p>

<pre><code>int n = 10;
int total = 0;
bool divisible = false;
int i;

void setup() {
 Serial.begin(9600);
 while (n &lt; 100) {
  divisible = false;
  for (i=2; i&lt;=9; i+=1){
    if (n%i==0){
      divisible = true;
    }
  }
  if (divisible == false){
    Serial.println(n);
    total++;
  }
  n++;
 }
 Serial.print(""Total: "");
 Serial.println(total);
}

void loop() {
 //Serial.println(total);
}
</code></pre>

<p>And you would get the output:</p>

<blockquote><pre>11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
Total: 21
</pre></blockquote>

<p>Hope it helps.</p>
",,49121119,65
39598424,2,39598039,2016-09-20T15:42:22.240,0,,2347483,,2016-09-20T15:42:22.240,,0,,"<p>Your code's structure is wrong. You need to increment <code>n</code> every time through the loop.</p>

<p>This should work:</p>

<pre><code>void loop() {
  while (n &lt; 100) {
    if (n % 2 != 0) {
      if (n % 3 != 0) {
        if (n % 5 != 0){
          if (n % 7 != 0) {
            total++;
          }
        }
      }
    }

    n++; /* Increment needs to be at the base of the loop! */
  }

  Serial.println(total);
}
</code></pre>
",,49134190,718
39816861,2,39659117,2016-10-02T12:10:54.433,1,,23118,,2016-10-02T12:10:54.433,2017-05-23T12:33:25.477,0,,"<p>This library code seems better than the worst I have seen at first glance, but it still have some issues. The most severe is its Final result code handling.</p>

<p>The <code>sim900_check_with_cmd</code> function is conceptually almost there, however only checking for <code>OK</code> is in no way acceptable. It should check for <strong>every single possible</strong> final result code the modem might send.
From your output examples you have the following final result codes</p>

<ul>
<li>OK</li>
<li>ERROR</li>
<li>NO CARRIER</li>
<li>NO ANSWER</li>
</ul>

<p>but there exists a few more as well. You can look at the code for <a href=""https://sourceforge.net/p/atinout/code/ci/master/tree/atinout.c"" rel=""nofollow noreferrer"">atinout</a> for an example of a <code>is_final_result_code</code> function (you can also compare to <code>isFinalResponseError</code> and <code>isFinalResponseSuccess</code><sup>1</sup> in <a href=""https://github.com/aferre/u300-ril/blob/master/atchannel.c"" rel=""nofollow noreferrer"">ST-Ericsson's U300 RIL</a>).</p>

<p>The unconditional <code>return true;</code> at the end of <code>GPRS::callUp</code> is an error, but it might be deliberate due to lack of ideas for implementing a better API so that the calling client could check the intermediate result codes. But that is such a wrong way to do it.
The library really should do all the stateful command line invocation and final result code parsing with no exceptions. Just doing parts of that in the library and leaving some of it up to the client is just bad design.</p>

<p>When clients want to inspect or act on intermediate result codes or information text that comes between the command line and the final result code, the correct way to do it is to let the library ""deframe"" everything it receives from the modem into individual complete lines, and for everything that is not a final result code provide this to the client through a callback function.</p>

<p>The following is from an unfinished update to my atinout program:</p>

<pre><code>bool send_commandline(
        const char *cmdline,
        const char *prefix,
        void (*handler)(const char *response_line, void *ptr),
        void *ptr,
        FILE *modem)
{
        int res;
        char response_line[1024];

        DEBUG(DEBUG_MODEM_WRITE, ""&gt;%s\n"", cmdline);
        res = fputs(cmdline, modem);
        if (res &lt; 0) {
                error(ERR ""failed to send '%s' to modem (res = %d)"", cmdline, res);
                return false;
        }

        /*
         * Adding a tiny delay here to avoid losing input data which
         * sometimes happens when immediately jumping into reading
         * responses from the modem.
         */
        sleep_milliseconds(200);

        do {
                const char *line;
                line = fgets(response_line, (int)sizeof(response_line), modem);
                if (line == NULL) {
                        error(ERR ""EOF from modem"");
                        return false;
                }
                DEBUG(DEBUG_MODEM_READ, ""&lt;%s\n"", line);
                if (prefix[0] == '\0') {
                        handler(response_line, ptr);
                } else if (STARTS_WITH(response_line, prefix)) {
                        handler(response_line + strlen(prefix) + strlen("" ""), ptr);
                }
        } while (! is_final_result(response_line));

        return strcmp(response_line, ""OK\r\n"") == 0;
}
</code></pre>

<p>You can use that as a basis for implementing proper handling. If you want to
get error responses out of the function, add an additional callback argument and change to</p>

<pre><code>        success = strcmp(response_line, ""OK\r\n"") == 0;
        if (!success) {
                error_handler(response_line, ptr);
        }
        return success;
</code></pre>

<hr>

<p>Tip: Read all of chapter 5 in the <a href=""http://www.itu.int/rec/T-REC-V.250-200307-I/en"" rel=""nofollow noreferrer"">V.250</a> specification, it will teach you almost everything you need to know about command lines, result codes and response handling. Like for instance that a command line should also be terminated with <code>\r</code> <a href=""https://stackoverflow.com/a/21503919/23118"">only</a>, not <code>\r\n</code>-</p>

<hr>

<p><sup>1</sup> Note that <code>CONNECT</code> is not a final result code, it is an intermediate result code, so the name isFinalResponseSuccess is strictly speaking not 100% correct.</p>
",,49191443,146
39665427,2,39661055,2016-09-23T16:23:05.033,1,,5271927,,2016-09-25T19:48:51.950,2016-09-25T19:48:51.950,21,,"<p>There are many issues, like:</p>

<pre><code>leds[0] = CRGB(36, 0, 0);
</code></pre>

<p>This means:</p>

<ul>
<li>copy parameters to the stack</li>
<li>call CRBG function</li>
<li>create local LED object</li>
<li>setR on that local object by calling constraint </li>
<li>setG ...</li>
<li>setB ...</li>
<li>return a copy of local object</li>
<li>copy assigment operator on led[0]</li>
</ul>

<p>Also using 8b wide variables for 12b colors is little bit redundant.
So for the start I would recommend something like that:</p>

<pre><code>class LED {
  public:
    uint16_t rgb;

    LED(uint8_t r=0, uint8_t g=0, uint8_t b=0) {
      setRGB(r,g,b);
    }

    void setRGB(uint8_t r=0, uint8_t g=0, uint8_t b=0) {
      r = r &gt;&gt; 4; 
      g = g&amp;0xF0;
      rgb = b&amp;0xF0;
      rgb = (rgb&lt;&lt;4) | g | r;
    }

    bool getBit(uint16_t mask) {
      return rgb &amp; mask;
    }
};

LED leds[100];

void setup() {
  pinMode(2, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(3, OUTPUT);
  pinMode(5, OUTPUT);
  Serial.begin(250000);
}

void loop() {
  leds[0].setRGB(36, 0, 0);
  leds[1].setRGB(103, 0, 0);
  leds[2].setRGB(170, 0, 0);
  leds[3].setRGB(255, 0, 0);
  leds[4].setRGB(255, 0, 0);
  leds[5].setRGB(170, 0, 0);
  leds[6].setRGB(103, 0, 0);
  leds[7].setRGB(36, 0, 0);
  leds[8].setRGB(0, 0, 0);
  leds[9].setRGB(0, 0, 0);
  leds[10].setRGB(36, 0, 0);
  leds[11].setRGB(103, 0, 0);
  leds[12].setRGB(170, 0, 0);
  leds[13].setRGB(255, 0, 0);
  leds[14].setRGB(255, 0, 0);
  leds[15].setRGB(170, 0, 0);
  leds[16].setRGB(103, 0, 0);
  leds[17].setRGB(36, 0, 0);
  leds[18].setRGB(0, 0, 0);
  leds[19].setRGB(0, 0, 0);
  leds[20].setRGB(36, 0, 0);
  leds[21].setRGB(103, 0, 0);
  leds[22].setRGB(170, 0, 0);
  leds[23].setRGB(255, 0, 0);
  leds[24].setRGB(255, 0, 0);
  leds[25].setRGB(170, 0, 0);
  leds[26].setRGB(103, 0, 0);
  leds[27].setRGB(36, 0, 0);
  leds[28].setRGB(0, 0, 0);
  leds[29].setRGB(0, 0, 0);
  leds[30].setRGB(36, 0, 0);
  leds[31].setRGB(103, 0, 0);
  leds[32].setRGB(170, 0, 0);
  leds[33].setRGB(255, 0, 0);
  leds[34].setRGB(255, 0, 0);
  leds[35].setRGB(170, 0, 0);
  leds[36].setRGB(103, 0, 0);
  leds[37].setRGB(36, 0, 0);
  leds[38].setRGB(0, 0, 0);
  leds[39].setRGB(0, 0, 0);
  leds[40].setRGB(36, 0, 0);
  leds[41].setRGB(103, 0, 0);
  leds[42].setRGB(170, 0, 0);
  leds[43].setRGB(255, 0, 0);
  leds[44].setRGB(255, 0, 0);
  leds[45].setRGB(170, 0, 0);
  leds[46].setRGB(103, 0, 0);
  leds[47].setRGB(36, 0, 0);
  leds[48].setRGB(0, 0, 0);
  leds[49].setRGB(0, 0, 0);
  leds[50].setRGB(36, 0, 0);
  leds[51].setRGB(103, 0, 0);
  leds[52].setRGB(170, 0, 0);
  leds[53].setRGB(255, 0, 0);
  leds[54].setRGB(255, 0, 0);
  leds[55].setRGB(170, 0, 0);
  leds[56].setRGB(103, 0, 0);
  leds[57].setRGB(36, 0, 0);
  leds[58].setRGB(0, 0, 0);
  leds[59].setRGB(0, 0, 0);
  leds[60].setRGB(36, 0, 0);
  leds[61].setRGB(103, 0, 0);
  leds[62].setRGB(170, 0, 0);
  leds[63].setRGB(255, 0, 0);
  leds[64].setRGB(255, 0, 0);
  leds[65].setRGB(170, 0, 0);
  leds[66].setRGB(103, 0, 0);
  leds[67].setRGB(36, 0, 0);
  leds[68].setRGB(0, 0, 0);
  leds[69].setRGB(0, 0, 0);
  leds[70].setRGB(36, 0, 0);
  leds[71].setRGB(103, 0, 0);
  leds[72].setRGB(170, 0, 0);
  leds[73].setRGB(255, 0, 0);
  leds[74].setRGB(255, 0, 0);
  leds[75].setRGB(170, 0, 0);
  leds[76].setRGB(103, 0, 0);
  leds[77].setRGB(36, 0, 0);
  leds[78].setRGB(0, 0, 0);
  leds[79].setRGB(0, 0, 0);
  leds[80].setRGB(36, 0, 0);
  leds[81].setRGB(103, 0, 0);
  leds[82].setRGB(170, 0, 0);
  leds[83].setRGB(255, 0, 0);
  leds[84].setRGB(255, 0, 0);
  leds[85].setRGB(170, 0, 0);
  leds[86].setRGB(103, 0, 0);
  leds[87].setRGB(36, 0, 0);
  leds[88].setRGB(0, 0, 0);
  leds[89].setRGB(0, 0, 0);
  leds[90].setRGB(36, 0, 0);
  leds[91].setRGB(103, 0, 0);
  leds[92].setRGB(170, 0, 0);
  leds[93].setRGB(255, 0, 0);
  leds[94].setRGB(255, 0, 0);
  leds[95].setRGB(170, 0, 0);
  leds[96].setRGB(103, 0, 0);
  leds[97].setRGB(36, 0, 0);
  leds[98].setRGB(0, 0, 0);
  leds[99].setRGB(255, 255, 255);


// show context
  for (uint16_t bitmask = 1U; bitmask &lt; 0x400; bitmask &lt;&lt;= 1) {
    for (LED &amp; led : leds) {
      Serial.print(led.getBit(bitmask), HEX);
      Serial.print("" "");
    }
    Serial.println();
  }

  do_cycle();
}

void do_cycle() {
  uint16_t bitmask_r = 0;  
  uint16_t bitmask_g = 0;  
  uint16_t bitmask_b = 0;  

  for (byte mag = 1; mag &lt; 16; ++mag) { // magnitude
    for (byte row = 0; row &lt; 10; ++row) { // mistake #2
      //uint32_t us = micros();

      if ((mag &amp; (mag-1)) == 0) { // Is it power of two? Change bitmask
        bitmask_r = mag;
        bitmask_g = bitmask_r &lt;&lt; 4;
        bitmask_b = bitmask_g &lt;&lt; 4;
      }

      // shift out init:
      PORTD &amp;= ~_BV(PD3); //Data aus
      PORTD &amp;= ~_BV(PD4); //Clock aus

      for (int8_t cnt = 9; cnt &gt;= 0; --cnt) {
        //Serial.print(cnt==row?1:0);
        shift1bit(cnt==row); // mistake #1
      }
      for (int8_t col = 9; col &gt;= 0; --col) {
        //Serial.print(leds[row*10+col].getBit(bitmask_b));
        shift1bit(leds[row*10+col].getBit(bitmask_b));
      }
      for (int8_t col = 9; col &gt;= 0; --col) {
        //Serial.print(leds[row*10+col].getBit(bitmask_g));
        shift1bit(leds[row*10+col].getBit(bitmask_g));
      }
      for (int8_t col = 9; col &gt;= 0; --col) {
        //Serial.print(leds[row*10+col].getBit(bitmask_r));
        shift1bit(leds[row*10+col].getBit(bitmask_r));
      }
      PORTD |=  _BV(PD2); // LatchPin
      PORTD &amp;= ~_BV(PD2); // disable LatchPin

      //Serial.println(micros()-us);
      delayMicroseconds(50);
    }
  }
}

inline void shift1bit (bool b) {
  // set data:
  if (b) {
    PORTD |= _BV(PD3);
  } else {
    PORTD &amp;= ~_BV(PD3);
  }
  // clock pulse:
  PORTD |=  _BV(PD4);
  PORTD &amp;= ~_BV(PD4);
}
</code></pre>

<hr>

<p>And you can consider:</p>

<ul>
<li>Using HW <code>SPI</code></li>
<li>Using <code>/MR</code> input to clear all registers by one pulse (much faster than shiftOut)</li>
<li>Using Johnson counter (<code>4017</code>) for row drivers and save one shift register (also buffer fits into the one <code>uint32_t</code>). With previous you can use <code>Q7S</code> ouput and MSB set to logic 1 to update counter.</li>
</ul>
",,49204265,50
39663891,2,39663789,2016-09-23T14:59:48.790,1,,6869585,,2016-09-23T15:08:32.527,2016-09-23T15:08:32.527,2,,"<pre><code>struct GPIO_Attr { uint8_t pinIndex, pinNumber; };
struct GPIO_Attr gpio_outputs[] = { {GPIO1}, {GPIO1} }; // Extra '{}' is necessary to initialize GPIO_Attr fields
for (i=0;i&lt;sizeof(gpio_outputs)/sizeof(gpio_outputs[0]);i++){
    Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, gpio_outputs[i].pinIndex, gpio_outputs[i].pinNumber);
}
</code></pre>
",,49244535,1564
39667998,2,39666469,2016-09-23T19:11:43.043,0,,134554,,2016-09-23T19:24:40.140,2016-09-23T19:24:40.140,0,,"<p>The compiler is complaining about the line</p>

<pre><code>recievedNumbers = getACOfNumber(256);
</code></pre>

<p>You cannot use the <code>=</code> operator to assign the contents of an array; an array expression may not be the target of an assignment operation.  Also, the result of <code>getACOfNumber</code> is an <code>int *</code>, which is not the same type as <code>int [100]</code>.  </p>

<p>This <em>could</em> work if you declared <code>receivedNumbers</code> as</p>

<pre><code>int *recievedNumbers;
</code></pre>

<p>In that case you're assigning a pointer to a pointer, which should work.  </p>

<p>But, you have another problem:</p>

<pre><code>int* getACOfNumber(int theNumber) {
  bool done = false;
  int i = 0;
  int theArray[100];
  ...
  return theArray;
}
</code></pre>

<p>This will not do what you expect.  Once the <code>getACOfNumber</code> function exits, <code>theArray</code> <em>no longer exists</em> - the pointer you return is no longer <em>valid</em>.  </p>

<p>IMO, your best bet is to pass the array as a parameter to <code>getACOfNumber</code> and update it directly in the function:</p>

<pre><code>getACOfNumber( 256, receivedNumbers, MAXSIZE );
...
void getACOfNumber( int number, int *theArray, size_t max )
{
  bool done = false;
  size_t i = 0;
  while ( i &lt; max &amp;&amp; !done )
  {
    ... // use existing code
  }
}
</code></pre>
",,49246446,889
39683791,2,39683371,2016-09-25T05:43:04.697,2,,620908,,2016-09-25T05:43:04.697,,0,,"<pre><code>String intString = """";
int intStart = 0;
for (int i = 0; i &lt; msg.length(); i++) {
    while (intStart != 2) {
        if (intStart == 0) {
            if (isdigit(msg[i])){
                        intString += msg[i];
                        intStart = 1;
                 }
        }
        // previous int, next is still int
        if (intStart == 1) {
            if (isdigit(msg[i])) {
                        intString += msg[i];
                        intStart = 1;
                 }
        }
        // previous int, next is not int
        else if ( isdigit(msg[i]) ) {
                             intStart = 2;
        }
    } 
}
</code></pre>

<p><a href=""https://en.wikipedia.org/wiki/Rubber_duck_debugging"" rel=""nofollow"">""Rubber duck debugging""</a>:</p>

<p>Let's assume the first char of the msg is a digit:</p>

<ol>
<li>set <code>intStart</code> to <code>0</code></li>
<li>take the first char of the msg</li>
<li>while <code>intStart</code> is not yet <code>2</code></li>
<li><code></code> if <code>intStart</code> is 0 (it is, we haven't adjusted it) and the first char of the msg is digit (we assumed it is), then append the first char to <code>intString</code> and make <code>intStart = 1</code></li>
<li><code></code> if <code>intStart == 1</code> (it is, we set it at the prev step) and the first char of the msg is digit (it is still the first, <code>i</code> didn't change), then append the first char to <code>intString</code> (great, now I have it twice) and set <code>intStart=1</code> (hey, <code>intStart</code> didn't change). Else... well, we can ignore else, we are in the good conditions for <code>then</code></li>
<li>so back to the step 3, with the <code>intStart==1</code> and <code>i</code> still 0 and the first char of the msg still a digit.</li>
</ol>

<p><strong>Should I continue or are you able to do it?</strong></p>

<p>In essence, with the first char of the msg a digit, you'll never get out from <code>while (intStart != 2)</code> until you run out of heap-space due to <code>intString</code> growing by repeating the same fisrt char all over.</p>

<p>Is that what you want?</p>

<p><strong>Is it so hard to explain this to your rubber duck before asking SO?</strong><br>(yes, I understand, Arduino doesn't have a debugger, but you still can use Serial.print)</p>
",,49254838,1634
39683926,2,39683371,2016-09-25T06:03:35.380,1,,620908,,2016-09-25T07:03:20.547,2020-06-20T09:12:55.060,4,,"<p>[Update on the comments]</p>
<blockquote>
<p>Sorry if I was unclear, but it doesn't necessarily start with an integer, the integer could be in the middle of the char buffer.</p>
<p>The first sequence of digits in the char buffer of any length (really doesn't have to be restricted to max 3-digit, only if it makes it easier)</p>
</blockquote>
<p>So, before stating to collect, we just need to position ourselves on the first digit of the string buffer</p>
<pre><code>int startScan=0;
// no body for the cycle, everything works just from 
// the exit condition and increment
for(
  ; 
  startScan &lt; msg.length() &amp;&amp; ! isdigit(msg[i]); // as long as it's not a digit
  startScan++
);

// from this position, start collecting for as long as we have digits
int intValue=0;
String intString;
for(; startScan &lt; msg.length() &amp;&amp; isdigit(msg[startScan]); startScan++) {
  intString += msg[startScan]; // take it inside the string

  // careful with this one, it may overflow if too many digits
  intValue = intValue*10 + (msg[startScan]-'0');
}
// if we reached here with an empty intString, we didn't find any digits
</code></pre>
<p>If you don't need the <code>intString</code>, just the <code>intValue</code>, don;t use the <code>intString</code> - at most a <code>bool hasDigits</code> to init to <code>false</code> and set to <code>true</code> in place of <code>intString += msg[startScan];</code> (to act as a signal for the 'no digits encountered' case).</p>
<p>If you don't need the <code>intValue</code>, just wipe out from the code anithing that uses it.</p>
<hr />
<p>So, if my understating is correct, you have the following problem:</p>
<blockquote>
<p>I have a <code>String</code> message which starts by <em>at most</em> 3 decimal digits and ends possibly with other info I don't need. I want that 'at most 3 digits' prefix transformed in an integer for me to use further</p>
</blockquote>
<p>If this is you problem, then try this:</p>
<pre><code>int intValue=0;
String intString;
int maxLookInto=(msg.length() &gt; 3 ? 3 : msg.length()); // at most 3 digits
for(int i=0; i&lt;maxLookInto &amp;&amp; isdigit(msg[i]); i++) {
  // if we got here, we know msg[i] is still a digit, otherwise
  // we get out of cycle ealier
  intString += msg[i]; // take it inside the string
  intValue = intValue*10 + (msg[i]-'0'); // transforming in base 10 in an int
}
// Do what you like with either intString (textual representation of the
//  at-most-3-digits or with the same value converted already to a number
//  in intValue
</code></pre>
<p>If Arduino doesn't have the <code>isdigit</code> function available, you can implement your own like</p>
<pre><code>int isdigit(char c) {
  // we are using ASCII encoding for characters, aren't we?
  return (c&gt;='0' &amp;&amp; c &lt;='9');
}
</code></pre>
",,49277375,149
39687345,2,39685625,2016-09-25T13:28:06.157,0,,4627080,,2016-09-25T13:28:06.157,,0,,"<p>To copy a string from flash memory to RAM</p>

<pre><code>#include&lt;avr/pgmspace.h&gt;
const byte Update_1[5]  PROGMEM = {0x01, 0xB2, 0x02, 0xFF, 0xFF};
byte buffer2[5];
setup {
  memcpy_P (buffer2, &amp;(Update_1),5);
}
</code></pre>
",,49433454,1101
39686782,2,39686632,2016-09-25T12:25:23.833,0,,4443449,,2016-09-25T12:25:23.833,,4,,"<p>Just initialize your array right after your declaration:</p>

<pre><code>int myarray[128];//128 would be the max
for (i=0; i&lt;128; i++)
    myarray[i] = -1;
</code></pre>

<p>This would fill the whole array with -1 and then you could start filling your array with your custom data, having blank cell filled with -1.</p>

<p>A better solution would be creating functions to handle a dynamic array, for instance:</p>

<pre><code>int test_array[128];
int curr_size = 0;
void pushData(int* myarray, int val){
    myarray[curr_size] =  val;
    curr_size++;
}

int popData(int* myarray){
    curr_size--;
    return myarray[curr_size];
}

//and then you could call these functions like this:

pushData(test_array, 3);

int somevar = popData(test_array);
</code></pre>

<p>Of course this is just an example and you shouldn't use it as is, since this would only work for handling 1 array.</p>
",,49433775,738
39709549,2,39693302,2016-09-26T18:09:08.203,1,,3082873,,2016-09-26T18:09:08.203,,3,,"<p>If you want an implementation example use steps below:</p>

<ul>
<li><p>Get DHT library from <a href=""https://github.com/adafruit/DHT-sensor-library/"" rel=""nofollow"">https://github.com/adafruit/DHT-sensor-library/</a></p></li>
<li><p>Use the code snippet below, but do not forget to set your pins :</p>

<pre><code>#include ""DHT.h""
#define DHT11PIN 2
#define DHT22PIN 3

DHT dht11(DHT11PIN, DHT11 );
DHT dht22(DHT22PIN, DHT22 );

void setup() {
  Serial.begin(9600);
  Serial.println(""DHTxx test!"");

  dht11.begin();
  dht22.begin();
}

void loop() {
  delay(2000);
  float h11 = dht11.readHumidity();
  float t11 = dht11.readTemperature();
  float f11 = dht11.readTemperature(true);

  float h22 = dht22.readHumidity();
  float t22 = dht22.readTemperature();
  float f22 = dht22.readTemperature(true);
  //do print them..
}
</code></pre></li>
</ul>
",,49441368,369
39723347,2,39719768,2016-09-27T11:22:00.237,1,,6105043,,2016-09-27T11:22:00.237,,0,,"<p>A server should always <em>bind</em> to its own interface (either its local IP address or <code>0.0.0.0</code> for all IPv4 interfaces or <code>0::0</code> for both IPv4 and IPv6).</p>

<p>A client should always <em>connect</em> to the remote IP address.</p>

<p>Since you want your PC to be a server pulling messages from the Raspberry Pi <em>client</em>, I think you should use the following:</p>

<p><strong>PC Side Code</strong></p>

<pre><code>zctx_t *ctx = zctx_new ();
void *reader = zsocket_new (ctx, ZMQ_PULL);
int rc = zsocket_bind (reader, ""tcp://PC-IP:5555"");
printf(""wait for a message...\n"");
while(1)
    {
        char *message = zstr_recv (reader);
        Sleep(10);
        printf(""Message: %s"",message);
    }
zctx_destroy (&amp;ctx);
</code></pre>

<p><strong>Raspberry Side Code</strong></p>

<pre><code>zctx_t *ctx = zctx_new ();
void *writer = zsocket_new (ctx, ZMQ_PUSH);
int rc = zsocket_connect (writer, ""tcp://PC-IP:5555"");
while(1)
    {
        cout&lt;&lt;""sending.................""&lt;&lt;endl;
        zstr_send (writer, ""HELLO"");
    }
zsocket_destroy (ctx, writer);
</code></pre>

<p>Of course you could also run the Raspberry Pi as pushing <em>server</em>, and the PC side as pulling <em>client</em>. In that case you could use:</p>

<pre><code>...
int rc = zsocket_connect (reader, ""tcp://raspberrypi-ip:5555"");
...
</code></pre>

<p>and:</p>

<pre><code>...
int rc = zsocket_bind (writer, ""tcp://raspberrypi-ip:5555"");
...
</code></pre>
",,49504923,1817
39742188,2,39742003,2016-09-28T08:39:43.413,2,,898348,,2016-09-28T08:46:55.843,2016-09-28T08:46:55.843,1,,"<p>You want this:</p>

<pre><code>void loop() {
  //Serial.println(noiseValue());
  //delay(10000);
  Particle.publish(""Sound"", String(noiseValue()));
  delay(5000);

  float nv = noiseValue();

  if (nv &lt; 130.00)
    Particle.publish(""noiseValue"", ""Green"", PUBLIC);

  if (nv &gt;= 130.00 &amp;&amp; nv &lt; 145.00)                          //&lt;&lt;&lt; h replaced by nv !!
     Particle.publish(""noiseValue"", ""Yellow"", PUBLIC);

  if (nv &gt;= 145.00)
     Particle.publish(""noiseValue"", ""Red"", PUBLIC);

  delay(10000);
}
</code></pre>

<p>You call <code>noisevalue</code> once here: <code>float nv = noisevalue();</code> and then you process <code>nv</code>.</p>

<p>BTW <code>h</code> should probably be replaced by <code>nv</code>, see comment in the code.</p>

<p>Be aware that following is most likeky wrong even if it compiles:</p>

<pre><code> if (noiseValue() &lt; 130.00)
    Particle.publish(""noiseValue"", ""Green"", PUBLIC);

  if (noiseValue() &gt;= 130.00 &amp;&amp; noiseValue() &lt; 145.00)                          
     Particle.publish(""noiseValue"", ""Yellow"", PUBLIC);

  if (noiseValue() &gt;= 145.00)
     Particle.publish(""noiseValue"", ""Red"", PUBLIC);
</code></pre>

<p>this calls <code>noisevalue</code> multiple times and the <code>noisevalue</code> function looks expensive. So it's better to call it only <em>once</em> as suggested in the first part of this answer.</p>
",,49534008,153
39750038,2,39745765,2016-09-28T14:12:27.197,3,,1411457,,2016-09-28T14:14:25.690,2017-04-13T12:50:09.193,2,,"<p>I think the main issue you have is that you have not allocated any buffer in which to store the received data (as pointed out in the comments by @WeatherVane).</p>

<p>When writing a function in C that is going to return a string, you have two choices: either the caller provides a buffer and passes a pointer to it into the function, or the function allocates the buffer and returns a pointer to it. </p>

<p>If the function is going to allocate it, then it will have to allocate it on the heap, using the <code>malloc</code> function. You could not use a local variable inside the function, because if you did then as soon as you exited the function, the variable is out of scope. In theory you could use a static variable as a buffer, but if you did that you could only read one string at a time.</p>

<p>If the caller is going to provide a buffer then it could use a local variable, a static variable, or allocate from the heap.</p>

<p>When the buffer is allocated on the heap, no matter who allocates it, the caller must free it when it is finished with it, using the <code>free</code> function.</p>

<p>Embedded systems generally minimize the use of heap allocated variables - see <a href=""https://arduino.stackexchange.com/questions/682/is-using-malloc-and-free-a-really-bad-idea-on-arduino"">this question</a> for some info about the reasons for that - so you might be better to allow the caller to allocate the buffer, like this:</p>

<pre><code>void UART0_READ(char* buffer, int buflen)
{
//  ... here goes code to read into buffer
}

#define BUFSIZE 100

int main(void)
{
    char input[BUFSIZE];
    UART0_READ(input, BUFSIZE);
    ...
}
</code></pre>

<p>Note that I defined the <code>UART0_READ</code> function to take two arguments: the address of the buffer, and it's length. Another thing your program is missing is any guard against the buffer overflowing.</p>

<p>Inside your input routine, use the buflen argument in eg. the call to memset, and inside the loop that reads characters to exit early if too many characters are read.</p>

<p>The buffer is defined as a local character array in the calling function.</p>

<p>Some other notes:</p>

<ul>
<li><p>Don't forget to add a zero, one past the last character added to the array. This also means that you must exit the loop after reading buflen-1 characters, so you have enough space for the 0.</p></li>
<li><p>I'm not sure why you are calling <code>strncpy</code> ? You seem to be copying the string onto itself.</p></li>
<li><p>Running a program with stray pointers in a full size OS will often result in a segfault. Embedded environments often lack the sophistication to detect  incorrect memory accesses so instead you might get less predictable behaivour (such as random garbage coming out the serial port).</p></li>
</ul>
",,49540852,148
39789212,2,39788834,2016-09-30T10:20:34.730,1,,5271927,,2016-10-03T12:31:25.227,2016-10-03T12:31:25.227,1,,"<p>Well, because there is no constructor for the buffer and its size, you have to do it yourself:</p>

<pre><code>String data;
data.reserve(length+1); // prepare space for the buffer and extra termination character '\0'
for (int i = 0; i&lt;length; ++i) {
    data += (char)data_chars[i]; // typecast because String takes uint8_t as something else than char
}
</code></pre>

<p>However it's kinda wasting a memory.</p>

<p>BTW: if you've used <code>char * data_chars</code> it'll be working even without type casting.</p>
",,49603470,140
39825430,2,39788834,2016-10-03T06:09:36.063,0,,1709088,,2016-10-03T06:09:36.063,,3,,"<p>The answer by KIIV is almost correct. However, I believe the 100% correct answer would be below;</p>

<pre><code>String data;
data.reserve(length+1); // prepare space for the buffer and extra termination character '\0'
for (int i = 0; i&lt;length; ++i) {
    data += (char) data_chars[i];
}
</code></pre>

<p>You need to cast <code>data_chars[]</code> to char to be completely sure. Tiny modification from KIIV's answer. The credit still goes to KIIV.</p>
",,49635710,129
39841866,2,39839796,2016-10-03T23:17:04.503,1,,6630084,,2016-10-03T23:17:04.503,,0,,"<p>Try to put SerialPort.Open() in try-catch block and call the SerialPort.Close() method after sending data:</p>

<pre><code>  void Serial(string port)
  {
      SerialPort sp = new SerialPort(port, 9600, Parity.None, 8, StopBits.One);
      try
      {
           sp.Open();
           try
           {
               sp.WriteLine(""G""); // Send 1 to Arduino
               sp.Close();
           }
           catch (Exception ex)
           {
                MessageBox.Show(ex.Message);
           }
       }
       catch (Exception e)
       {
            System.Diagnostics.Debug.WriteLine(e.Message); 
       }
  }
</code></pre>
",,49749112,327
39855376,2,39839796,2016-10-04T14:48:50.400,0,,2762128,,2016-10-04T14:48:50.400,,0,,"<p>Here is working codes....</p>

<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO.Ports;
using System.Threading;


namespace ForTest
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            string[] ports = SerialPort.GetPortNames();
            foreach (string port in ports)
            {
                SerialPort sp = new SerialPort(port, 9600, Parity.None, 8, StopBits.One);
                try
                {
                    sp.Open();
                    try
                    {
                        sp.WriteLine(""B""); // Send 1 to Arduino
                        sp.Close();
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ex.Message);
                    }
                }
                catch (Exception ek)
                {
                    System.Diagnostics.Debug.WriteLine(ek.Message);
                }
            }


        } 

    }
}
</code></pre>

<p>Thank you...............</p>
",,49785570,1107
39866719,2,39865734,2016-10-05T06:20:34.850,1,,5271927,,2016-10-05T06:29:31.893,2016-10-05T06:29:31.893,0,,"<p>The PROGMEM is not that easy to use. And it can be little bit simplified:</p>

<pre><code>#include &lt;avr/pgmspace.h&gt;

struct Route {
    void (*func)();
    const char *URI;
};

void test1() {
    Serial.println(F(""Executed testfunc1"")); // if you are using progmem, why not for string literals?
}

void test2() {
    Serial.println(F(""Executed testfunc2""));
}

const char route1URI[] PROGMEM = ""/route1"";
const char route2URI[] PROGMEM = ""/route2"";

const Route routingTable[] PROGMEM = {
    {test1,route1URI},
    {test2,route2URI}
};

void (*getRoute(char *URI))() {
    Route r;
    memcpy_P((void*)&amp;r, routingTable, sizeof(r)); // read flash memory into the r space. (can be done by constructor too)

    Serial.println((__FlashStringHelper*)r.URI); // it'll use progmem based print
    // for comparing use: strcmp_P( URI, r.URI)

    return r.func; // r.func is already pointer to the function
}

void setup() {
    Serial.begin(57600);
    while (!Serial) { }

    Serial.println(""started setup"");
    void (*fn)() = getRoute(""sometest"");
    // will cause errors if called
    //fn();
    Serial.print((uint16_t)test1, HEX); Serial.print(' ');
    Serial.print((uint16_t)test2, HEX); Serial.print(' ');
    Serial.println((uint16_t)fn, HEX);

    Serial.println(""ended setup"");
}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>

<p>I suppose <code>route1</code> and <code>route2</code> might cause all the troubles as it was used for copy into the <code>routingTable</code>. If you initialize elements of <code>routingTable</code> as I did, it works much better. And also <code>getRoute</code> was broken a lot.</p>

<p>Anyway, if you have flash string, you can use also <code>String str {(__FlashStringHelper*)r.URI};</code> and then use compare operator: <code>str == URI</code>:</p>

<pre><code>#include &lt;avr/pgmspace.h&gt;

// get size of array[]
template&lt;typename T, int size&gt; int GetArrLength(T(&amp;)[size]){return size;} 

struct Route {
    void (*func)();
    const char *URI;
};

void test1() {
    Serial.println(F(""Executed testfunc1"")); // if you are using progmem, why not for string literals?
}

void test2() {
    Serial.println(F(""Executed testfunc2""));
}
void test3() {
    Serial.println(F(""Executed testfunc3""));
}

const char route1URI[] PROGMEM = ""/route1"";
const char route2URI[] PROGMEM = ""/route2"";
const char route3URI[] PROGMEM = ""/route3"";

const Route routingTable[] PROGMEM = {
    {test1,route1URI},
    {test2,route2URI},
    {test3,route3URI}
};

void (*getRoute(char *URI))() {
  for (int8_t i = 0; i &lt; GetArrLength(routingTable); ++i) {
    Route r;
    memcpy_P((void*)&amp;r, routingTable+i, sizeof(r)); // read flash memory into the r space. (can be done by constructor too)

    String uri {(__FlashStringHelper*)r.URI};
    if (uri == URI) {
      return r.func; // r.func is already pointer to the function
    }
  }

  return nullptr;
}

void setup() {
    Serial.begin(57600);
    while (!Serial) { }

    Serial.println(""started setup"");
    void (*fn)() = getRoute(""/route3"");
    // will cause errors if called
    //fn();
    Serial.print((uint16_t)test1, HEX); Serial.print(' ');
    Serial.print((uint16_t)test2, HEX); Serial.print(' ');
    Serial.print((uint16_t)test3, HEX); Serial.print(' ');
    Serial.println((uint16_t)fn, HEX);

    Serial.println(""ended setup"");
}
</code></pre>
",,49801361,935
39867143,2,39865734,2016-10-05T06:47:54.437,0,,6207052,,2016-10-05T06:47:54.437,,2,,"<p>As pointed by @KIIV, it's better to specify <code>Route</code> directly inside the declaration of <code>routingTable</code>. As an alternative solution, you could redefined the struct <code>Route</code> to</p>

<pre><code>typedef struct {
    void (*func)();
    char URI[16];  //adjust the size to your need
} Route; 
</code></pre>

<p>In this way, reading both <code>URI</code> and <code>function</code> address from flash can be done by single call to <code>memcpy_P</code>. The complete codes:</p>

<pre><code>typedef struct {
    void (*func)();
    char URI[16];  //adjust the size to your need
} Route;

void test1() {
    Serial.println(""Executed testfunc1"");
}

void test2() {
    Serial.println(""Executed testfunc2"");
}

const Route routingTable[] PROGMEM = {
    {test1, ""/route1""},
    {test2, ""/route2""}
};

void (*getRoute(char *URI, int idx))() {
    Route r;
    memcpy_P(&amp;r, &amp;routingTable[idx], sizeof(Route));

    Serial.print(idx); Serial.println("". -----------------------------"");
    Serial.print(""Route: ""); Serial.println(r.URI);
    Serial.print(""fn address: ""); Serial.println((uint16_t)r.func, HEX);
    Serial.print(""test1 address: ""); Serial.println((uint16_t)test1, HEX);
    Serial.print(""test2 address: ""); Serial.println((uint16_t)test2, HEX);

    return r.func;
}

void setup() {
    Serial.begin(9600);
    while (!Serial) { }

    Serial.println(""started setup"");
    void (*fn)();

    const int n = sizeof(routingTable) / sizeof(Route);
    for (int i = 0; i &lt; n; i++) {
      fn = getRoute(""sometest"", i);
      fn();
    }
    Serial.println(""ended setup"");
}

void loop() {
  // put your main code here, to run repeatedly:
}
</code></pre>
",,49807644,83
39873005,2,39866623,2016-10-05T11:40:33.807,0,,2677670,,2016-10-05T11:40:33.807,,0,,"<p>I have no idea what you try to achieve here:</p>

<pre><code>#define SERVO1 2 ); Servo attach ;2
#define SERVO2 3 ); Servo attach ;-3
#define SERVO3 4 ); Servo attach ;4
#define SERVO4 5 ); Servo attach ; -5
#define PIEZO 6 ); attach ; -6
#define BUTTON 9 ); attach 9
</code></pre>

<p>but what you get is, in every place where <code>SERVO1</code> appears in the code, it is substituted with <code>2 ); Servo attach ;2</code> string. So <code>servo1.attach(SERVO1);</code> becomes <code>servo1.attach(2 ); Servo attach ;2);</code> which is nonsense. Just make the defines like <code>#define SERVO1 2</code> and you should be fine.</p>
",,49849983,1040
39867073,2,39866771,2016-10-05T06:43:00.653,1,,6742327,,2016-10-05T06:43:00.653,,6,,"<p>There is no need to go to these implementations. It pretty simple as follows.</p>

<p>LED13 will turn on when Pin 0 is high. I tested this code on arduino </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>#include &lt;avr/io.h&gt;                                      // Includes all the definition of register port etc  
#ifndef F_CPU

#define F_CPU 16000000UL      //Need to include it before &lt;util/delay.h&gt;

#endif                                       //Change 16000000 with your crystal freq. In my case its 16 MHz

#include &lt;util/delay.h&gt;    //includes delay functions delay_ms and delay_us

void setup() {
  // put your setup code here, to run once:
  DDRB |= 0xFF; //Configured Port B as OP
  DDRD &amp;= 0x00; //Configured Port D as IP
}

void loop() {
  // put your main code here, to run repeatedly:
  
  if (PIND&amp;(0x01)) //to check pin0 of portD (which is Pin 0 of arduino)
    PORTB |= 0xFF;
  else
    PORTB &amp;= 0x00;

}</code></pre>
</div>
</div>
</p>
",,49860173,432
39879422,2,39879324,2016-10-05T16:35:09.780,3,,391806,,2016-10-05T17:44:35.953,2016-10-05T17:44:35.953,0,,"<p>These three variables are static.  That means they will only be initialized once:</p>

<pre><code>// Remember the last step delay used when accelrating.
static int last_accel_delay;
// Counting steps when moving.
static unsigned int step_count = 0;
// Keep track of remainder from new_step-delay calculation to incrase accurancy
static unsigned int rest = 0;
</code></pre>

<p>If you follow the code you'll find that they are used to keep state from one interrupt to the next.</p>
",,49868762,81
40486251,2,39925689,2016-11-08T11:52:28.933,0,,325949,,2016-11-08T11:52:28.933,,1,,"<pre><code>char * CONNECTOR   = ""rest""; 
char * SERVER_ADDR   = ""myserver.com""; 

String uri = ""/public/auth_login?name=Alice&amp;age=12"";

CiaoData data = Ciao.write(CONNECTOR,SERVER_ADDR, uri);
</code></pre>

<p>I have used the Ciao library like this to send data and this seems to work.</p>
",,49910084,64
39985899,2,39985320,2016-10-11T20:11:38.920,1,,1351465,,2016-10-11T20:36:06.560,2016-10-11T20:36:06.560,0,,"<p>Lets recap your code:</p>

<pre><code>void loop() {
    // put your main code here, to run repeatedly:
    void StepperMotor.moveDegrees(-180);
    delay(1000);
}
</code></pre>

<p>First thing first: Don't put <code>void</code> in the call to <code>moveDegress()</code> there.</p>

<p>Second: </p>

<p>The method <code>moveDegrees</code> is not static, therefore, you need an instance of the class <code>StepperMotor</code> in order to call it:</p>

<pre><code>// note: you can initialize the variable here 
// but I'll  do it in setup
StepperMotor stepperMotorInstance; // your variable

void setup() {
    stepperMotorInstance = StepperMotor(8,9); // option 2: initialize variable in setup
}

void loop() {
    // put your main code here, to run repeatedly:
    stepperMotorInstance.moveDegrees(-180);
    delay(1000);
}
</code></pre>

<p>Hope it helps</p>
",,49945681,1104
40004418,2,39998247,2016-10-12T17:06:10.043,0,,3403834,,2016-10-12T17:06:10.043,,1,,"<p>The code doesn't measure the distance. It only measures the duration of the reflected signal. To get the distance you need to measure the delay between the beginning of ping, and the beginning of echo:</p>

<pre><code>    startTime = micros();

    digitalWrite(TRIG, HIGH);
    delayMicroseconds(20);
    digitalWrite(TRIG, LOW);

    //Wait for echo start
    while(digitalRead(ECHO) == LOW);
    long travelTime = micros() - startTime;
</code></pre>

<p>Of course, this is just a skeleton: you need to debounce the echo to guard yourself against background noises and other glitches.</p>
",,49958758,234
40055107,2,40045054,2016-10-15T04:56:49.440,1,,5621671,,2016-10-15T04:56:49.440,,6,,"<p>A few things that might help:</p>

<ol>
<li><p>You should wait until de GSM module returns <code>Connect</code> to the <code>mySerial.print(""AT+QHTTPPOST=187,60,7\r"");</code> command. After that you should send the post data.</p></li>
<li><p>When you use the <code>AT+QHTTP</code> commands you're using the HTTP layer implemented in the Quectel module. So you only have to send the post data and not the entire TCP message for a POST HTTP. The message you're sending is the TCP packet that implements HTTP protocol. For more information you can take a look of <a href=""https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html"" rel=""nofollow"">this</a>. </p></li>
</ol>

<p>From 2, you only need to send the data you want to post. From the link I've added you can see this HTTP POST packet example:</p>

<pre><code>POST /bin/login HTTP/1.1
Host: 127.0.0.1:8000
Accept: image/gif, image/jpeg, */*
Referer: http://127.0.0.1:8000/login.html
Accept-Language: en-us
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
Content-Length: 37
Connection: Keep-Alive
Cache-Control: no-cache

User=Peter+Lee&amp;pw=123456&amp;action=login
</code></pre>

<p>If you want to do this POST you should do something like:</p>

<pre><code>mySerial.print(""AT+QHTTPPOST=37,60,7\r"");
</code></pre>

<blockquote>
  <p>CONNECT</p>
</blockquote>

<pre><code>mySerial.print(""User=Peter+Lee&amp;pw=123456&amp;action=login"");
</code></pre>

<p>And then read the response or something.</p>
",,49973341,187
40141848,2,40045054,2016-10-19T21:31:14.290,2,,7018746,,2016-10-19T21:31:14.290,,0,,"<p>Using the AT TCPIP commands instead of the AT HTTP commands I was able to solve my own problem. I have now successfully posted data along with customized headers. </p>

<h2>Here is the code that works:</h2>

<pre><code>mySerial.print(""AT+QIOPEN=\""TCP\"",\""64.90.48.15\"",80\r""); 
</code></pre>

<blockquote>
  <p>WAIT for ""CONNECT"" response</p>
</blockquote>

<pre><code>mySerial.print(""AT+QISEND\r"");//
</code></pre>

<blockquote>
  <p>WAIT for ‘>’ response</p>
</blockquote>

<pre><code>//The HTML Header
mySerial.print(""POST /post.php?dir=WPCN HTTP/1.1\r\n"");
mySerial.print(""HOST: posttestserver.com\r\n"");
mySerial.print(""Accept: application/json\""\r\n"");
mySerial.print(""User-Agent: QUECTEL_MODULE2\r\n"");
mySerial.print(""Content-Length: 7\r\n"");
//Signifies end of Header
mySerial.print(""\r\n"");
//Data:
mySerial.print(“[hello]\r”);
//This is the &lt;CTRL+Z&gt; character which signifies end of transmission
mySerial.print(""\x1A"");
</code></pre>

<blockquote>
  <p>Response ""SEND OK""</p>
</blockquote>

<pre><code>//End Data Mode
delay(1000);
mySerial.print(""+++"");
delay(1000);
//Close connection
mySerial.print(""AT+QCLOSE\r"");
</code></pre>
",,49989844,341
40062226,2,40061836,2016-10-15T17:39:29.670,0,,7021136,,2016-10-15T23:29:57.617,2016-10-15T23:29:57.617,10,,"<p>I would suggest using event listenr fuction like _kbhit it can check when key is being pressed and when it's is being released and can be used as conditions to the type of signal u want to send. You will need to include : conio.h
This should work better:</p>

<pre><code>do{ 
    int key;
    if (_kbhit())
        key = getch();
    else
        key = 0;
    if (key==72)
    {
        // send message forward
    }
    else if (key=0) 
    {
        // send message STOP
    }
}while (cki.Key != ConsoleKey::Escape);
</code></pre>

<p>This code should work better</p>
",,50063974,22
40063987,2,40061836,2016-10-15T20:40:03.297,0,,2757079,,2016-10-15T20:48:05.420,2016-10-15T20:48:05.420,0,,"<p>What if you change the loop to <code>while (true)</code> and inside loop check if the key is available using <code>Console::KeyAvailable</code>, if the key is not available, send message stop, if it is available, read the key and check which key it is, if it is <code>UpArrow</code>, send message forward. If it is <code>Escape</code>, break the loop.</p>

<pre><code>ConsoleKeyInfo cki;
while (true){

    if (Console::KeyAvailable){
        cki = Console::ReadKey(true);
        if (cki.Key == ConsoleKey::UpArrow){
            // Forward
        }
        else if (cki.Key == ConsoleKey::Escape){
            break;
        }
    }
    else{
        // Stop
    }   
}
</code></pre>

<p>And maybe add some kind of sleep or something there, so your program doesn't always send stop whenever the pressed key is being processed and isn't in the keyboard buffer yet.</p>
",,50091499,643
40075771,2,40071375,2016-10-16T21:37:29.760,2,,3951057,,2016-10-16T21:37:29.760,,4,,"<p><code>&amp;class1::functionB</code> is a pointer-to-member-function, not a pointer-to-function. Its type is <code>void (class1::*)(void)</code>, not <code>void (*)(void)</code>, as expected by the <code>onRequest</code> method. It means that to call this pointer-to-member-function, it is required to have the instance as well (<code>class1*</code>).</p>

<p>If the <code>class1</code> is a singleton, the easiest way to solve this is probably making <code>functionB</code> a static member or simply a non-member function (not inside any class).</p>

<p>If <code>class1</code> cannot be assumed singleton, then the library must have a way to pass a context pointer (usually <code>void*</code>) along the pointer-to-function and this context is a parameter of the callback function. You should pass <code>this</code> as the context and a pointer to a wrapper function, like the following:</p>

<pre><code>void wrapper_for_class1_functionB(void* context)
{
    static_cast&lt;class1*&gt;(context)-&gt;functionB();
}

void class1::functionA(void)
{
    Wire.onRequest(&amp;wrapper_for_class1_functionB, this);
}
</code></pre>
",,50106781,52
40075991,2,40075468,2016-10-16T22:06:56.200,1,,2119587,,2016-10-16T22:06:56.200,,0,,"<p>Ok, instead of trying to make the unit tests inside the class, I managed to make them outside the <code>setup()</code> and <code>loop()</code> functions. Here's the working code with a sample output:</p>

<pre><code>//TMP36.h
#include &lt;Arduino.h&gt;
#include &lt;ArduinoUnit.h&gt;

class TMP36
{
    public:
        TMP36(int pino, float limInf, float limSup); //implementado
        float getTempC(); //implementado
        void setLimSup(float a);//implementado
        void setLimInf(float a);//implementado
        void testeLimSup();
        void testeLimInf();
        float getLimSup();
        float getLimInf();
    private:
        float _limSup; //setado pelo setLimSup;
        float _limInf; //setado pelo setLimInf;
        int _pino; //setado pelo construtor
        float _tensao; //retorno do getTempC;
        float getTensao();
};
</code></pre>

<p>/***************************/</p>

<pre><code>//TMP36.cpp
#include ""Arduino.h""
#include ""TMP36.h""
#include ""ArduinoUnit.h""

TMP36::TMP36 (int pino, float limInf, float limSup)
{
    pinMode(pino, OUTPUT);
    _pino = pino;
    _limInf = limInf;
    _limSup = limSup;
}

float TMP36::getTensao()
{
    return (analogRead(_pino) * 0.004882814);
}

float TMP36::getTempC ()
{   
    _tensao = getTensao();
    return (_tensao - 0.5) * 100.0;
}

void TMP36::setLimSup(float a)
{
    _limSup = a;
}

void TMP36::setLimInf(float a)
{
    _limInf = a;
}

float TMP36::getLimSup() {return _limSup; }

float TMP36::getLimInf() {return _limInf; }
</code></pre>

<p>/***************************/</p>

<pre><code>//sketch.ino
#include &lt;ArduinoUnit.h&gt;
#include ""TMP36.h""

TMP36 tmp36(0, -40, 125);

test(upLimOK)
{
  float a = tmp36.getLimSup();
  float b = tmp36.getTempC();
  assertLessOrEqual(b, a);
}

test(downLimOK)
{
  float a = tmp36.getLimInf();
  float b = tmp36.getTempC();
  assertMoreOrEqual(b, a);
}

void setup() {
  Serial.begin(9600);
}

void loop() {

  float temp;
  temp = tmp36.getTempC();
  Serial.print(""TMP36 Reading: "");
  Serial.println(temp);
  delay(1000);
  Test::run();

}
</code></pre>

<p>Sample Output:</p>

<pre><code>TMP36 Reading: 26.66
TMP36 Reading: 26.66
Test downLimOK passed.
Test upLimOK passed.
Test summary: 2 passed, 0 failed, and 0 skipped, out of 2 test(s).
</code></pre>
",,50144855,1410
40614670,2,40076037,2016-11-15T16:14:56.237,0,,7028234,,2016-11-15T16:14:56.237,,0,,"<p>The solution I came up with was to use:</p>

<pre><code>#ifdef __ARM__
include &lt;raspicam/raspicam.h&gt;
#endif
</code></pre>

<p>and in the main</p>

<pre><code>#ifdef __ARM__
    // pi specific camera initialization code
#elif __APPLE__
    // osx specific camera initialization code
#endif
</code></pre>

<p>These preprocessors will be evaluated before the code is compiled. If the source is being compiled on the pi (ARM architecture) the __ARM__ sections will be compiled, otherwise if the source code is being compiled on osx the __APPLE__ sections will be compiled.</p>
",,50155041,500
40093486,2,40093116,2016-10-17T18:44:20.150,2,,4513509,,2016-10-17T19:06:35.110,2016-10-17T19:06:35.110,8,,"<p>Expanding on what KIIV suggested, you could possibly do something like this:</p>

<pre><code>void setup() {
    // put your setup code here, to run once:
    Serial.begin(9600);
}

void loop() {
    // put your main code here, to run repeatedly:
    String words = ""This   is a sentence.""; //reassign same string at the start of loop.
    delay(1000);
    Serial.println(words);
    char c;
    char no = ' '; //character I want removed.

    for (int i=0; i&lt;words.length()-1;++i){
        c = words.charAt(i);
        if(c==no){
            words.remove(i, 1);
        }
    }
    Serial.println(words);
    delay(5000);//5 second delay, for demo purposes.
}
</code></pre>
",,50158033,431
40138956,2,40137637,2016-10-19T18:26:42.320,1,,5271927,,2016-10-19T18:26:42.320,,0,,"<p>Tested and it's working:</p>

<pre><code>/*
 * Connections:
 * A0 (PF0) -&gt; PCINT0 (PB0 / 53)
 * A1 (PF1) -&gt; PCINT1 (PB1 / 52)
 * A2 (PF2) -&gt; PCINT2 (PB2 / 51)
 * A3 (PF3) -&gt; PCINT3 (PB3 / 50)
 * A4 (PF4) -&gt; PCINT6 (PB6 / 12)
 * A5 (PF5) -&gt; PCINT7 (PB7 / 13)
 */

uint8_t pins[] = {A0,A1,A2,A3,A4,A5};

void setup() {
  Serial.begin(115200);

  // Make PF0-5 outputs:
  DDRF   = _BV(PF0) | _BV(PF1) | _BV(PF2) | _BV(PF3) | _BV(PF4) | _BV(PF5);

  PCICR  = _BV(PCIE0);
  PCMSK0 = _BV(PCINT0) | _BV(PCINT1) | _BV(PCINT2) | _BV(PCINT3) | _BV(PCINT6) | _BV(PCINT7);

  // Arduino sets global interrupts, so we don't have to do it here:
  // sei();
}

volatile uint8_t data = 0;
uint8_t          last = 0;

uint32_t    change_ts = 1000;
uint8_t       out_val = 0;

void loop() {

  if (data != last) {
    Serial.print(""Got: ""); Serial.println(data, BIN);
    last = data;
  }

  if (change_ts &lt;= millis()) {
    change_ts += 1000;
    Serial.print(F(""Changed to: "")); Serial.println(++out_val, BIN);
    PORTF = out_val;
  }
}

ISR(PCINT0_vect) {
  data = PINB &amp; PCMSK0; // read data and clear unused pins
}
</code></pre>

<p>If you don't use Arduino framework, you have to enable global interrupts by <code>sei()</code>. If you can't see some variable set inside of ISR from the outside, you have to make it <code>volatile</code>.</p>
",,50178804,101
40141342,2,40141047,2016-10-19T20:53:43.107,3,,1491895,,2016-10-19T20:53:43.107,,0,,"<p>Use the <a href=""http://man7.org/linux/man-pages/man4/tty_ioctl.4.html"" rel=""nofollow""><code>FIONREAD</code></a> ioctl.</p>

<pre><code>int nread;
ioctl(Serial, FIONREAD, &amp;nread);
if (nread &gt; 0) {
    ...
}
</code></pre>
",,50190574,660
40247676,2,40246601,2016-10-25T18:59:07.030,5,,1329652,,2016-10-25T19:21:34.843,2016-10-25T19:21:34.843,0,,"<p>You have no packetization whatsoever: there are no delimiters between individual chunks of data - other than time passing.</p>

<ol>
<li><p>On the Arudino side, instead of <code>write</code>, you should use <code>println</code> so that each message is a complete line.</p></li>
<li><p>On the Qt side, process complete lines. You're not guaranteed to get a complete response from the serial port after <code>waitForReadyRead</code>. All that you're guaranteed is that at least 1 byte is available to read. That is the source of your problem. Note how you got <code>LE</code>, then sometime later you got <code>D OFF</code> immediately followed by <code>LED ON</code>. You must wait for data until complete line(s) are available.</p></li>
</ol>

<p>The following should work on the Qt end of things - also note that you don't need as many includes, and you can use <code>QTextStream</code> instead of iostream, to lower the number of APIs that you use. Finally, you don't need <code>app.exec</code> since you write blocking code.</p>

<pre><code>// https://github.com/KubaO/stackoverflown/tree/master/questions/arduino-read-40246601
#include &lt;QtSerialPort&gt;
#include &lt;cstdio&gt;

int main(int argc, char *argv[])
{
    QCoreApplication a{argc, argv};
    QTextStream in{stdin};
    QTextStream out{stdout};

    QSerialPort port;
    port.setPortName(""COM6"");
    port.setBaudRate(9600);
    port.setDataBits(QSerialPort::Data8);
    port.setParity(QSerialPort::NoParity);
    port.setStopBits(QSerialPort::OneStop);
    port.setFlowControl(QSerialPort::NoFlowControl);

    if (!port.open(QSerialPort::ReadWrite)) {
        out &lt;&lt; ""Error opening serial port: "" &lt;&lt; port.errorString() &lt;&lt; endl;
        return 1;
    }

    while(true)
    {
        out &lt;&lt; ""&gt; "";
        auto cmd = in.readLine().toLatin1();
        if (cmd.length() &lt; 1)
            continue;

        port.write(cmd);

        while (!port.canReadLine())
            port.waitForReadyRead(-1);

        while (port.canReadLine())
            out &lt;&lt; ""&lt; "" &lt;&lt; port.readLine(); // lines are already terminated
    }
}
</code></pre>

<p>If you wish, you can also easily turn it into a GUI application, it's only a few lines to do so:</p>

<pre><code>#include &lt;QtSerialPort&gt;
#include &lt;QtWidgets&gt;

int main(int argc, char *argv[])
{
    QApplication app{argc, argv};
    QWidget ui;
    QFormLayout layout{&amp;ui};
    QLineEdit portName{""COM6""};
    QTextBrowser term;
    QLineEdit command;
    QPushButton open{""Open""};
    layout.addRow(""Port"", &amp;portName);
    layout.addRow(&amp;term);
    layout.addRow(""Command:"", &amp;command);
    layout.addRow(&amp;open);
    ui.show();

    QSerialPort port;
    port.setBaudRate(9600);
    port.setDataBits(QSerialPort::Data8);
    port.setParity(QSerialPort::NoParity);
    port.setStopBits(QSerialPort::OneStop);
    port.setFlowControl(QSerialPort::NoFlowControl);

    QObject::connect(&amp;open, &amp;QPushButton::clicked, &amp;port, [&amp;]{
        port.setPortName(portName.text());
        if (port.open(QSerialPort::ReadWrite)) return;
        term.append(QStringLiteral(""* Error opening serial port: %1"").arg(port.errorString()));
    });

    QObject::connect(&amp;command, &amp;QLineEdit::returnPressed, &amp;port, [&amp;]{
        term.append(QStringLiteral(""&gt; %1"").arg(command.text()));
        port.write(command.text().toLatin1());
    });

    QObject::connect(&amp;port, &amp;QIODevice::readyRead, &amp;term, [&amp;]{
        if (!port.canReadLine()) return;
        while (port.canReadLine())
            term.append(QStringLiteral(""&lt; %1"").arg(QString::fromLatin1(port.readLine())));
    });
    return app.exec();
}
</code></pre>
",,50203086,822
40248797,2,40247793,2016-10-25T20:07:04.303,1,,2402272,,2016-10-25T20:07:04.303,,0,,"<p>You seem to be trying to draw attention to this:</p>

<blockquote>
<pre><code>enum lgw_radio_type_e {
    LGW_RADIO_TYPE_NONE,
    LGW_RADIO_TYPE_SX1255,
    LGW_RADIO_TYPE_SX1257
};

#define LGW_RF_CHAIN_NB     2   /* number of RF chains */
</code></pre>
  
  <p>[...]</p>

<pre><code>static enum lgw_radio_type_e rf_radio_type[LGW_RF_CHAIN_NB];
</code></pre>
  
  <p>[...] the array is not initialized at any place in the code</p>
</blockquote>

<p>It is not a particular problem that the array is not <em>explicitly</em> initialized.  File-scope variables (and <code>static</code> block-scope variables) are subject to default initialization if no explicit initializer is provided.  In this case, the array declaration is equivalent to</p>

<pre><code>static enum lgw_radio_type_e rf_radio_type[2] = {
        LGW_RADIO_TYPE_NONE, LGW_RADIO_TYPE_NONE
    };
</code></pre>

<p>That seems to be quite sensible in itself.</p>

<p>You go on to say,</p>

<blockquote>
  <p>[...] when the function is called, and it selects the default Error 'unexpected rf chain' of course.</p>
</blockquote>

<p>I don't see any reason to expect a different case to be selected, but neither do I see any justification for assuming that a different one would <em>not</em> be selected.  Nor is it clear under what circumstances the <code>switch</code> itself is executed at all.</p>

<p>One would normally expect one or both elements of <code>rf_radio_type</code> to be set during driver initialization if in fact the corresponding hardware is present.  If the <em>overall</em> code (not just the parts you've presented) is correct, then probably it will not execute the presented <code>switch</code> when <code>rf_radio_type[rf_chain]</code> has a value different from both <code>LGW_RADIO_TYPE_SX1255</code> and <code>LGW_RADIO_TYPE_SX1257</code>.  On the other hand, printing the error message is essentially harmless in itself; if the driver prints it then that may be merely a quality-of-implementation issue, not a functional flaw.</p>

<blockquote>
  <p>So my question to the forum here is, aside from that this construct
  above makes not really sense, is that not a faulty construct anyway ?</p>
</blockquote>

<p>No, it isn't.  And as far as I can tell, all constructs presented make as much sense as can be expected when taken out of context as they have been.</p>

<blockquote>
  <p>Will this compile and work as meant under Linux GCC ?</p>
</blockquote>

<p>You have presented several individually valid C fragments, but they do not together constitute a valid translation unit.  It is possible to form a complete, valid translation unit containing all those fragments that will compile successfully and do absolutely anything.  The fragments will not inherently interfere with compilation, nor necessarily cause malfunction.</p>

<blockquote>
  <p>I try to use this code under GCC ARM and it does NOT work as it seems to be planned.</p>
</blockquote>

<p>I find your apparent confidence in your assessment of the intended behavior of the overall code to be a bit optimistic.</p>
",,50234614,733
40249596,2,40249512,2016-10-25T20:59:09.370,0,,4491252,,2016-10-25T20:59:09.370,,0,,"<p>You should be able to do</p>

<pre><code>uint8_t data[32];
uint8_t combinedArray[2];
data[11] = {'1'};
data[12] = {'2'};
data[13] = {'3'};
String result = data[11] + data[12] + data[13];
//then you can convert that to a char array by doing result.toChars();
//or converty the result by doing Integer.parseInt(result);
//you WILL have to use chars instead because they will concatenate correctly
//because uint8_t is not a character its a number so when you concatenate              
//them you add the two ascii values together
</code></pre>
",,50234692,91
40254768,2,40249512,2016-10-26T05:59:50.427,0,,5271927,,2016-10-26T05:59:50.427,,0,,"<p>Simple decimal (in ascii) to decimal (numeric) conversion should be enough:</p>

<pre><code>combinedArray[1] = 0;             // value must be defined
for (uint8_t * ptr = data+11; ptr != data+14; ++ptr) {
  combinedArray[1] *= 10;         // move previous value by one digit to the left (ie. 12 =&gt; 120)
  combinedArray[1] += *ptr - '0'; // substract ascii value of '0' from character to get value and add it to the result
}
</code></pre>

<p>If using characters for setting elements in <code>data</code> array is mistake, then you have to remove <code>- '0'</code> so it'll work with correct values: <br>
Now you have character '1' in <code>data[11] = {'1'};</code> with value 49 (ASCII value of character '1').</p>
",,50243704,68
40277652,2,40253441,2016-10-27T06:29:28.127,0,,3629249,,2016-10-27T06:29:28.127,,1,,"<p>an easy way to input a 2 digit decimal value</p>

<p>and output it as a hex value.</p>

<pre><code>unsigned int inputValue = 0;

if( 1 == scanf( ""%u"", &amp;inputValue ) )
{
    if( 99 &gt;= inputValue )
    {
        printf( %04x\n"", inputValue );
    }

    else
    {
         // handle range error
    }
}

else
{
    // handle scanf() failure
}
</code></pre>

<p>for the posted function:</p>

<pre><code>char * decToHex(unsigned int ones, unsigned int tens) 
{
    short int result = 0x0000;
    char *hexStr = NULL;

    if( NULL != (hexStr = malloc(7) ) )
    {
        // handle error and exit
    }

    // implied else, malloc successful

    unsigned short int totalValue = ones+ (10*tens);

    sprintf( hexStr, ""0X%04x"", totalValue );

    return hexStr;
}
</code></pre>
",,50251876,1604
40260679,2,40260563,2016-10-26T11:06:37.613,3,,70898,,2016-10-26T11:06:37.613,,1,,"<p>I would make an array with the values you need and load the correct value from the array. It will take you 4 bytes, it will be fast, and solve your problems even if you start using a different motor type.</p>

<pre><code>for example:
const char values[4]={1,2,4,8};
int current_value = 0;

....

if(++current_value&gt;=4)current_value=0;
motor = values[current_value];
</code></pre>
",,50270367,2211
40260689,2,40260563,2016-10-26T11:07:07.653,4,,440558,,2016-10-26T11:14:00.407,2016-10-26T11:14:00.407,0,,"<p>Use an 8-bit data type (like e.g. <code>uint8_t</code>). Initialize it to zero. Set the bit you want to set in the lower four bits of the byte (e.g. <code>value = 0x08</code>).</p>

<p>For each ""rotation"" take the LSB (least significant bit) and save it. Shift one step right. Overwrite the fourth bit with the bit you saved.</p>

<p>Something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

uint8_t rotate_one_right(uint8_t value)
{
    unsigned saved_bit = value &amp; 1;  // Save the LSB
    value &gt;&gt;= 1;  // Shift right
    value |= saved_bit &lt;&lt; 3;  // Make the saved bit the nibble MSB
    return value;
}

int main(void)
{
    uint8_t value = 0x08;  // Set the high bit in the low nibble
    printf(""%02hhx\n"", value);  // Will print 08
    value = rotate_one_right(value);
    printf(""%02hhx\n"", value);  // Will print 04
    value = rotate_one_right(value);
    printf(""%02hhx\n"", value);  // Will print 02
    value = rotate_one_right(value);
    printf(""%02hhx\n"", value);  // Will print 01
    value = rotate_one_right(value);
    printf(""%02hhx\n"", value);  // Will print 08 again

    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/rVW0Bq"" rel=""nofollow"">Live demonstration</a>.</p>
",,50283768,87
40260823,2,40260563,2016-10-26T11:13:45.120,8,,667266,,2016-10-27T11:52:05.113,2016-10-27T11:52:05.113,5,,"<p>IMO the easiest way is:</p>

<pre><code>const unsigned char steps[ 4 ] = { 0x08, 0x04, 0x02, 0x01 };
int stepsIdx = 0;
...
const unsigned char step = steps[ stepsIdx++ ];
stepsIdx = stepsIdx % ( sizeof( steps ) / sizeof( steps[ 0 ] ) );
</code></pre>
",,50319029,652
40260907,2,40260563,2016-10-26T11:17:18.700,15,,26095,,2016-10-26T11:17:18.700,,0,,"<p>Just use an <code>int</code> to hold the value. When you do the rotate copy the least significant bit to bit 4 and then shift it right by 1:</p>

<pre><code>int rotate(int value)
{
    value |= ((value &amp; 1) &lt;&lt; 4); // eg 1001 becomes 11001
    value &gt;&gt;= 1;                 // Now value is 1100
    return value;
}
</code></pre>
",,50320870,43
40266999,2,40260563,2016-10-26T15:59:45.567,10,,3517622,,2016-10-26T15:59:45.567,,8,,"<p>The arithmetic for this is simple enough that it will always be faster than the table approach:</p>

<pre><code>constexpr unsigned rotate_right_4bit ( unsigned value )
{
    return ( value &gt;&gt; 1 ) | ( ( value &lt;&lt; 3 ) &amp; 15 );
}
</code></pre>

<p>This turns into 5 lines of branch-free x86 assembly:</p>

<pre><code>lea     eax, [0+rdi*8]
shr     edi
and     eax, 15
or      eax, edi
ret
</code></pre>

<p>Or, alternatively, if you actually like to see the indexes <code>{3, 2, 1, 0}</code>, then you can split them up into 2 functions, one that ""increments"" the index, and the other that actually computes the value:</p>

<pre><code>constexpr unsigned decrement_mod4 ( unsigned index )
{
    return ( index - 1 ) &amp; 3;
}

constexpr unsigned project ( unsigned index )
{
    return 1u &lt;&lt; index;
}
</code></pre>
",,50331275,272
40267060,2,40266499,2016-10-26T16:02:33.257,0,,5271927,,2016-10-26T16:02:33.257,,0,,"<p>So many mistakes. For example:</p>

<pre><code>sim::sim()
{
   _msg= msg;  // where it should get this msg?
               // Also it's not possible to do a copy of array like this.
}
</code></pre>

<p>Why do you need _msg, if you are sending msg passed as a parameter?</p>

<pre><code>void sim::sendSMS(char msg[160])
</code></pre>

<p>If you want to call it, you have to use exactly the same data type:</p>

<pre><code>char something[160] = ""some text to send"";
instance.sendSMS(something);
</code></pre>

<p>But you can't just pass string directly:</p>

<pre><code>instance.sendSMS(""some text to send"");
</code></pre>

<p>as it's type of <code>const char *</code> and it can't be handled by type <code>char[160]</code>.</p>

<p>Also you don't count with termination characte at the end of the string.</p>
",,50342360,47
40288002,2,40287871,2016-10-27T15:00:10.777,2,,2711645,,2016-10-27T15:00:10.777,,6,,"<p>Sure, you can. However in the body of <code>constructDataString</code>, you need to use <code>*extString</code> instead of <code>extString</code> to dereference the pointer.
Otherwise, you can use a reference in C++.</p>

<p>With the reference, the code would be:</p>

<pre><code>void constructDataString (String&amp; extString)
{
 // Set up data to transmit
    extString = String(var1);                           
    extString += "","";
    extString += String(var2);                                  
    extString += "","";
    extString += String(var3);      
    extString += "","";
    extString += String(var4);  
    extString += "","";
    extString += String(var5);
}
</code></pre>

<p>and you use it as follows:</p>

<pre><code>String dataString =””;
constructDataString (dataString);
</code></pre>
",,50343741,74
40326568,2,40326502,2016-10-30T06:27:28.303,0,,2456565,,2016-10-30T06:55:39.790,2017-05-23T12:33:21.183,3,,"<p>Imo you're hurting readability a lot by using macros for this. But here's how I'd do this:</p>

<pre><code>#define STRIP0 0
#define STRIP1 1
#define STRIP2 2
#define STRIP3 3
#define  PINS0 2,3,4
#define  PINS1 5,6,7
#define  PINS2 8,9,10
#define  PINS3 11,12,13

#define CONCAT_HELP(A, B) A ## B

#define CONCAT(A, B) CONCAT_HELP(A, B)

#define PINS(FUNC,STRIP) FUNC(CONCAT(PINS, STRIP))
</code></pre>

<p>now, you'd call this like this:</p>

<pre><code>PINS(foo, STRIP0);
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/KuI4nqyaM0rgQ3og"" rel=""nofollow noreferrer"">demo</a></p>

<p>You need two levels of indirection, because of the way macro replacement works (<a href=""https://stackoverflow.com/a/1489985/2456565"">here</a> is an in-depth explanation). With just <code>#define CONCAT(A,B) A ## B</code>, <code>CONCAT(PINS,STRIP0)</code> would create <code>PINSSTRIP0</code> which makes no sense here.</p>

<hr>

<p>For completeness sake, if you expect to use this with runtime values (of which you gave no indication of in the question), you could go with a helper function template that would switch over the strip value:</p>

<pre><code>template&lt;typename Func&gt;
void pins(Func f, int strip)
{
    switch(strip){
    case 0: f(PINS0); break;
    case 1: f(PINS1); break;
    case 2: f(PINS2); break;
    case 3: f(PINS3); break;
    }
}
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/coEqvVJWb5wLOoUz"" rel=""nofollow noreferrer"">demo</a></p>

<p>and, if you have C++17 available:</p>

<pre><code>constexpr tuple&lt;int,int,int&gt; params[] = {
    make_tuple(PINS0),
    make_tuple(PINS1),
    make_tuple(PINS2),
    make_tuple(PINS3)
};

template&lt;typename Func&gt;
void pins(Func f, int strip)
{
    apply(f, params[strip]);
}
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/UzWrIVsHiVZpOQhZ"" rel=""nofollow noreferrer"">demo</a></p>

<p>though at this point, the helper function stops being necessary.</p>
",,50350334,619
40566057,2,40331617,2016-11-12T18:08:41.453,1,,2556237,,2016-11-12T18:08:41.453,,0,,"<p>OK, I found a solution myself: The <strong>bit-endianness</strong> was wrong! The RPi 3 uses big-endian on its SPI interface, but the display expects little-endian. So I did a little research and found this simple algo to reverse the bits in a byte:</p>

<pre><code>char vfd::Reverse (char b)
{
  b = (b &amp; 0xF0) &gt;&gt; 4 | (b &amp; 0x0F) &lt;&lt; 4;
  b = (b &amp; 0xCC) &gt;&gt; 2 | (b &amp; 0x33) &lt;&lt; 2;
  b = (b &amp; 0xAA) &gt;&gt; 1 | (b &amp; 0x55) &lt;&lt; 1;
  return b;
}
</code></pre>

<p>All I had to do then in the code addressing the display is to use the abovementioned function:</p>

<pre><code>buffer [0] = Reverse (0x01);
</code></pre>

<p>Now the display works perfectly. :)</p>
",,50359875,848
40365917,2,40364467,2016-11-01T18:03:33.557,0,,7100612,,2016-11-01T18:03:33.557,,1,,"<p>I was able to figure out that the issue was with how I was declaring the c_cflags. Xbee needs to be read in raw mode so rather than set the flags myself I just used cfmakeraw(). However I'm still not sure what exactly I was doing wrong or how opening the port with third party programs was helping the connection.</p>

<pre><code>int xbee_init (char *port, struct termios *tty) {

    int fd=open(port,O_RDWR | O_NOCTTY | O_NONBLOCK);

    if(fd == -1){return 0;}//should be something better
    else {
        if(tcgetattr(fd, tty)!=0){return 0;}
        else{
                // cfsetospeed(tty, B57600);
                // cfsetispeed(tty, B57600);

                // tty-&gt;c_cflag &amp;= ~PARENB;
                // tty-&gt;c_cflag &amp;= ~CSTOPB;
                // tty-&gt;c_cflag &amp;= ~CSIZE;
                // tty-&gt;c_cflag |= CS8;
                // tty-&gt;c_cflag &amp;= ~CRTSCTS; 
                // tty-&gt;c_cflag |= CLOCAL | CREAD;
                // // tty-&gt;c_cflag |= PARENB;
                // // tty-&gt;c_cflag ^= PARENB;

                // tty-&gt;c_iflag |= IGNPAR | IGNCR;
                // tty-&gt;c_iflag &amp;= ~(IXON | IXOFF | IXANY);
                // tty-&gt;c_lflag |= ICANON;
                // tty-&gt;c_oflag &amp;= ~OPOST;

                cfmakeraw(&amp;tty);
                cfsetispeed(&amp;tty, B57600);

                tcsetattr(fd, TCSANOW, &amp;tty);

                }
            }

    return fd;
}
</code></pre>
",,50365333,136
40402506,2,40400384,2016-11-03T13:17:08.380,1,,5271927,,2016-11-03T13:17:08.380,,2,,"<p>As there is only incomplete code and I couldn't test it directly, there is example how it's possible to get it work (it's all in one sketch, Arduino IDE 1.6.12, C++11):</p>

<pre><code>class Event {
  public:
    virtual void handle() = 0;
};

class EventLeft : public Event {
  public:
    virtual void handle() {
      Serial.println(""EventLeft"");
    }
} leftEvent;

class EventRight : public Event {
  public:
    virtual void handle() {
      Serial.println(""EventRight"");
    }
} rightEvent;

class PushButton {
  public:
    PushButton(int8_t _pin, Event * _event) : pin(_pin), state(true), event(_event) {
      pinMode(pin, INPUT_PULLUP);
    }

    void check() {
      if (! digitalRead(pin)) { // inverted logic
        if (state) event-&gt;handle();
        state = false;
      } else {
        state = true;
      }
    }

  private:
    int8_t    pin;
    bool    state;
    Event * event;
};

PushButton buttons[] = {
  {4, &amp;leftEvent},
  {5, &amp;rightEvent}
};

void setup()   {    
  Serial.begin(115200);
}

void loop() {
  delay(10);

  for (PushButton &amp; button : buttons) button.check();
  //// if the range based for loop above doesn't work, you have to use old school one:
  // for (uint8_t i = 0; i &lt; 2; ++i) buttons[i].check();
}
</code></pre>
",,50370487,449
40414425,2,40412719,2016-11-04T02:36:22.787,0,,2410359,,2016-11-04T02:36:22.787,,0,,"<p>Code needs an array of characters</p>

<pre><code>//       Pointer to a character -----v                            
void uint16_2_char(uint16_t n, char* c){
  sprintf( c, ""%04d"", (int) n );
}
</code></pre>

<p>Problem code</p>

<pre><code>//     This is one character
char  c_temp;

uint16_t mmLaser = 0;  // hold laser reading

// **ERROR:** invalid conversion from 'char' to 'char*'
// Does not make sense to pass a character when an address is needed
// Need to pass the initial _address_ as an array of characters instead.
//                         v
uint16_2_char( mmLaser, c_temp); 
</code></pre>

<p>Better code</p>

<pre><code>#define INT_BUF_SIZE 24 
char buffer[INT_BUF_SIZE]; 

// When an array is passed to a function, 
// it is converted to the address of the 1st character of the array.
//  The function receives &amp;buffer[0]
uint16_2_char( mmLaser, buffer); 
</code></pre>

<p>Even better, pass an address and the size available</p>

<pre><code>void uint16_2_char(uint16_t n, char* c, size_t sz){
  unsigned u = n;
  // I'd expect using unsigned types.  (use `%u`)
  // snprintf() will not not overfill the buffer
  snprintf( c, sz, ""%04u"", u);
}

char buffer2[INT_BUF_SIZE]; 
uint16_2_char2( mmLaser, buffer, sizeof buffer); 
</code></pre>
",,50414164,387
40428578,2,40415081,2016-11-04T17:27:57.593,0,,5552095,,2016-11-04T17:27:57.593,,0,,"<p>Your code has a few problems - In order:</p>

<p>The return value of read in this instance is a 32 bit integer - You are truncating it to a byte value, meaning if the file contents are ever over 255 bytes, you will incorrectly terminate your string, and fail to read the contents correctly:</p>

<pre><code>byte byteSize = sdFiles.read(sdData, datalen);
</code></pre>

<p>Secondly, you are storing the address of a stack variable into your <code>tempStoreParam</code> array with this line:</p>

<pre><code>tempStoreParam[index] = lsParam;
</code></pre>

<p>Now, this will work, but only for how long <code>sdData</code> remains in scope. After that, <code>sdData</code> is no longer valid to use, most likely leading to the garbage you experience. What you most likely are trying to do is take a copy of the data to place it into <code>tempStoreParam</code>. To do that, you should use something like this:</p>

<pre><code>// The amount of memory we need is the length of the string, plus one 
// for the null byte
int length = strlen(lsParam)+1

// Allocate storage space for the length of lsParam in tempStoreParam
tempStoreParam[index] = new char[length];

// Make sure the allocation succeeded 
if (tempStoreParam[index] != nullptr) {
   // Copy the string into our new container
   strncpy(tempStoreParam[index], lsParam, length);
}
</code></pre>

<p>At this point, you should be able to pass around that string outside the function successfully. As a note, you will need to <code>delete</code> the array created once you are done with it / before reading the file again.</p>
",,50440789,363
40416389,2,40416173,2016-11-04T06:12:52.563,0,,6803631,,2016-11-04T06:12:52.563,2017-05-23T10:30:30.147,0,,"<p>Use getsockopt with TCP_MAXSEG:</p>

<pre><code>int mss;
socklen_t len = sizeof mss;
getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, &amp;mss, &amp;len);
</code></pre>

<p>From <code>man tcp</code>:</p>

<blockquote>
<pre><code>  TCP_MAXSEG
         The maximum segment size for outgoing TCP packets.  In Linux 2.2
         and  earlier,  and  in Linux 2.6.28 and later, if this option is
         set before connection establishment, it  also  changes  the  MSS
         value  announced to the other end in the initial packet.  Values
         greater than the (eventual) interface MTU have no  effect.   TCP
         will  also  impose its minimum and maximum bounds over the value
         provided.
</code></pre>
</blockquote>

<p>According to <a href=""https://stackoverflow.com/questions/25996741/why-getsockopt-does-not-return-the-expected-value-for-tcp-maxseg"">this question</a>, this should be done <em>after</em> the connection is established, otherwise a generic default value will be returned.</p>
",,50459582,139
40463646,2,40435159,2016-11-07T11:05:20.713,0,,3365728,,2016-11-07T11:05:20.713,,0,,"<p>for Galileo 1 you can use this script to setup spidev1.0</p>

<pre><code>#!/bin/bash -e
# v0od0ochild

echo ""Configuring Spidev1.0 for Galileo..""
gpio_path=/sys/class/gpio
gpio4=""out 1""
gpio42=""out 0 strong""
gpio43=""out 0 strong""
gpio54=""out 0 strong""
gpio55=""out 0 strong""
gpios=""4 42 43 54 55""
setup_gpio() {
  echo ""Gpio ${1}: direction: $2, value: $3, drive: $4""
  echo -n $2 &gt; $1/direction
  echo -n $3 &gt; $1/value
  echo -n $4 &gt; $1/drive
}
for i in ${gpios}; do
  gpio=${gpio_path}/gpio${i}
  if [ ! -d ${gpio} ]; then
  echo ""Exporting gpio ${i}""
  echo -n ${i} &gt; ${gpio_path}/export
  fi
done
for i in ${gpios}; do
  gpio=${gpio_path}/gpio${i}
  if [ -d ${gpio} ]; then
  gpiovar=gpio${i}
  setup_gpio ${gpio} ${!gpiovar}
  fi
done
echo ""Spi ready""
</code></pre>

<p>If you are using a Galileo Gen2:</p>

<pre><code>#!/bin/bash -e

# v0od0ochild

echo ""Configuring Spidev1.0 for Galileo-Gen2..""

#pin10
echo 26 &gt; /sys/class/gpio/export || echo ""gpio26 already exported""
echo 74 &gt; /sys/class/gpio/export || echo ""gpio74 already exported""
echo 27 &gt; /sys/class/gpio/export || echo ""gpio27 already exported""
echo low &gt; /sys/class/gpio/gpio26/direction || echo ""Failed to set gpio26 low""
echo low &gt; /sys/class/gpio/gpio74/direction || echo ""Failed to set gpio74 low""
echo in &gt; /sys/class/gpio/gpio27/direction || echo ""Failed to set gpio27 direction in""

#pin11
echo 24 &gt; /sys/class/gpio/export || echo ""gpio24 already exported""
echo 44 &gt; /sys/class/gpio/export || echo ""gpio44 already exported""
echo 72 &gt; /sys/class/gpio/export || echo ""gpio72 already exported""
echo 25 &gt; /sys/class/gpio/export || echo ""gpio25 already exported""
echo low &gt; /sys/class/gpio/gpio24/direction || echo ""Failed to set gpio24 low""
echo high &gt; /sys/class/gpio/gpio44/direction || echo ""Failed to set gpio44 high""
echo low &gt; /sys/class/gpio/gpio72/direction || echo ""Failed to set gpio72 low""
echo in &gt; /sys/class/gpio/gpio25/direction || echo ""Failed to set gpio25 direction in""

#pin12
echo 42 &gt; /sys/class/gpio/export || echo ""gpio42 already exported""
echo 43 &gt; /sys/class/gpio/export || echo ""gpio43 already exported""
echo low &gt; /sys/class/gpio/gpio42/direction || echo ""Failed to set gpio42 low""
echo in &gt; /sys/class/gpio/gpio43/direction || echo ""Failed to set gpio43 direction in""

#pin13
echo 30 &gt; /sys/class/gpio/export || echo ""gpio30 alreay exported""
echo 46 &gt; /sys/class/gpio/export || echo ""gpio46 already exported""
echo 31 &gt; /sys/class/gpio/export || echo ""gpio31 already exported""
echo low &gt; /sys/class/gpio/gpio30/direction || ""Failed to set gpio30 low""
echo high &gt; /sys/class/gpio/gpio46/direction || ""Failed to set gpio46 high""
echo in &gt; /sys/class/gpio/gpio31/direction || ""Failed to set gpio31 direction in""
echo ""Spi ready""
</code></pre>
",,50487431,180
40451747,2,40450539,2016-11-06T16:34:54.087,0,,7120004,,2016-11-08T04:23:38.767,2016-11-08T04:23:38.767,3,,"<p>You are mixing up assignment ""="" and comparison ""=="" in your changeMode() function.  Here is a corrected version of the function.</p>

<pre><code>void changeMode() {
  if ( buttonState == HIGH) {
    modeSwitchValue = 1;
    automatic = true;
    manual = false;
    buttonState = LOW;
  }

  if (buttonState == LOW) {
    modeSwitchValue = 0;
    manual = true;
    automatic = false;
    buttonState = HIGH;
  } 
}
</code></pre>

<p>You should also realize that mechanical buttons can have contact bounce.  Since you are using an interrupt to detect changes in the button state you might get erratic behavior.  Usually, it is better to poll the button state and apply a de-bounce time delay on the order of 20ms.</p>

<p>You also have not shared how the button is wired.  Since you are detecting a rising edge, I assume that the button is wired to pull the pin high when pressed. If you are using a single-pole single-though button, you will need a pull down resistor to ground, otherwise the interrupt pin will float.  </p>

<p>You can avoid the required pull-up or pull down resistor, by connecting a simple button between the input pin and ground.  Then change your initialization code to</p>

<pre><code>pinMode(pin, INPUT_PULLUP)
</code></pre>

<p>You will then want to trigger interrupt on the falling edge.</p>

<p>I hope this helps.</p>
",,50494121,98
40462481,2,40450539,2016-11-07T10:06:23.220,0,,2819922,,2016-11-08T13:00:21.160,2016-11-08T13:00:21.160,2,,"<p>If you really want to attach an ISR to the RISING edge of a button signal, you should ignore multiple triggers. Minimum 2 msec, but why not ignore everything that's unrealistic (e.g. 100 msec) </p>

<p>As you just toggle two states, I'd propose a boolean variable <code>istate</code>. </p>

<pre><code>volatile bool istate; // the state maintained in the ISR changeMode

void changeMode() {
  static unsigned long lastime;
  if (millis() - lastime &gt; 100) {
     lastime = millis();
     istate = ! istate;
  } 
}
</code></pre>

<p>All other redundant stuff (automatic, manual) can be built from that volatile ISR variable in the main code, if necessary.
In my unterstanding, the name <code>buttonState</code> is just wrong. And the variable unnecessary.</p>

<hr>

<p>Do you know the data type enum?</p>

<pre><code>enum {MANUAL, AUTO} mode;
 if (istate) mode = AUTO;
 else        mode = MANUAL;
</code></pre>

<p>might be nice for your purpose.</p>
",,50500328,1369
40451154,2,40450692,2016-11-06T15:39:12.023,4,,1427124,,2016-11-06T15:50:51.450,2016-11-06T15:50:51.450,0,,"<p>First, I think you left out some key information: it looks like you must be using an Arduino board with a 16-bit <code>int</code> type (e.g., Arduino Uno).</p>

<p>The problem here is how integer promotion works in C and C++. When you cast a 16-bit signed integer literal, <code>1&lt;&lt;15</code>, to a 32-bit unsigned integer literal, it will take the following steps:</p>

<ol>
<li>You're casting from 16-bit up to 32-bit, so it will first extend your existing literal to 32-bits. Since it's a signed literal, it's first sign-extended to a 32-bit signed value.</li>
<li>Now that the operand have the same bit-width as the desired type, the compiler casts it to a 32-bit unsigned integer type.</li>
</ol>

<p>I don't have a 16-bit machine sitting around to test this on, but I can duplicate the same behavior on my 64-bit laptop with this test program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

int main(int argc, const char* argv[]) {
    printf(""%"" PRIx64 ""\n"", ((uint64_t)(1 &lt;&lt; 31)));
    // prints ffffffff80000000
    printf(""%"" PRIx64 ""\n"", ((uint64_t)(1 &lt;&lt; 31)) &gt;&gt; 31);
    // prints 1ffffffff
    return 0;
}
</code></pre>

<p>So you can see in this program, it's not the <code>&gt;&gt;</code> operation that's doing the unwanted sign extension, but rather the cast from a 32-bit signed integer to a 64-bit unsigned integer, because the cast actually acts like this:</p>

<p><code>int32_t</code> → <code>int64_t</code> → <code>uint64_t</code></p>

<p>If you want to avoid the extra sign extensions, you should either start with an unsigned literal (as Some programmer dude suggested in his comment), or make a cast to the same-width unsigned type. Any of these should work:</p>

<pre><code>Serial.print( ((uint32_t)(1u&lt;&lt;15)) &gt;&gt; 15, BIN);
Serial.print( ((uint16_t)(1&lt;&lt;15)) &gt;&gt; 15, BIN);
Serial.print( ((uint32_t)(uint16_t)(1&lt;&lt;15)) &gt;&gt; 15, BIN);
</code></pre>
",,50523515,3013
40476414,2,40454320,2016-11-07T23:16:00.437,1,,3576279,,2016-11-07T23:16:00.437,,0,,"<p>After a research the delay on loop function is causing request timeout. By deleting <code>delay(1000);</code> it works</p>

<p>Correct code with static ip:</p>

<pre><code>#include &lt;EtherCard.h&gt;

// ethernet interface mac address, must be unique on the LAN
static byte mymac[] = { 0x74, 0x69, 0x69, 0x2D, 0x30, 0x31 };
static byte myip[] = { xxx, xxx, 216, 203 };
static byte gwip[] = { xxx, xxx, 216, 126 };
static byte dnsip[] = { 8, 8, 8, 8};
static byte netmask[] = { 255, 255, 255, 0};
byte Ethernet::buffer[500];
BufferFiller bfill;

void setup () {
  Serial.begin(9600);
  if (ether.begin(sizeof Ethernet::buffer, mymac, 53) == 0)// 53 only on MEGA
    Serial.println(F(""Failed to access Ethernet controller""));
  ether.staticSetup(myip, gwip, dnsip, netmask);

  while (ether.clientWaitingGw())
    ether.packetLoop(ether.packetReceive());
  Serial.println(""\nGateway found"");
  Serial.print(""ether.clientWaitingGw="");// just to test
  Serial.print(ether.clientWaitingGw());
}


void loop () {

  word len = ether.packetReceive();
  word pos = ether.packetLoop(len);

  if (pos) { // check if valid tcp data is received
    ether.httpServerReply(homePage());// send web page data
    Serial.println(""\nSend web data"");
  }
</code></pre>
",,50547181,103
40465618,2,40465477,2016-11-07T12:49:19.913,9,,865874,,2016-11-07T12:49:19.913,,3,,"<p>In the C version it is clear that <code>sizeof(Targets) == 1</code>. And it looks like the second field of the struct is 2-byte aligned, so you have a padding byte, with undefined contents.</p>

<p>Now, in C++, <code>sizeof(PhaseTargets)</code> may be <code>1</code> or <code>2</code>. If it is <code>1</code> (likely) all is well and you have the same padding space, just happened to have different garbage value. If it is <code>2</code>... well, you'll have a wrong enum value!</p>

<p>The easy way to initialize the struct would be in the definition of the variable. If you don't have the values yet, just add a 0 and all the struct will be 0 initialized.</p>

<pre><code>struct saatProtoExec execCommand = {0};
</code></pre>

<p>If that cannot be done, you can <code>memset()</code> it to zero before using.</p>

<p>A portable alternative would be to declare the fields of the struct as integers of the proper size, and use the <code>enum</code> types just as collections of constants.</p>

<pre><code>struct saatProtoExec {
    uint8_t         target;
    uint8_t         commandName;
    uint8_t         padding[2];
    uint32_t        commandBody;
} execCommand;
</code></pre>
",,50575239,308
40503416,2,40499594,2016-11-09T09:18:59.983,4,,1790864,,2016-11-09T09:25:02.903,2016-11-09T09:25:02.903,0,,"<p>I can give you a quick overview about what the provided code does.</p>

<p>(This is from memory, so don't take my word for it. And you don't mention your controller type. You will have to look up the registers up in detail.)</p>

<pre><code>DDRB |= _BV(1);         // set the compare match output pin to output
TCCR1A |= _BV(COM1A0);  // enable output compare PIN toggle
TCNT1 = 0;              // set counter start value to 0
OCR1A = 100;            // set compare match value to 100 (the actual delay)
TIFR1 = _BV(OCF1A);     // clear the output compare flag 
TCCR1B |= _BV(CS10);    // enable the timer by setting the pre-scaler
while((TIFR1 &amp; _BV(OCF1A)) == 0);  // wait until the timer counted to 100 (compare flag is set again)
</code></pre>

<p>So the actual delay depends on:</p>

<ul>
<li>the setting of the prescaler</li>
<li>the clock speed of your controller</li>
<li>the value of OCR1A</li>
</ul>

<p>Example:<br>
If the prescaler is set to 1 and you run at 10MHz you got<br>
t = (1 / (10000000/s)) * 100 = 10us </p>

<p>This should get you started.</p>
",,50576918,502
40534827,2,40533507,2016-11-10T18:42:33.650,1,,5059631,,2016-11-10T18:42:33.650,,0,,"<p>maybe you can try to reset the millis using something like this, I don't have an arduino so it's not tested but hopefully it can help.</p>

<pre><code>extern volatile unsigned long timer0_millis;
unsigned long reset = 0;

#include &lt;Arduino.h&gt;
int led = 7;
void setup() {
  Serial.begin(9600);
  pinMode(led, OUTPUT);
}

void loop(){
  x();
  Serial.println(""Im ending main loop"");

  setMillis(reset);
}

void setMillis(unsigned long new_millis){
  uint8_t oldSREG = SREG;
  cli();
  timer0_millis = new_millis;
  SREG = oldSREG;
}

void x() {
  for (int i = 0; i &lt;= 10; i++) {
    mydelay(led, 0, 1);
    mydelay(led, 1, 1);
  }
}

void mydelay(int pin, int hol, int secs) {
  int starttime = millis();
  while ((millis() - starttime) &lt;= (secs * 1000)) Serial.println(""I am in while"");
  toggled(pin, hol);
  Serial.println(""Im ending mydelay"");
}

void toggled(int pin, int hol) {
  digitalWrite(led, hol);
}
</code></pre>
",,50626605,67
40546343,2,40546270,2016-11-11T10:47:11.683,3,,4849753,,2016-11-14T09:08:14.593,2016-11-14T09:08:14.593,5,,"<p>you can use pointer to a function as an argument and then you can execute it within your if block.</p>

<pre><code>void function(void (*arbitrary_function)()) {
    int buttonPinState = digitalRead(buttonPin);

    if (buttonPinState != lastButtonPinState) {
        if (buttonPinState == 1) {  
            arbitrary_function();
        }
    }

    lastButtonPinState = buttonPinState;
}

void arbitrary_function_1() {
    // some code here
}


void arbitrary_function_2() {
    // some other code here
}

void loop() {
     ...
     function(&amp;arbitrary_function_1);
     ...
     function(&amp;arbitrary_function_2);
     ...
}
</code></pre>
",,50629966,108
40547136,2,40546270,2016-11-11T11:33:37.707,2,,2959769,,2016-11-11T11:33:37.707,,0,,"<p>Yes you can. I am not sure if your question is this simple that you want to execute a call if the <code>buttonPinState == 1</code> and it is <code>!=</code> to <code>lastButtonPinState</code></p>

<p>Say if the condition you are looking forward to is true i.e. the button is pressed. </p>

<p>You do not need 2 seperate <code>if</code> conditions you can use <code>&amp;&amp;</code> and do what you intend is</p>

<p><strong>Solution 1:</strong> </p>

<pre><code>int buttonPinState = digitalRead(buttonPin);

  if ( (buttonPinState != lastButtonPinState) &amp;&amp; (buttonPinState == 1) ) 
  {  
      counter++; //increment or do anything.

  }
  lastButtonPinState = buttonPinState;
</code></pre>

<p><strong>Solution 2:</strong> </p>

<p>By calling a function </p>

<pre><code>int buttonPinState = digitalRead(buttonPin);

  if ( (buttonPinState != lastButtonPinState) &amp;&amp; (buttonPinState == 1) ) 
  {  
      functionCall(); //Call function to execute anything
  }

  lastButtonPinState = buttonPinState;

int functionCall()
{
   counter++;//increment counter
   // do your activity 
   return 0;
}
</code></pre>
",,50653822,94
40585338,2,40546270,2016-11-14T09:24:07.337,0,,841108,,2016-11-14T10:28:00.640,2016-11-14T10:28:00.640,1,,"<p><sup>(I am separating the general question from its Arduino specific counterpart)</sup></p>

<h3>General considerations</h3>

<p>Recommendation: <strong>read <a href=""http://mitpress.mit.edu/sicp/"" rel=""nofollow noreferrer""><em>SICP</em></a></strong>. It is not related to Arduino, but it is an excellent introduction to programming, freely available, and would teach you the right terminology and concepts.</p>

<p><sup>[it seems that you are lacking a lot of general programming concepts; your question is probably not Arduino specific, and much less related to C or C++ that what you believe]</sup></p>

<p>In general, it looks like you are <em>apparently</em> wanting <a href=""https://en.wikipedia.org/wiki/First-class_function"" rel=""nofollow noreferrer"">first class functional values</a> or metaprogramming facilities. So read more about <a href=""https://en.wikipedia.org/wiki/Functional_programming"" rel=""nofollow noreferrer"">functional programming</a> and about <a href=""https://en.wikipedia.org/wiki/Metaprogramming"" rel=""nofollow noreferrer"">metaprogramming</a>. For a tiny system like an Arduino, it might look like an <a href=""http://xyproblem.info/"" rel=""nofollow noreferrer"">XY problem</a>, and you should have motivated your question.</p>

<p>First class functions are generally implemented with <a href=""https://en.wikipedia.org/wiki/Closure_%28computer_programming%29"" rel=""nofollow noreferrer""><strong>closures</strong></a>. C don't have them, and C++ have them only since <a href=""https://en.wikipedia.org/wiki/C%2B%2B11"" rel=""nofollow noreferrer"">C++11</a> (but I am not sure your Arduino cross-compiler is C++11 compliant). In C++11, you'll use <a href=""https://en.wikipedia.org/wiki/Anonymous_function"" rel=""nofollow noreferrer"">anonymous functions</a>, <a href=""http://en.cppreference.com/w/cpp/language/lambda"" rel=""nofollow noreferrer"">lambda expressions</a>, and <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow noreferrer"">std::function</a>.</p>

<p>Very probably, the programming languages available on Arduino don't provide first class functions and closures. You'll then use <a href=""https://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer"">function pointers</a> (they exist in plain C99) thru <a href=""https://en.wikipedia.org/wiki/Callback_%28computer_programming%29"" rel=""nofollow noreferrer"">callbacks</a>, that is with the additional <em>convention</em> of passing some client data. Then you can look at these (function pointer + callback client data) as a poor man's convention to implement closures.</p>

<p>Alternatively, you could consider generating some code at runtime and then calling it. This is a form of <a href=""https://en.wikipedia.org/wiki/Metaprogramming"" rel=""nofollow noreferrer"">metaprogramming</a>. You might want some <a href=""https://en.wikipedia.org/wiki/Just-in-time_compilation"" rel=""nofollow noreferrer"">JIT compilation</a> libraries (such as <a href=""https://gcc.gnu.org/onlinedocs/jit/"" rel=""nofollow noreferrer"">GCCJIT</a> or <a href=""https://www.gnu.org/software/libjit/"" rel=""nofollow noreferrer"">libjit</a>), but these requires that executable code can sit in RAM (as in every <a href=""https://en.wikipedia.org/wiki/Von_Neumann_architecture"" rel=""nofollow noreferrer"">Von Neumann architecture</a>), which might not be the case for many Arduino boards (the code is only in Flash ROM, in some <a href=""https://en.wikipedia.org/wiki/Harvard_architecture"" rel=""nofollow noreferrer"">Harvard architecture</a>).</p>

<p>The abstract notion of <a href=""https://en.wikipedia.org/wiki/Continuation"" rel=""nofollow noreferrer"">continuation</a> and <a href=""https://en.wikipedia.org/wiki/Continuation-passing_style"" rel=""nofollow noreferrer"">CPS</a> is also indirectly relevant.</p>

<hr>

<h3>Back to the Arduino:</h3>

<p>Probably you could think of your code as some <a href=""https://en.wikipedia.org/wiki/Finite-state_machine"" rel=""nofollow noreferrer"">finite state</a> or <a href=""https://en.wikipedia.org/wiki/Pushdown_automaton"" rel=""nofollow noreferrer"">pushdown</a> stack automaton, or as some <a href=""https://en.wikipedia.org/wiki/Bytecode"" rel=""nofollow noreferrer"">bytecode</a> interpreter. (so I guess you don't <em>really</em> need metaprogramming, or first class closures, even if your question relates to them). Maybe associate every button with some callback (that is use an array of pointers and callback client data)., e.g.</p>

<pre><code>/// signature of callbacks
typedef void button_callback_sigt(int buttoncode, void*clientdata);

#define NB_BUTTONS 16
struct button_callback_st {
  button_callback_sigt* funptr; // function pointer
  void* data; // client data
};
struct button_callback_st buttoncb[NB_BUTTONS];
</code></pre>

<p>You'll then need some other code to initialize that array, and something to run the callbacks on button presses (and handle key <a href=""https://en.wikipedia.org/wiki/Switch#Contact_bounce"" rel=""nofollow noreferrer"">bounces</a>). Perhaps some callbacks might update that array (e.g. if some buttons are <a href=""https://en.wikipedia.org/wiki/Mode_%28computer_interface%29"" rel=""nofollow noreferrer"">modal</a>, like the shift key on your keyboard).</p>

<p>You might want to have a ""general purpose"" <a href=""https://en.wikipedia.org/wiki/Event_loop"" rel=""nofollow noreferrer"">event loop</a> handling the buttons and removing glitches and key bounces (following the <a href=""https://en.wikipedia.org/wiki/Separation_of_concerns"" rel=""nofollow noreferrer"">separation of concerns</a> design principle). Once it is sure that a button press is genuine (not a parasite), it will call the appropriate callback:</p>

<pre><code>int buttonnumber = .... ;
(*buttoncb[buttonnumber].funptr) (buttonnumber, buttoncb[buttonnumber].data);
</code></pre>

<p>A concrete example of some callback could be indeed incrementing some global counter. Here is the number of the relevant button (in fact, you'll better have an <code>enum</code> describing the buttons)</p>

<pre><code>#define COUNTBUTTON 3
</code></pre>

<p>Here is the counter, a global variable:</p>

<pre><code>extern int counter;
</code></pre>

<p>The actual work of incrementing it is in this callback function. Its second argument is the address of the counter.</p>

<pre><code>void counter_cbfun(int buttoncode, void*data) {
  int* pc = (int*)data;
  if (buttoncode == COUNTBUTTON)
     (*pc) ++;
};
</code></pre>

<p>and you'll initialize </p>

<pre><code>  buttoncb[COUNTBUTTON].funptr = counter_cbfun; // function address
  buttoncb[COUNTBUTTON].data = (void*)&amp;counter;
</code></pre>

<p>NB: Food for thought: <a href=""http://norvig.com/21-days.html"" rel=""nofollow noreferrer"">http://norvig.com/21-days.html</a></p>
",,50658105,188
40623487,2,40548941,2016-11-16T03:15:31.620,0,,89766,,2016-11-16T03:15:31.620,2017-05-23T12:30:23.367,0,,"<p>Kevin's done an excellent job at explaining what the syntax error you got means and how to tackle it.</p>

<p>In addition to that I'd like to point out an issue I spotted in <a href=""https://stackoverflow.com/questions/40513381/arduino-processing-to-save-and-display-the-data/40554272#40554272"">Simon's question</a> as well:</p>

<blockquote>
  <p>float inByte = port.read();</p>
</blockquote>

<p>According to Serial's documentaiton on <a href=""https://processing.org/reference/libraries/serial/Serial_read_.html"" rel=""nofollow noreferrer"">read()</a>:</p>

<blockquote>
  <p>Returns a number between 0 and 255 for the next byte that's waiting in the buffer. Returns -1 if there is no byte, although this should be avoided by first cheacking available() to see if data is available.</p>
</blockquote>

<p>There are couple of issues:</p>

<ol>
<li>EngduinoThermistor returns temperature as a float and that is not what <code>read()</code> returns. It returns one byte at a time. Let's say the temperature is <code>25.71</code>. That will be 5 bytes (<code>2 5 . 7 1</code> which as bytes represented from 0 to 255 would be <code>50 53 46 55 49</code>). You would need to convert each byte to a character then append each character to a String until the new line (<code>\n</code>) character is found, then the byte counter would reset. After the full string is put together, it can be converted to a float. I recommend using either <a href=""https://processing.org/reference/libraries/serial/Serial_readStringUntil_.html"" rel=""nofollow noreferrer"">readStringUntil()</a> or a combination of <a href=""https://processing.org/reference/libraries/serial/Serial_bufferUntil_.html"" rel=""nofollow noreferrer"">bufferUntil()</a> and <a href=""https://processing.org/reference/libraries/serial/Serial_readString_.html"" rel=""nofollow noreferrer"">readString()</a></li>
<li>You are not checking if read() returns -1 which you should always do unless you use <a href=""https://processing.org/reference/libraries/serial/serialEvent_.html"" rel=""nofollow noreferrer"">serialEvent()</a></li>
</ol>

<p>I recommend double checking if the data is displayed correctly in Arduino's Serial Monitor first. If it is, close Serial Monitor (as you can open a single connection to a serial port at a time), then run your Arduino code.</p>

<p>You can also take advantage of this one weird trick: Arduino already knows what serial port and baud rate you're using and saves this as a preference (so you don't have to select the port every single time you restart it). This is actually stored in a <a href=""https://docs.oracle.com/javase/7/docs/api/java/util/Properties.html"" rel=""nofollow noreferrer"">Java Properties</a> <a href=""https://en.wikipedia.org/wiki/.properties#Format"" rel=""nofollow noreferrer"">format</a> that you can easily parse in Processing. </p>

<p>You can easily find the location to this file from the <strong>Arduino Preferences</strong> panel:
<a href=""https://i.stack.imgur.com/4z6GM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4z6GM.png"" alt=""Arduino Preferences""></a></p>

<p>Here's a basic sketch that tries to read the serial port name and baud rate from Arduino preferences then read a string and print it to the console (while trying to handle some errors):</p>

<pre><code>import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import processing.serial.*;

String portName = null;
int baudRate = 9600;

Serial arduino;

void setup(){
  readArduinoPrefs(""/Users/George/Library/Arduino15/preferences.txt"");
  println(""last used Arduino port"",portName,""with baud rate"",baudRate);

  try{
    arduino = new Serial(this,portName,baudRate);
  }catch(Exception e){
    System.err.println(""ERROR connecting to Arduino port "" + portName);
    String message = e.getMessage();
    if(message.contains(""not found"")) println(""Please make sure your Arduino is connected via USB!"");
    if(message.contains(""busy"")) println(""Please make sure the port isn't already opened/used by Serial Monitor or other programs!"");
    e.printStackTrace();
    exit();
  }
}
void draw(){
}
void serialEvent(Serial s){
  println(""received string"",s.readStringUntil('\n'));
}
void readArduinoPrefs(String prefsPath){
  Properties prop = new Properties();
  InputStream input = null;

  try {

    input = new FileInputStream(prefsPath);

    prop.load(input);

    portName = prop.getProperty(""serial.port"");
    baudRate = int(prop.getProperty(""serial.debug_rate""));

  } catch (IOException ex) {
    ex.printStackTrace();
  } finally {
    if (input != null) {
      try {
        input.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

}
</code></pre>

<p>On the pragmatic side, you can always type in the port name and baud rate as you configure it in Arduino manually, just remember to double check the <a href=""https://processing.org/reference/libraries/serial/Serial.html"" rel=""nofollow noreferrer"">syntax</a>, in your case:</p>

<pre><code>Serial(parent, portName, baudRate)
</code></pre>

<p>e.g.</p>

<pre><code>   new Serial(this, ""/dev/tty.usbmodem1411"", 9600);
</code></pre>

<p>as Kevin pointed out</p>
",,50703901,767
40577194,2,40577161,2016-11-13T18:19:34.520,2,,157247,,2016-11-13T18:53:13.797,2016-11-13T18:53:13.797,4,,"<p>In a comment below you've said (in reference to the second solution under the bar using an array):</p>

<blockquote>
  <p>I actually do not need the second dimension,as the value ranges are defined in the first dimension/column (5 10 15 20 etc)</p>
</blockquote>

<p>In that case, it's really much simpler than the solutions below:</p>

<pre><code>int loops = ((X / 5) + 1) * 5;
</code></pre>

<p>...assuming <code>X</code> is an <code>int</code>. That uses integer division, which truncates (e.g., <code>4 / 5</code> is <code>0</code>), adds one, then multiplies the result by 5. Here's the same thing in JavaScript just for an on-site example (in JavaScript, since numbers are always floating point, we have to add in a flooring method, but you don't need that in Java):</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var X;
for (X = 0; X &lt; 25; ++X) {
  var loops = (Math.floor(X / 5) + 1) * 5;
  console.log(""X = "" + X + "", loops = "" + loops);
}</code></pre>
</div>
</div>
</p>

<hr>

<blockquote>
  <p>Then in each clause I have the same for loop,but the iterations change depending on the value of X.</p>
</blockquote>

<p>I'd set a variable to the number of iterations, then put the <code>for</code> loop after the <code>if</code>/<code>else</code> sequence.</p>

<pre><code>int loops;
if (X &lt; 5) {
    loops = /*whatever*/;
} else if (X &lt; 10) {
    loops = /*whatever*/;
} else if (X &lt; 15) {
    loops = /*whatever*/;
// ...and so on...
} else {
    loops = /*whatever for the catch-all case*/;
}
for (int i = 0; i &lt; loops; ++i) {
    // ...
}
</code></pre>

<p>If you're trying to avoid the <code>if</code>/<code>else</code>, if there are only a small number of possible sensor values, you could use a <code>switch</code> instead, which in some languages is compiled to a jump table and so fairly efficient.</p>

<p>If you want to have the ranges held as data rather than in an <code>if</code>/<code>else</code> sequence, you could use an array of values:</p>

<pre><code>int[][] values = {
    {5, 500},
    {10, 700},
    {15, 800},
    {20, 1200},
    {0, 1500}  // 0 is a flag value
};
</code></pre>

<p>(There I'm using an array of <code>int[]</code>, but it could be a nice clean class instance instead.)</p>

<p>Then loop through the array looking for the first entry where <code>X &lt; entry[0]</code> is true (or where <code>entry[0]</code> is <code>0</code>, to flag the last entry).</p>

<pre><code>int loops = 0; // 0 will never be used, but the compiler doesn't know that
for (int[] entry : values) {
    if (entry[0] == 0 || X &lt; entry[0]) {
        loops = entry[1];
        break;
    }
}
</code></pre>

<p>...followed by the <code>for</code> loop using <code>loop</code>s.</p>
",,50708707,102
40577319,2,40577161,2016-11-13T18:31:27.540,0,,4319483,,2016-11-13T18:31:27.540,,1,,"<p>Since your intervals are products of 5, it may be possible to just divide X by 5 and use the result as index in an array. </p>

<pre><code>const size_t loops[] = {someval, anotherval, ..., lastval};
size_t i,  nloops = loops[X / 5];
for (i = 0; i &lt; nloops; i++) {
    ...
}
</code></pre>
",,50747457,1769
40581176,2,40581092,2016-11-14T02:40:29.987,2,,3312311,,2016-11-14T02:40:29.987,,3,,"<p>You can't include C++ declarations in header files in C files. If you need to mix C and C++ declarations in the same header file, wrap the C++ ones in</p>

<pre><code>#ifdef __cplusplus
class MyClass {
  // ...
};
#endif
</code></pre>
",,50787947,94
48629682,2,40612562,2018-02-05T19:03:04.717,1,,2370362,,2018-02-05T19:03:04.717,,0,,"<p>Wow, this question is old, and I'm surprised it isn't answered yet.</p>

<p>I just got it working, but my project uses Scons as the build system. Still, the issue I found was that it wasn't linking enough libraries. This is what I set to get what I needed (the <code>qmake</code> syntax might be off):</p>

<pre><code>LIBS += \
  -L/opt/pylon5/lib64 \
  -lpylonbase \
  -lGenApi_gcc_v3_0_Basler_pylon_v5_0 \
  -lGCBase_gcc_v3_0_Basler_pylon_v5_0 \
  -lLog_gcc_v3_0_Basler_pylon_v5_0 \
  -lMathParser_gcc_v3_0_Basler_pylon_v5_0 \
  -lXmlParser_gcc_v3_0_Basler_pylon_v5_0 \
  -lNodeMapData_gcc_v3_0_Basler_pylon_v5_0
</code></pre>
",,50892571,367
40732511,2,40622427,2016-11-22T01:46:33.827,0,,3922985,,2016-11-22T01:46:33.827,,0,,"<p>There is a global variable <code> currentIdxStart </code> and I'm using a RTC clock to keep trac of time. </p>

<pre><code>int sizeOfArr = 10;
  int dutyPWM[sizeOfArr] = {0, 26, 52, 78, 104, 130, 156, 182, 208, 214}; 
  unsigned long nowtime = 0;
  nowtime = get_time();

if (nowtime &gt;= num_unixtime+3600) 
 {
//setpwmfor10pumps(); 
int idx = currentIdxStart;
for (int i = 4; i &lt;= 13; i++)
{
  analogWrite(i, dutyPWM[idx]);
  int duty = dutyPWM[idx];

  idx ++;
  if (idx &gt;= sizeOfArr)
  {
    idx = 0;
  }
  Serial.print(i);
  Serial.print(':');
  Serial.print(duty);
  Serial.println("" "");
}

currentIdxStart++;
if (currentIdxStart &gt;= 10)
{
  currentIdxStart = 0;
}
Serial.println(currentIdxStart); 
num_unixtime = get_time(); 
Serial.print(num_unixtime); 
Serial.println('\n');
}
</code></pre>

<p>Hope that helps anyone in the future, thanks. </p>
",,50940362,239
40637639,2,40636959,2016-11-16T16:45:23.190,2,,225074,,2016-11-16T16:45:23.190,,1,,"<p>If all of the objects are string and pattern, you can model them as an abstract base class:  </p>

<pre><code>class String_Pattern
{
  public:  
    virtual void pattern_method(ESPLedDriver&amp; driver_to_use) = 0;
  private:
    std::string  text;
};
</code></pre>

<p>Note that this design requires passing the driver to the string pattern object.  Think of this giving the object a driver to use.  </p>
",,50983952,148
40666815,2,40663189,2016-11-17T23:21:02.273,0,,3470630,,2016-11-17T23:32:54.983,2016-11-17T23:32:54.983,1,,"<p>If you want the simplest option, remember that the ""Convert T"" and ""Read Scratchpad"" commands are two distinct steps. Your program can read the temperature, then come back for the value later. There's no need to stall the program, unless you want to get the temperature value the exact instant the conversion finishes.</p>

<pre><code>mainLoop() {
    while(1) {
        // Do things
        int16_t rawTemperature = readScratchpad(myTemperatureSensor); // Get the last temperature reading
        if(!getTemperature(myTemperatureSensor)) { // Start the next conversion
            //Temperature conversion was not done, throw out value
            rawTemperature = INT16_MAX;
        }
        else {
            float temperature = ((float)rawTemperature / 4.0f);
            saveTemperature(temperature);
        }
        // Do other things while temperature conversion happens
    }
}
</code></pre>

<p>Where in this case, getTemperature issues a ""Convert T"" command, and returns 0 or 1 according to the datasheet (replies 0 if the prior conversion wasn't done, 1 if a new conversion has been started).</p>
",,51022682,127
40667941,2,40667703,2016-11-18T01:24:37.223,0,,6928569,,2016-11-18T01:24:37.223,,0,,"<p>In general you cannot use two infinite loops. That's because it is senquentional program, so it cannot run second when until the first one is done. So if first loop is infinite, the second will never run.</p>

<p>To do some kind of 'multithreading', in simplest way is to use timers and interrupts.</p>

<p>In your case you want to run two different task. Blinking led and steering servos. When you use wait()/sleep()/delay(), the uC is simply stopping (except handling other things like interupts etc.). So you can set timers and in the interrupt blink led. Or better in the interrupt just set some flag, and in your main just check if flag has changed. Than just handle blink. So in general you will have in you main sth like this:</p>

<pre><code>volatile uint8_t nowBlink = 0

ISR(TIMER1_OVF_vect)
{
  // some timer handling and then:
  nowBlink = 1
}

loop(){
 if(nowBlink){
    toggleLed();
    nowBlink = 0;
 }
 setServo(123123);

}
</code></pre>

<p>Setting intterupt to 1 s, will blink your led with freq of 1 Hz, and then other parts of program will be done.</p>

<p><a href=""http://letsmakerobots.com/node/28278"" rel=""nofollow noreferrer"">Here</a> you have timers explained, and <a href=""http://playground.arduino.cc/Code/Timer1"" rel=""nofollow noreferrer"">Here</a> you have some libraries. Just read that and you should be master of arduino.</p>

<p>Best regards, voodoo16.</p>
",,51043477,2275
40668085,2,40667703,2016-11-18T01:44:35.837,0,,7175903,,2016-11-18T01:44:35.837,,0,,"<p>Don't use functions like delay_ms(), wait () etc. Try interrupt. </p>

<p>Use the struture like this :</p>

<pre><code>int flag = 0;
void func_delay_50ms () interrupt
{
    // set initial condition
    flag ++;
}

void main
{
    while (1)
    {
        if (flag == 4) // per 200ms
        {
            led = -led;
            flag = 0;
        }

        if (!(flag % 2)) // per 100ms
        {    
             servo ();
        }  
    }
}
</code></pre>

<p>note : servo () should not block for a long time.</p>

<p>There are no really conturrent threads, And you should create an illusion to realize it.</p>

<p><em>(:з」∠)</em> My poor English. pardon me.</p>
",,51047481,49
40692245,2,40667703,2016-11-19T11:15:57.550,0,,5530013,,2016-11-19T11:15:57.550,,0,,"<p>I wrote an Operating System for Arduino which supports multithreading in order to run multiple loops at once. Note that the servo has a range from 0-180. You can't turn in 270 degrees. You can find the source and further documentation here <a href=""https://github.com/DrBubble/ArduinoOS"" rel=""nofollow noreferrer"">https://github.com/DrBubble/ArduinoOS</a>.</p>

<p>This example code should do exactly what you want when running under the ArduinoOS.</p>

<pre><code>#include ""KernelInitializer.h""
#include ""Servo.h""
#include ""Led.h""

void setup()
{
    KernelInitializer::InitializeKernel(mainThread);
}

void mainThread()
{
    InitTask(secondThread);
    while (true)
    {
        Led led(2); // replace 2 with the pin of your led
        while (true)
        {
            led.TurnOn();
            sleep(1000);
            led.TurnOff();
            sleep(1000);
        }
    }
}

void secondThread()
{
    Servo servo(9); // replace 9 with the pin of your servo
    while (true)
    {
        servo.SetValue(45);
        sleep(1000);
        servo.SetValue(90);
        sleep(1000);
        servo.SetValue(180);
        sleep(1000);
    }
}
</code></pre>
",,51052223,90
40685976,2,40674107,2016-11-18T21:09:38.610,0,,7179161,,2016-11-18T21:09:38.610,,0,,"<p>Theoretically it should be possible to shrink it to something like this. Note you should use an array instead of a series of guess1, guess2, … variables.</p>

<pre><code>int guess[4];

if ((buttonState != lastButtonState) &amp;&amp; buttonState == 1) {
  guess[turn-1] = newValue;
  if (turn == 4)
  {
      gok4 = nieuwewaarde;
      beurt = 5;
  }
  else
      turn = turn+1;
  Printer();
}
lastButtonState = buttonState;
</code></pre>

<p>You can adjust the +1/-1 if you count turn from 0. But with a broader view of what you would like to achieve, there might be other ways to write things.</p>

<p>Besides, Arduino code is not in C++, but AVR. The “user” code is Processing.</p>
",,51055140,158
40676555,2,40676459,2016-11-18T11:56:15.983,7,,576719,,2016-11-18T11:59:26.723,2016-11-18T11:59:26.723,1,,"<p><code>Double</code> is 8 bytes in size in pascal. use <code>Single</code> which is 4 bytes.</p>

<pre><code>TFloatUint = packed record
   case Boolean of
     False: (dabSingle: Single);
     True: (dabByte: packed array[0..3] of cuint8);
 end;
</code></pre>
",,51058615,609
40676565,2,40676459,2016-11-18T11:56:39.537,5,,505088,,2016-11-18T11:56:39.537,,1,,"<p>C <code>float</code> is a 4 byte single precision floating point type. Pascal <code>Double</code> is 8 byte double precision. You used the wrong type in other words. It should be:</p>

<pre><code>TFloatUint = record
   case Boolean of
     False: (Temperature: Single);
     True: (bytes: array[0..3] of cuint8);
 end;
</code></pre>

<p>Note also that you should not pack the record. Not that it has any impact on the layout, but it will lead to the type having the wrong alignment value. And I see no reason to pack the array either. </p>

<p>For reasons unknown to me, Pascal programmers the world over seem to have a tendency to want to pack things that should not be packed.</p>
",,51081508,710
40705325,2,40686422,2016-11-20T14:39:36.957,3,,5107799,,2020-02-10T15:20:23.500,2020-02-10T15:20:23.500,0,,"<p>Got it. The Problem was the setting of PKG_CONFIG-vars within the rpi-toolchain.cmake file, this does not work .They have to be added to the environment with export:</p>

<pre><code>...
export PKG_CONFIG_SYSROOT_DIR=${MOUNT_DIR}
export PKG_CONFIG_LIBDIR=${MOUNT_DIR}/usr/lib/arm-linux-gnueabihf/pkgconfig:${MOUNT_DIR}/usr/share/pkgconfig:${MOUNT_DIR}/usr/lib/pkgconfig
export PKG_CONFIG_DIR=

cmake -D CMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE -D PIROOT=$MOUNT_DIR -D TOOLROOT=$TOOLCHAIN -D CMAKE_BUILD_TYPE=Release -D WITH_V4L=ON -D WITH_OPENGL=ON ..
make -j $(nproc)
</code></pre>

<p>edit: I don't remember what the actual problem was here, but setting pkg-config variables with <code>ENV{}</code> works and was not the culprit.</p>
",,51083259,46
40708590,2,40700514,2016-11-20T19:43:52.237,9,,3820025,,2016-11-22T18:25:48.467,2016-11-22T18:25:48.467,5,,"<p>You are using the wrong ISR as @andars has pointed out correctly. In CTC ""Clear Timer on Compare"" mode the timer will never overflow as it will be cleared on compare match.</p>

<p>So you enabled the wrong interrupt of the timer as well. Bit 1 of TIMSK register enables timer overflow interrupt on timer0. That won't be triggered because of the previous reason. Taken from <a href=""http://www.atmel.com/images/atmel-2586-avr-8-bit-microcontroller-attiny25-attiny45-attiny85_datasheet.pdf"" rel=""nofollow noreferrer"">datasheet</a>.</p>

<p><a href=""https://i.stack.imgur.com/K95Yw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/K95Yw.png"" alt=""enter image description here""></a></p>

<p>As you are using <code>OCR0A</code> to set the compare value, you have to enable  <strong>Bit 4 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable</strong>.</p>

<p>Back to the ISR, you need the <code>ISR(TIMER1_COMPA_vect)</code> or <code>ISR(TIMER1_COMPB_vect)</code> depending on which bit you set in TIMSK. Note that the compare value should be written into the matching registers as well, <code>OCR0A</code> or <code>OCR0B</code>.</p>

<hr>

<p><strong>Note that</strong>, you can use the bit names in your code just like the register names, in my opinion it makes the code more transparent.</p>

<p>Your code should be changed as follows to enable the corresponding interrupt:</p>

<pre><code>void timer0_init( void )
{
    cli();          
    TCCR0B |= (1&lt;&lt;CS01) | (1&lt;&lt;CS00);   //clock select is divided by 64.
    TCCR0A |= (1&lt;&lt;WGM01);              //sets mode to CTC
    OCR0A = 0x7C;                      //sets TOP to 124 so the timer will overflow every 1 ms.    
    TIMSK |= (1&lt;&lt;OCIE0A);              //Output Compare Match A Interrupt Enable
    sei();                             //enable global interrupts
}
</code></pre>

<p>The ISR:</p>

<pre><code>ISR(TIMER0_COMPA_vect)
{
    cli();
    //ticks ++;
    PORTB |= ( 1 &lt;&lt; PORTB0 );   
    sei();
}
</code></pre>
",,51087056,630
40742403,2,40701003,2016-11-22T12:53:15.553,1,,6587083,,2016-11-22T12:53:15.553,,0,,"<p>Find the answer </p>

<pre><code>pstmt = con-&gt;prepareStatement(""SELECT * FROM `raspberry_cli` WHERE `Cli_id` = (?) AND `Cli_Group` = (?)"");
pstmt-&gt;setString(1, id);
pstmt-&gt;setString(2, group);

res = pstmt-&gt;executeQuery();

[delete pstmt;]      //===================&gt; This part is missing
</code></pre>

<p>in this section i didn't delete pstmt(sql::preparestatement*)
so the sql have send that malloc error.</p>

<p>So Be careful about allocating memory.</p>
",,51100805,144
40714022,2,40710938,2016-11-21T06:27:15.217,1,,3082873,,2016-11-21T06:27:15.217,,3,,"<p>Yo can stream an HTML file from SPIFFS. Here is an <a href=""https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WebServer/examples/FSBrowser/FSBrowser.ino"" rel=""nofollow noreferrer"">example</a> :</p>

<p>You need to get <strong>streamFile()</strong> function as denoted below : </p>

<pre><code>  String contentType = ""text/html"";
  if(SPIFFS.exists(path)){
    File file = SPIFFS.open(path, ""r"");
    size_t sent = server.streamFile(file, contentType);
    file.close();
    return true;
  }
</code></pre>
",,51111377,45
40780421,2,40710938,2016-11-24T07:34:28.337,0,,2317490,,2016-12-22T13:58:32.663,2016-12-22T13:58:32.663,0,,"<p>You might want to consider cleaning it up to use an unescaped multi-line syntax:</p>

<pre><code>void handleAbout() {
    const char* message = R""foo(
    &lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""UTF-8""&gt;
        &lt;title&gt;test&lt;/title&gt;
     &lt;link rel=stylesheet type=text/css href='//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css' /&gt;
    &lt;/head&gt;&lt;body class=container&gt;
    &lt;h1&gt;testing&lt;/h1&gt;
    &lt;main&gt;
     &lt;h3&gt;Status&lt;/h3&gt;
      &lt;ul&gt;
      &lt;li&gt;Mode: &lt;b&gt;[[MODE]]&lt;/b&gt;
       &lt;li&gt;&lt;a href=/reset &gt;reboot device&lt;/a&gt;
      &lt;/ul&gt;
    &lt;/main&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    )foo"";

    String message2= String(message);
    // templating replaces string-concat functionality:
    message2.replace(""[[MODE]]"", String(inputMode));
    // prove it's a usable String to the esp:
    server.send(200, ""text/html"", message2);
} // end about section handler
</code></pre>

<p>You can also use any online text-to-json encoder to make C-friendly escaped String literals from arbitrary text. ex: <a href=""http://danml.com/slim/"" rel=""nofollow noreferrer"">my slim's ""JSON.stringify""</a> engine transform...</p>
",,51147145,114
40713161,2,40712305,2016-11-21T05:09:32.443,0,,4577640,,2017-03-21T04:47:46.247,2017-03-21T04:47:46.247,2,,"<p>Try this: </p>

<p>Edit: I just edited displaying of voltage, because value was int. But principe would be same.</p>

<pre><code>int main (void){

    adcinit();

    lcd_init();//initializes LCD
    lcd_clear();//clear screen
    lcd_home();


    uint16_t value;
    float volts;
    while(1){
        ADCSRA |= (1&lt;&lt;ADSC);//start ADC conversion
        delay_ms(54);//delay 54 millisecond
        value = ADCW;//assign ADC conversion to value
        volts=(float)(value*5)/1023;
        lcd_goto_xy(0,0);// coordinates of the cursor on LCD Display
        lcd_printf(""ADC Value: %d "",value);//display on LCD
        lcd_goto_xy(0,1);// coordinates of the cursor on LCD Display
        lcd_printf(""Volts: %.2f "",volts);//display on LCD
    }
}
</code></pre>
",,51215229,717
40744831,2,40712305,2016-11-22T14:44:57.270,1,,5799798,,2016-11-25T16:43:15.240,2016-11-25T16:43:15.240,3,,"<p>I'm answering the question in the LAST sentence of the original post - not the heading. But this is the right answer for your project.</p>

<p>You say ""I only need 2 decimal places"" - so this should tell you that there's no need for floating point maths. Physicists and engineers need floats to represent very, very small or very, very large quantities, but you need ""fixed point"" - which means doing integer maths and choosing your units correctly. Fixed point is quicker, more accurate and reduces the size of your compiled binary, as there's no need for the floating point code.</p>

<p>The simplest solution is to use integers and display millivolts, in the same way that the delay() function you've just used takes an argument of an integer number of milliseconds, not a fractional number of seconds.</p>

<pre><code>#define VREF 5000
uint32_t mvolts;
.
.
mvolts=(value*VREF)&gt;&gt;10; // No floats here...
lcd_printf(""milliVolts: %d"",mvolts); // ...and no casts
</code></pre>

<p>If you must display volts, then this does the trick:</p>

<pre><code>lcd_printf(""Volts: %d.%02d "",mvolts/1000, (mvolts%1000)/10);
</code></pre>

<p>Notice, by the way, that mvolts is a 32 bit integer, because you're now multiplying a 10 bit number by 5000 and that won't fit into 16 bits. This is needed because you need to preserve the accuracy of the value while doing the scaling. I don't think this is heading off-topic, as I take it that you do want to display the <em>correct</em> value or there's no point in displaying those two decimal places.</p>

<p>Unless you're careful, the compiler will work out the value of 5000/1024 - 4.8828125 - and then do integer arithmetic, which cuts off the fractional part and ends up multipliying your ADC result by 4. To guarantee the correct behaviour, multiply by 5000 then divide - 2 separate operations. As 1024 is 2**10, shifting right by ten bits is identical to dividing by 1024.</p>

<p>Finally - don't assume that reading 1023 from the ADC actually means 5.000 volts to 4 significant figures; calibrate against a tested voltmeter by tweaking <code>#define VREF</code> to get the right result.</p>
",,51270065,728
40749835,2,40749737,2016-11-22T19:11:24.650,2,,7085711,,2016-11-22T19:11:24.650,,0,,"<p>After the first iteration of your while loop, you close the file and never open it again for editing.  When you try to append to a file that is closed, you get an error.  You could instead move the open statement inside your loop like so:</p>

<pre><code>while 1:
    line=ser.readline()
    messagefinal1 = message1 + line + message2
    print(line)
    file = open('index.html', 'a+')
    file.write(messagefinal1)
    file.close()
</code></pre>
",,51275675,31
40751020,2,40750984,2016-11-22T20:28:38.863,0,,6287472,,2016-11-22T20:30:57.473,2016-11-22T20:30:57.473,2,,"<p>You're not using the proper operator in your <code>if</code> statements.  Change your if statement to this...</p>

<pre><code>if (n==0){
  note = song[y]; 
  Serial.print(song[y]) ;
}
else if(n==1){
  dur = song[y+1];
}
</code></pre>
",,51297371,2184
40907541,2,40906704,2016-12-01T10:00:09.773,3,,3125194,,2016-12-01T12:58:32.623,2016-12-01T12:58:32.623,1,,"<p>As pointed before enum constants are basically integer constants. They do not take space themself, they are not listed somewhere in the executable code. </p>

<p>However if you use enum type for defining a variable, then the variable probably takes as much space as an int variable. If you need to save this space you can use any other integer type able to store the necessary range. For example, instead of:</p>

<pre><code>enum state {S1, S2, S3, S4};

enum state stack[1000];
...
stack[i] = S2;
... 
</code></pre>

<p>you can write:</p>

<pre><code>enum state {S1, S2, S3, S4};
typedef unsigned char my_state_type;

my_state_type stack[1000];
...
stack[i] = S2;
...
</code></pre>
",,51331486,418
40935165,2,40935080,2016-12-02T15:02:03.507,1,,6313992,,2016-12-02T15:02:03.507,,0,,"<p>Do not delete <code>current_mills</code> in destructor. You should only delete dynamically asigned variables. In other words, if you create object with new you delete it with delete in 1:1 ratio.</p>

<p>As for second error, there is no <code>setCurrentMills()</code> function defined inside <code>timelyCall</code> class. </p>

<p>You have to modify class definition:</p>

<pre><code>class timelyCall {
  public:
    timelyCall();
    ~timelyCall();
    unsigned long current_millis;
    void setCurrentMills();
    void callEvery(void (&amp;f)(), int ms);
  };
</code></pre>

<p>and then change function definition to be <code>void timelyCall::setCurrentMills()</code>.</p>

<p>Also it is a standard to pass a value you want to assign to function <code>set</code>. So it would be really beneficial for possible future modification to change this signature to <code>void setCurrentMills(const unsigned long&amp; mills);</code> and instead of assigning return value of funcion <code>mills()</code> to <code>current_mills</code>, call setter with return value of this function like this <code>object.setCurrentMills(mills());</code></p>
",,51371559,384
40938015,2,40937980,2016-12-02T17:39:20.437,2,,598696,,2016-12-02T17:50:39.123,2016-12-02T17:50:39.123,1,,"<pre><code>bool all_are(int* i_begin, std::size_t sz, int x)
{
    const int* i_end = i_begin + sz;
    for(; i_begin != i_end; ++i_begin)
        if(*i_begin != x) return false;

    return true;
}
</code></pre>

<p></p>

<pre><code>if (all_are(my_array, arraySize, -1))
   //do something
else if (all_are(my_array, arraySize, 1))
  //do something else
</code></pre>
",,51421763,181
40938863,2,40937980,2016-12-02T18:33:47.960,1,,5329483,,2016-12-02T18:33:47.960,,0,,"<p>Check first if all entries are the same and then <code>switch()</code>:</p>

<pre><code>for (int i=1; i&lt;arraysize; i++)
   if (theArray[0] != theArray[i]) return ""no way"";

/*** All array elements are the same, so we can evaluate any element ***/

switch (theArray[0]) 
{
   case 0:
        return ""All are zero"";
   case 1:
        return ""All are one"";
   default:
        return ""All elements are the same"";
}
</code></pre>
",,51525070,603
41068291,2,40959004,2016-12-09T20:23:01.653,0,,7028160,,2016-12-09T20:23:01.653,,0,,"<p>There is a simple solution to solve the given traffic lights sample.</p>

<p>Instead of calling the delay function you could call your special delay-function:</p>

<pre><code>int globalFlagSomeonePressedBeam = false;  // store global if someone pushed the beam button

void delay_and_check_for_beam (int msDelay) {
    for (int i=0; i&lt;msDelay; ++i) {
        if(digitalRead(beam)==HIGH){ // check beam button
            globalFlagSomeonePressedBeam = true; // store information
        }
        delay(1);
    }
}
</code></pre>

<p>Between the calls to your delay function you set the right lights (digital outs)
After you check your globalFlagSomeonePressedBeam you need to set it back to false</p>
",,51527458,670
51408145,2,40959004,2018-07-18T17:47:34.150,0,,1033581,,2018-07-18T17:47:34.150,,0,,"<p><em>Solution by OP.</em></p>

<pre><code>unsigned long curGoStopDuration, defGoStopDuration = 5000, maxGoStopDuration = 30000;
unsigned long currentMillis;

#pragma region SensorFields
int durationIncrement = 2500;
unsigned long greenPrevMillis;
float DetectionTime = 2500;
bool triggered;
#pragma endregion

enum LightState { Green, Yellow, Red };

class Stoplight
{
private:
    int greenLed, yellowLed, redLed;
    unsigned long previousMillis;
    float CurInterval;
    LightState state;
public:
    unsigned long GreenDuration = 5000;
    unsigned long RedDuration = 5000;
    int YellowDuration = 1000;

    Stoplight(int gLed, int yLed, int rLed) :greenLed(gLed), yellowLed(yLed), redLed(rLed)
    {
        pinMode(greenLed, OUTPUT);
        pinMode(redLed, OUTPUT);
        pinMode(yellowLed, OUTPUT);
    }

    void Loop()
    {
        if (currentMillis - previousMillis &gt;= CurInterval)
        {
            previousMillis = currentMillis;
            //Transitions
            switch (state)          
            {
                case Green:             
                    ToYellow();
                    break;
                case Yellow:
                    ToRed();
                    break;
                case Red:
                    ToGreen();
                    break;
            }
        }
    }

    void ToGreen()
    {
        digitalWrite(redLed, LOW);
        digitalWrite(greenLed, HIGH);
        CurInterval = GreenDuration - YellowDuration;
        state = Green;
    }

    void ToYellow()
    {
        digitalWrite(greenLed, LOW);
        digitalWrite(yellowLed, HIGH);
        CurInterval = YellowDuration;
        state = Yellow;
    }

    void ToRed()
    {
        digitalWrite(yellowLed, LOW);
        digitalWrite(redLed, HIGH);
        CurInterval = RedDuration;
        state = Red;
    }

};

Stoplight SL_01(2, 3, 4), SL_02(5, 6, 7);
int beamSensor = 8;

void setup()
{
    //Set default values
    curGoStopDuration = defGoStopDuration;

    SL_01.ToGreen();
    SL_02.ToRed();

    pinMode(beamSensor, INPUT);
    Serial.begin(9600);
}

void loop()
{
    currentMillis = millis();
    Sensor();

    //Manipulate durations
    SL_01.GreenDuration = curGoStopDuration;
    SL_02.RedDuration = curGoStopDuration;
    SL_01.Loop();
    SL_02.Loop();
}

void Sensor()
{
    //If sensor detects something
    if (digitalRead(beamSensor) == HIGH)
    {
        if (!triggered)
        {
            greenPrevMillis = currentMillis;
            triggered = true;
        }

        if (currentMillis - greenPrevMillis &gt;= DetectionTime)
        {

            if(curGoStopDuration &lt; maxGoStopDuration)
                curGoStopDuration += durationIncrement; //Add seconds

            greenPrevMillis = currentMillis;

            Serial.print(""Green light duration is now: "");
            Serial.println(curGoStopDuration);
        }
    }
    else  //No detection
    {
        curGoStopDuration = defGoStopDuration;
        triggered = false;
    }
}
</code></pre>
",,51531033,853
41050962,2,41050308,2016-12-08T23:59:19.797,3,,5120331,,2016-12-08T23:59:19.797,,0,,"<p>I tried to quickly search if there was anything online that maybe you had missed and I couldn't find much other than the source code for the MeMegaPi library (<a href=""https://github.com/Makeblock-official/Makeblock-Libraries/tree/master/makeblock/src"" rel=""nofollow noreferrer"">https://github.com/Makeblock-official/Makeblock-Libraries/tree/master/makeblock/src</a>)</p>

<p>They also refer you back to the MegaBlocks website for more info which I guess you already did. So I'll explain a bit of what's going on here, though for the future, using the API will require you to read the source and that can be a bit daunting if you aren't familiar with C/C++. Anyway here goes:</p>

<pre><code>MeEncoderOnBoard Encoder_1(SLOT1);
MeEncoderOnBoard Encoder_2(SLOT2);
void isr_process_encoder1(void)
</code></pre>

<p>First we have the instantiation of the Encoders to SLOT1 and SLOT2 for MeEncoderOnBoard Encoder_1 and MeEncoderOnBoard Encoder_2 respectively. SLOT1 and SLOT2 are aliases for connection 1 and connection 2 (/src/MePort.h) on your device (some kind of multi-pin cable I'd guess). These encoders also encode actions as we will see soon.</p>

<pre><code>void isr_process_encoder1(void)
{
  if(digitalRead(Encoder_1.getPortB()) == 0)
  {
    Encoder_1.pulsePosMinus();
  }
  else
  {
    Encoder_1.pulsePosPlus();;
  }
}
void isr_process_encoder2(void)
{
  if(digitalRead(Encoder_2.getPortB()) == 0)
  {
    Encoder_2.pulsePosMinus();
  }
  else
  {
    Encoder_2.pulsePosPlus();
  }
}
</code></pre>

<p>Then we make the interrupt routines isr_process_encoder#s 1 and 2 for these encoders. For both we are reading port B (a pin on the connection slot) and performing an increment/decrement (depending on the value on portB) on what they call the pulse position.</p>

<pre><code>void setup()
{
  attachInterrupt(Encoder_1.getIntNum(), isr_process_encoder1, RISING);
  attachInterrupt(Encoder_2.getIntNum(), isr_process_encoder2, RISING);
  Serial.begin(115200);
</code></pre>

<p>In setup(), we attach the interrupt routines to the encoders and tell them to trigger on a rising-signal interrupt. After both encoders are set with interrupt handlers, we initiate serial communication on the arduino device with a baud-rate of 115200. </p>

<pre><code>  //Set PWM 8KHz
  TCCR1A = _BV(WGM10);
  TCCR1B = _BV(CS11) | _BV(WGM12);
  TCCR2A = _BV(WGM21) | _BV(WGM20);
  TCCR2B = _BV(CS21);
</code></pre>

<p>The next 4 lines of code is a bit of magic. The reasoning (as the comment suggests) is to set the PWM rate at 8KHz for what I'm assuming is the motors. The _BV is apparently how arduino sets bit values at low-level (making a big guess here)? Not too sure about this actually but I trust the people making this did their homework.</p>

<pre><code>  Encoder_1.setPulse(7);
  Encoder_2.setPulse(7);
  Encoder_1.setRatio(26.9);
  Encoder_2.setRatio(26.9);
  Encoder_1.setPosPid(1.8,0,1.2);
  Encoder_2.setPosPid(1.8,0,1.2);
  Encoder_1.setSpeedPid(0.18,0,0);
  Encoder_2.setSpeedPid(0.18,0,0);
}
</code></pre>

<p>Now... admittedly, I have no idea what the numbers in setPulse, setRatio, setPosPid, or setSpeedPid represent... I hope that some kind of documentation for your PID motor is available because this is magic to me too. However these function calls are just setting these attributes on the Encoder objects (wish I had more to say :[)...</p>

<pre><code>void loop()
{
  if(Serial.available())
  {
    char a = Serial.read();
    switch(a)
    {
</code></pre>

<p>Next we have the main program loop. Starting off, we check if there is a Serial connection we can listen to. If yes, then we read a byte from the serial connection. if the byte we read corresponds to any case, we set the speeds on the Encoders as appropriate. </p>

<pre><code>  Encoder_1.loop();
  Encoder_2.loop();
</code></pre>

<p>After this switch block, we perform the loop() call on our Encoders. According to the source, this is actually an update step where our settings are actually relayed to the device we are communicating with (I've been assuming it's a pair of motors).</p>

<pre><code>  Serial.print(     ""Speed 1:\t"");
  Serial.print(Encoder_1.getCurrentSpeed());
  Serial.print(""    \t Speed 2:\t"");
  Serial.println(Encoder_2.getCurrentSpeed());
}
</code></pre>

<p>Finally, we print out the speeds of the motors and then loop routine continues to do this [Read->Update->Print] cycle</p>

<p>Sorry I can't be more help with this, but this is all I can give you. good luck and I hope you can find documentation! I'm back off to work in my boring non-embedded programming job ;)</p>
",,51535285,73
41073288,2,41073027,2016-12-10T07:37:48.733,0,,2742717,,2016-12-10T07:37:48.733,,0,,"<p>The protocol is same, how it can be in conflict. Practically, API is close to BSD \ POSIX, you just need make sure to intialise WinSocks with special call and cleanup it at end</p>

<pre><code>WSADATA            wsaData;
if( WSAStartup(MAKEWORD(2,2), &amp;wsaData) != 0)
{
    printf(""Server: WSAStartup failed with error %ld\n"", WSAGetLastError());
    return -1;
}
else
    printf(""Server: The Winsock DLL status is %s.\n"", wsaData.szSystemStatus);
</code></pre>

<p>Call WSACleanup();  when app doesn't need sockets anymore (before exit?) There is more to Winsock's than that</p>
",,51545872,683
41075677,2,41075482,2016-12-10T12:46:36.470,0,,4057102,,2016-12-10T12:58:48.367,2016-12-10T12:58:48.367,0,,"<p>You need to use PROGMEM directly. The <code>F()</code> macro is code that requires a function.</p>

<p>You can then cast the char pointer to a <code>__FlashStringHelper*</code> when needed.</p>

<pre><code>class FTester{
  private:
    const char* Label;

  public:
    FTester( const char *pstr ): Label(pstr){};
    void print(){ Serial.println( (const __FlashStringHelper*) Label ); };
};


const char str[] PROGMEM = ""FString-TestingTesting123"";

FTester FS(str);

void setup() {
  Serial.begin(9600);
}

void loop() {
  FS.print();
}
</code></pre>

<h2>EDIT:</h2>

<p>Oh, and the above is how you could do it if <code>FS</code> is a global variable, like your example. If it was a local variable, the <code>F()</code> macro could be used.</p>

<pre><code> class FTester{
  private:
    const __FlashStringHelper* Label;

  public:
    FTester( const __FlashStringHelper* pstr ): Label(pstr){};
    void print(){ Serial.println( Label ); };
};

void setup() {
  Serial.begin(9600);
}

void loop() {
  FTester FS(F(""FString-TestingTesting123""));
  FS.print();
}
</code></pre>
",,51559653,210
41080636,2,41075482,2016-12-10T21:44:39.223,-2,,6571733,,2016-12-10T21:44:39.223,,3,,"<p>Awesome thanks for your help.  It turns out the way I want my code written Im using global variables.  I also want to pass the string as an argment rather than defining a separate variable.</p>

<p>I ended up taking a different approach where I store the information into PROGMEM in the object constructor.  This has the needed effect of storing the data into PROGMEM and saving SRAM.</p>

<pre><code>class FTester{
  private:
    const char* Label PROGMEM;

  public:
    FTester(const char* _Label): Label(_Label){};
    void print(){ Serial.println(Label); };
};

FTester FS(""FString-TestingTesting123"");

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);

}

void loop() {
  // put your main code here, to run repeatedly:
  FS.print();
}
</code></pre>
",,51598345,62
41097378,2,41093085,2016-12-12T09:07:55.623,2,,3861548,,2016-12-12T09:07:55.623,,0,,"<p>In this case you could use two methods, not so clean neither elegant but works for this.</p>

<p><strong>Method one:</strong> pass <code>NULL</code> and check it inside.</p>

<pre><code>bool readPacket(unsigned long timeout, waitCallback cb) {   
    long time = millis();
    unsigned long delta = 0;
    while(delta &lt; timeout) {
        if(receivedPacket()) {
            return true;
        }
        delta = millis() - time;
        if(cb!=null){
            cb(delta);
        }
    }
    return false;
}
</code></pre>

<p><strong>Method two:</strong> defining a function without parameter. It use the method one implicitly.</p>

<pre><code>bool readPacket(unsigned long timeout){
    return readPacket(timeout, NULL);
}
</code></pre>

<p>Using second method you could make some generic functions that match with other specifications. You could pass other type of parameters and implictly cast them, add other parameters to make a preprocess, check errors...</p>
",,51609813,3661
41189916,2,41189302,2016-12-16T17:55:27.473,0,,7307940,,2016-12-16T18:15:06.377,2016-12-16T18:15:06.377,0,,"<p>Right here, in your code</p>

<pre><code>    float temperature, humidity;

    humidity = dht.readHumidity();
    temperature = dht.readTemperature();
    delay(2000); 
</code></pre>

<p>add the condition</p>

<pre><code>    float temperature, humidity;

    humidity = dht.readHumidity();
    temperature = dht.readTemperature();

    temperature = (temperature &lt; 5)?40:temperature;

    delay(2000); 
</code></pre>
",,51666435,45
41230421,2,41189302,2016-12-19T20:23:23.210,0,,7047790,,2016-12-19T20:23:23.210,,0,,"<p>Here is a more begineer friendly method of doing this:</p>

<pre><code>float temperature, humidity;

humidity = dht.readHumidity();
temperature = dht.readTemperature();

  if(temperature &lt; 5)
  {
    //code to display 40 on lcd screen
  }

delay(2000); 
</code></pre>
",,51740716,470
41219986,2,41218617,2016-12-19T10:00:37.083,0,,3436922,,2016-12-19T13:41:53.517,2016-12-19T13:41:53.517,0,,"<p>You are sending uninitialized data to your slave SPI device.</p>

<pre><code>unsigned char buff[100];

while (1)
{
    int ret = wiringPiSPIDataRW(chan, buff, 4);
    printf(""%d %s \n"", ret, buff);

}
</code></pre>

<p><code>buffer</code> content is indeterminate.</p>

<p>Looking at the <a href=""http://wiringpi.com/reference/spi-library/"" rel=""nofollow noreferrer"">library doc</a></p>

<blockquote>
  <p><strong>int wiringPiSPIDataRW (int channel, unsigned char *data, int len);</strong></p>
  
  <p>This performs a simultaneous write/read transaction over the selected SPI bus. <strong>Data that was in your buffer is overwritten by data returned from the SPI bus.</strong></p>
</blockquote>

<p>It means you should init your buffer with message to send. This data will be lost because of slave reply will be returned into the same buffer.</p>

<p>Looking at <a href=""https://gist.github.com/Jotschi/3659646"" rel=""nofollow noreferrer"">this example</a> you should do sometning like:</p>

<pre><code> unsigned char buff[100] = {0};

 // Following bytes must be set according to your slave SPI device docs.
 buffer[0] = ??; 
 buffer[1] = ??;
 buffer[2] = ??;
 buffer[3] = ??;
 wiringPiSPIDataRW(chan, buffer, 4);
</code></pre>
",,51787696,1071
41244787,2,41244560,2016-12-20T14:36:29.253,2,,7135101,,2016-12-20T17:48:06.913,2016-12-20T17:48:06.913,6,,"<p>You can use some boolean in IF statement, like this:</p>

<pre><code>bool ABC = true;

void loop() {
    if(ABC) {
        abc();
        ABC = false;
    }
}
</code></pre>

<p>I hope it's help.</p>

<p>Yoav</p>
",,51808029,1061
41281008,2,41266450,2016-12-22T10:30:53.143,0,,3368201,,2016-12-22T10:30:53.143,,6,,"<p>DISCLAIMER: I wanted to post this as a comment, not an answer, because in my opinion it does not solve the problem but just gives advices. Then I needed some code blocks, so I needed the answer features.</p>

<p>Well, your code IMHO needs some improvements (or maybe that's just because you reduced it, but anyway I'll post them for you)</p>

<ol>
<li>Don't put the function implementation in the header file: use a cpp file to store the functions implementation and the header file to store the prototypes</li>
<li>The purpose of the inheritance is to reuse the majority of the code you already have in common. So it's meaningless to have a lot of different variables; much better to declare them differently.</li>
</ol>

<p>For instance you can use it like this:</p>

<pre><code>/* File State.h */

class MachineState{
    public: 
        int getNumber();
    protected:
        String statusName;
        int number;
};

/////////////////////ACTIVE FULL/////////////////////////////////
class ActiveFull : public MachineState
{
    public:
        ActiveFull();
};

////////////////////////////// ACTIVE EMPTY ////////////////////
class ActiveEmpty : public MachineState
{
    public:
        ActiveEmpty();
};

/* File State.cpp */

int MachineState::getNumber(){
    return this-&gt;number;
}

ActiveEmpty::ActiveEmpty(){
    this-&gt;number=1;
};

ActiveEmpty::ActiveEmpty(){
    this-&gt;number=2;
};
</code></pre>

<p>or, if you don't have to change the value of number (and so you don't need a real variable)</p>

<pre><code>/* File State.h */

class MachineState{
    public: 
        virtual int getNumber() = 0;
    protected:
        String statusName;
};

/////////////////////ACTIVE FULL/////////////////////////////////
class ActiveFull : public MachineState
{
    public:
        virtual int getNumber();
};

////////////////////////////// ACTIVE EMPTY ////////////////////
class ActiveEmpty : public MachineState
{
    public:
        virtual int getNumber();
};

/* File State.cpp */

int ActiveEmpty::getNumber(){
    return 1;
};

int ActiveEmpty::getNumber(){
    return 2;
};
</code></pre>

<p>Then there is a small problem with the deallocation: if the <code>new</code> fails, you will get problems at the next <code>delete</code>. To solve this, you can do something like (and I've also shortened your code a bit)</p>

<pre><code>void *StateFactory::changeStatus(int choice)
{
    if (this-&gt;currentState) // If it was correctly allocated
        delete this-&gt;currentState;  // to prevent memory leak
    switch (choice)
    {
    case 1:
        this-&gt;currentState = new ActiveFull();
        break;
    case 2: // case 2 can be removed since it is identical to default
        this-&gt;currentState = new ActiveEmpty();
        break;
    default:
        this-&gt;currentState = new ActiveEmpty();
        break;
    }
}
</code></pre>

<p>That said... Well, I'd modify the loop this way:</p>

<pre><code>void printCurrentStateNumber()
{
    if (CurrentStateFactory.getCurrentState())
        Serial.println(CurrentStateFactory.getCurrentState()-&gt;getNumber());
    else
        Serial.println(""No more memory"");
}

void loop() {
    Serial.print(F(""Free RAM = "")); 
    Serial.println(freeMemory(), DEC);  // print how much RAM is available.
    CurrentStateFactory.changeStatus(1);
    printCurrentStateNumber();
    CurrentStateFactory.changeStatus(2);
    printCurrentStateNumber();
}
</code></pre>

<p>This is to test if the state was successfully created.</p>

<p>As for your explicit problem, I don't know how the library function works. Before starting to understand why there is this leak, I'd try to figure out if this is really a leak. So start the modified program (with the test before delete and the print of the no more memory string) and let it run until the library tells you that it run out of memory. If it stabilizes or it reaches 0 and does not print that, it's a library problem. On the other hand if the program halts printing the string it's a leak.</p>

<p>One sidenote: it's not a good habit to let a small microcontroller perform allocations and deallocations too often, since it has a limited memory. Do the test, because if there is a real leak maybe it should be investigated more, but for your application I suggest you to think about permanently allocating two instances of the object and then just use them according to the value you passed it before - obviously if there are only a couple of derived classes), like this:</p>

<pre><code>/* In the header file */
#define NUM_OF_STATES 2

class StateFactory{
private:
    MachineState states[NUM_OF_STATES];
public: 
    StateFactory();
    void changeStatus(int choice); // factory
    MachineState *getCurrentState();
private:
    int currentIdx;
};

/* In the source file */

StateFactory::StateFactory()
{
    states[0] = new ActiveFull();
    states[1] = new ActiveEmpty();
    this-&gt;currentIdx = 0;
}

MachineState *StateFactory::getCurrentState(){
    return states[this-&gt;currentIdx];
}

void StateFactory::changeStatus(int choice)
{
    switch (choice)
    {
    case 1:
        this-&gt;currentIdx = 0;
        break;
    case 2: // case 2 can be removed since it is identical to default
        this-&gt;currentIdx = 1;
        break;
    default:
        this-&gt;currentIdx = 1;
        break;
    }
}
</code></pre>

<p>FINAL NOTE: Revising the answer I found that your <code>changeStatus</code> function returns a <code>void *</code> instead of a <code>void</code>. You should definitely fix that, and MAYBE things will get fixed (in fact you are returning a pointer instead of nothing). But I'm not sure about that.</p>
",,51822921,1804
41430662,2,41266450,2017-01-02T17:03:55.820,1,,5283629,,2017-01-02T17:03:55.820,,2,,"<p>it seems like a destructor's problem,</p>

<p>I post a an implementation based on your code ..</p>

<pre><code>#ifndef State_h
#define State_h


/* MachineState Class */
class MachineState{
  public:
  virtual void test() = 0;
     MachineState(){
        number = 0;
        statusName = ""NULL"";
     }
     virtual ~MachineState(){
      Serial.println(""Destroy base"");
     }
     void setNumber(int n){
      number =  n;
     }
     void setStatusName(String some){
      statusName = some;
     }
     String getStatusName(){
      return statusName;
     }
     int getNumber(){
      return number;
     }
     virtual void print()const{
      Serial.println(""Class MS"");
     }
  protected:
      String statusName;
      int number;

};


/* ActiveFull Class */
class ActiveFull : public MachineState{
  public:
      ActiveFull(){
        x = ""Class AF"";
        setNumber(1);
      }
      void print()const{
        Serial.println(""Class AF""); 
      }
      void test(){}
      ~ActiveFull(){
       Serial.println(""Destroy AF"");
      }
  private:
    String x;
};


/* ActiveEmpty Class */
class ActiveEmpty : public MachineState
{
  public:
      void print()const{
        Serial.println(""Class EE""); 
      }
      ActiveEmpty(){
        x = ""Class EE"";
        setNumber(2);
      }
      void test(){}
      ~ActiveEmpty(){
          Serial.println(""Destroy EE"");
      }
  private:
    String x;
};

/* StateFactory Class */
class StateFactory{
    private:
      MachineState *currentState;
    public: 
      StateFactory();
      ~StateFactory(){
        Serial.println(""Ho distrutto StateFactory"");
      }
      void changeStatus(int choice); // factory
      MachineState *getCurrentState();
  };

StateFactory::StateFactory(){
  this-&gt;currentState=new ActiveFull(); 
}

MachineState *StateFactory::getCurrentState(){
  return this-&gt;currentState; 
 }


void StateFactory::changeStatus(int choice){
  if(this-&gt;currenState)
     delete  this-&gt;currentState;
  if (choice == 1){
      currentState = new ActiveFull();
    }
  else if (choice == 2){
      currentState = new ActiveEmpty();
    }
  else{
      currentState = new ActiveEmpty();
    }
}

#endif
</code></pre>

<p>This is my result with your main:</p>

<pre><code>...

2
Class EE
Free RAM = 7751
Destroy EE
Destroy base
1
Class AF
Destroy AF
Destroy base
2
Class EE
Free RAM = 7751
Destroy EE
Destroy base
1
Class AF
Destroy AF
Destroy base

...
</code></pre>
",,51838526,250
41280400,2,41279525,2016-12-22T10:00:12.473,0,,1382251,,2016-12-22T10:00:12.473,,0,,"<p>When the library function <code>balance.tare</code> completes, it will invoke your own function (aka <em>callback function</em>), which you provide to function <code>balance.tare</code> within that additional input argument.</p>

<p>You can think of this callback-mechanism concept as ""call me when you're done"".</p>

<hr>

<p>There are generally two ways to implement a callback-mechanism:</p>

<p><strong>Static Linkage:</strong></p>

<p>Function <code>balance.tare</code> invokes a function with a predefined (hard-coded) name.</p>

<p>You must implement a function of that name in your code.</p>

<p>Since the function-call and the function itself are necessarily located in different source files, the compiler has to assume that such function exists somewhere in the code, and leaves the address resolution to the linker (which will eventually replace it with a jump to the address of your function).</p>

<p><strong>Dynamic Linkage:</strong></p>

<p>Function <code>balance.tare</code> takes a function pointer as input, and invokes that function via the pointer (i.e., pushes input arguments if needed and jumps to the pointed function).</p>

<p>There is no symbol resolution at all - neither during compilation nor during linkage (you could say that the function-call is ""resolved"" during runtime).</p>

<p>This allows you to have function <code>balance.tare</code> invoking a different function every time you call it.</p>

<p>The only downside is perhaps an additional memory-read operation of the input argument which stores the address of your function, required in order to jump to that function.</p>

<p>This, instead of jumping to an already-known (constant) address.</p>

<p>But it is really platform-dependent, i.e., some HW architectures may execute this within a single instruction (just as any other function-call).</p>

<hr>

<p>In your case, the library owner chose the latter.</p>

<p>Usage example:</p>

<pre><code>void MyAfterTaredCallbackFunction(void)
{
    // Do some stuff
}

int main()
{
    ...
    balance.tare(100, MyAfterTaredCallbackFunction);
    ...
}
</code></pre>
",,51849401,98
41369608,2,41347474,2016-12-28T20:56:53.787,2,,5799798,,2016-12-28T20:56:53.787,2017-05-23T12:24:37.917,1,,"<p>You are missing what the error message actually says. The compiler is telling you that to assign the whole structure in one go needs a ""copy constructor"" which understands the volatile qualifier and there isn't one. Have a look at <a href=""https://stackoverflow.com/questions/5973427/error-passing-xxx-as-this-argument-of-xxx-discards-qualifiers"">this answer</a> for a discussion of what the error means.</p>

<p>But when you assign the individual elements of the structure one by one no copy constructor is needed and so the code works fine. Why are you ""trying to avoid"" this?</p>

<p>What you are expecting the volatile qualifier to do? In C/C++ it <strong>ONLY</strong> prevents the compiler from optimising away your variables or the code which uses them. Nothing more.</p>

<p>It wouldn't be useful to define a stock copy constructor for volatile structures, since your concurrency requirements will differ from everyone else's.</p>

<p>To guarantee that your structure elements are assigned consistently, you may need to disable interrupts, like this:</p>

<pre><code>cli();
inner.x0        = outer.x0 + 1;
inner.y0        = outer.y0 + 1;
inner.width     = 0;
inner.height    = outer.height - 2;
sei();
</code></pre>

<p>But you'll have to analyse precisely what you need and that's heading off topic. </p>
",,51874205,153
41377885,2,41376518,2016-12-29T10:34:36.850,2,,2002198,,2016-12-29T10:34:36.850,,1,,"<p>I suggest you use <code>i2c-dev</code> and <code>i2c-bcm2708</code> module, where you will have the i2c buses exposed to the /dev filesystem.</p>

<pre><code>$ sudo modprobe i2c-dev
$ sudo modprobe i2c-bcm2708
</code></pre>

<p>Now will will have i2c buses exported, list them with</p>

<pre><code>$ ls /dev/i2c-*
</code></pre>

<p>Using it is not that simple because it is i2c, it has different protocols and addresses.</p>

<p>If you are going to use it in C, this is the <a href=""https://www.kernel.org/doc/Documentation/i2c/dev-interface"" rel=""nofollow noreferrer"">tutorial</a>.</p>

<p>In python, you can install the <a href=""https://pypi.python.org/pypi/i2cdev"" rel=""nofollow noreferrer""><code>i2cdev</code></a> package and use it as this:</p>

<pre><code>from devi2c import I2C
device, bus = 0x42, 0
i2c = I2C(device, bus)
value = i2c.read(1)         # read 1 byte
i2c.write(b’some raw data’)     # write bytes
i2c.close()                 # close connection
</code></pre>
",,51886824,75
55837280,2,41390824,2019-04-24T19:31:53.393,0,,2522207,,2019-04-24T19:31:53.393,,0,,"<p>There was a point in Linux 2.something where nanosleep had a specific behavior for processes scheduled under a real-time policy like SCHED_FIFO or SCHED_RR where it would busy-wait when the specified sleep was below the minimum clock resolution or granularity, but it was removed. (Try man nanosleep, I believe this behavior is mentioned there).</p>

<p>I had a need to have a more precise sleep interval so I wrote my own version to call in those special cases. On the target machine I was able to get &lt; 10 µs delays with only occasional blips (see the comment in the code).</p>

<p>Just remember that for non-real-time scheduling policies, if your application tries to sleep for less than the minimum clock resolution, it may still be preempted.</p>

<p>Here is a little test program that I wrote to test this, the busy loop calls clock_gettime() so it knows when it's time to wake:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;signal.h&gt;


void usage(char *name, const char *msg)
{
    if ( msg )
        fprintf(stderr,""%s\n"",msg);
    fprintf(stderr,""Usage: %s, -s&lt;sleepNanoseconds&gt; [-c&lt;loopCount&gt;] [-e]\n"", name);
    fprintf(stderr,""  -s&lt;sleepNanoseconds&gt; is the number nanoseconds to busy-sleep, usually &lt; 60000\n"");
    fprintf(stderr,""  -c&lt;loopCount&gt; the number of loops to execute the busy sleep, default 1000000 \n"");
    fprintf(stderr,""  -e do not calculate min, max and avg. only elapsed time \n"");
}



# define tscmp(a, b, CMP)                             \
  (((a)-&gt;tv_sec == (b)-&gt;tv_sec) ?                         \
   ((a)-&gt;tv_nsec CMP (b)-&gt;tv_nsec) :                          \
   ((a)-&gt;tv_sec CMP (b)-&gt;tv_sec))
# define tsadd(a, b, result)                              \
  do {                                        \
    (result)-&gt;tv_sec = (a)-&gt;tv_sec + (b)-&gt;tv_sec;                 \
    (result)-&gt;tv_nsec = (a)-&gt;tv_nsec + (b)-&gt;tv_nsec;                  \
    if ((result)-&gt;tv_nsec &gt;= 1000000000)                          \
      {                                       \
    ++(result)-&gt;tv_sec;                           \
    (result)-&gt;tv_nsec -= 1000000000;                          \
      }                                       \
  } while (0)
# define tssub(a, b, result)                              \
  do {                                        \
    (result)-&gt;tv_sec = (a)-&gt;tv_sec - (b)-&gt;tv_sec;                 \
    (result)-&gt;tv_nsec = (a)-&gt;tv_nsec - (b)-&gt;tv_nsec;                  \
    if ((result)-&gt;tv_nsec &lt; 0) {                          \
      --(result)-&gt;tv_sec;                             \
      (result)-&gt;tv_nsec += 1000000000;                        \
    }                                         \
  } while (0)
///////////////////////////////////////////////////////////////////////////////
///
/// busySleep uses clock_gettime and a elapsed time check to provide delays
/// for less than the minimum sleep resolution (~58 microseconds). As tested
/// on a XEON E5-1603, a sleep of 0 yields a delay of &gt;= 375 Nsec, 1-360 about
/// 736 Nsec, 370-720 a little more than 1 Usec, 720-1080 a little less than
/// 1.5 Usec and generally it's pretty linear for delays of 10 Usec on up in
/// increments of 10 Usec, e.g., 10 Usec =~ 10.4, 20 Usec =~ 20.4 and so on.
///
///////////////////////////////////////////////////////////////////////////////
int busySleep( uint32_t nanoseconds )
{
    struct timespec now;
    struct timespec then;
    struct timespec start;
    struct timespec sleep;
    if ( nanoseconds &gt; 999999999 )
    {
        return 1;
    }
    clock_gettime( CLOCK_MONOTONIC_RAW, &amp;start);
    now = start;
    sleep.tv_sec = 0;
    sleep.tv_nsec = nanoseconds;
    tsadd( &amp;start, &amp;sleep, &amp;then );
    while ( tscmp( &amp;now, &amp;then, &lt; )  )
    {
        clock_gettime( CLOCK_MONOTONIC_RAW, &amp;now);
    }
    return 0;
}


int main(int argc, char **argv)
{
    uint32_t sleepNsecs = 1000000000;
    uint32_t loopCount = 1000000;
    bool elapsedOnly = false;
    uint32_t found = 0;
    int opt;
    if ( argc &lt; 2 )
    {
        sleepNsecs = atol(argv[1]);
        usage( argv[0], ""Required options were not given"" );
        return 1;
    }
    while ( (opt = getopt(argc, argv, ""s:d:e"")) != -1 )
    {
        switch ( opt )
        {
        case 's':
            sleepNsecs = strtoul(optarg,NULL,0);
            break;
        case 'd':
            loopCount = strtoul(optarg,NULL,0);
            break;
        case 'e':
            elapsedOnly = true;
            break;
        default:
            usage(argv[0],""Error: unrecognized option\n"");

            return 1;
        }
        found++;
    }
    if ( found &lt; 1 )
    {
        usage( argv[0], ""Invalid command line."" );
        return 1;
    }
    if ( sleepNsecs &gt; 999999999 )
    {
        usage( argv[0], ""Sleep nanoseconds must be less than one second."" );
        return 1;
    }

    printf(""sleepNsecs set to %d\n"",sleepNsecs);
    struct timespec start;
    struct timespec now;
    struct timespec prev;
    struct timespec elapsed;
    struct timespec trem;

    uint64_t count = 0;
    int64_t sum = 0;
    int64_t min = 99999999;
    int64_t max = 0;

    clock_gettime( CLOCK_MONOTONIC_RAW, &amp;start);
    now = start;
    prev = start;
    //while ( tscmp( &amp;now, &amp;then, &lt; )  )
    for ( uint32_t i = 0; i &lt; loopCount; i++ )
    {
        int rc = busySleep( sleepNsecs );
        if ( rc != 0 )
        {
            fprintf( stderr, ""busySleep returned an error!\n"" );
            return 1;
        }
        if ( ! elapsedOnly )
        {
            clock_gettime( CLOCK_MONOTONIC_RAW, &amp;now);
            tssub( &amp;now, &amp;prev, &amp;trem );
            min = ( min &lt; trem.tv_nsec ? min : trem.tv_nsec );
            max = ( max &gt; trem.tv_nsec ? max : trem.tv_nsec );
            count++;
            sum += trem.tv_nsec;
            prev = now;
        }
    }

    if ( ! elapsedOnly )
    {
        printf(""Min: %lu, Max: %lu, avg %lu, count %lu\n"",min,max,(sum / count),count);
    }
    else
    {
        clock_gettime( CLOCK_MONOTONIC_RAW, &amp;now);
        tssub( &amp;now, &amp;start, &amp;elapsed );
        double secs = ((double)elapsed.tv_sec) + ((double) elapsed.tv_nsec / (double)1e9 );
        fprintf( stderr, ""Elapsed time of %ld.%09ld for %u sleeps of duration %u, avg. = %.9f Ns\n"",
                 elapsed.tv_sec, elapsed.tv_nsec, loopCount, sleepNsecs, (secs / loopCount) );
    }
    return 0;
}
</code></pre>
",,51897074,177
41395899,2,41393918,2016-12-30T11:58:29.033,0,,6945651,,2016-12-30T11:58:29.033,2017-05-23T12:01:51.000,2,,"<p>As suggest that post <a href=""https://stackoverflow.com/questions/257091/how-do-i-flush-the-cin-buffer"">""How do I flush the cin buffer?""</a>, the problem is located after your <code>std::cin.get(command, 2);</code> code. Extra characters stay in the <code>std::cin</code> and be reused directly at the next call. And the first extra character is <code>'\n'</code> (Enter Key) and the <code>std::cin.get()</code> will return 0.</p>

<p>The best solution is to ignore extra characters after getting the command.</p>

<pre><code>std::cout &lt;&lt; ""Enter your command: "";
std::cin.get(command, 2);     //input command
std::cin.clear(); // to reset the stream state
std::cin.ignore(INT_MAX,'\n'); // to read and ignore all characters except 'EOF' 
int msglen = strlen(command);
</code></pre>

<p>Instead of</p>

<pre><code>std::cout &lt;&lt; ""Enter your command: "";
std::cin.get(command, 2);     //input command 
int msglen = strlen(command);
</code></pre>
",,51904342,289
41404161,2,41403974,2016-12-30T23:53:59.443,0,,3166476,,2016-12-30T23:53:59.443,,0,,"<p>See if your compiler is looking for a constructor:</p>

<pre><code>typedef void( *aproc ) ( );
struct Task{
    void (*proc)();                     // Process callback
    unsigned long dly;                  // delay in ms
    unsigned long mls = 0;              // last run in millis()
    Task( aproc a, unsigned long b, unsigned long c ) { proc= a; dly= b; mls= c; }
};
</code></pre>
",,51920568,2987
41404193,2,41403974,2016-12-30T23:58:35.760,1,,2828213,,2016-12-31T00:57:54.423,2016-12-31T00:57:54.423,2,,"<p>Oh, I got it. The error is in the struct:</p>

<pre><code>struct Task{
    void (*proc)();
    unsigned long dly;
    unsigned long mls = 0;  // &lt; There should not be = 0
};
</code></pre>

<p>After removing it, it compiles fine.</p>
",,51927084,132
41411418,2,41411349,2016-12-31T20:14:07.517,1,,6024122,,2016-12-31T20:18:37.380,2016-12-31T20:18:37.380,1,,"<p>When you do this</p>

<pre><code>Adafruit_NeoPixel strip1 = Adafruit_NeoPixel(21, LEFT_BAND_1, NEO_GRB + NEO_KHZ800);
   ...
Adafruit_NeoPixel strip14 = Adafruit_NeoPixel(21, RIGHT_BAND_7, NEO_GRB + NEO_KHZ800);

Adafruit_NeoPixel strips[14] = {strip1,strip2,strip3,strip4,strip5,strip6,strip7,strip8,strip9,strip10,strip11,strip12,strip13,strip14};
</code></pre>

<p>You occupy the memory equivalent of <code>2 * 14 = 28</code> <em>Adafruit_NeoPixel</em> in memory, instead of the needed <code>14</code>.</p>

<p>This would be better:</p>

<pre><code>Adafruit_NeoPixel strips[14] = {
    Adafruit_NeoPixel(21, LEFT_BAND_1, NEO_GRB + NEO_KHZ800),
    ...
    Adafruit_NeoPixel(21, RIGHT_BAND_7, NEO_GRB + NEO_KHZ800)
}
</code></pre>

<hr>

<p>Instead of passing <code>stripx</code> by value</p>

<pre><code>void set_band_ledx(Adafruit_NeoPixel stripx, uint32_t color, float value, float value_old) {...}
</code></pre>

<p>you should pass it by <em>reference</em></p>

<pre><code>void set_band_ledx(Adafruit_NeoPixel &amp;stripx, uint32_t color, float value, float value_old) {...}
</code></pre>

<hr>

<p>Also, there doesn't seem to be any reason for passing <code>uint32_t color</code> as a separate argument, since apparently it's stored within the <code>stripx</code> instance:</p>

<pre><code>  set_band_ledx(strips[i],strip[i].Color(c1, c2, c3), value_l[i],value_l_old[i]);
</code></pre>

<p><em>(though I might be wrong on this without seeing the rest of the code.)</em></p>
",,51982383,364
41419812,2,41419677,2017-01-01T23:06:44.667,2,,5719384,,2017-01-01T23:21:51.787,2017-01-01T23:21:51.787,2,,"<p>First of all, strtok works iteratively. This means that to split a string into tokens you have to call it until it returns NULL:</p>

<pre><code>char* token = strtok(input, "","");

while (token)
{
    ...
    token = strtok(NULL, "","");
}
</code></pre>

<p>And the second thing to know is that char * is just a pointer to a block of memory treated as a string. So when you write something like:</p>

<pre><code>char* str = ...;
if (str == 'c')
{
    ...
}
</code></pre>

<p>This actually means ""compare an address pointed by variable 'str' with a value of an ASCII code of character 'c' (which is 0x63 in hex)"", therefore your condition will be true iff the pointer returned by strtok equals to 0x63 and that is definitely not what you want.</p>

<p>What you really need is strcmp function, that compares two blocks of memory character by character:</p>

<pre><code>char* chars_array = strtok(receivedChars, "","");

if (strcmp(chars_array, ""bla"") == 0)
{
    // a first token is ""bla""
}
</code></pre>
",,52002484,49
41419821,2,41419677,2017-01-01T23:08:17.840,0,,2630032,,2017-01-01T23:08:17.840,,0,,"<p>The main issue is that you should use  <code>if(*func == 'c') {</code>, i.e. dereference pointer <code>func</code>, instead of <code>if(func == 'c') {</code>.
Note that you additionally should consider that <code>chars_array</code> might be an empty string or might comprise only <code>','</code>-characters; in this case, <code>strtok</code> will yield <code>NULL</code>, and probably lets your app crash. Hence, the code should look as follows:</p>

<pre class=""lang-cpp prettyprint-override""><code>if (func != nullptr) {
  Serial.println(func);
  if(*func == 'c') {
      Serial.println(""It works""); 
  }
}
</code></pre>
",,52017080,266
41436797,2,41434820,2017-01-03T05:12:29.547,0,,7363840,,2017-01-03T18:25:23.547,2017-01-03T18:25:23.547,0,,"<p>Reading the first ten values from memory and storing it in a buffer</p>

<pre><code>uint8_t buffer[10];

for (uint16_t a = 0; a &lt; 10; a++) {
  buffer[a] = fram.read8(a);
}
</code></pre>
",,52079648,2106
41448543,2,41440245,2017-01-03T16:56:31.057,2,,2836621,,2017-01-03T19:27:27.147,2017-01-03T19:27:27.147,3,,"<p>I use <strong>Raspicam</strong> from <a href=""https://sourceforge.net/projects/raspicam/files/"" rel=""nofollow noreferrer"">here</a> on a Raspberry Pi 3 and get around 90 fps in black and white mode. </p>

<p>I am currently re-purposing the code for something else so it is not 100% perfect for your needs, but should get you going.</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;raspicam/raspicam.h&gt;
#include &lt;unistd.h&gt; // for usleep()

using namespace std;

#define NFRAMES 1000
#define WIDTH   1280
#define HEIGHT  960

int main ( int argc,char **argv ) {

    raspicam::RaspiCam Camera;
    // Allowable values: RASPICAM_FORMAT_GRAY,RASPICAM_FORMAT_RGB,RASPICAM_FORMAT_BGR,RASPICAM_FORMAT_YUV420
    Camera.setFormat(raspicam::RASPICAM_FORMAT_GRAY);

    // Allowable widths: 320, 640, 1280
    // Allowable heights: 240, 480, 960
    // setCaptureSize(width,height)
    Camera.setCaptureSize(WIDTH,HEIGHT);

    // Open camera 
    cout&lt;&lt;""Opening Camera...""&lt;&lt;endl;
    if ( !Camera.open()) {cerr&lt;&lt;""Error opening camera""&lt;&lt;endl;return -1;}

    // Wait until camera stabilizes
    cout&lt;&lt;""Sleeping for 3 secs""&lt;&lt;endl;
    usleep(3000000);
    cout &lt;&lt; ""Grabbing "" &lt;&lt; NFRAMES &lt;&lt; "" frames"" &lt;&lt; endl;

    // Allocate memory for camera buffer
    unsigned long bytes=Camera.getImageBufferSize();
    cout &lt;&lt; ""Width: ""  &lt;&lt; Camera.getWidth() &lt;&lt; endl;
    cout &lt;&lt; ""Height: "" &lt;&lt; Camera.getHeight() &lt;&lt; endl;
    cout &lt;&lt; ""ImageBufferSize: "" &lt;&lt; bytes &lt;&lt; endl;;
    unsigned char *data=new unsigned char[bytes];

    for(int frame=0;frame&lt;NFRAMES;frame++){
       // Capture frame
       Camera.grab();

       // Extract the image
       Camera.retrieve (data,raspicam::RASPICAM_FORMAT_IGNORE);
       }
    }
    return 0;
}
</code></pre>

<hr>

<p>By the way, it works very nicely with <a href=""http://cimg.eu"" rel=""nofollow noreferrer"">CImg</a>.</p>

<p>Also, I haven't yet had the time to see if it works faster to create a new thread to process each frame, or to have a few threads started at the beginning and use a condition variable to start one after acquiring each frame.</p>
",,52083686,1461
41443897,2,41443720,2017-01-03T12:48:12.260,2,,82294,,2017-01-03T12:48:12.260,,8,,"<p>Interrupts must be static functions (if they are member functions) in order to work correctly, so if you want to use non-static members, you need to get an instance.  The only way you can realistically do this is with global variables.</p>

<p>Here is a sketch of how you can do that:</p>

<pre><code>class MyClass {
    static MyClass *instance;

    void init() {
        instance = this;
        attachInterrupt(...)
    }

    // Forward to non-static member function.
    static void ISRFunc() {
        instance-&gt;ISR();
    }

    // Do your work here.
    void ISR() {
        // ...
    }
}
</code></pre>

<p>This is one of many ways to set this up, but you can't avoid the fact that interrupts are inherently global.  There are a number of ""gotchas"" in the above implementation which I'm omitting, hopefully you're aware of those.</p>

<p>P.S. Also note that ""static"" has multiple meanings.  It has one meaning when declaring class members, and a completely different meaning when declaring functions outside a class (as in your declaration <code>static void ISR()</code>).  Modern C++ coding style leans using anonymous namespaces instead of <code>static</code> in the second case.</p>
",,52106452,782
41453380,2,41443720,2017-01-03T22:28:57.130,1,,6945651,,2017-01-03T22:52:10.423,2017-01-03T22:52:10.423,0,,"<p>As @DietrichEpp said, Interrupts must be static functions. But here is another approach by using the inheritance in a class.</p>

<p><strong>Step 1</strong> - create a Interrupt base class with a virtual pure InterServ() function and an array of instance based to a set of enum.</p>

<pre><code>class IntBase {
public:
    virtual void InterServ() = 0;
};

enum eIntNum {
    INT_DEV1 = 0,
    INT_DEV2,
    // ...
    INT_MAX
};

static IntBase *tInstance[INT_MAX];
</code></pre>

<p><strong>Step 2</strong> - each use-class interrupt will have:</p>

<ul>
<li>a constructor to store the instance,</li>
<li>a static function <code>ISRFunc()</code> dedicate to that class</li>
<li>a virtual function <code>InterServ()</code>, called from the static <code>ISRFunc()</code>.</li>
</ul>

<blockquote>
  <p><code>class IntDev1</code> with the number <code>INT_DEV1</code></p>
</blockquote>

<pre><code>class IntDev1 : public IntBase {
public:
    IntDev1() {
        tInstance[INT_DEV1] = this;
        // attachInterrupt(...)
    }
    virtual void InterServ() {
        // access to local members
    }
    static void ISRFunc() {
        tInstance[INT_DEV1]-&gt;InterServ();
    }
};
</code></pre>
",,52134014,245
41459045,2,41457006,2017-01-04T08:10:39.923,0,,3368201,,2017-01-04T08:10:39.923,,0,,"<p>Most probably the problem is that in 10ms the previous communication can't reach you.</p>

<p>Now, I don't have much experience in programming with plain C++ and visual studio (I usually use the managed C++ extensions and the event loop) but when I have to deal with serial ports I usually use either events or parallel threads.</p>

<p>When using events, I use the <code>SerialPort</code> class and its <code>DataReceived</code> event. Since you are using Visual C++ this is the method I suggest you to use. Just let VS create a base skeleton for you by creating a managed console application instead of an empty one and see how events work.</p>

<p>If you want to use multiple threads, just use one thread to check for the input and the other to check for the serial. I'm afraid I can't help you on how to start and handle the threads (you have to use some OS or library functions, maybe pthread's ones), but the two threads functions can be something like this:</p>

<pre><code>void thread1()
{
    while (1)
    {
        std::cout &lt;&lt; ""Enter your command: "";
        std::cin.get(command, 2);     //input command 
        int msglen = strlen(command);
        if (port-&gt;WriteData(command, msglen));   //write to arduino
        printf(""\n(writing success)\n"");
    }
}

void thread2()
{
    while (1)
    {
        int n = port-&gt;ReadData(data, 4);
        if (n != -1){
            data[n] = 0;
            cout &lt;&lt;""arduino: "" data &lt;&lt; endl;
        }
        Sleep(10);
    }
}
</code></pre>

<p>The third solution is to check the input and the serial only when some data is there:</p>

<pre><code>std::cout &lt;&lt; ""Enter your command: "";

while(1)
{
    if (_kbhit())
    {
        std::cin.get(command, 2);     //input command 
        int msglen = strlen(command);
        if (port-&gt;WriteData(command, msglen));   //write to arduino
        printf(""\n(writing success)\n"");
        std::cout &lt;&lt; ""Enter your command: "";
    }

    //read from arduino output
    n = port-&gt;ReadData(data, 4);
    if (n != -1)
    {
        data[n] = 0;
        cout &lt;&lt;""arduino: "" data &lt;&lt; endl;
    }
    Sleep(10);
}
</code></pre>

<p>These are the solutions if you want to send multiple commands (i.e. make the program wait for the input, send it and then wait for another input).</p>

<p>If you want to just use it for one command and then exit, just wait for some data:</p>

<pre><code>std::cout &lt;&lt; ""Enter your command: "";
std::cin.get(command, 2);     //input command 
int msglen = strlen(command);
if (port-&gt;WriteData(command, msglen));   //write to arduino
printf(""\n(writing success)\n"");

while ((n = port-&gt;ReadData(data, 4)) &lt;= 0)
    Sleep(10);

data[n] = 0;
cout &lt;&lt;""arduino: "" data &lt;&lt; endl;
</code></pre>

<p>The easiest but most unsuggested solution is to just increase the sleep period (e.g. to 50 ms) to allow the packets to be sent and received.</p>

<p>One more thing, since sooner or later you will face this problem. Usually with communication (be it serial, ethernet, ...) you don't have control on how often the driver tells you when it received the data. When you receive ""FORW"", you usually receive it as a block, but sometimes you receive a block with ""FOR"" and another with ""W"", or ""FO"" ""RW"", or ""F"" ""ORW"". Or you can receive two consecutive messages, for instance ""FORWLEFT"". Consequently you should either</p>

<ol>
<li>decide a ""terminator"" character, for instance #. The sending function sends FORW#, the receiving tests each received character until it finds the terminator and then processes all it received till that moment. For instance, it receives ""FO"". Append to the buffer (FO). No terminator, no processing. Then it receives ""RW"". Append to the buffer (FORW). No terminator, no processing. Then it receives ""#LEFT#"". Append to the buffer (FORW#LEFT#). The first terminator is at position 5, so analyze the first 5 bytes (FORW#) and remove them from the buffer (which now contains LEFT#). Still a terminator, analyze. If you don't like #, you can use a carriage return (\n), a space, a string terminator (\0); every character you are NOT using in the strings is fine.</li>
<li>make each command exactly the same length (for instance 4 chars). Then read every byte until the buffer is longer or equal to 4 chars, and process the first n bytes.</li>
</ol>
",,52154443,230
41485026,2,41484853,2017-01-05T12:23:08.050,0,,,user4489658,2017-01-05T12:23:08.050,,0,,"<p>Use <code>else if</code> instead of <code>if</code>. If your <code>rx_byte[0]</code> isn't equal to <code>0xcc</code> then it can also be <code>0xaa</code> or <code>0xbb</code>.</p>

<pre><code>if (rx_byte[0] == 0xaa){

         debug_Serial.println(""aa Running"");

        }

else if (rx_byte[0] == 0xbb){
        debug_Serial.println(""bb Running"");

        }

else if (rx_byte[0] == 0xcc){
          a_Serial.readBytes(input,2);
          rawcmd(input);

          }

else {
...
</code></pre>
",,52154566,85
52282987,2,41511494,2018-09-11T19:29:48.350,1,,4734360,,2018-09-11T19:39:37.737,2018-09-11T19:39:37.737,2,,"<p>To solve my problem, I had to change the virtual address used to access the PIO hardware in the following way:</p>

<pre><code>addr_virtual = (volatile unsigned long *) mem_map + (0x800 &gt;&gt; 2);
</code></pre>

<p>which equals the shortened statement:</p>

<pre><code>addr_virtual = (volatile unsigned long *) mem_map + 0x200;
</code></pre>

<p>but is more readable, as the PIO hardware address is <code>0x01C20000 + 0x800</code>. I also went with a map size of <code>4096 * 10</code> bytes.</p>

<p>I am using these macros for I/O-operations:</p>

<pre><code>#define GPIO_IN(g) *(gpio.addr_virtual + (((((g) / 32) * 36) + ((((g) - ((g) &amp; ~31)) / 8) * 4)) &gt;&gt; 2)) &amp;= ~(7 &lt;&lt; ((((g) - (((g) / 32) * 32)) - ((((g) - (((g) / 32) * 32)) / 8) * 8)) * 4))
#define GPIO_OUT(g) GPIO_IN(g); *(gpio.addr_virtual + (((((g) / 32) * 36) + ((((g) - ((g) &amp; ~31)) / 8) * 4)) &gt;&gt; 2)) |= 1 &lt;&lt; ((((g) - (((g) / 32) * 32)) - ((((g) - (((g) / 32) * 32)) / 8) * 8)) * 4)

#define GPIO_SET(g) *(gpio.addr_virtual + (((((g) / 32) * 36) + 0x10) &gt;&gt; 2)) |= 1 &lt;&lt; ((g) - (((g) / 32) * 32))
#define GPIO_CLR(g) *(gpio.addr_virtual + (((((g) / 32) * 36) + 0x10) &gt;&gt; 2)) &amp;= ~(1 &lt;&lt; ((g) - (((g) / 32) * 32)))
</code></pre>
",,52159911,52
41523141,2,41522943,2017-01-07T15:39:49.843,4,,7262357,,2017-01-07T16:10:55.923,2017-01-07T16:10:55.923,1,,"<p>If you are using a C compiler (as opposed to C++) you either have to typedef your struct or use the struct keyword wherever you use the type.</p>

<p>So it's either:</p>

<pre><code>typedef struct RGB {
  byte r;
  byte g;
  byte b;
} RGB;
</code></pre>

<p>and then:</p>

<pre><code>RGB theseColours;
</code></pre>

<p>or</p>

<pre><code>struct RGB {
  byte r;
  byte g;
  byte b;
};
</code></pre>

<p>and then:</p>

<pre><code>struct RGB theseColours;
</code></pre>

<p>However, if you are using a C++ compiler, then it may help if you tell us on what line the error occurs.</p>
",,52206882,467
41539784,2,41537283,2017-01-09T01:30:27.587,1,,7059512,,2017-01-09T01:30:27.587,,0,,"<p>You're trying to compare two different things with confusingly similar names. A <a href=""https://www.arduino.cc/en/Reference/String"" rel=""nofollow noreferrer"">string</a>(C style string) is a null terminated char array. This is different from the <a href=""https://www.arduino.cc/en/Reference/StringObject"" rel=""nofollow noreferrer"">String object</a>. It's generally accepted that with extremely memory limited hardware such as the standard Arduino boards you should avoid the use of the String class if possible as it uses more memory and may cause memory fragmentation from dynamic memory allocation. Much better to use strings instead, which are actually pretty much just as easy to work with as String.</p>

<p>Your code using only strings:</p>

<pre class=""lang-cpp prettyprint-override""><code>char alarmTime[] = ""08:52:00"";

void loop() {
  if (strcmp(rtc.getTimeStr(), alarmTime) == 0) {
    alarmState = true;
  }
}
</code></pre>
",,52215722,396
41550166,2,41549624,2017-01-09T14:27:00.530,0,,7380138,,2017-01-09T14:32:49.000,2017-01-09T14:32:49.000,1,,"<p>It's not possible to be definite, however I think this explains your problem so it may well be the error.</p>

<p>You don't include the declaration of <code>RXFlag</code>, but I surmise that you are not declaring it <code>volatile</code>. Unless you do so the compiler is allowed to assume that it knows everything about what will happen to that variable. In particular it knows that, unless <code>main()</code> calls any other functions, the value of RxFlag is never going to change. So it can optimise the <code>if</code> expression by moving it outside the loop. In effect it's changing your code like this:</p>

<pre><code>#include ""Definitions.h""

int main(void)
{
    register bool x;

    Initialization();

    x = RxFlag;

    while (1) 
    {
        //wait for RXC flag
        if (x) //wait for new byte in
        {
            //PORTB &amp;= ~(1 &lt;&lt; PB7);
            PORTB |= (1 &lt;&lt; PB7);
            rxcount = 0;
            UDR0 = 'R';
            RxFlag = false;
            TxFlag = false;

        }
    }
}
</code></pre>

<p>However, if <code>main()</code> calls another function, then the compiler gives up trying to keep RxFlag in a register over that call. The other function might change the register that RxFlag is being held in. It would have to push it onto the stack or something. Reading it again is cheaper in code and time and therefore it will read it each time it goes around the loop.</p>

<p>The correct fix for this bug is to declare any variables that are shared between the main thread and the ISR as <code>volatile</code>.</p>
",,52231567,356
41584140,2,41582825,2017-01-11T06:30:54.860,3,,1561291,,2017-01-11T06:30:54.860,,0,,"<p>You can have an array that stores a function pointer along with the string that triggers the command (you can create a struct to store both).</p>

<p>Unfortunately Arduino does not support the std::vector class so for my example I will use c type arrays. However there is a library for Arduino that adds some STL support for Arduino <a href=""https://github.com/maniacbug/StandardCplusplus"" rel=""nofollow noreferrer"">https://github.com/maniacbug/StandardCplusplus</a> (also with this library you can use the functional library to make passing functions as arguments easier)</p>

<pre><code>//struct that stores function to call and trigger word (can actually have spaces and special characters
struct shellCommand_t
{
  //function pointer that accepts functions that look like ""void test(){...}""
  void (*f)(void);
  String cmd;
};

//array to store the commands
shellCommand_t* commands;
</code></pre>

<p>With this you can either initialize the command array to one size on start or resize it every time you add a command, it just depends on your use case.</p>

<p>A basic function that assumes you have already allocated enough space in the array for adding a command could look like this</p>

<pre><code>int nCommands = 0;
void addCommand(String cmd, void (*f)(void))
{
  shellCommand_t sc;
  sc.cmd = cmd;
  sc.f = f;

  commands[nCommands++] = sc;
}
</code></pre>

<p>Then inside your setup function you can add your commands in a similar fashion as you have above</p>

<pre><code>addCommand(""test"", test);
addCommand(""hello world"", helloWorld);
</code></pre>

<p>Lastly in your loop function you can use a for loop to look through all of the commands check the input string against all of the command strings.</p>

<p>You can call the function of the matched command like this</p>

<pre><code>(*(commands[i].f))();
</code></pre>
",,52248032,782
41589270,2,41586035,2017-01-11T11:07:44.470,2,,771073,,2017-01-11T11:13:03.273,2017-01-11T11:13:03.273,1,,"<p>As Rickard has explained, <code>*buffer++ = (char)c;</code> is how you assign a character to the memory a pointer points at, and then increment the pointer.  </p>

<p>However, your function has a lot of problems - you keep comparing unset memory with <code>*endChar</code>.  I suggest:</p>

<pre><code>size_t Debugwifi::readChar(const char * const endStr, // const pointer to const.
                           char * const buffer, const size_t length) {
    if (length &lt; 1) return 0;
    const size_t endLen = strlen(endStr);
    for (size_t index = 0; index &lt; length; index++) {
        const int c = timedRead();
        if (c &lt; 0 ) break;
        buffer[index] = (char)c;

        // Debug
        _dbgSerial-&gt;println(""buffer"");
        for (size_t i = 0; i &lt; length; i++){  // Better to use size_t here, 
                                              // and compare against length not 32
            _dbgSerial-&gt;print(buffer[i], DEC);
            _dbgSerial-&gt;print("","");
        }
        _dbgSerial-&gt;println("""");

        // Finished?
        if (index &gt;= endLen) {
            if (memcmp(&amp;buffer[index-endLen], endStr, endLen)==0) {
                _dbgSerial-&gt;println(""brk""); // Must do this *before* ""break""!
                break;
            }
        }
    }
    return index;
}
</code></pre>

<p>I have added a lot of <code>const</code>s.  It's hard to have too many.  </p>

<p>The important point is that once you have read enough characters, to start comparing the last characters you have read to the end marker.</p>

<p>Note that this function does not remove the end marker, and if you pass a 32-byte zero-filled array and it reads 32 characters, the result will <em>NOT</em> be zero terminated.</p>

<p>Finally, I changed the argument name to <code>endStr</code> because I had expected <code>endChar</code> to be a pointer to a single character - not a NUL-terminated string.</p>
",,52296003,628
41650019,2,41647845,2017-01-14T12:33:26.033,1,,7406508,,2017-01-15T10:40:33.083,2017-01-15T10:40:33.083,1,,"<p>On your devide part, it looks like you are receiving 2 datas:</p>

<ol>
<li>Raw data (char* <strong>non NULL terminated</strong>)</li>
<li>Length of the data</li>
</ol>

<p>You should NULL terminate your received string</p>

<pre><code>void SimbleeBLE_onReceive(char *data, int len)
{       
    char tmp[256]={0};
    strncpy(tmp,data,min(len,sizeof(tmp)-1));
    Serial.print(tmp);
}
</code></pre>

<p>This way, on your second call, you should see <strong>action/3</strong> instead of <strong>action/323/</strong></p>
",,52332809,2509
41650473,2,41648117,2017-01-14T13:22:38.010,0,,3368201,,2017-01-14T13:22:38.010,2017-05-23T12:16:30.553,1,,"<p>You have to split it. You already know (or you should) that an int16 has, well, 16 bits (so it takes two bytes to store it).</p>

<p>Now very small digression about endianness. With endianness you mean the order of the bytes when stored. For instance, if you have the value 0x1234, you can either store it as 0x12 0x34 (big endian) or as 0x34 0x12 (little endian).</p>

<p>I don't know what language you use, so... Normally in C++ you do something like this:</p>

<pre><code>const int datalen = 3;
uint16_t data[datalen];
data[0]= 1;
data[1]= 123;
data[2]= 555;

uint8_t sendingData[] = new uint8_t[datalen * sizeof(uint16_t)];
for (int i = 0; i &lt; datalen; i++)
{
    sendingData[i * 2] = (data[i] &gt;&gt; 8) &amp; 0xFF;
    sendingData[i * 2 + 1] = data[i] &amp; 0xFF;
}

functionToSendData(sendingData, datalen * sizeof(uint16_t));
</code></pre>

<p>This sends in big endian format. If you prefer the little endian one, write</p>

<pre><code>    sendingData[i * 2] = data[i] &amp; 0xFF;
    sendingData[i * 2 + 1] = (data[i] &gt;&gt; 8) &amp; 0xFF;
</code></pre>

<p>A simpler version can be</p>

<pre><code>const int datalen = 3;
uint16_t data[datalen];
data[0]= 1;
data[1]= 123;
data[2]= 555;

functionToSendData((uint8_t*)data, datalen * sizeof(uint16_t));
</code></pre>

<p>In the first case you know the endianness of the transmission (it is little or big according to how you code), in the second it depends on the architecture and/or the compiler.</p>

<p>In JavaScript you can use this:</p>

<pre><code>var sendingData = new Uint8Array(data.buffer)
</code></pre>

<p>and then send this new array. Credits go to <a href=""https://stackoverflow.com/a/28291416/3368201"">this answer</a></p>

<p>When you receive it, you will have to do one of these three things to convert it</p>

<pre><code>// Data is big endian
void SimbleeBLE_onReceive(char *receivedData, int len) {
    uint16_t data[] = new uint16_t[len/2];

    for (int i = 0; i &lt; len/2; i++)
        data = (((uint16_t)receivedData[i * 2]) &lt;&lt; 8) + receivedData[i * 2 + 1];

    Serial.print(data[0]);
    Serial.print(data[1]);
    Serial.print(data[2]);
}

// Data is little endian
void SimbleeBLE_onReceive(char *receivedData, int len) {
    uint16_t data[] = new uint16_t[len/2];

    for (int i = 0; i &lt; len/2; i++)
        data = receivedData[i * 2] + (((uint16_t)receivedData[i * 2 + 1]) &lt;&lt; 8);

    Serial.print(data[0]);
    Serial.print(data[1]);
    Serial.print(data[2]);
}

// Trust the compiler
void SimbleeBLE_onReceive(char *receivedData, int len) {
    uint16_t *data = receivedData;

    Serial.print(data[0]);
    Serial.print(data[1]);
    Serial.print(data[2]);
}
</code></pre>

<p>The last method is the most error-prone, since you have to know what endianness uses the compiler and it has to match the sendong one.</p>

<p>If the endianness mismatches you will receive what you think are ""random"" numbers. It is really easily debugged, though. For instance, you send the value 156 (hexadecimal 0x9C), and receive the 39936 (hexadecimal 0x9C00). See? The bytes are inverted. Another example: sending 8942 (hex 0x22EE) and receiving 60962 (hex 0xEE22).</p>

<p>Just to finish, I think you are going to have problems with this, because sometimes you will not receive the bytes ""in one block"", but separated. For instance, when you send 1 123 555 (in hex and, for instance, big endian this will be six bytes, particularly 00 01 00 7B 02 2B) you may get a call to SimbleeBLE_onReceive with just 3 or 4 bytes, then receive the others. So you will have to define a sort of protocol to mark the start and/or end of the packet, and accumulate the bytes in a buffer until ready to process them all.</p>
",,52336870,99
41667479,2,41667391,2017-01-15T23:22:56.360,3,,459640,,2017-01-15T23:22:56.360,,6,,"<p>First off, every definition is a declaration; a definition is a special kind of declaration.</p>

<pre><code>enum operation_status {
    PRE_START,
    RUNNING,
    PAUSED
};
</code></pre>

<p>is technically a definition - it defines the type <code>operation_status</code>.  But it's a definition of the sort that's allowed to appear in multiple compilation units (as long as it has the same contents and meaning every time), so a header file is usually the right place for it.</p>

<pre><code>operation_status op_status;
</code></pre>

<p>is in fact a definition, even though it has no initializer.  To make it not a definition, you would need the <code>extern</code> keyword:</p>

<pre><code>extern operation_status op_status;
</code></pre>

<p>The definition to go with that belongs in one source file and may optionally have an initializer.</p>

<pre><code>operation_status op_status = PRE_START;
</code></pre>

<p>Finally,</p>

<pre><code>op_status = PRE_START;
</code></pre>

<p>is not a declaration at all.  It's a statement, and is only valid inside a function definition.</p>
",,52348930,9387
41667553,2,41667391,2017-01-15T23:33:58.530,1,,471160,,2017-01-15T23:46:58.750,2017-01-15T23:46:58.750,1,,"<blockquote>
  <p>I'm trying to segment my code into multiple .cpp files, all of which should have access to an enum type, which I thought I was declaring in a header file, then including in a number of cpp files.</p>
</blockquote>

<p>You cannot forward-declare an unscoped enumeration which has no specified underlying type (standard does not allow this). This is a kind of enum from pre c++11 age. For such enums, Standard does not enforce on compiler any default underlying type, so if you specify only few values in your enum it can use a char, or if you have some large values in might use short or int. But this will be known only when you define it.</p>

<p>If you want declare an unscoped enum, then you must specify its underlying type. This is possible since c++11:</p>

<pre><code>// forward declare (in header file .h)
enum operation_status : int;


// define (in implementation file .cpp)
enum operation_status : int {
    PRE_START,
    RUNNING,
    PAUSED
};
</code></pre>

<p>but you can also go ahead and use new scoped enums, their underlying type by default is int:</p>

<pre><code>// forward declare
enum class operation_status;


// define
enum class operation_status {
    PRE_START,
    RUNNING,
    PAUSED
};
</code></pre>

<p>[edit]</p>

<p>Your questions:</p>

<pre><code>enum operation_status {
    PRE_START,
    RUNNING,
    PAUSED
};
If I have this in my main.h file, this is clearly just a declaration, isn't it?
</code></pre>

<p>this is both declaration and definition, my above answer goes deeper on this.</p>

<blockquote>
  <p>operation_status op_status;</p>
</blockquote>

<p>thats definition. You dont need to initialize it, to make it a definition.</p>
",,52371410,468
41724363,2,41715726,2017-01-18T16:20:58.000,1,,1329652,,2017-01-19T15:41:41.167,2017-05-23T12:16:28.983,3,,"<p>You should factor out a separate <code>QObject</code> class that performs communications, and connect other classes to it.</p>

<p>A well designed system will never have a UI class own and use a serial port directly. See e.g. <a href=""https://stackoverflow.com/a/32595398/1329652"">this answer</a> for an idea how to separate the communications and the UI.</p>

<p>Let's see what transformations you could do to your code. At present you might have something similar to the below:</p>

<pre><code>// https://github.com/KubaO/stackoverflown/tree/master/questions/serial-owner-41715726
#include &lt;QtWidgets&gt;
#include &lt;QtSerialPort&gt;

class Operations1 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_send{""Send""};
    QPointer&lt;QSerialPort&gt; m_serial;
public:
    Operations1() {
        m_layout.addWidget(&amp;m_send);
        connect(&amp;m_send, &amp;QPushButton::clicked, this, &amp;Operations1::sendRequest);
    }
    void sendRequest() {
        QByteArray request;
        QDataStream ds(&amp;request, QIODevice::WriteOnly);
        ds &lt;&lt; qint32(44);
        m_serial-&gt;write(request);
    }
    void setSerial(QSerialPort * port) {
        m_serial = port;
    }
};

class MainWindow1 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_open{""Open""};
    QSerialPort m_serial;
    QScopedPointer&lt;Operations1&gt; m_operations;
    Operations1 * operations() {
        if (!m_operations)
            m_operations.reset(new Operations1);
        return m_operations.data();
    }
public:
    MainWindow1() {
        m_layout.addWidget(&amp;m_open);
        connect(&amp;m_open, &amp;QPushButton::clicked, this, &amp;MainWindow1::open);
    }
    void open() {
        m_serial.setBaudRate(38400);
        m_serial.setPortName(""/dev/tty.usbserial-PX9A3C3B"");
        if (!m_serial.open(QIODevice::ReadWrite))
            return;
        operations()-&gt;show();
        operations()-&gt;setSerial(&amp;m_serial);
    }
};

int main1(int argc, char ** argv) {
    QApplication app{argc, argv};
    MainWindow1 ui;
    ui.show();
    return app.exec();
}
</code></pre>

<p>The serial-port using functionality is spread across the UI classes, coupling them very tightly with the port. Let's fix that by factoring out the port operations:</p>

<pre><code>class Controller2 : public QObject {
    Q_OBJECT
    QSerialPort m_port;
public:
    Controller2(QObject * parent = nullptr) : QObject{parent} {
        connect(&amp;m_port, &amp;QIODevice::bytesWritten, this, [this]{
            if (m_port.bytesToWrite() == 0)
                emit allDataSent();
        });
    }
    Q_SLOT void open() {
        m_port.setBaudRate(38400);
        m_port.setPortName(""/dev/tty.usbserial-PX9A3C3B"");
        if (!m_port.open(QIODevice::ReadWrite))
            return;
        emit opened();
    }
    Q_SIGNAL void opened();
    Q_SLOT void sendRequest() {
        QByteArray request;
        QDataStream ds(&amp;request, QIODevice::WriteOnly);
        ds &lt;&lt; qint32(44);
        m_port.write(request);
    }
    Q_SIGNAL void allDataSent();
};

class Operations2 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_send{""Send""};
    QPointer&lt;Controller2&gt; m_ctl;
public:
    Operations2(Controller2 * ctl, QWidget * parent = nullptr) :
        QWidget{parent},
        m_ctl{ctl}
    {
        m_layout.addWidget(&amp;m_send);
        connect(&amp;m_send, &amp;QPushButton::clicked, m_ctl, &amp;Controller2::sendRequest);
    }
};

class MainWindow2 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_open{""Open""};
    QPointer&lt;Controller2&gt; m_ctl;
    QScopedPointer&lt;Operations2&gt; m_operations;
    Operations2 * operations() {
        if (!m_operations)
            m_operations.reset(new Operations2{m_ctl});
        return m_operations.data();
    }
public:
    MainWindow2(Controller2 * ctl, QWidget * parent = nullptr) :
        QWidget{parent},
        m_ctl{ctl}
    {
        m_layout.addWidget(&amp;m_open);
        connect(&amp;m_open, &amp;QPushButton::clicked, m_ctl, &amp;Controller2::open);
        connect(m_ctl, &amp;Controller2::opened, this, [this]{
            operations()-&gt;show();
        });
    }
};

int main2(int argc, char ** argv) {
    QApplication app{argc, argv};
    Controller2 controller;
    MainWindow2 ui(&amp;controller);
    ui.show();
    return app.exec();
}
</code></pre>

<p>Finally, if you're tired of passing the controller around explicitly, we can implement a method akin to <code>QCoreApplication::instance</code> to get access to the unique controller instance:</p>

<pre><code>class Controller3 : public QObject {
    Q_OBJECT
    QSerialPort m_port;
    static Controller3 * instance(bool assign, Controller3 * newInstance = nullptr) {
        static Controller3 * instance;
        if (assign)
            instance = newInstance;
        return instance;
    }
public:
    Controller3(QObject * parent = nullptr) : QObject{parent} {
        connect(&amp;m_port, &amp;QIODevice::bytesWritten, this, [this]{
            if (m_port.bytesToWrite() == 0)
                emit allDataSent();
        });
        instance(true, this);
    }
    ~Controller3() {
        instance(true);
    }
    Q_SLOT void open() {
        m_port.setBaudRate(38400);
        m_port.setPortName(""/dev/tty.usbserial-PX9A3C3B"");
        if (!m_port.open(QIODevice::ReadWrite))
            return;
        emit opened();
    }
    Q_SIGNAL void opened();
    Q_SLOT void sendRequest() {
        QByteArray request;
        QDataStream ds(&amp;request, QIODevice::WriteOnly);
        ds &lt;&lt; qint32(44);
        m_port.write(request);
    }
    Q_SIGNAL void allDataSent();
    static Controller3 * instance() {
        return instance(false);
    }
};

class Operations3 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_send{""Send""};
public:
    Operations3(QWidget * parent = nullptr) : QWidget{parent}
    {
        m_layout.addWidget(&amp;m_send);
        connect(&amp;m_send, &amp;QPushButton::clicked, Controller3::instance(), &amp;Controller3::sendRequest);
    }
};

class MainWindow3 : public QWidget {
    Q_OBJECT
    QVBoxLayout m_layout{this};
    QPushButton m_open{""Open""};
    QScopedPointer&lt;Operations3&gt; m_operations;
    Operations3 * operations() {
        if (!m_operations)
            m_operations.reset(new Operations3);
        return m_operations.data();
    }
public:
    MainWindow3(QWidget * parent = nullptr) : QWidget{parent}
    {
        m_layout.addWidget(&amp;m_open);
        connect(&amp;m_open, &amp;QPushButton::clicked, Controller3::instance(), &amp;Controller3::open);
        connect(Controller3::instance(), &amp;Controller3::opened, this, [this]{
            operations()-&gt;show();
        });
    }
};

int main3(int argc, char ** argv) {
    QApplication app{argc, argv};
    Controller3 controller;
    MainWindow3 ui;
    ui.show();
    return app.exec();
}
</code></pre>
",,52389255,887
41748220,2,41726934,2017-01-19T17:36:40.517,0,,7433247,,2017-01-19T17:36:40.517,,0,,"<p>The issue was the use of the %d in the printf string in RunTest.c.  Updating the code to that shown below fixes the issue and makes the output:</p>

<pre><code>Value seen in modifyFloat: 22.55
The value that was returned is: 22.55
</code></pre>

<h1>RunTest.c</h1>

<pre><code>#include ""FloatTest.h""

void runInLoop(void)
{
    while(1)
    {
        float testValue;
        modifyFloat(&amp;testValue);
        char str_tmp[6];
        dtostrf(testValue, 4, 2, str_tmp);
        (void)printf(""The value that was returned is: %s\r\n"", str_tmp);
        delay(1000);
    }

}
</code></pre>
",,52399011,461
47518430,2,41727205,2017-11-27T19:29:27.240,0,,7892036,,2017-11-27T19:45:58.413,2017-11-27T19:45:58.413,0,,"<p>You must use signed value in last 2 bytes of data:</p>

<p><strong>To spin backwards:</strong></p>

<pre><code>...

I2C_Write(1); // send the command variable for speed

I2C_Write(1); // send LSB of 1 

I2C_Write(255);// send MSB of 255 to and so Speed of backward 255 

...
</code></pre>

<p><strong>To spin forwards:</strong></p>

<pre><code>...

I2C_Write(1);// send the command variable for speed  
I2C_Write(255);// send LSB of 255  
I2C_Write(0);// send MSB of 0 to and so Speed of forward 255

...
</code></pre>
",,52449688,1281
41754533,2,41754453,2017-01-20T01:17:35.313,0,,607407,,2017-01-20T01:28:36.250,2017-05-23T12:03:05.203,6,,"<p>First off, apostrophes are for <strong>char literals not strings</strong>, that is <code>'x'</code> is of type <code>char</code> whereas <code>""x""</code> is of type <code>char*</code>. It is not clearly defined what <code>'xyz'</code> means, as discussed in this question: <a href=""https://stackoverflow.com/a/3961219/607407"">https://stackoverflow.com/a/3961219/607407</a></p>

<p>The value <code>Serial.read</code> returns is of type <code>int</code>. So in this case:</p>

<pre><code>if (state == ""stop"")
</code></pre>

<p>You are comparing <code>int</code> with <code>const char*</code>. Instead, you probably want to read a string and compare that. Here is an example of reading string on arduino from serial:</p>

<pre><code>const int max_len = 20;
char input_string[max_len+1]; // Allocate some space for the string
size_t index = 0;

while(Serial.available() &gt; 0) // Don't read unless
{
    if(max_len &lt; 19) // One less than the size of the array
    {
        int input_num = Serial.read(); // Read a character
        input_string[index] = (char)input_num; // Store it
        index++; // Increment where to write next
        input_string[index] = '\0'; // Null terminate the string
    }
    else {
        // all data read, time to data processing
        break;
    }
}
// Don't forget that you have to compare
// strings using strcmp
if(strcmp(inData, ""stop"") == 0) {
    // do something
}
// reset the buffer so that
// you can read another string
index = 0;
</code></pre>
",,52456566,1859
41754745,2,41754678,2017-01-20T01:43:33.430,1,,607407,,2017-01-20T01:54:37.040,2017-01-20T01:54:37.040,1,,"<p>I don't understand why do you convert the bitset to string. Just access it's elements directly.</p>

<pre><code>bitset&lt;10&gt; myBitset(myValue);
for (int i = 0; i &lt; 10; i++)
    binary[i] = myBitset[i];
</code></pre>

<p>You could also go with bit shifting, that's the most low level way of doing this:</p>

<pre><code>int mask = 1; // binary 10000000 00000000 ...
for (int i = 0, l = NUM_BITS; i &lt; l; ++i) {
    // binary &amp; operation does 
    // AND logic operation for all corresponging bit
    // so 0010&amp;0011=0010
    binary[i] = myValue &amp; mask;
    // move the bits in mask one to the right
    mask = mask&gt;&gt;1;
}
</code></pre>

<p>If you're going with bitset, I'd recommend that you keep the bitset instead of using <code>bool*</code> because in bitsets, every bit actually occupies one bit, whereas <code>bool</code> is eight bits large at least.</p>

<p>Finally, here's some test code I made for that, you can use it to do benchmarks:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
#define NUM_BITS 10
int main(int argc, char *argv[])
{
    const int numBits = NUM_BITS;
    bool binary[numBits];
    const int myValue = 1;

    std::bitset&lt;NUM_BITS&gt; myBitset(myValue);
    //for (int i = 0; i &lt; NUM_BITS; i++)
        //binary[i] = myBitset[i];

    for (int i = 0, l = NUM_BITS; i &lt; l; ++i) {
        std::cout&lt;&lt; (binary[i]?'1':'0')&lt;&lt;"" "";
    }
    std::cout&lt;&lt;""\n"";
    int mask = 1; // binary 10000000 00000000 ...
    for (int i = 0, l = NUM_BITS; i &lt; l; ++i) {
        // binary &amp; operation does 
        // AND logic operation for all corresponging bit
        // so 0010&amp;0011=0010
        binary[i] = myValue &amp; mask;
        // move the bits in mask one to the right
        mask = mask&gt;&gt;1;
    }

    for (int i = 0, l = NUM_BITS; i &lt; l; ++i) {
        std::cout&lt;&lt; (binary[i]?'1':'0')&lt;&lt;"" "";
    }
}
</code></pre>
",,52514784,1339
41758487,2,41757588,2017-01-20T07:45:42.120,0,,2378300,,2017-01-20T07:45:42.120,,2,,"<p>You can easily reuse your <code>std::vector</code> like this:</p>

<pre><code>std::vector&lt;char&gt; fileData;

while(isRunning)
{
    ssize_t n = recv(Connection, received_message, sizeof(received_message), 0); //receiving the size of image in bytes
    if (n &lt; 0)
        throw std::runtime_error(std::string(""Connection error (getting fileSize)"") + strerror(errno));
    assert(n == sizeof(received_message));

    fileSize = atoi(received_message);

    if (fileSize &gt; maxFileSize or fileSize == 0)
        throw std::runtime_error(""Invalid fileSize "" + std::to_string(fileSize));

    fileData.resize(fileSize);

    size_t received = 0;
    while (received &lt; fileSize)
    {
        ssize_t n = recv(Connection, fileData.data() + received, fileSize - received, 0); //Receiving the image
        if (n &lt; 0)
            throw std::runtime_error(std::string(""Connection error (getting image)"") + strerror(errno));
        received += n;
    }
    //The code loops over and over again
}
</code></pre>

<p>A few notes:</p>

<ul>
<li>Handle the event that the first <code>recv</code> does not receive <code>sizeof(received_message)</code> bytes (currently protected by the <code>assert</code>)</li>
<li>You should define <code>maxFileSize</code> </li>
<li>Include the <code>&lt;cassert&gt;</code>, <code>&lt;exception&gt;</code> and <code>&lt;string&gt;</code> headers</li>
<li>Compile using <code>-std=c++11</code></li>
</ul>
",,52518638,577
41801357,2,41763658,2017-01-23T07:42:51.033,0,,5708620,,2017-01-23T07:42:51.033,,0,,"<p>There are several problems here:</p>

<p><strong>1)</strong> You get a HTTP 404 response, which means the resource was not found on the server. So you need to check your request.</p>

<p><strong>2)</strong> You are cutting off the string at pos 400:</p>

<pre><code>Ethernet::buffer[off + 400] = 0;  // if i raise 400 much higher, response will be blank
</code></pre>

<p>That's why it stops after <code>Cache-Control: no</code>, which is exactly 400 bytes (byte 0-399).</p>

<p>You probably want <code>Ethernet::buffer[off + len] = 0;</code>, but you also need to check if that is not out of bounds (i.e. larger than your buffer size - that's probably why you get a 'blank' response).</p>

<p>For example, a 404 response from that server looks like this:</p>

<pre class=""lang-none prettyprint-override""><code>HTTP/1.1 404 Not Found
Date: Mon, 23 Jan 2017 07:00:00 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2
Connection: keep-alive
x-powered-by: Express
Vary: Accept-Encoding
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Expires: -1
x-content-type-options: nosniff
Etag: W/""2-mZFLkyvTelC5g8XnyQrpOw""
Via: 1.1 vegur
CF-Cache-Status: MISS
Server: cloudflare-nginx
CF-RAY: 32595301c275445d-xxx

{}
</code></pre>

<p>and the 200 response headers (from a browser):</p>

<pre class=""lang-none prettyprint-override""><code>HTTP/1.1 200 OK
Date: Mon, 23 Jan 2017 07:00:00 GMT
Content-Type: application/json; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
x-powered-by: Express
Vary: Accept-Encoding
Access-Control-Allow-Credentials: true
Cache-Control: public, max-age=14400
Pragma: no-cache
Expires: Mon, 23 Jan 2017 10:59:01 GMT
x-content-type-options: nosniff
Etag: W/""124-yv65LoT2uMHrpn06wNpAcQ""
Via: 1.1 vegur
CF-Cache-Status: HIT
Server: cloudflare-nginx
CF-RAY: 32595c4ff39b445d-xxx
Content-Encoding: gzip
</code></pre>

<p>So your buffer needs to be big enough to hold both the response headers and the data.</p>

<p><strong>3)</strong> In the 200 response we see 2 things: the transfer is <a href=""https://en.wikipedia.org/wiki/Chunked_transfer_encoding"" rel=""nofollow noreferrer"">chunked</a>, and gzipped (but the latter only happens when there is a <code>Accept-Encoding: gzip</code> header in the request.</p>

<p>The easiest way to handle this is to send a HTTP/1.0 request instead of HTTP/1.1 (chunked transfer and gzip are not allowed/available in HTTP/1.0).</p>
",,52553466,172
41764142,2,41764016,2017-01-20T12:50:36.223,2,,7359094,,2017-01-20T12:53:03.397,2017-01-20T12:53:03.397,0,,"<p>That's specifically what the <a href=""http://en.cppreference.com/w/cpp/language/operators#Function_call_operator"" rel=""nofollow noreferrer"">function call operator</a> is for.</p>

<pre><code>class Sum{
public:
    void value(int val){ _v = val; }
    int add(int val) const{ return _v + val; }

    // Function call operator
    int operator()(int val) const {
        return add(val);
    }

private:
    int _v;
};

int main()
{
    Sum sum;
    sum.value(5);

    // Calls the function call operator
    int myResult = sum(10);
}
</code></pre>
",,52553508,652
41812026,2,41811577,2017-01-23T17:20:46.543,0,,4581301,,2017-01-23T17:20:46.543,,0,,"<p>Checking in advance for the ultrasonic sensor there's not much anyone can suggest without knowing more about the sensor. If the communication is purely bit-toggling you probably can't tell without more hardware.</p>

<p>For the second part, timing out <code>getCM</code>, add an extra condition to the <code>digitalRead</code> loops to force an exit. For example:</p>

<pre><code>int timeout = &lt;read timeout goes here&gt;;
while((digitalRead(ECHO_R) == LOW)&amp;&amp;(--timeout));
if (!timeout)
{
    return -1; // Should never be able to read less than blanking distance 
               // from an ultrasonic sensor. -1 is certainly out of range.
}
</code></pre>

<p>In <code>main</code> you can either print out the -1 or check for -1 and print out a better error message. For more clarity, the second loop could <code>return -2;</code> on failure so you know what failed.</p>
",,52572703,1104
41817301,2,41816834,2017-01-23T23:06:15.817,0,,360913,,2017-01-23T23:06:15.817,,0,,"<pre><code>int h = 12;
int m = 11;
int s = 50;
int num = h * 10000 + m * 100 + s;
printf(""%d\n"", num);  
</code></pre>

<p>Output: 121150</p>
",,52580643,335
41853576,2,41853306,2017-01-25T14:01:46.320,0,,1870232,,2017-01-25T14:01:46.320,,0,,"<p>Try:</p>

<p><code>Serial.readStringUntil('0')</code> since as per <a href=""https://www.arduino.cc/en/Serial/ReadStringUntil"" rel=""nofollow noreferrer"">docs</a> it accepts a <code>char</code></p>

<p>Else I'd suggest to change the terminate character to say <code>\n</code> ( ENTER ) , </p>

<p>then on serial : <code>""L\n20""</code> will give you correct output.</p>

<pre><code>void loop() 
{
    if(Serial.available() &gt; 0)
    {
        evalComms( Serial.readStringUntil('\n') );
    }
}
</code></pre>
",,52588676,58
41931791,2,41855327,2017-01-30T08:46:24.837,0,,4623899,,2017-01-30T08:46:24.837,,0,,"<p>I've resolved the problem using <code>friend</code> modifier for the operator declaration inside the class.</p>

<pre><code>friend AddOperationMode operator | ( AddOperationMode lhs, AddOperationMode rhs );

friend AddOperationMode operator + ( AddOperationMode lhs, AddOperationMode rhs );
</code></pre>

<p>Then the operator are defined outside the class:</p>

<pre><code>MngSpiLS7366R::OperationMode operator | (MngSpiLS7366R::OperationMode lhs, MngSpiLS7366R::OperationMode rhs )
{
// Cast to int first otherwise we'll just end up recursing
return static_cast&lt; MngSpiLS7366R::OperationMode &gt;( static_cast&lt; int &gt;( lhs ) | static_cast&lt; int &gt;( rhs ) );
}

MngSpiLS7366R::OperationMode operator + (MngSpiLS7366R::OperationMode lhs, MngSpiLS7366R::OperationMode rhs )
{
// Cast to int first otherwise we'll just end up recursing
return static_cast&lt; MngSpiLS7366R::OperationMode &gt;( static_cast&lt; int &gt;( lhs ) | static_cast&lt; int &gt;( rhs ) );
}
</code></pre>
",,52629993,52
41859092,2,41858929,2017-01-25T18:37:01.043,0,,4991953,,2017-01-25T18:45:23.307,2017-01-25T18:45:23.307,0,,"<p>Your problem is that you are setting temp, then entering the loop that checks that value. A simple solution would be to update the temp value inside the while loop, to give the application a chance to break out of the while loop.</p>

<p>Example:</p>

<pre><code>void loop()
{

  // Other code here giving temp a value

  if (temp &gt; 22)
  {
    status = false;
    value[""status""] = status;
    while (temp &gt; 22)
    {
      sendToGCM(); // Sends push notification 

      //Additional code to set the value of temp, allowing the value to
      //be greater than 22.
    }
  }
  else 
  {
    status = true;
    value[""status""] = status;
  }
}
</code></pre>

<p>Please note that the above example is intended to continuously send the push notification while the temp value is over 22. If that's not the intention, just remove the sendToGCM() from the while loop. You will still only send it if the temp is greater than 22, since you have the if check.</p>
",,52670521,1533
41859134,2,41858929,2017-01-25T18:39:25.717,2,,3669613,,2017-01-27T15:11:21.887,2017-01-27T15:11:21.887,3,,"<p>So if I understood you correctly, if the temperature goes 22 degrees you want to send a message, but only the first time. If you break the loop, you still enter it if you the <code>loop()</code> function is executed again.</p>

<p>In order to achieve what you want to do, you code will need to look something like this</p>

<pre><code>boolean message_sent;

void loop() {
    ...
    if(temperature &gt; 22 &amp;&amp; !message_sent) {
        sendToGCM();
        message_sent = true;            
    }
}
</code></pre>

<p>If you want to send a message every time the temperature rises over 22 degrees you would need something like this</p>

<pre><code>boolean message_sent;
boolean was_under_22;

void setup() {
    ...
    was_under_22 = function_that_checks_if_temp_is_under_22();
    ...
}

void loop() {
    ...
    if(temperature &gt; 22 &amp;&amp; was_under_22) {
        if(!message_sent) {
            sendToGCM();
            message_sent = true;
            was_under_22 = false;            
        }
    } else {
        was_under_22 = true;
        message_sent = false;
    }
}
</code></pre>

<p><strong>EDIT:</strong> slightly adapted the code in response to Patrick Trentin's comment. The code assumes you only want to capture if the temperature rises above 22 degrees and that if the Arduino starts with over 22 degrees then no message is sent.</p>
",,52689172,242
41867152,2,41864374,2017-01-26T04:58:09.520,1,,5708620,,2017-01-26T05:03:10.483,2017-01-26T05:03:10.483,0,,"<p>This is very strange indeed.</p>

<p>I would suggest to create a second, minimal function like this:</p>

<pre><code>int calcPID2(double current, double desired){

    Serial.println(desired - current);

    return(1);
}
</code></pre>

<p>and then gradually changing it to your original version, and see where it goes wrong (<em>if</em> it goes wrong..).</p>

<p>I have had some strange things with the Arduino software too in the past. Maybe you should check if you have the latest version.</p>

<p>You might also want to check if there is no memory or stack problem (i.e. if you have enough free memory left).</p>
",,52709911,574
41868368,2,41868245,2017-01-26T07:08:54.803,4,,5649326,,2017-01-27T07:02:14.413,2017-01-27T07:02:14.413,5,,"<blockquote>
  <p>how to split char c into two separate integer variables?</p>
</blockquote>

<ul>
<li>First of all, what you have is a string, not a <code>char</code>. </li>
<li><p>You can use the <code>strtok()</code> function to split a string (and specify the delimiter to use), like this :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    char nums[] = ""140,100"";
    char *str;
    int num;
    int SpeedX, SpeedY, i = 0;

    str = strtok (nums, "","");

    while (str != NULL)
    {
        num = atoi(str);
        if (i == 0)
           SpeedX = num;
        else if (i == 1)
           SpeedY = num;
        str = strtok (NULL, "","");
        i++;
    }
    return 0;
}
</code></pre></li>
<li><p><strong><em>NOTE : If, generally speaking about such a problem to solve in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> and not in <a href=""/questions/tagged/arduino"" class=""post-tag"" title=""show questions tagged &#39;arduino&#39;"" rel=""tag"">arduino</a>, you do not know for sure that you will have only two elements</em></strong> in <code>nums</code>, you should use <strong><em>dynamic memory allocation</em></strong> (read more about it <a href=""https://www.tutorialspoint.com/cprogramming/c_memory_management.htm"" rel=""nofollow noreferrer"">here</a>), and modify your code like this :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    char nums[] = ""140,100,500"";
    char *str;
    int num;
    int len, i = 0;
    int *p;

    str = strtok (nums, "","");
    len = strlen(str);
    p = malloc((len-1)*sizeof(int));

    while (str != NULL)
    {
        num = atoi(str);
        *(p+i) = num;
        i++;
        str = strtok (NULL, "","");
    }

    for (i = 0; i &lt; len-1; i++)
    printf(""%d\n"", *(p+i));
    return 0;
}
</code></pre></li>
</ul>
",,52721674,84
41898886,2,41896389,2017-01-27T16:43:19.197,0,,7375520,,2017-01-27T16:43:19.197,2020-06-20T09:12:55.060,1,,"<blockquote>
<p>Your code doesn't make any sense. To write the input given by user to a file:</p>
<p>Create a file first. Take input from user (say any string) and write it to the file with the help of file descriptor (fp) and close the file so that all buffers get flushed.</p>
</blockquote>
<pre><code>FILE *fp;
char comment[100] = {0};
 fp=fopen(&quot;tempfile.txt&quot;,&quot;w&quot;);

if (fp == NULL)
{
    printf(&quot;Error opening file!\n&quot;);
    exit(1);
}

printf(&quot;Enter String: &quot;);
gets(comment);
fwrite(comment, sizeof(comment), 1, fp) ;

fclose(fp);
</code></pre>
<blockquote>
<p>fprintf() too can be used instead to write data into a file.
Similarly to read from a file you can use fgets() or fread() to store the contents of the file in a buffer and display the contents of the file. Hope it helps.</p>
</blockquote>
",,52751103,1111
41969312,2,41903047,2017-01-31T23:23:23.897,0,,88485,,2017-01-31T23:23:23.897,,0,,"<p>Your code works fine, provided that off_1 and off_2 are actually defined and the assignment is done inside a function, like so:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef void(*offFunction)(void);

void off_1() {
    printf(""off_1\n"");
}
void off_2() {
    printf(""off_2\n"");
}

int main() {
    offFunction offFunctionList[2] = {off_1, off_2};    
    offFunctionList[0]();
}
</code></pre>
",,52764806,101
41905749,2,41905648,2017-01-28T02:20:12.483,4,,7445652,,2017-01-28T17:42:10.087,2017-01-28T17:42:10.087,2,,"<p>The problem here is that ptr in bind_regex_member points to const T and your method InterpreterClass::MatchAddressCallback is non const. 
Basicly like this:</p>

<pre><code>InterpreterClass i;
const InterpreterClass* myPtr = &amp;i;
MatchState myMs;
myPtr-&gt;MatchAddressCallback("""", 0, myMs); // OUCH! myPtr points to const T and MatchAddressCallback is non const member function
</code></pre>

<p>Remove the const from ptr in bind_regex_member and it should work!</p>

<p>EDIT: 
There is a second problem in Interpreter.h:</p>

<pre><code>class Interpreter
{
public:
    void init();
    GlobalMatchCallback MatchAddressCallback; // &lt;----------- HERE
};
</code></pre>

<p>You cannot declare a method like this. The ""final"" Interpreter.h should look like this:</p>

<pre><code>#ifndef _INTERPRETER_h
#define _INTERPRETER_h

#include &lt;Arduino.h&gt;
#include ""Regexp.h""

template&lt;class T, void(T::*PTR)(const char *, const unsigned int, const MatchState &amp;), size_t I&gt;
struct bind_regex_member
{
    typedef void(*fn_type)(const char *, const unsigned int, const MatchState &amp;);
    explicit bind_regex_member(T* _ptr)
    {
        ptr = _ptr;
    }
    static void func(const char * match, const unsigned int length, const MatchState &amp; ms)
    {
        (ptr-&gt;*PTR)(match, length, ms);
    }
    operator fn_type()
    {
        return &amp;func;
    }
private:
    static T*  ptr;
};

template&lt;class T,

void(T::*PTR)(const char *, const unsigned int, const MatchState &amp;), size_t  I&gt;
T* bind_regex_member&lt;T, PTR, I&gt;::ptr = NULL;

class InterpreterClass
{
 public:
    void init();

    void MatchAddressCallback(const char * match, const unsigned int length, const MatchState &amp; ms);
};

extern InterpreterClass Interpreter;

#endif
</code></pre>
",,52781387,167
41923767,2,41923609,2017-01-29T17:22:42.687,1,,121747,,2017-01-29T17:22:42.687,,6,,"<p>Your code seems really overdone. You can use a nested loop which iterates any each possible bit of source data and set dest data accordingly (which basically swaps indices), something like:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef unsigned char byte;

void printCharacter(const byte* data, size_t length)
{
  for (size_t i = 0; i &lt; length; ++i)
  {
    for (size_t j = 0; j &lt; 8; ++j)
    {
      const unsigned char mask = 1 &lt;&lt; j;
      printf(""%c "", data[i] &amp; mask ? 'o' : '-');
    }
    printf(""\n"");
  }
}

void rotate(const byte* source, byte* dest, size_t length)
{
  /* for each bit position starting from first */
  for (size_t j = 0; j &lt; 8; ++j)
  {
    /* this is the mask of the i-th bit in source data */
    const unsigned char mask = 1 &lt;&lt; j;

    /* for each row in source data (which will become column) */
    for (size_t i = 0; i &lt; length; ++i)
    {
      /* if j-th bit of i-th row set */
      if (source[i] &amp; mask)
      /* then set i-th bit of j-th row */
        dest[j] |= 1 &lt;&lt; i;
    }
  }
}

int main() {
  byte a[5]= { 0b01111110,0b00010001,0b00010001,0b01111110,0b00000000 };
  byte b[8]= { 0 };
  printCharacter(a, 5);
  rotate(a, b, 5);
  printCharacter(b, 8);
  return 0;
}
</code></pre>

<p>Now this outputs</p>

<pre><code>- o o o o o o - 
o - - - o - - - 
o - - - o - - - 
- o o o o o o - 
- - - - - - - - 

- o o - - - - - 
o - - o - - - - 
o - - o - - - - 
o - - o - - - - 
o o o o - - - - 
o - - o - - - - 
o - - o - - - - 
- - - - - - - - 
</code></pre>

<p>which is not exactly what you are looking for, but you just need to adjust the mask/index to start from first/last bit according to the rotation you want.</p>
",,52788897,29
45528409,2,41925515,2017-08-06T04:00:06.403,1,,3015188,,2017-08-06T21:18:41.507,2017-08-06T21:18:41.507,0,,"<p>I was recently having the same issue myself and I spent several hours trying to figure this out. Ivanov, you have a good point about the length of the encoded data. The main problem is basically when the AES encrypt function creates additional padding and the decrypt function not being able to remove it.</p>

<p>This does not have anything to do with the null termination of the string or the fact that it lacks a terminator. The problem is actually solved by simply omitting the last 5 padding from the decrypted string.</p>

<p><strong>Edit</strong> This is actually more than just omitting 5 characters from the end. As I found out that the amount of gibberish or padding varies depending on the length of your original JSON, it makes more sense to trim the string by detecting the end of the JSON string.</p>

<p>I am providing my (updated) working code for reference. I hope this helps anyone who also has this issue! Good luck with your project!</p>

<pre><code>#include ""AES.h""
#include ""Base64.h""

AES aes;

// Our AES key. Same in NodeJS but in hex bytes
byte key[] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };
// The unitialized Initialization vector (16-bit)
byte iv[N_BLOCK] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

// NodeMCU side raw message
String msg = ""{\""x\"":10, \""y\"":20, \""z\"":30 \""lamp_stat\"":\""ON  This is a sentence. Testing testing testing\""}"";

uint8_t generate_random_unit8()
{
  uint8_t really_random = *(volatile uint8_t *)0x3FF20E44;
  return really_random;
}

// Generate a random initialization vector
void generate_iv(byte *vector)
{
  for (int i = 0; i &lt; N_BLOCK; i++)
  {
    vector[i] = (byte)generate_random_unit8();
  }
}

void encrypt()
{
  char b64data[200];
  byte cipher[1000];
  byte iv[N_BLOCK];

  generate_iv(iv);

  base64_encode(b64data, (char *)iv, N_BLOCK);
  String IV_base64 = String(b64data);
  Serial.println("" IV b64: "" + IV_base64);

  int b64len = base64_encode(b64data, (char *)msg.c_str(), msg.length());

  Serial.println("" The lenght is:  "" + String(b64len));

  // Encrypt! With AES128, our key and IV, CBC and pkcs7 padding
  aes.do_aes_encrypt((byte *)b64data, b64len, cipher, key, 128, iv);

  Serial.println(""Cipher size: "" + String(aes.get_size()));

  base64_encode(b64data, (char *)cipher, aes.get_size());
  Serial.println(""Encrypted data in base64: "" + String(b64data));

  //decrypt(b64data, IV_base64, aes.get_size());
}

void decrypt(String b64data, String IV_base64, int lsize)
{
  char data_decoded[300];
  char iv_decoded[300];
  byte out[300];
  char temp[300];
  b64data.toCharArray(temp, 300);
  base64_decode(data_decoded, temp, b64data.length());
  IV_base64.toCharArray(temp, 300);
  base64_decode(iv_decoded, temp, IV_base64.length());
  aes.do_aes_decrypt((byte *)data_decoded, lsize, out, key, 128, (byte *)iv_decoded);
  char message[msg.length()];
  base64_decode(message, (char *)out, aes.get_size());
  for (int i = 0; i &lt; aes.get_size(); i++)
  {
    char curChar = (char)message[i];
    if (curChar != '}')
      temp[i] = curChar;
    else
    {
      temp[i] = curChar;
      temp[i+1] = '\0';
      break;
    }
  }
  String result = String((char *)temp);
  Serial.println(result);
}

void setup_aes()
{
  aes.set_key(key, sizeof(key)); // Get the globally defined key
}

void setup()
{
  Serial.begin(115200);

}

void loop()
{
  encrypt();
  decrypt(""ipYk12VCYyD+aJ7KL7lO8L5zOq71XvsLzp650gKBFgQor7GHs98QpQSjQOZdhCwggq2Ehf4nVNwTeK3VjtqMVJRGBw9YViARXCTOGqctjFc="", ""+eNzSlRRPi0YZhrp5ctpnA=="", 83);
  delay(8000);
}
</code></pre>
",,52840483,496
41929440,2,41926178,2017-01-30T05:20:58.483,1,,3082873,,2017-01-31T07:32:15.033,2017-01-31T07:32:15.033,0,,"<p>Be sure <strong>pch</strong> is valid by printing it. Yo do not need to assign your <strong>dataStr</strong> to an other variable. Last, String class overloading function for equal operator. You can use the sample :</p>

<pre><code>String dataStr = esp8266.readString(); // get the information

char * pch = strstr (dataStr.c_str(), ""nonce""); 
char nonceChar[40];
memset(nonceChar, 0, 40);
strncpy (nonceChar, pch, 39);
String result =  nonceChar;

Serial.println(result);//it prints nothing
Serial.println(result.length()); //it prints 0
</code></pre>
",,52843224,72
41937901,2,41926178,2017-01-30T14:07:37.427,2,,7447144,,2017-01-30T14:07:37.427,,1,,"<p>The problem you illustrate in your example may be due to a null pointer; or you encounter weird behavior because of a non null-terminated char array.</p>

<p>In your small example you construct a char array that may not be null-terminated. I tried it but my compiler (arduino) tends to correct it by accident. Indeed it sees that str2 is like a constant so it puts it in program memory, and nothing in RAM memory. Hence it inializes array with 0. Yet it sees that the 40 cells are not used but the 3 first are simply copied to a String, thus it never creates <code>char str2[40]</code>. Your small code:</p>

<pre><code>char str2[40]
str2[0]='a';
str2[1]='b';
String v (str2);
Serial.println(v);
</code></pre>

<p>is usually converted ( / optimized) by the compiler as:</p>

<pre><code>String v (""ab"");  // note that ""ab"" is null-terminated
Serial.println(v);
</code></pre>

<p>or:</p>

<pre><code>Serial.println(""ab"");
</code></pre>

<p>Note that that tranformation is an example; the compiler will do other assumptions depending of what is written around.</p>

<p>I dont know exactly what you are doing in your program elsewhere, but I think you can do all with the <a href=""https://www.arduino.cc/en/Reference/StringObject"" rel=""nofollow noreferrer"">arduino String class</a>. For instance your main example should be something like that:</p>

<pre><code>  String dataStr(""deb,nonce,end"");
  int ind = dataStr.indexOf(""nonce"");
  String result = dataStr.substring(ind);
  Serial.println(result);
</code></pre>

<p>I am pretty sure you should not used old c string library; they are complicated to use and very dangerous. For instance <code>strncpy</code> is mostly useless, it gives you nothing more than strcpy. In <code>strncpy(nonceChar, pch, sizeof(nonceChar));</code>  if pch is too long, nonceChar wont be null-terminated ! In fact you could use <code>strlcpy</code> instead (it is available in my arduino linux v1.6.9 compiler).</p>

<p>Also you should check that <code>strstr</code> does not returns NULL pointer. Or better: use <code>indexOf</code>, and check that it does not return -1.</p>
",,52863942,324
41941298,2,41940235,2017-01-30T16:55:19.390,1,,586873,,2017-01-30T21:36:02.413,2017-01-30T21:36:02.413,3,,"<blockquote>
  <p>So if <code>gpiod</code> isn't a <code>stuct gpio_desc</code> what is then?</p>
</blockquote>

<p>It seems, that you are confusing a struct object with <em>pointer</em> to struct object. The type of <code>gpiod</code> object is the latter, <code>struct gpio_desc *</code>.</p>

<p>The API uses <a href=""https://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow noreferrer"">opaque pointer</a>, a common scheme of <em>struct encapsulation</em>.</p>

<p>A consumer can access or modify the struct using public functions, which operate on object indirectly, via pointer. The direct access is forbidden, as it would require to place <em>definition</em> of the struct within consumer translation unit.</p>

<p>The typical code layout may look like as follows (the code is only illustrative):</p>

<h3>Header file:</h3>

<pre><code>struct gpio_desc;

struct gpio_desc *create(void);
void modify(struct gpio_desc *);
</code></pre>

<h3>Source file:</h3>

<pre><code>// include header file

struct gpio_desc
{
    int secret_field_1;
    int secret_field_2;
};

struct gpio_desc *create(void)
{
    return malloc(sizeof(struct gpio_desc));   // definition required here
}

void modify(struct gpio_desc *p)
{
    p-&gt;secret_field_1 = 100;                   // definition required here too
    p-&gt;secret_field_2 = 200;
}
</code></pre>

<h3>API consumer:</h3>

<pre><code>// include header file

struct gpio_desc *gpiod = create();
modify(gpiod);
</code></pre>

<p>The idea is that consumer doesn't need or/and it's not supposed to know the internals of the struct. All operations are covered by calling public API functions.</p>
",,52932529,352
41992699,2,41990020,2017-02-02T01:10:25.547,1,,794749,,2017-02-02T01:10:25.547,,0,,"<p>You need to read the data and put it into a buffer. After you encounter a <code>' '</code> character you terminate the string inside the buffer and convert it into an int.<br>
When you do this three times you have read all three ints.</p>

<pre><code>const uint8_t buff_len = 7; // buffer size
char buff[buff_len]; // buffer
uint8_t buff_i = 0; // buffer index

int arr[3] = {0,0,0}; // number array
uint8_t arr_i = 0; // number array index

void loop() {
    while (Serial.available() &gt; 0) {
        char c = Serial.read();
        if (buff_i &lt; buff_len-1) { // check if buffer is full
            if (c == ' ') { // check if got number terminator
                buff[buff_i++] = 0; // terminate the string
                buff_i = 0; // reset the buffer index
                arr[arr_i++] = atoi(buff); // convert the string to int
                if (arr_i == 3) { // if got all three numbers
                    arr_i = 0; // reset the number array index

                    // do something with the three integers
                }
            }
            else if (c == '-' || ('0' &lt;= c &amp;&amp; c &lt;= '9')) // if negative sign or valid digit
                buff[buff_i++] = c; // put the char into the buffer
        }
    }
    // maybe do some other stuff
}
</code></pre>

<p>Or if you don't mind blocking code<sup>[1]</sup> you can use builtin <a href=""https://www.arduino.cc/en/Serial/ParseInt"" rel=""nofollow noreferrer""><code>ParseInt</code></a>.</p>

<pre><code>void loop() {
    while (Serial.available() &gt; 0) {
        arr[0] = Serial.parseInt();
        arr[1] = Serial.parseInt();
        arr[2] = Serial.parseInt();
        Serial.read(); // read off the last space

        // do something with the three integers
    }
    // maybe do some other stuff, but might be blocked by serial read
}
</code></pre>

<p><sup>[1] If your computer has a hiccup and doesn't send all the data at once, your Arduino code will just wait for data and won't be doing anything else. Read more <a href=""https://hackingmajenkoblog.wordpress.com/2016/02/01/reading-serial-on-the-arduino/"" rel=""nofollow noreferrer"">here</a>.</sup></p>
",,52963118,68
42024317,2,42024190,2017-02-03T12:27:28.467,4,,598696,,2017-02-03T12:27:28.467,,2,,"<p>Instead of having a <code>setupMIDI</code> function that sets some global variables, have a <code>MIDIContext</code> class that stores those values and initializes them via its constructor.</p>

<p>Users of <code>pin</code>, <code>delayTime</code>, and <code>debug</code> will either be <em>methods</em> of <code>MIDIContext</code> or take a <code>MIDIContext&amp;</code> <em>(<code>const&amp;</code> where appropriate)</em> to access the values.</p>

<p>Example:</p>

<pre><code>class MIDIContext
{
private:
    byte pin;
    int delayTime;
    bool debug;

public:
    MIDIContext(byte x_pin, int x_delayTime, bool x_debug) 
        : pin{x_pin}, delayTime{x_delayTime}, debug{x_debug}
    {
    }

    void sendMIDI();
};

class Analog
{
    void refresh (MIDIContext&amp; ctx);
};
</code></pre>

<p>Possible usage:</p>

<pre><code>Analog a1( ... );
Analog a2( ... );
Digital d1( ... );

MIDIContext context(13, 10, true);

while(true) {
  a1.refresh(context);
  a2.refresh(context);
  d1.refresh(context);
}
</code></pre>
",,52978879,51
42040814,2,42038243,2017-02-04T13:15:15.117,0,,6024122,,2017-02-04T13:15:15.117,,1,,"<p>Here:</p>

<pre><code>  while(true){
      cr = myFile.read();
      if((cr == '\n')||(cr == '\r'))
          break;
      lcd.print(cr);
  }
</code></pre>

<p>you have some code that is supposed to read, and print, all characters on the 16th line of your file, and <strong>stop</strong> when a <em>newline</em> character is found.</p>

<p>It looks acceptable, but <strong>what if</strong> the <em>16th line</em> is <strong>not terminated</strong> by <code>\n</code> or <code>\r</code> ?</p>

<p>The <a href=""https://www.arduino.cc/en/Serial/Read"" rel=""nofollow noreferrer"">documentation</a> of <code>read()</code> says that this function returns <code>-1</code> if there is no data available. Clearly, if the file ends without a <em>newline</em>, that is precisely what is going to happen. So now you are <strong>stuck</strong> in a loop in which you read <code>-1</code> endlessly, but why do you see those <em>white blocks</em> on screen?</p>

<p>Let's see. <code>lcd.print(char)</code> is inherited from <code>class Print</code>, and it <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/Print.cpp"" rel=""nofollow noreferrer"">contains</a> the following code:</p>

<pre><code>size_t Print::print(char c)
{
  return write(c);
}
</code></pre>

<p>inside <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/Print.h"" rel=""nofollow noreferrer""><code>Print.h</code></a>, <code>Print::write(uint8_t)</code> is declared to be a <strong>purely virtual method</strong>, which means that its implementation can be found in one of its sub-classes, in this case <a href=""https://github.com/arduino/Arduino/blob/master/libraries/LiquidCrystal/src/LiquidCrystal.cpp"" rel=""nofollow noreferrer""><code>LiquidCrystal.cpp</code></a>: </p>

<pre><code>inline size_t LiquidCrystal::write(uint8_t value) {
  send(value, HIGH);
  return 1; // assume sucess
}
</code></pre>

<p>Now, we find out that the original <code>-1</code> of type <code>char</code>, which is encoded as <code>0xFF</code>, is interpreted as <code>255</code> of type <code>uint8_t</code>. A quick look at the following table</p>

<p><a href=""https://i.stack.imgur.com/xLXYZ.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xLXYZ.gif"" alt=""enter image description here""></a></p>

<p>reveals that 255 (last column, last row) corresponds to a full black square. </p>

<p>Ok, we are almost there, only that you see <em>white squares</em> rather than <em>black squares</em>. On this regard, it should be noted that your code is <em>continuosly</em>, and without <strong>any delay</strong>, printing stuff on the <em>lcd</em>. So it is likely that the <em>lcd screen</em> keeps being <strong>refreshed</strong> <em>(and its content possibly shifted?)</em>, thus making the <em>black blocks</em> appear <em>whiter</em> than they truly are.</p>

<hr>

<p><strong>TL;DR Solution:</strong> </p>

<pre><code>  while(true){
      cr = myFile.read();
      if((cr == '\n')||(cr == '\r') || (cr &lt; 0))
          break;
      lcd.print(cr);
  }
</code></pre>
",,52982967,80
42050459,2,42049969,2017-02-05T09:29:25.917,3,,4386427,,2017-02-05T09:57:38.763,2017-02-05T09:57:38.763,1,,"<p>You are reading and writing outside array boundaries.</p>

<p>Look at this part:</p>

<pre><code>for (int a = 0; a &lt; 8; a++) {
    *ptr++ = *fieldPtr++;
</code></pre>

<p>In the first loop you access <code>UTC</code> through <code>fieldPtr</code>. In memory <code>UTC</code> looks like:</p>

<pre><code>'1' '2' '0' '4' '3' '5' '\0'
</code></pre>

<p>So when <code>a</code> is <code>0</code> you read <code>1</code>, when <code>a</code> is <code>1</code> you read <code>2</code> and so on. Like:</p>

<pre><code>'1' '2' '0' '4' '3' '5' '\0' 
 ^   ^   ^   ^   ^   ^   ^   ^
a=0 a=1 a=2 a=3 a=4 a=5 a=6 a=7
</code></pre>

<p>For <code>a=7</code> you read outside the array which is illegal (i.e. undefined bahvior).</p>

<p>For the writing part it is more or less the same. Except that you have two extra increments of <code>ptr</code>. So the writing is:</p>

<pre><code>TIME[0] TIME[1] TIME[2] TIME[3] TIME[4] TIME[5] TIME[6] TIME[7] TIME[8]
 ^       ^       ^       ^       ^       ^       ^       ^       ^       ^
a=0     a=1     a=1     a=2     a=3     a=3     a=4     a=5     a=6     a=7
</code></pre>

<p>So again - when <code>a=7</code> you write outside <code>TIME</code>. In fact you write once more after the loop: <code>*ptr = '\0';</code></p>

<p>So all together ""Undefined behavior"".</p>

<p>When you have undefined behavior it doesn't make sense from a language point of view to discuss what is going on.</p>

<p>However, you can analyse what happened on your specific system. It could be that when you write to <code>DATE</code> in the second loop and write outside the <code>DATE</code> array, the data written may end up in <code>TIME</code> and thereby destroying the original value and consequently you get wrong prints. Once again - notice that this would be system specific. On my system your code produce the expected output despite the undefined behavior.</p>

<p>To fix you problem see the answer from @PaulOgilvie</p>

<p>Since you are dealing with small fixed size input strings an alternative solution that avoid all the pointer stuff, could be:</p>

<pre><code>  char *UTC = ""120435"";
  char TIME[9];
  if (strlen(UTC) == 6)
  {
      sprintf(TIME, ""%c%c:%c%c:%c%c"", UTC[0], UTC[1], UTC[2], UTC[3], UTC[4], UTC[5]);
      printf(""%s\n"", TIME);
  }
  else
  {
    printf(""wrong format\n"");

    // .... add error handling here ....
  }
</code></pre>
",,52983680,77
42079309,2,42079140,2017-02-06T23:44:06.760,2,,589924,,2017-02-07T20:47:42.687,2017-02-07T20:47:42.687,5,,"<p><code>sprintf ""%X""</code> can be used to convert to hex, but it can't do arbitrary sized arrays without some effort. Might as well put that effort into something more direct.</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

static const char* const HEX_CHARS = ""0123456789ABCDEF"";

ssize_t to_hex(char* dest, size_t dest_size, const void* src, size_t src_size) {
   if (dest == NULL)
      return src_size*2+1;

   if (dest_size &lt; src_size*2+1)
      return -1;

   while (src_size--) {
      *(dest++) = HEX_CHARS[*((const uint8_t*)src) &gt;&gt; 4];
      *(dest++) = HEX_CHARS[*((const uint8_t*)src) &amp; 0xF];
      src = (const uint8_t*)src + 1;
   }

   *dest = '\0';
   return src_size*2+1;
}
</code></pre>
",,52999277,857
42102865,2,42079140,2017-02-08T01:02:45.433,0,,4967617,,2017-02-08T01:02:45.433,,0,,"<p>**SOLVED! </p>

<p>For clarity, I wanted this string format ""047E0B72443484"" because my ultimate goal was to send this data out by JSON (ArduinoJson.h library)</p>

<p>I ultimately accomplished what I was trying to do when I noticed that the JSON library included a function to send an array.</p>

<pre><code>JsonArray&amp; uid = root.createNestedArray(""UID"");
uid.add(testArray[0]);
uid.add(testArray[1]);
uid.add(testArray[2]);
uid.add(testArray[3]);
</code></pre>

<p>and this allowed me to get a JSON out of: </p>

<p>{ ""UID"":[4,126,11,114] }</p>

<p>which was exactly what I was trying to do</p>
",,53036331,41
42160870,2,42151118,2017-02-10T13:43:59.467,1,,6232717,,2017-02-10T13:43:59.467,2017-05-23T12:33:40.730,0,,"<p><a href=""https://stackoverflow.com/a/42151214/6232717"">Alex Zywicki's answer</a> is perfect for cases where it doesn't matter if you redefine the macro. But, to be safe or if you need to ensure the macro gets defined back to its previous definition, you can use <a href=""https://gcc.gnu.org/onlinedocs/gcc/Push_002fPop-Macro-Pragmas.html"" rel=""nofollow noreferrer"">the <code>push_macro</code> and <code>pop_macro</code> pragmas</a> (assuming your compiler supports it):</p>

<pre><code>#ifdef MEDIAN_MAX_SIZE
#pragma push_macro(""MEDIAN_MAX_SIZE"")
#define MEDIAN_MAX_SIZE 30

// Use the modified value for MEDIAN_MAX_SIZE here

#pragma pop_macro(""MEDIAN_MAX_SIZE"")
</code></pre>

<p>This allows you to temporarily redefine macros for a block of code.</p>
",,53072356,528
42180887,2,42173716,2017-02-11T20:29:20.473,0,,6024122,,2017-02-11T21:28:42.610,2017-02-11T21:28:42.610,0,,"<p><em>Note: I realize that this answer doesn't meet all of your requirements, in fact this approach still requires you to list the names of relevant Arduino Libraries that you use in your project, as well as a list of paths to directories that should be included in the project. However, this solution is the closest to your requirements that I could think of and it might still help someone else reading this question down the road.</em></p>

<hr>

<p>I use <em>Arduino</em> <strong>Makefile</strong> for this:</p>

<ol>
<li>put <strong>Makefile.master</strong> in your main work-space directory</li>
<li>when you start a new <em>Arduino</em> project, you create it as a sub-directory in your workspace

<ul>
<li>create a single file with <code>.pde/.ino</code> extension containing <code>setup()</code> and `loop() methods</li>
<li>put the remaining logic into <code>.c/.cpp/.h/.hpp</code> files</li>
</ul></li>
<li><p>add a <em>project Makefile</em> that sets project-refined settings in this sub-directory, e.g.:</p>

<pre><code># Your Arduino environment.
ARD_HOME = /usr/share/arduino
ARD_BIN = $(ARD_HOME)/hardware/tools/avr/bin

# Monitor Baudrate
MON_SPEED = 4800

# Board settings.
BOARD = uno
PORT = /dev/ttyACM0
PROGRAMMER = stk500v2

# Where to find header files and libraries.
INC_DIRS =
MY_LIB_DIRS =
LIBS =
LIB_DIRS = $(addprefix $(ARD_HOME)/libraries/, $(LIBS)) $(MY_LIB_DIRS)

include ../Makefile.master
</code></pre></li>
<li><p>compile and run using <code>make all</code>, <code>make upload</code>, <code>make monitor</code>, etc.</p></li>
</ol>

<p>Ensure that you have <strong>picocom</strong> installed on your <em>Unix/Linux</em> machine (or equivalent) as <em>console serial monitor</em>. On <em>MAC-OS</em>, you can use <strong>screen</strong> by setting the <code>MON_CMD</code> variable accordingly.</p>

<hr>

<p><strong>Makefile.master:</strong></p>

<p>The original <strong>Makefile.master</strong> was written by <code>Alan Burlison</code> and modified by <code>Matthieu Weber</code>, and can be found <a href=""http://weber.fi.eu.org/software/arduino/Makefile.master"" rel=""nofollow noreferrer"">here</a>.</p>

<p>I made some changes so that it fits my configuration, in particular I've added these lines of code:</p>

<pre><code>### DEBUG Compilation ###
ifeq ($(DEBUG), 1)
    ARD_FLAGS += -DDEBUG_PROJ
    C_FLAGS += -g
    CXX_FLAGS += -g
else
    ARD_FLAGS += -DNDEBUG_PROJ
endif
</code></pre>

<p>and subsequently removed <code>-g</code> option from default <code>C/CXX _FLAGS</code> entries in <strong>Makefile.master</strong>. In this way <em>symbol information</em> is not added on <em>release</em> code, and only when code is compiled with <code>DEBUG=1</code> the code shielded by </p>

<pre><code>#ifdef DEBUG_PROJ
    /* debug code here */
#endif
// or
#ifndef NDEBUG_PROJ
    /* debug code here */
#endif
</code></pre>

<p>finds its way into the binary, thus resulting smaller <em>release</em> executables.</p>

<p>Here you can find <em>my own</em> version of the <strong>Makefile.master</strong>:</p>

<pre><code>#
# Copyright 2011 Alan Burlison, alan@bleaklow.com.  All rights reserved.
# Subsequently modified by Matthieu Weber, matthieu.weber@jyu.fi.
# Subsequently modified by Patrick Trentin, patrick.trentin.88@gmail.com
# Use is subject to license terms.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  1. Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY ALAN BURLISON ""AS IS"" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL ALAN BURLISON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Makefile for building Arduino projects outside of the Arduino environment
#
# This makefile should be included into a per-project Makefile of the following
# form:
#
# ----------
# BOARD = mega
# PORT = /dev/term/0
# INC_DIRS = ../common
# LIB_DIRS = ../libraries/Task ../../libraries/VirtualWire
# include ../../Makefile.master
# ----------
#
# Where:
#   BOARD    : Arduino board type, from $(ARD_HOME)/hardware/boards.txt
#   PORT     : USB port
#   INC_DIRS : List pf directories containing header files
#   LIB_DIRS : List of directories containing library source
#
# Before using this Makefile you can adjust the following macros to suit
# your environment, either by editing this file directly or by defining them in
# the Makefile that includes this one, in which case they will override the
# definitions below:
#   ARD_REV      : arduino software revision, e.g. 0017, 0018
#   ARD_HOME     : installation directory of the Arduino software.
#   ARD_BIN      : location of compiler binaries
#   AVRDUDE      : location of avrdude executable
#   AVRDUDE_CONF : location of avrdude configuration file
#   PROGRAMMER   : avrdude programmer type
#   MON_TERM     : terminal command for serial monitor
#   MON_CMD      : serial monitor command
#   MON_SPEED    : serial monitor speed
#

# Global configuration.
ARD_REV ?= 100
ARD_HOME ?= /usr/local/arduino
ARD_BIN ?= /usr/bin
AVRDUDE ?= $(ARD_HOME)/hardware/tools/avrdude
AVRDUDE_CONF ?= $(ARD_HOME)/hardware/tools/avrdude.conf
MON_TERM ?= xterm
MON_SPEED ?= 57600
MON_CMD ?= picocom
PORT ?= $(HOME)/dev/arduino
BOARD ?= atmega328

### Nothing below here should require editing. ###

# Check for the required definitions.

ifndef BOARD
    $(error $$(BOARD) not defined)
endif
ifndef PORT
    $(error $$(PORT) not defined)
endif

# Version-specific settings
ARD_BOARDS = $(ARD_HOME)/hardware/arduino/boards.txt
ARD_SRC_DIR = $(ARD_HOME)/hardware/arduino/cores/arduino
ARD_MAIN = $(ARD_SRC_DIR)/main.cpp

# Standard macros.
SKETCH = $(notdir $(CURDIR))
BUILD_DIR = build
VPATH = $(LIB_DIRS)

# Macros derived from boards.txt
MCU := $(shell sed -n 's/$(BOARD)\.build\.mcu=\(.*\)/\1/p' &lt; $(ARD_BOARDS))
F_CPU := $(shell sed -n 's/$(BOARD)\.build\.f_cpu=\(.*\)/\1/p' &lt; $(ARD_BOARDS))
UPLOAD_SPEED := \
    $(shell sed -n 's/$(BOARD)\.upload\.speed=\(.*\)/\1/p' &lt; $(ARD_BOARDS))
PROGRAMMER := \
    $(shell sed -n 's/$(BOARD)\.upload\.protocol=\(.*\)/\1/p' &lt; $(ARD_BOARDS))
ARD_VAR := \
    $(shell sed -n 's/$(BOARD)\.build\.variant=\(.*\)/\1/p' &lt; $(ARD_BOARDS))

# More Version-specific settings
ARD_VAR_DIR = $(ARD_HOME)/hardware/arduino/variants/$(ARD_VAR)

# Build tools.
CC = $(ARD_BIN)/avr-gcc
CXX = $(ARD_BIN)/avr-g++
CXXFILT = $(ARD_BIN)/avr-c++filt
OBJCOPY = $(ARD_BIN)/avr-objcopy
OBJDUMP = $(ARD_BIN)/avr-objdump
AR = $(ARD_BIN)/avr-ar
SIZE = $(ARD_BIN)/avr-size
NM = $(ARD_BIN)/avr-nm
MKDIR = mkdir -p
RM = rm -rf
MV = mv -f
LN = ln -f

# Compiler flags.
INC_FLAGS = \
    $(addprefix -I,$(INC_DIRS)) $(addprefix -I,$(LIB_DIRS)) -I$(ARD_SRC_DIR) -I$(ARD_VAR_DIR)
ARD_FLAGS = -mmcu=$(MCU) -DF_CPU=$(F_CPU) -DARDUINO=$(ARD_REV)
C_CXX_FLAGS = \
    -Wall -Wextra -Wundef -Wno-unused-parameter \
    -fdiagnostics-show-option -Wa,-adhlns=$(BUILD_DIR)/$*.lst
C_FLAGS = \
    $(C_CXX_FLAGS) -std=gnu99 -Wstrict-prototypes -Wno-old-style-declaration
CXX_FLAGS = $(C_CXX_FLAGS)

### DEBUG Compilation ###
ifeq ($(DEBUG), 1)
    ARD_FLAGS += -DDEBUG_PROJ
    C_FLAGS += -g
    CXX_FLAGS += -g
else
    ARD_FLAGS += -DNDEBUG_PROJ
endif

# Optimiser flags.
#     optimise for size, unsigned by default, pack data.
#     separate sections, drop unused ones, shorten branches, jumps.
#     don't inline, vectorise loops. no exceptions.
#     no os preamble, use function calls in prologues.
# http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/
# http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
OPT_FLAGS = \
     -Os -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums \
    -ffunction-sections -fdata-sections -Wl,--gc-sections,--relax \
    -fno-inline-small-functions -fno-tree-scev-cprop -fno-exceptions \
    -ffreestanding -mcall-prologues

# Build parameters.
IMAGE = $(BUILD_DIR)/$(SKETCH)
ARD_C_SRC = $(wildcard $(ARD_SRC_DIR)/*.c)
ARD_CXX_SRC = $(wildcard $(ARD_SRC_DIR)/*.cpp)
ARD_C_OBJ = $(patsubst %.c,%.o,$(notdir $(ARD_C_SRC)))
ARD_CXX_OBJ = $(patsubst %.cpp,%.o,$(notdir $(ARD_CXX_SRC)))
ARD_LIB = arduino
ARD_AR = $(BUILD_DIR)/lib$(ARD_LIB).a
ARD_AR_OBJ = $(ARD_AR)($(ARD_C_OBJ) $(ARD_CXX_OBJ))
ARD_LD_FLAG = -l$(ARD_LIB)

# Workaround for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34734
$(ARD_AR)(Tone.o) : CXX_FLAGS += -w

# Sketch libraries.
LIB_C_SRC = $(foreach ld,$(LIB_DIRS),$(wildcard $(ld)/*.c))
LIB_CXX_SRC = $(foreach ld,$(LIB_DIRS),$(wildcard $(ld)/*.cpp))
LIB_SRC = $(LIB_C_SRC) $(LIB_CXX_SRC)
ifneq ""$(strip $(LIB_C_SRC) $(LIB_CXX_SRC))"" """"
    LIB_C_OBJ = $(patsubst %.c,%.o,$(notdir $(LIB_C_SRC)))
    LIB_CXX_OBJ = $(patsubst %.cpp,%.o,$(notdir $(LIB_CXX_SRC)))
    LIB_LIB = library
    LIB_AR = $(BUILD_DIR)/lib$(LIB_LIB).a
    LIB_AR_OBJ = $(LIB_AR)($(LIB_C_OBJ) $(LIB_CXX_OBJ))
    LIB_LD_FLAG = -l$(LIB_LIB)
endif

# Sketch PDE source.
SKT_PDE_SRC = $(wildcard *.pde *.ino)
ifneq ""$(strip $(SKT_PDE_SRC))"" """"
    SKT_PDE_OBJ = $(BUILD_DIR)/$(SKETCH)_pde.o
endif

# C and C++ source.
SKT_C_SRC = $(wildcard *.c)
SKT_CXX_SRC = $(wildcard *.cpp)
ifneq ""$(strip $(SKT_C_SRC) $(SKT_CXX_SRC))"" """"
    SKT_C_OBJ = $(patsubst %.c,%.o,$(SKT_C_SRC))
    SKT_CXX_OBJ = $(patsubst %.cpp,%.o,$(SKT_CXX_SRC))
    SKT_LIB = sketch
    SKT_AR = $(BUILD_DIR)/lib$(SKT_LIB).a
    SKT_AR_OBJ = $(SKT_AR)/($(SKT_C_OBJ) $(SKT_CXX_OBJ))
    SKT_LD_FLAG = -l$(SKT_LIB)
endif

# Definitions.
define run-cc
    @ $(CC) $(ARD_FLAGS) $(INC_FLAGS) -M -MT '$@($%)' -MF $@_$*.dep $&lt;
    $(CC) -c $(C_FLAGS) $(OPT_FLAGS) $(ARD_FLAGS) $(INC_FLAGS) \
        $&lt; -o $(BUILD_DIR)/$%
    @ $(AR) rc $@ $(BUILD_DIR)/$%
    @ $(RM) $(BUILD_DIR)/$%
    @ $(CXXFILT) &lt; $(BUILD_DIR)/$*.lst &gt; $(BUILD_DIR)/$*.lst.tmp
    @ $(MV) $(BUILD_DIR)/$*.lst.tmp $(BUILD_DIR)/$*.lst
endef

define run-cxx
    @ $(CXX) $(ARD_FLAGS) $(INC_FLAGS) -M -MT '$@($%)' -MF $@_$*.dep $&lt;
    $(CXX) -c $(CXX_FLAGS) $(OPT_FLAGS) $(ARD_FLAGS) $(INC_FLAGS) \
        $&lt; -o $(BUILD_DIR)/$%
    @ $(AR) rc $@ $(BUILD_DIR)/$%
    @ $(RM) $(BUILD_DIR)/$%
    @ $(CXXFILT) &lt; $(BUILD_DIR)/$*.lst &gt; $(BUILD_DIR)/$*.lst.tmp
    @ $(MV) $(BUILD_DIR)/$*.lst.tmp $(BUILD_DIR)/$*.lst
endef

# Rules.
.PHONY : all clean upload monitor upload_monitor

all : $(BUILD_DIR) $(IMAGE).hex

clean :
    $(RM) $(BUILD_DIR)

$(BUILD_DIR) :
    $(MKDIR) $@

$(SKT_PDE_OBJ) : $(SKT_PDE_SRC)
    if [ $(ARD_REV) -ge 100 ]; then \
    echo '#include ""Arduino.h""' &gt; $(BUILD_DIR)/$(SKETCH)_pde.cpp; \
    else \
    echo '#include ""WProgram.h""' &gt; $(BUILD_DIR)/$(SKETCH)_pde.cpp; \
    fi
    echo '#include ""$(SKT_PDE_SRC)""' &gt;&gt; $(BUILD_DIR)/$(SKETCH)_pde.cpp
    $(LN) $(SKT_PDE_SRC) $(BUILD_DIR)/$(SKT_PDE_SRC)
    cd $(BUILD_DIR) &amp;&amp; $(CXX) -c $(subst build/,,$(CXX_FLAGS)) \
        $(OPT_FLAGS) $(ARD_FLAGS) -I.. \
        $(patsubst -I..%,-I../..%,$(INC_FLAGS)) \
        $(SKETCH)_pde.cpp -o $(@F)

(%.o) : $(ARD_SRC_DIR)/%.c
    $(run-cc)

(%.o) : $(ARD_SRC_DIR)/%.cpp
    $(run-cxx)

(%.o) : %.c
    $(run-cc)

(%.o) : %.cpp
    $(run-cxx)

$(BUILD_DIR)/%.d : %.c
    $(run-cc-d)

$(BUILD_DIR)/%.d : %.cpp
    $(run-cxx-d)

$(IMAGE).hex : $(ARD_AR_OBJ) $(LIB_AR_OBJ) $(SKT_AR_OBJ) $(SKT_PDE_OBJ)
    $(CC) $(CXX_FLAGS) $(OPT_FLAGS) $(ARD_FLAGS) -L$(BUILD_DIR) \
        $(SKT_PDE_OBJ) $(SKT_LD_FLAG) $(LIB_LD_FLAG) $(ARD_LD_FLAG) -lm \
        -o $(IMAGE).elf
    $(OBJCOPY) -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load \
        --no-change-warnings --change-section-lma .eeprom=0 $(IMAGE).elf \
        $(IMAGE).eep
    $(OBJCOPY) -O ihex -R .eeprom $(IMAGE).elf $(IMAGE).hex
    $(OBJDUMP) -h -S $(IMAGE).elf | $(CXXFILT) -t &gt; $(IMAGE).lst
    $(SIZE) $(IMAGE).hex

upload : all
    - pkill -f '$(MON_CMD).*$(PORT)'
    - sleep 1
    - stty -F $(PORT) hupcl
    - $(AVRDUDE) -V -C$(AVRDUDE_CONF) -p$(MCU) -c$(PROGRAMMER) -P$(PORT) \
        -b$(UPLOAD_SPEED) -D -Uflash:w:$(IMAGE).hex:i

monitor :
    LD_LIBRARY_PATH= LD_PRELOAD= \
        $(MON_TERM) -title '$(BOARD) $(PORT)' \
        -e '$(MON_CMD) -b $(MON_SPEED) $(PORT)' &amp;

upload_monitor : upload monitor

-include $(wildcard $(BUILD_DIR)/*.dep))
# vim:ft=make
</code></pre>

<hr>

<p><strong>Use Example:</strong></p>

<p>Given a <em>dir-tree</em> like follows:</p>

<pre><code>Base_Dir
├── Library
│   ├── Base
│   │   ├── general STM8 sources and headers 
│   ├── STM8S_Discovery
│   │   └── board specific sources and headers
│   └── User
│       └── optional user library sources and headers
├── Projects
│   ├── Examples (to be filled)
│   │   └── Basic_Project
│   │       ├── config.h
│   │       ├── example.ino
│   │       └── Makefile           --&gt; should detect dependencies in ./*.c and ./*.h
...
</code></pre>

<p>You could place <code>Makefile.master</code> within <code>Projects</code>, then assuming that:</p>

<ul>
<li>You only need what is in <code>Library/Base</code> and <code>Library/User</code> for this project</li>
<li>You need to use <em>LiquidCrystal</em> Arduino Library in your project</li>
</ul>

<p>then you would add the following <code>Makefile</code> into <code>Basic Project</code>:</p>

<pre><code># Your Arduino environment.
BASE_DIR = /path/to/Base_Dir              # to edit
ARD_HOME = /usr/share/arduino             # to edit, maybe
ARD_BIN = $(ARD_HOME)/hardware/tools/avr/bin

# Monitor Baudrate
MON_SPEED = 4800

# Board settings.
BOARD = uno
PORT = /dev/ttyACM0
PROGRAMMER = stk500v2

# Where to find header files and libraries.
INC_DIRS =
MY_LIB_DIRS= $(BASE_DIR)/Library/Base $(BASE_DIR)/Library/User 
LIBS= LiquidCrystal
LIB_DIRS = $(addprefix $(ARD_HOME)/libraries/, $(LIBS)) $(MY_LIB_DIRS)

include ../../Makefile.master
</code></pre>

<p>Note that <code>common.h</code> should be automatically detected because it is located in <code>.</code>, and there should be no need to add the latter to <code>INC_DIRS</code>.</p>

<hr>

<p><em>Final Note:</em> last time I tested this configuration I was using version <code>1.0.5</code> of <em>Arduino</em> source code, and it was working flawlessly.</p>
",,53091205,887
42311994,2,42173716,2017-02-18T06:39:36.480,0,,7549304,,2017-02-18T06:39:36.480,,0,,"<p>thanks again for your support! </p>

<p>Following the above advice I wrote a small python script, which uses the gcc (or actually sdcc) dependency generator. The below script scans all project .c files for <em>#included</em> headers using gcc. The respective header files are then searched in the project and library folders. If a corresponding .c file exist (same path and name as header), it is added to the Makefile. This process is repeated until no more new headers are found. </p>

<p>The result is a Makefile which only builds modules which are <em>#included</em> modules in the project .c files - just as in the Arduino IDE. It may not be elegant but the job  :-)</p>

<p>Lines 95-106 in the script are compiler and project specific, and have to be adapted accordingly. Have fun and thanks again!</p>

<pre><code>#!/usr/bin/python

'''
 automatically create a Makefile with dependencies from
 all .c files in a starting directory 
'''

# required modules
import sys
import os
import platform
import shlex
from subprocess import Popen, PIPE

# set OS specific
OS = platform.system()
if OS == 'Windows':
  MAKE      = 'mingw32-make.exe'
else:
  MAKE      = 'make'


##################
# helper functions
##################

#########
def getchar():
  """"""
   python equivalent of getchar()
  """"""
  ch = 0
  if OS == 'Windows':
    import msvcrt as m
    ch = m.getch()
    sys.stdio.flush()
    sys.stderr.flush()
  else:
    import sys, tty, termios
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    tty.setraw(sys.stdin.fileno())
    ch = sys.stdin.read(1)
  return ch
  # end getchar()


#########
def listFiles( start='.', pattern='.c' ):
  """"""
   return set of matching files in project folder incl. subfolders
  """"""
  result = set()
  for root, dirs, files in os.walk(start):
    for file in files:
      if file.endswith(pattern):
        #print(os.path.join(root, file))
        result.add(os.path.join(root, file))
  return result
  # end listFiles()


#########
def listSubdirs( start='.' ):
  """"""
   return set of subdirectories in given folder
  """"""
  result = set()
  for root, dirs, files in os.walk(start):
    for dir in dirs:
      #print(os.path.join(root, dir))
      result.add(os.path.join(root, dir))
  return result
  # end listFiles()


#########
def get_exitcode_stdout_stderr(cmd):
  """"""
   execute the external command and get its exitcode, stdout and stderr.
  """"""
  args = shlex.split(cmd)
  proc = Popen(args, stdout=PIPE, stderr=PIPE)
  out, err = proc.communicate()
  exitcode = proc.returncode
  return exitcode, out, err



##################
# main program
##################

# set compile search paths
ROOT_DIR = '../../../'
TOOL_DIR = ROOT_DIR + 'Tools/'
LIB_ROOT = ROOT_DIR + 'Library/'
PRJ_ROOT = '.'
OBJDIR   = 'output'
TARGET   = 'main.ihx'

# set command for creating dependencies and set search paths 
CC       = 'sdcc '
CFLAGS   = '-mstm8 --std-sdcc99 --std-c99 '
LFLAGS   = '-mstm8 -lstm8 --out-fmt-ihx '
DEPEND   = '-MM '
INCLUDE  = '-I. '
for dir in listSubdirs(PRJ_ROOT):
  INCLUDE += '-I' + dir + ' '
for dir in listSubdirs(LIB_ROOT):
  INCLUDE += '-I' + dir + ' '

# get set of .c files in project folder incl. subdirectories
source_todo = listFiles(PRJ_ROOT,"".c"")
source_done = set()
header_done = set()
object_done = set()


# print message
sys.stdout.write('start Makefile creation ... ')
sys.stdout.flush()


# generate generic Makefile header
Makefile = open('Makefile', 'wb')
Makefile.write('OBJDIR   = '+OBJDIR+'\n')
Makefile.write('TARGET   = '+TARGET+'\n\n')
Makefile.write('.PHONY: clean all default objects\n\n')
Makefile.write('.PRECIOUS: $(TARGET)\n\n')
Makefile.write('default: $(OBJDIR) $(OBJDIR)/$(TARGET)\n\n')
Makefile.write('all: default\n\n')
Makefile.write('# create output folder\n')
Makefile.write('$(OBJDIR):\n')
Makefile.write('    mkdir -p $(OBJDIR)\n')
Makefile.write('    rm -fr -- -p\n\n')

# iteratively add project sources to Makefile
while (len(source_todo) &gt; 0):

  # get next pending source and mark as done
  source = source_todo.pop()
  source_done.add(source)

  # convert Windows path to POSIX for Makefile
  if OS == 'Windows':
    source = source.replace('\\','/')

  # use compiler generate dependency list
  cmd = CC+DEPEND+CFLAGS+INCLUDE+source
  #print cmd
  exitcode, out, err = get_exitcode_stdout_stderr(cmd)
  if (exitcode != 0):
    print 'error: ' + err
    getchar()
    exit()

  # append .c file with dependency and compile instruction to Makefile
  Makefile.write('$(OBJDIR)/'+out)
  #print(out)
  Makefile.write('\t'+CC+CFLAGS+INCLUDE+'-c $&lt; -o $@\n\n')

  # extract file list including object[0], source[1] and headers[2..N]
  out = out.replace(':', '')
  out = out.replace('\\', '')
  out = out.replace('\n', '')
  out = out.split()
  #print out

  # for all files returned by compiler...
  for next in out:

    # append object files for linker
    if next.endswith('.rel'):
      object_done.add(next)

    # if corresponding source to header exists, add to pending sources
    if next.endswith('.h'):
      if next not in header_done:           # not yet in list
        header_done.add(next)                 # add to treated headers
        if (os.path.isfile(next[:-1]+'c')):   # if corresponding .c exists, add to todo list
          source_todo.add(next[:-1]+'c')


# link project object files
Makefile.write('$(OBJDIR)/$(TARGET): ')
for next in object_done:
  Makefile.write('$(OBJDIR)/'+next+' ')
Makefile.write('\n')
Makefile.write('\t'+CC+LFLAGS)
for next in object_done:
  Makefile.write('$(OBJDIR)/'+next+' ')
Makefile.write(' -o $@\n')

# close Makefile.dep
Makefile.close()


print('done\n')
sys.stdout.write('press any key to exit')
getchar()
exit()

# END OF MODULE
</code></pre>
",,53116860,115
42180852,2,42180378,2017-02-11T20:26:26.920,2,,6462432,,2017-02-11T20:41:30.240,2017-02-11T20:41:30.240,1,,"<p>The example states:</p>

<blockquote>
  <p>The message structure has a single field called data which can be
  treated as a std::vector type in your C++ node.</p>
</blockquote>

<p>But that does not apply to your case, since instead of using an underlying <code>std::vector</code>-like implementation, it defaulted to a plain <code>float</code> array, likely due to Arduino particularities (see <a href=""http://wiki.ros.org/rosserial"" rel=""nofollow noreferrer"">rosserial</a>).</p>

<p>You have to work with <code>vec3_msg.data</code> like with any other plain array. So:</p>

<pre><code>vec3_msg.data = (float*)malloc(sizeof(float) * 9);
for (int i = 0; i &lt; 9; ++i)
{
    vec3_msg.data[i] = someValue;
}
</code></pre>

<p>is one way.</p>

<p>You probably want to keep a static array that you work with somewhere, and make your message's data point to it.</p>

<pre><code>float myGlobalArray[9];

setup()
{
    vec3_msg.data = myGlobalArray;
}

// change myGlobalArray here and the
// data will update too.
</code></pre>

<p>Remember to set <code>vec3_msg.data_length</code> to 9 since in your case it's necessary. See <a href=""https://web.archive.org/web/20160711134453/http://answers.ros.org/question/10988/use-multiarray-in-rosserial/"" rel=""nofollow noreferrer"">this answer</a> and the <a href=""http://docs.ros.org/api/std_msgs/html/msg/MultiArrayLayout.html"" rel=""nofollow noreferrer"">MultiArrayLayout docs</a> for extra info.</p>
",,53122140,59
42204872,2,42197185,2017-02-13T13:10:49.653,1,,6628708,,2017-02-13T13:10:49.653,,2,,"<p>You need to manually allocate memory to store the temperature value. It will be freed in the<code>log_record-&gt;destroy(log_record)</code>.</p>

<p>So, you need to do something like this:</p>

<pre><code>double *p_temperature = KAA_MALLOC(sizeof(double));
if (!p_temperature) {
    // error handling
}

*p_temperature = 25.5;
log_record-&gt;temperature-&gt;data = p_temperature;
</code></pre>
",,53128423,368
44543232,2,42301711,2017-06-14T11:16:48.953,0,,7926064,,2017-06-14T11:24:24.410,2017-06-14T11:24:24.410,0,,"<p>You could use a combination of <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow noreferrer"">sprintf</a> and <a href=""http://www.cplusplus.com/reference/cstring/strcmp/"" rel=""nofollow noreferrer"">strcmp</a> to achieve your described behaviour e.g. similar to <a href=""http://forum.arduino.cc/index.php?topic=290342.msg2030584#msg2030584"" rel=""nofollow noreferrer"">this</a></p>

<pre><code>// date and time from RTC
DateTime now = rtc.now();

// date and time to compare with - this is provided by you
String datetimeCompare = ""1970/01/01 00:00:00"";

// this buffer must be big enough for your complete datetime (depending on the format)
char datetimeBuffer[20] = """";

// convert current date and time to your specific format
sprintf(datetimeBuffer, ""%04d/%02d/%02d %02d:%02d:%02d"", now.year(), now.month(), now.day(), now.hour(), now.minute(), now.second());

// perform the comparison
if(strcmp(datetimeBuffer, datetimeCompare.c_str()) == 0)
{
    // datetime strings are the same
}
</code></pre>

<p>Or you convert your rtc.now() DateTime according to your format as described over at the <a href=""https://arduino.stackexchange.com/a/4803"">arduino stackexchange</a>.</p>
",,53138067,454
42315311,2,42314723,2017-02-18T12:46:36.520,3,,325117,,2017-02-18T12:46:36.520,,0,,"<p>That's what structs are for:</p>

<pre><code>typedef struct {
    double a;
    double b;
    double c;
    unsigned int d;
    unsigned int e;
} mystruct;

mystruct m = { 2.333, 4.478, 2.447, 90, 43 };
printf(""%.3f %.3f %.3f %u %u\n"", m.a, m.b, m.c, m.d, m.e);
</code></pre>
",,53158896,109
42487880,2,42333338,2017-02-27T14:12:48.187,0,,7630242,,2017-02-27T14:35:52.893,2017-02-27T14:35:52.893,2,,"<p>I encountered the same problem however I solved it with <code>pkg-config opencv --cflags --libs</code>. </p>

<p>When I compiled with the previous command, the output was like below:</p>

<pre><code>qsp@ubuntu:~/Documents/caffeProject/assign3$ g++ -o ""test_mnist""
""test_mnist.cpp"" -lopencv_dnn -lopencv_highgui -lopencv_imgcodecs
-lopencv_imgproc -lstdc++ -lopencv_core /usr/bin/ld: warning: libopencv_core.so.3.1, needed by //usr/local/lib/libopencv_dnn.so, may
conflict with libopencv_core.so.2.4 /usr/bin/ld: /tmp/ccovch2b.o:
     undefined reference to symbol '_ZN2cv6String10deallocateEv'
     //usr/local/lib/libopencv_core.so.3.1: error adding symbols: DSO
     missing from command line collect2: error: ld returned 1 exit status
</code></pre>

<p>Although problem solved, I still wonder why. Can anybody explain?</p>
",,53174085,554
42340002,2,42336734,2017-02-20T08:50:26.367,1,,3368201,,2017-02-20T08:50:26.367,,5,,"<p>The problem here is that it is not guaranteed that the serial transmission is received all at once. So it is better to let the serial to be processed somewhere else, for instance:</p>

<pre><code>// in the class definition
    QSerialPort serialPort;
private slots:
    void handleReadyRead();
private:
    QByteArray serialBuffer;
    volatile double lastSerialValue;

// In the initialization part (not the realtimeDataSlot function)
lastSerialValue = qQNaN();
serialPort.setPortName(currentPortName);
connect(&amp;serialPort, &amp;QSerialPort::readyRead, this, &amp;Dialog::handleReadyRead, Qt::UniqueConnection);
if (!serialPort.open(QIODevice::ReadOnly)) {
    return;
}
serialBuffer.clear();

// Other functions:
void Dialog::realtimeDataSlot()
{
    ...
    if (key-lastPointKey &gt; 0.002) // at most add point every 2 ms
    {
        if (!qIsNaN(lastSerialData))
        {
            // use lastSerialValue as the data.toDouble() you had before, then, at the end

            lastSerialValue = qQNaN();
        }
    ...
}

void Dialog::handleReadyRead()
{
    serialBuffer.append(serialPort.readAll());
    int serPos;
    while ((serPos = serialBuffer.indexOf('\n')) &gt;= 0)
    {
        bool ok;
        double tempValue = QString::fromLatin1(serialBuffer.left(serPos)).toDouble(&amp;ok);
        if (ok) lastSerialValue = tempValue;

        serialBuffer = serialBuffer.mid(serPos+1);
    }
}
</code></pre>

<p>Explanation: whenever you receive something from the arduino the bytes are appended to a buffer. Then the byte array is parsed looking for a terminator, and if found the byte array is split and analysed. When the other function needs the data, it simply pulls the most recent one saved in the variable.</p>

<p>NOTE 1: I saw that you used a binary transmission. The problem is that you do not have any way to determine where the data begins and end in this way. For instance, if you receive 0x01 0x02 0x03 0x04 and you know that there are 3 bytes, are they 01..03 or 02..04 or 03, 04 and a missing one or...? The version I implemented requires you to send data in string format with a new-line terminator (simplest version, you just have to write <code>Serial.println(doubleValue);</code> in the arduino code), but if you need the binary version I can give you some hints</p>

<p>NOTE 2: The code I wrote is NOT thread safe. It will work only if the realtimeDataSlot and the handleReadyRead are called in the same thread. Note that if they belong to the same object and are called through signals this is guaranteed.</p>

<p>Now, this should work. But I highly discourage you from doing this. I don't know who needs to call the <code>realtimeDataSlot()</code>, but I think that the most correct version is something like this:</p>

<pre><code>// in the class definition
    QSerialPort serialPort;
private slots:
    void handleReadyRead();
    void receivedData(double val);
private:
    QByteArray serialBuffer;
signals:
    void newData(double data);

// In the initialization part (not the realtimeDataSlot function)
serialPort.setPortName(currentPortName);
connect(&amp;serialPort, &amp;QSerialPort::readyRead, this, &amp;Dialog::handleReadyRead, Qt::UniqueConnection);
connect(this, &amp;Dialog::newData, this, &amp;Dialog::receivedData, Qt::UniqueConnection);
if (!serialPort.open(QIODevice::ReadOnly)) {
    return;
}
serialBuffer.clear();

// Other functions:
void Dialog::receivedData(double val)
{
    double key = time.elapsed()/1000.0;
    static double lastPointKey = 0;
    if (key-lastPointKey &gt; 0.002) // at most add point every 2 ms
    {
        QTextStream(stdout) &lt;&lt; ""HERE:"" &lt;&lt; data.toDouble() &lt;&lt; endl;
        customPlot-&gt;graph(0)-&gt;addData(key, data.toDouble());
        customPlot-&gt;graph(0)-&gt;rescaleValueAxis();
        ...
    }
}

void Dialog::handleReadyRead()
{
    serialBuffer.append(serialPort.readAll());
    int serPos;
    while ((serPos = serialBuffer.indexOf('\n')) &gt;= 0)
    {
        bool ok;
        double tempValue = QString::fromLatin1(serialBuffer.left(serPos)).toDouble(&amp;ok);
        if (ok) emit newData(tempValue);

        serialBuffer = serialBuffer.mid(serPos+1);
    }
}
</code></pre>

<p>So keep the graph responsive to events (received a new data) instead of to a timer.</p>

<p>One more thing: I removed the port change on purpose. I suggest you to handle it in another way: put a button to start and stop the serial, and when the serial port is started prevent the user from changing the port name. This way the user will explicitely need to shut it down when he needs to change the port. If you want your version, however, don't include it in your code, but make a slot on its own to call whenever you need to change the port name:</p>

<pre><code>void changeSerialPortName(QString newName)
{
    if (newName != serialPort.portName()) {
        if (serialPort.isOpen())
            serialPort.close();

        serialPort.setPortName(newName);

        if (!serialPort.open(QIODevice::ReadOnly)) {
            return;
        }
    }
}
</code></pre>
",,53179916,367
42373619,2,42370554,2017-02-21T17:04:53.203,0,,1212012,,2017-02-21T17:04:53.203,2017-05-23T10:29:49.297,1,,"<p>I have two solution in mind to solve your problem:</p>

<ul>
<li>You could <a href=""https://stackoverflow.com/a/8353435/1212012"">create a timer</a> which will call a function to deal with <code>butPin</code> value each 100ms,</li>
<li><p>You could use threads:</p>

<pre><code>void *start_gtk_thread(void *arg)
{
    gtk_main();
    return NULL;
}
void *start_pin_thread(void *arg)
{
    while(1)
    {
        if (digitalRead(butPin)) // Button is released if this returns 1
        {
             ....
        }
        return NULL;
    }
}
</code></pre>

<p><strong>And in your main function</strong></p>

<pre><code>gtk_widget_show (window);

/* threads id*/
pthread_t tid[2];

/* create threads */        
pthread_create(&amp;tid[0], NULL, start_gtk_thread, NULL);
pthread_create(&amp;tid[1], NULL, start_pin_thread, NULL);

/* wait for threads (warning, they should never terminate) */ 
pthread_join(id[0], NULL);
pthread_join(id[1], NULL);
</code></pre></li>
</ul>
",,53197443,4920
42388182,2,42385227,2017-02-22T09:55:26.860,1,,7494166,,2017-10-12T05:00:17.840,2017-10-12T05:00:17.840,1,,"<p>You have two Problems:</p>

<p>First you hooked your ""for loop"" for the green color in(!) the for loop for the Blue color. Based on the fact that the loops running infinite you only loop through the second for loop.</p>

<p>The second Problem (perhaps not a problem, but the reason why you don't see Blue) is your initialization of the blueVariable as 0.
If you run the first time, you write the value 0 to the PWM Pin. After that you change the variable, but do not write to the PWM Pin, because you get stuck in your ""infinite green Loop"".</p>

<p>Btw, like said in the comments from Michael, you should change the 255 to 8 AND in your array you should change the last value (256) to 255 because the 8bit PWM means 256 values from 0-255.</p>

<p>Example:</p>

<pre><code>int x[9] = {0, 32, 64, 96, 128, 160, 192, 224, 255};    // Changed Value

void loop() {
  int blueVariable = 0;                                 //Blue LED
  int greenVariable = 0;                                //Green LED

  while(1) {                                            // Because it was infinite already i changed it to while(1)
    blueVariable = random(0,8);                         //Put in front of analogWrite()
    analogWrite(11, x[blueVariable]);                   
    delay(500);

    // Deleted the scond loop
    greenVariable = random(0,8);                        // Value changed from 255 to 8; Also put in front of analogWrite
    analogWrite(10, x[greenVariable]);
    delay(500);
  }        
}
</code></pre>
",,53225192,484
42426759,2,42423562,2017-02-23T21:44:29.197,1,,696391,,2017-02-23T21:44:29.197,,0,,"<p>It looks like your function has a period of 180, do you can take the input value and mod 180 first of all:</p>

<pre><code>x = x % 180;
</code></pre>

<p>Then you need to handle the fact that it decreases from 90-180:</p>

<pre><code>if(x &gt; 90)
   x = 180 - x;
</code></pre>

<p>x will now be a value between 0 and 90. You can scale and convert to float:</p>

<pre><code>float value = (float)x / 90.0f;
</code></pre>

<p>In function form:</p>

<pre><code>float getValue(int x)   
{
    if(x &lt; 0) // check for negatives (may not be necessary if you never pass them in)
       x = -x;  // your function is symmetrical about 0 so we can just negate
    x %= 180;
    if(x &gt; 90)
       x = 180 - x;
    return (float)x / 90.0f;
}
</code></pre>
",,53237642,132
44909314,2,42433671,2017-07-04T15:05:47.903,0,,6535976,,2017-07-04T15:05:47.903,,0,,"<p>I'm trying to do something similar - use a PlatformIO compiler as part of my CI process in Gitlab. I received a similar error when compiling so I went looking for the missing files and found them here (note, I'm using linux so adjust accordingly for Windows):</p>

<pre><code>/.arduino15/packages/Intel/hardware/arc32/2.0.2/system/libarc32_arduino101/framework/src/services/ble_service
</code></pre>

<p>I moved the ble_service folder to the CurieBLE library folder (within the project folder) so now my project folder structure is:</p>

<pre><code>|--lib
|  |--CurieBLE
|  |  |--src
|  |  |  |--bluetooth
|  |  |  |  |[contents of the bluetooth folder from .arduino15/packages/Intel/hardware/arc32/2.0.2/system/libarc32_arduino101/drivers]
|  |  |  |--services
|  |  |  |  |--ble_service
|  |  |  |  |  |[contents of the ble_service folder from above path]
|  |  |  |[rest of the CurieBLE folder contents]
|--src
|  |- main.cpp
|- platformio.ini
</code></pre>

<p>I'm still working through other errors to get PlatformIO to work but this at least fixed the missing libraries/files.</p>
",,53267340,334
43147203,2,42444307,2017-03-31T18:16:14.183,1,,6522064,,2017-03-31T18:16:14.183,,0,,"<p>So after following user3629249's solution, this issue appears to be resolved. Have now had multiple weeks of error free runtime. user3629249, if you want to repost your advice as an answer, I will accept it. Thank you to user3629249 and Patrick Trentin for your help!</p>

<p>My update ProcessDate function now contains:</p>

<pre><code>if(date.available() &gt;0){
  while (date.available() &gt; 0) {
  // get the result of the date process (should be hh:mm:ss):
  String timeString = date.readString();

  // find the colons:
  int firstColon = timeString.indexOf("":"");
  int secondColon = timeString.lastIndexOf("":"");

  // get the substrings for hour, minute second:
  String hourString = timeString.substring(0, firstColon);
  String minString = timeString.substring(firstColon + 1, secondColon);
  String secString = timeString.substring(secondColon + 1);


  // convert to ints,saving the previous second:
  lastSecond = seconds;          // save to do a time comparison
  lastMinute = minutes;
  lastHour = hours;
  hours = hourString.toInt();
  minutes = minString.toInt();
  seconds = secString.toInt();
  String currTime = hourString + "":"" + minString + "":"" + String(seconds);
  return currTime;
} 
else{
        String currTime = """"; // If there is no result from the date process, return nothing. Should not happen.
        return currTime;
      }
    }
</code></pre>
",,53366240,93
42453414,2,42452407,2017-02-25T07:49:42.403,4,,6024122,,2017-02-25T07:49:42.403,,1,,"<p>Here is the source code of <code>make_hash</code>:</p>

<pre class=""lang-cpp prettyprint-override""><code>unsigned char* MD5::make_hash(const void *arg)
{
    MD5_CTX context;
    unsigned char * hash = (unsigned char *) malloc(BLOCK_SIZE);
    MD5Init(&amp;context);
    MD5Update(&amp;context, arg, strlen((char*)arg));
    MD5Final(hash, &amp;context);
    return hash;
}
</code></pre>

<p>As you can see, there is a <code>malloc()</code> in there for the returned <code>hash</code> variable. Therefore you should invoke <code>free(hash)</code> at the end of each loop iteration.</p>

<p>If you need to keep <code>hash</code> around, put it in the <em>global scope</em> and create it <em>only once</em> in the <code>setup()</code> function.</p>
",,53385750,43
42460960,2,42460381,2017-02-25T20:01:02.150,1,,7444781,,2017-02-26T02:38:27.937,2017-02-26T02:38:27.937,4,,"<p>This function will return the amount of time a laser module was shot at a photo resistor in milliseconds:</p>

<pre><code>int photo_resistor_time()
{
    int i = 0;
    while (photo_resistor_value &gt; 100)
    {
        i++;
        Delay(1);
    }
    return i;
}
</code></pre>
",,53408016,118
42470255,2,42470112,2017-02-26T15:17:00.943,0,,4153870,,2017-02-26T15:17:00.943,,3,,"<p>You can use serial print like this -</p>

<pre><code>  Serial.print(""PRbpm : %d \t"");
  Serial.print(eHealth.getBPM());
  Serial.print("" %%SPo2 : %d\n \t"");
  Serial.print(eHealth.getOxygenSaturation());
  Serial.print(""============================="");
</code></pre>
",,53413090,206
42505946,2,42499339,2017-02-28T10:16:31.560,1,,6024122,,2017-02-28T10:34:45.900,2017-02-28T10:34:45.900,5,,"<p>In your source code you first <em>null-terminate</em> your <code>char[]</code> array with <code>value[i] = 0</code>, but then when <code>#</code> is pressed you overwrite that position with <code>value[i]= true;</code> right before printing it, and obviously causes problems.</p>

<p>This is a <em>quick-and-dirty</em> fix:</p>

<pre class=""lang-cpp prettyprint-override""><code>...

void loop()
{
    static char buffer[4];
    static byte i = 0;

    char key = keypad.getKey();

    // i &lt; 3: prevent buffer overflow
    if  ('0' &lt;= key &amp;&amp; key &lt;= '9' &amp;&amp; i &lt; 3)
    {
        buffer[i] = key;
        ++i;
    } else if (key == '#' &amp;&amp; i &gt; 0) {
        buffer[i] = '\0';              // null-terminate buffer

        Serial.println(buffer);    // debug print ?

        int value = atoi(buffer);
        myservo.write(value);

        i = 0;
    }
}
</code></pre>

<p>Please notice that in this source code example <code>#</code> is <em>required</em> to terminate a sequence of digits, and every digit in a sequence after the third one is <em>ignored</em>. This does not exactly reassemble your original behaviour, but I think that <em>consistency</em> of interaction is to be preferred.</p>
",,53498564,826
42526544,2,42526098,2017-03-01T08:19:40.767,2,,3545273,,2017-03-01T08:19:40.767,,0,,"<p>Oups, a C string is by convention a char array terminated with a null byte. All <code>strxx</code> functions follow this convention.</p>

<p>As the first character of the array is... 0, <code>strlen</code> finds a terminating null at index 0 and correctly says that the length of the string is 0.</p>

<p>In addition, all characters with code 0 to 10 (assuming ASCII) are control non printable characters.</p>

<p>I assume that what you wanted to do is</p>

<pre><code>for ( i=0; i&lt;11;i++)
{
  x[i]= '0' + i; /* 0 to 9 and : */
}
x[11] = '\0';   /* terminate the array with a null to make it a C string */
</code></pre>
",,53562803,111
42561096,2,42538987,2017-03-02T16:42:56.810,2,,440558,,2017-03-02T16:42:56.810,,0,,"<p>When you do</p>

<pre><code>std::bind(&amp;MyClass::handleFileRead(edit), this)
</code></pre>

<p>you attempt to <strong><em>call</em></strong> <code>MyClass::handleFileRead(edit)</code>, and take the pointer of the result as the argument to the <code>std::bind</code> call. This is of course not valid, especially since the function doesn't return anything as well as it's not being a <code>static</code> member function..</p>

<p>You should not <em>call</em> the function, just pass a pointer to it (and set the argument):</p>

<pre><code>std::bind(&amp;MyClass::handleFileRead, this, edit)
//                                ^       ^
// Note not calling the function here     |
//                                        |
//       Note passing edit as argument here
</code></pre>
",,53567099,106
42578358,2,42575182,2017-03-03T11:59:57.610,0,,6024122,,2017-03-03T11:59:57.610,,2,,"<p>If you don't give a chance to <em>Arduino</em> to parse the <em>serial input</em> in-between the execution of the <code>for</code> loop, then obviously is not going to work as you want.</p>

<p>You should do something similar to this:</p>

<pre class=""lang-cpp prettyprint-override""><code>...

void loop() {
  static int j;

  if (Serial.available() &gt; 0){
    switch(Serial.read()){
      case 'a':
       entry = true;

       /**
        * replace next 3 lines with `j = -20` if you want to start
        * the loop from scratch each time `a` is received,
        * instead of resuming from where you stopped.
        */
       if (j &gt;= 20) {
         j = -20;
       }

       break;
      case 'b':
       entry = false;
       break;
      default:break;
    }
  }

  if (entry) {
    if (j &lt;= 20) {
      motor.step(j/0.176);
      ++j;
    }
  } else {
     digitalWrite(in1Pin, LOW);
     digitalWrite(in2Pin, LOW);
     digitalWrite(in3Pin, LOW);
     digitalWrite(in4Pin, LOW);
  }
}
</code></pre>

<p>In this code, I let <em>Arduino</em> parse a new character after each call to <code>motor.step()</code>. Note that this approach introduces a <em>tiny</em> delay among sub-sequent calls to <code>motor.step()</code> wrt. your original solution, but it should be <em>negligible</em> in practice.</p>

<p>If you send multiple <code>a</code> in a row to <em>Arduino</em> using this code, but <em>Arduino</em> did not complete the <code>for</code> loop yet, then with this code the additional <code>a</code> will be ignored. If you want to handle them as additional <code>for</code> request, then you should add a <code>counter</code> to keep track of the number of pending (full) iterations of the <code>for</code> loop that you want to perform.</p>
",,53591324,92
42580665,2,42578515,2017-03-03T13:50:54.970,0,,6594779,,2017-03-03T13:50:54.970,,1,,"<p>It seems that your variable <code>arr</code> contains <code>0</code>. Since you are directly assigning it to <code>String</code>, this <code>0</code> is treated as a character rather than its face value.</p>

<p>Add 1 extra condition to avoid leading zeros. Body of loop</p>

<pre><code>char str[10];
if (i &lt; aCount)
   if (arr[i]!=0)
      sprintf(str, ""%d"", arr[i]);
else
   sprintf(str, ""%d"", curId);
msg += str;
</code></pre>

<p>Hope it solves your problem.</p>
",,53602625,596
42669127,2,42655059,2017-03-08T10:43:38.787,0,,1705337,,2017-03-08T11:40:43.997,2017-03-08T11:40:43.997,3,,"<p>The <a href=""https://www.arduino.cc/en/Reference/YunPut"" rel=""nofollow noreferrer"">Bridge.put()</a> method requires a char or a string as its second parameter. So we can use the <a href=""https://www.arduino.cc/en/Reference/StringConstructor"" rel=""nofollow noreferrer"">String constructor</a> to do that.</p>

<pre><code>void setup()
{
  Serial.begin(115200); // To test this make sure your serial monitor's baud matches this, or change this to match your serial monitor's baud rate.

  double floatVal = 1234.2; // The value we want to convert

  // Using String()
  String arduinoString =  String(floatVal, 4); // 4 is the decimal precision

  Serial.print(""String(): "");
  Serial.println(arduinoString);

  // You would use arduinoString now in your Bridge.put() method.
  // E.g. Bridge.put(""Some Key"", arduinoString)
  // 
  // In your case arduinoString would have been dP or hIinCel.

  // In case you need it as a char* at some point
  char strVal[arduinoString.length() + 1]; // +1 for the null terminator.
  arduinoString.toCharArray(strVal, arduinoString.length() + 1);

  Serial.print(""String() to char*: "");
  Serial.println(strVal);
}

void loop()
{

}
</code></pre>

<p>And we get:</p>

<pre><code>String(): 1234.2000
String() to char*: 1234.2000
</code></pre>

<p>Go <a href=""https://www.tutorialspoint.com/cprogramming/c_strings.htm"" rel=""nofollow noreferrer"">here</a> to read about the null terminator.</p>
",,53609809,497
42670731,2,42670630,2017-03-08T11:56:42.393,0,,721269,,2017-03-08T11:56:42.393,,2,,"<p>Change code like:</p>

<pre><code>          case 'A' :
              AA(x,y,z);
          break;  
          case 'a' :
            AA(x,y,z);
          break;  
</code></pre>

<p>to:</p>

<pre><code>          case 'A' :
          case 'a' :
              AA(x,y,z);
          break;  
</code></pre>

<p>You still have an absurd amount of code duplication. Why aren't you using something like a lookup table? Or even an <code>if</code>/<code>else if</code> tree that would eliminate the need for all the <code>break</code> statements? Or <code>toupper</code>?</p>
",,53613064,407
42671060,2,42670630,2017-03-08T12:12:12.763,0,,4950584,,2017-03-08T12:21:47.677,2017-03-08T12:21:47.677,0,,"<p>You could use <code>strcasecmp()</code> which compares two strings but doesn't care about the case of the characters.</p>

<pre><code>if(strcasecmp(instruction, ""pa"") == 0)
  {
  PA(x,y);
  }
else if(strcasecmp(intruction, ""pr"") == 0)
  {
  PR(x,y);
  }
</code></pre>
",,53622380,339
42671136,2,42670630,2017-03-08T12:15:40.740,1,,3555525,,2017-03-08T12:15:40.740,,0,,"<p>One way to do it would be by using the switch <strong>fall through</strong>. Though in your case, you would have to use it in a nested manner. </p>

<p>Something like this.</p>

<pre><code>switch (instruction[0])
{
    case 'P' :
    case 'p' :

        switch (instruction[1])
        {
            case 'A' :
            case 'a' :
                PA(x,y);
            break ; 

            case 'R' :
            case 'r' :
                  PR(x,y);
             break ; 

            case 'U' :
            case 'u' :
                  PU(x,y);
            break ; 

            case 'D' :
            case 'd' :
                  PD(x,y);
            break ;  
        }
    break;
    case 'T' :
    case 't' :
        Serial.println(""error"");
        break;

    case 'A' :
    case 'a' :
        switch(instruction[1])
        {
            case 'A' :
            case 'a' :
                  AA(x,y,z);
            break;  
        }
    break;
}
</code></pre>

<p>Note that the default case is not taken care of in the various switch statements. You need to decide what action to take if the user inputs a value of ""px"". Currently this code takes no action.</p>
",,53636279,715
42672970,2,42670630,2017-03-08T13:42:32.743,0,,4184258,,2017-03-08T13:42:32.743,,0,,"<p>Depending on how flexible you are with those functions, you could refactor them so that they take the second letter as a parameter.</p>

<p>So, instead of having</p>

<pre><code>PA(x,y);
PR(x,y);
PU(x,y);
PD(x,y);
...
</code></pre>

<p>use</p>

<pre><code>P( c, x, y );
</code></pre>

<p>and hand over <code>A</code>, <code>R</code>, <code>U</code>, <code>D</code>, etc (i.e, <code>instruction[1]</code>) for the parameter <code>c</code>.</p>
",,53676929,776
42773174,2,42673101,2017-03-13T20:51:05.670,0,,4763489,,2017-03-13T20:51:05.670,,0,,"<p><em>Turning my comment into an answer</em></p>

<p>I've installed <a href=""https://www.arduino.cc/en/Guide/Windows"" rel=""nofollow noreferrer"">Arduino Software (IDE) for Windows PCs</a> version 1.8.1 and have given it a try with my Visual Studio 2015 Community Edition installation.</p>

<p>Here is my test code (but maybe you just search on the Internet for some ready to use toolchains):</p>

<p><strong>toolchain.txt</strong></p>

<pre><code>set(TOOLCHAIN_ROOT ""C:/Program Files (x86)/Arduino/hardware/tools/avr"")

if(CMAKE_HOST_SYSTEM_NAME STREQUAL ""Windows"")
    set(TOOL_OS_SUFFIX "".exe"")
else()
    set(TOOL_OS_SUFFIX """")
endif()

set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_SYSTEM_PROCESSOR avr)

set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

set(TRIPLE avr)
set(CMAKE_C_COMPILER ""${TOOLCHAIN_ROOT}/bin/${TRIPLE}-gcc${TOOL_OS_SUFFIX}"")
set(CMAKE_CXX_COMPILER ""${TOOLCHAIN_ROOT}/bin/${TRIPLE}-g++${TOOL_OS_SUFFIX}"")
</code></pre>

<p>Since the download hasn't come with an <code>arm</code> compiler toolchain, I used <code>avr</code> (which should be replaceable). And you don't have to give all the tools, CMake will find them based on the naming scheme of your compilers.</p>

<p>And - as @Tsyvarev commented - variable <code>CMAKE_CROSSCOMPILING</code> is set by CMake automatically, no need to set it manually.</p>

<hr>

<p>Here is what you can/can't do for Arduino with an out-of-the-box Visual Studio:</p>

<ol>
<li><p>For <code>nmake</code> I was running on the cmd prompt:</p>

<pre><code>&gt; ""c:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat""
&gt; mkdir NMake
&gt; cd NMake
&gt; NMake&gt;cmake -G ""NMake Makefiles"" -DCMAKE_TOOLCHAIN_FILE:PATH=..\toolchain.txt ..
-- The C compiler identification is GNU 4.9.2
-- The CXX compiler identification is GNU 4.9.2
-- Check for working C compiler: C:/Program Files (x86)/Arduino/hardware/tools/avr/bin/avr-gcc.exe
-- Check for working C compiler: C:/Program Files (x86)/Arduino/hardware/tools/avr/bin/avr-gcc.exe -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: C:/Program Files (x86)/Arduino/hardware/tools/avr/bin/avr-g++.exe
-- Check for working CXX compiler: C:/Program Files (x86)/Arduino/hardware/tools/avr/bin/avr-g++.exe -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
</code></pre></li>
<li><p>For Visual Studio you can't just change the compiler. It would need an additional plug-in or toolset installed (which would need CMake awareness or needs to be supported by CMake). The just released Visual Studio 2017 does have some build-in support for Linux systems, but I don't think that there is something implemented yet.</p></li>
</ol>

<p><strong>References</strong></p>

<ul>
<li><a href=""https://stackoverflow.com/questions/42762424/cmake-generator-for-visual-studio-linux-cross-platform"">CMake Generator for Visual Studio Linux cross-platform</a></li>
<li><a href=""https://stackoverflow.com/questions/38700198/how-to-partially-disabling-cmake-c-c-custom-compiler-checking"">How to partially disabling cmake C/C++ custom compiler checking</a></li>
<li><a href=""https://github.com/mkleemann/cmake-avr"" rel=""nofollow noreferrer"">cmake-avr toolchain</a></li>
</ul>
",,53682029,93
42722830,2,42720526,2017-03-10T16:08:34.047,5,,1705337,,2017-03-10T16:21:17.547,2020-06-20T09:12:55.060,0,,"<p>A line of Arduino code does not have a fixed execution time.</p>
<p><code>delay(1000);</code> will take about a second to run, while <code>Serial.print(&quot;Hello, World!&quot;);</code> might take a few hundred microseconds to run.</p>
<p>It depends on what the line does. A single line of Arduino code might get converted into 1 line or multiple lines of assembler code.</p>
<p>A simple for loop in Arduino code:</p>
<pre><code>for (i=0; i&lt;100; i++) {
    p[i] = i;
}
</code></pre>
<p>Might become this in assembler code:</p>
<pre><code>LDI     R19,0x00
MOVW    R30,R24
ST      Z+,R19
SUBI    R19,0xFF
CPI     R19,0x64
BRCS    PC-0x03
</code></pre>
<p>This doesn't solve your question either, because lines of assembler code don't necessarily have the same execution time.</p>
<p>The only thing you can do is time the parts that you are interested in.</p>
<p>To answer the specific examples you listed:</p>
<h1>Example 1</h1>
<pre><code>void setup() {
  Serial.begin(9600);
  t1 = micros();
  val = analogRead(pin);
  t2 = micros();
  Serial.print(t2-t1);
}
</code></pre>
<p>The speed of <code>val = analogRead(pin)</code> is determined by a few factors. The storing of the value to a register (<code>val =</code>) will take 1 instruction cycle. The reading of an analogue value (<code>analogRead(pin)</code>) from the <code>PIN</code> buffer will take a few instructions.</p>
<h1>Example 2</h1>
<pre><code>void setup() {
  Serial.begin(9600);
  t1 = micros();
  int x = 1 + 2;
  t2 = micros();
  Serial.print(t2-t1);
}
</code></pre>
<p>The reason why <code>int x = 1 + 2;</code> takes 0 microseconds to execute is that the compiler optimises code that you write. Since the variable <code>x</code> is never used in its scope, the compiler just removes this line. Which means this line is not on the Arduino, and therefor is not executed. So what you're actually doing is this:</p>
<pre><code>void setup() {
  Serial.begin(9600);
  t1 = micros();
  t2 = micros();
  Serial.print(t2-t1);
}
</code></pre>
<p>Even if it didn't remove the line, the addition of constatnts, i.e. <code>1 + 2</code> would be optimised to <code>3</code>, the addition operation would never occur on the Arduino.</p>
",,53691292,420
42734934,2,42726502,2017-03-11T12:00:45.360,0,,730260,,2017-03-11T12:00:45.360,,0,,"<p>I've found my problem: I wasn't using the declareQueue() method! In fact, I had to use it but specifying the following parameters (the same as I did when I created the queue manually):</p>

<pre><code>AMQP::Table arguments;
arguments[""x-message-ttl""] = 120 * 1000;

// declare the queue
channel.declareQueue(""domoqueue"", AMQP::durable + AMQP::passive, arguments).onSuccess(callback);
</code></pre>
",,53693424,64
42736386,2,42736250,2017-03-11T14:28:11.327,1,,2878796,,2017-03-11T14:33:59.620,2017-03-11T14:33:59.620,0,,"<p>The constructor is declared to accept an array of <code>Note</code>, but <code>Note *notes[]</code> declares an array of <code>Note*</code>. As you stated in your question that you want to allocate the <code>Note</code>s on the heap you should adjust your class to take <code>Note *notes[]</code> in the constructor and store an array of pointers in its member.</p>

<p>However this solution can (and quite likely will) have issues with ownership and deallocation (who is in charge of <code>delete</code>ing the allocated objects and when does it happen? And how to prevent any dangling pointer in that case?).</p>

<p>The IMO better approach would be to store the <code>Note</code>s in automatic duration inside the <code>Chord</code> class, so that they will be destroyed when the ""owner"" object gets destroyed. For this all you'd need to change would be the initial array you want to pass to:</p>

<pre><code>Note notes[] = {
    Note(0, ""C"", ""B#""),
    Note(5, ""E"", ""Fb""),
    Note(8, ""G"", ""G"")
};
</code></pre>

<p>Another option (if you really want to have the <code>Note</code>s be dynamically allocated) could be the have your <code>Chord</code> constructor create copies of the <code>Note</code>s passed as a parameter, which could be allocated with <code>new</code> and destroyed in the destructor of <code>Chord</code> - this would solve the issues mentioned in the first solution (but it would disconnect the <code>Note</code>s in <code>Chord</code> from the ones passed in via the constructor)</p>

<p>Note: you also have another minor syntax error in your question: <code>Chord chord = new Chord(""CMaj"", notes, 127, 1);</code> should be <code>Chord* chord = new Chord(""CMaj"", notes, 127, 1);</code></p>
",,53702425,142
42748276,2,42747716,2017-03-12T13:58:04.300,-1,,4524618,,2017-03-12T13:58:04.300,,1,,"<p>You had to use </p>

<pre><code>struct measurement_t getLightSensorData()
{
  int sensorValue = analogRead(LIGHTSENSOR_PIN);
  measurement_t m(1, sensorValue);
  return m;
}
</code></pre>

<p>You might have outdated version of Arduino IDE because on my IDE it compiled without the use of <code>struct</code> keyword.</p>
",,53719200,586
42761173,2,42759434,2017-03-13T10:18:42.413,1,,7478597,,2017-03-13T10:38:44.140,2017-03-13T10:38:44.140,0,,"<p>The <code>struct op[] {</code> ... <code>}</code> looks weird to me. (I even don't know how to read/interprete this.)</p>

<p>Thus, I tested this with gcc on cygwin (in a simplified version):</p>

<pre><code>$ gcc --version
gcc (GCC) 5.4.0

$ echo 'typedef union u { struct op[] { int i; } value; };
&gt; int main() { return 0; } 
&gt; ' &gt; test-weird-union.c

$ gcc test-weird-union.c   
test-weird-union.c:1:28: error: expected identifier or '(' before '[' token
 typedef union u { struct op[] { int i; } value; };
                            ^
test-weird-union.c:1:42: error: expected ';' before 'value'
 typedef union u { struct op[] { int i; } value; };
                                          ^
test-weird-union.c:1:42: warning: useless storage class specifier in empty declaration
</code></pre>

<p>(Same output with <code>gcc -std=c11</code>.)</p>

<p>The code is probably wrong or at least not standard C.</p>

<p>OK. Thinking additionally about it: How to fix it?</p>

<p>A little bit more background would be nice. Thus, see this as an approach and prove how to apply it:</p>

<pre><code>#include &lt;stdint.h&gt;

typedef union accel_t_gyro_union
{
  struct
  {
    uint8_t x_accel_h;
    uint8_t x_accel_l;
    uint8_t y_accel_h;
    uint8_t y_accel_l;
    uint8_t z_accel_h;
    uint8_t z_accel_l;
    uint8_t t_h;
    uint8_t t_l;
    uint8_t x_gyro_h;
    uint8_t x_gyro_l;
    uint8_t y_gyro_h;
    uint8_t y_gyro_l;
    uint8_t z_gyro_h;
    uint8_t z_gyro_l;
  } reg;
  struct op
  {
    int16_t x_accel;
    int16_t y_accel;
    int16_t z_accel;
    int16_t temperature;
    int16_t x_gyro;
    int16_t y_gyro;
    int16_t z_gyro;
  } value;
} accel_t_gyro_union;
</code></pre>

<p>The following things I have done:</p>

<ol>
<li><p>Removed the <code>[]</code> behind <code>op</code> to fix the syntax error.</p></li>
<li><p>Changed the <code>int</code> to <code>int16_t</code>. This assures that this code works also on non-16 bit platforms.</p></li>
<li><p>Added <code>accel_t_gyro_union</code> to the end of <code>typedef</code>. This might not be necessary but I felt comfortable with this.</p></li>
</ol>

<p>Again checked with gcc on cygwin:</p>

<pre><code>$ gcc -std=c11 test-weird-union.c
</code></pre>

<p>At least, no syntax errors. The rest is beyond my knowledge.</p>
",,53735968,302
42761396,2,42759434,2017-03-13T10:30:02.927,1,,3754223,,2017-03-13T10:30:02.927,,0,,"<h2>Definition/Information:</h2>

<p>From <a href=""http://en.cppreference.com/w/cpp/language/union"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/union</a></p>

<blockquote>
  <p>A union is a special class type that can hold only one of its
  non-static data members at a time.</p>
</blockquote>

<p>And</p>

<blockquote>
  <p>The union is only as big as necessary to hold its largest data member.
  The other data members are allocated in the same bytes as part of that
  largest member.</p>
</blockquote>

<p>Also:</p>

<p>Your declaration is incorrect and should be:</p>

<pre><code>struct op
{
    int x_accel;
    int y_accel;
    int z_accel;
    int temperature;
    int x_gyro;
    int y_gyro;
    int z_gyro;
} value [SIZE];
</code></pre>

<p>I advise you to use a specific size for your array, OR a pointer declartion of your struct type to make clear, that you will decide it's heap-size later, but the union on the stack will have a pointer-size for the member...</p>

<p>(Although with empty brackets it still compiles and works in my quick testing... I should read into this behaviour, too. :D)</p>

<h2>Solution:</h2>

<p>Use the corrected declaration above.</p>

<p>Advice:
Use a SIZE for the array in the brackets.
If you don't know the size yet, use a pointer for reasons mentioned above.</p>
",,53739494,105
42761503,2,42759434,2017-03-13T10:36:04.767,1,,5271927,,2017-03-13T10:36:04.767,,0,,"<p>The <code>struct op[] {</code> ... <code>}</code> is nonsense anyway. If you want <code>struct</code> type named <code>op</code>, it should be outside of union (but it's not really issue, there might be a problem to use it somewhere else):
</p>

<pre><code>struct A {
    uint8_t  low_byte; // depends on byte order 
    uint8_t high_byte;
};

struct B {
    int          word;
};

union U {
    A  reg;
    B  val;
} variable;
</code></pre>

<p>But there is no need for the array at all. So the second <code>struct</code> should be also anonymous:</p>

<pre><code>union accel_t_gyro_union
{
  struct
  {
    uint8_t x_accel_h;
    uint8_t x_accel_l;
    uint8_t y_accel_h;
    uint8_t y_accel_l;
    uint8_t z_accel_h;
    uint8_t z_accel_l;
    uint8_t t_h;
    uint8_t t_l;
    uint8_t x_gyro_h;
    uint8_t x_gyro_l;
    uint8_t y_gyro_h;
    uint8_t y_gyro_l;
    uint8_t z_gyro_h;
    uint8_t z_gyro_l;
  } reg;
  struct
  {
    int x_accel;
    int y_accel;
    int z_accel;
    int temperature;
    int x_gyro;
    int y_gyro;
    int z_gyro;
  } value;
};
</code></pre>
",,53752096,84
42796218,2,42790459,2017-03-14T20:44:45.770,2,,660162,,2017-03-14T23:44:42.637,2017-03-14T23:44:42.637,2,,"<p>Without access to the board you're using, it's difficult to pinpoint exactly what's going on, but I can make some educated guesses. Since you're learning, I'll be a bit longwinded (as is my nature anyway).</p>

<p>Here is a diagram of a 7 segment display, and its labels (side by side)</p>

<pre><code> --    aa
|  |  f  b
 --    gg
|  |  e  c
 --    dd
</code></pre>

<p>From your code, it appears that the wiring from your values to the display is as follows within a byte (bit numbers on top, X for unused), where 0 is ON and 1 is OFF:</p>

<pre><code>76543210
abcdefgX
</code></pre>

<p>Based on that, the values used in your table should be:</p>

<pre><code>0 = B00000011
1 = B10011111
2 = B00100101
3 = B00001101
4 = B10011001
5 = B01001001
6 = B01000001
7 = B00011111
8 = B00000001
9 = B00001001
</code></pre>

<p>Unless I've made a mistake, which is quite possible, I think your implementation of ""2"" is incorrect. This is further likely because the ""2"" value should have 5 ""ON"" bits, and there are only four 0's in your implementation.</p>

<p>Since you thought the 2 was correct, this implies that the wire for the 6th bit (""b"" in the 7-segment diagram above) is loose or miswired (or possibly shorted to a different wire) because it is apparently still ""ON"" when a ""1"" is on that bit. This would cause a 6 to show as an 8, and a 5 to show as a 9, as you described.</p>
",,53770145,512
42807607,2,42806715,2017-03-15T10:50:38.373,1,,7701649,,2017-03-15T10:50:38.373,,0,,"<p>I think you need a public class if you're gonna use enum outside of that scope. Also, you need an argument in your function and are missing a semi-colon. I am not sure why you are declaring a function inside of a class? But here is your code with those corrections. Hopefully, I was able to help you.</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;

class MPU9250
{
public:
    // Set initial input parameters
    enum Ascale
    {
        AFS_2G = 0,
        AFS_4G,
        AFS_8G,
        AFS_16G
    };
    void setAccScale(Ascale accScale) {
        std::cout &lt;&lt; accScale &lt;&lt; std::endl;
    } // function needs argument

};// missing semi-colon
int main() {
    return 0;
}
</code></pre>
",,53813914,512
42807649,2,42806715,2017-03-15T10:51:53.407,1,,3179310,,2017-03-15T10:51:53.407,,0,,"<p>Judging by your error :</p>

<blockquote>
  <p>../../MPU9250.h: In function 'void initMovementDetected()':<br>
  ../../MPU9250.h:196:7: error: 'MPU9250::A_scale AFS_8G' is protected
         AFS_8G,<br>
         ^<br>
  ../../nRF52.cpp:49:31: error: within this context<br>
    mpu9250.setAccScale(MPU9250::AFS_8G);</p>
</blockquote>

<p>And your data structure :</p>

<pre><code>class MPU9250
{
protected:
    enum A_scale
    {
      AFS_2G = 0,
      AFS_4G,
      AFS_8G,
      AFS_16G
    };

private:
    void setAccScale(A_Scale);
}
</code></pre>

<p>I can assume that you're trying to call <code>MPU9250::setAccScale</code> from outside of the <code>MPU9250</code> class which is impossible because of the accessibility of that function.<br>
Another thing is that you're trying to access enumeration that is <code>protected subtype</code> of your <code>MPU9250</code>.</p>

<p>For the fix I would suggest making your <code>A_scale</code> publicly visible or rewrite this to use <code>#define</code>:</p>

<p><strong>Solution 1 :</strong></p>

<pre><code>// define this in some header
#ifndef AFS_2G
#    define AFS_2G 0
#endif

#ifndef AFS_4G
#    define AFS_4G 1
#endif
// rest of your values ...

//to use this:
mpu9250.SetAccScale(AFS_2G);
</code></pre>

<p><strong>Solution 2 :</strong></p>

<pre><code>//declare this enum as public :
class MPU9250
{
public:
    enum A_scale
    {
        AFS_2G = 0,
        AFS_4G = 1
        // rest of your values
    }
};

// to use this:
mpu9250.SetAccScale(MPU9250::A_scale::AFS_2G);
</code></pre>

<p>Both of the solutions require from you to make a public function <code>SetAccScale</code> because as I assume you're setting this scale from outside of <code>MPU9250</code> type.</p>
",,53819340,96
42819227,2,42818372,2017-03-15T19:40:48.703,2,,3521005,,2017-03-15T19:40:48.703,,2,,"<p>Each of your leg classes (fRight, fLeft, bRight, bLeft) creates two variables:</p>

<pre><code>int channels[2]= {2, 3};
bool started= false;
</code></pre>

<p>...which creates a different copy which cannot be accessed through the Leg pointer.</p>

<p>You need to change to something like the following to make sure you are setting the values in the base struct, Leg.</p>

<pre><code>struct fRight :  Leg
{
    fRight() {
        started = false;
        channels[0] = 0;
        channels[1] = 1;
    }
    virtual void foo() {}
};
</code></pre>

<p>It's possible you don't even need these individual classes though (depending on what your pure virtual foo() needs to do).  If you were to change Leg to look like:</p>

<pre><code>struct Leg
{
    Leg(int channel1, int channel2) :
        started {false}
    {
        channels[0] = channel1;
        channels[1] = channel1;
    }

    int channels[2];
    bool started;
    //virtual void foo() = 0;
};
</code></pre>

<p>... you could just instantiate:</p>

<pre><code>Leg* myLegs[4] = { new Leg{0,1}, new Leg{2,3}, new Leg{4,5}, new Leg{6,7} }
</code></pre>
",,53820936,104
42970085,2,42826405,2017-03-23T07:50:40.247,0,,992931,,2017-03-23T07:50:40.247,,1,,"<p>I fixed wiring(MISO to MISO, MOSI to MOSI, connect SS).</p>

<p><a href=""https://i.stack.imgur.com/4HsA0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4HsA0.png"" alt=""Fixed wiring""></a></p>

<p>And I changed the program on PIC16F1. It appends initialize RB pins and signal receives as an interrupt.</p>

<pre><code>unsigned char count = 0;

void interrupt OnInterSpi()
{
    if (SSP1IF == HIGH){
        SSP1IF = LOW;

        unsigned char read_data = SSP1BUF;
        if(count == 255) count = 0; else count++;
        SSP1BUF = count;
    }
}

void main(void)
{
    OSCCON = 0b00110100;    

    ANSELA = 0b00000000;    
    TRISA = 0b00000001;     
    PORTA = 0b00000000;     


    ANSELB = 0b00000000;
    TRISB = 0b00010010;     
    PORTB = 0b00000000;     

    SDO1SEL = 0;             
    SSP1CON1 = 0b00100100;    
    SSP1STAT = 0b01000000;    

    SSP1IF = 0;  
    SSP1IE = 1;  
    PEIE = 1;   
    GIE = 1;   

    while(1) ;
}
</code></pre>

<p>On Arduino, I enabled SS signal.</p>

<pre><code>#include &lt;SPI.h&gt;

#define SS_PIN 10

void setup()
{
    Serial.begin(9600);

    pinMode(SS_PIN, OUTPUT);
    digitalWrite(SS_PIN, HIGH);

    SPI.begin();
    SPI.setBitOrder(MSBFIRST);
    SPI.setDataMode(SPI_MODE0);
}

char msg[100];
byte i, n;

void loop()
{
    digitalWrite(SS_PIN, LOW);
    n = SPI.transfer(i);
    digitalWrite(SS_PIN, HIGH);

    sprintf(msg, ""%d/%d, "", n, i);
    Serial.print(msg);
}
</code></pre>

<p>Received values increased correctly on the serial monitor of Arduino at least  in my environment.</p>
",,53822846,262
42841774,2,42840931,2017-03-16T18:09:36.870,1,,669576,,2017-03-18T17:32:17.393,2017-03-18T17:32:17.393,9,,"<p>I will assume you want the ""Knight Rider"" pattern to constantly run.</p>

<p>I've made a couple of changes. First, I added a function to run the led sequence one way. Second, I added a <code>while</code> loop that will always run once, and will continue to run while the button is pushed.</p>

<pre><code>bool paused = false;
int buttonState = HIGH;

void loop() {
    a();
}

// This only works if leds ports are consecutive
void runSequence(int ledStart, int ledEnd)
{
    int direction = ledStart &lt; ledEnd ? 1 : -1;
    for (int i = ledStart; i != ledEnd + direction; i += direction) {
        digitalWrite(i, Uit);
        do {
            delay(100);
        } while (LOW == digitalRead(analogPin));  // Check button state
        digitalWrite(i, Aan);
    }
}

void a() {
  runSequence(LED4, LED1);
  runSequence(LED1, LED4);
}
</code></pre>

<p><strong>EDIT</strong> Changes based on comment</p>

<pre><code>bool paused = false;
int buttonState = HIGH;

int currentLED = LED1;
int currentDirection = -1;

void loop() {
    checkButton();
    if (!paused) {
        // Flash the led
        digitalWrite(currentLED, Uit);
        delay(100);
        digitalWrite(currentLED, Aan);
        // Change direction?
        if (LED1 == currentLED || LED4 == currentLED) {
            currentDirection *= -1;
        }
        // Setup for next iteration
        currentLED += currentDirection;
    }
}

void checkButton() {
    int state = digitalRead(analogPin);
    // Check if button state has changed
    if (state != buttonState) {
        buttonState = state;
        // Change paused state when button is released
        if (state == HIGH) {
            paused = !paused;
        }
    }
}
</code></pre>
",,53847046,578
42852482,2,42852317,2017-03-17T08:21:48.253,0,,3716664,,2017-03-17T08:21:48.253,,0,,"<p>Something fast:</p>

<pre><code>int main() {
    //....
    //Init your pins and so on
    //....
    while (1) {
        if ((PINB &amp; (1 &lt;&lt; 4))) {
            PORTB |= 1 &lt;&lt; 5;
        } else {
            PORTB &amp;= ~(1 &lt;&lt; 5);
        }
    }
}
</code></pre>
",,53856579,138
42865528,2,42865343,2017-03-17T19:17:32.237,0,,7667894,,2017-03-17T19:17:32.237,,2,,"<p>I'm assuming whenever <code>(true != ok)</code> your value in invalid. The problem might be there, you keep that value while you should discard it.</p>

<p>What about you do</p>

<pre><code>bool ok;
double parsed = QString::fromLatin1(serialBuffer.left(serPos)).toDouble(&amp;ok);
if (ok) {
    previousValue = tempValue;
    tempValue = parsed;
    emit newData(parsed, previousValue);      
    }
</code></pre>

<p>It might be relevant to rename <code>tempValue</code> to <code>currValue</code> in that example.</p>
",,53872874,1193
42866451,2,42865343,2017-03-17T20:19:04.587,0,,4153719,,2017-03-17T20:19:04.587,,3,,"<p>Try this</p>

<pre><code>double tempValue = 0;
double previousValue = 0;

while ((serPos = serialBuffer.indexOf('\n')) &gt;= 0)
{
    tempValue = QString::fromLatin1(serialBuffer.left(serPos)).toDouble(&amp;ok);

    if (previousValue != 0 &amp;&amp; tempValue != 0){
        emit newData(tempValue, previousValue);
    }

    previousValue = tempValue
    serialBuffer = serialBuffer.mid(serPos+1);
}
</code></pre>
",,53891054,151
42905635,2,42904053,2017-03-20T14:01:46.677,1,,1705337,,2017-03-20T14:01:46.677,,1,,"<p>This demonstrates the concept of alphanumeric keypad typing:</p>

<pre><code>const int max_delay_between_keys = 300; // Time in milliseconds to allow between keypresses

String text = """";
char current_char = '\0';
int last_pressed = -1;
int times_pressed = 0;
int time_last_pressed = 0;

char lookup_value(int key, int count) {
    const char* const characters[12] = {""1"", ""abc2"", ""def3"", ""ghi4"", ""jkl5"", ""mno6"", ""pqrs7"", ""tuv8"", ""wxyz9"", ""*"", ""0 "", ""#""}; //Change this to match the characters on your keypad.
    const char* sequence = characters[key];
    return sequence[count % strlen(sequence)];
}

String process_keystream(int key_code) {
    int new_time = millis();
    bool time_over = (new_time - time_last_pressed &gt; max_delay_between_keys);

    time_last_pressed = new_time;

    key_code = log((float)key_code) / log(2.0) - 1;
    if (key_code == last_pressed &amp;&amp; !time_over) {
        times_pressed += 1;
    }
    else {
        if (last_pressed != -1) {
            text += current_char;
        }

        last_pressed = key_code;
        times_pressed = 0;
    }
    current_char = lookup_value(key_code, times_pressed);

    return text + current_char;
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  // Serial.println() is what you'd send to your screen.
  Serial.println(process_keystream(16)); // Pressed the 4 key
  Serial.println(process_keystream(16)); // Pressed the 4 key
  Serial.println(process_keystream(8));  // Pressed the 3 key
  Serial.println(process_keystream(8));  // Pressed the 3 key
  Serial.println(process_keystream(32)); // Pressed the 5 key
  Serial.println(process_keystream(32)); // Pressed the 5 key
  Serial.println(process_keystream(32)); // Pressed the 5 key
  delay(500);                            // Wait a while so the current letter is set.
  Serial.println(process_keystream(32)); // Pressed the 5 key
  Serial.println(process_keystream(32)); // Pressed the 5 key
  Serial.println(process_keystream(32)); // Pressed the 5 key
  Serial.println(process_keystream(64)); // Pressed the 6 key
  Serial.println(process_keystream(64)); // Pressed the 6 key
  Serial.println(process_keystream(64)); // Pressed the 6 key
}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>

<h3>Result:</h3>

<pre><code>g
h
hd
he
hej
hek
hel
helj
helk
hell
hellm
helln
hello
</code></pre>
",,53900441,1905
42937078,2,42908594,2017-03-21T20:01:38.477,1,,2317490,,2017-03-21T20:01:38.477,,2,,"<p>This binary serve worked for me:</p>

<pre><code>const char favicon[1344] = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 
 ... //  ( way shortened )
0x44, 0xae, 0x42, 0x60, 0x82
};


void handleFavicon() {
  server.send_P(200, ""image/x-icon"", favicon, sizeof(favicon));
}


server.on(""/favicon.ico"", handleFavicon); // in setup() or something like it
</code></pre>

<p>you might need to adjust your gzip header, but this method of embeding binary content works enough to show the right icon, i'd imaging a gzip stream works the same way...</p>
",,53914467,148
42968424,2,42968302,2017-03-23T06:07:15.930,0,,6059867,,2017-03-23T06:13:35.190,2017-03-23T06:13:35.190,2,,"<p>You should simply just have to change the name of the prototype in the header file, then change the name of the definition of the implementation in the cpp file, and finally remember to change the name where you are using it. </p>

<p>.h:</p>

<pre><code>size_t print(const char* str); to size_t Msg(const char * str)
</code></pre>

<p>.cpp:</p>

<pre><code>size_t Sha256Class::print(const char *str){
    return write_L(str);
}

to

size_t Sha256Class::Msg(const char *str){
    return write_L(str);
}
</code></pre>

<p>arduino file:</p>

<pre><code>uint8_t* hash;
uint32_t a;
unsigned long ms;
Serial.println(""Test: RFC4231 4.2"");
Serial.println(""Expect:b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7"");
Serial.print(""Result:"");
ms = micros();
Sha256.initHmac(hmacKey1,20);
/* change from Sha256.print(""Hi There"") to */
Sha256.Msg(""Hi There"");
printHash(Sha256.resultHmac());
Serial.print("" Hash took : "");
Serial.print((micros() - ms));
Serial.println("" micros"");
Serial.println();
</code></pre>

<p>However, since you have a <code>#if  defined(SHA256_LINUX)</code> around the prototype in the header file it could possibly not be declared as <code>Msg(const char *str)</code> instead of <code>print(const char *str)</code> so the best solution would just be to leave the print function implemented and create a second method that does the same thing.</p>

<p>In response to the comment.</p>

<p>.h:</p>

<pre><code>// Add this somewhere in the code wherever you see fit
size_t Msg(const char * str);
</code></pre>

<p>.cpp:</p>

<pre><code>//Add this somewhere in the cide wherever you see fit
size_t Sha256Class::Msg(const char *str){
    return write_L(str);
}
</code></pre>

<p>And in the arduino file just call the function as you wanted it to be with the new name <code>Sha256.Msg(""Hi There"");</code></p>
",,53914554,158
43598738,2,42980922,2017-04-24T22:33:57.720,3,,5674914,,2017-04-24T22:33:57.720,,1,,"<p>here's an extended example inspired by <a href=""https://www.mikrocontroller.net/topic/390980"" rel=""nofollow noreferrer"">https://www.mikrocontroller.net/topic/390980</a>:</p>

<pre><code>function display_off() {
i2cset -y 0 0x3c 0x00 0xAE  # Display OFF (sleep mode)
sleep 0.1
}

function init_display() {
i2cset -y 0 0x3c 0x00 0xA8  # Set Multiplex Ratio
i2cset -y 0 0x3c 0x00 0x3F    # value
i2cset -y 0 0x3c 0x00 0xD3  # Set Display Offset
i2cset -y 0 0x3c 0x00 0x00    # no vertical shift
i2cset -y 0 0x3c 0x00 0x40  # Set Display Start Line to 000000b
i2cset -y 0 0x3c 0x00 0xA1  # Set Segment Re-map, column address 127 ismapped to SEG0
i2cset -y 0 0x3c 0x00 0xC8    # Set COM Output Scan Direction, remapped mode. Scan from COM7 to COM0
#i2cset -y 0 0x3c 0x00 0xC0   # Set COM Output Scan Direction, remapped mode. Scan from COM7 to COM0
i2cset -y 0 0x3c 0x00 0xDA  # Set COM Pins Hardware Configuration
#i2cset -y 0 0x3c 0x00 0x12   # Alternative COM pin configuration, Disable COM Left/Right remap
#i2cset -y 0 0x3c 0x00 0x2    # Sequential COM pin configuration,  Disable COM Left/Right remap
#i2cset -y 0 0x3c 0x00 0x22   # Sequential COM pin configuration,  Enable Left/Right remap  (8pixels height)
i2cset -y 0 0x3c 0x00 0x32    # Alternative COM pin configuration, Enable Left/Right remap   (4pixels height)
#i2cset -y 0 0x3c 0x00 0x81 # Set Contrast Control
#i2cset -y 0 0x3c 0x00 0xCF   # value, 0x7F max.
i2cset -y 0 0x3c 0x00 0xA4  # display RAM content
i2cset -y 0 0x3c 0x00 0xA6  # non-inverting display mode - black dots on white background
i2cset -y 0 0x3c 0x00 0xD5  # Set Display Clock (Divide Ratio/Oscillator Frequency)
i2cset -y 0 0x3c 0x00 0x80    # max fequency, no divide ratio
i2cset -y 0 0x3c 0x00 0x8D  # Charge Pump Setting
i2cset -y 0 0x3c 0x00 0x14    # enable charge pump
i2cset -y 0 0x3c 0x00 0x20  # page addressing mode
i2cset -y 0 0x3c 0x00 0x20    # horizontal addressing mode
#i2cset -y 0 0x3c 0x00 0x21   # vertical addressing mode
#i2cset -y 0 0x3c 0x00 0x22   # page addressing mode
}

function display_on() {
i2cset -y 0 0x3c 0x00 0xAF  # Display ON (normal mode)
sleep 0.001
}

function reset_cursor() {
i2cset -y 0 0x3c 0x00 0x21  # set column address
i2cset -y 0 0x3c 0x00 0x00  #   set start address
i2cset -y 0 0x3c 0x00 0x7F  #   set end address (127 max)
i2cset -y 0 0x3c 0x00 0x22  # set page address
i2cset -y 0 0x3c 0x00 0x00  #   set start address
i2cset -y 0 0x3c 0x00 0x07  #   set end address (7 max)
}

display_off
init_display
display_on
reset_cursor

# fill screen
for i in $(seq 1024)
do
   i2cset -y 0 0x3c 0x40 0xff
done

reset_cursor

# clear screen
for i in $(seq 1024)
do
   i2cset -y 0 0x3c 0x40 0x0
done

reset_cursor

# draw a pattern
for i in $(seq 146)
do
    for i in 1 4 16 64 16 4 1
    do
        i2cset -y 0 0x3c 0x40 $i
    done
done
</code></pre>

<p>it is quite slow but works. tested with 128x32 oled display + raspberry pi 1.</p>
",,53919253,802
43098688,2,42991034,2017-03-29T16:04:23.793,0,,1347519,,2017-03-29T16:31:40.903,2017-05-23T12:02:00.800,0,,"<p>Probably because it uses <code>libusb</code>... and they appear to do it badly.</p>

<p>See my question here: <a href=""https://stackoverflow.com/questions/42145020/libusb-1-0-hotplug-events-stop-working-in-parent-after-fork-when-child-calls"">libusb-1.0 hotplug events stop working in parent after fork(), when child calls libusb_exit()</a></p>

<p>And the discussion here: <a href=""https://github.com/libusb/libusb/issues/268"" rel=""nofollow noreferrer"">https://github.com/libusb/libusb/issues/268</a></p>

<p>My specific problem was related to hotplug events, but I expect that other things will go wrong for you too.</p>

<p>The reason that this is less obvious in your scenario is because they are probably doing some setup / init when the library loads (how kind of them), rather than when you start to use it.</p>

<p>As pointed out by @duskwuff, there is another answer here: <a href=""https://stackoverflow.com/a/35186414/149341"">https://stackoverflow.com/a/35186414/149341</a></p>

<hr>

<p>I've just done some playing, follow along below:</p>

<pre class=""lang-sh prettyprint-override""><code>cd $(mktemp -d)
curl http://www.ftdichip.com/Drivers/D2XX/Linux/libftd2xx-x86_64-1.3.6.tgz | tar -xvz
</code></pre>

<p>Put this in <code>test.c</code>:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include ""ftd2xx.h""

int main(void) {
    int num_devs;

    fprintf(stderr, ""in to main()\n"");

    FT_STATUS ft_status = FT_CreateDeviceInfoList(&amp;num_devs);
    fprintf(stderr, ""FT_CreateDeviceInfoList() returned: %d\n"", ft_status);

    fprintf(stderr, ""out of main()\n"");

    return 0;
}
</code></pre>

<p>Compile:</p>

<pre class=""lang-sh prettyprint-override""><code>gcc test.c -o test -g -I release -L release/build -lftd2xx -ldl -lpthread
</code></pre>

<p>Now in <code>gdb</code>:</p>

<pre class=""lang-none prettyprint-override""><code>[...]
Reading symbols from test...done.
(gdb) b libusb_init
Breakpoint 1 at 0x40cd20
(gdb) start
Temporary breakpoint 2 at 0x401d75: file test.c, line 7.
Starting program: /tmp/tmp.jJpBNywVzB/test 
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/x86_64-linux-gnu/libthread_db.so.1"".

Breakpoint 1, 0x000000000040cd20 in libusb_init ()
(gdb) bt
#0  0x000000000040cd20 in libusb_init ()
#1  0x0000000000401f36 in my_init ()
#2  0x000000000041a05d in __libc_csu_init ()
#3  0x00007ffff7614ed5 in __libc_start_main (main=0x401d6d &lt;main&gt;, argc=1, argv=0x7fffffffe228, init=0x41a010 &lt;__libc_csu_init&gt;, fini=&lt;optimised out&gt;, rtld_fini=&lt;optimised out&gt;, stack_end=0x7fffffffe218)
    at libc-start.c:246
#4  0x0000000000401ca9 in _start ()
(gdb)
</code></pre>

<p>It hit the breakpoint on <code>libusb_init()</code> before even getting to <code>main()</code>, called from their <code>my_init()</code>.</p>
",,53930091,57
43026395,2,43025720,2017-03-26T07:55:27.887,0,,1132871,,2017-03-26T07:59:54.547,2017-03-26T07:59:54.547,3,,"<p>If you can use C++11 you may use the scoped enum:</p>

<pre><code>enum class Color {
    RED = 22,
    GREEN = 25
    // ...
};
</code></pre>

<p>Please take into account that scoped enums are not implicitly convertible to integer.</p>

<p>Another option is to use a regular enum:</p>

<pre><code>enum Color {
    COLOR_RED = 22,
    COLOR_GREEN = 25
    // ...
};
</code></pre>

<p>Defines aren't good and in general I would avoid them as well as allocating a color object because it will cost you in a runtime.</p>

<p>Independently on what your choice it should be in a header file.</p>
",,53940073,611
43027015,2,43026807,2017-03-26T09:15:34.593,1,,1705337,,2017-03-26T09:27:00.463,2017-03-26T09:27:00.463,0,,"<p>I have corrected your code and commented where necessary. You had some small problems I fixed as well:</p>

<ol>
<li>You were decrementing <code>plannedSpeed</code> without stopping it from dropping below the minimum value, i.e. <code>0</code>.</li>
<li>You were incrementing <code>plannedSpeed</code> without stopping it from going above the maximum value, i.e. <code>stepsPerRevolution</code>.</li>
<li>You weren't changing the value of <code>plannedSpeed</code> when starting the stepper motor.</li>
</ol>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;LiquidCrystal.h&gt;
#include &lt;Stepper.h&gt;
#include &lt;Key.h&gt;
#include &lt;Keypad.h&gt;

const int stepsPerRevolution = 200;
const byte ROWS = 4; //four rows
const byte COLS = 1; //one column
char keys[ROWS][COLS] = {
  {'-'},
  {'+'},
  {'I'},
  {'0'}
};
byte rowPins[ROWS] = {6, 7, 8, 9};
byte colPins[COLS] = {10};

int count = 0;
LiquidCrystal lcd(A5, A4, A3, A2, A1, A0);
Stepper myStepper(stepsPerRevolution, 2, 4, 3, 5);
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

int plannedSpeed = 50;
void setup() {
  // put your setup code here, to run once:
  lcd.begin(16, 2);
  Stepper.setSpeed(plannedSpeed);
  Serial.begin(9600);
}

void loop() {
  // put your main code here, to run repeatedly:
  char key = keypad.getKey();
  Serial.println(plannedSpeed);
  if (key == '-') {
    if (--plannedSpeed &lt; 0) // Decrease plannedSpeed 
      plannedSpeed = 0; // Make sure it does not go below 0
    Serial.println(plannedSpeed);
    delay(10);
  }
  else if (key == '+') {
    if (++plannedSpeed &gt; stepsPerRevolution) // Increase plannedSpeed 
      plannedSpeed = stepsPerRevolution; // Make sure it does not go above stepsPerRevolution
    Serial.println(plannedSpeed);
    delay(10);
  }
  else if (key == 'I') {
    plannedSpeed = stepsPerRevolution; // Set plannedSpeed to maximum
    myStepper.step(plannedSpeed); // Set stepper to plannedSpeed
    Serial.print(""Running at "" );
    Serial.println(plannedSpeed);
    delay(10);
  }
  else if (key == '0') {
    plannedSpeed = 0; // Set plannedSpeed to 0
    myStepper.step(plannedSpeed); // Set stepper to plannedSpeed
    Serial.print(""Stopping at "" );
    Serial.println(plannedSpeed);
    delay(10);
  }
}
</code></pre>
",,53956408,913
43053912,2,43052026,2017-03-27T18:30:41.677,1,,1386054,,2017-08-03T17:34:59.120,2017-08-03T17:34:59.120,2,,"<p>When you press a mechanical switch, it's possible for arcing or actual bouncing of the contacts to cause the circuit to open and close several times in rapid succession.</p>

<p>I think the problem is that you haven't ""debounced"" the button presses, thus, when you click a button once, it can actually register as multiple consecutive presses.</p>

<p>The simplest way to handle this in software is to add a delay after you detect the pin going low and then to check the pin again after the delay.  So, instead of:</p>

<pre><code>if (digitalRead(button) == LOW)
{ 
    while (digitalRead(button) == LOW) { } // do nothing
    ...
}
</code></pre>

<p>You'd do something like:</p>

<pre><code>if (digitalRead(button) == LOW)
{
    delay(20);
    if (digitalRead(button) == LOW) {
        ...
    }
}
</code></pre>

<p>There are more sophisticated approaches, but I bet this solves your immediate problem.</p>
",,53978811,150
43054690,2,43052026,2017-03-27T19:18:11.297,0,,7775249,,2017-03-27T19:18:11.297,,0,,"<p>Based on the information you provided above, here is my updated attempt at the checkButton function:</p>

<pre><code>void checkButton(int button){

  if (digitalRead(button) == LOW)
 { 
    delay(20);
    if(digitalRead(button) == LOW)
      while (digitalRead(button) == LOW) { } // do nothing
      //convert int to string for tracking/compare
      char buttStr = button + '0';
      attempt[z] = buttStr;
      z++;
      //light up led so we know btn press worked
      pulseLED(yellowLed, brightness, 500);
  }
}
</code></pre>
",,53980112,304
43064026,2,43063071,2017-03-28T08:10:01.597,1,,3716664,,2017-03-28T08:15:06.160,2017-03-28T08:15:06.160,0,,"<p>Convert your EPOCH time (seconds from 1970) to separate tokens (day, month, year, hour, minute, second) and the format it to string.</p>

<pre><code>char str[20];
sprintf(str, ""%02d:%02d.%04d"", date.day, date.month, date.year);
//Use your formatted date string not
</code></pre>

<p>Example decode library</p>

<pre><code>void TM_RTC_GetDateTimeFromUnix(TM_RTC_t* data, uint32_t unix) {
    uint16_t year;      
    data-&gt;Unix = unix;          /* Store unix time to unix in struct */
    data-&gt;Seconds = unix % 60;  /* Get seconds from unix */
    unix /= 60;                 /* Go to minutes */
    data-&gt;Minutes = unix % 60;  /* Get minutes */
    unix /= 60;                 /* Go to hours */
    data-&gt;Hours = unix % 24;    /* Get hours */
    unix /= 24;                 /* Go to days */
    data-&gt;WeekDay = (unix + 3) % 7 + 1; /* Get week day, monday is first day */

    year = 1970;                /* Process year */
    while (1) {
        if (RTC_LEAP_YEAR(year)) {
            if (unix &gt;= 366) {
                unix -= 366;
            } else {
                break;
            }
        } else if (unix &gt;= 365) {
            unix -= 365;
        } else {
            break;
        }
        year++;
    }
    /* Get year in xx format */
    data-&gt;Year = (uint8_t) (year - 2000);
    /* Get month */
    for (data-&gt;Month = 0; data-&gt;Month &lt; 12; data-&gt;Month++) {
        if (RTC_LEAP_YEAR(year)) {
            if (unix &gt;= (uint32_t)RTC_Months[1][data-&gt;Month]) {
                unix -= RTC_Months[1][data-&gt;Month];
            } else {
                break;
            }
        } else if (unix &gt;= (uint32_t)RTC_Months[0][data-&gt;Month]) {
            unix -= RTC_Months[0][data-&gt;Month];
        } else {
            break;
        }
    }

    data-&gt;Month++;            /* Month starts with 1 */
    data-&gt;Day = unix + 1;     /* Date starts with 1 */
}
</code></pre>

<p>More available here (All structures and macros):</p>

<p><a href=""https://github.com/MaJerle/stm32fxxx_hal_libraries/blob/master/00-STM32_LIBRARIES/tm_stm32_rtc.c"" rel=""nofollow noreferrer"">https://github.com/MaJerle/stm32fxxx_hal_libraries/blob/master/00-STM32_LIBRARIES/tm_stm32_rtc.c</a></p>

<p><a href=""https://github.com/MaJerle/stm32fxxx_hal_libraries/blob/master/00-STM32_LIBRARIES/tm_stm32_rtc.h"" rel=""nofollow noreferrer"">https://github.com/MaJerle/stm32fxxx_hal_libraries/blob/master/00-STM32_LIBRARIES/tm_stm32_rtc.h</a></p>
",,53984567,603
43094208,2,43088480,2017-03-29T12:57:13.737,0,,7047790,,2017-03-29T12:57:13.737,,0,,"<p>Here is a <em>very</em> simple logic you can try : </p>

<pre><code>if( sensorVal &lt;= treshold ) {
  Serial.println(""Watering"");
  waterOn();
} else {
  Serial.println(""NOT watering"");
  waterOff();
}
</code></pre>
",,54008315,107
43131823,2,43127524,2017-03-31T03:18:19.447,0,,908821,,2017-03-31T03:35:46.960,2017-03-31T03:35:46.960,0,,"<p>you can consolidate your condition checks.</p>

<pre><code>if(motionIOS == 0 &amp;&amp; previousMotion == 40 &amp;&amp; character == 50) {
    motionIOSValue = 50;
} else if (motionIOS == 1 &amp;&amp; previousMotion == 60 &amp;&amp; character == 70){
    motionIOSValue = 70;
} else {
    previousMotion = character;
}
</code></pre>

<p>You can extract the condition check to another class if you want.</p>

<pre><code>bool updateIosValue(int previousMotion, int character, int testMotion, int testCharacter){
    //do your custom checks here.
    return previousMotion==testMotion &amp;&amp; character== testCharacter;
} 

if(motionIOS==0 &amp;&amp; updateIosValue(previousMotion, character, 40, 50){
    motionIOSValue = 50;
}else if(motionIOS==1 &amp;&amp; updateIosValue(previousMotion, character, 60, 70){
    motionIOSValue = 70;
}else{
    previousMotion = character;
}
</code></pre>
",,54057193,226
43230090,2,43194587,2017-04-05T11:37:02.453,1,,3861548,,2017-06-20T12:53:30.617,2017-06-20T12:53:30.617,0,,"<p>You need to add the condition of <code>min(117)</code> and <code>max(137)</code> tolerance to move motor. And then, map the posibles values of joystick to the range of motor's speed</p>

<pre><code>if (PS4.connected()) 
{
    int analogValue = PS4.getAnalogHat(LeftHatY);
    if (analogValue  &gt; 137 || analogValue &lt; 117)
    {
        int motorValue = y = map(x, 117, 137 , 0, 255); 
        M3-&gt;setSpeed(motorValue); 
        PS4.setLed(Green);
        PS4.setLedFlash(100 ,100);
    }
}
</code></pre>

<p>It could be better with some error handling but you could start with it.</p>
",,54060022,66
45533630,2,43194587,2017-08-06T15:35:32.143,0,,7810950,,2017-08-06T15:35:32.143,,0,,"<pre><code> uint16_t s = PS4.getAnalogHat(RightHatY);

if (PS4.getAnalogHat(RightHatY) &lt; 117 )
{
 s = map (s, 117,  0, 0, 250);
 M3-&gt;run(FORWARD);
 M3-&gt;setSpeed(s);
 PS4.setLed(Green);
 PS4.setLedFlash(100, 100);
}

if (PS4.getAnalogHat(RightHatY) &gt; 137)
{
 s = map (s, 137, 0, 0, -250);
 M3-&gt;run(BACKWARD);
 M3-&gt;setSpeed(s);
 PS4.setLed(Green);
 PS4.setLedFlash(100, 100);
}
</code></pre>

<p>This is the solution to the problem I originally asked. Variable speed control of a motor using a Dualshock 4 &amp; Arduino Motor shield. Thanks a lot for the help. I was 3d Printing parts for the robot/chassis which is why I took time off programming.  </p>
",,54065822,692
43244768,2,43200966,2017-04-06T02:44:03.463,1,,6601582,,2017-04-06T02:44:03.463,,8,,"<p>You can reference <a href=""https://github.com/Azure/azure-iot-sdk-c/blob/master/iothub_client/samples/iothub_client_sample_amqp/iothub_client_sample_amqp.c"" rel=""nofollow noreferrer"">official sample</a> of C SDK and set the properties like this:</p>

<pre><code>                        static char UseridText[15] = ""userid prop"";
                        static char propUserid[10] = ""user-id"";
                        static char toText[10] = ""to prop"";
                        static char propTo[10] = ""to"";
                        if (Map_AddOrUpdate(propMap, propTo, toText) != MAP_OK)
                        {
                            (void)printf(""ERROR: Map_AddOrUpdate Failed!\r\n"");
                        }
                        if (Map_AddOrUpdate(propMap, propUserid, UseridText) != MAP_OK)
                        {
                            (void)printf(""ERROR: Map_AddOrUpdate Failed!\r\n"");
                        }
</code></pre>

<p>And access them on the receiver side in C# via the EventData Class like the following code piece. For complete sample of using compatible endpoint to read device-to-cloud messages you can reference <a href=""https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-csharp-csharp-getstarted#receive-device-to-cloud-messages"" rel=""nofollow noreferrer"">here</a>.</p>

<pre><code>            if (eventData.Properties.ContainsKey(""to""))
            {
                object value;
                eventData.Properties.TryGetValue(""to"", out value);
                Console.WriteLine(""property key: 'to' value: '{0}'"", value.ToString());
            }
            if (eventData.Properties.ContainsKey(""user-id""))
            {
                object value;
                eventData.Properties.TryGetValue(""user-id"", out value);
                Console.WriteLine(""property key: 'user-id' value: '{0}'"", value.ToString());
            }
</code></pre>

<p>As for accessing them on the receiver side in C SDK with the EventData Class you can use <code>EventData_Properties()</code>. This is the <a href=""https://github.com/Azure/azure-event-hubs-c/blob/b1b28676ee228c6cf828a4cb3f2505d65c3284a9/eventhub_client/samples/receive/receive.c#L79"" rel=""nofollow noreferrer"">receive sample</a> you can reference.</p>
",,54066235,65
43223382,2,43205485,2017-04-05T06:26:33.513,0,,2135792,,2017-04-05T19:31:28.630,2017-04-05T19:31:28.630,0,,"<p>After diving into my old calculus i found a mathematical answer to this problem.</p>

<p>Given that I've got three points in the space I can form a plane:</p>

<pre><code>P: (Px, Py, Pz)
Q: (Qx, Qy, Qz)
R: (Rx, Ry, Rz)
</code></pre>

<p>These points and the math described in here <a href=""http://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfPlanes.aspx"" rel=""nofollow noreferrer"">http://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfPlanes.aspx</a> allowed me to move forward.</p>

<pre><code>Vector(PQ) = (PQx, PQy, PQz)
Vector(PR) = (PRx, PRy, PRz)
</code></pre>

<p>Now I apply the cross product to these two vectors and this gives the normal vector of the plane<br>
(Cross product math described here: <a href=""http://tutorial.math.lamar.edu/Classes/CalcII/CrossProduct.aspx#Vectors_CrossProd_Ex2"" rel=""nofollow noreferrer"">http://tutorial.math.lamar.edu/Classes/CalcII/CrossProduct.aspx#Vectors_CrossProd_Ex2</a>)</p>

<pre><code>Vector(PQ) x Vector(PR) = Vector(PQy * PRz - PQz * PRy, 
                                 PQz * PRx - PQx * PRz,
                                 PQx * PRy - PQy * PRx)
</code></pre>

<p>So, this is what I've got as a plane equation, without respect to that it has to pass trough one of the points:</p>

<pre><code>x(PQy * PRz - PQz * PRy) + y(PQz * PRx - PQx * PRz) + z(PQx * PRy - PQy * PRx) = 0
</code></pre>

<p>To get the full equation of my plane that passes trough all of the points, I have to apply one point, as described in example 1 in the first link.</p>

<pre><code>x(PQy * PRz - PQz * PRy) + y(PQz * PRx - PQx * PRz) + z(PQx * PRy - PQy * PRx) = 
Px(PQy * PRz - PQz * PRy) + Py(PQz * PRx - PQx * PRz) + Pz(PQx * PRy - PQy * PRx)
</code></pre>

<hr>

<p>To apply my example to this formula I get the following equation:</p>

<pre><code>P: (90, 6, 5)
Q: (70, 6, 6)
R: (70, 8, 7)

Vector(PQ) = (20,  0, -1)
Vector(PR) = (20, -2, -2)
</code></pre>

<p>Cross product of these gives me this formula:</p>

<pre><code>-2x + 20y - 40z = 0
</code></pre>

<p>If I now apply the point P to this I can get the full equatio of my plane:</p>

<pre><code>-2x + 20y - 40z = -2 * 90 + 20 * 6 - 40 * 5
-2x + 20y - 40z = -260
z = (-2x + 20y + 260) / 40
</code></pre>

<p>As I seek the z value where x = 6 and y = 80 I put these values into the equation.</p>

<pre><code>x = 80
y = 6
z = (-2 * 80 + 20 * 6 + 260) / 40
z = 5.5
</code></pre>

<p>5.5 is the expected answer for this example as it exactly in the middle of P and Q.</p>

<p>The final implementation of this algorithm:</p>

<pre><code>float TargetSpeed::PlaneInterpolation(Point3D p, Point3D q, Point3D r, int x, int y)
{
    Point3D pq = Point3D(p.X - q.X, p.Y - q.Y, p.Z - q.Z);
    Point3D pr = Point3D(p.X - r.X, p.Y - r.Y, p.Z - r.Z);

    Point3D  n = Point3D(pq.Y * pr.Z - pq.Z * pr.Y, 
                         pq.Z * pr.X - pq.X * pr.Z, 
                         pq.X * pr.Y - pq.Y * pr.X);
    float d = n.X * p.X + n.Y * p.Y + n.Z * p.Z;

    float z = (d - n.X * (float)x - n.Y * (float)y) / n.Z;
    return z;
}
</code></pre>
",,54092429,70
43254072,2,43218883,2017-04-06T11:36:37.247,0,,5295429,,2020-02-20T21:18:42.157,2020-02-20T21:18:42.157,0,,"<p>You can try using samples from here:</p>

<p><a href=""http://jnicookbook.owsiak.org/recipe-No-001/"" rel=""nofollow noreferrer"">http://jnicookbook.owsiak.org/recipe-No-001/</a></p>

<p>I am able to run the code without any issues at:</p>

<pre><code>cat /proc/cpuinfo
processor   : 0
model name  : ARMv6-compatible processor rev 7 (v6l)
BogoMIPS    : 2.00
Features    : half thumb fastmult vfp edsp java tls
CPU implementer : 0x41
CPU architecture: 7
CPU variant : 0x0
CPU part    : 0xb76
CPU revision    : 7

Hardware    : BCM2708
Revision    : 0010
Serial      : 00000000ee4a3dc2
</code></pre>

<p>Just do following:</p>

<pre><code>git clone https://github.com/mkowsiak/jnicookbook.git
cd jnicookbook/recipes/recipeNo001/
export JAVA_HOME=$WHEREVER_YOUR_JAVA_IS
make test
</code></pre>

<p>Should give you result:</p>

<pre><code>make test
/usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt/bin/java -Djava.library.path=:./lib -cp target recipeNo001.HelloWorld
library: :./lib
Hello world!
</code></pre>
",,54110906,301
43221471,2,43219965,2017-04-05T03:49:04.053,1,,1505939,,2017-04-05T03:49:04.053,,0,,"<p>Maybe what you want is:</p>

<pre><code>uint8_t const event[][8] = 
{  {'0','0','0','0','7','0','1','5'}
,  {'0','0','0','0','7','0','1','5'}
,  {'0','0','0','0','7','0','1','5'}
};
</code></pre>
",,54173340,34
43253056,2,43251424,2017-04-06T10:52:16.923,0,,7690317,,2017-04-06T15:03:21.870,2017-04-06T15:03:21.870,8,,"<p>I have edited the code to reflect what you are trying to do.</p>

<p>Essentially you need to check if your pressure is increasing or decreasing. 
So for this you can take two readings and compare them; one reading is taken before the other. If the latest reading is higher than the previous then its going up, no cause for alarm. </p>

<p>If the latest reading is less that the previous then the pressure is going down. So, cause for alarm but not just yet... </p>

<p>TWO conditions need to be met before the alarm sounds, the pressure needs to be on a downward path AND the pressure needs to be below the threshold value. </p>

<p>kpa must be going down AND be below threshold:</p>

<p><code>(val &lt; previous &amp;&amp; val &lt; threshold)</code></p>

<p>See if this works, sorry I rushed it a bit and haven't tested it at all: </p>

<pre><code>#include &lt;LiquidCrystal.h&gt;

LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

// These constants won't change:
const int analogPin = A0;    // pin that the sensor is attached to
const int ledPin = 13;       // pin that the LED is attached to
const int threshold = 5;   // an arbitrary threshold level that's in the range of the analog input
const int buzzer = 9;  // pin that the buzzer is connected to.
int val = 0;  // store value
int previous; // previous reading

void setup()
{
  pinMode(ledPin, OUTPUT);  // initialize the LED pin as an output:
  pinMode(buzzer, OUTPUT); // Set buzzer - pin 9 as an output
  Serial.begin(9600);   // initialize serial communications:
  lcd.begin(16, 2);
  lcd.print (""Pressure in kpa"");
}

void loop() {
  float sensorValue = analogRead(analogPin);   // read the value of the pressure sensor:
  int kpa = ((sensorValue * 5 / 1024) * (15 / 5) * (6.894 / 1) - 10);

  // we want to check if this is going up or down.
  previous = val;
  val = kpa;

  if (val &gt; previous) {
    digitalWrite(ledPin, HIGH);
    delay(1000);
    digitalWrite(ledPin, HIGH);  // make LED flashy-flashy if its going up
    delay(1000);
  }
  else if (val &lt; previous &amp;&amp; val &lt; threshold) {
    digitalWrite(ledPin, LOW); // ... and we switch off the LED
    tone(buzzer, 1000);     // WEE WAH WEE WAH WEE WAH
    delay(1000);
  }

}
</code></pre>

<p>I added a flashing LED to the code because flashing LEDs are just better. 
I also used an <code>else...if</code> statement.</p>

<p>Hopefully this will work. </p>

<p>Cheers, 
Ingwe.</p>
",,54183908,231
43263227,2,43262647,2017-04-06T18:35:29.390,2,,794749,,2017-04-06T18:35:29.390,,2,,"<p>You need to replace <code>Serial.read()</code> with <a href=""https://www.arduino.cc/en/Reference/StreamReadStringUntil"" rel=""nofollow noreferrer""><code>Serial.readStringUntil('\n')</code></a>. The strings will need to be sent with a trailing new line character.</p>

<pre><code>void loop()
{
    if (Serial.available())
    {
        String value = Serial.readStringUntil('\n');
             if (value == ""1on"")  digitalWrite(PUMP1, LOW);           //relay1 on
        else if (value == ""1off"") digitalWrite(PUMP1, HIGH);          //relay1 off
        else if (value == ""2on"")  digitalWrite(PUMP2, LOW);           //relay2 on
        else if (value == ""2off"") digitalWrite(PUMP2, HIGH);          //relay2 off
        // and so on
    }
}
</code></pre>

<p><a href=""https://www.arduino.cc/en/Serial/ReadString"" rel=""nofollow noreferrer""><code>Serial.readString()</code></a> was suggested in the comments, but that will lead to 1 sec of delay (by default). In this case the string is considered complete when there is no data for certain amount of time. And it will be impossible to control multiple relays at the same time.</p>
",,54189535,74
43286729,2,43285966,2017-04-07T20:36:27.547,0,,225074,,2017-04-07T20:36:27.547,,0,,"<p>You don't need to put everything into a class.  I think using a class for the lights is overkill.</p>

<p>In my experience, a functions are used to process the light pins and they all would take a pin enum.  </p>

<p>Unless you have a huge amount of pins to set up, a loop may not be worthwhile.  Unrolling the loop may increase the programs efficiency:</p>

<pre><code>pinMode(5,OUTPUT);
pinMode(6,OUTPUT);
pinMode(7,OUTPUT);
pinMode(8,OUTPUT);
pinMode(9,OUTPUT);
</code></pre>

<p>Initialization usually only occurs once, so optimization is usually not warranted.  </p>

<p>If need to use classes, I suggest one class that <em>models</em> a single light.  </p>

<p>Every light has an associated pin.</p>

<p>You can have a container of lights (such as array):  </p>

<pre><code>class Light
{
  public:  
    Light(unsigned int pin)
      : m_pin(pin),
        m_is_on(false)
    { ; }

    void initialize(); // Sets up the appropriate pin
    void on(); // Turns on the light
    void off(); // Turns off the light
    void blink(unsigned int rate, unsigned int duration);

  private:
     unsigned int m_pin;
     bool         m_is_on;
};

Light display[] = {Light(5), Light(6), Light(7), Light(8), Light(9)};
const unsigned int light_quantity =
    sizeof(display) / sizeof(display[0]);
</code></pre>

<p>An advantage to this model is that your program can be in terms of <em>lights</em> and not worry about pins.</p>
",,54203672,44
43286846,2,43285966,2017-04-07T20:45:39.183,0,,982161,,2017-04-07T21:10:47.487,2017-04-07T21:10:47.487,0,,"<p>Your code is not working because you are just writing code but didnt make an algorithm to design the application first...</p>

<p>Take a minute to see what you wrote as a software...
you are passing to the constructor an array, but where are you using that information??  nowhere... </p>

<pre><code> lights(int ledPins[]){

    for(i=0; i&lt;5; i++){     //pins are set up as output
      pinMode(pins[i],OUTPUT);
    }

  }//end constructor
</code></pre>

<p>and you are setting as output in the arduino the pins <code>{0 to 4}</code> and not <code>{5 to 9}</code> as you think, after that the <strong>loop</strong> method is just setting to HIGH level pins that probably dont even have LEds :) </p>

<p>(you should there by the way use a sleep and play turning the leds on an off so you can see how they blink )</p>
",,54208786,70
43287770,2,43285966,2017-04-07T22:07:37.470,-1,,7834613,,2017-04-07T22:07:37.470,,0,,"<p>I resolved the problem: just two lines were missing. I correct the real constructor</p>

<pre><code>public:
  lights(int ledPins[]){
    for(i=0; i&lt;5; i++){    
      pines[i] = ledPines[i];
    for(i=0; i&lt;5; i++){     //pins are set up as output
      pinMode(pins[i],OUTPUT);
    }

  }//end constructor
</code></pre>
",,54212549,651
43287233,2,43286860,2017-04-07T21:18:49.653,1,,4511648,,2017-04-09T09:46:51.587,2017-04-09T09:46:51.587,2,,"<p>Use a bit operation:</p>

<p><strong>C code</strong></p>

<pre><code>char b = 0x01;

if( b &amp; 0x01 ) {
   // LSB is set
}
else {
   // LSB is not set
}
</code></pre>

<p><strong>Python code</strong></p>

<pre><code>b = 0x01
if (b&amp;0x01)==0x01 :
    # LSB is set
else:
    # LSB is not set
</code></pre>

<p>LSB = <strong>L</strong>east <strong>S</strong>ignificant <strong>B</strong>it (in your case)</p>
",,54216231,97
43291650,2,43291522,2017-04-08T07:59:45.790,2,,7478597,,2017-04-08T07:59:45.790,,6,,"<p>To be sure that <code>leds_left</code> and <code>leds_right</code> are really allocated in consecutive memory they must be ""structured together"". This in combination with a <code>union</code> could provide what you want:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct { int i; /* ... */ } myStruct;

static union {
  struct {
    myStruct leds_left[20];
    myStruct leds_right[20];
  };
  myStruct leds_all[40];
} data;

int main()
{
  for (int i = 0; i &lt; 20; ++i) {
    data.leds_left[i].i = 1 + i;
    data.leds_right[i].i = -(1 + i);
  }
  for (int i = 0; i &lt; 40; ++i) {
    printf("" %d"", data.leds_all[i].i);
  }
  printf(""\n"");
  return 0;
}
</code></pre>

<p>Compiled and tested with gcc in cygwin on Windows 10 (64 bit):</p>

<pre><code>$ gcc -std=c11 -o test-struct-array test-struct-array.c 

$ ./test-struct-array.exe 
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20

$
</code></pre>

<p><strong>Attention!</strong></p>

<p>Packing and alignment could become an issue (depending on what components <code>myStruct</code> actually contains).</p>
",,54225045,90
43292098,2,43291522,2017-04-08T08:59:33.323,0,,7836186,,2017-04-08T08:59:33.323,,3,,"<p>I just found a solution which is good enough for me. Because the nice way with an combined array is not possible, i just wrote a function witch is checking the index and then accessing the right element in one of the arrays. </p>

<pre><code>    void setLED(int number, CRGB color){
       if (number &lt; leds_left_size){
          leds_left[number] = color;
       }else if (number &gt;= leds_left_size &amp;&amp; number &lt; leds_left_size + leds_top_size){
          leds_top[number - leds_left_size] = color;
       }else if (number &gt;= leds_left_size + leds_top_size &amp;&amp; number &lt; leds_top_size + leds_left_size + leds_right_size){
          leds_right[number - leds_left_size - leds_top_size] = color;
       }else{
          leds_bottom[number - leds_left_size - leds_top_size - leds_right_size] = color;
       }
    }
</code></pre>

<p>It does not exactly anwer my question, but it works as a workaround</p>
",,54250050,298
43348632,2,43347331,2017-04-11T14:19:39.523,0,,5467603,,2017-04-11T14:26:33.000,2017-04-11T14:26:33.000,1,,"<p>I can't add comment so I will answer what I think about your problem.
Looks like your code written in global scope outer any function body.</p>

<p>You can't use if statement out of any function body.
Try to enclose your if statement in function body. </p>

<p>Something like this:</p>

<pre><code>void chec(int fd) {
  if (fd == -1) {
     perror(""/dev/ttyAMS0"");
     exit(1);
  }
}
int fd = open(""/dev/ttyAMS0"", O_RDWR);
check(fd);
</code></pre>
",,54256634,95
43414187,2,43413718,2017-04-14T15:04:44.093,1,,1757475,,2017-04-14T15:04:44.093,,0,,"<p>The solution as Andriano Repetti told</p>

<pre><code>  uint8_t id = read8(BME280_REGISTER_CHIPID);
  if ( ( id != BME_280_2_CHIPID)  &amp;&amp; (id != BME_280_1_CHIPID) ){

    #ifdef DEBUG
        uint8_t value = read8(BME280_REGISTER_CHIPID);
        debugPrint(""BME280 DEBUG: read BME280_CHIPID "");
        debugPrint(value,HEX);
        debugPrint( "" expected "");
        debugPrint(BME_280_1_CHIPID,HEX);
      debugPrint( "" or "");
      debugPrintLn(BME_280_2_CHIPID,HEX);
    #endif
        return false;
  }
</code></pre>
",,54280655,199
43416903,2,43416844,2017-04-14T18:09:42.557,2,,1386054,,2017-04-14T18:17:49.717,2017-04-14T18:17:49.717,3,,"<p>Declare <code>color</code> before the if statement, and just assign to it in the blocks:</p>

<pre><code>// seeing which color I got(r g or b)
int color = 0;
if (RW &gt; BW &amp;&amp; RW &gt; GW){
  color = 1;    // no `int` here, just assigning
    delay(7000);
}  else if  (GW &gt; RW &amp;&amp; GW &gt; BW){
  color = 2;
  delay(7000);
} else if  (BW &gt; RW &amp;&amp; BW &gt; GW){
  color = 3;
  delay(7000);
} 
</code></pre>

<p>If you need it to survive to a future call to loop, make it global.</p>
",,54280752,764
43416948,2,43416844,2017-04-14T18:12:58.053,0,,7368195,,2017-04-14T18:12:58.053,,4,,"<p>why not declare it outside the if-else if ladder and set its value in the conditions?
Something like,</p>

<pre><code>    int i;
    if(...)
    {
      i=1;
    }
    else if(...)
    { 
      i=2;
    }
</code></pre>

<p>...and so  </p>
",,54296146,110
43417042,2,43416844,2017-04-14T18:20:20.853,1,,3313064,,2017-04-14T18:20:20.853,,0,,"<p>A very clean solution would be to move that functionality into a separate function which returns an <code>int</code>. This is also the only way to make the resulting <code>int</code> a <code>const</code> variable, which is good practice.</p>

<p>Example:</p>

<pre><code>int ChooseColor(unsigned int RW, unsigned int BW, unsigned int GW)
{
    // seeing which color I got(r g or b)
    if (RW &gt; BW &amp;&amp; RW &gt; GW) {
        return 1;
    } else if  (GW &gt; RW &amp;&amp; GW &gt; BW) {
        return 2;
    } else if  (BW &gt; RW &amp;&amp; BW &gt; GW) {
        return 3;
    }
    assert(false);
    return 0; // to prevent compiler warnings
}
</code></pre>

<p>Then inside <code>loop</code>, do this:</p>

<pre><code>int const color = ChooseColor(RW, BW, GW);
delay(7000);
</code></pre>
",,54316980,136
43418731,2,43417444,2017-04-14T20:24:07.280,0,,4709300,,2017-04-18T04:21:07.993,2017-04-18T04:21:07.993,2,,"<p>While I was trying to understand your question I realized what you needed was more than a single variable. You needed a class, this is because you wished to have a string that represents the hex code to be printed out and also the number itself in the form of an unsigned 16 bit integer, which I deduced would be something like <code>unsigned short int</code>. So I created a class that did all this for you named <code>hexset</code> (I got the idea from <code>bitset</code>), here:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class hexset {
 public:
     hexset(int num) {
         this-&gt;hexnum = (unsigned short int) num;
         this-&gt;hexstring = hexset::to_string(num);
    }

    unsigned short int get_hexnum() {return this-&gt;hexnum;}
    std::string get_hexstring() {return this-&gt;hexstring;}

 private:
    static std::string to_string(int decimal) {
        int length = int_length(decimal);
        std::string ret = """";
        for (int i = (length &gt; 1 ? int_length(decimal) - 1 : length); i &gt;= 0; i--) {
            ret = hex_arr[decimal%16]+ret;
            decimal /= 16;
        }
        if (ret[0] == '0') {
            ret = ret.substr(1,ret.length()-1);
        }
        return ""0x""+ret;
    }

    static int int_length(int num) {
        int ret = 1;
        while (num &gt; 10) {
            num/=10;
            ++ret;
        }
        return ret;
    }

    static constexpr char hex_arr[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    unsigned short int hexnum;
    std::string hexstring;
};

constexpr char hexset::hex_arr[16];

int main() {
    int number_from_file = 3000; // This number is in all forms technically, hex is just another way to represent this number.
    hexset hex(number_from_file);
    std::cout &lt;&lt; hex.get_hexstring() &lt;&lt; ' ' &lt;&lt; hex.get_hexnum() &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>I assume you'll probably want to do some operator overloading to make it so you can add and subtract from this number or assign new numbers or do any kind of mathematical or bit shift operation.</p>
",,54383773,87
43437848,2,43427063,2017-04-16T13:37:47.010,0,,4760587,,2017-04-16T13:37:47.010,,0,,"<p>Since it seems to be a memory-related problem, you should consider using simple <code>char</code>s instead of <code>String</code>s, or <code>char[]</code> if you really need multi-character strings.</p>

<p>Your initialization would then look like this:</p>

<pre><code>char Pieces[][6] =
 {
    {'n', 'n', 'n', 'n', 'n', 'n'},
    {'n', 'n', 'n', 'n', 'n', 'n'},
    ...
    {'t', 't', 't', 't', 't', 't'}
 };
</code></pre>

<p>and your assignment would be</p>

<pre><code>char temp = Pieces[piece][0];
</code></pre>

<p>In case you need to use strings, use char*:</p>

<pre><code>char* Pieces[][6] =
    {
        { ""n"", ""n"", ""n"", ""n"", ""n"", ""n"" },
        ...
        { ""n"", ""n"", ""n"", ""n"", ""n"", ""n"" }
    };

char *temp = Pieces[0][1];
</code></pre>

<p>If you are not going to perform any fancy string operations, the <code>String</code> class is not useful for you anyhow.</p>

<p>By the way, note how conveniently you can leave out the array size when initializing.</p>
",,54391285,2251
43455977,2,43441730,2017-04-17T17:06:56.527,1,,7215838,,2019-12-28T10:57:09.757,2019-12-28T10:57:09.757,0,,"<p>I found answer to my own problem. I used this time c++ to organize it in class (very poor one because it doesn't handle any errors and doesn't use c++ in the most..) Here is the code : </p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;termios.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;strings.h&gt;

#include &lt;cstring&gt;
#include &lt;iostream&gt;
//Here I define some vars 
#define BAUDRATE B9600
#define MODEMDEVICE ""/dev/ttyACM0""
#define _POSIX_SOURCE 1

class serial{
public:
serial(){
    fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY );
    if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); } 
    // Improvement No. 1 I save old setting and clean the new one 
    tcgetattr(fd,&amp;oldtio);
    bzero(&amp;newtio, sizeof(newtio));

    // Here I set all the flags to vars at once
    newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
    newtio.c_iflag = IGNPAR | ICRNL;
    newtio.c_oflag = 0;
    newtio.c_lflag = ICANON;
    //here I set some new flags..
    newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */
    newtio.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
    newtio.c_cc[VERASE]   = 0;     /* del */
    newtio.c_cc[VKILL]    = 0;     /* @ */
    newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */
    newtio.c_cc[VTIME]    = 0;     /* inter-character timer unused */
    newtio.c_cc[VMIN]     = 1;     /* blocking read until 1 character  arrives */
    newtio.c_cc[VSWTC]    = 0;     /* '\0' */
    newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */
    newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */
    newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
    newtio.c_cc[VEOL]     = 0;     /* '\0' */
    newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */
    newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */
    newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */
    newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
    newtio.c_cc[VEOL2]    = 0;     /* '\0' */
    // and I finally save the settings 
    tcflush(fd, TCIFLUSH);
    tcsetattr(fd,TCSANOW,&amp;newtio);
}
~serial(){
    close(fd);
}

    std::string sread(){
        res = read(fd,buf,255);
        buf[res]=0;
        return buf;
    }
    void swrite(const char* input){
        write(fd,input,std::strlen(input));
    }
private:
    int fd,c,res;
    struct termios oldtio,newtio;
    char buf[255];
};


int main(){
    serial s;
    s.swrite(""Light"");
    std::string buf = s.sread();
    std::cout &lt;&lt; buf;
}
</code></pre>

<p>This is more of a ripoff from ""Serial programming HOW TO"" : <a href=""http://tldp.org/HOWTO/Serial-Programming-HOWTO/"" rel=""nofollow noreferrer"">http://tldp.org/HOWTO/Serial-Programming-HOWTO/</a> (form the example code..)</p>

<p>And here is the new poor arduino code :</p>

<pre><code>int x; 
String buff;
int lpin = A0;
int tpin = A1;
int data;
void setup() {
  Serial.begin(9600);
  pinMode(lpin,INPUT);
  pinMode(tpin,INPUT);
}
void loop() {
  if(Serial.available() == 1)
  {
    buff = Serial.readString();
    if(buff == ""Light""){
      data = analogRead(lpin);
      Serial.print(data);
      Serial.print(""\n"");
    }else if(buff == ""Temp""){
      data = analogRead(tpin);
      Serial.print(data);
      Serial.print(""\n"");
    }else{
      Serial.print(""Something went wrong !"");
      Serial.print(""\n"");
    }
  }
  delay(1);
}
</code></pre>
",,54421840,270
43509928,2,43506217,2017-04-20T03:55:04.790,0,,7021499,,2017-04-20T03:55:04.790,,2,,"<p>Other people have recommended that the if statement rpmcount == 1 be updated to rpmcount >= 1. I agree with them and here is why:</p>

<p>When the LCD code is added to your project it makes the loop() call take far longer than when it is not there. Since the loop call is taking so long the wheel is going to get around several times before the rpmcount = 0 code even gets a chance to run. Try removing the rpm code and putting millis() calls around the LCD code to see how long it takes to update the LCD. Then as a test replace the LCD update code with a delay of the measured interval.</p>

<pre><code>  unsigned long temp = millis();

  lcd.clear();
  lcd.begin(16,2);
  lcd.setCursor(0,0);
  lcd.print(""GS="");
  lcd.setCursor(3,0);
  lcd.print(groundspeed,1);
  lcd.print(""m/s"");
  lcd.setCursor(10,0);
  lcd.print(""D="");
  lcd.print(distance,0);
  lcd.print(""m"");

  Serial.println(millis()-temp); // println can take a while too, 
                                 // so don't add to many in parts 
                                 // of the code that are timing critical.
</code></pre>

<p>A couple of other points to note:</p>

<p>rpmcount is read before a value has been assigned to it. So it should be initialized to 0 in the setup function. </p>

<p>The same is true for fin_time, as good practice the code should initialize all of the global variables. </p>

<p>Uninitialized variables might cause of some of the undesired behavior... Sometimes.</p>
",,54446038,542
46528641,2,43555829,2017-10-02T15:26:25.333,0,,8604608,,2017-10-02T15:26:25.333,,3,,"<p>The answer to your question is in the following code:</p>

<pre><code>QByteArray ba(""J"");
serial.write(ba);
serial.flush();
qDebug() &lt;&lt; ""data has been send"" &lt;&lt; endl;
serial.close();
</code></pre>

<p>After you make <code>serial.flush ()</code>, you immediately close the port. It is necessary to wait until the data is really sent. For example, using <code>bool QSerialPort :: waitForBytesWritten (int msecs)</code>.</p>
",,54474686,100
49839723,2,43555829,2018-04-15T07:59:05.897,1,,9478282,,2018-04-15T07:59:05.897,,4,,"<p>I would suggest you to read about how Qt event system works. All Qt IODevice derived classes work asynchronously. You need to use QApplication in order to host its object system. After that, you need to change your code so that it's not blocking io thread of QSerialPort.</p>

<p>I usually use readyRead singal or I use waitForBytesWritten and waitForReadReady combination.You should take a look at the <a href=""http://doc.qt.io/qt-5/qtserialport-terminal-example.html"" rel=""nofollow noreferrer"">QtSerialPort examples</a>. You'll find there several possible implementations depending on your application needs.</p>

<p>You can try this, it will work fine.</p>

<pre><code>#include &lt;QCoreApplication&gt;
#include &lt;iostream&gt;
#include &lt;QSerialPort&gt;
#include &lt;QDebug&gt;
#include &lt;Windows.h&gt;
#include &lt;QElapsedTimer&gt;

using namespace std;
QSerialPort serial;
QElapsedTimer timer;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    serial.setPortName(""ttyUSB0"");
    serial.open(QIODevice::ReadWrite);

       serial.setBaudRate(QSerialPort::Baud9600);
       serial.setDataBits(QSerialPort::Data8);
       serial.setParity(QSerialPort::NoParity);
       serial.setStopBits(QSerialPort::OneStop);
       serial.setFlowControl(QSerialPort::NoFlowControl);

       while(!serial.isOpen()) serial.open(QIODevice::ReadWrite);

       if (serial.isOpen() &amp;&amp; serial.isWritable())
       {
       qDebug() &lt;&lt; ""Serial is open"";

       QByteArray output;
       QByteArray input;

       while(true)
       {
         output = ""a"";
         serial.write(output);
        serial.flush();
        timer.start();
       // Sleep(80);
        qDebug() &lt;&lt; timer.elapsed();

         serial.waitForBytesWritten(100);
         serial.waitForReadyRead(100);

        if(serial.bytesAvailable()&gt;=18)
         input = serial.read(18);
        qDebug()&lt;&lt;input;
         }
       }
    return a.exec();
}
</code></pre>
",,54477942,1114
43572469,2,43572367,2017-04-23T14:36:34.957,1,,6681210,,2017-04-23T14:36:34.957,,2,,"<p>execl() function returns an integer as an return code. If the return code is not 0 use errno() and strerror(errno) to determinate if there was an error and what was causing the error.
<p>
example:<br></p>

<pre><code>int err=0;
err=execl(""/bin/match-face"", ""-face-image"", ""image.jpg"", ""-display"", ""true"",  (char*) NULL);
if( err != 0 )
{
  fprintf(stderr,""execl() failed: %s\n"",strerror(errno));
}
</code></pre>
",,54495764,63
43596334,2,43594815,2017-04-24T19:33:57.953,0,,4524618,,2017-04-24T19:33:57.953,,2,,"<p>You are not setting <code>prevmillis</code></p>

<p>Change your function </p>

<pre><code>void Cluster::lightning(unsigned long g_flag[]){

    static unsigned long prevmillis=millis();
    if(counter&lt;=5){  
        currentmillis=millis();

        if(currentmillis-prevmillis&gt;=g_flag[0]){
            _led[0].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[1]){
            _led[1].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[2]){
            _led[2].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[3]){
            _led[3].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[4]){
            _led[4].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[5]){
            _led[5].blinkled();
        }
        if(currentmillis-prevmillis&gt;=g_flag[6]){
            prevmillis=currentmillis;
            counter=counter+1;
        }

    }
}
</code></pre>
",,54518123,202
43654360,2,43654042,2017-04-27T09:51:20.097,1,,7511215,,2017-04-28T13:30:05.357,2017-04-28T13:30:05.357,0,,"<p>You should read the status of a button inside the while loop. Like this:</p>

<pre><code>while(time &gt; 0)
{
  buttonState02 = digitalRead(button02);
  if (buttonState02){
    Serial.println(""Points"");
  }
  time--;
  Serial.println(time);  
}
</code></pre>

<p>And in your code, there is no logic to add points to the score.</p>
",,54555031,60
43657168,2,43654042,2017-04-27T12:00:04.727,1,,2207924,,2017-04-27T12:05:37.770,2017-04-27T12:05:37.770,0,,"<p>A hardware interrupt would do exactly what you need.  </p>

<p>Attach an interrupt routine to the pin your button is linked to,  and get it to set the 'score' variable.  Make sure you introduce some sort of timeout to avoid button-bounce (I.e. set LastTimeIncremented when you increase the score, and only increment score if LastTimeIncremented is more than 1 second ago)</p>

<p>This way the score will always be set regardless of what else the program may be doing.</p>

<p>Information on this can be found in the Arduino <a href=""https://www.arduino.cc/en/Reference/attachInterrupt"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Reference/attachInterrupt</a></p>

<p>The example on that page would do exactly what you want, just replace 'blink' with 'incrementScore' and you're pretty much done</p>

<pre><code> const byte ledPin = 13;
 const byte interruptPin = 2;
 int score = 0;
 int increment = 1;


void setup() {
   pinMode(ledPin, OUTPUT);
   pinMode(interruptPin, INPUT_PULLUP);
   attachInterrupt(digitalPinToInterrupt(interruptPin), incScore, RISING);
}

void loop() {
   digitalWrite(ledPin, state);
}

void incScore() {
   score = score+increment;
   // add anti-bounce functionality here
}
</code></pre>
",,54562271,66
43655816,2,43655520,2017-04-27T10:57:43.420,1,,1620779,,2017-04-27T10:57:43.420,,0,,"<p>In Linux, you may do command substitution and pass its result as arguments to the program, Something like this</p>

<pre><code>./your_program ""$(/path/to/your/binary/file)""
</code></pre>

<p>Suppose your main is </p>

<pre><code>int main(int argc,char* argv[]){
.
.
return 0;
}
</code></pre>

<p>Acess the arguments like <code>argv[1]</code> and  so.</p>

<p>Here the <code>$(command)</code> does the substitution and it passes the printed values from the binary as arguments to the pgm. Hope this helps.</p>
",,54583818,5340
43657087,2,43655520,2017-04-27T11:56:33.250,1,,6633483,,2017-05-08T07:53:43.813,2017-05-08T07:53:43.813,1,,"<p>Use snprintf function. For e.g.</p>

<pre><code>snprintf(cmdbuff, BUFFER_LEN, ""dmidecode --type 17 | grep -i Size | grep -o '\\&lt;[0-9]*\\&gt;' | paste -sd+ | bc"");
</code></pre>

<p>Here cmdbuff is character array where command will be stored , BUFFER_LEN is a size of the character array</p>

<p>Then use popen and fgets to get the output of command into some buffer as shown below</p>

<pre><code>      if((fd = popen(cmdbuff,""r"")) != NULL)
  {
     fgets(buffer, BUFFER_LEN, fd);
     sprintf(vnfc_configured_memory, ""%s"", buffer);
     vnfc_configured_totalRAM = atof(vnfc_configured_memory);
  }
</code></pre>
",,54593409,638
43711419,2,43655520,2017-04-30T21:17:53.427,1,,15168,,2017-04-30T21:17:53.427,,0,,"<p>The correct function pair to use on POSIX systems is <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html"" rel=""nofollow noreferrer""><code>popen()</code></a> and
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/pclose.html"" rel=""nofollow noreferrer""><code>pclose()</code></a>.  You can perhaps use Microsoft's <a href=""https://msdn.microsoft.com/en-us/library/96ayss4b.aspx"" rel=""nofollow noreferrer""><code>_popen()</code></a> and 
<a href=""https://msdn.microsoft.com/en-us/library/25xdhsd2.aspx"" rel=""nofollow noreferrer""><code>_pclose()</code></a> unless the warning 'This API cannot be used in applications that execute in the Windows Runtime' matters to you.</p>

<p>You would use it more or less like this.  I've had to invent the name of the command you wish to execute since the question doesn't specify that.  I chose <code>./example.exe</code> as the name — and I'm assuming it needs no arguments.</p>

<pre><code>char cmd[] = ""./example.exe"";
FILE *fp = popen(cmd, ""r"");
if (fp != NULL)
{
    char buffer[4096];
    size_t nbytes;
    while ((nbytes = fread(buffer, sizeof(buffer), sizeof(char), fp)) != 0)
    {
        …process nbytes of data…
        …it is not a null-terminated string unless you add the null byte…
    }
    pclose(fp);
}
else
{
    …report error for failure to execute command…
}
</code></pre>
",,54611864,771
43666440,2,43666376,2017-04-27T19:30:02.180,1,,3716664,,2017-04-27T19:30:02.180,,2,,"<p><code>X</code> is parameter how many measurements must be created before average calculation.</p>

<pre><code>float getAverage(int X) {
    float out = 0;
    int i = 0;

    for (i = 0; i &lt; X; i++) {
        out += sonar.ping_cm();
    }
    return out / (float)X;
}
</code></pre>
",,54618065,96
43666442,2,43666376,2017-04-27T19:30:12.050,1,,982161,,2017-04-27T19:32:40.037,2017-04-27T19:32:40.037,1,,"<p>for loop look ok:</p>

<pre><code>void loop(const int x) {
    float distance_1 = 0.0;
    for (int i=0;i&lt;x;i++)
    {
        distance_1 += sonar.ping_cm();
        delay(50);
    }
    mean distance = (distance_1)/x;
</code></pre>
",,54658621,67
43682631,2,43682584,2017-04-28T14:28:54.467,3,,7359094,,2017-04-28T14:28:54.467,,0,,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow noreferrer"">aggregate initialization</a>.</p>

<pre><code>struct Sensors
{
    int pin;
    int angle;
    bool state;
};

Sensors sensor[6] = {
    { 0, 0, true },
    { 1, 0, true },
    { 2, 0, false },
    { 3, 0, false },
    { 4, 0, false },
    { 5, 0, false }
};
</code></pre>
",,54671220,1419
43682659,2,43682584,2017-04-28T14:30:36.347,2,,2060725,,2017-04-28T14:30:36.347,,0,,"<pre><code>struct Sensors
{
    int pin;
    int angle;
    bool state;
};

int main()
{
    Sensors sensor[6] = {
        { 1, 2, false },
        { 1, 2, true },
        { 1, 3, false },
        { 2, 2, false },
        { -1, -2, true },
        { 1, 2, false }
    };

    return 0;
}
</code></pre>
",,54706042,78
43687562,2,43687487,2017-04-28T19:25:23.920,0,,1997148,,2017-04-28T19:32:42.753,2017-04-28T19:32:42.753,1,,"<p>I Have found the answer (by mistake)<br>
i have added the includes to Boiler.cpp file
and moved the   </p>

<pre><code>   RF24 radio(7, 8);                                    // Init RF24 Radio
   RF24Network network(radio);                          // Init RF24 Network
   RF24Mesh mesh(radio, network);                       // Init RF24 Mesh
</code></pre>

<p>this is the new code :  </p>

<pre><code>#include ""RF24.h""
#include ""RF24Network.h""
#include ""RF24Mesh.h""
#include &lt;SPI.h&gt;
.
.
.
#include ""Boiler.h""

RF24 radio(7, 8);                                   // Init RF24 Radio
RF24Network network(radio);                         // Init RF24 Network
RF24Mesh mesh(radio, network);                      // Init RF24 Mesh

Boiler::Boiler(int pin ,float Rev , String Last )
{
    _pin = pin;
    dev.setDevice(_pin);                    // Set Device Output (on/off)
    turnOff();
}

void Boiler::init( char nodeID)
{
    _nodeID = nodeID;
    // Connect to the mesh and set Node ID
    mesh.setNodeID(_nodeID);
    if (_DEBUG) Serial.println(F(""Connecting to the mesh...""));
    mesh.begin();

    // init LCD and print init data on LCD
    myGLCD.InitLCD(60);                         // Init LCD 55 contrast
    myGLCD.setFont(SmallFont);                  // Set small font
    myGLCD.clrScr();                            // clr screen
    myGLCD.print(""Boiler Device"",0,0);          //Print init Data on screen
    myGLCD.print(""Rev :"" , 0 , 10);
    myGLCD.printNumF(_rev,1 ,35,10,'.',1,'0');
    myGLCD.print(_last,0,40);
    myGLCD.update();                            // Update display


    turnOff();
}
</code></pre>

<p>and now it compiles ;-)  </p>
",,54721928,649
43693968,2,43693115,2017-04-29T09:28:46.663,0,,6049796,,2017-04-29T09:33:52.777,2017-04-29T09:33:52.777,0,,"<p>This is a dirty code which works well under severe limitations:</p>

<ul>
<li>no error checking needed</li>
<li>string format is exactly known and is <code>F...F'\0'</code></li>
<li>it is assumed that codes for <code>'0'</code> to <code>'9'</code> and <code>'A'</code> to <code>'F'</code> are subsequent and growing </li>
</ul>

<p>The trick is to use character codes for calculations
_</p>

<pre><code>char * in;
uint64_t out=0;
int counter;

for(counter=0; in[counter]; counter++){
    if(in[counter]&gt;='0'&amp;&amp;in[counter]&lt;='9') {
        out*=0x10;
        out+=in[counter]-'0';
    } else {
    //assuming that character is from 'A' to 'F'
        out*=0x10;
        out+=in[counter]-'A'+10;
    }
}
</code></pre>
",,54724651,685
43694139,2,43693115,2017-04-29T09:49:37.620,0,,982161,,2017-04-29T10:01:41.620,2017-04-29T10:01:41.620,0,,"<p>if you get every char of the string and converted to a numeric hex value then you will need only to calculate the power of every digit, that conversion returns a number which can be represented in several ways (hex in your case)</p>

<pre><code>std::string w(""ABCD"");
unsigned int res = 0;
for (int i = w.length()-1; i &gt;= 0; i--)
{
    unsigned int t = parseCharToHex(w[w.length() - 1 - i]);
    std::cout &lt;&lt; std::hex &lt;&lt; t &lt;&lt; std::endl;
    res += pow(16, i) * t;
}

std::cout &lt;&lt; ""res: "" &lt;&lt; std::dec &lt;&lt; res &lt;&lt; std::endl;
</code></pre>

<p>the function <strong>parseCharToHex</strong>:</p>

<pre><code>unsigned int parseCharToHex(const char charX)
{
    if ('0' &lt;= charX &amp;&amp; charX &lt;= '9') return charX - '0';
    if ('a' &lt;= charX &amp;&amp; charX &lt;= 'f') return 10 + charX - 'a';
    if ('A' &lt;= charX &amp;&amp; charX &lt;= 'F') return 10 + charX - 'A';
}
</code></pre>

<p><strong>pow</strong> function is required from the arduino doc <a href=""https://www.arduino.cc/en/reference/pow"" rel=""nofollow noreferrer"">here</a></p>

<p><a href=""https://i.stack.imgur.com/EvnvD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EvnvD.png"" alt=""enter image description here""></a></p>
",,54744985,337
43695286,2,43695121,2017-04-29T11:43:43.590,1,,991484,,2017-04-29T12:10:52.860,2017-04-29T12:10:52.860,7,,"<p>I suggest you expand on your design somewhat:</p>

<ul>
<li>have a repeating <code>QTimer</code> with an interval depending on the rate you want to send the string at, and the timer to the function that sends the string</li>
<li>connect the button's pressed signal to start the timer</li>
<li>connect the button's released signal to stop the timer</li>
</ul>

<p>Events are sent only once, thus the handlers will be executed only once, if you want to keep on repeating it, you will have to use a timer or some other event driven way. You cannot use a loop as that would block the GUI thread and your application will stop responding.</p>

<p>Sure, you could use the button's auto repeat, and there is the option to adjust the triggering and repeating intervals, but a solution that puts a line between logic and GUI is better. You should really rely on the GUI for storing data or controlling the internal logic. The GUI should only be a front end.</p>

<p>You need more work on the serial port though. If you are going to use it from the GUI thread, you will have to use the non-blocking API. Which will require to extend on your implementation a little bit more. There is a <a href=""http://doc.qt.io/qt-5/qtserialport-cwriterasync-serialportwriter-cpp.html"" rel=""nofollow noreferrer"">good example on how to achieve that</a>, you only need to modify it to simply enable the sending of further payloads once the previous payload has been successfully sent. In pseudo code:</p>

<pre><code>on button press
  start timer
on button release
  stop timer
onTimeout
  if (can send) 
    send
    can send = false
onBytesWritten
  accumulate bytes
  if (payload is completed)
    can send = true
    reset payload byte counter
</code></pre>

<p>Of course, you will also have to do some error checking, you can't just expect it to work. The example linked contains basic error handling.</p>
",,54767297,113
43703784,2,43695121,2017-04-30T06:52:22.240,0,,1329652,,2017-04-30T07:09:13.370,2017-05-23T11:46:49.270,0,,"<p>A ""blind"" or unconfirmed auto-repeat is not a good idea, because presumably it takes the Arduino some time to react to the command. Given that by default you have no flow control anywhere, you'll overflow the buffers along the way - in the USB-to-serial chip (if any), and also in Arduino. Since your packets (lines) have no error checking, you'll end up executing junk commands on Arduino, with varying effects.</p>

<p>At the very minimum, the Arduino should send a message indicating that a command was finished. It can be a simple <code>Serial.println(""OK"")</code>. You would then send the next command as soon as you receive the successful reply.</p>

<p>This slows things down a bit since the next command can only be processed after you've finished receiving the reply and finished sending the command. Instead, you can pre-send one or more commands ahead of time, so that the Arduino is always busy.</p>

<p><a href=""https://i.stack.imgur.com/8toQj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8toQj.png"" alt=""Sequence Diagram""></a></p>

<p>We can leverage Qt to concisely model both the PC side of it, as well as Arduino.</p>

<p>A complete example follows, written in the literate programming style.</p>

<p>First, we'll need a local pipe to communicate between the PC and the mockup Arduino. This is much easier than using <code>QLocalServer</code>.</p>

<pre><code>// https://github.com/KubaO/stackoverflown/tree/master/questions/comm-button-loop-43695121
#include &lt;QtWidgets&gt;
#include &lt;private/qringbuffer_p.h&gt;
#include &lt;cctype&gt;

class AppPipe; // See https://stackoverflow.com/a/32317276/1329652
</code></pre>

<p>To manage the communications, the controller allows up to two commands ""in flight"" at any given time. This is a very simple controller - in production code, we should have an explicit state machine that would allow error handling etc. See e.g. <a href=""https://stackoverflow.com/q/32486198/1329652"">this question</a>.</p>

<pre><code>class Controller : public QObject {
   Q_OBJECT
   int m_sent = {}, m_received = {};
   QPointer&lt;QIODevice&gt; m_dev;
   QByteArray m_command;
   QQueue&lt;QByteArray&gt; m_commands;
   void sendCommand() {
      if (m_command.isEmpty()) return;
      while (m_commands.size() &lt; 2) {
         m_commands.enqueue(m_command);
         m_dev-&gt;write(m_command);
         m_dev-&gt;write(""\n"");
         m_sent ++;
         updateStatus();
      }
   }
   Q_SLOT void updateStatus() {
      emit statusChanged(m_sent, m_received, m_commands.size());
   }
public:
   Controller(QIODevice * dev, QObject * parent = {}) : QObject{parent}, m_dev(dev) {
      connect(dev, &amp;QIODevice::readyRead, [this]{
         if (!m_dev-&gt;canReadLine()) return;
         auto const replyFor = m_commands.dequeue();
         m_received ++;
         if (m_dev-&gt;readLine() == ""OK\n"" || m_dev-&gt;readLine() == ""ERROR\n"")
            sendCommand();
         updateStatus();
         Q_UNUSED(replyFor);
      });
      QMetaObject::invokeMethod(this, ""updateStatus"", Qt::QueuedConnection);
   }
   Q_SLOT void setCommand(const QByteArray &amp; cmd) {
      m_command = cmd;
      sendCommand();
   }
   Q_SLOT void stop() {
      m_command.clear();
   }
   Q_SIGNAL void statusChanged(int sent, int received, int queueDepth);
};
</code></pre>

<p>A user interface provides a button and a status indicator:
<a href=""https://i.stack.imgur.com/krqTu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/krqTu.png"" alt=""screenshot of the example""></a></p>

<pre><code>class Ui : public QWidget {
   Q_OBJECT
   QFormLayout m_layout{this};
   QPushButton m_move{""Move""};
   QLabel m_status;
public:
   Ui(QWidget * parent = {}) : QWidget{parent} {
      setMinimumWidth(300);
      m_layout.addWidget(&amp;m_move);
      m_layout.addWidget(&amp;m_status);
      connect(&amp;m_move, &amp;QPushButton::pressed, this, &amp;Ui::moveActive);
      connect(&amp;m_move, &amp;QPushButton::released, this, &amp;Ui::inactive);
   }
   Q_SIGNAL void moveActive();
   Q_SIGNAL void inactive();
   Q_SLOT void setStatus(const QString &amp; status) {
      m_status.setText(status);
   }
};
</code></pre>

<p>We're mostly done with the PC side of things - the test setup will come later, inside of <code>main</code>.</p>

<p>We now turn to the Arduino side, and mock up a minimal Arduino environment. Recall that the Arduino ""language"" is really C++11! We implement Arduino functionality using Qt classes.</p>

<pre><code>#define F(str) str

QElapsedTimer arduinoTimer;

unsigned long millis() {
   return arduinoTimer.elapsed();
}

inline bool isSpace(int c) {
   return ( isspace (c) == 0 ? false : true);
}

class Print {
public:
   virtual size_t write(uint8_t) = 0;
   size_t write(const char *str) {
      if (str == nullptr) return 0;
      return write((const uint8_t *)str, strlen(str));
   }
   virtual size_t write(const uint8_t *buffer, size_t size) = 0;
   size_t write(const char *buffer, size_t size) {
      return write((const uint8_t *)buffer, size);
   }
   size_t print(const char text[]) { return write(text); }
   size_t println(const char text[]) { return write(text) + write(""\n""); }
   size_t println() { return write(""\n""); }
};

class Stream : public Print {
public:
   virtual int available() = 0;
   virtual int read() = 0;
};

class HardwareSerial : public Stream {
   QPointer&lt;QIODevice&gt; m_dev;
public:
   void setDevice(QIODevice * dev) { m_dev = dev; }
   void begin(int) {}
   size_t write(uint8_t c) override {
      return m_dev-&gt;putChar(c) ? 1 : 0;
   }
   size_t write(const uint8_t * buffer, size_t size) override {
      return m_dev-&gt;write((const char*)buffer, size);
   }
   int read() override {
      char c;
      return m_dev-&gt;getChar(&amp;c) ? c : -1;
   }
   int available() override {
      return m_dev-&gt;bytesAvailable();
   }
} Serial;
</code></pre>

<p>We can now write the Arduino code, exactly as it would appear on the real Arduino. The <code>LineEditor</code> is a class I find missing in Arduino - it provides asynchronous input tokenization, and allows interactive line editing when <code>TTY</code> is set. When run on an actual Arduino, you could call <code>Line.setTTY(true)</code> and connect to the Arduino via PUTTY or any other terminal program. Yes - PUTTY is a general-purpose terminal that can connect to a serial port.</p>

<pre><code>template &lt;unsigned int N&gt; class LineEditor {
   char m_data[N];
   char * m_ptr;
   bool m_has : 1; ///&lt; Have we got a complete line yet?
   bool m_tty : 1; ///&lt; Are we an interactive application (attached to a terminal)?
   LineEditor(const LineEditor &amp;) = delete;
   LineEditor &amp; operator=(const LineEditor &amp;) = delete;
public:
   LineEditor() : m_tty{false} { clear(); }
   void clear() {
      m_data[0] = '\0';
      m_ptr = m_data;
      m_has = false;
   }
   void input(Stream &amp; str) {
      auto const c = str.read();
      if (c == '\r' || c == '\n') {
         m_has = true;
         m_ptr = m_data;
         if (m_tty) str.println();
      }
      else if (m_tty &amp;&amp; (c == '\b' || c == 0x7F)) {
         if (m_ptr &gt; m_data) {
            *--m_ptr = '\0';
            str.print(F(""\b \b""));
         }
      }
      else if (c &gt;= 32 &amp;&amp; c &lt; 127 &amp;&amp; m_ptr &lt; m_data+N-1) {
         *m_ptr++ = c;
         *m_ptr = '\0';
         if (m_tty) str.write(c);
      }
   }
   void setTTY(bool tty) { m_tty = tty; }
   bool isTTY() const { return m_tty; }
   bool ready() const { return m_has; }
   char * data() { return m_data; }
   unsigned int size() const { return m_ptr-m_data; }
   const char * getToken() {
      if (!m_has) return nullptr;
      char c;
      while ((c = *m_ptr) &amp;&amp; isSpace(c)) m_ptr++;
      auto ret = m_ptr;
      while ((c = *m_ptr) &amp;&amp; !isSpace(c)) *m_ptr++ = tolower(c);
      if (c)
         *m_ptr++ = '\0'; // terminate the previous token
      return ret;
   }
};

LineEditor&lt;32&gt; Line;

void s_input();
void s_moveCommand();
struct {
   unsigned long at = {};
   void (*handler)() = s_input;
} state ;

void processLine() {
   auto const cmd = Line.getToken();
   auto const param = Line.getToken();
   if (strcmp(cmd, ""move"") == 0 &amp;&amp; param) {
      char * end;
      auto distance = strtol(param, &amp;end, 10);
      if (param != end &amp;&amp; distance &gt;= 0 &amp;&amp; distance &lt;= 10000) {
         // valid move command - pretend that it took some time
         state.at = millis() + 1000;
         state.handler = s_moveCommand;
      }
   } else
      Serial.println(""ERROR"");
   Line.clear();
}

void s_moveCommand() {
   Serial.println(""OK"");
   state.at = {};
   state.handler = s_input;
}

void s_input() {
   while (Serial.available()) {
      Line.input(Serial);
      if (Line.ready())
         return processLine();
   }
}

void setup() {
   Serial.begin(9600);
}

void loop() {
   if (!state.at || millis() &gt;= state.at)
      state.handler();
}
</code></pre>

<p>An adapter class executes the Arduino environment:</p>

<pre><code>class Arduino : public QObject {
   QBasicTimer m_loopTimer;
   static QPointer&lt;Arduino&gt; m_instance;
   void timerEvent(QTimerEvent * event) override {
      if (event-&gt;timerId() == m_loopTimer.timerId())
         loop();
   }
public:
   Arduino(QObject * parent = {}) : QObject{parent} {
      Q_ASSERT(!m_instance);
      m_instance = this;
      m_loopTimer.start(0, this);
      arduinoTimer.start();
      setup();
   }
};
QPointer&lt;Arduino&gt; Arduino::m_instance;
</code></pre>

<p>Finally, we set up the test and connect all of the involved components.
The <code>Arduino</code> object runs in its own thread.</p>

<pre><code>class SafeThread : public QThread {
using QThread::run;
public:
   ~SafeThread() { quit(); wait(); }
};

int main(int argc, char ** argv) {
   using Q = QObject;
   QApplication app{argc, argv};
   AppPipe ctlPipe(nullptr, QIODevice::ReadWrite | QIODevice::Text);
   AppPipe serialPipe(&amp;ctlPipe, QIODevice::ReadWrite | QIODevice::Text);
   ctlPipe.addOther(&amp;serialPipe);
   Serial.setDevice(&amp;serialPipe);
   Controller ctl(&amp;ctlPipe);
   Ui ui;
   Arduino arduino;
   SafeThread thread;
   arduino.moveToThread(&amp;thread);
   thread.start(QThread::LowPriority);

   Q::connect(&amp;ui, &amp;Ui::moveActive, &amp;ctl, [&amp;]{ ctl.setCommand(""move 200""); });
   Q::connect(&amp;ui, &amp;Ui::inactive, &amp;ctl, [&amp;]{ ctl.stop(); });
   Q::connect(&amp;ctl, &amp;Controller::statusChanged, &amp;ui, [&amp;](int s, int r, int d){
      ui.setStatus(QStringLiteral(""sent=%1 received=%2 queue depth=%3"").arg(s).arg(r).arg(d));
   });

   ui.show();
   return app.exec();
}
#include ""main.moc""
</code></pre>

<p>This concludes the example. You can copy-paste it into an empty <code>main.cpp</code>, or you can fetch the complete project from github.</p>
",,54823232,57
43706972,2,43705519,2017-04-30T13:32:44.687,0,,1630963,,2017-04-30T13:32:44.687,,1,,"<p><code>strcttest *tt;</code> is your problem. You're not allocating memory for and creating an object of type <code>strcttest</code> - you're merely allocating memory for a pointer to an object of that type. Basically, the code should crash everywhere when your code gets to the line <code>tt-&gt;a=1;</code> The fact that it doesn't when run on the Nano is basically dumb luck..</p>

<p>Think of the case where you have a char* variable and then try to copy a string to it - it will crash too, since you dont have any storage space for the string itself - you only have a few bytes allocated that store the address of the string.</p>

<p>The following is a more reasonable implementation of your <code>void loop()</code> function:</p>

<pre><code>void loop() {
  // put your main code here, to run repeatedly:
  //Create structure
  strcttest tt;
  tt.a=1;
  tt.b=2;
  //Output result
  Serial.println (t.libTest(&amp;tt));  
  delay(1000);
}
</code></pre>

<p>Another (slower, due to use of new and delete) implementation may look like this:</p>

<pre><code>void loop() {
  // put your main code here, to run repeatedly:
  //Create structure
  strcttest *tt = new strcttest;
  tt-&gt;a=1;
  tt-&gt;b=2;
  //Output result
  Serial.println (t.libTest(tt));
  delete tt;  
  delay(1000);
}
</code></pre>
",,54823307,2348
43709019,2,43708927,2017-04-30T17:03:56.883,6,,1593860,,2017-04-30T17:03:56.883,,6,,"<p>It might or might not be, depending on how it's used. Most compilers are pretty smart about not creating storage for a <code>const</code> object if they don't need it. So, for example:</p>

<pre><code>void f() {
    const int arr_size = 10;
    int arr[arr_size];
    // do something with arr
}
</code></pre>

<p>Here, the only use of <code>arr_size</code> is to specify the size of the array. There's no need to create an <code>int</code> object for that; the compiler just creates an array of size 10.</p>

<p>On the other had:</p>

<pre><code>void f(const int* ip) {
    // do something with ip
}

int main() {
    const int n = 100;
    f(&amp;n);
    return 0;
}
</code></pre>

<p>Here, the compiler has to create an <code>int</code> object for <code>n</code>, because the code takes the address of <code>n</code>.</p>
",,54854205,414
43711688,2,43711313,2017-04-30T21:48:45.133,5,,404970,,2017-04-30T21:48:45.133,,1,,"<p>Because of </p>

<pre><code>#define charLCD
</code></pre>

<p>this is what your compiler sees:</p>

<pre><code>class
{
  public:
    (int pin1,int pin2,int pin3,int pin4,int enable);
    void sendChar(unsigned char c);

  private:
    int _pin1;
    int _pin2;
    int _pin3;
    int _pin4;
    int _enable



};

::(int pin1,int pin2,int pin3,int pin4,int enable) {
  _pin1 = pin1;
  _pin2 = pin2;
  _pin3 = pin3;
  _pin4 = pin4;
  _enable = enable;

}

// ...
</code></pre>

<p>Pick a better header guard.</p>

<p>You also need to qualify the definitions of member functions:</p>

<pre><code>void charLCD::sendChar(unsigned char c) {
    // Send char to item
}
</code></pre>
",,54902816,208
43712468,2,43711548,2017-04-30T23:34:33.370,0,,5627286,,2017-04-30T23:34:33.370,,0,,"<p>Two points:
1. your code says the function <code>inversekinematic()</code> returns a pointer to a <code>double</code>, not an array.
2. you return a pointer to a <code>double</code>, but it's always the same address.</p>

<p>Maybe typedefs will help simplify the code?</p>

<pre><code>typedef double Mat42[4][2];

Mat42 a, a1;

Mat42 *inversekinematic(double target[4][4])
{
        // ...
        return &amp;a;
}
</code></pre>

<p>But, for the code you've shown, I don't see why you need to return the address of a fixed global value. Perhaps your real code might return the address of 'a' or 'a1', but if it doesn't ...</p>
",,54908601,40
43715125,2,43713008,2017-05-01T06:19:46.957,2,,1136195,,2017-05-01T15:03:10.410,2017-05-01T15:03:10.410,4,,"<p>Since you are going through an array 0-7 of 1s, you should be using bit shifting:</p>

<pre><code>int convertBinToDec(boolean Bin[]) {
  int ReturnInt = 0;
  for (int i = 0; i &lt; 8; i++) {
    if (Bin[7 - i]) {
      Serial.print(""Set Bit "");
      Serial.print(i);
      ReturnInt += 1&lt;&lt;i;
      Serial.print("" ==&gt; "");
      Serial.print(1&lt;&lt;i);
      Serial.print("", "");
    }
  }
  return ReturnInt;
}

DecToBin: 1 -&gt; 00000001 -&gt; Set Bit 0 ==&gt; 1, 1
DecToBin: 2 -&gt; 00000010 -&gt; Set Bit 1 ==&gt; 1, 2
DecToBin: 3 -&gt; 00000011 -&gt; Set Bit 0 ==&gt; 1, Set Bit 1 ==&gt; 1, 3
DecToBin: 4 -&gt; 00000100 -&gt; Set Bit 2 ==&gt; 2, 4
DecToBin: 5 -&gt; 00000101 -&gt; Set Bit 0 ==&gt; 1, Set Bit 2 ==&gt; 2, 5
DecToBin: 6 -&gt; 00000110 -&gt; Set Bit 1 ==&gt; 1, Set Bit 2 ==&gt; 2, 6
DecToBin: 7 -&gt; 00000111 -&gt; Set Bit 0 ==&gt; 1, Set Bit 1 ==&gt; 1, Set Bit 2 ==&gt; 2, 7
DecToBin: 8 -&gt; 00001000 -&gt; Set Bit 3 ==&gt; 4, 8
</code></pre>
",,54944742,725
43752501,2,43715499,2017-05-03T06:21:23.243,3,,7203873,,2018-07-15T11:35:46.740,2018-07-15T11:35:46.740,1,,"<p>If you are importing project from Arduino then rename the main file to main.cpp first. Use extern and function name from the file. Refer given example. Suppose you have two files viz main.cpp and someFuntion.cpp and you want to call functions from someFunction.cpp in main.cpp then,</p>

<p>someFunction.cpp    </p>

<pre><code>void someFunction() {
    int i = 0;
    i = i + 1;
}
</code></pre>

<p>main.cpp </p>

<pre><code>#include ""Arduino.h""
extern void someFunction();
void setup() {
}
void loop() {
    someFunction();
}
</code></pre>
",,54952967,91
43719441,2,43717639,2017-05-01T12:56:07.157,1,,669576,,2017-05-01T15:15:34.087,2017-05-01T15:15:34.087,1,,"<p>Using <code>exit()</code> with an Arduino is not standard. It basically disables all interrupts and enters an infinite loop. You could restructure your <code>loop()</code> like this to avoid it:</p>

<pre><code>void loop()
{
    // Still moving?
    if (moveCount &lt; moveSteps) {
        moveCount = moveCount + 1;

        // Move complete
        if (moveCount == moveSteps) 
        {
            digitalWrite(left1,LOW);
            digitalWrite(right1,LOW);
            Serial.println(moveCount);
        }
        else {
            digitalWrite(left2,HIGH);
            digitalWrite(right2,HIGH);
            //etc.....
        }
    }
}
</code></pre>

<p>Also, your loop delays 1200µs 8x. That's only 1200 × 8 = 9600 µs = 9.6 ms. If <code>moveSteps = 48</code> then the entire loop will only take 460.8 ms. The program is running once before you open the serial monitor then a second time after. What happens if you push the reset button after you've opened the Serial Monitor?</p>

<p>Have you considered using the Arduino's built in <a href=""https://www.arduino.cc/en/reference/stepper"" rel=""nofollow noreferrer"">Stepper Library</a>?</p>

<p>Lastly, in the future, consider posting questions like this at <a href=""https://arduino.stackexchange.com/"">[arduino.se]</a>.</p>
",,54983032,259
43789817,2,43789757,2017-05-04T18:00:45.723,2,,6622587,,2017-05-04T19:28:39.797,2017-05-04T19:28:39.797,4,,"<p>In the constructor of your class you are passing a pointer of the type Servo, so you must store that value in another pointer. To do this you must change:</p>

<p>*.h</p>

<pre><code>#ifndef SHUTTER_H
#define SHUTTER_H
#include ""Servo.h""

class Shutter {
  public:
    Shutter(Servo *servo);
    Servo *getServo() const;

    void shut();
  private:
    Servo *_servo;        
}

#endif
</code></pre>

<p>*.cpp</p>

<pre><code>Shutter::Shutter(Servo *servo) {
    _servo = servo;
}


Servo *Shutter::getServo() const
{
    return _servo;
}
</code></pre>

<p>Use:</p>

<pre><code>Servo servo;
Shutter shuter(&amp;servo)
</code></pre>
",,54995265,593
43800740,2,43800172,2017-05-05T09:02:09.937,7,,1322972,,2017-05-05T09:04:58.867,2017-05-05T09:04:58.867,3,,"<p>Not knowing the first thing about Arduino and BLE, I can only offer assistance with the actual math you're doing, which is wrong. </p>

<p>First some minor points:</p>

<pre><code>char data[] = ""lat:29.459612,lon:44.011856,speed:0.75,sats:9"";
char sendBuffer[20];

int len = sizeof(data); // HERE
int buflen= sizeof(sendBuffer); // HERE
</code></pre>

<p>Both of those should be <code>size_t</code> type. Apart from that, unless you're planning on sending the terminating nullchar character of your string, the actual data size of your send should be one-less than what you have now, which you can get via simple subtraction or via <code>strlen</code>.</p>

<p>Beyond that, this is completely wrong:</p>

<pre><code>for( i=buflen; i&lt;len+buflen; i=i+buflen){
    memcpy(sendBuffer,data,i);
    *data= *data+i;
    ble.print(""AT+BLEUARTTX="");
    ble.println(sendBuffer);
    delay(10000);
}
</code></pre>

<p>The string you're sending is 45 characters. This loop starts at 20. Therefore, the first iteration of your <code>memcpy</code> will do this:</p>

<pre><code>memcpy(sendBuffer, data, 20);
</code></pre>

<p>However, the <em>second</em> iteration will do this:</p>

<pre><code>memcpy(sendBuffer, data, 40);
</code></pre>

<p>The third:</p>

<pre><code>memcpy(sendBuffer, data, 60);
</code></pre>

<p>but by that time you're long since invoked undefined behavior.</p>

<p>Further, your attempt to increment your source buffer starting location using pointer math is wrong, and looks like you tried to ""fix"" the problem of modifying a non-lvalue. i.e. It looks like you first tried this:</p>

<pre><code>data = data + i;
</code></pre>

<p>and when that didn't work, you shoved <code>*</code> in front of each <code>data</code>, it compiled, so you ran with it. Believe me. C is <em>not</em> a language you want throw at a wall to see if something sticks. </p>

<p>Finally, I highly suspect your <code>println</code> member requires a nulchar terminated string, which you're not providing.</p>

<hr>

<p>The following code addresses all of the above. It just dumps to a console. You'll have to tailor it for your needs regarding sending it... wherever.</p>

<p><strong>Example</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char data[] = ""lat:29.459612,lon:44.011856,speed:0.75,sats:9"";
    char buffer[21] = {0}; // note space for terminator

    size_t len = strlen(data);      // doesn't count terminator
    size_t blen = sizeof(buffer)-1; // doesn't count terminator
    size_t i = 0;

    // put up a header row so you can see the output in columns
    for (i=0; i&lt;blen; ++i)
        printf(""%zu"", i%10);
    fputc('\n', stdout);

    // the actual loop that enumerates your buffer
    for (i=0; i&lt;len/blen; ++i)
    {
        memcpy(buffer, data + (i*blen), blen);
        puts(buffer);
    }

    // if there is anything left over
    if (len % blen)
        puts(data + (len - len % blen));

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>01234567890123456789
lat:29.459612,lon:44
.011856,speed:0.75,s
ats:9
</code></pre>

<p>Note we never overwrite the 21'st char in that send-buffer, which was initialized to 0's, so it is always terminated. Also we pick up the short frame (if there is one) directly from the source string as the last operation.</p>

<p>I leave integrating the actual send logic to you.</p>
",,55009675,134
43804470,2,43804222,2017-05-05T12:03:41.533,1,,1866300,,2017-05-05T12:06:42.430,2017-05-05T12:06:42.430,2,,"<p>in C++ when you want to override behavior in subclasses you must mark the function as virtual and declare them in the subclass again.</p>

<p>So you must do this:</p>

<pre><code>class portal
{
  public: virtual void drawContents();
};

void portal::drawContents()
{
//do stuff
}

class meter : public portal
{
public:
    virtual void drawContents() override; // virtual may be omitted
};

void meter::drawContents()
{
// override behavior
}
</code></pre>

<p>The keyword override after drawContents is a relatively new C++ feature. It might not be implemented by the arduino compiler. You can just omit it then.</p>
",,55012540,58
43813418,2,43813180,2017-05-05T20:38:01.720,1,,3220135,,2017-05-05T20:38:01.720,,1,,"<p>Have you tried simply creating multiple dht objects and polling them separately?</p>

<pre><code>#include ""DHT.h""

#define DHTPINA 2     // what digital pin the first one's connected to
#define DHTPINB 3     // what digital pin the second one's connected to

#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321

DHT dhtA(DHTPINA, DHTTYPE);
DHT dhtB(DHTPINA, DHTTYPE);

void setup() {
  Serial.begin(9600);
  Serial.println(""DHTxx test!"");

  dhtA.begin();
  dhtB.begin();
}

void loop() {
  delay(2000);
  float tA = dhtA.readTemperature();
  float tB = dhtB.readTemperature();

  Serial.print(""Temp A:"")
  Serial.print(tA)
  Serial.print(""Temp B:"")
  Serial.print(tB)
}
</code></pre>

<p>adapted from <a href=""https://github.com/adafruit/DHT-sensor-library/blob/master/examples/DHTtester/DHTtester.ino"" rel=""nofollow noreferrer"">this</a>.</p>
",,55012774,258
44094716,2,43821090,2017-05-21T08:23:09.600,0,,7973092,,2017-05-21T10:34:34.707,2017-05-21T10:34:34.707,0,,"<p>After research and reflection, I decided not to use the serial readings in my program, but only to send data to the Arduino and let it process. So, without further explanations, here's my (simple) code : </p>

<pre><code>//communication des infos avec l'arduino

char buffer [50];               //chaîne stockée dans buffer
int n;
n = sprintf (buffer, ""%d"", densityLevel);       // n est le nombre de carac
std::cout &lt;&lt; ""Density level : ""&lt;&lt; buffer&lt;&lt;endl;

string lvl = buffer;
string cmd = ""c_dL:"" + lvl;                      //concaténation
system((string (""./arduino-serial -b 9600 -p /dev/ttyACM0 -s ""+ cmd)).c_str());//envoi de l'info par arduino-serial (qui doit être dans le dossier du bin useTracker)
</code></pre>

<p>So I tried it, and verified what message the arduino received, and it's working. Since my project's ""presentation"" deadline has been reached, I had to do with what I had ^^ Too bad for the reading, but I managed to do without it. I hope I'll have more time to do research for my next project... </p>
",,55014300,51
43824307,2,43824128,2017-05-06T19:00:50.663,0,,16007,,2017-05-06T20:13:22.983,2017-05-06T20:13:22.983,1,,"<p>Just try it:</p>

<pre><code>#include &lt;stdio.h&gt;
#define HIGH 0
int main ( void )
{

    unsigned char i;
    unsigned char PORTD;
    unsigned char val;

    PORTD=0;

    for(val=3;val;val&lt;&lt;=1)
    {
        printf(""0x%02X\n"",val);
        for(i=0;i&lt;8;i++)
        {
            PORTD |= !!(val &amp; (HIGH &lt;&lt; i));
            printf(""PORTD 0x%02X\n"",PORTD);
        }
    }
    return(0);
}        
</code></pre>

<p>I dont know what your definition of HIGH is but since they are walking it 8 time across a byte i assume it is one bit, it is perhaps allowing for positive or negative logic on the port, so could be a 0 or 1 I am thinking.</p>

<p>I get all 0x01 if HIGH is 1 and all 0x00 if HIGH is 0.  so it doesnt seem to be doing anyting.  When you have &amp;&amp; for example that is a boolean expression not a bitwise logical, so perhaps this is a typo?</p>

<p>the <code>val&amp;(HIGH&lt;&lt;i)</code> though is pretty simple, again you should have posted what HIGH was defined as, lets assume it is a 1 since that makes the most sense relative to the rest of the code.  There is a loop i that goes from 0 to 7.  so that means that you are anding (bitwise) with <code>1&lt;&lt;0</code> and then <code>1&lt;&lt;1</code> and then <code>1&lt;&lt;2</code> and so on.  <code>1&lt;&lt;0</code> is just 1 right?  so <code>val&amp;(1&lt;&lt;0)</code> is the same as val&amp;0x01.  <code>1&lt;&lt;1 = 0x02</code> so val&amp;0x02.  this code is one bit at a time isolating the individual bits in val.  you understand that if for example val is 0x07 then 0x07&amp;0x02 = 0x02?  you line each bit up 0x07 = 0b00000111, 0x02 = 0b00000010</p>

<pre><code> 00000111
&amp;00000010
=========
 00000010
</code></pre>

<p>you look at this vertically isolate one column at a time and use the AND truth table which basically says the result is 0 unless both operands are a 1, there is one column where both operands are a 1 so the result for that column is a 1, the rest of the columns one or the other operand or both is a zero so the result is zero for that column.</p>

<pre><code> 00000111
&amp;00000100
=========
 00000100

 00000111
&amp;000010000
=========
 00000000
</code></pre>

<p>Increment i two more times and evaluate against a val of 0x07 and you see what is happening at least with the <code>val&amp;(HIGH&lt;&lt;i)</code> assuming that HIGH is a 1, if HIGH is a 0 then you will always get zeros come out of this code.</p>

<p>If you are wanting to and with a walking one why dont you just do val&amp;HIGH, so again this doesnt make sense unless that peripheral or what is on the other end of that port desires this one bit at a time thing.</p>

<p>The double bang (!!) looks like a logical operation to me and has no business here IMO.</p>

<p>A single bang is a logical operation</p>

<pre><code>#include &lt;stdio.h&gt;

#define HIGH 1

int main ( void )
{

    unsigned char i;
    unsigned char PORTD;
    unsigned char val;

    PORTD=0;

    val=3;
    {
        printf(""0x%02X\n"",val);
        for(i=0;i&lt;8;i++)
        {
            PORTD |= !(val &amp; (HIGH &lt;&lt; i));
            printf(""PORTD 0x%02X\n"",PORTD);
        }
    }
    return(0);
}
</code></pre>

<p>The hope here would be that we know the compiler will generate 0x00 for a false, but what does it generate for a true?  0x01, 0xFF, the C language probably has a definition.  So the above code is genrating a bitstream based on our value</p>

<pre><code>PORTD 0x00
PORTD 0x00
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
</code></pre>

<p>In the lsbit position, the the loop tickles a clock.</p>

<p>My personal preference would not be to play games with the C language spec, but be explicit to what you want to do:</p>

<pre><code>#include &lt;stdio.h&gt;
#define HIGH 1
int main ( void )
{

    unsigned char i;
    unsigned char PORTD;
    unsigned char val;

    PORTD=0;

    val=3;
    {
        printf(""0x%02X\n"",val);
        for(i=0;i&lt;8;i++)
        {
            PORTD |= (~(val&gt;&gt;i))&amp;1;
            printf(""PORTD 0x%02X\n"",PORTD);
        }
    }
    return(0);
}        

PORTD 0x00
PORTD 0x00
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
PORTD 0x01
</code></pre>

<p>using all bitwise operations, no boolean true/false operations.</p>

<p>Wondering if they were trying to do two boolean nots in a row to shift the not-zero bit to the zero bit position or something...instead for lsbit first or 7-i for msbit first.</p>

<pre><code>#include &lt;stdio.h&gt;
#define HIGH 1
int main ( void )
{

    unsigned char i;
    unsigned char PORTD;
    unsigned char val;

    PORTD=0;

    val=3;
    {
        printf(""0x%02X\n"",val);
        for(i=0;i&lt;8;i++)
        {
            PORTD |= (val&gt;&gt;i)&amp;1;
            printf(""PORTD 0x%02X\n"",PORTD);
        }
    }
    return(0);
}        
</code></pre>
",,55031186,52
43847969,2,43832180,2017-05-08T12:41:42.903,1,,7721966,,2017-05-08T12:41:42.903,,0,,"<p>I assume, that you are trying to turn on the LED for 100ms, when the string variable <code>readString</code> contains the defined literal string, and turning it of after it.</p>

<p>I think you are missing an <code>else</code> in your code, because without it the <code>digitalWrite(22, LOW)</code> to turn off the LED will be directly followed by the <code>digitalWrite(22, HIGH)</code>, which will turn the LED on again. And with executing <code>previousMillis1 = millis()</code> you let the LED blink continuously, not only once.
Try something like this:</p>

<pre class=""lang-cpp prettyprint-override""><code>unsigned long interval1=100;    // the time we need to wait
unsigned long previousMillis1=0; // millis() returns an unsigned long.
boolean led_blinking = false;

void loop(){
    if (readString.indexOf(""?22"") &gt;0 &amp;&amp; !led_blinking){
        led_blinking = true;
        previousMillis1 = millis();
    }
    if (led_blinking &amp;&amp; millis() - previousMillis1 &lt;= interval1) {
        digitalWrite(22, HIGH);
    } else {
        digitalWrite(22, LOW);
        led_blinking = false;
        readString = """"; /* resetting the string variable to prevent
                            further blinking, until the variable is set
                            by another part of the code */
    }

    // Do other task of the main loop
}
</code></pre>

<p>Note that, depending on the time it takes to execute the rest of your main loop, the timing here is not exact. But if you only want to have a visual sign of your condition, this will be sufficient.
If you don't want to reset the string variable, you can use another boolean variable, which you can set at the time, when the string variable is set. But don't forget resetting it instead of the string variable.</p>
",,55036226,75
43888284,2,43861435,2017-05-10T09:18:06.190,-1,,5388805,,2017-05-13T12:08:58.633,2017-05-13T12:08:58.633,11,,"<p>Check if the RCC and or the MODER registers are applied correctly.<br>
Try to add some delay after setting the RCC register.</p>

<p>Maybe your compiler optimizes something and the following condition is not met:</p>

<blockquote>
  <p>When the peripheral clock is not active, the peripheral registers read or write accesses are not supported.<br>
  The enable bit has a synchronization mechanism to create a glitch free clock for the peripheral.<br>
  After the enable bit is set, there is a 2 clock cycles delay before the clock be active.<br>
  <strong>Caution:</strong><br>
  Just after enabling the clock for a peripheral, <em>software must wait for a delay before accessing the peripheral registers</em>.</p>
</blockquote>

<p><strong>Edit:</strong></p>

<p><em>Note: The following is a solution approach and appeared to be wrong.
See comments for details.</em></p>

<p>I'm just compiled the above <em>init_adc_gpio</em> function and my compiler generates the following assembler instructions (-O3):</p>

<pre><code>  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOCEN;        // Enable clock for GPIOC
0x080004d0  ldr r3, [pc, 60]    ; (0x8000510 &lt;init_adc_gpio+64&gt;) 
  GPIOE-&gt;MODER &amp;= (uint32_t)0x000FFFFFU;  // Pins 10-15 of E -&gt; input (6 least significant bits of ADC data)
0x080004d2  ldr r0, [pc, 64]    ; (0x8000514 &lt;init_adc_gpio+68&gt;) 
0x080004d4  ldr r2, [r3, 76]    ; 0x4c 
  GPIOH-&gt;MODER &amp;= (uint32_t)0xFFFFFFFCU;  // Pin 0 of H -&gt; input (ADC data ready flag)
0x080004d6  ldr r1, [pc, 64]    ; (0x8000518 &lt;init_adc_gpio+72&gt;) 
0x080004d8  orr.w r2, r2, 4 
  void init_adc_gpio(void) {
0x080004dc  push {r4} 
0x080004de  str r2, [r3, 76]    ; 0x4c 
  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOEEN;        // GPIOE
0x080004e0  ldr r2, [r3, 76]    ; 0x4c 
  GPIOC-&gt;MODER &amp;= (uint32_t)0x0FFFFFFFU;  // Pins 14-15 of C -&gt; input (2 most significant bits of ADC data)
0x080004e2  ldr r4, [pc, 56]    ; (0x800051c &lt;init_adc_gpio+76&gt;) 
0x080004e4  orr.w r2, r2, 16 
0x080004e8  str r2, [r3, 76]    ; 0x4c 
  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOHEN;        // GPIOH
0x080004ea  ldr r2, [r3, 76]    ; 0x4c 
0x080004ec  orr.w r2, r2, 128   ; 0x80 
0x080004f0  str r2, [r3, 76]    ; 0x4c 
0x080004f2  ldr r3, [r4, 0] 
0x080004f4  bic.w r3, r3, 4026531840    ; 0xf0000000 
0x080004f8  str r3, [r4, 0] 
0x080004fa  ldr r3, [r0, 0] 
  }
0x080004fc  ldr.w r4, [sp], 4 
0x08000500  ubfx r3, r3, 0, 20 
0x08000504  str r3, [r0, 0] 
0x08000506  ldr r3, [r1, 0] 
0x08000508  bic.w r3, r3, 3 
0x0800050c  str r3, [r1, 0] 
0x0800050e  bx  lr
0x08000510  .word   0x40021000 ; [RCC]
0x08000514  .word   0x48001000 ; [GPIOE]
0x08000518  .word   0x48001c00 ; [GPIOH]
0x0800051c  .word   0x48000800 ; [GPIOC]
</code></pre>

<p>As you can see the compiler reorder the instructions. Therefore the registers are not set properly.
<em>Note: Actually the sequence is right. The way how the disassembler show it can mislead someone.</em></p>

<p>To solve this problem you can use a <a href=""http://preshing.com/20120625/memory-ordering-at-compile-time/"" rel=""nofollow noreferrer"">explicit compiler barrier</a> wich prevents the compiler to reorder the commands:</p>

<pre><code>void init_adc_gpio(void) {
  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOCEN;     // Enable clock for GPIOC
  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOEEN;    // GPIOE
  RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOHEN;    // GPIOH
  asm("""" ::: ""memory""); // prevent instruction reordering
  GPIOC-&gt;MODER &amp;= (uint32_t)0x0FFFFFFFU;  // Pins 14-15 of C -&gt; input (2 most significant bits of ADC data)
  GPIOE-&gt;MODER &amp;= (uint32_t)0x000FFFFFU;  // Pins 10-15 of E -&gt; input (6 least significant bits of ADC data)
  GPIOH-&gt;MODER &amp;= (uint32_t)0xFFFFFFFCU;  // Pin 0 of H -&gt; input (ADC data ready flag)
}
</code></pre>

<p>A simple nop instructions before setting the MODER registers should do it also.</p>

<p><em>Note: The compiler barrier leads to a slightly different assembler code. But both still correct.</em></p>
",,55046212,887
57035594,2,43870751,2019-07-15T08:04:36.520,0,,4292371,,2019-07-15T08:11:53.597,2019-07-15T08:11:53.597,0,,"<p>I spent weeks on controlling two servo (SG90) using WiringPi and programming in C, there're three things that I recommend.</p>

<p>1.Using <code>BCM GPIO</code> instead of <code>WiringPi Pin</code> because controlling more than one servo, you might need more than one pin such like 1(<code>WiringPi Pin</code>)/18(<code>BCM GPIO</code>) for another servo, For RPi3 B+ version, it give access to two channels for hardware PWM. Channel 0 on gpios 12/18 and channel 1 on gpios 13/19, it's easy and no need to worry about pin mapping exists if you adpopt <code>BCM GPIO</code>.</p>

<p>2.Better make sure there is only one program access PWM. pins at one time. Based on my experience, if you find that using command like ""<code>gpio -g pwm 18 25</code>"" is workable but otherwise using code like ""<code>pwmWrite(18, 25)</code>"" doesn's get any servo responds, maybe try ""<code>ps -A</code>"" to make sure if any other program is racing the access of your servo.</p>

<p>3.The last and the hardest one for me, when I execute <code>pwmWrite(18, 25)</code>"" on <code>PWM. pin 18</code> triggers the same instruction onto <code>PWM. pin 12</code>, which means <code>pwmWrite(18, 25)</code> triggers <code>pwmWrite(12, 25)</code>. To solve this situation, changing the modes of other pins of servos which should freeze without any moving to be input mode and set all of them to be pull-down.</p>

<p>For details, codes for controlling two servos with PWM. Channel 0 on gpios 12/18.</p>

<p><strong>Basic function:</strong></p>

<pre><code>void servo_init() {
    servo_open(0);
    delay(DELAY_SERVO);
    servo_open(1);}
</code></pre>

<p>and</p>

<pre><code>void servo_open(int servo) {
switch (servo) {
    case 0:
        pullUpDnControl(SERVO_0, PUD_OFF);
        pinMode(SERVO_0, PWM_OUTPUT);
        pwmSetMode(PWM_MODE_MS);
        pwmSetClock(PWM_CHANNEL_0_CLOCK);
        pwmSetRange(PWM_CHANNEL_0_RANGE);
        break;
    case 1:
        pullUpDnControl(SERVO_1, PUD_OFF);
        pinMode(SERVO_1, PWM_OUTPUT);
        pwmSetMode(PWM_MODE_MS);
        pwmSetClock(PWM_CHANNEL_0_CLOCK);
        pwmSetRange(PWM_CHANNEL_0_RANGE);
        break;  
    default:

        break;
}}
</code></pre>

<p>and </p>

<pre><code>void servo_close(int servo) {

switch (servo) {
    case 0:
        pinMode(SERVO_0, INPUT);
        pullUpDnControl(SERVO_0, PUD_DOWN);
        break;
    case 1:
        pinMode(SERVO_1, INPUT);
        pullUpDnControl(SERVO_1, PUD_DOWN);
        break;  
    default:

        break;
}}
</code></pre>

<p>and</p>

<pre><code>void servo(int servo, int angle) {
switch (servo) {
    case 0:
        servo = SERVO_0;
        break;
    case 1:
        servo = SERVO_1;
        break;  
    default:
        servo = -1;
        break;
}
switch (angle) {
    case 90:
        value = 25;
        break;
    case -90:
        value = 10;
        break;
    case 0:
        value = 14;
        break;  
    default:
        break;
}
if (servo == -1) return;
pwmWrite(servo, value);}
</code></pre>

<p><strong>Rotate one servo connected to 18 (BCM GPIO)</strong></p>

<p>Close others before you are going to rotate one</p>

<pre><code>servo_close(1);
delay(DELAY_SERVO);
</code></pre>

<p>Rotate</p>

<pre><code>servo(0, 90);
delay(3*DELAY_MAGIC);
servo(0, 0);
</code></pre>

<p>Reset all of servos to their init angles for fixing servo occasional jitter</p>

<pre><code>delay(DELAY_SERVO);
servo_init();
</code></pre>

<p>Check more source code and informations about servo and sensor on Raspberry: <a href=""https://github.com/MouChiaHung/RaspberryPi"" rel=""nofollow noreferrer"">MY GitHub</a></p>
",,55069755,1330
43883159,2,43882816,2017-05-10T03:32:02.517,0,,6947289,,2017-05-10T16:46:32.053,2017-05-10T16:46:32.053,1,,"<p>If you wanted to return the result without having to allocate data every time you could use something like this.</p>

<p>Note: This only works for values -99 to 999</p>

<pre><code>typedef union
{
    char str[4];
    int i;
} CharInt;

CharInt hour()
{
    CharInt ci = {0};
    sprintf(ci.str,""%02d"", hour(now()));
    return ci;
}

int main()
{
    printf(""%s"", hour().str);
}
</code></pre>
",,55080058,58
43889248,2,43882816,2017-05-10T10:02:29.293,0,,7699452,,2017-05-10T10:02:29.293,,1,,"<p>As everyone mentioned your question is vague.But from your title and content I think I might help you.</p>

<p>I think you need to print a <code>0</code> infront of every digit (hour) that is less than <code>10</code>. that is if hour is 1 then print <code>01</code> etc.</p>

<p>If that's what you need then you made a few mistakes in your sketch.First of all you are returning a <code>char</code> array from the function not <code>int</code>. Then <code>hour(now())</code> is required instead of <code>hour(now)</code>.</p>

<pre><code>char * hour() { // the hour now 
  static char s[25]; //might be 5 is enough and more
  sprintf(s,""%02d"", hour(now()));
  return s;
}
</code></pre>

<p>PS : As the return type is char array if you were storing it to an integer variable at caller , as if say <code>int hr = hour();</code>,it wont be possible now.So you need to print it directly as <code>Serial.println (hour ());</code> </p>
",,55094137,234
43911009,2,43905188,2017-05-11T09:03:28.517,0,,7721966,,2017-05-11T09:03:28.517,,0,,"<p>Normal buttons, like they are used in most project, are doing nothing else but pressing two electrical contacts together, when it is pressed. But - because it's a mechanical action with limited velocity - the level on the pin doesn't simply rise from LOW to HIGH (or vice versa). Instead it changes it's level in the moment the button gets pressed a few times, until the final level is reached. This variation is to fast for a human to see (for example with an attached LED), but slow enough for a microcontroller like the arduino taking notice. So often you have to make sure, that it's really only one button press, even if the level changes a few times in a row. Mostly it is sufficient to add a small timeout, where the button presses aren't recognized by your code (for example 50 ms), or checking a second time for the state of the button after this period. You can check the corresponding <a href=""https://www.arduino.cc/en/Tutorial/Debounce"" rel=""nofollow noreferrer"">Arduino page</a> for an official example of debouncing.</p>

<p>In your code you are only checking directly the state of the button, which is why it turns off, when you release the button. I would try something like this:</p>

<pre><code>boolean program_state = false;
unsigned long debounce_time = 50;
unsigned long debounce_time_stamp=0;

void loop(){
    // ultasound measuring code
    if(digitalRead(buttonPin) &amp;&amp; debounce_time_stamp - millis() &gt; debounce_time){
        program_state=!program_state;
        debounce_time_stamp = millis();
    }

    if(program_state){
        // distance checking and servo code
    }
}
</code></pre>

<p>This check - when the button is pressed - if enough time has been bygone since the last recognized press (the amount of time can be adjusted with the variable <code>debounce_time</code>). When a valid press is recognized, the <code>program_state</code> variable is toggled to change the state between the two modes (On and Off).
Notice that with this the code is unresponsive for the time the servo needs to finish one sequence. If you want to have code, that is more responsive, you should consider using the button as an external interrupt (for this look at the examples on the correspondig Arduino page).</p>
",,55125784,220
43922549,2,43914915,2017-05-11T17:57:40.690,1,,1850429,,2017-05-11T17:57:40.690,2017-05-23T12:02:42.857,3,,"<p>I've had this problem too, it took a while before I noticed it. It is because you clear the IRQ flag very close the interrupt return. Creating a <a href=""https://stackoverflow.com/a/13029263/1850429"">tail-chain</a> interrupt with itself.</p>

<pre><code>void EXTI9_5_IRQHandler(void)
{
    if(__HAL_GPIO_EXTI_GET_IT(TOR2_IN_uC_Pin) != RESET)
    {
        HAL_GPIO_EXTI_IRQHandler(TOR2_IN_uC_Pin);
        __HAL_GPIO_EXTI_CLEAR_IT(TOR2_IN_uC_Pin);
    }
    __DMB(); // add this
}
</code></pre>

<p>You have to wait for the bus to finish the clear action. The <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489c/CIHGHHIE.html"" rel=""nofollow noreferrer"">DMB instruction</a> helps with this.</p>

<blockquote>
  <p>Data Memory Barrier acts as a memory barrier. It ensures that all explicit memory accesses that appear in program order before the DMB instruction are observed before any explicit memory accesses that appear in program order after the DMB instruction. It does not affect the ordering of any other instructions executing on the processor.</p>
</blockquote>
",,55165811,71
43949002,2,43934882,2017-05-13T03:50:38.097,0,,2685897,,2017-05-13T11:55:48.987,2017-05-13T11:55:48.987,2,,"<p>I just checked the microPython's UART (<a href=""http://docs.micropython.org/en/latest/wipy/library/machine.UART.html"" rel=""nofollow noreferrer"">http://docs.micropython.org/en/latest/wipy/library/machine.UART.html</a>) and Arduino's Serial (<a href=""https://www.arduino.cc/en/Reference/Serial"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Reference/Serial</a>
), and it seems you're missing one initialization line for UART. UART document states the default baud rate it sets is 9600, and you expect a 115200 on serial receiver. I believe setting the baud rate different on each side will have undefined behavior.</p>

<p>In your python code, could you try uart.init(115200) after uart = UART(0) call (and the default values for the rest seems same as the Serial's expectations on receiver)?</p>

<p>Also, Serial document says that if it can't find the char you define in the readStringUntil(), then it'll try until it times out. So I guess your function call times-out because it won't find an endline ('\n') in the stream, because you didn't inject any.</p>

<p>In addition, although the help documents of the functionality you're using don't state such a thing, if you really always get the number of characters as the first char at the receiver, it might be worthwhile to try using that to your advantage. I wonder if you can try to get that number first, then read that many chars afterwards (at the Arduino receiver site). Here's some code I hope may help (I'm afraid I didn't try using it):</p>

<pre><code>#include &lt;string.h&gt;
char buffer[256];  // buffer to use while reading the Serial
memset(buffer, (char)0, 256);  // reset the buffer area to all zeros

void loop()
{
   if (Serial.available() &gt; 0){ 
    int count = Serial.read();  // the first byte that shows the num of chars to read after, assuming that this is a 'byte' - which means we can have max 256 chars in the stream
    Serial.readBytes(buffer, count);
    msg = String(buffer);
   }
}
</code></pre>
",,55190804,343
43939751,2,43939631,2017-05-12T14:05:40.690,2,,4253229,,2017-05-12T14:18:20.927,2017-05-12T14:18:20.927,3,,"<p>Just ""shift"" bits into the appropriate positions in the number:</p>

<pre><code>unsigned int number = 0;
for (int i=0; i&lt;5; i++)
{
    number |= a[i] &lt;&lt; i;
} 
</code></pre>

<p>This will work in case <code>digitalRead</code> is returning <code>0</code> or <code>1</code> only. In case it returns <code>0</code> or a <code>non-zero</code> values we will need to check it against zero instead:</p>

<pre><code>unsigned int number = 0;
for (int i=0; i&lt;5; i++)
{
    number |= (a[i] != 0) &lt;&lt; i;  //  (a[i] != 0) will have a value of `1` for any non-zero `a[i]`
} 
</code></pre>

<p>or even more idiomatic trick:</p>

<pre><code>number |= !!a[i] &lt;&lt; i;  
</code></pre>

<p>This is a double logical negation. The first one will turn any non-zero into <code>0</code>, the second will turn the <code>0</code> into <code>1</code>.</p>
",,55201313,1186
43940662,2,43939860,2017-05-12T14:51:25.133,1,,5636775,,2017-05-12T15:00:10.120,2017-05-12T15:00:10.120,2,,"<p>The data you receive in the callback should not be truncated. You can check this for yourself by altering the code as follows:</p>

<pre><code>function receiver(sck, data)
   print(""Len: "" .. #data)
   print(data)
   sck:close()
 end
</code></pre>

<p>You will observe, that, while the data is indeed only printed up to the first zero byte (by the <code>print()</code>-function), the whole data is present in the LUA-String <code>data</code> and you can process it properly with 8-bit-safe (and zerobyte-safe) methods.</p>

<p>While it should be easy to modify the <code>print()</code>-function to also be zerobyte-safe, I do not consider this as a bug, since the print function is meant for texts. If you want to write binary data to serial, use <code>uart.write()</code>, i.e.</p>

<pre><code>uart.write(0, data)
</code></pre>
",,55201623,85
44007994,2,43963019,2017-05-16T17:30:35.790,4,,4328846,,2017-05-16T17:49:21.990,2017-05-16T17:49:21.990,0,,"<p>Create a struct with an string, pointer to a function and pointers to the next and previous struct </p>

<p>the string is the text that will be displayed for the option, the function is the function called if the user click the item, and the pointers give you the previous and next itens if the user go up or down</p>

<p>example:</p>

<p>in the header file:</p>

<pre><code>const struct item
{
    const char name[16];                
    void (*func)(void);                     // Pointer to the item function
    const struct item * prev;           // Pointer to the previous
    const struct item * next;           // Pointer to the next
};
</code></pre>

<p>in the c file:</p>

<pre><code>const struct item item_ON = 
{
    "" 1 On"",
    fcn_item_turn_on,
    &amp;item_OFF,
    &amp;item_PARTIAL 
};

const struct item item_PARTIAL = 
{
    "" 2 Partial"",
    fcn_item_partial,
    &amp;item_ON,
    &amp;item_OFF 
};

const struct item item_OFF =
{
    "" 3 Off"",
    fcn_item_turn_off,
    &amp;item_PARTIAL,
    &amp;item_ON
}; 
</code></pre>

<p>then:</p>

<pre><code>void menu_show() 
{
    putrsXLCD((rom char *)(*ptr_item).name); // or the LCD print function in your code
}

void menu_inc() {
    ptr_item = (*ptr_item).prev;
    menu_show();
}

void menu_dec() {
    ptr_item = (*ptr_item).next;
    menu_show();
}

void menu_fwd() {
    (*ptr_item).func(); // execute item function
}
</code></pre>

<p>don't forget to initialize the ptr_item with the first item:</p>

<pre><code>ptr_item = &amp;item_ON;
</code></pre>
",,55214290,84
44078453,2,43963019,2017-05-19T20:23:15.857,1,,4343520,,2017-05-19T20:23:15.857,,0,,"<p>From the looks of it you are trying to create a hierarchical menu system. (As the JSON Object is not an array, but more akin to a tree.)</p>

<p>C++ would probably be easier to implement in because of the STL, I'm not sure on your experience but I'll give a general layout. Design-wise anyways.</p>

<pre><code>#include &lt;functional&gt;
#include &lt;vector&gt;

class MenuTreeNode {
    std::string title;
    std::vector&lt;MenuTreeNode&gt; children;
    std::function&lt;void(int)&gt; action;
public:
    MenuTreeNode(const std::string&amp; title, std::function&lt;void(int)&gt; action = {});
    // ^ Construct the node, with the action item being optional.
    // {} is just an empty function block.

    /*
    ** You can construct with a lambda function, which are pretty useful.
    */

    void addChild(MenuTreeNode&amp;&amp; childNode); // append a node to the child array.
    void displayStuff() {

        // However you display stuff to Arduino...

        for (auto&amp; child : this-&gt;children) {
            child.displayStuff();
        }
        this-&gt;action(); // Call the action.
    }
};
</code></pre>

<p>I hope that gives you some guidance. The older answer in C is good however doesn't allow for child items that you have in your JSON struct. This might be easier to work with IMO.</p>
",,55265279,102
44484766,2,43983535,2017-06-11T14:08:43.020,2,,8143718,,2017-06-11T14:08:43.020,,1,,"<p>You need a <strong>HttpClient</strong> to communicate with a <strong>web server</strong>.</p>

<p>Good way to start is to use the HttpClient sample -> ReuseConnection.</p>

<p>This will allow you to make more <strong>requests than one</strong>.</p>

<p>You can see in Serial Monitor in Arduino IDE to see the response from the request.</p>

<p>Sample code:</p>

<p><strong>Note</strong>: replace "" http://:/someroute "" with the desired http page you want to get.</p>

<pre><code>#include &lt;Arduino.h&gt;

#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266WiFiMulti.h&gt;

#include &lt;ESP8266HTTPClient.h&gt;

#define USE_SERIAL Serial

ESP8266WiFiMulti WiFiMulti;

HTTPClient http;

void setup() {

    USE_SERIAL.begin(115200);
   // USE_SERIAL.setDebugOutput(true);

    USE_SERIAL.println();
    USE_SERIAL.println();
    USE_SERIAL.println();

    for(uint8_t t = 4; t &gt; 0; t--) {
        USE_SERIAL.printf(""[SETUP] WAIT %d...\n"", t);
        USE_SERIAL.flush();
        delay(1000);
    }

    WiFiMulti.addAP(""SSID"", ""PASSWORD"");

    // allow reuse (if server supports it)
    http.setReuse(true);
}

void loop() {
    // wait for WiFi connection
    if((WiFiMulti.run() == WL_CONNECTED)) {

        http.begin(""http://&lt;IP&gt;:&lt;Port&gt;/someroute"");

        int httpCode = http.GET();
        if(httpCode &gt; 0) {
            USE_SERIAL.printf(""[HTTP] GET... code: %d\n"", httpCode);

            // file found at server
            if(httpCode == HTTP_CODE_OK) {
                String payload = http.getString();
                USE_SERIAL.println(payload);
            }
        } else {
            USE_SERIAL.printf(""[HTTP] GET... failed, error: %s\n"", http.errorToString(httpCode).c_str());
        }

        http.end();
    }

    delay(3000);
}
</code></pre>
",,55271832,108
44005448,2,44003765,2017-05-16T15:19:06.583,1,,656243,,2017-05-16T15:19:06.583,,0,,"<p>Try enabling flow control.</p>

<p>On the python side, set <code>rtscts=1</code> in your ctor:</p>

<pre><code>ser = serial.Serial(
        port = '/dev/serial0',
        baudrate = 115200,
        parity = serial.PARITY_NONE,
        stopbits = serial.STOPBITS_ONE,
        bytesize = serial.EIGHTBITS,
        timeout = 10,
        rtscts = True
)
</code></pre>

<p>On the win c++ side, enable hardware flow control in the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx"" rel=""nofollow noreferrer"">DCB Struct</a>:</p>

<pre><code>DCB dcb;
SecureZeroMemory(&amp;dcb, sizeof(DCB));
dcb.DCBlength = sizeof(DCB);
fSuccess = GetCommState(dataFile, &amp;dcb)
dcb.fOutX = false;
dcb.fInX = false;
dcb.fOutxCtsFlow = true;
dcb.fOutxDsrFlow = true;
dcb.fDsrSensitivity = true;
dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
fSuccess = SetCommState(hCom, &amp;dcb);
</code></pre>
",,55325315,807
44015020,2,44004422,2017-05-17T03:27:55.230,1,,7203873,,2017-05-17T03:27:55.230,,3,,"<p>I think you must have forgotten to add <code>#include ""Arduino.h""</code> header file in the main code. Also, do note that Platform IO compiles cpp files not ino file.</p>

<p><strong>main.cpp</strong></p>

<pre><code>// Without Arduino.h this code will not compile
#include ""Arduino.h""
#include ""demo.h""

devConfig myConfig;

void setup() {
  strncpy(myConfig.defPass, ""somepass"", 16);
}

void loop() {

}
</code></pre>

<p><strong>demo.h</strong></p>

<pre><code>typedef struct {
        char idPrefix[8];
        char defPass[16];
        char targetSSID[32];
        char targetPass[64];
        uint8_t beepInRange;
        uint8_t beepOutofRange;
} devConfig;
</code></pre>
",,55396304,247
44012895,2,44004939,2017-05-16T22:55:26.313,1,,2150864,,2017-05-16T22:55:26.313,,1,,"<p>I think it has to do with PROGMEM is storing the variable in FLASH, instead of RAM. Read <a href=""https://www.arduino.cc/en/Reference/PROGMEM"" rel=""nofollow noreferrer"">this documentation on PROGMEM</a>, so when you don't use <em>pgm_read_word_near()</em> and dynamically accessing the FLASH-stored variable, there will be problem. But when you were using constants(literal):</p>

<pre><code>strcpy_P(str_buf, data.manufacturer[0]-&gt;info);
menuItems[0] = str_buf;
</code></pre>

<p>to access the variable it's fine.</p>

<p>And the problem can manifest itself due to the implementation of <em>strcpy_P()</em>.</p>

<p>So in that documentation they did this:</p>

<pre><code>const char* const string_table[] PROGMEM = {string_0, string_1, string_2, string_3, string_4, string_5};

char buffer[30];    // make sure this is large enough for the largest string it must hold

void loop()
{
  /* Using the string table in program memory requires the use of special functions to retrieve the data.
     The strcpy_P function copies a string from program space to a string in RAM (""buffer"").
     Make sure your receiving string in RAM  is large enough to hold whatever
     you are retrieving from program space. */


  for (int i = 0; i &lt; 6; i++)
  {
    strcpy_P(buffer, (char*)pgm_read_word(&amp;(string_table[i]))); // Necessary casts and dereferencing, just copy.
    Serial.println(buffer);
    delay( 500 );
  }
}
</code></pre>
",,55417238,556
44041218,2,44004939,2017-05-18T07:24:56.880,0,,8019844,,2017-06-19T07:57:21.170,2017-06-19T07:57:21.170,1,,"<p>Thanks to user14042 and Jeroen3 my brother and I found a solution which partly works; up to 8 <code>manufacturer_def</code> structures. The solution is based on, firstly, creating a pointer to the correct <code>manufacturer_def</code> structure using <code>pgm_read_ptr(&amp;data.manufacturer[i])</code>. And, secondly, the string is retrieved out of flash memory using <code>strcpy_P(str_buf, manufacturer_ptr-&gt;info)</code>.</p>

<p>The code:</p>

<pre><code>void mainMenu()
{
   unsigned int i = 0;

   unsigned int totalMenuItems = pgm_read_word(&amp;data.totalManufacturers);
   String menuItems[totalMenuItems];

   char str_buf[20];

   // Create array with items for menu
   for (i = 0; i &lt; totalMenuItems; i++)
   {
     manufacturer_def* manufacturer_ptr = pgm_read_ptr(&amp;data.manufacturer[i]);
     strcpy_P(str_buf, manufacturer_ptr-&gt;info);
     menuItems[i] = str_buf;
   }
 }
</code></pre>

<p>The sketch uploads without any warnings or errors when I am using 8 <code>manufacturer_def</code> structures:</p>

<pre><code>const data_def data PROGMEM =
{
  8,
  {
    &amp;manufacturer_1,
    &amp;manufacturer_2,
    &amp;manufacturer_3,
    &amp;manufacturer_4,
    &amp;manufacturer_5,
    &amp;manufacturer_6,
    &amp;manufacturer_7,
    &amp;manufacturer_8
  }
};
</code></pre>

<p>However, when I am using more than 8 <code>manufacturer_def</code> structures trouble starts. With 9 <code>manufacturer_def</code> structures the sketch uploads without warnings or errors but the Arduino does not boot correctly. With 10 <code>manufacturer_def</code> structures I get the following error:</p>

<pre><code>/tmp/ccovyDEX.s: Assembler messages:
/tmp/ccovyDEX.s:5799: Error: value of 70776 too large for field of 2 bytes at 78808
</code></pre>

<p>With 11 <code>manufacturering_def</code> structures I get the following error:</p>

<pre><code>/tmp/ccCa42WT.s: Assembler messages:
/tmp/ccCa42WT.s:6513: Error: value of 78640 too large for field of 2 bytes at 86672
/tmp/ccCa42WT.s:6514: Error: value of 70776 too large for field of 2 bytes at 86674
</code></pre>

<p>I understand that 2 bytes can hold a maximum value of 65535. But what value could be causing this?</p>
",,55452548,96
44626282,2,44004939,2017-06-19T09:02:22.103,0,,8019844,,2017-06-19T09:44:28.410,2017-06-19T09:44:28.410,0,,"<p><strong>Solution!</strong></p>

<p>Due to the size of the <code>data</code> structure some addresses exceed the maximum value of standard 2-bytes pointers can hold. Therefore, it is necessary to use the <code>_far</code> commands to address that part of <code>PROGMEM</code>, and thus 4-byte pointers. This is easily solved for the user-defined <code>PROGMEM</code> data. However, by having this much user-defined data in <code>PROGMEM</code>, some internal Arduino functionality is also pushed past the 64K mark, and those do not use 4-byte pointers. This issue arises from the default linker map, which places those functions after the user-defined PROGMEM data. A solution here is to move that data into another section of PROGMEM. See the topics below for more information and the pull request for a fix:</p>

<p><a href=""https://github.com/arduino/Arduino/issues/2226"" rel=""nofollow noreferrer"">https://github.com/arduino/Arduino/issues/2226</a></p>

<p><a href=""https://github.com/arduino/Arduino/pull/6317"" rel=""nofollow noreferrer"">https://github.com/arduino/Arduino/pull/6317</a></p>

<p>When the mentioned fix is applied my code is working with <code>data</code> structures bigger than 64k bytes. A caveat of storing <code>structs</code> in <code>PROGMEM</code> at >64k bytes is that one has to manually calculate addresses using offsets (i.e. to get the <code>ith</code> element of an array in <code>PROGMEM</code>, one would do <code>mystruct_ptr + offsetoff(mystruct, myarray) + i * sizeof(myarrayitem)</code>.</p>

<p>The code:</p>

<pre><code>void mainMenu()
{
   unsigned int i = 0;

   unsigned int totalMenuItems = data.totalManufacturers;
   String menuItems[totalMenuItems];

   char str_buf[20];

  // Create array with items for menu
  for (i = 0; i &lt; totalMenuItems; i++)
  {
    uint_farptr_t manufacturer_ptr = data.manufacturer[i];
    strcpy_PF(str_buf, manufacturer_ptr + offsetof(manufacturer_def, info));
    menuItems[i] = str_buf;
  }
 }
</code></pre>
",,53609809,497
44021912,2,44021219,2017-05-17T10:11:39.373,2,,5296568,,2017-05-17T10:11:39.373,,2,,"<p>You are using the Arduino-provided <code>String</code> class, but didn't include the <code>Arduino.h</code> header in your <code>test.h</code> header file. That causes it to not find the <code>String</code> class and compilation fails.</p>

<p>The following works:</p>

<p><code>main.cpp</code>:</p>

<pre><code>#include &lt;Arduino.h&gt;
#include &lt;test.hpp&gt;

void writeLog (char* message);
void writeLog (String message);

void setup() {
  Serial.begin(115200);
  Test t;
  t.setLogging(writeLog);
  writeLog(""Test message!"" + String("" .... ""));
  t.doSomething(""This is useful."");
  t.doSomething(""This as well.\n"");
  t.doSomething(""This is even more useful.\n"");
  bool b = true;

}

void loop() {
}

void writeLog (char* message) {
  Serial.print(""char function: "");
  Serial.print(message);
}

void writeLog (String message) {
  Serial.print(""String function: "");
  Serial.println(message);
}
</code></pre>

<p><code>test.hpp</code>:</p>

<pre><code>#ifndef TEST_h
#define TEST_h

#include &lt;Arduino.h&gt; //for ""String"" class

//Typdef for the log function. Takes a String, returns nothing
typedef void (*LogFunction)(String);

class Test
{
  public:
    Test();       // The constructor.
  //  void setLogging(void (*)(char*)); // Takes function setting where to log.
    void setLogging(LogFunction); //use the typedef here
    void doSomething(char*);
};

#endif
</code></pre>

<p><code>test.cpp</code>:</p>

<pre><code>#include &lt;test.hpp&gt;


LogFunction writeLog;

Test::Test () {
}

void Test::doSomething (char* s) {

  // Do something useful and log the result.
  writeLog(s);
}

//void Test::setLogging (void (*f)(char*) ) {
void Test::setLogging (LogFunction f) { //also use typedef here
  writeLog = f;
  return;
}
</code></pre>
",,53613064,407
44052164,2,44051517,2017-05-18T15:37:27.777,0,,3602072,,2017-05-19T17:23:01.900,2017-05-19T17:23:01.900,2,,"<p>First of all, you can extract pointer to a class method and call it:</p>

<pre><code>auto my_method_ptr = &amp;MyClass::my_method;
....
(myClassInstance-&gt;*my_method_ptr)(); // calling via class ptr
(myclassInstance.*my_method_ptr)(); // calling via class ref
</code></pre>

<p>This basically passes <code>myClassInstance</code> pointer to <code>MyClass::my_method</code> as an implicit argument, accessible via <code>this</code>.</p>

<p>Unfortunately, AVR interrupt controller can't call class method, as the hardware operate on simple pointers only and can't call that method with implicit argument. You'll need a wrapper function for this.</p>

<pre><code>MotorEncoderClass g_motor; // g_ for global

void my_isr() {
    g_motor.do_something();
}

int main() {
    // init g_motor with relevant data
    // install my_isr handler
    // enable interrupts
    // ... do rest of stuff
    return 0;
}
</code></pre>

<ol>
<li>Create your class instance as a global variable.</li>
<li>Create ordinary function that calls that method</li>
<li>Initialize your motor class with relevant data</li>
<li>Install <code>my_isr</code> as IRQ handler.</li>
<li>Press start to begin :)</li>
</ol>
",,53622380,339
44052207,2,44051517,2017-05-18T15:39:34.657,3,,1774667,,2017-05-18T18:30:46.503,2017-05-18T18:30:46.503,8,,"<pre><code>// type of an interrupt service routine pointer
using ISR = void(*)();

// a fake version of the environment we are working with
// for testing purposes
namespace fake_environment {
    enum bob{FALLING};

    ISR isrs[100] = {0};

    void attachInterrupt(int i, void(*f)(), bob) {
        isrs[i] = f;
    }

    void runInterrupt(int i) {
        isrs[i]();
    }
}

// type storing a pointer to member function
// as a compile-time constant
template&lt;class T, void(T::*m)()&gt;
struct pmf {};

// stores a pointer to a class instance
// and a member function.  Invokes it
// when called with operator().  Type erases
// stuff down to void pointers.
struct funcoid {
  using pfunc = void(*)(void*);
  pfunc pf = 0;
  void* pv = 0;
  void operator()()const { pf(pv); }
  template&lt;class T, void(T::*m)()&gt;
  funcoid(T* t, pmf&lt;T,m&gt;):
    pv(t)
  {
    // create a lambda, then decay it into a function pointer
    // this stateless lambda takes a void* which it casts to a T*
    // then invokes the member function m on it.
    pf = +[](void* pt) {
      (static_cast&lt;T*&gt;(pt)-&gt;*m)();
    };
  }
  funcoid()=default;
};

// a global array of interrupts, which have a this pointer
// and a member function pointer type erased:
namespace client {
  enum {interrupt_count = 20};
  std::array&lt;funcoid, interrupt_count&gt; interrupt_table = {{}};
  // with a bit of work, could replace this with a std::vector        
}

// some metaprogramming utility code
// this lets me iterate over a set of size_t at compile time
// without writing extra helper functions at point of use.
namespace utility {
  template&lt;std::size_t...Is&gt;
  auto index_over( std::index_sequence&lt;Is...&gt; ) {
    return [](auto&amp;&amp; f)-&gt;decltype(auto) {
      return f(std::integral_constant&lt;std::size_t, Is&gt;{}...);
    };
  }
  template&lt;std::size_t N&gt;
  auto index_upto( std::integral_constant&lt;std::size_t, N&gt; ={} ) {
    return index_over( std::make_index_sequence&lt;N&gt;{} );
  }
}

// builds an array of interrupt service routines
// that invoke the same-index interrupt_table above.
namespace client {
  // in g++, you'd write a helper function taking an `index_sequence`
  // and take the code out of that lambda and build the array there:
  std::array&lt;ISR, interrupt_count&gt; make_isrs() {
    // creates an array of ISRs that invoke the corresponding element in interrupt_table.
    // have to do it at compile time, because we are generating 20 different functions
    // each one ""knows"" its index, then storing pointers to them.
    // Could be done with a lot of copy-pasta or a macro
    return ::utility::index_upto&lt; interrupt_count &gt;()(
      [](auto...Is)-&gt;std::array&lt;ISR, interrupt_count&gt;{
        return {{ []{ interrupt_table[decltype(Is)::value](); }... }};
      }
    );
  }
  // isr is a table of `void(*)()`, suitable for use
  // by your interrupt API.  Each function pointer ""knows"" its
  // index, which it uses to invoke the appropraite `interrupt_table`
  // above.
  auto isr = make_isrs();
  // with a bit of work, could replace this with a std::vector        
}

// interrupt is the interrupt number
// index is the index in our private table (0 to 19 inclusive)
// t is the object we want to use
// mf is the member function we call
// kind is FALLING or RISING or the like
// index must be unique, that is your job.
template&lt;class T, void(T::*m)()&gt;
void add_interrupt( int interrupt, int index, T* t, pmf&lt;T, m&gt; mf, fake_environment::bob kind ) {
  client::interrupt_table[index] = {t, mf};
  fake_environment::attachInterrupt(interrupt,client::isr[index],kind);
}


class Encoder {
  public:
    Encoder():Encoder(1, 7) {};
    Encoder(int interrupt, int index);
    void ISR_function(void);
    // my choice for some state:
    std::string my_name;
};

Encoder::Encoder(int interrupt, int index) {
  add_interrupt( interrupt, index, this, pmf&lt;Encoder, &amp;Encoder::ISR_function&gt;{}, fake_environment::FALLING );
}

void Encoder::ISR_function() {
  // display state:
  std::cout &lt;&lt; my_name &lt;&lt; ""\n"";
}

int main() {
  Encoder e0;
  e0.my_name = ""Hello World"";
  fake_environment::runInterrupt(1);
  Encoder e1(0, 10);
  e1.my_name = ""Goodbye World"";
  fake_environment::runInterrupt(0);
}
</code></pre>

<p>Does not compile in g++ and uses C++14.</p>

<p>Does solve your problem.  g++ problem is in <code>make_isrs</code>, which can be replaced by verbose copy-paste initialization.  C++14 is from <code>index_upto</code> and <code>index_over</code>, which can similarly be reworked for C++11.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/f63ad75c3ccbef04"" rel=""nofollow noreferrer"">Live example</a>.</p>

<p>However, ISRs are supposed to be minmal; I suspect you should just record the message and handle it elsewhere instead of interacting with object state.</p>
",,53636279,715
44123706,2,44123055,2017-05-22T23:52:14.707,1,,16007,,2017-05-23T00:22:31.587,2017-05-23T00:22:31.587,0,,"<pre><code>kernel8.img

12345678
00000800
00080264
00000000
12345678

kernel8-32.img

12345678
00008320
00008224
200001DA
12345678

kernel7.img

12345678
00000700
00008224
200001DA
12345678

kernel.img

12345678
00000000
00008224
200001DA
12345678
</code></pre>

<p>when I wrote and posted this code this is what I got so if you name your file kernel.img then 0x8000 is your entry point the answer I gave in your other SO question is a complete raspberry pi starting point.  You can simply add your mailbox stuff, although if you are struggling with this I thing the mailbox and video are not where you should start IMO.</p>

<p>if you name the file kernel8.img then the entry point is 0x80000 change the linker script to match.</p>

<p>I have a serial port based bootloader you can use to save on the sd card dance, can get a long way with that then simply use the binary version of what you are creating to write to the flash once your application is working.</p>

<p>EDIT</p>

<p>Okay this is incredibly disgusting and by posting it here maybe that means you cant use it in your classwork...you should really do this right and not use inline assembly for your bootstrap...</p>

<p>so.c</p>

<pre><code>asm(
"".globl _start\n""
""_start:\n""
""mov sp,#0x8000\n""
""bl centry\n""
""b .\n""
);


unsigned int centry ( void )
{
    return(5);
}
</code></pre>

<p>build</p>

<pre><code>arm-none-eabi-gcc -O2 -c so.c -o so.o
arm-none-eabi-ld -Ttext=0x8000 so.o -o so.elf
arm-none-eabi-objdump -D so.elf &gt; so.list
arm-none-eabi-objcopy so.elf -O binary kernel.img
</code></pre>

<p>examine</p>

<pre><code>Disassembly of section .text:

00008000 &lt;_start&gt;:
    8000:   e3a0d902    mov sp, #32768  ; 0x8000
    8004:   eb000000    bl  800c &lt;centry&gt;
    8008:   eafffffe    b   8008 &lt;_start+0x8&gt;

0000800c &lt;centry&gt;:
    800c:   e3a00005    mov r0, #5
    8010:   e12fff1e    bx  lr
</code></pre>

<p>A complete raspberry pi C with bootstrap example that will work on any of the flavors of pi (so far as I know they might have changed the GPU bootloader in the last few months but assume the didnt).</p>
",,53676929,776
44183611,2,44183281,2017-05-25T14:55:20.723,2,,3807729,,2017-05-25T15:23:37.807,2017-05-25T15:23:37.807,5,,"<p>It seems like Arduino doesn't come with <code>std::string</code>. You can copy it to an allocated character array like this:</p>

<pre><code>uint8_t buffer[128] = {0};

uint8_t mux_id;

uint32_t len = wifi.recv(&amp;mux_id, buffer, sizeof(buffer), 100);
if (len &gt; 0) {

    char* s = new char[len + 1]; // one extra space for the null terminator
    strncpy(s, (char*)buffer, len);
    s[len] = '\0'; // Don't forget to terminate the string with null

    // use s here


    delete[] s; // Don't forget to delete[] it after
}
</code></pre>
",,53682029,93
44192409,2,44191981,2017-05-26T01:55:49.020,0,,,user1593881,2017-05-26T03:42:17.013,2017-05-26T03:42:17.013,0,,"<p>In Arduino you can use the <a href=""https://www.arduino.cc/en/Tutorial/StringSubstring"" rel=""nofollow noreferrer"">substring</a> function followed by a <a href=""https://www.arduino.cc/en/Reference/StringToFloat"" rel=""nofollow noreferrer"">toFloat</a> function:</p>

<pre><code>void setup() {
  // put your setup code here, to run once:
}

void loop() {
  String stringOne = ""[GET /weight/250/ HTTP/1.1 Host: 192.168.1.2:8080 Connection: Keep-Alive]"";
  String stringTwo = stringOne.substring(13, 16);
  float weight = stringTwo.toFloat();

  // do nothing while true:
  while (true);
}
</code></pre>
",,53691292,420
44227786,2,44223824,2017-05-28T13:22:37.333,0,,794749,,2017-05-28T13:22:37.333,,0,,"<p>The array is passed to the function by reference.<br>
If you modify the array in the function, the changes will persist after the function call.</p>

<pre><code>int arrays[2] = {0, 1};

void setup() {
    Serial.begin(9600);
    pinMode(2, INPUT);
}

void loop() {

    int buttonstate = digitalRead(2); //reads I/O pin 2
    if (buttonstate == HIGH) {          //if I/O pin 2 is HIGH do following

        function(arrays);      //calls function ""function""
        Serial.println(arrays[0]);        //prints out arrays[0]
        Serial.println(arrays[1]);        //prints out arrays[1]

    }
}

void function(int arrays[]) {   

    int holder = arrays[1];           //switches place the values on the array
    arrays[1] = arrays[0];
    arrays[0] = holder;

}
</code></pre>

<p>If you don't want to modify the existing array, you will need to pass another array.</p>

<pre><code>int arrays[2] = {0, 1};
int arrays2[3];

void setup() {
    Serial.begin(9600);
    pinMode(2, INPUT);
}

void loop() {

    int buttonstate = digitalRead(2); //reads I/O pin 2
    if (buttonstate == HIGH) {          //if I/O pin 2 is HIGH do following

        function(arrays, arrays2);      //calls function ""function""
        Serial.println(arrays2[0]);        //prints out arrays2[0]
        Serial.println(arrays2[1]);        //prints out arrays2[1]
        Serial.println(arrays2[2]);        //prints out arrays2[2]

    }
}

void function(int arrays[], int arrays_return[]) {   

    arrays_return[0] = arrays[1];
    arrays_return[1] = arrays[0];
    arrays_return[2] = arrays[0] + arrays[1];

}
</code></pre>

<p>You will need to make sure that the array have appropriate size, because there won't be any explicit error thrown if you write/read outside the array's range, but you may find some odd behavior that will be hard to debug.</p>
",,53693424,64
44238365,2,44223824,2017-05-29T08:55:18.420,1,,3899431,,2017-05-29T08:55:18.420,,0,,"<p>Well, your worst misconception is thinking that C allows you to pass a complete array as parameter or return value.</p>

<p>First of all, you cannot do an assignment like</p>

<pre><code>arrays[] = function(...);
</code></pre>

<p>This is incorrect, as there's no way to refer to the array as a whole.  You can return a <em>reference to an array</em>, something like:</p>

<pre><code>arrays = function(...);
</code></pre>

<p>always that your function returns a valid <strong>POINTER TO INTEGER</strong>, and always that you declare your <code>arrays</code> variable as <code>int *arrays;</code>, instead.  But this has another problem... a pointer doesn't allocate memory for the pointed to values.</p>

<p>The best solution is to use the array reference to pass it to the function, and then make the function to operate on the array proper.  Like in</p>

<pre><code>function(arrays);  /* you should have function exchanged the arrays values properly */
for (i = 0; i &lt; 2; i++) /* print arrays contents and check values have been exchanged */ 
    printf(""arrays[%d] == %d\n"", i, arrays[i]);
</code></pre>

<p>in this case, the <code>arrays()</code> function should have been implemented as</p>

<pre><code>void function(int arrays[])
{
    int temporary = arrays[0];
    arrays[0] = arrays[1];
    arrays[1] = temporary;
    /* no return as function is declared void */
}
</code></pre>

<p>Of course, you can return the reference to the original array, and this can be helpful in some expressions, but think always that <strong>you are dealing with the same array anycase</strong>.</p>

<pre><code>int *function(int *arrays) /* this parameter declaration is equivalent to the last one */
{
    int temporary = arrays[0];
    arrays[0] = arrays[1];
    arrays[1] = temporary;
    return arrays; /* reference to the first array element */
}
</code></pre>
",,53702425,142
44232202,2,44229409,2017-05-28T21:28:45.497,1,,5708620,,2017-05-28T21:28:45.497,,0,,"<blockquote>
  <p>Does motor.step complete and then the rest of the program resumes..</p>
</blockquote>

<p>Yes, <code>motor.step()</code> is <a href=""https://www.arduino.cc/en/Reference/StepperStep"" rel=""nofollow noreferrer"">a blocking function</a>:</p>

<blockquote>
  <p>This function is blocking; that is, it will wait until the motor has
  finished moving to pass control to the next line in your sketch.</p>
</blockquote>

<p>But you probably have to set the speed in <code>setup()</code>, for example <code>motor.setSpeed(30);</code>.</p>

<p>Looking at the <a href=""https://github.com/arduino/Arduino/tree/master/libraries/Stepper/src"" rel=""nofollow noreferrer"">code for stepper</a> it looks like <code>step_delay</code> stays undefined (or zero) until <code>setSpeed()</code> is called (i.e. it doesn't get a default value in the constructor..)</p>

<pre><code>unsigned long step_delay; // delay between steps, in ms, based on speed
</code></pre>

<p>This value only changes in <code>setSpeed()</code>:</p>

<pre><code>/*
 * Sets the speed in revs per minute
 */
void Stepper::setSpeed(long whatSpeed)
{
  this-&gt;step_delay = 60L * 1000L * 1000L / this-&gt;number_of_steps / whatSpeed;
}
</code></pre>
",,53719200,586
44244889,2,44234119,2017-05-29T14:27:02.430,0,,982161,,2017-05-29T14:27:02.430,,0,,"<p>Your code is incomplete, when you do:</p>

<pre><code>ros::Subscriber&lt;geometry_msgs::Twist&gt; sub(""/cmd_vel"", messageCb );
</code></pre>

<p>you are telling the ROS-Master the following:</p>

<p>please informe about the msgs onthe topic ""<strong>/cmd_vel</strong>"" and for that use the callback method: <strong><em>messageCb</em></strong> but you have no callback method in the code.... you are missing something like:</p>

<pre><code>void messageCb(const std_msgs::String::ConstPtr&amp; msg)
{
    Serial1.println(""The turtle said:"");
    Serial1.println(msg-&gt;data.c_str());
}
</code></pre>
",,53735968,302
44267259,2,44266860,2017-05-30T16:16:53.330,1,,955273,,2017-05-30T16:16:53.330,,0,,"<p>There are a few possible explanations for this.</p>

<p><strong>optional argument:</strong></p>

<p>One possible explanation is that <code>Setpoint</code> is optional, so you can pass <code>nullptr</code>.</p>

<p>In the code, if you passed a null pointer, no setpoint is used.</p>

<p>You have mentioned that <code>Setpoint</code> gets dereferenced in another function, so it's likely not optional.</p>

<p><strong>out-param:</strong></p>

<p>C doesn't have references, so out-params are typically passed as pointers. In order to make a change to a parameter which is visible to the caller of the function, you pass it as a pointer</p>

<pre><code>void setFoo(double* in)
{
    *in = 5;
}

double foo;
setFoo(&amp;foo); // pass the memory address of your variable
</code></pre>

<p>At this point <code>foo</code> has the value of 5.</p>

<p>In C++ you can use references, so if you wanted to have an out-param, but require the user provide a value, you would use <code>double&amp; Setpoint</code>.</p>

<p><strong>allow external changes to be visible:</strong></p>

<p>Probably the most likely explanation is to allow you to provide the address of <code>Setpoint</code>, and then if you change the value of <code>Setpoint</code> later, the object will observe those changes.</p>

<pre><code>double setpoint = 1;

PID p(&amp;input, &amp;output, &amp;setpoint, ...)

p.foobar(); // setpoint=1 

setpoint = 3;
p.foobar(); // setpoint=3
</code></pre>

<p>Again, in C++ you could use a reference to get this same behaviour (although that would make your object non-assignable).</p>

<p>As you can see there are several possible explanations, so without further details you can't really say for sure why the library author requires you to use a pointer instead of by-value semantics</p>
",,53739494,105
44310697,2,44308401,2017-06-01T14:46:58.823,1,,4769313,,2017-06-01T14:46:58.823,,4,,"<p>When you develop code in the Arduino environment the code you write is compiled with a main.cpp that is into the core SW.</p>

<p>This code loops calling the function <code>loop()</code> that is in your code module.</p>

<p>Here the Arduino code:</p>

<pre><code>/*
 * \brief Main entry point of Arduino application
 */
int main( void )
{
    init();

    initVariant();

    delay(1);

#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();

    for (;;)
    {
        loop();
        if (serialEventRun) serialEventRun();
    }

    return 0;
}
</code></pre>

<p>You can see, in the main, that loop() is called forever!</p>

<p>Note that, in the main, the function <code>serialEventRun()</code> may be called when serial communication are enabled ( <code>if (serialEventRun) serialEventRun();</code> ). If this behavior is avoided you will have no serial communication.</p>
",,53752096,84
44385768,2,44354908,2017-06-06T09:04:39.537,0,,6533711,,2017-06-06T09:04:39.537,,0,,"<p>I Solved the problem by making the message function a normal function outside the class. Not sure if it is good practice - but it works. </p>

<pre><code>// File: LoRa.cpp
#include ""Arduino.h""
#include ""LoRa.h""
#include &lt;TheThingsNetwork.h&gt;

TheThingsNetwork ttn(loraSerial,debugSerial,freqPlan);

void message(const uint8_t *payload, size_t size, port_t port)
{
  // Stuff to do when reciving a downlink
}

LoRa::LoRa(){ 
}

void LoRa::init(){
  // Set the callback
  ttn.onMessage(message);
}
</code></pre>
",,53770145,512
44361384,2,44361329,2017-06-05T03:44:25.000,4,,857132,,2017-06-05T22:52:07.010,2017-06-05T22:52:07.010,6,,"<p>Hard to tell what you mean by ""the last part"", but lets assume you're here:</p>

<pre><code>else if (content.substring(1) != ""A0 B9 8D 7C"")    {
    /* stuff */
 }
 else if ((content.substring(1) != ""A0 B9 8D 7C"") &amp;&amp; (digitalRead(IESIRE)==0))     {
    /* other stuff */
  }
</code></pre>

<p>Lets simplify that:</p>

<pre><code>else if (A)    {
    /* stuff */
 }
 else if (A &amp;&amp; B)     {
    /* other stuff */
  }
</code></pre>

<p>Can you see it now? If condition A is met the first bit is done and so the else if is ignored.</p>

<p>If the 2nd bit should always be done remove the ""else if"" so it is always checked. If it is a case of one or the other then put the more specific part <code>(A &amp;&amp; B)</code> before the general case.</p>

<p>Also: for performance and dare I say clarity, don't call <code>substr</code> twice - store <code>substr(...) != ""...""</code> in a variable and just use the variable. If you give it a sensible name like what <code>!= ""A0 B9 8D 7C""</code> actually means, your code becomes much clearer! You also avoid the hassle of having to change the string in 2 places should values changes etc.</p>

<p>edit:
So from the comments: ANYTIME digitalRead(IESIRE)==0 I want this to happen: Serial.println(""Drum bun!""); digitalWrite(LED_V, HIGH); tone(BUZZER, 350); delay(300); bariera.write(120); ... (etc) </p>

<p>You should do this:</p>

<pre><code>else if (content.substring(1) != ""A0 B9 8D 7C"")    {
    /* stuff */
 }

if (digitalRead(IESIRE)==0)     {
    /* other stuff */
  }
</code></pre>

<p>Note it is not an <code>else if</code> and we've removed the redundant check that you don't care about.</p>

<p>Another edit:</p>

<p>I Think this does it. This is a good example of why DRY (Don't Repeat Yourself) is important. You've got one chunk of about 10 lines that is repeated for 2 conditions - it makes it that much harder to see shat is going on. Compare your original code to this simplified version of your code.</p>

<pre><code>if (content.substring(1) == ""A0 B9 8D 7C"")  { //aici schimbam ID-ul (UID-ul) cartelelor autorizate, citite anterior pe monitorul serial
    doA();
  } 
 else if (content.substring(1) != ""A0 B9 8D 7C"")    {
    do(B);
 }
  else if ((content.substring(1) != ""A0 B9 8D 7C"") &amp;&amp; (digitalRead(IESIRE)==0))     {
    doA();  
  }


 I think this is what you want:


 bool isRightCard = (content.substring(1) == ""A0 B9 8D 7C"");
 bool buttonPressed = digitalRead(IESIRE)==0;
 if (isRightCard || buttonPressed) //aici schimbam ID-ul (UID-ul) cartelelor autorizate, citite anterior pe monitorul serial
  {
    if (buttonPressed)
    {
        Serial.println(""Drum bun!"");
    }
    else
    {
        Serial.println(""Acces autorizat! Bine ati venit!"");
    }
    Serial.println();
    delay(500);
    digitalWrite(LED_V, HIGH);
    tone(BUZZER, 350);
    delay(300);
    noTone(BUZZER);
    bariera.write(120);
    delay(5000);
    bariera.write(0);
    digitalWrite(LED_V, LOW);

  }
 else {
    Serial.println("" Access interzis! La revedere!"");
    digitalWrite(LED_R, HIGH);
    tone(BUZZER, 300);
    delay(1000);
    digitalWrite(LED_R, LOW);
    noTone(BUZZER);

 }
</code></pre>
",,53813914,512
44365742,2,44365468,2017-06-05T09:26:56.857,1,,4685802,,2017-06-05T09:39:07.657,2017-06-05T09:39:07.657,1,,"<p>The answer is from <a href=""http://www.hackshed.co.uk/arduino-sorting-array-integers-with-a-bubble-sort-algorithm/"" rel=""nofollow noreferrer"">here</a></p>

<p>Sort your frequency array with the below function and then only take the last three elements of sorted array.</p>

<pre><code> void sort(int a[], int size)
 {
   for(int i=0; i&lt;(size-1); i++) 
   {
    for(int o=0; o&lt;(size-(i+1)); o++) 
       {
            if(a[o] &gt; a[o+1]) 
            {
                int t = a[o];
                a[o] = a[o+1];
                a[o+1] = t;
            }
        }
    }

  }
</code></pre>
",,53819340,96
44382959,2,44365468,2017-06-06T06:39:11.410,0,,5913737,,2017-06-06T06:39:11.410,,0,,"<p>I got the answer! Thanks for the help</p>

<pre><code>for (int i = 0; i &lt; 10; i++)  // Loop to sort the storeKeys array according to freq array
{   
   if(freq[i]!=0 &amp;&amp; storeKeys[i] != NULL){
    for (int j = i + 1; j &lt; 10; j++)
    {
        if (freq[i] &lt; freq[j])
        {
            a = freq[i];
            freq[i] = freq[j];
            freq[j] = a;
            b = storeKeys[i];
            storeKeys[i] = storeKeys[j];
            storeKeys[j] = b;
        }
    }
   }
}
for(int i=0;i&lt;10;i++) {  
  if(storeKeys[i] != NULL &amp;&amp; freq[i] != 0){
    // Serial.println(storeKeys[i]);
    while(c&lt;3){
      mostPressed[c] = storeKeys[i];
      c=c+1;
      break;
    }
  }
  if(c==3){
    break;
  }
}
</code></pre>

<p>Here I sorted the <strong>storeKeys</strong> array according to the frequency array and stored the top three results in a new array. I got it myself. Thanks for the help!</p>
",,53820936,104
44387717,2,44386831,2017-06-06T10:37:16.880,0,,7097407,,2017-06-06T10:37:16.880,,0,,"<p>the error seemed to be located in the loop as the output is</p>

<pre><code>Write Request Received: Andy
Writing To i2c: 0xa800fd98

I'm working here
I wrote the memory adress
I wrote a byte of data
I wrote a byte of data
I wrote a byte of data
I wrote a byte of data
I wrote a byte of data
....
</code></pre>

<p>this seems to go on ad infinitum. </p>

<p>After adding a few more debug statements and changing the points Some programmer dude noticed </p>

<pre><code>{
    Wire.beginTransmission((int)device);
    Serial.println(""I'm working here"");
    Wire.write((unsigned char)_memstart);
    Serial.println(""I wrote the memory adress"");
    for (int j = 0; j &lt; blockSize; j++) {
        Wire.write(wrBuf[bytesWritten + j]);
        Serial.println(""I wrote a byte of data"");
        //Serial.write(wrBuf[bytesWritten + j]);
    }
    Wire.endTransmission();
    Serial.println(""I ended the transmission"");
    bytesWritten += blockSize;
    _memstart += blockSize;
    delay(25);
}
</code></pre>

<p>i noticed that i was checking for I &lt; blocksize (copied from the reading part,) now i'm running into some other (small) issues but this solved the problem i was having. </p>
",,53822846,262
44394996,2,44392618,2017-06-06T16:11:23.213,0,,794749,,2017-06-06T16:11:23.213,,0,,"<p>You are waiting for the <code>voltage</code> variable to change, without actually changing it (reading from analog pin).</p>

<p>You need to add <code>voltage = analogRead(A0);</code> into your loop.</p>

<pre><code>do
{
    voltage = analogRead(A0);
    if ((voltage &gt;= 1) &amp;&amp; (voltage &lt;= 10))   //while the voltage is between 4.88 and 48.8 mV the calibration light will flash once
    {                                        //this ensures the voltage is above 0 and lower than the threshold for the max voltage routine 
        ...

        flag = 1;
    }
} while (flag == 0);
</code></pre>
",,53847046,578
44394691,2,44394619,2017-06-06T15:54:51.977,0,,598696,,2017-06-06T15:54:51.977,,4,,"<blockquote>
  <p>What would be the correct way of populating the arrayOfPointers with pointers to the passed in items? </p>
</blockquote>

<p>Firstly, don't use raw <code>new</code> and <code>delete</code>. Use containers and smart pointers.</p>

<pre><code>struct HolderClass
{
    std::unique_ptr&lt;std::unique_ptr&lt;ItemClass&gt;[]&gt; arrayOfPointers;
    // ...
};

HolderClass::HolderClass(int number)
{
     arrayOfPointers = std::make_unique&lt;std::unique_ptr&lt;ItemClass&gt;[]&gt;(number);
}
</code></pre>

<p>Then, pass a pointer to <code>addItem</code> instead of a value to avoid object slicing and lifetime issues:</p>

<pre><code>HolderClass::addItem(int number, std::unique_ptr&lt;ItemClass&gt; item)
{
    arrayofPointers[number] = std::move(item);
}
</code></pre>
",,53856579,138
44413113,2,44395231,2017-06-07T12:48:23.513,0,,8091017,,2017-06-07T12:48:23.513,,0,,"<p>Try to follow below steps to enable audio recording and playback from a usb-sound adapter for rpi with alsa first. With this you can test your USB sound adapters are working correctly as input and output module.I have not tested before a usecase with above mentioned library in C++ code, will give it a try soon. Try by referring to ""hw:1"" later in your C++ code if it working.</p>

<p>Steps:
1.1) Create/edit file .asoundrc</p>

<pre><code>$vim .asoundrc
</code></pre>

<p>If file is not present create it;</p>

<pre><code>$ touch .asoundrc

$vim .asoundrc 
pcm.!default {
        type asym
        playback.pcm ""hw:1,0""
        capture.pcm ""hw:1,0""
}

ctl.!default {
        type hw
        card 1
}
</code></pre>

<p>1.2) Edit below line in file alsa.conf;</p>

<pre><code>$sudo vim /usr/share/alsa/alsa.conf
defaults.ctl.card 0
defaults.pcm.card 0
</code></pre>

<p>to</p>

<pre><code>$sudo vim /usr/share/alsa/alsa.conf
defaults.ctl.card 1
defaults.pcm.card 1
</code></pre>

<p>1.3) Change audio levels/setting using alsamixer utility</p>

<pre><code>$alsamixer
</code></pre>

<p>1.4) Command to record audio</p>

<pre><code>$arecord -D plughw:1 -f S16_LE -r 48000 -d 5 ./testSound.wav
</code></pre>

<p>1.5) Command to play recorded audio</p>

<pre><code>$aplay --device=plughw:1,0 ./testSound.wav
</code></pre>
",,53872874,1193
44417090,2,44416941,2017-06-07T15:35:36.117,2,,979325,,2017-06-07T15:35:36.117,,0,,"<p>You can try something like</p>

<pre><code>int year;
int month;
int day;
int hour;
int minute;
int second;
sscanf(buffer, ""%4d%2d%2d%2d%2d%2d"", &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second);
</code></pre>
",,53891054,151
44459934,2,44454300,2017-06-09T14:07:57.743,1,,1015327,,2017-06-09T15:03:12.833,2017-06-09T15:03:12.833,6,,"<p>Those 700ms are not caused by the execution time of the few instructions in your function. Those should be done in microseconds. You may have a buffer overflow, or the other device might be delaying transfers, or there's another bug not related to buffer overflow.</p>

<p>This is about how I'd do it:</p>

<pre><code>void i2cRead(unsigned char device, unsigned char memory, int len, unsigned char * rdBuf, int bufLen)
{
     ushort _memstart = memory;
     if ( bufLen &lt; len ) {
         len = bufLen;
     }
     while (len &gt; 0) 
     {
         Wire.beginTransmission((int)device);
         Wire.write(_memstart);
         Wire.endTransmission();

         int reqSize = 32;

         if ( len &lt; reqSize ) {
             reqSize = len;
         }

         Wire.requestFrom((int)device, reqSize);

         while (Wire.available() &amp;&amp; (len != 0)) 
         {
              *(rdBuf++) = Wire.read();
              _memstart++;
              len--;
         }
     }
}
</code></pre>
",,53900441,1905
44473132,2,44472740,2017-06-10T12:05:43.673,0,,5741073,,2017-06-10T14:30:17.363,2017-06-10T14:30:17.363,3,,"<p><code>sei()</code> ENABLES interrupts, while <code>cli()</code> disables them.  Your comments suggest you have them backwards.  Perhaps there are other problems, but these instructions are certainly not consistent with your intentions.</p>

<p>If you want to get lower-level, consider a pure interrupt-driven design like:</p>

<pre><code>ISR (USART0_UDRE_vect)
{
    // Send next byte and increment pointer
    UDR0 = *ub_outptr++;
    // Pointer wrapping
    if (ub_outptr &gt;= UART_buffer + BUFF_SIZE)
    ub_outptr = UART_buffer;
    // If buffer is empty: disable interrupt
    if(--ub_buffcnt == 0)
    UCSR0B &amp;= ~(1 &lt;&lt; UDRIE0);
</code></pre>

<p>}</p>

<p>I know this takes you out of the Arduino library stuff, so this may not be ideal for you.  But it works (the example is for sending data, as I have an active project where the microcontroller sends data to an LCD display.  Just an example in AVR-GCC C.)</p>
",,53914467,148
44500475,2,44488382,2017-06-12T13:18:11.833,2,,4100891,,2017-06-12T23:44:52.903,2017-06-12T23:44:52.903,2,,"<p>The part you're missing is that double-quoted string constants use both flash memory (program size) and RAM.  It's not because of <code>strcpy</code>; it's an artifact of the different types of memory on this Harvard Architecture MCU.</p>

<p>To avoid using both flash and RAM for string constants, use the F macro to force it to be accessible from flash ONLY:</p>

<pre><code>void setup() {
  Serial.begin(9600);
  char cc[300];
  strcpy_P(cc, (const char *) F(""Bonjour ca va et toi ?Bonjour ca va et toi ?""
                                ""Bonjour ca va et toi ?Bonjour ca va et toi ?"") );
  Serial.println(getFreeMemory());
}
</code></pre>

<p>... or define it as a PROGMEM character array:</p>

<pre><code>const char ce[] PROGMEM =
        ""Bonjour ca va et toi ?Bonjour ca va et toi ?""
        ""Bonjour ca va et toi ?Bonjour ca va et toi ?"";

void setup() {
  Serial.begin(9600);
  char cc[300];
  strcpy_P(cc,ce);
  Serial.println(getFreeMemory());
}
</code></pre>

<h3>NOTES:</h3>

<ul>
<li>you have to use the <code>strcpy_P</code> variant to copy <em>from</em> flash, not RAM.</li>
<li>long double-quoted strings can be broken up into several adjacent double-quoted strings.  The compiler will concatenate them for you.</li>
</ul>

<h3>UPDATE:</h3>

<p>You may not need one big array if you can do your ""thing"" with the pieces.  For example, don't make one big array so you can print or send it.  Just print or send the individual pieces -- some pieces from RAM (e.g., variables) and some from flash (e.g., double-quoted string constants).  This saves RAM (lots!) and processing time (no copies or concatenations).  </p>
",,53914554,158
44513095,2,44511623,2017-06-13T05:37:34.660,4,,1512962,,2017-06-13T05:37:34.660,,0,,"<p>What it sounds like you want is called a <em>moving median</em> (very similar to a <a href=""https://en.wikipedia.org/wiki/Moving_average"" rel=""nofollow noreferrer""><em>moving average</em></a>). This would be when you need to store the last <code>n</code> values in an array and compute the median.</p>

<p>Here's what this would look like:</p>

<pre><code>int data[5] = {0, 0, 0, 0, 0};
int dataI = 0;

int sortedData[5] = {0, 0, 0, 0, 0};

void pushNewData(int d) {
    data[dataI] = d;

    dataI++;
    if(dataI &gt; 4) {
        dataI = 0;
    }
}

int median() {
    for(int i = 0; i &lt; 5; i++) {
        sortedData[i] = data[i];
    }

    // Use a sorting algorithm here to sort sortedData

    return sortedData[3];
}
</code></pre>

<hr>

<p>If you want to get the median of hundreds of hours of data, on the other hand, you have to store every data value. If this is your use case, I strongly recommend that you <strong>use an average instead.</strong> Since an average is just <code>sum / n</code>, you can only have two variables and add to them. Of course, you'll have to account for overflow.</p>

<hr>

<p>Let's say you still want a median (for example, if you're worried about your data not being symetric or you're worried about outliers). In that case, you could easily build a histogram and estimate the median using that.</p>

<p>You'd do this by creating an array of ints. Index 0 would be for values <code>0-5</code>, index 2 would be for values <code>6-10</code>, and so on. (The size of each value range would vary based on your setup.) Each time a new data point comes in, you would check which ""bucket"" (value range) the point falls into and you would increment the corresponding counter in that array.</p>

<p>It's easy to approximate your median from this data. Let's say you extracted this data:</p>

<pre><code>Values 00-05: 1
Values 06-10: 7
Values 11-15: 8
Values 16-20: 2
Values 21-25: 1
Values 26-30: 5
</code></pre>

<p>Since n = 24, the median would be n=12. The 12th data point would be in the <code>11-15</code> range, so your median would be between 11 and 15.</p>

<p>Instead of ranges of 5, you could easily do ranges of 3 or of 1 with the same effect. Just beware of overflow and memory usage: you should use an array of unsigned longs in addition to making sure to not use too many buckets.</p>
",,53919253,802
44532129,2,44530390,2017-06-13T21:47:42.300,2,,2430669,,2019-08-03T04:46:20.340,2019-08-03T04:46:20.340,0,,"<p>As long as you understand that you will never be able get 36 pulses per turn accuracy with 24 pulse/turn, you can do this, which is a common trick derived from the Bresenham algorithm.  This solution assumes you are concerned about the position.</p>

<p>Now, this will generate pulses in real-time, as opposed to your code, which generates pulses in a blocking manner, I don't think losing pulses was your original intent. </p>

<p>This code will not generate pulses uniformly, 1 out of 3 readings will generate 2 pulses. </p>

<p>Another way would be to calculate the average speed and program a hardware timer to simulate the 36 pulses per turn, using interrupts, but going that route would likely (invariably, in my experience) end up in total loss of sync between the actual position of the wheel and what your corrected tick count reports.  There are also strict speed ranges that you have to respect if going that route, also this will introduce severe <em>latency</em> issues to your application.  </p>

<ol>
<li>Change the increment value to 36, and the whole turn count to 24/36.</li>
<li>Change the step detection to a threshold of 24.</li>
<li>I'm trying to understand why you want to do this 36/24 thing, and can't.</li>
</ol>

<p>So, your mileage may vary.</p>

<pre><code>// compare the hall State to its previous state
// to declared outside of loop()
// int smallCounter;
// PULSE_WIDTH as small positive pulse with in us
//
if (hallState != lasthallState) {
  // if the state has changed, increment the counter
  smallCounter += ((hallState == HIGH) ? 36 : 0);
  // ... I'm assuming that the serial prints you had here were just here for debugging.
  lasthallState = hallState;
}
//
// reporting for each step below
//
if (smallCounter &gt;= 24)
{
  smallCounter -= 24;
  if (++teethCounter &gt;= 36) {
    cycle = true;
    cycles++;
    teethCounter=0;
    usElapsedUp = usElapsed;

  }
  digitalWrite(13,HIGH);
  delayMicroseconds(PULSE_WIDTH);
  digitalWrite(13,LOW);
  delayMicroseconds(PULSE_WIDTH); // this is probably not needed.
}
</code></pre>
",,53930091,57
44563460,2,44555949,2017-06-15T09:11:20.860,0,,7408924,,2017-06-15T09:11:20.860,,0,,"<p>I noticed that the TFT display and Touchscreen share some Analog pins. I think this is causing the problems.
So I sectioned my code in a part where the touchscreen is handled. Then I can reassign the pins to the TFT monitor and draw to it. I don't know whether this theory makes sence, but it is working:</p>

<pre><code> void loop() {
  //Touchposition bestimmen
  if (ts.isTouching()) {
    Point p = ts.getPoint();
    p.x = map(p.x, TS_MINX, TS_MAXX, 0, 240);
    p.y = map(p.x, TS_MINY, TS_MAXY, 0, 320);
    if (released) {
      released = false;
    }
  }
  else {
    //Serial.println(""Touch me where I like it!"");
    released = true;
  }

  if (ts.isTouching() &amp;&amp; !released) {
    //re assing pins to tft because they are also used by the touchscreen
    Adafruit_TFTLCD tft(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET);
    Serial.println(""don't touch me!"");
    drawButton(100, 100, ""Manuell"");
    touched = false;
  }
}
</code></pre>

<p>The drawButton funton contains several draw functions</p>
",,53940073,611
44573010,2,44572943,2017-06-15T16:57:59.940,11,,3552770,,2017-06-15T17:06:32.100,2017-06-15T17:06:32.100,5,,"<p>You have to pick a different name for your include guard macro (commonly <code>TOUCHABLE_H</code>), because preprocessor translates your code in <code>Touchable.h</code> to:</p>

<pre><code>class {
public:
   int posX;
   int posY;
   (int, int);
   ~();
   void ::draw();
};
</code></pre>

<p>same goes for all files that <code>#include</code> this one... Or you can use <a href=""https://stackoverflow.com/questions/787533/is-pragma-once-a-safe-include-guard""><code>#pragma once</code></a>.</p>
",,53956408,913
44608191,2,44587611,2017-06-17T18:44:45.423,1,,1252334,,2017-06-17T18:44:45.423,,1,,"<p>There's something wrong with handling the response. It works when connecting to my server but it doesn't work when connecting to yours.</p>

<p>This is what ESP8266 gets when connecting to my server:</p>

<pre><code>HTTP/1.1 200 OK
Date: Sat, 17 Jun 2017 18:21:37 GMT
Server: Apache/2.4.17 (Win32) OpenSSL/1.0.2d PHP/5.6.19
X-Powered-By: PHP/5.6.19
Content-Length: 31
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: application/json

{""light"":""OFF"",""time"":""20""}
</code></pre>

<p>And this is what it gets when connecting to yours:</p>

<pre><code>HTTP/1.1 200 OK
Server: nginx admin
Date: Sat, 17 Jun 2017 18:25:53 GMT
Content-Type: application/json
Transfer-Encoding: chunked
Connection: keep-alive

28
{""light"":""OFF"",""online"":""0"",""time"":""21""}
0
</code></pre>

<p>Unfortunately, I don't have time now to investigate the problem with your code but meanwhile here is a working one which uses HTTPClient to handle request and response (I would recommend using this anyway):</p>

<pre><code>#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266HTTPClient.h&gt;
#include &lt;ArduinoJson.h&gt;
#define pin 5

const char* ssid     = ""ssid"";  
const char* password = ""password""; 

void setup() {  
  pinMode(pin, OUTPUT); 
  pinMode(pin, HIGH);
  digitalWrite(5, HIGH);
  Serial.begin(9600);

  delay(10);
  Serial.print(""Connecting to "");
  Serial.println(ssid);

  WiFi.begin(ssid, password);
  int wifi_ctr = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }

  Serial.println(""WiFi connected"");  
  Serial.println(""IP address: "" + WiFi.localIP());
}

void loop() {  
  HTTPClient http;
  http.begin(""http://bot.erm.today/lightAPI.php"");
  int statusCode = http.GET();
  StaticJsonBuffer&lt;200&gt; jsonBuffer;
  JsonObject&amp; json_parsed = jsonBuffer.parseObject(http.getString());
  http.end();
  if (!json_parsed.success())
  {
    Serial.println(""parseObject() failed"");
    return;
  }

  // Make the decision to turn off or on the LED
  if (strcmp(json_parsed[""light""], ""OFF"") == 0) {
    digitalWrite(5, HIGH); 
    Serial.println(""LED OFF"");
  }
  else {
    digitalWrite(5, LOW);
    Serial.println(""LED ON"");
  }
}
</code></pre>
",,53978811,150
44597591,2,44597305,2017-06-16T20:36:04.100,4,,5741073,,2017-06-16T20:41:18.330,2017-06-16T20:41:18.330,2,,"<p>It is okay but not preferred.  It is always safer to do less -- perhaps simply set a flag -- and exit interrupts as fast as possible.  Then take care of the flag/semaphore back in your main loop.  For example:</p>

<pre><code>volatile uint8_t i2cmessage = 0;  // must be volatile since altered in an interrupt 

void ReceivedI2CMessage(int numBytes) // not sure what numBytes are used for...
{
    i2cmessage = 1;  // set a flag and get out quickly
}
</code></pre>

<p>Then in your main loop:</p>

<pre><code>loop()
{
    if (i2cmessage == 1) // act on the semaphore
    {
        cli(); // optional but maybe smart to turn off interrupts while big message traffic going through...
        i2cmessage = 0; // reset until next interrupt
        while (Wire.available())
        {
            messageFromBigArduino = Wire.read();
            // do something with bytes read
        }
        Serial.println(messageFromBigArduino);
        sei(); // restore interrupts if turned off earlier
    }
}
</code></pre>

<p>This achieves the goal of the interrupt, which is ideally to set a semaphore to be acted on quickly in the main loop.  </p>
",,53980112,304
44639290,2,44638938,2017-06-19T20:21:38.713,4,,4151599,,2017-06-20T00:32:54.777,2017-06-20T00:32:54.777,0,,"<p>Non-static member functions require an object to work on, and thus can't be passed and called like normal function pointers.</p>

<p>The simplest way to make your <code>debounce</code> method work, would be to use a lambda that captures your <code>player</code> object and calls <code>increment</code> on it:</p>

<pre><code>class Button {
  //...
  template&lt;typename Callback&gt;
  void debounce(Callback&amp;&amp; func) {  // &lt;&lt;-- Note the &amp;&amp; here, without
                                    //      it func would need to be
                                    //      copied
    if (millis() - buttonDownTime &gt; debounceTime) {
      func();
    }
  }
}

void loop() {
  //...
  button.debounce([&amp;player](){ player.incriment(); });
}
</code></pre>

<p>With a little bit of extra effort, you could implement something similar to C++17's <code>std::invoke</code> to uniformly invoke any type of callable.  Since you're on Arduino and don't have access to the C++ standard library, you'll need to implement <code>std::remove_reference</code> and <code>std::forward</code> yourself as well:</p>

<pre><code>template &lt;typename T&gt;
struct remove_reference
{
  using type = T;
};

template &lt;typename T&gt;
struct remove_reference&lt;T&amp;&gt;
{
  using type = T;
};

template &lt;typename T&gt;
struct remove_reference&lt;T&amp;&amp;&gt;
{
  using type = T;
};

template &lt;typename T&gt;
constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t)
{
  return static_cast&lt;T&amp;&amp;&gt;(t);
}

template &lt;typename T&gt;
constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t)
{
  return static_cast&lt;T&amp;&amp;&gt;(t);
}

template &lt;typename Callable, typename... Args&gt;
auto invoke(Callable&amp;&amp; func, Args&amp;&amp;... args) 
    -&gt; decltype(forward&lt;Callable&gt;(func)(forward&lt;Args&gt;(args)...))
{
    return forward&lt;Callable&gt;(func)(forward&lt;Args&gt;(args)...);
}

template &lt;typename Callable, typename Class, typename... Args&gt;
auto invoke(Callable&amp;&amp; method, Class&amp;&amp; obj, Args&amp;&amp;... args)
    -&gt; decltype((forward&lt;Class&gt;(obj).*method)(forward&lt;Args&gt;(args)...))
{
    return (forward&lt;Class&gt;(obj).*method)(forward&lt;Args&gt;(args)...);
}

class Button {
  //...
  template&lt;typename Callback, typename... Args&gt;
  void debounce(Callback&amp;&amp; func, Args&amp;&amp;... args) {
    if (millis() - buttonDownTime &gt; debounceTime) {
      invoke(forward&lt;Callback&gt;(func),
             forward&lt;Args&gt;(args)...);
    }
  }
}

void loop() {
  //...
  button.debounce(&amp;Player::increment, player);
}
</code></pre>

<p>This doesn't quite do everything that C++17's <code>std::invoke</code> does, but it's close enough to implement a basic callback.  It also gives you extra flexibility in that you could pass additional arguments to <code>debounce</code> and they will be passed along to your callback:</p>

<pre><code>void foo(int num) { /*...*/ }

void loop() {
    Button b;
    b.debounce(foo, 42);
}
</code></pre>

<p>This doesn't really work if you need to save the callback and call it later, but it doesn't look like that's what you're trying to do.</p>
",,53984567,603
44639398,2,44638938,2017-06-19T20:27:46.240,2,,6421496,,2017-06-19T20:27:46.240,,2,,"<p>In C++, the class name (Player) would be part of function signature, and the syntax becomes non-trivial. Templates do not resolve it in an elegant way, and even what Boost gives you (look <a href=""https://stackoverflow.com/questions/5245072/pass-and-call-a-member-function-boostbind-boostfunction"">here</a>), is not really elegant (in my book).</p>

<p>Here is a simpler syntax which achieves the same goal.</p>

<pre><code>class Button {
  int buttonDownTime = 0;
  int debounceTime = 2000;

  public:
  template&lt;typename CallbackClass&gt;
  void debounce(CallbackClass* po) {
    if (millis() - buttonDownTime &gt; debounceTime) {
      po-&gt;increment();
    }
  }
};

class Player {
  int playerCount = 0;

  public:
  void increment() {
    playerCount++;
  }
};

int main() {
  Button button;
  Player player;
  button.debounce(&amp;player);
}
</code></pre>
",,54008315,107
44640675,2,44638938,2017-06-19T22:03:07.233,1,,1621935,,2017-06-19T22:29:21.797,2017-06-19T22:29:21.797,0,,"<p>Another valid approach is to define an interface with the pure virtual func() method so that you can pass an implementation of this interface to your debounce() method and call its func() method there.</p>

<pre><code>class YourInterface {
public:
  virtual void func() = 0;
};

class Button {
public:
  int buttonDownTime = 0;
  int debounceTime = 2000;

  ...

  void debounce(YourInterface yourInterface) {
    if (millis() - buttonDownTime &gt; debounceTime) {
      yourInterface-&gt;func();
    }
  }
}

class Player {
public:
  int playerCount = 0;

  void increment() {
    playerCount++;
  }
}

void loop() {

  ...

  button.debounce(player.increment);
}
</code></pre>
",,54057193,226
44642753,2,44642165,2017-06-20T02:15:55.047,0,,2430669,,2017-06-20T02:24:31.310,2017-06-20T02:24:31.310,7,,"<p>See comments below, in your program:</p>

<pre><code>    if (!fWaitingOnRead) {
        if (!ReadFile(                // here you make a non-blocking read.
            hComm,
            message,
            sizeof(*message),
            &amp;dwRead,
            &amp;osReader
            )) {
                                     // Windows reports you should wait for  input.
                                     //
                if (GetLastError() != ERROR_IO_PENDING) {
                 std::cout &lt;&lt; ""Communications error"" &lt;&lt; std::endl;
                return 3;
            }
            else {                   // &lt;-- remove this.
                                     // insert call to GetOverlappedcResult here.
                std::cout &lt;&lt; message &lt;&lt; std::endl;
            }
        }
    }

    return 0;                       // instead of waiting for input, you exit.
}
</code></pre>

<p>After you call <code>ReadFile()</code> you have to insert a call for <code>GetOverlappedResult(hComm, &amp;osReader, &amp;dwBytesRceived, TRUE)</code> to wait for the read operation to complete and have some bytes in your buffer.</p>

<p>You will also need to have a loop in your program if you don't want to exit prematurely.</p>

<p>If you do not want to do overlapped i/o (which is a wise decision) , do not pass an OVERLAPPED pointer to ReadFile.  ReadFile will block until it has some data to give you.  You will then obviously not need to call <code>GetOverlappedresult()</code></p>

<p>For the serial port, you also need to fill in a DCB structure. <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx</a></p>

<p>You can use <code>BuildCommDCB()</code>to initialize it.  There is a link to it in the MS doc, <code>CallGetCommState(hComm, &amp;dcb)</code> to initialize the serial port hardware.  The serial port needs to know which baud rate etc. you need for your app.</p>
",,54060022,66
44757335,2,44664865,2017-06-26T10:08:34.603,2,,8191277,,2017-06-26T11:04:35.440,2017-06-26T11:04:35.440,0,,"<p>This was solved in my question on the stackexchange site: unix.stackexchange.com/questions/372452/disable-read-cache-buffer-for-usb-mass-storage-device-in-linux</p>

<p>To summarise, the issue was that I needed to use <code>O_DIRECT</code> but ensure that I was reading (and seeking) full blocks of data. In my case, the device was in 512byte blocks so I needed to fetch that amount.</p>

<pre><code>#define NUM_VARS 1024
#define PAGE 4096
#define STARTBYTE (272384/PAGE*PAGE) // must align
#define OFFSET (272384-STARTBYTE)
#define ITEMSIZE (sizeof(*liveBuffer))
#define LIVEBUFSIZE ((OFFSET+NUM_VARS*ITEMSIZE+PAGE-1)/PAGE*PAGE)

signed short *liveBuffer;
FILE *input = fopen(""/dev/sda"", ""r+"");
if(posix_memalign((void**)&amp;liveBuffer, PAGE, LIVEBUFSIZE)!=0)
   exit(5);
if (fcntl(fileno(input), F_SETFL, O_DIRECT) == -1)
   exit(6);
fseek(input, OFFSET, SEEK_SET);
fread(liveBuffer, ITEMSIZE, LIVEBUFSIZE, input);
fclose(input);
</code></pre>
",,54065822,692
44686238,2,44683769,2017-06-21T21:02:43.373,0,,4521119,,2017-06-21T21:02:43.373,,0,,"<p>The client.publish destroys the payload buffer. So I had to catch the payloads into new variables to overcome the problem.</p>

<pre><code> void callback(char* topic, byte* payload, unsigned int length) {
      char p0 = (char)payload[0];
      char p1 = (char)payload[1];
      Serial.print(""Message arrived ["");
      Serial.print(topic);
      Serial.print(""] "");
      for (int i = 0; i &lt; length; i++) {
        Serial.print((char)payload[i]);
      }

       //Set GPIO0 to HIGH or LOW on first character received in message
      if (p0 == '1') {
        digitalWrite(GPIO0, HIGH);   // Turn the relay on
        client.publish(getOutTopic().c_str(), ""GPIO0 set to HIGH"");
      } else if (p0 == '0') {
        digitalWrite(GPIO0, LOW);  // Turn the relay off
        client.publish(getOutTopic().c_str(), ""GPIO0 set to LOW"");
      }

      //Set GPIO2 to HIGH or LOW on first character received in message
      if (p1 == '1') {
        digitalWrite(GPIO2, HIGH);   // turn LED off. With High it is inactive  on the ESP-01)
        client.publish(getOutTopic().c_str(), ""GPIO2 set to HIGH"");
      } else if (p1 == '0') {
        digitalWrite(GPIO2, LOW);  // Turn the LED on by making the voltage LOW
        client.publish(getOutTopic().c_str(), ""GPIO2 set to LOW"");
      } 
}
</code></pre>
",,54066235,65
44729065,2,44727004,2017-06-23T19:56:40.780,0,,943010,,2017-06-23T20:12:28.997,2017-06-23T20:12:28.997,2,,"<p>Looking specifically at this piece of code (which seems to be the actual question</p>

<pre><code>for (i = 0; i &lt; ch_num; i++)
        {
            adc[i] = ADS1256_GetAdc(i);
                 volt[i] = (adc[i] * 100) / 167;    
        }
</code></pre>

<p>It reads a number of ADC channels (0 through ch_num-1) and then does a crude conversion of each ADC value to a percentage of 167.</p>

<p>Consider the way we normally do percentage calculations as (a/b)*100. In other words, work out what fraction a is of b and then multiply by 100. But with integer math, the initial division will yield zero for all values &lt; b, and the multiply won't affect that.</p>

<p>So we rewrite (a/b)*100 as (a*100)/b. Now the division occurs after the multiply and you will get non-zero results.</p>

<p>More specifically consider this example</p>

<p>(100/167) * 100 should become 0.59 * 100 = 59%. But with integer math you get (100/167) * 100 = (0) * 100 = 0%. After the rewrite you have (100*100)/167 = (10000)/167 = 59.</p>

<p>This is a standard trick with integer math.</p>
",,54092429,70
44752248,2,44729722,2017-06-26T01:58:20.457,0,,1599004,,2017-06-27T23:06:28.943,2017-06-27T23:06:28.943,5,,"<ul>
<li>If the integer values of variables <code>a</code>, <code>b</code>, <code>c</code>, ... <code>i</code>, and <code>r</code> are monotonic increasing, then the <strong>if</strong> conditionals can be optimized.  </li>
<li>The repeated access of a structure element and an array element can be optimized to local scaler variables.  </li>
<li>Repeated allocation &amp; deallocation of a local variable can be eliminated for time optimization.  </li>
<li><p>The repetition of the <strong>write()</strong> syscall can be eliminated for space optimization and code maintainability.  </p></li>
<li><p>A binary comparison algorithm can improve upon a sequential comparison.<br>
Instead of a maximum of executing ten <strong>if</strong> statements, the maximum could be four (plus a boolean test for the syscall).<br>
The original code has two integer comparisons and a logical operation (which are not that expensive) in each <strong>if</strong>, but that can be optimized to just one comparison in each <strong>if</strong>. </p></li>
</ul>

<p>The following (is tested and) may be optimal for space and time.</p>

<pre><code>void Path(Point j)
{
   int val = j.y;
   char moveMsg = 0;

   /* ASSERT(0 &lt; a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g &lt; h &lt; i &lt; r) */

   if (val &lt;= e) {
      if (val &lt;= b) {
         if (val &lt;= a) {
            if (val &gt; 0)   /* &amp;&amp; val &lt;= a */
               moveMsg = 'j';
         } else    /* val &lt;= b &amp;&amp; val &gt; a */
            moveMsg = 'i';
      } else {  
         if (val &lt;= c)      /* &amp;&amp; val &gt; b */
            moveMsg = 'h';
         else if (val &lt;= d) /* &amp;&amp; val &gt; c */
            moveMsg = 'g';
         else      /* val &lt;= e &amp;&amp; val &gt; d */
            moveMsg = 'f';
      }
   } else {
      if (val &lt;= h) {
         if (val &lt;= f)      /* &amp;&amp; val &gt; e */
            moveMsg = 'e';
         else if (val &lt;= g) /* &amp;&amp; val &gt; f */
            moveMsg = 'd';
         else      /* val &lt;= h &amp;&amp; val &gt; g */
            moveMsg = 'c';    
      } else {
         if (val &lt;= i)      /* &amp;&amp; val &gt; h */
            moveMsg = 'b';
         else if (val &lt;= r) /* &amp;&amp; val &gt; i */
            moveMsg = 'a';
      }
   }

   if (moveMsg)
      write(fd1, &amp;moveMsg, 1);
}
</code></pre>

<p>The savings in time is highly dependent on the distribution of the input values.  If the data skews low then the savings is small, whereas if it skews to large values or uniform distribution then the savings is better.<br>
The variation in execution time is also no longer a function of the input value; of course for integer comparisons this variation isn't large.  </p>

<hr>

<blockquote>
  <p>...  the receiving code is optimized, while running through this segment is taking around 600 clock cycles, and I feel that it could be cut down from that.  </p>
</blockquote>

<p>Except for the binary algorithm, these are all well-known optimizations that a good optimizing compiler can perform for you.<br>
Since hand optimization is becoming a useless/lost skill, I'm inclined to be dubious of your claim that <em>""the receiving code is optimized""</em>.<br>
The best optimizations are the proper algorithm and proper use of syscalls (e.g. the syscall to write only one byte will consume the bulk of the execution time of this routine).</p>

<hr>

<p><strong>Addendum</strong>  </p>

<blockquote>
  <p>Could you explain why you did the if statements like that? Why would gong through more if statements help make it faster? </p>
</blockquote>

<p>The optimized code has 11 <strong>if</strong> statements to find the range; that's only one <em>""more""</em> than the original code.<br>
Moreover each <strong>if</strong> statement is just one simple integer comparison, versus the original's compound logical expression of two comparisons.<br>
In terms of the number of actual ALU operations (rather than source code complexity), the original code is clearly more expensive to execute than the
optimized code.  </p>

<p>The optimized code could typically execute <em>fewer</em> (not more) <strong>if</strong> statements and perform fewer comparisons than the original code.<br>
The apparent simplicity of that original code has a well-known inefficiency, since it employs a linear or sequential (i.e. one after the other) search.  </p>

<p>The worst case scenario with the original code occurs when the input value is equal to the maximum value <code>r</code>.<br>
That is when the original code has to execute all 10 <strong>if</strong> statements and perform 20 integer comparisons.<br>
The optimized code uses a <a href=""https://en.wikipedia.org/wiki/Binary_search_algorithm"" rel=""nofollow noreferrer"">binary search</a> that executes 4 <strong>if</strong> statements and performs only 4 integer comparisons for that same input.<br>
The worst case scenario with the optimized code is execution of 4 <strong>if</strong> statements and perform 4 integer comparisons.  </p>

<p>The best case scenario with the original code occurs when the input value is equal to the minimum value <code>a</code>.<br>
The original code has to execute just 1 <strong>if</strong> statement, but that does involve 2 integer comparisons.<br>
The optimized code would execute 4 <strong>if</strong> statements and performs 4 integer comparisons for that same input.<br>
That's only 2 more comparisons, and it's the number of comparisons that influence execution time, not the number of <strong>if</strong> statements in the source code.<br>
The penalty of two more comparisons for this best case is offset by the significant advantage of 16 fewer comparisons for the worst case.</p>

<p>The average case favors the optimized code using a binary search.<br>
The original's 5 <strong>if</strong> statements performing 10 integer comparisons is slower than than the optimized 4 <strong>if</strong> statements performing only 4 integer comparisons.<br>
That's an advantage of 6 integer comparisons.  </p>

<p>In fact unless the input value is consistently not more than <code>a</code> (i.e. the first interval), then the optimized code will execute the same number or fewer integer comparisons than the original code, despite the appearance of having more <strong>if</strong> statements.  </p>

<blockquote>
  <p>That seems counterintuitive to me. </p>
</blockquote>

<p>With search (and sorting) algorithms, simple or straightforward usually means slow.</p>
",,54110906,301
44767698,2,44733265,2017-06-26T19:56:09.983,0,,16007,,2017-06-26T19:56:09.983,,0,,"<p>very slight modifications, the naked attributes are not required (what tools are you using?)</p>

<pre><code>asm("".globl _start; _start: nop\n"");

#ifndef GPIO_H
#define GPIO_H

#ifdef RPI2
    #define GPIO_BASE       0x3F200000UL
#else
    #define GPIO_BASE       0x20200000UL
#endif

#if defined( RPIBPLUS ) || defined( RPI2 )
    #define LED_GPFSEL      GPIO_GPFSEL4
    #define LED_GPFBIT      21
    #define LED_GPSET       GPIO_GPSET1
    #define LED_GPCLR       GPIO_GPCLR1
    #define LED_GPIO_BIT    15
#else
    #define LED_GPFSEL      GPIO_GPFSEL1
    #define LED_GPFBIT      18
    #define LED_GPSET       GPIO_GPSET0
    #define LED_GPCLR       GPIO_GPCLR0
    #define LED_GPIO_BIT    16
#endif

#define GPIO_GPFSEL0    0
#define GPIO_GPFSEL1    1
#define GPIO_GPFSEL2    2
#define GPIO_GPFSEL3    3
#define GPIO_GPFSEL4    4
#define GPIO_GPFSEL5    5

#define GPIO_GPSET0     7
#define GPIO_GPSET1     8

#define GPIO_GPCLR0     10
#define GPIO_GPCLR1     11

#define GPIO_GPLEV0     13
#define GPIO_GPLEV1     14

#define GPIO_GPEDS0     16
#define GPIO_GPEDS1     17

#define GPIO_GPREN0     19
#define GPIO_GPREN1     20

#define GPIO_GPFEN0     22
#define GPIO_GPFEN1     23

#define GPIO_GPHEN0     25
#define GPIO_GPHEN1     26

#define GPIO_GPLEN0     28
#define GPIO_GPLEN1     29

#define GPIO_GPAREN0    31
#define GPIO_GPAREN1    32

#define GPIO_GPAFEN0    34
#define GPIO_GPAFEN1    35

#define GPIO_GPPUD      37
#define GPIO_GPPUDCLK0  38
#define GPIO_GPPUDCLK1  39

/** GPIO Register set */
volatile unsigned int* gpio;

/** Simple loop variable */
volatile unsigned int tim;

// Function to change a pin's mode
static int pinMode(int pinnum, int mode);

#endif


static int pinMode(int pinnum, int mode) {
    // Variable declaration and initialization
    int fsr = 0;
    int fsrbit;
    // Let's check the pin does exist
    if (pinnum &lt; 0 || pinnum &gt; 53) {
        // Abort, there is no such pin.
        return 1;
    }
    else if (mode &lt; 0 || mode &gt; 1) {
        // Abort, invalid mode (Actually there are 7 modes but we will only use 2)
        return 1;
    }
    // Create a pointer to the GPIO perhiperal register so we can speak to it
    gpio = (unsigned int*)GPIO_BASE;
    // And calculate wich FSR we should use
    /* do {
        if (pinnum &gt; 9) {
            pinnum -= 10;
            fsr++;
        }
    } while (pinnum &gt; 9); */
    if (pinnum &gt; 9) {
        while (pinnum &gt; 9) {
            pinnum -= 10;
            fsr++;
        }
    }
        // Then we calculate the bytes of the fsreg to use
        fsrbit = pinnum * 3;
        // Finally let's set the pin to the desired mode
        gpio[fsr] |= (mode &lt;&lt; fsrbit);

        return 0;
}

int main(void)
{
    gpio = (unsigned int*)GPIO_BASE;

    /* Write 1 to the GPIO16 init nibble in the Function Select 1 GPIO
       peripheral register to enable GPIO16 as an output */
    // gpio[LED_GPFSEL] |= (1 &lt;&lt; LED_GPFBIT);
    pinMode(47, 1);

    // Never return from here
    while(1)
    {
        for(tim = 0; tim &lt; 500000; tim++)
            ;

        /* Set the LED GPIO pin low ( Turn OK LED on for original Pi, and off
           for plus models )*/
        gpio[LED_GPCLR] = (1 &lt;&lt; LED_GPIO_BIT);

        for(tim = 0; tim &lt; 500000; tim++)
            ;

        /* Set the LED GPIO pin high ( Turn OK LED off for original Pi, and on
           for plus models )*/
        gpio[LED_GPSET] = (1 &lt;&lt; LED_GPIO_BIT);
    }
}
</code></pre>

<p>along with some hackery to get it to link, not something you can use directly but main wont need to change, just bootstrap and linking.</p>

<pre><code>00001000 &lt;main&gt;:
    1000:   e52de004    push    {lr}        ; (str lr, [sp, #-4]!)
    1004:   e3a00801    mov r0, #65536  ; 0x10000
    1008:   e3a0e000    mov lr, #0
    100c:   e59f3078    ldr r3, [pc, #120]  ; 108c &lt;main+0x8c&gt;
    1010:   e59f2078    ldr r2, [pc, #120]  ; 1090 &lt;main+0x90&gt;
    1014:   e5823000    str r3, [r2]
    1018:   e5932010    ldr r2, [r3, #16]
    101c:   e3822602    orr r2, r2, #2097152    ; 0x200000
    1020:   e1a0c003    mov r12, r3
    1024:   e5832010    str r2, [r3, #16]
    1028:   e59f1064    ldr r1, [pc, #100]  ; 1094 &lt;main+0x94&gt;
    102c:   e59f3064    ldr r3, [pc, #100]  ; 1098 &lt;main+0x98&gt;
    1030:   e583e000    str lr, [r3]
    1034:   e5932000    ldr r2, [r3]
    1038:   e1520001    cmp r2, r1
    103c:   8a000005    bhi 1058 &lt;main+0x58&gt;
    1040:   e5932000    ldr r2, [r3]
    1044:   e2822001    add r2, r2, #1
    1048:   e5832000    str r2, [r3]
    104c:   e5932000    ldr r2, [r3]
    1050:   e1520001    cmp r2, r1
    1054:   9afffff9    bls 1040 &lt;main+0x40&gt;
    1058:   e58c0028    str r0, [r12, #40]  ; 0x28
    105c:   e583e000    str lr, [r3]
    1060:   e5932000    ldr r2, [r3]
    1064:   e1520001    cmp r2, r1
    1068:   8a000005    bhi 1084 &lt;main+0x84&gt;
    106c:   e5932000    ldr r2, [r3]
    1070:   e2822001    add r2, r2, #1
    1074:   e5832000    str r2, [r3]
    1078:   e5932000    ldr r2, [r3]
    107c:   e1520001    cmp r2, r1
    1080:   9afffff9    bls 106c &lt;main+0x6c&gt;
    1084:   e58c001c    str r0, [r12, #28]
    1088:   eaffffe8    b   1030 &lt;main+0x30&gt;
    108c:   20200000    eorcs   r0, r0, r0
    1090:   000110a4    andeq   r1, r1, r4, lsr #1
    1094:   0007a11f    andeq   r10, r7, pc, lsl r1
    1098:   000110a0    andeq   r1, r1, r0, lsr #1

0000109c &lt;_start&gt;:
    109c:   e1a00000    nop         ; (mov r0, r0)

Disassembly of section .bss:

000110a0 &lt;tim&gt;:
   110a0:   00000000    andeq   r0, r0, r0

000110a4 &lt;gpio&gt;:
   110a4:   00000000    andeq   r0, r0, r0
</code></pre>

<p>so the first problem is here which comes straight from your code</p>

<pre><code>    fsrbit = pinnum * 3;
    gpio[fsr] |= (mode &lt;&lt; fsrbit);

    100c:   e59f3078    ldr r3, [pc, #120]  ; 108c &lt;main+0x8c&gt;

    1018:   e5932010    ldr r2, [r3, #16]
    101c:   e3822602    orr r2, r2, #2097152    ; 0x200000
    1024:   e5832010    str r2, [r3, #16]
</code></pre>

<p>doing a read-modify-write is correct, but unless you knew the bits were zeros to start with it is best to zero them first</p>

<pre><code>gpio[fsr] &amp;= (~(7&lt;&lt;fsrbit));
gpio[fsr] |= (mode&lt;&lt;fsrbit);
</code></pre>

<p>by declaring tim as volatile the code as you can see actually counts takes a few instructions, yes it might be a 1GHZ processor but you are not running that fast, you are fetching from dram (slow), even with the cache, and you have pipe hazards, etc.  </p>

<p>As pointed out though maybe make your loop count number larger.  Another thing to try is to swap things around on/off state.</p>

<p>first this:</p>

<pre><code>while(1)
{
    gpio[LED_GPCLR] = (1 &lt;&lt; LED_GPIO_BIT);
    for(tim = 0; tim &lt; 500000; tim++) continue;

    gpio[LED_GPSET] = (1 &lt;&lt; LED_GPIO_BIT);
    for(tim = 0; tim &lt; 500000; tim++) continue;
}
</code></pre>

<p>is it on, does it glow?  then try this</p>

<pre><code>while(1)
{
    gpio[LED_GPSET] = (1 &lt;&lt; LED_GPIO_BIT);
    for(tim = 0; tim &lt; 500000; tim++) continue;

    gpio[LED_GPCLR] = (1 &lt;&lt; LED_GPIO_BIT);
    for(tim = 0; tim &lt; 500000; tim++) continue;
}
</code></pre>

<p>if the led looks the same then your count may be too small, make it larger, control the bit then do the delay not the other way around.  If it still glows and doesnt blink with set first then clear or clear first then set?  then maybe too fast still, just do this</p>

<pre><code>    gpio[LED_GPSET] = (1 &lt;&lt; LED_GPIO_BIT);
</code></pre>

<p>with no loop </p>

<p>or </p>

<pre><code>    gpio[LED_GPCLR] = (1 &lt;&lt; LED_GPIO_BIT);
</code></pre>

<p>with no loop.</p>

<p>can you make it go on and stay on?  can you make it go off and stay off?  If not then there is something wrong in the code you use to make it go on and off, if so then there maybe something wrong with your delay.  but examination of optimized code shown above the volatile is taking care of that and burning cycles.</p>

<p>your I solved with a naked answer, was deleted, so does that mean you didnt solve it?  The baking pi tutorials are nice, glad they are there, but the baremetal forum at raspberry pi has over time been littered with it (baking pi) doesnt work questions, mostly makefile/directory issues, but perhaps others.  Looks like though you get the gist of it, your gpio pointer/array style is interesting, I wouldnt go that way but so far it is working for you.</p>

<p>Ahh, wait and another bug...you didnt define RPI2 but clearly you had on the command line perhaps?</p>

<pre><code>800c:   e3433f20    movt    r3, #16160  ; 0x3f20
</code></pre>

<p>so lets try my smaller build again</p>

<pre><code>1034:   e5804020    str r4, [r0, #32]  ; 0x20
1048:   e580e02c    str lr, [r0, #44]   ; 0x2c
</code></pre>

<p>much better GPSET1 and GPCLR1  where 47 is found...so no bug there.</p>

<p>actually instead of hardcoding 47 you should have finished out your header file and used some LED_GPIO_BIT in the pinMode() call insuring you matched the LED_otherstuff to the gpio pin.</p>
",,54173340,34
44735857,2,44735630,2017-06-24T11:21:45.800,0,,6110094,,2017-06-24T11:21:45.800,,0,,"<pre><code>union 
{
uint32_t number;
uint8_t CardNumberByte[4];
} CardNum;

char cn[] = ""B763AB23"";
</code></pre>

<p>and ""conversion"":</p>

<pre><code>CardNum.Number = strtol(cn, NULL, 16);
</code></pre>

<p>and your bytes are avaiable via</p>

<pre><code>CardNum.CardNumberByte[xx]
</code></pre>

<p>But I think you should start from the begginers C++ tutorial and learn some basics.</p>
",,54183908,231
44738962,2,44737252,2017-06-24T17:13:50.363,1,,2430669,,2017-06-24T17:13:50.363,,12,,"<p>This is not right...</p>

<pre><code>   Serial.println(RESET);       // println expects a null terminated string  
                                // you are sending a char.
</code></pre>

<p>You should define dataToSend as a null-terminated char array.</p>

<pre><code>void ADS124X::reset(void)
{
  char dataToSend[] = { RESET, 0 };
  // ...
  serial.println(dataToSend);  // maybe println ""reset"" would be better?
  SPI_Write(dataToSend, 1); 
  //...
}
</code></pre>

<p>Don't expect to see a nice <code>0x06</code> on your serial monitor, since that is not a printable character.</p>
",,54189535,74
44748147,2,44748034,2017-06-25T16:06:01.837,1,,1143850,,2017-06-25T16:06:01.837,,0,,"<p>imagine your array is allocated in memory as the following</p>

<pre><code>packet 0:
  [0]
  ..
  [163]
packet 1:
  [164]
  ..
  [227]
packet 2:
  [228]
   ...
</code></pre>

<p>so, address of packet 1 is (size of the packet (164) * j(1)), where j is the packet number.
sizeof unit8 will resolve in the number of bytes needed, '1' in most cases.</p>
",,54203672,44
44754692,2,44754077,2017-06-26T07:17:53.637,0,,1266018,,2017-06-26T07:17:53.637,,0,,"<p>Question is not clear. To stop running the loop you can use break as given below. Check if this is what you're looking for.</p>

<pre><code>   void loop() {
    while(digitalRead(ctsPin) == LOW) {
        // Some code here
        if (digitalRead(ctsPin) == HIGH){
            break;
        }
        // Some code here
      }
    }
</code></pre>
",,54208786,70
44760068,2,44754077,2017-06-26T12:44:38.310,0,,5741073,,2017-06-26T13:02:06.277,2017-06-26T13:02:06.277,0,,"<p>There are two ways to break ""instantly.""  One is to use an interrupt and the other is to check for the condition more often -- after each instruction if really necessary, and break out then:</p>

<pre><code>void loop()
{
    while(digitalRead(ctsPin) == LOW)
    {
       // code block (or even a single statement)...
       if (digitalRead(ctsPin) == HIGH) break;
       // code block (or even a single statement)...
       if (digitalRead(ctsPin) == HIGH) break;
       // code block (or even a single statement)...
       if (digitalRead(ctsPin) == HIGH) break;
       // etc.
    }
}
</code></pre>

<p>If you get too many of these, it may be advisable then to look into an interrupt instead.  For an example of how to do that, and the various interrupts available for your target board, I suggest taking a look at <a href=""https://www.arduino.cc/en/Reference/AttachInterrupt"" rel=""nofollow noreferrer"">Arduino Interrupt Documentation</a>.</p>

<p>If you decide to go that way, give it a try and then if you run into issues, ask a different question and we'll help you out.</p>
",,54212549,651
44843704,2,44842834,2017-06-30T09:57:05.707,2,,919155,,2017-06-30T10:02:56.540,2017-06-30T10:02:56.540,0,,"<p>morse is an array of char. indexOf is a string (class) method.</p>

<p>You could try this:</p>

<pre><code>String char_to_morse(char letter)
{
    String morsecode[]={"".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."", ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."", ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"", ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""};

    if ((letter &gt;= 'a') &amp;&amp; (letter &lt;= 'z')) return morsecode[a - 'a'];
    else if ((letter &gt;= 'A') &amp;&amp; (letter &lt;= 'Z')) return morsecode[a - 'A'];
    else if (letter == ' ') return ""     ""; // longer space to see different words
    else return ""ERR"";
}

main() {
    String words[] = ""my message"";

    int i=0;
    String result;
    while (words[i])
    {
        result += char_to_morse(words[i]) + ' '; // use space to separate each morse code.
    }

    printf(result);
}
</code></pre>

<p>The morsecode[a - 'a']; is a quick way to return the position of the ASCII char. a=0, b=1, etc...</p>

<p>Bonus, this is case insensitive</p>
",,54216231,97
44859873,2,44856599,2017-07-01T10:28:02.493,0,,7478597,,2017-07-01T10:33:16.503,2017-07-01T10:33:16.503,0,,"<p>""La la la"" sounds for me like something I learnt 40 (fourty!) years ago in the school. I asked google and found <strong><a href=""https://en.wikipedia.org/wiki/Solmization"" rel=""nofollow noreferrer"">Solmization</a></strong>.</p>

<p>Thus, my first conclusion: <strong>Everything, we learnt in school will pay off one day (sooner or later).</strong></p>

<p>As I read some concerns about (wasted) storage (between the lines), I thought about how to make it a little bit more compact. (It would become even more compact using some clever compression techniques but this is beyond what I want to present here.)</p>

<p>As there is a limited set of syllables with not too many distinct values, I intended to store them as bytes. As bytes can be represented as characters, sequences of bytes can simply be defined as constant C strings. Constant C strings provide an end-marker (0 terminator) for free. It's possible to declare/initialize arrays of constant C strings even if they have differing lengths (as the array stores actually only the pointers to the strings). Last but not least, I exploited the fact that multiple double-quoted sequences are concatenated as one string constant (if separated by whitespace only).</p>

<p>Furthermore, I did some ""macro-magic"" to simplify the code writing. This is not very elegant but quite convenient in ""daily usage"". (The ""design goal"" was to make the source code robust against typos in the definition of <code>notes</code> as well as to keep it ""readable"".)</p>

<p>My sample <code>solmization.cc</code>:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

#define C_REST '0'
#define C_DO '1'
#define C_RE '2'
#define C_MI '3'
#define C_FA '4'
#define C_SOL '5'
#define C_LA '6'
#define C_TI '7'
#define C_DI 'a'
#define C_RI 'b'
#define C_FI 'c'
#define C_SI 'd'
#define C_LI 'e'

#define REST ""0""
#define DO ""1""
#define RE ""2""
#define MI ""3""
#define FA ""4""
#define SOL ""5""
#define LA ""6""
#define TI ""7""
#define DI ""a""
#define RI ""b""
#define FI ""c""
#define SI ""d""
#define LI ""e""

const char *notes[] = {
  DO RE MI FA,
  SOL REST MI DO REST SOL REST FA RE REST FA REST RE TI REST FA REST MI DO REST,
  REST SI DO FA MI SOL DO REST MI FA MI FA MI FA MI DO RE,
  LA LA SOL FA MI FA SOL DO DO REST MI FA MI DO FA MI DO LA SOL REST,
  REST SOL SOL FA MI RE MI DO,
  LA TI SOL FA SOL FA FA MI RE MI RE DO TI DO TI LA SOL,
  REST DO TI DO SOL REST,
  DO TI DO MI REST,
  FA MI RE DO FA MI RE DO DO RE RE DO RE,
  REST DO TI DO SOL FA FA FA FA FA MI RE MI REST RE MI FA MI MI MI RE DO MI REST,
  LA TI DO RE LA LA TI DO RE DO SOL
};

using namespace std;

int main()
{
  enum { n = sizeof notes / sizeof *notes };
  for (size_t i = 0; i &lt; n; ++i) {
    cout &lt;&lt; ""Line "" &lt;&lt; (i + 1) &lt;&lt; "":"" &lt;&lt; endl;
    const char *line = notes[i];
    for (size_t j = 0, m = strlen(line); j &lt; m; ++j) {
      switch (line[j]) {
#define CASE(SYL) case C_##SYL: cout &lt;&lt; ' ' &lt;&lt; #SYL; break
        CASE(REST);
        CASE(DO);
        CASE(RE);
        CASE(MI);
        CASE(FA);
        CASE(SOL);
        CASE(LA);
        CASE(TI);
        CASE(DI);
        CASE(RI);
        CASE(FI);
        CASE(SI);
        CASE(LI);
#undef CASE
        default: assert(false); // should be unreachable
      }
    }
    cout &lt;&lt; endl;
  }
  return 0;
}
</code></pre>

<p>Test and output:</p>

<pre><code>$ g++ -std=c++11 -o solmization solmization.cc 

$ ./solmization     
Line 1:
 DO RE MI FA
Line 2:
 SOL REST MI DO REST SOL REST FA RE REST FA REST RE TI REST FA REST MI DO REST
Line 3:
 REST SI DO FA MI SOL DO REST MI FA MI FA MI FA MI DO RE
Line 4:
 LA LA SOL FA MI FA SOL DO DO REST MI FA MI DO FA MI DO LA SOL REST
Line 5:
 REST SOL SOL FA MI RE MI DO
Line 6:
 LA TI SOL FA SOL FA FA MI RE MI RE DO TI DO TI LA SOL
Line 7:
 REST DO TI DO SOL REST
Line 8:
 DO TI DO MI REST
Line 9:
 FA MI RE DO FA MI RE DO DO RE RE DO RE
Line 10:
 REST DO TI DO SOL FA FA FA FA FA MI RE MI REST RE MI FA MI MI MI RE DO MI REST
Line 11:
 LA TI DO RE LA LA TI DO RE DO SOL

$ 
</code></pre>

<p>Notes:</p>

<ol>
<li><p>I resisted the first desire for <em>audible output</em> and made print output instead.</p></li>
<li><p>While I was transforming the original data I realized some <code>,</code> and <code>&#x60;</code> in the strings. I didn't consider them to keep the sample code short. They've probably a meaning which I don't know. I guess, following the idea of my sample it should be possible to extend the definitions appropriately.</p></li>
<li><p>I don't like the double definition of syllable macros (for character constants as well as string constants) but I didn't get a better idea. Although, I really couldn't remember that something like stringize for character constants exists I googled and found in <a href=""https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html"" rel=""nofollow noreferrer"">The C Preprocessor &ndash; 3.4 Stringizing</a> (part of the GNU gcc online docs.):</p></li>
</ol>

<blockquote>
  <p>There is no way to convert a macro argument into a character constant.</p>
</blockquote>
",,54225045,90
44868967,2,44868823,2017-07-02T08:44:03.830,0,,6049102,,2017-07-02T08:56:07.667,2017-07-02T08:56:07.667,5,,"<p>If you are having a hex value (not a string). This small program can be a good example:</p>

<p>This method extracts the individual nibble. And then joins them back.</p>

<p>We can get the least significant 4-bits by taking modulus with 16.
Then we can do left shift 4 times (divide by 16). And then extract the next least significant 4-bits.</p>

<p>Now we got the 8 LSB. Now we just append them. </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    unsigned int x = 0x40BF00FF;

    // Extracting the first 4 least significant bits.
    unsigned int one = x % 16;

    // Extracting the next 4 least significant bits.
    unsigned int two = (x &gt;&gt; 4) % 16;

    // Appending the bits and printing the result.
    printf (""%x\n"", (two &lt;&lt; 4) + one);

    return 0;
}
</code></pre>

<p>OR </p>

<p>You can use the power of bits!</p>

<p>Here, the input is stored in x. </p>

<p>I take a mask <code>0xFF</code>. </p>

<p>And I perform bitwise and operation. </p>

<p>Now, as we know </p>

<p><code>b&amp;1 = b</code> and <code>b&amp;0 = 0</code>. </p>

<p>We can use this property to extract only the lower 8 bits by setting them all to <code>1</code> and others as <code>0</code>. 
And performing a bitwise and (<code>&amp;</code>).  </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    unsigned int x = 0x40BF00FF;

    // The mask.
    unsigned int mask = 0xFF;

    // Applying bitwise and
    printf (""%x\n"", x &amp; mask);

    return 0;
}
</code></pre>
",,54250050,298
44870962,2,44868823,2017-07-02T12:44:46.127,1,,6110094,,2017-07-02T12:44:46.127,,0,,"<pre><code>uint8_t get8bits(uint32_t value, int byteNumber) 
{
 uint8_t bitShift = byteNumber * 8;
 uint32_t mask = 0xfful &lt;&lt; byteShift;

 return (value &amp; mask) &gt;&gt; bitShift;
}
</code></pre>
",,54256634,95
44894797,2,44894184,2017-07-03T23:01:03.810,1,,7815340,,2017-07-03T23:01:03.810,,5,,"<p>You're comparing strings while the inputString is set to an empty string before it can be used.
Put the string compares inside the if(stringInput) block. Also, you'll need to include the newline character in the comparison. </p>

<pre><code>void loop() 
{
   serialEvent();

   if(stringComplete)
   {
        Serial.println(inputString);
        if(inputString==""HELLO\n"")
        {
           digitalWrite(12,HIGH);
           serialEvent();
        }
        else if(inputString==""WORD\n"")
        {
           digitalWrite(13,HIGH);
           serialEvent();
        }

        inputString="""";
        stringComplete=false;
   }
}
</code></pre>
",,54280655,199
44945700,2,44940440,2017-07-06T09:58:43.263,0,,,user3177100,2017-07-06T09:58:43.263,,3,,"<p>Use poll:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;poll.h&gt;
int main()
{
    struct pollfd mypoll = { STDIN_FILENO, POLLIN|POLLPRI };
    unsigned char c, blink=1, on =1, q=1;
    while(q) {
      if( poll(&amp;mypoll, 1, 500) ) {
        c=getchar();
        switch(c) {
          case '1':
              blink = 1;
              break;
          case '2':
              blink =0;
              break;
          case 'q':
              q= 0;
              break;
       }
   }
   else{
    if (blink) {
       if (on)
          on =0;
       else 
         on =1;
     }
     printf(""%u\n"",on);
    }
  } 
  return 0;
}
</code></pre>

<p>replace the on parameter with the led functions.</p>
",,54280752,764
54482599,2,44966525,2019-02-01T15:36:32.943,0,,4140822,,2019-02-01T15:36:32.943,,0,,"<p>This works for me while polling. </p>

<pre><code>static inline int microsleep(long micros)
{
    struct timespec ts = {0, micros * MICROS_PER_NANO};
    struct timespec remainder = {0, 0};

    int retval;

    while(1)
    {
        retval = nanosleep(&amp;ts, &amp;remainder);
        if (retval &lt; 0)
        {
            if (errno == EINTR)
            {
                ts = remainder;
                errno = 0;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
    return retval;
}
</code></pre>
",,54296146,110
44990474,2,44989366,2017-07-08T20:30:11.517,3,,7893951,,2017-07-08T20:52:10.337,2017-07-08T20:52:10.337,0,,"<p>If <a href=""http://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/"" rel=""nofollow noreferrer"">this</a> is the original code you copied, then you can see that there are no macro definitions. In your example there are two macro definitions with the same name as the following <code>const int</code> declarations:</p>

<pre><code>#define ECHOPIN 10
#define TRIGPIN 9

const int TRIGPIN = 9;
const int ECHOPIN = 10;
</code></pre>

<p>The <a href=""https://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow noreferrer"">preprocessor</a> will substitute every <code>ECHOPIN</code> and <code>TRIGPIN</code> macros with their value. Therefore after the preprocessor finished its job, the code snippet above will look like:</p>

<pre><code>const int 9 = 9;
const int 10 = 10;
</code></pre>

<p>Remove either the macros or the <code>const int</code> declarations from your code and it may work.</p>
",,54316980,136
45033797,2,45033498,2017-07-11T11:51:21.030,0,,6699433,,2017-07-11T13:43:28.890,2017-07-11T13:43:28.890,8,,"<pre><code>int main()
{
  int wave[4096/100 + 1];
  for(int i = 0, j=0; i &lt; 4096; i = i + 100, j++)
    wave[j]= i;
}
</code></pre>
",,54383773,87
45159687,2,45113885,2017-07-18T06:58:46.313,0,,3082873,,2017-07-18T06:58:46.313,,0,,"<p>As long as you use rest api you will not be able to comfortably keep the session alive. So you better have websocket or MQTT like protocol where session is handled by them an you will be only responsible to push the data to server instantly on any time. </p>

<p>This <a href=""https://www.mathworks.com/help/thingspeak/use-arduino-client-to-publish-to-a-channel.html"" rel=""nofollow noreferrer"">link</a> describes how an mqtt client connection to be done on Thingspeak and pushing the data to it. </p>

<p>Some code cuts from the link :</p>

<pre><code>#include &lt;PubSubClient.h&gt;

WiFiClient client;
PubSubClient mqttClient(client);
const char* server = ""mqtt.thingspeak.com"";

mqttClient.setServer(server, 1883);
</code></pre>
",,54391285,2251
45143927,2,45143314,2017-07-17T12:08:13.747,3,,4386427,,2017-07-17T12:12:35.807,2017-07-17T12:12:35.807,0,,"<p>Using recursion is making it more complicated than necessary.</p>

<p>You can simply do:</p>

<pre><code>void binaryToAbits(unsigned int input, char *result)
{
    result[0] = (input &amp; 0x1) ? '1' : '0';
    result[1] = (input &amp; 0x2) ? '1' : '0';
    result[2] = (input &amp; 0x4) ? '1' : '0';
    result[3] = (input &amp; 0x8) ? '1' : '0';
}
</code></pre>
",,54421840,270
45238865,2,45238773,2017-07-21T13:25:03.820,1,,1983495,,2017-07-21T14:34:13.843,2017-07-21T14:34:13.843,4,,"<p>A <code>char *</code> pointer and an array are not a string. Use <code>std::string</code> instead.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;


// This function cannot be modified because
// is a part of a library
void foo(const char *bar)
{
    cout &lt;&lt; ""Result: "" &lt;&lt; bar &lt;&lt; endl;
}

int main(void)
{
    std::string values[10]; // My array of values
    char tmp[10]; // Temporary buffer for the int &gt; char conversion

    for (int i = 0; i &lt; 10; i++) {
        int samplevalue = i * 2; // Just a sample value, not important
        sprintf(tmp, ""%d"", samplevalue); // Copy the sample value to the temporary buffer
        values[i] = tmp; // Assign the value of the temp var to a position in my values array
        cout &lt;&lt; values[i] &lt;&lt; endl;
    }

    cout &lt;&lt; ""=============="" &lt;&lt; endl;


    // Here comes the problem:
    for (int i = 0; i &lt; 10; i++) {
        foo(values[i].c_str());
    }

    return 0;
}
</code></pre>

<p>When using an array, all the pointers in your <code>values</code> array point to <code>tmp</code>, you can check that by looping through <code>values</code> and printing the address like this</p>

<pre><code>fprintf(stdout, ""%p\n"", values[i]);
</code></pre>

<p>So because you <code>sprintf()</code> into <code>tmp</code> all the values, the value that will be printed is always the last one, there is no copy implied in</p>

<pre><code>values[i] = tmp;
</code></pre>

<p>that just makes <code>values[i]</code> point to <code>tmp</code>, so when you access <code>values[i]</code> you really access <code>tmp</code>.</p>

<p>With <code>std::string</code> copy occurs.</p>

<p>Also, you should probably use a string stream to write numbers into each <code>values[i]</code> directly, because <code>sprintf()</code> is very dangerous. </p>

<p>Or even better use a real c++ solution like this one,</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

// This function cannot be modified because
// is a part of a library
void foo(const char *bar)
{
    std::cout &lt;&lt; ""Result: "" &lt;&lt; bar &lt;&lt; std::endl;
}

int main(void)
{
    std::vector&lt;std::string&gt; values;
    for (int i = 0; i &lt; 10; i++) {
        values.push_back(std::to_string(2 * i));
        std::cout &lt;&lt; values[i] &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""=============="" &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; values.size(); i++) {
        foo(values[i].c_str());
    }
    return 0;
}
</code></pre>

<p>Note that now, you can change the number of elements in <code>values</code> and you can use it as an array if you need to, just read the documentation for <code>std::vector</code>.</p>
",,54446038,542
45241637,2,45241524,2017-07-21T15:38:45.413,1,,5616680,,2017-07-21T15:38:45.413,,1,,"<p>Have you tried encapsulating it in a main() method?</p>

<pre><code>#include &lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char **argv)
{
    int pid;
    pid=fork();
    if(pid==0)
    {
            //printf(""I am the child\n"");
            execlp(""/usr/bin/omxplayer"", "" "", ""/home/pi/projects/my_project/audio/my_file.wav"", NULL);
            _exit(0);
    }
    else
    {
            //printf(""I am the parent\n"");
            wait();
    }

    system(""killall omxplayer.bin"");
    return 0;
}
</code></pre>
",,54474686,100
45267685,2,45266556,2017-07-23T17:01:06.580,1,,5843430,,2017-07-23T17:49:55.667,2017-07-23T17:49:55.667,1,,"<p>Disclaimer: I don't have an Arduino to compile and test this, but from the pure C++ point of view, I would declare the member in the class declaration and initialize it in the constructor. Like this:</p>

<pre><code>class MidiHandler
{
public:
    MidiHandler(HardwareSerial&amp; serial_port)
        : midiA(serial_port)
    { }

private:
    midi::MidiInterface&lt;HardwareSerial&gt; midiA;
};
</code></pre>

<p>Then, instantiate the class like this:</p>

<pre><code>MidiHandler handler((HardwareSerial&amp;) Serial1);
</code></pre>

<p>DETAIL:</p>

<p>The <code>MidiHandler</code> class has a member variable named <code>midiA</code> of type <code>midi::MidiInterface&lt;HardwareSerial&gt;</code>, which is a template with one template parameter (the <code>Type</code> parameter from the macro). <code>HardwareSerial</code> is used as the value for the template parameter.</p>

<p>The type <code>midi::MidiInterface&lt;HardwareSerial&gt;</code> has a constructor requiring one parameter of type <code>HardwareSerial&amp;</code>. Therefore, <code>MidiHandler::MidiHandler</code>, the <code>MidiHandler</code> class constructor, needs a parameter of the same type to be used to construct <code>midiA</code>.</p>

<p>Finally, <code>Serial1</code> is passed as the constructor parameter to <code>handler</code>. <code>Serial1</code> must be of type <code>HardwareSerial&amp;</code> or convertible to it. The C stile cast, <code>(HardwareSerial&amp;)</code>, may or may not be needed depending on the type of Serial1, but I put it there since the macro had it.</p>
",,54477942,1114
45273075,2,45272529,2017-07-24T05:16:02.070,3,,1136195,,2017-07-24T05:16:02.070,,0,,"<p>This won't work as you noticed.</p>

<p>You need to use a variable, to calculate the time elapsed since last check.</p>

<pre><code>unsigned long t1;
void setup() {
  ...
  t1=millis();
}

void loop() {
  if (motion == HIGH) {
     // Motion Detected
     // Send to Gateway
  }
  if(millis()-t1&gt;20000) {
    temp = random(1, 5) + 28;
    // Send to Gateway
    t1=millis();
  }
}
</code></pre>
",,54495764,63
45560967,2,45301141,2017-08-08T06:36:55.160,0,,1889116,,2017-08-08T06:36:55.160,,0,,"<p>So you want to understand what the stated operations do. Let's have a look if we can clarify this, by examining the <code>pin5</code> variable and subdividing it into 2 parts:</p>

<pre><code>pin5              000100000000
                  MMMMLLLLLLLL
</code></pre>

<p><code>M</code> = 4 Most significant bits, <code>L</code> = 8 Least significant bits</p>

<p><code>payload[0]</code> takes the result of some operations on <code>pin5</code>:</p>

<pre><code>pin5              000100000000
&gt;&gt; 8              000000000001  Shifts all bits 8 positions to the right
                  00000000MMMM  and fills the left part with zeroes
</code></pre>

<p>so you have the originally leading 4 bits right-aligned now, on which an additional operation is performed:</p>

<pre><code>                  000000000001
&amp; 0xFF            000011111111  Anding with FF
                  000000000001
</code></pre>

<p>Right-shifting a 12-bits variable by 8 positions leaves 4 significant positions; the leading 8 bits will always be 0. <code>0xFF</code> is binary <code>11111111</code>, i.e., represents 8 set bits. So what is done here is <code>And</code>ing the 4 least significant bits with 8 least significant bits in order to make sure, that the 4 most significant bits get erased.</p>

<pre><code>                  00000000xxxx  Potentially set bits (you have 0001)
                  000011111111  &amp; 0xFF
                  00000000xxxx  Result
                      0000xxxx  Storing in 8-bits variable
payload[0] =          00000001  in your case
</code></pre>

<p>In this case, the <code>And</code>ing operation is not useful and a complete waste of time, because <code>And</code>ing any variable with <code>0xFF</code> does never change its 8 least significant bits in any way, and since the 4 most significant bits are never set anyway, there simply is no point in this operation.</p>

<p>(Technically, because the source is a 12-bits variable (presumably it is a 16 bits variable though, with only 12 significant (relevant) binary digits), <code>0x0F</code> would have sufficed for the <code>And</code>ing mask. Can you see why? But even this would simply be a wasted CPU cycle.)</p>

<p><code>payload[1]</code> also takes the result of an operation on <code>pin5</code>:</p>

<pre><code>pin5              MMMMLLLLLLLL  potentially set bits
&amp; 0xFF            000011111111  mask to keep LLLLLLLL only
                  0000LLLLLLLL  result (you have 00000000)
                      xxxxxxxx  Storing in 8-bits variable
payload[1] =          00000000  in your case
</code></pre>

<p>In this case, Anding with <code>11111111</code> makes perfect sense, because it discards <code>MMMM</code>, which in your case is <code>0001</code>.</p>

<p>So, all in all, your value</p>

<pre><code>pin5              000100000000
                  MMMMLLLLLLLL
</code></pre>

<p>is split such, that <code>payload[0]</code> contains <code>MMMM</code> (<code>0001</code> = decimal 1), and <code>payload[1]</code> contains <code>LLLLLLLL</code> (<code>00000000</code> = decimal 0).</p>

<p>If the input was</p>

<pre><code>pin5              101110010001
                  MMMMLLLLLLLL
</code></pre>

<p>instead, you would find in <code>payload[0]</code>: <code>1011</code> (decimal 8+2+1 = 11), and in <code>payload[1]</code>: <code>10010001</code> (decimal 128+16+1 = 145).</p>

<p>You would interpret this result as decimal 11 * 256 + 145 = 2961, the same result you obtain when converting the original 101110010001 from binary into decimal, for instance using <code>calc.exe</code> in Programmer mode (<code>Alt+3</code>), if you are using Windows.</p>

<p>Likewise, your original data is being interpreted as 1 * 256 + 0 = 256, as expected.</p>
",,54518123,202
45328480,2,45327750,2017-07-26T13:30:34.450,0,,187998,,2017-07-26T13:30:34.450,,3,,"<p>I think there are several possible problems with <code>myRead</code>.</p>

<p>A minor rewrite could be:</p>

<pre><code>void myRead(int i)
{
    if((digitalRead(4) == HIGH) &amp;&amp; (i&lt;5)) {
        record();
        digitalWrite(14, HIGH);
        delay(500);
        digitalWrite(14, LOW);  
        ++i;
        delay(500);
        myRead(i);
    } else if((digitalRead(4) != HIGH) &amp;&amp; (i&lt;5)) {
        myRead(i);
    }
}
</code></pre>

<p>Notice that you have two calls to <code>digitalRead</code> -- this may lead to problems since the first one my return something different from <code>HIGH</code> and the second may return <code>HIGH</code>, meaning neither conditions are true.</p>

<p>You make a call to <code>myRead</code> with the same <code>i</code> in the alternative branch as the original call. If <code>digitalRead</code> returns something different from <code>HIGH</code> suffeciently many times, your stack will be full very fast and you'll get a segfault.</p>

<p>I'll propose a different version, that <em>should</em> be identical (baring any misunderstanding on my part):</p>

<pre><code>void myRead(int i)
{
    // as long as i is less than 5
    while (i &lt; 5) {
        // busy wait for digitalRead(4) to be HIGH
        while (digitalRead(4) != HIGH);
        // do the main thing
        record();
        digitalWrite(14, HIGH);
        delay(500);
        digitalWrite(14, LOW);  
        ++i;
        delay(500);
    }
}
</code></pre>

<p>Also please note that this is just plain C, not C++ (well, technically it's valid C++, but it's making no use of C++)</p>
",,54555031,60
45378551,2,45376629,2017-07-28T16:40:55.757,2,,8382663,,2017-07-28T16:40:55.757,,8,,"<p>From what I understand, you want create an array of structs such contains both compound literals and items from another array, all defined in header information.
I don't think this is possible - or at least not in the exact way you suggest. I'll try and provide an alternative though.</p>

<blockquote>
  <p>Can I assume that I can use an identical populated struct in the place of what is inside the curly brackets?</p>
</blockquote>

<p>No - you're mixing your types. 'files' is defined as an array of 'struct t_website'.
The code</p>

<pre><code>struct t_websitefiles files[] = {
    ...
    &amp;default_files[1],
    ...
}
</code></pre>

<p>won't compile as you are mixing your types. <em>files</em> is defined as an array of <em>struct t_websitefile</em>, but <em>&amp;default_files[1]</em> is a pointer. C makes a distinction between pointers and non-pointers. They are seperate types.</p>

<p>The obvious option that I can see to do what you want is to use pointers. This will allow you to define everything in header information.  </p>

<pre><code>struct t_websitefiles default_files[] = {
   ....
}
struct t_websitefiles files[] = {
   ....
}

// An array of pointers
struct t_websitefiles *files_combined[] = {
    &amp;files[0],
    &amp;files[1],
    &amp;default_files[0],
    // Or whatever values you want here
    ...
}

// Example main, just iterates through the combined list
//  of files
int main(int argc, char* argv[]) {
    int i;
    int files_combined_len = sizeof(files_combined)/sizeof(struct t_websitefiles);

    for (i=0; i&lt;files_combined_len; i++) {
        printf(""File %s\r\n"", files_combined[i]-&gt;path);
    }

    return 0;
}
</code></pre>

<p>Hope this helps.</p>
",,54562271,66
45382204,2,45379362,2017-07-28T20:50:17.770,3,,6301420,,2017-07-29T14:59:02.550,2017-07-29T14:59:02.550,3,,"<p>Here is a small implementation of compile-time filtering, reproducing small parts of the standard library in a minimalist way.  It includes an example of usage at the end.  (It probably isn't possible to implement the filtering as a function, since C++ doesn't allow the result type of a function to depend on the values of the arguments.  So, you would have to have the result type have enough storage for the case where the predicate always returns <code>true</code> which seems like it would be a show-stopper for your use case.  That is why the approach here is to do the filtering using template metaprogramming first, and then convert the results to an <code>array</code> wrapper object.)</p>

<pre><code>#include &lt;sys/types.h&gt;

template &lt;typename T, size_t N&gt;
struct array {
    T elem[N];
    constexpr size_t size() const { return N; }
    constexpr T operator[](size_t i) const { return elem[i]; }
    T* begin() { return elem; }
    const T* begin() const { return elem; }
    T* end() { return elem + N; }
    const T* end() const { return elem; }
};
template &lt;typename T&gt;
struct array&lt;T, 0&gt; {
    constexpr size_t size() const { return 0; }
    T* begin() { return nullptr; }
    const T* begin() const { return nullptr; }
    T* end() { return nullptr; }
    const T* end() const { return nullptr; }
};

template &lt;typename T, T... x&gt;
struct static_sequence { };

template &lt;bool p, typename TrueT, typename FalseT&gt;
struct conditional;
template &lt;typename TrueT, typename FalseT&gt;
struct conditional&lt;true, TrueT, FalseT&gt; {
    using type = TrueT;
};
template &lt;typename TrueT, typename FalseT&gt;
struct conditional&lt;false, TrueT, FalseT&gt; {
    using type = FalseT;
};
template &lt;bool p, typename TrueT, typename FalseT&gt;
using conditional_t = typename conditional&lt;p, TrueT, FalseT&gt;::type;

template &lt;typename T, T x, typename S&gt;
struct static_sequence_cons;
template &lt;typename T, T x, T... Ss&gt;
struct static_sequence_cons&lt;T, x, static_sequence&lt;T, Ss...&gt;&gt; {
    using type = static_sequence&lt;T, x, Ss...&gt;;
};
template &lt;typename T, T x, typename S&gt;
using static_sequence_cons_t = typename static_sequence_cons&lt;T, x, S&gt;::type;

template &lt;typename T, bool(*pred)(T), T... N&gt;
struct filter;
template &lt;typename T, bool(*pred)(T)&gt;
struct filter&lt;T, pred&gt; {
    using type = static_sequence&lt;T&gt;;
};
template &lt;typename T, bool(*pred)(T), T hd, T... tl&gt;
struct filter&lt;T, pred, hd, tl...&gt; {
private:
    using filter_tl = typename filter&lt;T, pred, tl...&gt;::type;
public:
    using type = conditional_t&lt;pred(hd),
                               static_sequence_cons_t&lt;T, hd, filter_tl&gt;,
                               filter_tl&gt;;
};
template &lt;typename T, bool(*pred)(T), T... N&gt;
using filter_t = typename filter&lt;T, pred, N...&gt;::type;

template &lt;ssize_t curr_index, typename T, bool(*pred)(T), T... N&gt;
struct filter_index;
template &lt;ssize_t curr_index, typename T, bool(*pred)(T)&gt;
struct filter_index&lt;curr_index, T, pred&gt; {
    using type = static_sequence&lt;ssize_t&gt;;
};
template &lt;ssize_t curr_index, typename T, bool(*pred)(T), T hd, T... tl&gt;
struct filter_index&lt;curr_index, T, pred, hd, tl...&gt; {
    using type = conditional_t&lt;pred(hd),
        static_sequence_cons_t&lt;ssize_t, curr_index, typename filter_index&lt;curr_index + 1, T, pred, tl...&gt;::type&gt;,
        static_sequence_cons_t&lt;ssize_t, -1, typename filter_index&lt;curr_index, T, pred, tl...&gt;::type&gt;&gt;;
};
template &lt;typename T, bool(*pred)(T), T... N&gt;
using filter_index_t = typename filter_index&lt;0, T, pred, N...&gt;::type;

template &lt;typename T, T... x&gt;
constexpr array&lt;T, sizeof...(x)&gt; static_sequence_to_array(
    static_sequence&lt;T, x...&gt;) {
    return array&lt;T, sizeof...(x)&gt; { x... };
}


//
// EXAMPLE USAGE
//
constexpr bool even(int n) {
    return n % 2 == 0;
}
constexpr auto x = static_sequence_to_array(
    filter_t&lt;int, even, 0, 1, 2, 3, 4&gt;{});
constexpr auto i = static_sequence_to_array(
    filter_index_t&lt;int, even, 0, 1, 2, 3, 4&gt;{});

static_assert(x.size() == 3, ""Bad filter"");
static_assert(x[0] == 0, ""Bad filter"");
static_assert(x[1] == 2, ""Bad filter"");
static_assert(x[2] == 4, ""Bad filter"");
static_assert(i.size() == 5, ""Bad filter_index"");
static_assert(i[0] == 0, ""Bad filter_index"");
static_assert(i[1] == -1, ""Bad filter_index"");
static_assert(i[2] == 1, ""Bad filter_index"");
static_assert(i[3] == -1, ""Bad filter_index"");
static_assert(i[4] == 2, ""Bad filter_index"");
</code></pre>
",,54583818,5340
45395554,2,45379362,2017-07-30T01:33:28.547,0,,2960823,,2017-07-30T02:53:27.090,2017-07-30T02:53:27.090,0,,"<p>My own answer just to put things together from a mundane point of view.</p>

<p>It is heavily based on Daniel Schepler's solution. I certainly would still be stuck on this problem without his help. Rewriting my own version was more like a learning exercise.</p>

<pre><code>//////////////////////////////////////////////////////////////////////////////
// should allow to compile outside Arduino environment without std includes
typedef unsigned char uint8_t;
typedef unsigned size_t;

//////////////////////////////////////////////////////////////////////////////
// pseudo-stl

// barebone std::array
template &lt;typename T, size_t N&gt; struct array {
    T elem[N];
    constexpr size_t size() { return N; }
    constexpr T operator[](size_t i) { return elem[i]; }
};

// barebone std::integer_sequence
template &lt;typename T, T... Values&gt; struct integer_sequence
{
    typedef T value_type;
};

//////////////////////////////////////////////////////////////////////////////
// sequence filtering

// predicate functions prototype (means the sequence type must be convertible to int)
typedef bool(*predicate)(int);

// LISP-like 'if' (selects a parameter according to a boolean value)
template &lt;bool Check, typename IfTrue, typename IfFalse&gt; struct s_if;
template &lt;typename IfTrue, typename IfFalse&gt; struct s_if&lt;true , IfTrue, IfFalse&gt; {using type = IfTrue ;};
template &lt;typename IfTrue, typename IfFalse&gt; struct s_if&lt;false, IfTrue, IfFalse&gt; {using type = IfFalse;};
template &lt;bool Check, typename IfTrue, typename IfFalse&gt;
using f_if = typename s_if&lt;Check, IfTrue, IfFalse&gt;::type;

// LISP-like 'cons' for integer_sequence
template &lt;typename T, T Car, typename Cdr&gt; struct s_integer_sequence_cons;
template &lt;typename T, T Car, T... Cdr&gt; struct s_integer_sequence_cons&lt;T, Car, integer_sequence&lt;T, Cdr...&gt;&gt;
{ using type = integer_sequence&lt;T, Car, Cdr...&gt;; };
template &lt;typename T, T Car, typename Cdr&gt;
using f_cons = typename s_integer_sequence_cons&lt;T, Car, Cdr&gt;::type;

// LISP-like 'append' for integer_sequence
template &lt;typename T, typename S1, typename S2&gt; struct s_integer_sequence_append;
template &lt;typename T, T... S1, T... S2&gt; struct s_integer_sequence_append&lt;T, integer_sequence&lt;T, S1...&gt;, integer_sequence&lt;T, S2...&gt;&gt;
{ using type = integer_sequence&lt;T, S1..., S2...&gt;; };
template &lt;typename S1, typename S2&gt;
using f_append = typename s_integer_sequence_append&lt;S1::value_type, S1, S2&gt;::type;

// filter an integer_sequence according to a predicate
template &lt;typename Sequence, predicate pred&gt; struct s_filter;
template &lt;typename T, predicate pred&gt; struct s_filter&lt;integer_sequence&lt;T&gt;, pred&gt;
{
    using type = integer_sequence&lt;T&gt;; // termination condition
};
template &lt;typename T, T Car, T...Cdr, predicate pred&gt; struct s_filter&lt;integer_sequence&lt;T, Car, Cdr...&gt;, pred&gt;
{
    using tail = typename s_filter&lt;integer_sequence&lt;T, Cdr...&gt;, pred&gt;::type; // forward recursion on the sequence tail
    using type = f_if&lt;pred(Car),            // if current element satisfies the predicate
                      f_cons&lt;T, Car, tail&gt;, // add it to the list
                      tail&gt;;                // else skip it
};
template &lt;typename Sequence, predicate pred&gt;
using f_filter = typename s_filter&lt;Sequence, pred&gt;::type;

//////////////////////////////////////////////////////////////////////////////
// now for the indexation...

// returns the index of a value in a list of values, or -1 if not found
template &lt;int I  , typename T&gt; constexpr T find_index (T elem) { return -1; }
template &lt;int I=0, typename T, typename... List&gt; constexpr T find_index (T elem, T val, List... rest)
{ return elem == val ? I : find_index&lt;I+1&gt;(elem, rest...); }

// builds an index list allowing to reach each value final position from their initial position
template &lt;typename Target, typename Origin&gt; struct s_index_list;
template &lt;typename T, typename Origin&gt; struct s_index_list&lt;integer_sequence&lt;T&gt;, Origin&gt;
{ 
    using type = integer_sequence&lt;T&gt;; // termination of the Target list
};
template &lt;typename T, T Car, T... Cdr, T...Origin&gt; struct s_index_list&lt;integer_sequence&lt;T, Car, Cdr...&gt;, integer_sequence&lt;T, Origin...&gt;&gt;
{
    // as usual, the only way to loop is to recurse...
    using tail = typename s_index_list&lt;integer_sequence&lt;T, Cdr...&gt;, integer_sequence&lt;T, Origin...&gt;&gt;::type;
    using type = f_cons&lt;T, find_index(Car, Origin...), tail&gt;;
};
template &lt;typename Target, typename Origin&gt;
using f_index = typename s_index_list&lt;Target, Origin&gt;::type;

//////////////////////////////////////////////////////////////////////////////
// implementing sequences as arrays

// turn an integer_sequence into a (constant) array
template &lt;typename T, T... x&gt; constexpr array&lt;T, sizeof...(x)&gt; integer_sequence_to_array(integer_sequence&lt;T, x...&gt;)
{ return array&lt;T, sizeof...(x)&gt; { x... }; }

//////////////////////////////////////////////////////////////////////////////
// Putting all this marvelous piece of engineering to use
//

// our initial list
#define input_list 2,10,4,7,9,3

// convert the list into a sequence
typedef integer_sequence&lt;uint8_t, input_list&gt; input_sequence;

// define filtering predicates
constexpr bool test_group_1(int n) { return (n &gt;&gt; 3) == 0; } // values from 0 to 7
constexpr bool test_group_2(int n) { return (n &gt;&gt; 3) == 1; } // values from 8 to 15

// compute the two split sequences
typedef f_filter&lt;input_sequence, test_group_1&gt; sequence_1; // &lt;unsigned char, 2u, 4u, 7u, 3u&gt;
typedef f_filter&lt;input_sequence, test_group_2&gt; sequence_2; // &lt;unsigned char, 10u, 9u&gt;

// append them
typedef f_append&lt;sequence_1, sequence_2&gt; output_sequence; // &lt;unsigned char, 2u, 4u, 7u, 3u, 10u, 9u&gt;

// compute indexes
typedef f_index&lt;output_sequence, input_sequence&gt; output_indexes; // &lt;unsigned char, 0u, 2u, 3u, 5u, 1u, 4u&gt;

// turn the results into arrays
constexpr auto const_values  = integer_sequence_to_array(output_sequence{}); // [2, 4, 7, 3,10, 9]
constexpr auto const_indexes = integer_sequence_to_array(output_indexes {}); // [0, 2, 3, 5, 1, 4]
</code></pre>

<h1>A few afterthoughts</h1>

<p>The purpose of this code is to generate a couple of integer arrays at compile time. This could easily be done with 20 lines of any language able to handle text files (Python, PHP, Perl, awk, you name it...), doing the trivial filtering and indexing in a couple of loops and replacing the line</p>

<pre><code>#define my_list 2,10,4,7,9,3
</code></pre>

<p>with</p>

<pre><code>const int    filtered_list [] = {2,4,7,3};
const size_t filtered_index[] = {0,-1,1,2,-1,3};
</code></pre>

<p>before passing the modified source to the actual C++ compiler.</p>

<p>The only reason I wanted a self-contained C++ program is the Arduino environment. It is meant to be very simple, and as such is considerably restrictive. You can't really ask a casual Arduino programmer to tweak makefiles or use external code generation tools, so if you want to provide an ""Arduino-friendly"" module you're basically stuck with this stdlib-less gnu++11 compiler. </p>

<p>Now since the C++ preprocessor is clearly not up to that kind of job, the only choice left is template metaprogramming.</p>

<p>I can't say I really understand how it works, I just used it as a last resort. I'm an embedded software programmer, and my functional programming skills are certainly nothing to write home about.</p>

<p>Still I tried to put my rusty LISP notions to good use, but basic tools like <code>cons</code>, <code>append</code> or <code>if</code> were apparently nowhere to be found, and re-writing them from scratch felt largely like trying to reinvent the wheel. Having to coax the pattern-matching engine into recursion to implement simple loops was also rather painful and made for pretty eye-watering code. Hopefully there's a few useful tricks I missed there.</p>

<p>All this being said, and to my surprise, the lack of <code>stdlib</code> was not really a problem. You can whip up the bare minimum in a few lines of code, provided you throw caution to the wind and kiss the syntactic sugar goodbye.  </p>

<p>I finally came up with something that actually does the job in a bit less than 100 lines of very obfuscated code.</p>

<p>I'm not looking for efficiency here, my lists will hardly hold more than a dozen values, but I sure would be happy to watch and learn a way to achieve the same result with less source code. Any takers?</p>
",,54593409,638
45425413,2,45379362,2017-07-31T21:15:26.337,1,,8396330,,2017-07-31T21:15:26.337,,1,,"<p>There is a way to avoid most of the boilerplate using function templates instead of full classes. The last class template is needed because there is no return type deduction for functions in c++11. <em>int</em> is used instead of <em>typename T</em> to skip unimportant template parameters. The code could be slimmed further when atmel updates their toolchain to gcc5 or newer with c++14 support.</p>

<pre><code>#define LIST  2,10,4,7,9,3
constexpr bool less8(int v) { return v &lt; 8; }

typedef bool(*predicate)(int);

template&lt;int... values&gt;
struct seq {};

template&lt;int N&gt;
struct array {
      const int   data[N];
};

template&lt;int... values&gt;
constexpr array&lt;sizeof...(values)&gt; to_array(seq&lt;values...&gt;) { return {{ values... }}; }

template&lt;typename trueType, typename falseType&gt;
constexpr falseType select(seq&lt;0&gt;, trueType, falseType) { return {}; }

template&lt;typename trueType, typename falseType&gt;
constexpr trueType select(seq&lt;1&gt;, trueType, falseType) { return {}; }

template&lt;int... first, int... second&gt;
constexpr seq&lt;first..., second...&gt; append(seq&lt;first...&gt;, seq&lt;second...&gt;) { return {}; }

template&lt;predicate p, typename N, typename V&gt;
struct filter_impl;

template&lt;predicate p, int next&gt;
struct filter_impl&lt;p, seq&lt;next&gt;, seq&lt;&gt;&gt; {
      using type = seq&lt;&gt;;
};

template&lt;predicate p, int next, int first, int... rest&gt;
struct filter_impl&lt;p, seq&lt;next&gt;, seq&lt;first, rest...&gt;&gt; {
      using type = decltype(
            append(
                  select(seq&lt;p(first)&gt;{}, seq&lt;next&gt;{}, seq&lt;-1&gt;{}),
                  typename filter_impl&lt;p, decltype(select(seq&lt;p(first)&gt;{}, seq&lt;next+1&gt;{}, seq&lt;next&gt;{})), seq&lt;rest...&gt;&gt;::type{}
            )
      );
};

extern constexpr auto  const_indices = to_array(filter_impl&lt;less8, seq&lt;0&gt;, seq&lt;LIST&gt;&gt;::type{});
</code></pre>
",,54611864,771
45394497,2,45391453,2017-07-29T22:04:42.977,1,,214671,,2017-07-30T12:57:48.323,2017-07-30T12:57:48.323,13,,"<p>First of all, your loop never ends, and goes on incrementing <code>j</code> without bounds, so, after you filled the screen once, you go on looping outside of the screen height; although your library <a href=""https://github.com/adafruit/Adafruit_SHARP_Memory_Display/blob/master/Adafruit_SharpMem.cpp#L202"" rel=""nofollow noreferrer"">does bounds checking</a>, it's certainly not a productive use of CPU to keep on looping without actually doing useful work until <code>j</code> overflows and goes back to zero.</p>

<p>Also, signed overflow is undefined behavior in C++, so you are technically on shaky grounds (I originally thought that Arduino always compiles with <code>-fwrapv</code> which guarantees wraparound on signed integer overflow, <a href=""https://github.com/arduino/Arduino/pull/4624"" rel=""nofollow noreferrer"">but apparently I was mistaken</a>).</p>

<p>Given that the library you are using keeps the whole framebuffer in memory and sends it all on <code>refresh</code> calls, it doesn't make much sense to re-send it at each pixel - especially since the frame transmission is probably going to be by far the slowest part of this loop. So, you can move it out of the loop.</p>

<p>Putting this together (plus caching width and height and using the simpler overload of <code>random</code>), you can change this to:</p>

<pre><code>void testdrawnoise() {
    int w = display.width(), h = display.height();
    for (int j=0; j&lt;h; ++j) {
        for (int i=0; i&lt;w; ++i) {
            display.drawPixel(i, j, random(2));
        }
    }
    display.refresh();
}
</code></pre>

<p>(if your screen dimensions are smaller than 256 on AVR Arduinos you <em>may</em> gain something by changing all those <code>int</code> to <code>byte</code>, but don't take my word for it)</p>

<p>Notice that this will do it just once, you can put it into your <code>loop()</code> function or in an infinite loop to make it keep generating random patterns.</p>

<hr>

<p>This is what you can do with the provided interface; now, going into undocumented territory we can go faster.</p>

<p>As stated above, the library you are using keeps the whole framebuffer in memory, packed (as expected) at 8 bits per byte, in a single global variable named <a href=""https://github.com/adafruit/Adafruit_SHARP_Memory_Display/blob/master/Adafruit_SharpMem.cpp#L50"" rel=""nofollow noreferrer""><code>sharpmem_buffer</code></a>, initialized <a href=""https://github.com/adafruit/Adafruit_SHARP_Memory_Display/blob/master/Adafruit_SharpMem.cpp#L87"" rel=""nofollow noreferrer"">with a <code>malloc</code> of the obvious size</a>.</p>

<p>It should also be noted that, when you ask for a random bit in your code, the PRNG generates a full 31-bit random number and takes just the low bit. Why waste all the other perfectly good random bits?</p>

<p>At the same time, when you call <code>drawPixel</code>, the library performs a series of boolean operations on the corresponding byte in memory to set just the bit you asked for without touching the rest of the bits. Quite stupid, given that you are going to overwrite the other ones with random anyway.</p>

<p>So, putting together these two facts, we can do something like:</p>

<pre><code>void testdrawnoise() {
    // access the buffer defined in another .cpp
    extern byte *sharpmem_buffer;
    byte *ptr = sharpmem_buffer; // pointer to current position
    // end position
    byte *end = ptr + display.width()*display.height()/8;
    for (; ptr!=end; ++ptr) {
        // store a full byte of random
        *ptr = random(256);
    }
    display.refresh();
}
</code></pre>

<p>which, subtracted the <code>refresh()</code> time, should be <em>at very least</em> 8 times faster than the previous version (I actually expect significantly more, given that not only the core of the loop executes 1/8th of iterations, but it's also way simpler - no function calls besides <code>random</code>, no branches, no boolean operations on memory).</p>

<p>On AVR Arduinos the only point that can be optimized further is probably the RNG - we are still using only 8 bit of a 31 bit (if they are actually 31 bits? Arduino documentation as usual sucks badly at providing useful technical information) RNG, so we could probably generate 3 bytes of random out of a single RNG call, or 4 if we switched to a hand-rolled LCG that didn't mess with the sign bit. On ARM Arduinos, in this last case, we could even gain something by performing full 32-bit stores in memory instead of writing single bytes.</p>

<p><del>However, these further optimizations are (1) tedious to write (if you have to handle screens where the number of pixels is not multiple of 24/32) and (2) probably not particularly profitable, given that most of the time will be spent in transmission over the SPI anyway. Worth mentioning them anyway, as they may be useful in other cases where there's no transmission bottleneck to slow everything down.</del></p>

<p>Given that OP's MCU is actually a Cortex M0 (so, a 32 bit ARM), it's worth trying to make it even faster using a full 32 bit PRNG and 32 bit stores.</p>

<p>As said above, built-in <code>random</code> returns a signed value, and it's not exactly clear what range it provides; for this reason, we'll have to roll our own PRNG that is guaranteed to provide 32 full bits of randomness.</p>

<p>A decent and very fast PRNG that provides 32 random bits with minimal state is <a href=""https://en.wikipedia.org/wiki/Xorshift"" rel=""nofollow noreferrer"">xorshift</a>; we'll just use the xorshift32 straight from Wikipedia, as we don't really need the improved ""*"" or ""+"" versions (nor we really care about having a bigger period provided by the larger counterparts).</p>

<pre><code>struct XorShift32 {
    uint32_t state = 0x12345678;
    uint32_t next() {
        uint32_t x = state;
        x ^= x &lt;&lt; 13;
        x ^= x &gt;&gt; 17;
        x ^= x &lt;&lt; 5;
        state = x;
        return x;
    }
};

XorShift32 xorShift;
</code></pre>

<p>Now we can rewrite <code>testdrawnoise()</code>:</p>

<pre><code>void testdrawnoise() {
    int size = display.width()*display.height();
    // access the buffer defined in another .cpp
    extern byte *sharpmem_buffer;
    /*
        we can access the framebuffer as if it was an array of 32-bit words;
        this is fine, since it was alloc-ed with malloc, which guarantees memory
        aligned for the most restrictive built-in type, and the library only
        uses it with byte pointers, so there should be no strict aliasing problem
    */
    uint32_t *ptr = (uint32_t *)sharpmem_buffer;
    /*
        notice that the division is an integer division, which truncates; so, we
        are filling the framebuffer up the the last multiple of 4 bytes; with
        ""strange"" sizes we may be leaving out up to 3 bytes (see later)
    */
    uint32_t *end = ptr + size/32;
    for (; ptr!=end; ++ptr) {
        // store a full byte of random
        *ptr = xorShift.next();
    }
    // now to fill the possibly missing last three bytes
    // pick it up where we left it
    byte *final_ptr = (byte *)end;
    byte *final_end = sharpmem_buffer + size/8;
    // generate 32 random bits; it's ok, we'll need at most 24
    uint32_t r = xorShift.next();
    for(; final_ptr!=final_end; ++final_ptr) {
        // take the lower 8 bits
        *final_ptr = r;
        // throw away the bits we used, get in the upper ones
        r = r&gt;&gt;8;
    }
    display.refresh();
}
</code></pre>
",,54618065,96
45396430,2,45396221,2017-07-30T04:38:33.197,5,,8022450,,2017-07-30T05:07:36.863,2017-07-30T05:07:36.863,3,,"<p>The whitespace is fouling the conversion. Try this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;
using namespace std;

unsigned long hexToDec(string hexString) {
  unsigned long decValue = 0;
  char nextInt;
  for ( long i = 0; i &lt; hexString.length(); i++ ) {
    nextInt = toupper(hexString[i]);
    if( isxdigit(nextInt) ) {
        if (nextInt &gt;= '0' &amp;&amp; nextInt &lt;= '9') nextInt = nextInt - '0';
        if (nextInt &gt;= 'A' &amp;&amp; nextInt &lt;= 'F') nextInt = nextInt - 'A' + 10;
        decValue = (decValue &lt;&lt; 4) + nextInt;
    }
  }
  return decValue;
}

int main() {
    string test = ""00 00 00 0c 1e"";
    printf(""'%s' in dec = %ld\n"", test.c_str(), hexToDec(test));
    return 0;
}

output:
'00 00 00 0c 1e' in dec = 3102
</code></pre>
",,54658621,67
45398726,2,45396221,2017-07-30T10:17:05.067,2,,214671,,2017-07-30T10:17:05.067,,0,,"<ol>
<li>Why are you hardcoding ASCII values? Just use <code>char</code> literals - <code>'0'</code>, <code>'9'</code>, <code>'a'</code>, <code>'f'</code>, ...; they are way more readable.</li>
<li>There's no need to all those <code>map</code>, simple math operations will do; also, there's no need for <code>constrain</code>, it's only hiding your problem (see next point).</li>
<li>If you meet a character that is not in the <code>[0-9a-fA-F]</code> range instead of skipping it you are just constraining its ASCII value to 0-15, which is definitely not what you want to do.</li>
</ol>

<p>So:</p>

<pre><code>unsigned long hexToDec(String hexString) {
    unsigned long ret;
    for(int i=0, n=hexString.length(); i!=n; ++i) {
        char ch = hexString[i];
        int val = 0;
        if('0'&lt;=ch &amp;&amp; ch&lt;='9')      val = ch - '0';
        else if('a'&lt;=ch &amp;&amp; ch&lt;='f') val = ch - 'a' + 10;
        else if('A'&lt;=ch &amp;&amp; ch&lt;='F') val = ch - 'A' + 10;
        else continue; // skip non-hex characters
        ret = ret*16 + val;
    }
    return ret;
}
</code></pre>

<p>Notice that this will provide the correct result if the data you are getting is a <em>big-endian</em> dump of some integer.</p>
",,54671220,1419
45410990,2,45409990,2017-07-31T08:36:55.000,0,,4713758,,2017-07-31T08:36:55.000,,0,,"<p>Serge Ballesta pointed out the problem: you set the fourth element of the <code>cmd</code> array to the value of a pointer to a string, which is not what you intended to do.</p>

<p>Instead, you can initialize the structure at the same time as it is declared, as in the following example (it is not explicit Arduino code, but C/C++ compatible).</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct myStruct {
  char cmd[4];
  double b;
  long c;
} myStruct;


int main(int argc, char const *argv[])
{
  myStruct s = {
    ""def"", 3.0, 10000
  };
  printf(""{%s, %f, %li}"", s.cmd, s.b, s.c);
  return 0;
}
</code></pre>

<p>Saving this to a file <code>structTest.c</code>, compiling and running:</p>

<pre><code>$ gcc structTest.c -o structTest
$ ./structTest.exe
{def, 3.000000, 10000}
</code></pre>
",,54706042,78
45530344,2,45530229,2017-08-06T08:58:43.953,0,,1626132,,2017-08-06T08:58:43.953,,3,,"<p>First of all you can not put a string in a char variable, you can however create a null terminated C string as follows:</p>

<pre><code>char* x1 = ""hello"";
char* x2 = ""world"";
char* x3 = ""hi"";
</code></pre>

<p>then you can print them individually or if you want to use a for loop, place them in an array as follows:</p>

<pre><code>char* sentence[3];

sentence[0] = ""hello"";
sentence[1] = ""world"";
sentence[2] = ""hi"";
for(int i=0; i&lt;sizeof(sentence); i++)
{
// words will be displayed one at a time
  lcd.clear();
  lcd.setCursor(0,0);   
  lcd.print( sentence[i]);
}
</code></pre>
",,54721928,649
45548909,2,45537419,2017-08-07T14:07:00.773,0,,2410359,,2017-08-07T14:07:00.773,,0,,"<blockquote>
  <p>is there a better way to achieve this?</p>
</blockquote>

<p>Rather than save the character bitmap in a rotated way, save it packed in 5 bytes.</p>

<p>To pack at compile time:</p>

<ol>
<li><p>Create 32 constants (or <code>eunm</code>)</p>

<pre><code>#define L_____ 0
#define L____X 1
#define L___X_ 2
...
#define LXXXX_ 30
#define LXXXXX 31
</code></pre></li>
<li><p>Make macros</p>

<pre><code>#define PACK8_5(a,b,c,d,e,f,g,h) \
  ((((((uint64_t)(a) &lt;&lt; 5) + (b)) &lt;&lt; 5) + (c)) &lt;&lt; 5) + (d) ...
#define UNPACK40_5(a) \
  ((a) &gt;&gt; 32) &amp; 31, ((a) &gt;&gt; 24) &amp; 31, ((a) &gt;&gt; 16) &amp; 31, ((a) &gt;&gt; 8) &amp; 31, (a) &amp; 31 
#define CHBM(a,b,c,d,e,f,g,h) (UNPACK40_5(PACK8_5((a),(b),(c),(d),(e),(f),(g),(h))))
</code></pre></li>
<li><p>Make the character bit map.  What is nice about this is that the source code can look like the character bitmap.</p>

<pre><code>unsigned char letter[5] = { CHBM( \
  L__X__, \
  L_X___, \
  L_____, \
  LXXXXX, \
  LX____, \
  LXXXX_, \
  LX____, \
  LXXXXX) };
</code></pre></li>
</ol>

<p>To unpack at run time - various methods possible.  Below is a simple idea.</p>

<pre><code>void unpack5to8(unsigned char dest[8], const unsigned char src[5]) {
  uint64_t pack = src[0];
  for (unsigned i=1; i&lt;5; i++) {
    pack &lt;&lt;= 8;
    pack += src[i];
  }
  for (unsigned i=8; i&gt;0; ) {
    i--;
    dest[i] = pack &amp; 31;
    pack &gt;&gt;= 5;
  }
</code></pre>

<p>Another idea would use more code but 32-bit variables.  This is where OP can profile different codes.</p>
",,54724651,685
45556303,2,45538674,2017-08-07T21:56:46.310,1,,6110094,,2017-08-07T22:15:47.240,2017-08-07T22:15:47.240,0,,"<p>Very simple answer. When main returns on most AVR toolchains it evecutes cli instruction disabling the interrupts and then ends in the infinitive loop. This is the most common epilogue routine in the AVR bare metal toolchains. </p>

<p>This is what is happening when you exit from the <code>main</code> </p>

<pre><code>00000078 &lt;_exit&gt;:
  78:   f8 94           cli

0000007a &lt;__stop_program&gt;:
  7a:   ff cf           rjmp    .-2         ; 0x7a &lt;__stop_program&gt;
</code></pre>

<p>You can change it by amending the startup assembly file (it contains the epilogue as well). </p>
",,54744985,337
45559888,2,45556886,2017-08-08T05:24:19.583,1,,2254698,,2017-08-09T01:49:45.097,2017-08-09T01:49:45.097,2,,"<p>The <code>package</code> variable is being streamed as 12, unsigned 8-bit integers in your MATLAB code, so I would use a <code>char[12]</code> array in C++.  You can double check <code>sizeof(char)</code> on your platform to ensure that <code>char</code> is only 1 byte.  </p>

<p>Yes, MATLAB default data-type is a <code>double</code>, but that does not mean your vector V isn't filled with integer values.  You have to look at this data or the specs from your equipment to figure this out.  </p>

<p>Whatever the values are coming in, you are setting/clipping the outgoing range to [-100, 100] and then offsetting them to the byte range [0, 255].  </p>

<p>If you do not know a whole lot about MATLAB, you may be able to leverage what you know from C++ and use C as an interim.  MATLAB's fwrite functionality lines up with that of C's, and you can include these functions in C++ with the <code>#include&lt;cstdio.h&gt;</code> preprocessor directive.  </p>

<p>Here is an example solution:</p>

<pre><code>#include &lt;cstdio.h&gt;    // fwrite 
#include &lt;algorithm&gt;  // min, max
...

void makeAndSendPackage(int * a6x1array, FILE * fHandles, int numHandles){

   char packageBuffer[13] = {'B','D',24,0,0,0,0,0,0,'P','\n','\r',0};

   for(int i=0;i&lt;6;i++){
       int tmp = a6x1array[i];
       packageBuffer[i+3] = tmp&lt;0: abs(max(-100,tmp))+144 ? min(100,tmp)+16;
   }

   for(int i=0;i&lt;6;i++){
       fwrite(fHandles[i],""%s"",packageBuffer);
   }

}
</code></pre>

<p>Let me know if you have questions about the above code.  </p>
",,54767297,113
45621009,2,45578320,2017-08-10T18:25:14.473,0,,3447123,,2017-08-13T22:06:22.593,2017-08-13T22:06:22.593,0,,"<p>Thank for your help. So I created a solution with class style:</p>

<pre><code>#include ""Blink.h""

#include &lt;util/delay.h&gt;
#include ""Arduino.h""

#define boardLedOn PORTB  |= (1 &lt;&lt; DDB5);
#define boardLedOff PORTB &amp;= ~(1 &lt;&lt; DDB5); // inverse bits

#define delay(ms) _delay_ms(ms);

Blink::Blink(){
};

void Blink::run(){

    boardLedOn;

    delay(1000);

    boardLedOff;

    delay(1000);

}
</code></pre>

<p>Caller:</p>

<pre><code>#include &lt;avr/io.h&gt;
#include &lt;Arduino.h&gt;
#include &lt;Blink.h&gt;

int main(void)
{


    Blink blink;

    while(1)
    {       
        blink.run();        
    }
}
</code></pre>

<p>header file:</p>

<pre><code>#ifndef BLINK_H
#define BLINK_H

class Blink{

  public: 

    Blink();
    void run();

};

#endif
</code></pre>
",,54823232,57
45584760,2,45584601,2017-08-09T07:55:44.457,1,,1491895,,2017-08-09T07:55:44.457,,4,,"<p>You're missing the type declarations for the parameters to your functions, so they're defaulting to <code>int</code>.</p>

<pre><code>void on_slider_frequency_value_changed(GtkAdjustment *slider_frequency){
    //gtk_main_quit();
    int value;
    value = gtk_adjustment_get_value(slider_frequency);
    //printf(""%d\n"",value);
    pwmSetClock(value);
}
void on_slider_duty_cycle_value_changed(GtkAdjustment *slider_duty_cycle){
    //gtk_main_quit();
    int value;
    value = gtk_adjustment_get_value(slider_duty_cycle);
    //printf(""%d\n"",value);
   // pwm_Write(18, value);
    pwmWrite (18, value);
}
</code></pre>
",,54823307,2348
45592113,2,45591955,2017-08-09T13:28:41.890,1,,982161,,2017-08-09T13:28:41.890,,0,,"<p>dont block the main loop instead let the loop to call the handler every time the function is called...</p>

<pre><code>void setup()
{
    //setup required parameters/handlers
}

void loop()
{
    // a piece of code that calls the handler
    if(handler())
    {
        // TODDY
    }
}

bool handler()
{
    //intended infinite loop
}
</code></pre>
",,54854205,414
45600885,2,45600202,2017-08-09T21:27:05.007,1,,1521611,,2017-08-09T22:30:53.143,2017-08-09T22:30:53.143,13,,"<p>According to the Arduino reference I just looked up <a href=""https://www.arduino.cc/en/Serial/Read"" rel=""nofollow noreferrer"">Serial::read</a>, the code returns data byte-by-byte (eight bits at a time). So probably you should just read the data one byte (eight bits at a time) and do your unpacking after the fact.</p>

<p>In fact you might want to use a <code>union</code> (see e.g. <a href=""https://stackoverflow.com/questions/2468708/converting-bit-field-to-int"">this other stackoverflow post</a> on how to use a <code>union</code>) so that you can get the best of both worlds. Specifically, if you define a <code>union</code> of your definition with the bits broken out and a second part of the <code>union</code> as one or two bytes, you can send the data as bytes and then decode it in the bits you are interested in.</p>

<p><strong>UPDATE</strong></p>

<p>Here is an attempt at some more details. There are a lot of caveats about unions - they aren't portable, they are compiler dependent, etc. But this might be worth trying.</p>

<pre><code>typedef struct {
  unsigned int page:1; // (0,1)
  unsigned int cric:4; // 10 choices (4 bits)
  unsigned int crac:3; // 5 choices (3 bits)
  unsigned int croc:2; // 3 choices (2 bits)
} structTable;

typedef union {
  structTable a;
  uint16_t b;
} u_structTable;

serial.Read(val1);
serial.Read(val2);

u_structTable x;
x.b = val1 | (val2&lt;&lt;8);
printf(""page is %d\n"", x.a.page);
</code></pre>
",,54902816,208
45603281,2,45600202,2017-08-10T02:02:41.363,1,,2430669,,2017-08-10T02:18:17.993,2017-08-10T02:18:17.993,2,,"<p>You can only send full bytes over the serial port.  But you can also send raw data directly. </p>

<pre><code>void send (const structTable* table)
{
    Serial.write((const char*)table, sizeof(structTable));  // 2 bytes.
}

bool receive(structTable* table)
{
    return (Serial.readBytes((char*)table, sizeof(structTable)) == sizeof(structTable));
}
</code></pre>

<p>You also have to be aware that sizeof(int) is not the same on all CPUS</p>

<p>A word about endianness.  The definition for your struct for the program at the other end of the serial link, if running on a CPU with a different endianness would become:</p>

<pre><code>struct structTable {
  unsigned short int croc:2; // 3 choices (2 bits)
  unsigned short int crac:3; // 5 choices (3 bits)
  unsigned short int cric:4; // 10 choices (4 bits)
  unsigned short int page:1; // (0,1)
};
</code></pre>

<p>Note the use of short int, which you can also use in the arduino code to be more precise.  The reason is that short int is 16 bits on most CPUs, while int may be 16,32 or even 64 bits.</p>
",,54908601,40
45624025,2,45623729,2017-08-10T21:54:47.203,0,,6110094,,2017-08-10T22:01:20.197,2017-08-10T22:01:20.197,5,,"<p>Maybe this this union covers all types and as it uses anonymous structures less dots needed  :) :</p>

<pre><code>#define PACKED __attribute__((__packed__))

PACKED union {
    PACKED struct
    {
        unsigned int page:1; // (0,1)
        unsigned int cric:4; // 10 choices (4 bits)
        unsigned int crac:3; // 5 choices (3 bits)
        unsigned int croc:2; // 3 choices (2 bits)
    };
    PACKED struct
    {
        uint8_t val1;
        uint8_t val2;
    };
    uint8_t  val_table[2];
    uint16_t b;
}MegaUnion;

MegaUnion.val1 = PORTone.read();
MegaUnion.val2 = PORTone.read();
</code></pre>

<p>Remember that your page bitfield occupies the youngest bit of the union so to set it to <code>one</code> you need to write <code>MegaUnion.val1 = 1</code> or <code>MegaUnion.val_table[0] = 1</code> or <code>MegaUnion.b = 1</code> </p>
",,54944742,725
45625659,2,45623729,2017-08-11T01:35:33.950,0,,5043289,,2017-08-11T05:13:02.873,2017-08-11T05:13:02.873,9,,"<p><em>Original code:</em></p>

<pre><code>while(PORTone.available()&gt;0) {
    volatile unsigned int val1, val2, val3, val4;
    for(int i = 0; i&lt;=4; i++){    
        val1 = PORTone.read();
        val2 = PORTone.read();
        val3 = PORTone.read();
        val4 = PORTone.read();
    }
</code></pre>

<ul>
<li><p><code>PORTone.available()&gt;0</code> guarantees that a single byte is available for reading. You are reading 20 bytes. Almost certainly 19 of those will be -1 (0xFFFF).</p></li>
<li><p>I don't see why you are reading the four values five times.</p></li>
<li><p>There is no need to make val1, val2, val3, and val4 volatile because they are not being shared with an interrupt service routine.</p></li>
</ul>

<hr>

<p><em>Amended code:</em></p>

<pre><code>while(PORTone.available()&gt;0) {
delay(100);      
  for(int i = 0; i&lt;=4; i++){    
      for(int i = 0; i&lt;=3; i++){  
        for( int j = 0; j&lt;=3; j++) {
          int inByte = PORTone.read();         
          *MegaUnion.struct.val1[j] = inByte; 
</code></pre>

<p>I don't see what you are doing here, except throwing stuff together and hoping for the best. You are now reading 80 bytes in the inner loop once you find a single byte available. The word ""struct"" doesn't belong there in the variable name. You have two loop variables, both called <code>i</code>.</p>

<hr>

<blockquote>
  <p>If you wouldn't mind to describe, and how to access the interrupt service routine, that would be great!</p>
</blockquote>

<p><em>What</em> interrupt service routine? You don't need <code>volatile</code> unless you are using interrupts, which you don't seem to be doing.</p>
",,54952967,91
45642971,2,45641206,2017-08-11T20:03:11.003,1,,576911,,2017-08-24T12:25:55.217,2017-08-24T12:25:55.217,0,,"<p>Here is a <a href=""http://howardhinnant.github.io/date_algorithms.html"" rel=""nofollow noreferrer"">paper with calendrical algorithms</a> that can be used to compute things like the 2nd Sunday in March.  See <a href=""http://howardhinnant.github.io/date_algorithms.html#Example:%20%20Finding%20nth%20weekday%20of%20month"" rel=""nofollow noreferrer"">Example: Finding nth weekday of month</a>.</p>

<p>If you have C++11 available, you can use this <a href=""https://howardhinnant.github.io/date/date.html"" rel=""nofollow noreferrer"">free, open-source date library</a> to compute such things with very high-level syntax.  The library uses the algorithms from <a href=""http://howardhinnant.github.io/date_algorithms.html"" rel=""nofollow noreferrer"">the paper</a> under the hood.  For example:</p>

<pre><code>std::chrono::system_clock::time_point
DST_US(std::chrono::system_clock::time_point tp, std::chrono::hours std_offset)
{
    using namespace date;
    using namespace std::chrono;
    const auto y = year_month_day{floor&lt;days&gt;(tp)}.year();
    const auto begin = sys_days{sun[2]/mar/y} + 2h - std_offset; // DT begins at this UTC time
    const auto end   = sys_days{sun[1]/nov/y} + 1h - std_offset; // ST begins at this UTC time
    if (tp &lt; begin || end &lt;= tp)
        return tp + std_offset;
    return tp + std_offset + 1h;
}
</code></pre>

<p>Feel free to use the datetime library if you have C++11 (it is portable), and to create your own using the algorithms in <a href=""http://howardhinnant.github.io/date_algorithms.html"" rel=""nofollow noreferrer"">the paper</a> otherwise.</p>

<p>Disclaimer:  Timezone rules change all the time.  The above is certainly sufficient for a homemade clock.  For industrial strength applications needing up-to-date timezone rules, use a library based on the <a href=""http://www.iana.org/time-zones"" rel=""nofollow noreferrer"">IANA timezone database</a> such as <a href=""https://howardhinnant.github.io/date/tz.html"" rel=""nofollow noreferrer"">this one</a>.</p>
",,54983032,259
45643361,2,45641206,2017-08-11T20:34:33.357,0,,7735711,,2017-08-11T20:56:39.750,2017-08-11T20:56:39.750,0,,"<p>Here, I made a C++ code for you. You don't need C++11 to run this.</p>

<p>How it works is, it gets the current month and year. Checks if the year is a leap year, then goes ahead and sets max day amount. Let's say 2017 August. The max day will be 31.</p>

<p>Program starts to run through and counts <code>sundayCounter</code> up if the day it hit is a sunday.</p>

<p>This way you'll get the amount of sundays in the current month, automatically.</p>

<p>Here's my code, feel free to use it. It does exactly what you want to do. Your desired variable is <code>sundayCounter</code>. Have fun.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
using namespace std;

int main()
{
    bool isLeap = false;
    int sundayCounter = 0;
    int MAX_DAY;
    int month, year;
    string monthText;

    time_t theTime = time(NULL);
    struct tm *aTime = localtime(&amp;theTime);
    month = aTime-&gt;tm_mon;
    year = aTime-&gt;tm_year;

    if (year % 4 == 0)
        {;
            if (year % 100 == 0)
            {
                if (year % 400 == 0)
                    isLeap = true;
                else
                    isLeap = false;
            }
            else
                isLeap = true;
        }
    else {
        isLeap = false;
    }

    switch(month)
    {
    case 0:
        MAX_DAY = 31;
        break;
    case 1:
        if(isLeap)
            MAX_DAY = 29;
        else
            MAX_DAY = 28;
        break;
    case 2:
        MAX_DAY = 31;
        break;
    case 3:
        MAX_DAY = 30;
        break;
    case 4:
        MAX_DAY = 31;
        break;
    case 5:
        MAX_DAY = 30;
        break;
    case 6:
        MAX_DAY = 31;
        break;
    case 7:
        MAX_DAY = 31;
        break;
    case 8:
        MAX_DAY = 30;
        break;
    case 9:
        MAX_DAY = 31;
        break;
    case 10:
        MAX_DAY = 30;
        break;
    case 11:
        MAX_DAY = 31;
        break;
    }

    for(int day = 0; day &lt;= MAX_DAY; day++) {
        struct tm time_in = { 0, 0, 0, // second, minute, hour
                day, month + 1, year - 1900 }; // 1-based day, 0-based month, year since 1900

        time_t time_temp = mktime( &amp; time_in );

        // the return value from localtime is a static global - do not call
        // this function from more than one thread!
        tm const *time_out = localtime( &amp; time_temp );

        switch(time_out-&gt;tm_wday)
        {
        case 0:
            sundayCounter++;
            break;
        }
    }

    const char* month_list[] = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
    int current_month = month+1;
    const char* current_month_name = month_list[current_month-1];
    cout &lt;&lt; ""Sunday amount in "" &lt;&lt; current_month_name &lt;&lt; "" "" &lt;&lt; (year + 1900) &lt;&lt; "": "" &lt;&lt; sundayCounter;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Sunday amount in August 2017: 4
</code></pre>
",,54995265,593
45645742,2,45645087,2017-08-12T01:41:15.407,0,,2612271,,2017-08-12T01:41:15.407,,2,,"<p>Nested if's should end-up with a plethora of ending '}'s, such as:</p>

<pre><code>   if (cond-1) {
        stuff;
   }
   else {
      if (cond-2) {
         stuff_2;
      }
      else {
         other_stuff_2;

       } // end_if for cond-2

   }  // end_if for cond-1
</code></pre>

<p>You get the idea.  Your code needs to clearly indicate the blocks ""{}"" of code.
It is easiest to be very explicit about blocks instead of relying on the bug producer: ""one statement qualifies as a block"".  That is, write code that can be easily modified and clearly states relationships. </p>
",,55009675,134
45718562,2,45645087,2017-08-16T16:18:28.090,0,,8453074,,2017-08-16T16:18:28.090,,0,,"<p>I have managed to work the loop that would not work in the switch case statement. However, I decided to completely ditch the switch case and instead use if/else if's to point towards new functions that I made. </p>

<p>I fixed the loop for the if/else to loop the values of the potentiometer and to turn on the LEDs by simply moving these two lines (that was just at the top of the if/else, not inside), </p>

<pre><code>potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31
</code></pre>

<p>into every if/else statement like so,</p>

<pre><code>void potentiometer() {

  Serial.println(""P"");

  do {
    if (potValue &gt;= 0 &amp;&amp; potValue &lt;= 6) {
      /* If the value on the potentiometer is greater than or equal to 0,
         or less than or equal to 6, the red LED will turn on */

      potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31

      // Converts the DEC value of the potentiometer to BIN
      Serial.println(potValue, BIN);
      delay(500);

      digitalWrite(LED_RED, HIGH);
      digitalWrite(LED_ORANGE, LOW);
      digitalWrite(LED_YELLOW, LOW);
      digitalWrite(LED_GREEN, LOW);
      digitalWrite(LED_BLUE, LOW);
    }
    else if (potValue &gt;= 7 &amp;&amp; potValue &lt;= 12) {
      /* If the value on the potentiometer is greater than or equal to 3,
         or less than or equal to 12, the orange LED will turn on */

      potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31

      Serial.println(potValue, BIN);
      delay(500);

      digitalWrite(LED_RED, LOW);
      digitalWrite(LED_ORANGE, HIGH);
      digitalWrite(LED_YELLOW, LOW);
      digitalWrite(LED_GREEN, LOW);
      digitalWrite(LED_BLUE, LOW);
    }
    else if (potValue &gt;= 13 &amp;&amp; potValue &lt;= 18) {
      /* If the value on the potentiometer is greater than or equal to 13,
         or less than or equal to 18, the yellow LED will turn on */

      potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31

      Serial.println(potValue, BIN);
      delay(500);

      digitalWrite(LED_RED, LOW);
      digitalWrite(LED_ORANGE, LOW);
      digitalWrite(LED_YELLOW, HIGH);
      digitalWrite(LED_GREEN, LOW);
      digitalWrite(LED_BLUE, LOW);
    }
    else if (potValue &gt;= 19 &amp;&amp; potValue &lt;= 24) {
      /* If the value on the potentiometer is greater than or equal to 19,
         or less than or equal to 24, the green LED will turn on */

      potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31

      Serial.println(potValue, BIN);
      delay(500);

      digitalWrite(LED_RED, LOW);
      digitalWrite(LED_ORANGE, LOW);
      digitalWrite(LED_YELLOW, LOW);
      digitalWrite(LED_GREEN, HIGH);
      digitalWrite(LED_BLUE, LOW);
    }
    else if (potValue &gt;= 25 &amp;&amp; potValue &lt;= 31) {
      /*If the value on the potentiometer is greater than or equal to 25,
        or less than or equal to 31, the blue LED will turn on */

      potValue = analogRead(potPin); // Reads the value on the pin
      potValue = map(potValue, 0, 1023, 0, 31); // Changes the default range from 0 to 1023 to 0 to 31

      Serial.println(potValue, BIN);
      delay(500);

      digitalWrite(LED_RED, LOW);
      digitalWrite(LED_ORANGE, LOW);
      digitalWrite(LED_YELLOW, LOW);
      digitalWrite(LED_GREEN, LOW);
      digitalWrite(LED_BLUE, HIGH);
    }
  } while (true);
}
</code></pre>

<p>I wasn't sure how to end the while because there was no way of me ending it, but I don't mind that it keeps looping infinitely. </p>
",,55012540,58
45665253,2,45662049,2017-08-13T21:56:41.117,0,,6110094,,2017-08-13T22:10:35.197,2017-08-13T22:10:35.197,5,,"<p>It because int on stm32 is 32bit and int on AVR is 16 bits long. When you pass pointer to int to the function which takes pointer to uint16_t there is no conversion possible. Why?</p>

<p>When you derefernce the pointer any asignments to the dereferanced one only write 2 bytes and the original type is 4 bytes. So 2 bytes are unaffected.</p>

<p>example </p>

<pre><code>void foo(uint16_t *ptr) {
    *ptr = 0x1122
}

int val = 0x0feeddcc;

foo((uint16_t *)&amp;val);
</code></pre>

<p>the result will be 0x0fee1122 not 0x00001122; -if you force it with the implicit cast. But it is an UB</p>

<p>Change int to short in your code to make them the same size.</p>

<p>another solution - leave int and unsigned not changed just rewrite the method;</p>

<pre><code>#define PACKED __attribute__((__packed__))

void MechaQMC5883::read(int* x,int* y,int* z){
    PACKED union {
        short     xs;
        uint8_t   xu[2];
    }xunion;
  Wire.beginTransmission(address);
  Wire.write(0x00);
  Wire.endTransmission();
  Wire.requestFrom(address, 6);
  xunion.xu[0] = Wire.read(); 
  xunion.xu[1] = Wire.read(); 
  *x = (int)xunion.xs;
  xunion.xu[0] = Wire.read(); 
  xunion.xu[1] = Wire.read(); 
  *y = (int)xunion.xs;
  xunion.xu[0] = Wire.read(); 
  xunion.xu[1] = Wire.read(); 
  *z = (int)xunion.xs;
}
</code></pre>
",,55012774,258
45704711,2,45703261,2017-08-16T03:34:45.690,0,,8022450,,2017-08-16T03:34:45.690,,3,,"<p>In your <code>char dataInput()</code> function you are taking the serial input with <code>Serial.parseInt()</code> which when inputting 'A' parseInt will return 0. See the <a href=""https://www.arduino.cc/en/Reference/ParseInt"" rel=""nofollow noreferrer"">documentation</a>. In order to read a char use <code>Serial.read()</code> to get a single character.</p>

<pre><code>void loop() {

  Serial.println (""Enter your chosen operator"");
  Serial.println (""A for Addition, S for Subtraction, M for Multiplication,"");
  Serial.println (""D for Division, and P for Potentiometer: "");

  // Takes an input from the user
  char theOperator = Serial.read();

  switch(theOperator) {
    case 'A':
    // If input is equal to 1, carry out function 'addition()'
      addition();
      break;
    case 'S':
    // If input is equal to 2, carry out function 'subtraction()'
      subtraction();
      break;
    case 'M':
    // If input is equal to 3, carry out function 'multiplication()'
      multiplication();
      break;
    case 'D':
    // If input is equal to 4, carry out function 'division()'
      division();
      break;
  case 'P':
    // If input is equal to 5, carry out function 'potentiometer()'
    potentiometer();
    break;
  }
}
</code></pre>
",,55014300,51
45729790,2,45726974,2017-08-17T08:11:54.927,0,,6459864,,2017-08-17T08:11:54.927,,0,,"<p>For setting up the port and read/write commands you can use the code from <a href=""https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c"">this answer</a>. 
Then you only have to worry about what you send and what you receive.</p>

<p>Putty actually reads the serial port in the background and then prints it on the console so you can see it. You will have to do the same thing in your app. After you read the data, you have to print it.</p>

<p>For example, for login, as you described it:</p>

<pre><code>write (fd, ""login\r\n"", 7);          // send 7 character login command
                                     // (similar to writing login + enter in Putty)

usleep ((7 + 25) * 100);             // allow time for sending &amp; receiving
                                     // (sleep enough to transmit the 7 plus
                                     // receive 25:  approx 100 uS per char transmit)

char buf [100];
int n = read (fd, buf, sizeof(buf)); // read rx characters (Putty does this automatically)
                                     // expect to have ""the sentence saying type your password"" in this buffer
                                     // 100 characters are read, adjust it if you expect a longer answer

printf(""Rx:"");                       // display the rx data (Putty does this automatically)
for (int i = 0; i &lt; sizeof(buf); i++) 
    printf(""%c"",buf[i]);            
printf(""\n"");

// continue with sending the password + reading the response
// then sending the ip command + reading the answer
</code></pre>
",,55031186,52
45744986,2,45744631,2017-08-17T21:07:13.080,2,,2630032,,2017-08-17T21:54:46.110,2017-08-17T21:54:46.110,11,,"<p>According to your comments it seems as if you want to interpret the higher and the lower byte of a 16 bit integral value (e.g. <code>14392</code>) as ASCII-characters (e.g. <code>'8'</code>+<code>'8'</code>). To achieve that, you do not have to ""convert"" the decimal value into a hex value in order to then get an ASCII-character. You could simply <em>interpret</em> the higher and the lower byte as an (ASCII-) char; Then - if needed - you can interpret two consecutive ASCII-characters as a string representing a hex-value and convert it to decimal. 
No idea why you actually need that, but see the following code that does exactly that. Hope it helps.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() {

    u_int16_t decVal = 14392;
    cout &lt;&lt; ""original dec value: "" &lt;&lt; decVal &lt;&lt; endl;
    cout &lt;&lt; ""dec value as hex: 0x"" &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; decVal  &lt;&lt; endl;
    char c1 = (decVal&amp;0x7F00 &gt;&gt; 8);
    char c2 = (decVal&amp;0x7F);
    char hexStr[3] = { c1, c2, '\0' };
    cout &lt;&lt; ""2 bytes interpreted as ASCII: "" &lt;&lt; hexStr &lt;&lt; endl;

    char *lastCharInterpreted;
    decVal = strtol(hexStr, &amp;lastCharInterpreted, 16);
    if (lastCharInterpreted == hexStr) {
        cout &lt;&lt; ""invalid hexadecimal value: ""  &lt;&lt; hexStr &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; ""ASCII interpreted as hex and converted to dec:"" &lt;&lt; std::dec &lt;&lt; decVal &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>original dec value: 14392
dec value as hex: 0x3838
2 bytes interpreted as ASCII: 88
ASCII interpreted as hex and converted to dec:136
</code></pre>
",,55036226,75
45746878,2,45746518,2017-08-18T00:45:31.963,1,,2430669,,2017-08-18T00:45:31.963,,0,,"<p>Yes, a substring is what you need.</p>

<p>Fortunately, String provides a substring function.</p>

<p><a href=""https://www.arduino.cc/en/Reference/StringSubstring"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Reference/StringSubstring</a></p>

<p>You code could look a bit like this:</p>

<pre><code>// expecting operation in for ""oxxxyyy"" where o is the operator, xxx, yyy operands.

   bool ParseOperation(String&amp; strInput, char&amp; op, int&amp; x, int&amp; y)
   {
       if (strInput.length() != 7)
           return false;

       op = strInput[0];
       x = atoi(strInput.substring(1, 4).c_str());
       y = atoi(strInput.substring(4).c_str());
       return true;
   }

   // call as:

   void loop()
   {
       String str;
       char op;
       int r, x, y;

       // read user input into str...

       if (ParseOperation(str, op, x, y))
       {
           switch(op)
           {
           case 'A': case 'a': 
               op = '+'; 
               r = x + y; 
               break;

           // etc...

           default:
                // print some error message...
                break;
           }
           // print x op y = r
       }
       else
       {
            // print error message...
       }
   }
</code></pre>
",,55046212,887
45747126,2,45746518,2017-08-18T01:22:37.463,1,,7247051,,2017-08-19T02:41:57.450,2017-08-19T02:41:57.450,0,,"<pre><code>#include &lt;string.h&gt;
#include &lt;SoftwareSerial.h&gt;

#define RX_TIMEOUT = 5000; // wait until 5 second

void initSerial() {
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect
  }
}

int hex2int(char *hexStr) {
    int v = 0;
    while (*hexStr) {
        char c = *hexStr++; 

        if (c &gt;= '0' &amp;&amp; c &lt;= '9') c = c - '0';
        else if (c &gt;= 'a' &amp;&amp; c &lt;='f') c = c - 'a' + 10;
        else if (c &gt;= 'A' &amp;&amp; c &lt;='F') c = c - 'A' + 10;    

        v = (v &lt;&lt; 4) | (c &amp; 0xF);
    }
    return v;
}

int main(){
    char data[128];

    initSerial();

    while (1) {
          // operator A
          // value1 ranges = 0x0000 - 0xFFFF (hex 2 bytes);
          // value2 ranges = 0x0000 - 0xFFFF (hex 2 bytes);
          // 
          // value1 = 10 (decimal) = 00 0A (hex 2 bytes)
          // value2 = 20 (decimal) = 00 14 (hex 2 bytes)
          // A  00 0A  00 14 
          Serial.println (""Enter A000A0014"");

          unsigned long startTime = millis();
          int i = 0;
          do {
            int length = Serial.available();
            if(length &gt; 0) {
                if(i &gt;= 128) {
                    break;
                }
                data[i++] = Serial.read();
            }
          } while ( millis() - startTime &lt; RX_TIMEOUT);              
          data[i] = '\0';

          if(data[0]== '\0') {
            Serial.println (""Time out.., try again!"");
            continue;
          }

          char c1[2], c2[2];
          int v1, v2, v3;

          memcpy(c1, &amp;data[1], 2); // data[1], data[2]
          v1 = hex2int(c1);

          memcpy(c2, &amp;data[3], 2);  // data[3], data[4]
          v2 = hex2int(c2);

          switch(data[0]){
            case 'A':                   
                v3 = v1 + v2;
                Serial.write(v3);
                break;

            case 'S':                   
                v3 = v1 - v2;
                Serial.write(v3);
                break;

            case 'M':
                v3 = v1 * v2;
                Serial.write(v3);
                break;

            case 'D':
                v3 = v1 / v2;
                Serial.write(v3);
                break;

            case 'P':
                // todo
                break;

            default:
                // else
                break;
          }
    }
    return 0;
}
</code></pre>
",,55069755,1330
45749276,2,45747495,2017-08-18T05:42:42.027,0,,2430669,,2017-08-18T05:42:42.027,,0,,"<p>You are using double quote marks ("") in your char comparisons.  In C++, the double quote marks are used to define strings, not characters.  Characters are defined using single quotes (')</p>

<p>testing for a space:  <code>if (c == ' ')</code>.</p>

<p>Unlike strings, you can also use chars in switch statements:</p>

<pre><code>switch (c)
{
case 'a': case 'A':
    Serial.println(""I've got an A!!"");
    break;
}
</code></pre>
",,55080058,58
45783238,2,45783033,2017-08-20T14:34:23.597,1,,2104697,,2017-08-20T15:47:14.167,2017-08-20T15:47:14.167,4,,"<p>Function pointer and member function pointer have different types. You can it for yourself:</p>

<pre><code>struct Test {
    void fun();
};

int main() {
    void(*ptr)() = &amp;Test::fun; // error!
}
</code></pre>

<p>Instead, member function pointer need this syntax:</p>

<pre><code>void(Test::*fun)() = &amp;Test::fun; // works!
</code></pre>

<p>Why you ask? Because member function need an instance to be called with. And calling that function have a special syntax too:</p>

<pre><code>Test t;

(t.*funptr)();
</code></pre>

<p>To accept member function pointer, you'll need to change your code to this:</p>

<pre><code>inline void setHandleAfterTouch(void(EncodeWrapper::*fptr)(uint8_t, uint8_t)) {                
    usb_midi_handleAfterTouch = fptr;
};
</code></pre>

<p>Since it's rather limiting accepting only the functions from one class, I recommend using <code>std::function</code>:</p>

<pre><code>inline void setHandleAfterTouch(std::function&lt;void(uint8_t, uint8_t)&gt; fptr) {                
    usb_midi_handleAfterTouch = std::move(fptr);
};
</code></pre>

<p>This will allow you to send lambda with captures, and call your member function insode it:</p>

<pre><code>//  we capture this to use member function inside
//                           v---
usbMIDI.setHandleAfterTouch([this](uint8_t, channel, uint8_t pressure) {
    onAfterTouch(channel, pressure);
});
</code></pre>

<hr>

<p>It seems you can't change, and by looking quickly at the API, it doesn't seem you have access to a state object.</p>

<p>In that case, if you want to use your member function, you need to introduce a global state:</p>

<pre><code>// global variable
EncodeWrapper* encode = nullptr;

// in your function that sets the handle
encode = this; //            v--- No capture makes it convertible to a function pointer
usbMIDI.setHandleAfterTouch([](uint8_t, channel, uint8_t pressure) {
    encode-&gt;onAfterTouch(channel, pressure);
});
</code></pre>

<p>Another solution would be to make <code>onAfterTouch</code> function static. If it's static, it's pointer is not a member function pointer, but a normal function pointer.</p>
",,55094137,234
45798243,2,45795619,2017-08-21T13:21:40.873,0,,8429055,,2017-08-21T13:21:40.873,,0,,"<p>In Keil IDE there is a project option for writing listing (map) files containing information about your memory usage of your program. Example:</p>

<pre><code>Image component sizes

Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name
  28         10          0          0          0          0   app_error.o

...

Code (inc. data)   RO Data    RW Data    ZI Data      Debug   

 22580       2194        388        232       3904          0   Grand Totals
 22580       2194        388        232       3904          0   ELF Image Totals
 22580       2194        388        232          0          0   ROM Totals
</code></pre>

<p>==============================================================================</p>

<pre><code>Total RO  Size (Code + RO Data)                22968 (  22.43kB)
Total RW  Size (RW Data + ZI Data)              4136 (   4.04kB)
Total ROM Size (Code + RO Data + RW Data)      23200 (  22.66kB)
</code></pre>

<p>Visual Studio also have such an option.</p>
",,55125784,220
45867491,2,45867379,2017-08-24T17:15:16.613,52,,3807729,,2018-08-22T14:25:02.433,2018-08-22T14:25:02.433,4,,"<p><code>GCC v7</code> still does not implement <a href=""https://en.cppreference.com/w/cpp/header/filesystem"" rel=""noreferrer"">&lt;filesystem&gt;</a> but it does have the <em>Filesystem Technical Specification</em> which is in <a href=""https://en.cppreference.com/w/cpp/header/experimental/filesystem"" rel=""noreferrer"">&lt;experimental/filesystem&gt;</a></p>

<pre><code>#include &lt;experimental/filesystem&gt;

// for brevity
namespace fs = std::experimental::filesystem;

int main()
{
    fs::path p = ""/path/to/my/file""; // etc...
}
</code></pre>

<p>This is also available in <code>GCC v6</code>.</p>

<p>To link with the library you need to add <code>-lstdc++fs</code> to the command line.</p>

<p><strong>Note:</strong> There may be some minor differences between the current <em>Technical Specification</em> and the final draft of <a href=""https://en.cppreference.com/w/cpp/header/filesystem"" rel=""noreferrer"">&lt;filesystem&gt;</a> that is decided upon by the Standards Committee.</p>

<p><strong>Note 2:</strong> <code>GCC v8</code> now implements <a href=""https://en.cppreference.com/w/cpp/header/filesystem"" rel=""noreferrer"">&lt;filesystem&gt;</a> with the <code>-std=c++17</code> flag.</p>
",,55165811,71
45872764,2,45872139,2017-08-25T00:31:16.503,1,,8490870,,2017-08-25T00:31:16.503,,0,,"<p>Evolution took about 4 billion years, that is a good indication that programming by random mutation is not a good idea. I don´t have arduino and I don´t have a hardware setup to test the code and your description is not sufficient to precisely guess what you are going to do. That said:</p>

<p>What do you expect</p>

<pre><code>length.pixs
</code></pre>

<p>could mean or do? C++ idiom would suggest to use std::array I think, that would enable you to elegantly get the number of entries. Since you stick with C arrays, the length would be calculated by</p>

<pre><code>sizeof(pixs)/sizeof(*pixs)
</code></pre>

<p>The array construction is defective, in your code you access the array being 1 dimensional and your type also indicates 1 dimensional. So it should be</p>

<pre><code>unsigned long pixs [] = {0xCE2131, 0xCE1929, 0xCE1929}
</code></pre>

<p>and not your double braced list. Hex literals are given by using 0x, nothing else. 
0xCE1929 and not FFCE1929 which has no meaning (despite being an identifier which is meaningless in your code)</p>

<p>The following version of your code is at least syntactically correct and should provide a basis for your further explorations.</p>

<pre><code>#include &lt;LEDMatrix.h&gt;
#include &lt;string.h&gt;

#define MATRIX_WIDTH   32  // Set this negative if physical led 0 is opposite to where you want logical 0
#define MATRIX_HEIGHT  8  // Set this negative if physical led 0 is opposite to where you want logical 0
#define MATRIX_TYPE    VERTICAL_ZIGZAG_MATRIX  // See top of LEDMatrix.h for matrix wiring types


cLEDMatrix&lt;MATRIX_WIDTH, MATRIX_HEIGHT, MATRIX_TYPE&gt; leds;

unsigned long pixs [] = {0xCE2131,
    0xCE1929,0xCE1929,0xCE1929,0xCE1929,
    0xCE1929,0xCE1929,0xCE2131,0xC50821,
    0xC50821,0xC50821,0xC50821,0xC50821,
    0xC50821,0xC50821,0xC50821,0xCE1929,
    0xC50821,0xC50821,0xC50821,0xC50821,
    0xC50821,0xC50821,0xCE1929,0xCE1929,
    0xC50821,0xC50821,0xC50821,0xC50821,
    0xC50821,0xC50821,0xCE1929,0xCE1929,
    0xC50821,0xC50821,0xC50821,0xC50821,
    0xC50821,0xC50821,0xCE1929,0xCE1929,
    0xC50821,0xC50821,0xC50821,0xC50821,
    0xC50821,0xC50821,0xCE1929,0xCE1929};



void setup()
{
    FastLED.addLeds&lt;CHIPSET, LED_PIN, COLOR_ORDER&gt;(leds[0], leds.Size());
    FastLED.setBrightness(15);
    FastLED.clear(true);
    delay(500);
    FastLED.clear(true);
    Serial.begin(9600);
}

void loop() {
    leds(0,0) = 0xCE2131;
    leds(31,0) = CRGB::White;
    leds(0,7) = CRGB::Green;
    leds(31,7) = CRGB::Yellow;
    FastLED.show();
    delay(2000);
    FastLED.clear(true);
    delay(1000);

    for (int i = 0; i &lt; sizeof(pixs)/sizeof(*pixs) ; i ++){
        leds(0,0) = pixs[i];
        FastLED.show();
    }

}
</code></pre>
",,55190804,343
45903629,2,45903613,2017-08-27T09:43:01.237,3,,8254699,,2017-08-27T09:54:31.700,2017-08-27T09:54:31.700,2,,"<p>If you want to modify class (member) variables, you have to create an instance of this class first.</p>

<p>Then the best way would be set <code>detectorSniffer</code> as method (or friend function) of class <code>Detector</code>, after that you can access &amp; modify its member variables from <code>detectorSniffer</code>.</p>

<pre><code>void Detector::detectorSniffer(uint8_t *buf, uint16_t len)
{
  if(buf[12] == 0xA0 || buf[12] == 0xC0) {
    c++;
  }
};

// Calling
Detector d;
d.start();
d.detectorSniffer(/*parameters*/);
</code></pre>

<p>or pass reference to an instance of <code>Detector</code></p>

<pre><code>void Detector::detectorSniffer(uint8_t *buf, uint16_t len, Detector &amp; d) {
  if(buf[12] == 0xA0 || buf[12] == 0xC0) {
    d.c++; //Failing to read C long in the detector class
  }
};

// Calling
Detector d;
d.start();
detectorSniffer(/*some parameters*/, d);
</code></pre>
",,55201313,1186
45906243,2,45906205,2017-08-27T14:52:05.570,2,,6840989,,2018-10-11T18:01:23.427,2018-10-11T18:01:23.427,2,,"<p>On line 4 it says 
<code>#define PinOut1</code>
try adding a space to make it
<code>#define PinOut 1</code></p>

<p>EDIT:
There were also a few other things I noticed after this post so I compiled a fixed version of your code:</p>

<pre><code>#include &lt;Servo.h&gt;
#define trigPin 13
#define echoPin 12
#define PinOut1 11
Servo myservo; 
int AnalogIn=A0;
int buttonState = 0;
int integer1 = 3;
float floating1 = PI;
String string1 = ""words and numbers123"";
int array1[5] = {100, 200, 300, 400, 500};


int PinIn1 = 2;
int PinOut = 11;
int button = 0;


void setup() {
  pinMode(PinOut, OUTPUT);
  pinMode(PinIn1, INPUT);
  Serial.begin(9600);
  myservo.attach(9);
}
void loop() {
Conditional1();
}

void Conditional1() {
   button = digitalRead(PinIn1);

  if (buttonState == HIGH) {
digitalWrite(PinOut1, HIGH);
    myservo.write(60);

  } else{
    digitalWrite(PinOut1, LOW);
    myservo.write(0);

  }
}
</code></pre>
",,55201623,85
45956344,2,45956343,2017-08-30T09:09:22.737,0,,361177,,2017-08-30T13:58:31.787,2017-08-30T13:58:31.787,0,,"<p>The cause of bad performance is the usage of floating point values.</p>

<p>I will show how to get rid of it.</p>

<p>First we talk about precision:</p>

<ul>
<li>The TMP36 has a range of 500°C (from -50°C to +450°C).</li>
<li>The analog read works on 10 bits from 0 to 1023 (1024 possible values).</li>
</ul>

<p>So the precision is 500/1024. Roughly 0.5 °C.</p>

<p>So if we want to code the temperature on an <code>int</code>, the less significant bit of this <code>int</code> needs to code for 0.5°C instead of 1°C.</p>

<p><strong>Example:</strong></p>

<pre class=""lang-cpp prettyprint-override""><code>int celciusTemperatureByHalfDegree = +40; // +20.0°C
int celciusTemperatureByHalfDegree = +41; // +20.5°C
int celciusTemperatureByHalfDegree = -10; // -5.0°C
int celciusTemperatureByHalfDegree = -15; // -5.5°C
</code></pre>

<p>We see that:</p>

<pre class=""lang-cpp prettyprint-override""><code>celciusTemperatureByHalfDegree = celciusTemperature * 2
</code></pre>

<p>Roughly will have:</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = analogRead(PIN);
int voltage = (reading * 500) / 1024;  
int celciusTemperature = voltage - 50;
int celciusTemperatureByHalfDegree = celciusTemperature * 2;
</code></pre>

<p>At this point an overflow and rounding issues cause this code to be useless.</p>

<p>Let's simplify it:</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = (analogRead(PIN) * 500) / 1024;
int celciusTemperatureByHalfDegree = (reading - 50) * 2;
</code></pre>

<p>And again:</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = (analogRead(PIN) * 500) / 512;
int celciusTemperatureByHalfDegree = reading - 100;
</code></pre>

<p>And again:</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = (analogRead(PIN) * 125) / 128;
int celciusTemperatureByHalfDegree = reading - 100;
</code></pre>

<p>At this point there is no more rounding issue. But <code>analogRead()</code> gives an output between 0 and 1023.</p>

<p>And <code>1023 * 125</code> is bigger than max <code>int16</code> (32,767), so overflow is possible.</p>

<p>Here we will use that 125 = 5*25 and 128 = 4*32.</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = (analogRead(PIN) * 5 * 25) / (4 * 32);
int celciusTemperatureByHalfDegree = reading - 100;
</code></pre>

<p>Will become:</p>

<pre class=""lang-cpp prettyprint-override""><code>int reading = analogRead(PIN); // 0 to 1023
reading *= 5;                  // 0 to 5115 (no overflow)
reading /= 4;                  // 0 to 1278 (no overflow)
reading *= 25;                 // 0 to 31950 (no overflow)
reading /= 32;                 // 0 to 998
int celciusTemperatureByHalfDegree = reading - 100;
</code></pre>

<p>Finally to print it we will use this code:</p>

<pre class=""lang-cpp prettyprint-override""><code>// print the integer value of the temperature
Serial.print(celciusTemperatureByHalfDegree/2);
Serial.print(""."");
// less significant bit code for ""__.0"" of ""__.5""
Serial.print(celciusTemperatureByHalfDegree % 2 ? '5' : '0'); 
Serial.print(""°C"");
</code></pre>
",,55214290,84
45974746,2,45974514,2017-08-31T06:34:25.193,2,,4442671,,2017-08-31T06:34:25.193,,2,,"<p>You can see in the <a href=""https://github.com/arduino/Arduino/blob/b77957eb59499643aca0749165c3440b77c9e841/hardware/arduino/avr/cores/arduino/Print.h"" rel=""nofollow noreferrer"">header</a> That <code>print()</code> simply does not have an overload for <code>uint64_t</code>.</p>

<p>You'll have to encode the large number somehow, by breaking it up into two separate <code>uint32_t</code> for example:</p>

<pre><code> uint64_t num = 9223372036854775807;

 uint32_t low = num % 0xFFFFFFFF; 
 uint32_t high = (num &gt;&gt; 32) % 0xFFFFFFFF;

 Serial.print(low);
 Serial.print(high); 
</code></pre>

<p>Obviously, you'll have to recombine them on the other end.</p>
",,55265279,102
46081325,2,45974514,2017-09-06T17:40:36.490,2,,8569707,,2017-09-06T17:40:36.490,,0,,"<p>This is how I would do it. It's messy but it gets the job done.</p>

<p>Output from serial console: <code>9223372036854775807</code></p>

<pre><code>void print_uint64_t(uint64_t num) {

  char rev[128]; 
  char *p = rev+1;

  while (num &gt; 0) {
    *p++ = '0' + ( num % 10);
    num/= 10;
  }
  p--;
  /*Print the number which is now in reverse*/
  while (p &gt; rev) {
    Serial.print(*p--);
  }
}
</code></pre>
",,55271832,108
46006500,2,46006325,2017-09-01T19:01:49.143,1,,434551,,2017-09-05T13:28:58.060,2017-09-05T13:28:58.060,4,,"<p>Since  <code>int</code>s are represented using 16 bits n Arduino, you'll have to fall back on basic math to get the answer you need.</p>

<p>You are trying to compute <code>(A*B)/C</code>.</p>

<p><code>(A*B)/C = ((k1*C+a) * (k2*C+b)/C</code>, where<br>
<code>k1 = A/C</code> and <code>a = A%C</code>, and <code>k2 = B/C</code> and <code>b = B%C</code>.</p>

<p><code>(k1*C+a) * (k2*C+b)</code> is equal to <code>(k1*k2*C*C + b*k1*C + a*k2*C + a*b)</code></p>

<p>If you divide that by <code>C</code>, you get <code>k1*k2*C + b*k1 + a*k2 + (a*b)/C</code>.</p>

<p>That number should stay within the limits of a 16-bit number.</p>

<p>A sample program that demonstrates the idea on a 64-bit machine:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
   int A = 255;
   int B = 195;
   int C = 200;

   int k1 = A/C;
   int a = A%C;
   int k2 = B/C;
   int b = B%C;

   std::cout &lt;&lt; k1*k2*C &lt;&lt; std::endl;
   std::cout &lt;&lt; k1*b &lt;&lt; std::endl;
   std::cout &lt;&lt; k2*a &lt;&lt; std::endl;
   std::cout &lt;&lt; a*b &lt;&lt; std::endl;

   int sum = k1*k2*C + k1*b + k2*a + (a*b)/C;
   std::cout &lt;&lt; sum &lt;&lt; std::endl;
   std::cout &lt;&lt; (A*B)/C &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>



<pre><code>0
195
0
10725
248
248
</code></pre>
",,55325315,807
46037607,2,46006883,2017-09-04T12:58:06.037,0,,6124634,,2017-09-04T12:58:06.037,,0,,"<p>I found the solution in the different numbering used with the setup functions. WirinpPi has its own Pin numbering and there is the native BCM numbering. The solution is to change the numbering in the lcdInit function to the BCM numbering.</p>

<pre><code>                        //wiringPi Nr.
pinMode(17, OUTPUT);    //0
pinMode(18, OUTPUT);    //1
pinMode(27, OUTPUT);    //2
pinMode(22, OUTPUT);    //3
pinMode(8, OUTPUT);     //10
pinMode(7, OUTPUT);     //11

//int fd = lcdInit(2, 16, 4, 11, 10, 0, 1, 2, 3, 0, 0, 0, 0);   //wiringPi Nr.
int fd = lcdInit(2, 16, 4, 7, 8, 17, 18, 27, 22, 0, 0, 0, 0);   //BCM Nr.
</code></pre>
",,55396304,247
46107379,2,46028764,2017-09-08T01:38:09.160,3,,565244,,2017-09-11T16:53:43.003,2017-09-11T16:53:43.003,0,,"<p>Allright, it takes a longer journey to figure it out and test it. Also made a video of it, see link at the bottom of this answer. All credits go to @user0042 who points me into the right direction. The default Wire library is actually of no use when it comes to stability, reliability, so it is required to 'replace' it with this: </p>

<hr>

<p>The I2C Master library - 
<a href=""http://dsscircuits.com/articles/arduino-i2c-master-library"" rel=""nofollow noreferrer"">http://dsscircuits.com/articles/arduino-i2c-master-library</a></p>

<hr>

<p>There are more benefits to use this library, it is smaller in compile size, read the article above for more information.</p>

<p>I changed my software, the 'key' to detect a device on the bus could be simplified to this:</p>

<pre><code>bool TEnjoyPad::isPnpDeviceAvailable( uint8_t iAddress )
{
  return ( I2c.write( (int)iAddress, (int)0x00 ) == 0x00 ); 
}
</code></pre>

<p><em>Notice: The (int) typecasting is required to avoid a compiler warning but it does work fine without.</em></p>

<p>I send a <code>**0x00 command**</code> which do nothing, however, the device seems to answer. The function I made returns true when plugged in and false if not. </p>

<p><code>I doesn't test it with other i2c devices yet, however, will try later and update this question. For now it seems to working fine.</code>
<em>NOTICE: SEE UPDATE BELOW:</em></p>

<hr>

<p><strong>The PNP approach</strong></p>

<p><em>Step #1</em></p>

<p>In the first version I didn't use any resistors (lazyness) but it is a good idea to stabilize the readouts of the bus. Add two resistors (4.7K) on the +5V output to the data lines. It is very important to do this to avoid false detections and to avoid your Arduino can still freeze because of that.</p>

<p><em>Step #2</em> </p>

<p>You need to keep track on changes/device state of each I2C device. I use three states:</p>

<ul>
<li>Connected</li>
<li>Reconnected (aka was connected)</li>
<li>Disconnected (or never connected before)</li>
</ul>

<p><em>Step #3</em> </p>

<p>If you use a class to 'speak' to a device, it must be dynamically created when device comes available. In my example it is something like this:</p>

<pre><code>TOLEDdisplay* display; // declaration
......
......
display = new TOLEDdisplay( SDA, SCL ); // To create it
display-&gt;begin(); // it's a pointer to an object so you need to use -&gt; instead of . (simple explanation ;-) )
......
// etc 
</code></pre>

<p><em>Step #4</em> </p>

<p>Before each update, you need to check the availability and the state of initialization (the three states mentioned in step #3). This is very important to avoid unnecessary delays/code execution (stress). </p>

<ul>
<li>If it wasn't connected before, you need the create the class</li>
<li>If it was connected before (a reconnect), you have to reinitialize (the class and thus the device)</li>
</ul>

<p><em>Step #5</em></p>

<p>You need to check for changes, in a loop or an interrupt. Better do it in a loop instead of an interrupt.</p>

<p><em>Step #6</em></p>

<p>Perform updates when changes are detected. Use a little delay of about 200ms seconds before the real update. </p>

<hr>

<p><strong>Some example code</strong></p>

<p>You cannot use this code, however, it can give you some idea how to design your code. I use many macro's to simplify my actual code, so it is easier to read:</p>

<pre><code>void TEnjoyPad::showAbout() // only showed at initialization
{
  __tepClearDisplay();

  __tepSetDisplayText( ""ENJOYPAD v1.0""     , TOD_TEXT_ALIGN_CENTER, TEP_DISPLAY_LINE1 );
  __tepSetDisplayText( ""(c) 2017 codebeat"" , TOD_TEXT_ALIGN_CENTER, TEP_DISPLAY_LINE2 );


  __tepRefreshDisplay();
  setDelay( 2000 );
  updateDisplay();

}

void TEnjoyPad::updateDisplay()
{
 if( !__tepDisplayIsInit() )
  { return; }


 __tepDrawDisplayBitmap( TEP_DISPLAY,           // bitmap
                         0, TEP_DISPLAY_LINE0,  // x,y
                         TEP_DISPLAY_WIDTH,
                         TEP_DISPLAY_HEIGHT
                        );

  uint8_t i = TEP_MIN_MODE - 1;

  __tepDrawDisplayClearRect( 0, 10, 128, 35 );

  while( ++i &lt;= TEP_MAX_MODE )
  {
    if ( emuMode != i )
    {
      // erase area, delete what's NOT selected
      __tepDrawDisplayClearRect( TEP_DISPLAY_MODE_ICON_X + ((i - 1) * (TEP_DISPLAY_MODE_ICON_WIDTH + TEP_DISPLAY_MODE_ICON_SPACING)),
                                 TEP_DISPLAY_MODE_ICON_Y,
                                 TEP_DISPLAY_MODE_ICON_WIDTH,
                                 TEP_DISPLAY_MODE_ICON_HEIGHT
                               );
    }
    else {
            __tepSetDisplayText( TEP_MODE_GET_NAME(i), TOD_TEXT_ALIGN_CENTER, TEP_DISPLAY_LINE1 );
         }
  }

  __tepRefreshDisplay();
}

void TEnjoyPad::beginDisplay( bool bIsFound = false )
{
  static bool bWasConnected = false;

  bIsFound = bIsFound?true:isPnpDeviceAvailable( TEP_PNP_ADDR_DISPLAY );

  if( bIsFound )
  {
    if( !bWasConnected  )
    {
      if( pnpStates[ TEP_PNP_IDX_DISPLAY ] )
      {
        // Reset
        setDelay( 200 );
        // Reset display
        bIsFound = isPnpDeviceAvailable( TEP_PNP_ADDR_DISPLAY );
        if( bIsFound )
        {
          __tepDisplay-&gt;begin(); 
          updateDisplay();
        } 
      }
     else {
            // (re-)connected"" );
            __tepCreateDisplay(); // This macro checks also if class is created
            __tepInitDisplay();
            showAbout();

             // Set class is created
            pnpStates[ TEP_PNP_IDX_DISPLAY ] = TEP_PNP_ADDR_DISPLAY;
          }  
    }

    bWasConnected = bIsFound;
  }
  else { 
            // Disconnected           
            bWasConnected = false; 
       }  
} 

 // In a loop I call this function:
uint8_t TEnjoyPad::i2CPnpScan()
{
  uint8_t iAddress = 0x7F; // 127
  bool    bFound   = false;
  uint8_t iFound   = 0;

  //Serial.println( ""Scanning PNP devices...."" );
  while ( --iAddress )
  {
    //Serial.print( ""Scanning address: 0x"" );
    //Serial.println( iAddress, HEX );

    if( iAddress == TEP_PNP_ADDR_DISPLAY )
     { beginDisplay( bFound = isPnpDeviceAvailable( iAddress ) ); 
       iFound+=bFound;
     }
  }

  return iFound;
}
</code></pre>

<hr>

<p><strong>Demo video</strong></p>

<p>I also create a demo video, proof of concept, to show you this method is working fine. You can watch the video on YouTube:
<a href=""https://www.youtube.com/watch?v=ODWqPQJk8Xo"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=ODWqPQJk8Xo</a></p>

<hr>

<p>Thank you all for the help and hopefully this info can help others too.</p>

<hr>

<p><strong>UPDATE:</strong></p>

<p>My method seems to work fine with several I2C devices. I wrote this renewed I2CScanner:</p>

<hr>

<p><strong>I2CScanner code that you can use:</strong></p>

<pre><code>/*
 ----------------------------------------
 i2c_scanner - I2C Master Library Version

 Version 1 (Wire library version)
    This program (or code that looks like it)
    can be found in many places.
    For example on the Arduino.cc forum.
    The original author is not know.

 Version 2, Juni 2012, Using Arduino 1.0.1
     Adapted to be as simple as possible by Arduino.cc user Krodal

 Version 3, Feb 26  2013
    V3 by louarnold

 Version 4, March 3, 2013, Using Arduino 1.0.3
    by Arduino.cc user Krodal.
    Changes by louarnold removed.
    Scanning addresses changed from 0...127 to 1...119,
    according to the i2c scanner by Nick Gammon
    http:www.gammon.com.au/forum/?id=10896

 Version 5, March 28, 2013
    As version 4, but address scans now to 127.
    A sensor seems to use address 120.

 Version 6, November 27, 2015.
    Added waiting for the Leonardo serial communication.

 Version 7, September 11, 2017 (I2C Master Library version)
    - By codebeat
    - Changed/Optimize code and variable names
    - Add configuration defines
    - Add fallback define to standard Wire library
    - Split functionality into functions so it is easier to integrate 
    - Table like output


 This sketch tests the standard 7-bit addresses between
 range 1 to 126 (0x01 to 0x7E)
 Devices with higher addresses cannot be seen.

 ---------------------
 WHY THIS NEW VERSION?

 The Wire library is not that great when it comes to stability, 
 reliability, it can cause the hardware to freeze because of
 infinite loops inside the library when connection is lost or
 the connection is unstable for some reason. Because of that
 the Wire library is also not suitable for plug and play 
 functionality, unplugging an I2C device will immediately
 lock the hardware (if you want to talk to it) and you 
 need to reset the hardware. I will not recover on itselfs.  

 Another reason is the way to check if a device is plugged-in
 or not. The methods of the Wire library doesn't allow to 
 do this because it resets/stop the I2C device when it is
 already started/available.



 Benefits of the I2C Master Library:
 - More flexible;
 - Faster;
 - Smaller compile size;
 - Idiot proof;
 - Self recovering (no hardware freeze);    
 - Able to check for availability of devices without 
   interrupt bus status and/or device (see the 
   example function isDeviceAvailable() how to achieve 
   this)
   .

 More info at:
 http://dsscircuits.com/articles/arduino-i2c-master-library
 You can also download the library there.

 PRECAUTIONS:
 It is a good idea to stabilize the readouts of the bus. 
 Add two resistors (4.7K) on the +5V output to the data lines. 
 Only one pair is required, don't use more or different resistors.
 It is very important to do this to avoid false detections and to 
 avoid your Arduino can still freeze because of that. 

 NOTICE:
 When selecting the default Wire library, this scanner will probably 
 not show the side effects I am talking about because the code 
 don't talk to the device and the connection to a device is extremely 
 short period of time.
*/

// *** Uncomment this if you want to use the default Wire library.
//#define I2C_LIB_WIRE

 // Some settings you can change if you want but be careful
#define I2C_MIN_ADDRESS     0x01
#define I2C_MAX_ADDRESS     0x7F
#define I2C_UPDATE_TIMEOUT  3000
#define I2C_I2CLIB_TIMEOUT  1000
#define I2C_I2CLIB_FASTBUS  true


 // Errorcodes that are normal errors when I2C device does
 // not exists.
#define I2C_I2CLIB_ERROR_NOT_AVAIL  32
#define I2C_WIRELIB_ERROR_NOT_AVAIL  2


// -------------------------------------------------------------


#ifdef I2C_LIB_WIRE
 #define I2C_ERROR_NOT_AVAIL I2C_WIRELIB_ERROR_NOT_AVAIL
  // Compile size with Wire library: 6014 bytes
 #include &lt;Wire.h&gt;
 #pragma message ""Compiled with Wire library""
#else 
 #define I2C_ERROR_NOT_AVAIL I2C_I2CLIB_ERROR_NOT_AVAIL
  // Compile size with I2C Master library: 5098 bytes
 #include &lt;I2C.h&gt;
 #define Wire I2c
 #pragma message ""Compiled with I2C Master library""
#endif


// -------------------------------------------------------------


int iLastError = 0;

bool isDeviceAvailable( uint8_t iAddress )
{
 #ifdef I2C_LIB_WIRE
  // Wire:
  // The i2c_scanner uses the return value of the Write.endTransmisstion 
  // to see if a device did acknowledge to the address.
  Wire.beginTransmission( iAddress );
  iLastError = Wire.endTransmission();  
 #else
   // I2C Master Library:
   // Just send/write a meaningless 0x00 command to the address 
   // to figure out the device is there and the device answers.
  iLastError = Wire.write( (int)iAddress, (int)0x00 ); 
  // Notice: The (int) typecasting is required to avoid compiler  
  //         function candidate notice. 
 #endif  

 return ( iLastError == 0x00 ); 
}

byte findI2Cdevices( bool bVerbose = true ) 
{
  byte nDevices = 0;

  if( bVerbose )
   { Serial.println(""Scanning...""); }

  for(byte iAddress = I2C_MIN_ADDRESS; iAddress &lt; I2C_MAX_ADDRESS; iAddress++ ) 
  {
    if( bVerbose )
    {
     Serial.print(""Address 0x"");
     if( iAddress &lt; 16 ) 
      { Serial.print(""0""); }

     Serial.print( iAddress, HEX );
     Serial.print("": "");
    }

    if( isDeviceAvailable( iAddress ) )
    {
      if( bVerbose )
       { Serial.println(""FOUND  !""); }
      nDevices++;
    }
    else { 
            if( bVerbose )
            {
              Serial.print( ""&lt;NO DEVICE FOUND"" ); 
              if( iLastError != I2C_ERROR_NOT_AVAIL )
              {
                Serial.print( "" - ERRCODE: "" );
                Serial.print( iLastError );
              }
              Serial.println( ""&gt;"" ); 
            }
         }    
  }

  if( bVerbose )
  {
    if( nDevices &gt; 0 )
    { 
      Serial.print( nDevices );
      Serial.println( "" device(s) found\n"" ); 
    }
    else { Serial.println( ""No I2C devices found\n""); }

    Serial.print( ""Press CTRL+A, CRTL+C to copy data.\n"" );
  }

  return nDevices;
}

void setupI2C()
{
 Wire.begin();

 #ifndef I2C_LIB_WIRE  
  // This is important, don't set too low, never set it zero.
  Wire.timeOut( I2C_I2CLIB_TIMEOUT ); 

  #ifdef I2C_I2CLIB_FASTBUS
   if( I2C_I2CLIB_FASTBUS )
    { Wire.setSpeed(1); }
  #endif
 #endif
}

void setupSerial()
{
 Serial.begin(9600);
 while (!Serial); // Leonardo: wait for serial monitor
 Serial.println(""\nI2C Scanner"");
}

// -------------------------------------------------------------

void setup()
{
  setupI2C();
  setupSerial();
}

void loop()
{
    // Skip the Arduino slow down housekeeping after the loop() 
    // function, we stay here forever ;-) 
   while(1)
   {
     findI2Cdevices();
     delay( I2C_UPDATE_TIMEOUT ); // wait n seconds for next scan
   }
}
</code></pre>
",,55417238,556
46128556,2,46128464,2017-09-09T08:09:22.570,1,,5812238,,2017-09-09T08:09:22.570,,1,,"<p>Use <a href=""http://en.cppreference.com/w/cpp/string/byte/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a>:</p>

<pre><code>char rawData[] = ""9000, 4500, 650, 550, 650, 1650, 600, 550, 650, 550, 600, 1650, 650, 550, 600, 1650, 650, 1650, 650, 1650, 600, 550, 650, 1650, 650, 1650, 650, 550, 600, 1650, 650, 1650, 650, 550, 650, 550, 650, 1650, 650, 550, 650, 550, 650, 550, 600, 550, 650, 550, 650, 550, 650, 1650, 600, 550, 650, 1650, 650, 1650, 650, 1650, 650, 1650, 650, 1650, 650, 1650, 600"";
size_t rawDataLength = 67;

uint16_t blawData[rawDataLength];
char *token = strtok(rawData, "", "");
for (size_t i = 0; i &lt; rawDataLength; ++i) {
    blawData[i] = atoi(token);
    token = strtok(nullptr, "", "");
}
//assert(token == nullptr);
</code></pre>

<p><a href=""https://ideone.com/ip8mrd"" rel=""nofollow noreferrer"">Ideone</a></p>
",,55452548,96
46133894,2,46128464,2017-09-09T18:32:55.730,0,,4589425,,2017-09-09T18:32:55.730,,0,,"<pre><code>char* rawData = ""9000, 4500, 650, 550, 650, 1650, 600, 550, 650, 550, 600, 
1650, 650, 550, 600, 1650, 650, 1650, 650, 1650, 600, 550, 650, 1650, 650, 
1650, 650, 550, 600, 1650, 650, 1650, 650, 550, 650, 550, 650, 1650, 650, 
550, 650, 550, 650, 550, 600, 550, 650, 550, 650, 550, 650, 1650, 600, 550, 
650, 1650, 650, 1650, 650, 1650, 650, 1650, 650, 1650, 650, 1650, 600"";

const char s[3] = "", "";
char *token;
uint16_t crawlCall[200] = {};
int while_count = 0;
token = strtok(rawData, s);
while( token != NULL ) 
{
  int i =  atoi (token);
  crawlCall[while_count] = i;
  token = strtok(NULL, s);
  while_count++;
}
</code></pre>

<p>I am new to all this so it probably isn't optimal, but crawlCall is the uint16_t value I was looking for.</p>
",,55489106,520
46234305,2,46231706,2017-09-15T07:43:23.380,0,,7586668,,2017-09-15T07:50:02.713,2017-09-15T07:50:02.713,0,,"<p>I think it's best if we print the indices to the Serial Monitor to see if it's working. Try these codes below.</p>

<pre><code>int totalCols = 4;
int totalRows = 5;

// exclude pins 0 and 1 since these are used for Serial communication
int keyCols[] = { 2, 4, 5,  6     }; 
int keyRows[] = { 7, 8, 9, 10, 11 };

void setup() 
{
    Serial.begin(9600); // begin Serial Communication at 9600 baudrate
    pinMode(13, OUTPUT);
    for (int i = 0; i &lt; totalCols; i++)
        pinMode(keyCols[i], OUTPUT);

    for (int i = 0; i &lt; totalRows; i++) 
        pinMode(keyRows[i], INPUT); // you can use INPUT instead
}

void loop() {
    for (int i = 0; i &lt; totalCols; i++) {
        digitalWrite(keyCols[i], HIGH);
        ScanActiveRows(i);
        digitalWrite(keyCols[i], LOW);
    }
}

void ScanActiveRows(int col) {
    delay(5); // wait for 5 milliseconds after setting column pin
    for (int row = 0; row &lt; totalRows; row++) {
        if (digitalRead(keyRows[row]) == HIGH) {

            // print column and row indices
            Serial.print(""Column : "");
            Serial.println(col);
            Serial.print(""Row : "");
            Serial.println(row);

        }
        else if (digitalRead(keyRows[row]) == LOW) {
            digitalWrite(13,LOW);
        }
    }
}
</code></pre>

<p>If the above code outputs the exact column and row, then the blink for-loop is the problem. I hope this helps. This is my first time answering. :)</p>
",,55511331,239
46271149,2,46270236,2017-09-18T03:21:44.463,0,,4983082,,2017-09-18T03:21:44.463,,6,,"<p>You can see <a href=""https://doc.qt.io/qt-5/qtserialbus-can-example.html"" rel=""nofollow noreferrer"">this example</a>. </p>

<p>To store data in log file, you can write data like this.</p>

<pre><code>QByteArray data = serial-&gt;readAll();
QFile file(""log.csv"");
file.open(QIODevice::Append);
file.write(data);
file.close();
</code></pre>
",,55527046,94
46278042,2,46277313,2017-09-18T11:19:30.200,1,,918959,,2017-09-18T11:19:30.200,,5,,"<p>The <code>mmap</code> object in Python is rather different from pointers in C. The <code>mmap</code> object behaves rather like a <em>bytearray</em>, with some extra methods. However the bytearray interface is the most useful here. The C code adds an offset to the base address to get a pointer to the first byte of the timer value, then converts this to a pointer to a <code>long long int</code>. In Python we can do a similar thing by <em>slicing</em> a part of the bytearray, specifically <code>sizeof (long long int)</code> bytes starting from the offset, and using the <a href=""https://docs.python.org/3/library/struct.html"" rel=""nofollow noreferrer""><code>struct</code></a> module to decode the value.</p>

<p>Thus we get something like</p>

<pre><code>import struct
sizeof_long_long = struct.calcsize('q')

...


    timer_bytes = stBase[TIMER_OFFSET:TIMER_OFFSET + sizeof_long_long]
    print(timer_bytes)

    # struct.unpack would return a tuple of one element, note the comma.
    timer_value, = struct.unpack('q', timer_bytes)
    print(timer_value)
</code></pre>
",,55540460,266
46320085,2,46277313,2017-09-20T10:50:58.340,2,,8541718,,2017-09-20T10:50:58.340,,0,,"<p>Almost good  :) Just unpack_from instead off unpack</p>

<pre><code>import os, mmap, sys
import struct

ST_BASE = 0x3F003000
TIMER_OFFSET = 4
sizeof_long_long = struct.calcsize(""Q"")
LENGTH = TIMER_OFFSET + sizeof_long_long

def timer():
    fd = os.open(""/dev/mem"", os.O_RDONLY | os.O_SYNC)
    stBase = mmap.mmap(fileno=fd, length=4096, access=mmap.ACCESS_COPY, offset=ST_BASE)
    os.close(fd)

    while True:
        timer_value = struct.unpack_from(""Q"", stBase, TIMER_OFFSET)[0]
        print(""timer_value"")
</code></pre>
",,55560673,769
46390787,2,46279057,2017-09-24T13:53:01.537,1,,8505251,,2017-09-24T13:53:01.537,,0,,"<p>okey i'v secceded to opreate the motor,and also added some other function like changing direction and controling speed.
one problem i'm facing know is that whan the user changing the speed ,the motor stop and than apllied the speed ,and that can cuase a motor a fialure if the speed is very high.(speed is given as the delay time between stepper motor steps).
here is the codes,if any one has sulotion for the speed control i would be please to hear and learn :)</p>

<p>python code: </p>

<pre><code>import serial  # Import Serial Library
from Tkinter import *
import time

usbport = 'COM3'
serial_begin_is = 38400
arduinoSerialData = serial.Serial(usbport, serial_begin_is,timeout=0.5)  # Create Serial port object called arduinoSerialData


    class GUI():
        def __init__(self, root,arduinoSerialData):
            # type: (object) -&gt; object
            self.root = root
            self.root.geometry(""750x600"")
            self.root.title(""motor"")
            self.CreateWidgets()
            self.spin = 0
            self.num = 1
            self.arduinoSerialData=arduinoSerialData
            self.flag = True;

        def CreateWidgets(self):
            self.number_of_spins = 0
            self.speed_value = 150
            self.spin_num = StringVar()
            self.speed_val = StringVar()
            self.spin_num_entry = Entry(self.root, textvariable=self.spin_num)
            self.spin_num_entry.place(x=200, y=20)
            self.spin_num_chose = Label(self.root, text=""enter spin numbers:"")
            self.spin_num_chose.place(x=50, y=20)
            self.enter_spin_num = Button(self.root, text=""enter"", command=lambda: self.set())
            self.enter_spin_num.place(x=200, y=45)
            # self.spin_num_label = Label(self.root, text=""spin num will be"" +str(self.number_of_spins))
            # self.spin_num_label.place(x=255, y=45)
            self.speed_label = Label(text=""speed val will be:""+str(self.speed_value))
            self.speed_label.place(x=550,y=75)
            self.speed_b = Button(self.root, text=""enter"", command=lambda: self.speed_set())
            self.speed_b.place(x=550, y=45)
            self.speed_num_entry = Entry(self.root, textvariable=self.speed_val)
            self.speed_num_entry.place(x=550, y=20)
            self.speed_num_chose = Label(self.root, text=""enter speed value:"")
            self.speed_num_chose.place(x=420, y=20)
            self.spin_num_label = Label(self.root, text=""spin num will be: "" + str(self.number_of_spins))
            self.spin_num_label.place(x=255, y=45)
            self.run_b = Button(self.root, text=""run"", command=lambda: self.run())
            self.run_b.place(x=255, y=85)
            self.run_b.config(state=DISABLED)
            self.spin_num_B = Button(self.root, text=""stop&amp;reset"", command=lambda: self.send_stop())
            self.spin_num_B.place(x=255, y=150)
            self.quit_b = Button(self.root, text=""quit"", command=lambda: root.destroy())
            self.quit_b.place(x=50, y=500)
            self.dir_b = Button(self.root, text=""change direction"", command=lambda: self.dirf())
            self.dir_b.place(x=295, y=85)

        def set(self):
            self.number_of_spins = int(self.spin_num_entry.get())
            self.data = [b""s""]
            #self.arduinoSerialData.write(self.data)
            value = list(str(self.number_of_spins))
            for char in value:
                self.data.append(char.encode())
            print self.data
            self.spin_num_label.config(text=""spin num will be: "" + str(self.number_of_spins))
            self.run_b.config(state=NORMAL)
        def run(self):
            run_char= ""r""
            self.data[0] = run_char.encode()
            print self.data
            self.arduinoSerialData.write(self.data)
            print ""run""
            self.spin_num_entry.delete(0, END)

        def send_stop(self):
            stop = ""s""
            self.data[0] =stop.encode()
            self.arduinoSerialData.write(self.data)
            print self.data
            self.arduinoSerialData.close()
            self.arduinoSerialData = serial.Serial(usbport, serial_begin_is)
            self.speed_label.place_forget()
            self.speed_label.config(text=""speed val will be:"" +str(self.speed_value))
            self.speed_label.place(x=550, y=75)
            time.sleep(0.05)

        def dirf(self):
            print ""direction had been chaged ""
            self.arduinoSerialData.write(b""d"")
        def speed_set(self):
            self.speed_label.place_forget()
            self.speed_label.config(text=""speed val will be:""+self.speed_num_entry.get())
            self.speed_label.place(x=550, y=75)
            self.speed_in_int = int(self.speed_num_entry.get())
            self.data_speed = [b""v""]
            value = list(str(self.speed_in_int))
            for char in value:
                self.data_speed.append(char.encode())
            print self.data_speed
            self.arduinoSerialData.write(self.data_speed)


    root = Tk()
    GUI(root,arduinoSerialData)
    root.mainloop()
</code></pre>

<p>Arduino code:</p>

<pre><code>int cnt = 0 ;
long spin=0;
float num = 1.0 ;
float speed1 = 150;
char start ;
bool prt = false;
bool dirf = true;
int flag =0;
String data[2];
void setup() {
  // put your setup code here, to run once:
Serial.begin(38400);
#define stepPin 4
#define dirPin 7
#define enable 8
 pinMode(stepPin, OUTPUT);
 pinMode(dirPin, OUTPUT);
 pinMode(enable, OUTPUT);  
 digitalWrite(enable, HIGH); 
 digitalWrite(dirPin, HIGH);

}

void loop() {
  // put your main code here, to run repeatedly:

  while(Serial.available()&gt;0){
   if (Serial.peek() == 'r') {
      prt = true;  
      Serial.read();
      num = Serial.parseInt();
      //Serial.println(num);
   }
    if (prt){

    while(spin &lt;200*32*num){   
      move();
      spin++;
      if (Serial.peek() == 's') {
          Serial.read();
          digitalWrite(enable, HIGH); 
          prt = false;
          spin = 200*32*num;
        }
      if (Serial.peek() == 'd') {
         Serial.read();
         dirf = !dirf;
         dir();
         Serial.read();
      }
       if (Serial.peek() == 'v') {
         Serial.read();
         speed1 = Serial.parseInt(); 
         Serial.read();
      }
     }
    prt = false;
    spin = 0;
    //num = 1;
    }


  if (Serial.peek() == 's') {
    Serial.read();
    digitalWrite(enable, HIGH);
    prt = false;
    spin = 0;
    num = 1;
  }
  if (Serial.peek() == 'd') {
         dirf = !dirf;
         dir();
      }
  if (Serial.peek() == 'v') {
         Serial.read();
         speed1 = Serial.parseInt(); 
         Serial.read();
      }
}
  /*
      while (Serial.available() &gt; 0) {
        Serial.read();
      }
  */
}


void move () {
  digitalWrite(enable, LOW);
  digitalWrite(stepPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(stepPin, LOW);
  delayMicroseconds(speed1); 

}
void dir (){

   if (dirf)
      digitalWrite(dirPin, HIGH);
  else
     digitalWrite(dirPin, LOW);

}
</code></pre>
",,55570854,77
46317193,2,46315757,2017-09-20T08:38:11.950,0,,6002560,,2017-09-20T08:45:08.323,2017-09-20T08:45:08.323,0,,"<p>Try this</p>

<pre><code>std::cout &lt;&lt; ""locking in main"" &lt;&lt; std::endl;
std::unique_lock&lt;std::mutex&gt; lock(m);
std::cout &lt;&lt; ""locked in main"" &lt;&lt; std::endl;

std::cout &lt;&lt; ""starting thread"" &lt;&lt; std::endl;
std::thread t([&amp;cv, &amp;m, &amp;ok]() {
    std::cout &lt;&lt; ""locking in thread"" &lt;&lt; std::endl;
    std::unique_lock&lt;std::mutex&gt; lock(m);
    std::cout &lt;&lt; ""locked in thread"" &lt;&lt; std::endl;
    ok = true;
    std::cout &lt;&lt; ""unlocking in thread"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""signalling cv"" &lt;&lt; std::endl;
    cv.notify_one();
});

std::cout &lt;&lt; ""starting wait"" &lt;&lt; std::endl;
while(!ok)
    cv.wait(lock);
std::cout &lt;&lt; ""finished waiting: "" &lt;&lt; ok &lt;&lt; std::endl;

std::cout &lt;&lt; ""unlocking in main"" &lt;&lt; std::endl;
lock.unlock();
std::cout &lt;&lt; ""joining thread"" &lt;&lt; std::endl;
t.join();
std::cout &lt;&lt; ""thread joined"" &lt;&lt; std::endl;
</code></pre>

<p>Furthemore, I think that you should avoid to unlock mutex within thread, because at the end of scope, unique_lock automatically releases lock     </p>
",,55579371,161
46452980,2,46426172,2017-09-27T16:33:16.173,1,,3306446,,2017-09-27T16:33:16.173,,0,,"<p>I think you missed the clearing of pending timer interrupts. </p>

<pre><code>ISR(TIMER2_COMPA_vect) {
   TIMSK2 &amp;= ~(1 &lt;&lt; OCIE2A);    // disable interrupt
   /* Clear pending interrupts */ 
   TIFR2 = (1 &lt;&lt; TOV2) | (1 &lt;&lt; OCF2A) | (1 &lt;&lt; OCF2B);
   // do stuff
} 
</code></pre>
",,55645481,3128
46457783,2,46428396,2017-09-27T21:52:17.440,1,,8436941,,2017-09-28T15:33:35.903,2017-09-28T15:33:35.903,4,,"<p>For each of the packets that fail the checksum test, you find a <code>CHAR_PRELIM</code>  (66) either in the middle or at the end. This means the sensor is occasionally dropping packets and causing misalignment. </p>

<p><strike>One solution is to restart packet reading each time a 66 is read. This code should do it:</strike></p>

<p><strong>UPDATE</strong>: as per @sawdust's comment, the presence of both <code>66</code> and <code>77</code> should be used as a start condition because it may be possible for <code>66</code> to appear by itself in the data. The other consideration is to use the packet length provided by the 3rd and 4th bytes instead of assuming the length to be 32. Hopefully these improvements make the code more durable.</p>

<pre><code>size_t length;
incomingByte[0] = 66; // the first two bytes are always known
incomingByte[1] = 77;

... 

if (serial.available()) {
  if (serial.read() == 66 &amp;&amp; serial.read() == 77)
    incomingByte[2] = serial.read(); // length high byte
    incomingByte[3] = serial.read(); // length low byte
    int length = (incomingByte[2] &lt;&lt; 8) + incomingByte[3];

    // starting at index 4, read `length` bytes
    serial.readBytes(incomingByte + 4, length);
    break;
  }
}

// when the code breaks out of the while(1) loop, you still need to evaluate the checksum.
</code></pre>

<p>According to the protocol defined by <a href=""https://www.dfrobot.com/wiki/index.php/PM2.5_laser_dust_sensor_SKU:SEN0177#Specification"" rel=""nofollow noreferrer"">this source</a>, the packet length is fixed at 32 bytes, so the encoded frame length (bytes 3 and 4) should always equal <code>0 28</code> (32 bytes - 2 start bytes - 2 frame length bytes = 28). </p>

<p>However, this code should work even for variable length packets (thanks @sawdust).</p>

<p><strong>Fair warning</strong>: I do not have one of these sensors, so obviously I didn't test this, but the concept remains.</p>

<p>I recognize that this code won't <em>solve</em> the issue of characters being dropped, <strike>since it just ignores incomplete packets</strike> and you still rely on the validity of the checksum.</p>

<p>Finally, I find it interesting that the reason that the checksum is failing is because <strong>the checksum bytes are not even being received</strong> in those cases!</p>

<p>Hope this helps!</p>

<hr>

<p><strong>UPDATE #2</strong>: <strong>This is more or less a revised answer in it of itself.</strong></p>

<p>Using this code to read packets, the following criteria (which are defined by the protocol) are guaranteed:</p>

<ol>
<li>The packets begins with [66 77]</li>
<li>The packet contains 32 bytes</li>
<li>The start condition [66 77] will never occur in the body of the packet.</li>
</ol>

<p>Here's the code. I manage to reduce it down to  a few <code>if</code> statements</p>

<pre><code>void PMS5003::processDataOn(HardwareSerial &amp;serial) {
    bool possibleStart = false;
    incomeByte[0] = 66;
    incomeByte[1] = 77;
    uint8_t count = 0;

    ...

    while (1) {
        ...

        if (serial.available()) {    
            uint8_t c = serial.read();

            if (possibleStart) {
                possibleStart = false;
                if (c == 77) count = 2;
            }
            if (c == 66) possibleStart = true;

            if (count &gt;= 2) incomeByte[count++] = c;
            if (count == NUM_DATA_BYTE) break;      
        }
    }

    // at this point, incomeByte must:\
    // &gt; begin with [66 77]
    // &gt; contain 32 bytes
    // &gt; not contain [66 77] anywhere after the first two bytes
    // &gt; therefore, it is guaranteed to contain a checksum

    // now is the right time to evaluate the checksum.
    // I expect all of the checksums to match, but you might as well check
}
</code></pre>

<p>At the time of posting, the OP has already coded a solution which fulfills the requirements. I am posting this because I believe this code improves upon the OP's by being more concise, more readable/declarative, and hopefully more easily manageable.</p>

<p>This code can also serve as a <strong>general solution for any case</strong> in which <em>two characters</em> define a start condition, provided the <em>packet length is known or can be determined</em>. </p>
",,55647368,164
46465908,2,46428396,2017-09-28T09:41:41.857,0,,1252334,,2017-09-28T09:41:41.857,,2,,"<p>While the question why the data comes corrupted still remains, here is a workaround I managed to achieve:</p>

<ol>
<li>I'm checking the checksum, if it's incorrect, then:</li>
<li>I'm looking for <code>66 77</code> in the whole data. When I find it:</li>
<li>I'm checking if in the next 16 bytes there's another <code>66 77</code>. If it's not found:</li>
<li>I'm presuming the values that are distanced by 10-15 bytes from <code>66 77</code> are the ones I'm looking for (PM1, PM2.5, PM10).</li>
</ol>

<p>Here's the code:</p>

<pre><code>void PMS5003::processDataOn(HardwareSerial &amp;serial) {
  unsigned long timeout = millis();
  int count = 0;
  byte incomeByte[NUM_INCOME_BYTE];
  boolean startcount = false;
  byte data;
  int timeoutHops = 0;
  while (1){
    if (((millis() - timeout) &gt; 1000) &amp;&amp; (timeoutHops == 0)) {
      timeoutHops = 1;
      yield();
      ESP.wdtFeed();
    }
    if (((millis() - timeout) &gt; 2000) &amp;&amp; (timeoutHops == 1)) {
      timeoutHops = 2;
      yield();
      ESP.wdtFeed();
    }
    if ((millis() - timeout) &gt; 3000) {
      yield();
      ESP.wdtFeed();
      Serial.println(""SENSOR-ERROR-TIMEOUT"");
      break;
    }
    if (serial.available()) {
      data = serial.read();
      if (data == CHAR_PRELIM &amp;&amp; !startcount) {
        startcount = true;
        count++;
        incomeByte[0] = data;
      } else if (startcount) {
        count++;
        incomeByte[count - 1] = data;
        if (count &gt;= NUM_INCOME_BYTE){
          break;
        }
      }
    }
  }
  unsigned int calcsum = 0;
  unsigned int exptsum;
  for (int a = 0; a &lt; NUM_INCOME_BYTE; a++) {
    Serial.print((unsigned int)incomeByte[a]);
    Serial.print("" "");
  }
  Serial.println();
  Serial.println(((unsigned int)incomeByte[PM25_BYTE] &lt;&lt; 8) + (unsigned int)incomeByte[PM25_BYTE + 1]);
  for (int i = 0; i &lt; NUM_DATA_BYTE; i++) {
    calcsum += (unsigned int)incomeByte[i];
  }
  exptsum = ((unsigned int)incomeByte[CHECK_BYTE] &lt;&lt; 8) + (unsigned int)incomeByte[CHECK_BYTE + 1];
  if (calcsum == exptsum) {
    pm1 = ((unsigned int)incomeByte[PM1_BYTE] &lt;&lt; 8) + (unsigned int)incomeByte[PM1_BYTE + 1];
    pm25 = ((unsigned int)incomeByte[PM25_BYTE] &lt;&lt; 8) + (unsigned int)incomeByte[PM25_BYTE + 1];
    pm10 = ((unsigned int)incomeByte[PM10_BYTE] &lt;&lt; 8) + (unsigned int)incomeByte[PM10_BYTE + 1];
  } else {
    Serial.println(""#[exception] PM2.5 Sensor CHECKSUM ERROR!"");
    pm1 = -1;
    pm25 = -1;
    pm10 = -1;
    for (int a = 0; a &lt; NUM_INCOME_BYTE; a++) {
      bool valid = true;
      if (((unsigned int)incomeByte[a] == 66) &amp;&amp; ((unsigned int)incomeByte[a+1] == 77)) {
        if (a+16 &lt; NUM_INCOME_BYTE) {
          for (int b = a+1; b &lt; a+15; b++) {
            if (((unsigned int)incomeByte[b] == 66) &amp;&amp; ((unsigned int)incomeByte[b+1] == 77)) {
              valid = false;
              break;
            }
          }
          if (valid) {
            pm1 = ((unsigned int)incomeByte[a+10] &lt;&lt; 8) + (unsigned int)incomeByte[a+11];
            pm25 = ((unsigned int)incomeByte[a+12] &lt;&lt; 8) + (unsigned int)incomeByte[a+13];
            pm10 = ((unsigned int)incomeByte[a+14] &lt;&lt; 8) + (unsigned int)incomeByte[a+15];
            Serial.println(""valid: "");
            Serial.print(pm1);
            Serial.print("" "");
            Serial.print(pm25);
            Serial.print("" "");
            Serial.print(pm10);
            Serial.println();
            break;
          }
        }
      }
    }
  }
  return;
}
</code></pre>

<p>Theoretically, it may produce false positives or negatives but in practice, it just works.</p>

<pre><code>66 77 0 28 0 12 0 15 0 17 0 12 0 15 0 17 9 102 2 176 66 77 0 28 0 12 0 15 0 16 0 12 
15
#[exception] PM2.5 Sensor CHECKSUM ERROR!
valid: 
12 15 17
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 114 2 175 0 73 0 4 0 1 0 0 145 0 3 12 
15
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 114 2 175 0 73 0 4 0 1 0 0 145 0 3 12 
15
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 141 2 190 0 72 0 3 0 1 0 0 145 0 3 52 
15
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 141 2 190 0 72 0 3 0 1 0 0 145 0 3 52 
15
66 77 0 28 0 12 0 16 0 16 0 12 0 16 0 16 9 198 2 202 0 75 0 3 0 0 0 0 145 0 3 125 
16
66 77 0 28 0 12 0 16 0 16 0 66 77 0 28 0 12 0 16 0 16 0 12 0 16 0 16 9 198 2 202 0 
19712
#[exception] PM2.5 Sensor CHECKSUM ERROR!
valid: 
12 16 16
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 174 2 199 0 71 0 3 0 0 0 0 145 0 3 92 
15
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 174 2 199 0 71 0 3 0 0 0 0 145 0 3 92 
15
66 77 0 28 0 12 0 15 0 16 0 12 0 15 0 16 9 174 2 199 66 77 0 28 0 13 0 16 0 16 0 13 
15
#[exception] PM2.5 Sensor CHECKSUM ERROR!
valid: 
12 15 16
66 77 0 28 0 13 0 16 0 16 0 13 0 16 0 16 9 213 2 205 0 72 0 3 0 0 0 0 145 0 3 142 
16
66 77 0 28 0 13 0 16 0 16 0 13 0 16 0 16 9 213 2 205 0 72 0 3 0 0 0 0 145 0 3 142 
16
66 77 0 28 0 13 0 16 0 17 0 13 0 16 0 17 9 207 2 208 0 83 0 6 0 1 0 0 145 0 3 156 
16
66 77 0 28 0 13 0 16 0 17 0 13 0 16 0 17 9 207 2 208 0 83 0 6 0 1 0 0 145 0 3 156 
16
66 77 0 28 0 13 0 17 0 17 0 13 0 17 0 17 9 159 2 202 0 87 0 5 0 1 0 0 145 0 3 107 
17
66 77 0 28 0 13 0 17 0 17 0 66 77 0 28 0 13 0 17 0 17 0 13 0 17 0 17 9 159 2 202 0 
19712
#[exception] PM2.5 Sensor CHECKSUM ERROR!
valid: 
13 17 17
</code></pre>
",,55648053,178
46429211,2,46428903,2017-09-26T14:29:26.307,2,,8628824,,2017-09-26T14:29:26.307,,5,,"<p>You can do it in the same single char basis as:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;wiringSerial.h&gt;

int main ()

  for (;;)
  {
    char c = serialGetchar (fd);
    putchar (c == '!' ? '\r' : c) ;
    fflush (stdout) ;
  }
}
</code></pre>

<p>Normally it is used new line with carriage return, in that case would be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;wiringSerial.h&gt;

int main ()

  for (;;)
  {
    char c = serialGetchar (fd);
    if (c == '!')
    {
        putchar ('\r') ;
        putchar ('\n') ;
    }
    else
    {
        putchar (c) ;
    }
    fflush (stdout) ;
  }
}
</code></pre>
",,55656641,75
46429608,2,46428903,2017-09-26T14:46:10.230,1,,584518,,2017-09-26T14:46:10.230,,2,,"<p>You can replace the whole code with</p>

<pre><code>for(;;)
{
  char c = serialGetchar (fd);
  if(c == '!')
  {
    putchar('\n');
  }
  else
  {
    putchar(c);
    fflush (stdout);
  }
}
</code></pre>

<p>It isn't necessary to flush stdout after writing a <code>'\n'</code> to it - doing this will trigger a flush automatically. So as a minor optimization, this code doesn't flush stdout twice upon finding a <code>'!'</code>.</p>
",,55678021,212
46452340,2,46429388,2017-09-27T15:58:15.463,0,,8677120,,2017-09-27T15:58:15.463,,0,,"<p>This seems to work.  strMsg.toCharArray(msg, i);  Can you please comment on the efficiency of the code?  Is there a better way?  Thanks!</p>

<pre><code>void setup() {
  Serial.begin(9600); // Debugging only
  if (!driver.init())
    Serial.println(""init failed"");
  else
    Serial.println(""TX"");
}

void loop() {
if (Serial.available() &gt; 0)
  {
String strMsg = """";
int i;

strMsg = Serial.readString();
i = (strMsg.length() + 1);
char msg[i] = {};
Serial.print(""Sent: "");
Serial.println(strMsg);
Serial.print(""Size: "");
Serial.println(i);
strMsg.toCharArray(msg, i);
driver.send((uint8_t *)msg, strlen(msg));
driver.waitPacketSent();
delay(200);
 }
}
</code></pre>
",,55680701,1112
46467664,2,46466441,2017-09-28T11:09:08.547,0,,455322,,2017-09-28T11:56:52.173,2017-09-28T11:56:52.173,3,,"<p>First, your code is c++, not strictly c, that's okay, but the tag should be changed.  Here are some problems I found in your code...</p>

<pre><code>    ///// Passing nothing, println requires one or two parameters
    debugSerial.println();
</code></pre>

<p>See <a href=""https://www.arduino.cc/en/Serial/Println"" rel=""nofollow noreferrer"">documentation on println</a></p>

<pre><code>    // init data for the next element of result array
    ////// You are creating a local buffer, it will go out of scope
    ////// when you leave the function.  And you are trying to store
    ////// it in an array that you return from your function.
    ////// And you are changing the data with pass through your loop
    ////// (2 passes).
    SMSData smsData = {"""", """", """", """", """"};

    //...
    ////// You should be assigning an allocated struct pointer
    ////// count is not changing, you are only assigning the last
    ////// element of the array.
    smsArray[count - 1] = smsData;


///// This will not work.  smsArray is a pointer and you have lost
///// the information about how much memory was allocated and assigned to
///// the pointer.
SMSData* smsArray = readSMS(reply);
int count = sizeof(smsArray);
</code></pre>

<p>One trick we use to use with C style pointers as arrays, was to allocate a block of pointers one bigger than we needed, and make sure they were all set to NULL (using calloc() instead of malloc()).  Then, we would set eacch pointer in the array except the last one.  Finally, we would iterate through the array until the pointer was NULL, indicating the end of the data.</p>

<p>You should be storing pointers to allocated data in your smsArray, and you should free (destroy) the that data as well as the array.</p>

<p>So, your code might look something like...</p>

<pre><code>SMSData** smsArray = NULL;
smsArray = (SMSData **)calloc(count+1, sizeof(SMSData *));
int idx = 0;
//...

    SMSData* smsData = new smsData();
    smsData-&gt;id = """"; //etc. for the rest of the fields
    //...

    smsArray[idx++] = smsData;
    //..
</code></pre>

<p>After return...</p>

<pre><code>SMSData ** smsArray = readSMS(reply);
SMSData ** ptr = smsArray;
while (ptr != NULL) {
    //do stuff with ptr-&gt;whatever
    destroy(ptr); //destroy since allocated with new
    ptr++;
}
free(smsArray); //free since allocated with malloc
</code></pre>

<p>This is not the best code (and may have bugs, I don't have access to my compiler right now).  But it tries to stick with your approach.</p>
",,55684371,4805
46611014,2,46467934,2017-10-06T17:27:53.467,0,,8689164,,2017-10-12T02:22:10.707,2017-10-12T02:22:10.707,0,,"<p>So after a ridiculous amount of time and googling, I found the answer.  I ended up using opencv to do the actual color conversion.  Here is my method (continuing from above):</p>

<pre><code>GstBuffer *buffer = gst_sample_get_buffer (sample);
gst_buffer_map (buffer, &amp;map, GST_MAP_READ);
cv::Mat temp_mat = cv::Mat(cv::Size(width, height+height/2), CV_8UC1, (char*)map.data);
cv::Mat result(height,width,3);
cv::cvtColor(temp_mat,result,CV_YUV2RGB_I420,3);
QImage rgb(result.size().width,result.size().height,QImage::Format_RGB888);
memcpy(rgb.scanLine(0), (unsigned char*)result.data, rgb.width() * rgb.height() * result.channels());
((CameraStreamer*)obj)-&gt;emitNewImage(rgb);
gst_buffer_unmap (buffer, &amp;map);
gst_sample_unref (sample);
</code></pre>

<p>I will post more information on my application git repo, but I thought this may help other people.</p>

<p>Here's the link: <a href=""https://github.com/dgitz/DriverStation/blob/master/DriverStation/camerastreamer.cpp"" rel=""nofollow noreferrer"">camera streamer example</a></p>
",,55698070,2804
46475077,2,46472894,2017-09-28T17:27:07.523,0,,7815671,,2017-09-28T17:27:07.523,,0,,"<p>so as it turns out after some extensiv research that BigNumber is not fit for very large numbers but another part of the 'BigNumber.h' lib does its bc_num.</p>

<pre><code>bc_num x;
bc_str2num(&amp;x, ""9898989898"", 10);
String c = ""Controll="";
c+=bc_num2str(x);
Serial.println(c);
</code></pre>

<p>output</p>

<pre><code>Controll=9898989898
</code></pre>

<p>but as you can see this takes a bit more programming to get implamented and so im going to go off and start now bye.</p>
",,55698142,829
46514305,2,46514258,2017-10-01T16:14:11.113,1,,3142971,,2017-10-01T17:13:57.820,2017-10-01T17:13:57.820,5,,"<p>Definitely read a tutorial on C++. What you have here is a basic syntax error. An if/else statements uses the following syntax:</p>

<pre><code>if (condition) {
    // Do stuff here
} else {
    // Do other stuff here
}
</code></pre>

<p>You have a semi colon after your condition in your if statement. Change that to a curly brace and you’re good! So this:</p>

<pre><code>if (bumpPin == HIGH);
</code></pre>

<p>Should be this:</p>

<pre><code>if (bumpPin == HIGH) {
</code></pre>

<p><a href=""https://www.cprogramming.com/tutorial.html"" rel=""nofollow noreferrer"">Here</a> is an online C++ tutorial. </p>

<p><a href=""https://www.cprogramming.com/tutorial/lesson2.html"" rel=""nofollow noreferrer"">Here</a> is that tutorial’s section on if statements. </p>
",,55698382,48
46624450,2,46624337,2017-10-07T19:48:32.690,0,,7336374,,2017-10-07T20:24:02.017,2017-10-07T20:24:02.017,0,,"<p>Well if I am not mistaken in this case nothing.</p>

<p>In most computer programming languages, a while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The while loop can be thought of as a repeating if statement.</p>

<p>Note that if you do have a condition, a while loop must have an exit option, like this:</p>

<pre><code>const int buttonPin = 2;    
int buttonState = 0;        

void setup() {
  Serial.begin(9600);
  pinMode(buttonPin, INPUT);
}

void loop() {
  buttonState = digitalRead(buttonPin);
  if (buttonState == HIGH) {
    Serial.println(""1"");
    buttonState=LOW;
    delay(20000);
    int a =0;
      while(a==0){
        if (something)
          a=1;
      }
  }
}
</code></pre>

<p>Then on your chosen condition you will exit the loop.</p>
",,55735757,465
46636247,2,46626201,2017-10-08T21:26:30.967,0,,565244,,2017-10-09T15:35:13.900,2017-10-09T15:35:13.900,0,,"<p>Okay, I figured it out myself. It seems that pin 9 and pin 16 are not usable with attachInterrupt() so it will never work. Also the usage was not correct, it must be something like this:</p>

<pre><code>attachInterrupt( digitalPinToInterrupt( TEP_PIN_TOUCHSENSOR ), wakeup, HIGH );
</code></pre>

<hr>

<p>Came up with the idea to use a pin change interrupt to wake up the device and this seems to work. However, recovering from sleep mode cannot restore all peripherals without malfunctioning so it needs a hardware reset, it must start from scratch. Also because of changes when sleeping, for example cable disconnected from computer (it also has a battery) and USB connection is lost. Not all of the classes I use are mine and not optimized for such powerdown things.</p>

<p>Anyway, I change the code to this, just to show you the changes, maybe it can help others too:</p>

<hr>

<pre><code>#include &lt;LowPower.h&gt;          // To enter sleep mode, save power 
#include &lt;avr/wdt.h&gt;           // For watchDog device reset


......

#define TEP_IR_RECV_PIN         16
#define TEP_PIN_TOUCHSENSOR     9

    ......
    ......

namespace TEP_LIB_FUNCS
{

void pciSetup(uint8_t iPin)
{
    *digitalPinToPCMSK( iPin ) |= bit( digitalPinToPCMSKbit( iPin ) );  // enable pin
    PCIFR|= bit( digitalPinToPCICRbit( iPin )); // clear any outstanding interrupt
    PCICR|= bit( digitalPinToPCICRbit( iPin )); // enable interrupt for the group
}

#if defined( TEP_PIN_TOUCHSENSOR )
 #if TEP_PIN_TOUCHSENSOR &gt;= 8 &amp;&amp; TEP_PIN_TOUCHSENSOR &lt;= 13 
 ISR(PCINT0_vect) 
 {    
  #define TEP_SLEEP_WAKEUP_PIN_ENABLED 0 
  // Event handler for pins: D8 to D13 
  // Pin change wakeup event handler, does nothing but is required. 
  // Do not remove this.
 } 
 #elif defined(A0) &amp;&amp; defined(A5) &amp;&amp; TEP_PIN_TOUCHSENSOR &gt;= A0 &amp;&amp; TEP_PIN_TOUCHSENSOR &lt;= A5 
 ISR(PCINT1_vect) 
 {    
  #define TEP_SLEEP_WAKEUP_PIN_ENABLED 1 
  // Event handler for pins: A0 to A5 
  // Pin change wakeup event handler, does nothing but is required. 
  // Do not remove this.
 } 
 #elif TEP_PIN_TOUCHSENSOR &gt;= 0 &amp;&amp; TEP_PIN_TOUCHSENSOR &lt;= 7 
 ISR(PCINT2_vect) 
 {    
  #define TEP_SLEEP_WAKEUP_PIN_ENABLED 0 
  // Event handler for pins: A0 to A5 
  // Pin change wakeup event handler, does nothing but is required. 
  // Do not remove this.
 } 
 #endif
#endif

void sleep()
{
  // Possible pins Micro, Leonardo, other 32u4-based:  0, 1, 2, 3, 7.
  // Because we use all pins already by other functions, we cannot
  // use attachInterrupt(), it doesn't work.
  // see also: https://www.arduino.cc/en/Reference/AttachInterrupt
  // Instead of this we use a change event interrupt to wake up 
  // the device from sleep state.  
  //
  // The device can be woke up by using:
  // - The reset button
  // - The touch sensor

  // Okay, lets go
  // We enable interrupts here to be sure it is going to work
 interrupts();

 #ifdef TEP_SLEEP_WAKEUP_PIN_ENABLED
  // Set pin change interrupt enabled for sensor pin
  // (See also https://playground.arduino.cc/Main/PinChangeInterrupt)
   // old code: attachInterrupt( digitalPinToInterrupt( TEP_PIN_TOUCHSENSOR ), wakeup, HIGH );
   // old code: attachInterrupt( digitalPinToInterrupt( TEP_IR_RECV_PIN ), wakeup, HIGH ); 
  pciSetup( TEP_PIN_TOUCHSENSOR );
 #endif

 // Enter power down state with ADC and BOD module disabled.
 // Wake up when wake up pin has changed.
 LowPower.powerDown( SLEEP_FOREVER, ADC_OFF, BOD_OFF );

 // Disable external pin interrupt on wake up pin.
  // old code: detachInterrupt( TEP_PIN_TOUCHSENSOR );
  // old code: detachInterrupt( TEP_IR_RECV_PIN ); 
}


 void softReset()
 {
   wdt_enable(WDTO_15MS);  
   while(true) {}
 } 

  // Function Implementation
 void init(void)
 {
   MCUSR = 0;
   wdt_disable();
 }

} // end namespace TEP_LIB_FUNCS
</code></pre>

<hr>

<p>And also the sleep function of my EnjoyPad class (will be triggered when pushing power button on remote control or when reach timeout when not touched or doing anything):</p>

<pre><code>void TEnjoyPad::setSleepMode()
{
  // Notify user device entering sleep mode, beep twice
 setBeep( 200 );
 setBeep( 200, 100, false );

  // To be sure: Trigger end / unhandled down events and reset states
 reset(init);

  // Shut down any 
 broadcastSleepMode();

  // Handle sleep event
 eventSleep();

  // Stop all peripherals
 end();

  // Turn off onboard led
 digitalWrite( 13, LOW );
 pinMode( 13, INPUT ); 

  // Finally go to sleep, code stops here
 TEP_LIB_FUNCS::sleep();

  // Device woke up
 setBeep( 500, 100, false );

  // Handle wake up event
 eventAwake();

  // Restart whole device, start from scratch.
  // This seems to be the best way to guarantee all 
  // peripherals will be initialized properly
  // and without errors.
 TEP_LIB_FUNCS::softReset();
}
</code></pre>

<hr>

<p><em>NOTICE: Restarting this type of MCU is fast, there is no remarkable difference in speed when you wake up and continue or wake up and reset.</em></p>

<p>That's it for the moment, tanks for watching ;-)</p>

<h2>----------</h2>

<p>EDIT: When adding <code>pciSetup( TEP_IR_RECV_PIN );</code> it also seems to work perfectly (because there is already an interrupt handler defined for it). So the device can also woke up when receiving an IR-command. Didn't expect this was possible but tried it, neat feature.</p>
",,55740114,58
46632750,2,46630884,2017-10-08T15:22:35.703,1,,8396518,,2017-10-09T04:55:48.740,2017-10-09T04:55:48.740,0,,"<p><em>This solution is efficient in the case that there are not many exclusions during the lifetime, once the exclusion function is quadratic.</em></p>

<p>There is a struct called <em>RandomArray</em> that holds a pointer to and array with size N. N is the desired size of the sequence. The time and space complexity is linear O(N) for the create function.</p>

<p>When an event happens it shall call the function <em>excludeValue</em>, with a time complexity of O(N) and space complexity of 1.</p>

<p>If it is desired to exclude a bunch of values, the function <em>excludeValues</em> (pay attention to s at the end) shall be called. In this case the complexity is O(N x K) and the space complexity is 1. K is the amount of values that shall be excluded.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct RandomArray {
  int *pData;
  size_t dataLen;
  int excludedIdx;
};
struct RandomArray *excludeValue(struct RandomArray *pAr, int val) {
  size_t i;
  for (i = 0; i &lt; pAr-&gt;excludedIdx; ++i) {
    if (pAr-&gt;pData[i] == val) {
      pAr-&gt;excludedIdx--;
      int tmp = pAr-&gt;pData[i];
      pAr-&gt;pData[i] = pAr-&gt;pData[pAr-&gt;excludedIdx];
      pAr-&gt;pData[pAr-&gt;excludedIdx] = tmp;
      // Do test again the position
      --i;
    }
  }  return pAr;
}

struct RandomArray *excludeValues(struct RandomArray *pAr, int *pVals, size_t len) {
  size_t i;
  for (i = 0; i &lt; len; ++i)
    excludeValue(pAr, pVals[i]);
}

struct RandomArray *destroyRandomArray(struct RandomArray *pAr) {
  if (pAr) {
    if (pAr-&gt;pData)
      free(pAr-&gt;pData);
    pAr-&gt;dataLen = 0;
  }
  return pAr;
}

struct RandomArray *createRandomArray(
struct RandomArray *pAr,
size_t dataLen,
int lowLimit, int highLimit) {
  int i;
  int range = (highLimit - lowLimit);
  pAr-&gt;pData = (int*)malloc(sizeof(int) * dataLen);
  pAr-&gt;dataLen = dataLen;
  srand(time(NULL));
  for (i = 0; i &lt; dataLen; ++i) {
    pAr-&gt;pData[i] = rand() % (range + 1) + lowLimit;
  }
  // Clear excluded indexs
  pAr-&gt;excludedIdx = pAr-&gt;dataLen;  return pAr;
}

void printRandomArray(struct RandomArray *pAr) {
  size_t i;
  printf(""Random Array (len = %d): "", pAr-&gt;dataLen);
  for (i =0; i &lt; pAr-&gt;dataLen; ++i) {
    printf("" %d"", pAr-&gt;pData[i]);
  }
  printf(""\n"");
}

void printValidRandomArray(struct RandomArray *pAr) {
  size_t i;
  printf(""Valid Random Array (len = %d): "", pAr-&gt;excludedIdx);
  for (i =0; i &lt; pAr-&gt;excludedIdx; ++i) {
    printf("" %d"", pAr-&gt;pData[i]);
  }
  printf(""\n"");
}

void printExcludedRandomArray(struct RandomArray *pAr) {
  size_t i;
  printf(""Excluded Random Array (len = %d): "", pAr-&gt;dataLen - pAr-&gt;excludedIdx);
  for (i = pAr-&gt;excludedIdx; i &lt; pAr-&gt;dataLen; ++i) {
    printf("" %d"", pAr-&gt;pData[i]);
  }
  printf(""\n"");
}

void printAllRandomArray(struct RandomArray *pAr) {
  printRandomArray(pAr);
  printValidRandomArray(pAr);
  printExcludedRandomArray(pAr);
}

int main() {
  int lowLimit = 100;
  int highLimit = 105;
  int arrayLen = 10;
  struct RandomArray myAr;
  createRandomArray(&amp;myAr, arrayLen, lowLimit, highLimit);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 100);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 101);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 102);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 103);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 104);
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  excludeValue(&amp;myAr, 105);
  printAllRandomArray(&amp;myAr);
  destroyRandomArray(&amp;myAr);
  createRandomArray(&amp;myAr, arrayLen, lowLimit, highLimit);
  printf(""\n\n\n"");
  printAllRandomArray(&amp;myAr);
  printf(""\n"");
  int vals[] = { 102, 105, 104  };
  excludeValues(&amp;myAr, vals, sizeof(vals) / sizeof(vals[0]));
  printAllRandomArray(&amp;myAr);
  destroyRandomArray(&amp;myAr);
}
</code></pre>
",,55765324,57
46634124,2,46630884,2017-10-08T17:42:59.530,-1,,4410829,,2017-10-09T04:50:09.343,2017-10-09T04:50:09.343,0,,"<p>This was asked <a href=""http://forum.arduino.cc/index.php?topic=504473.0"" rel=""nofollow noreferrer"">here on the Arduino forum</a> but I saw it here too. My answer is in Arduino's flavor of C++ since it was posted there...</p>

<p>Of course, performance varies as the set of excluded numbers grows relative to the set of numbers to be used to create your ""new sequence.""</p>

<pre><code>void setup() {
  Serial.begin(115200);
  randomSeed(analogRead(A0));
}
void loop() {
  // create an arbitray sized array to be filled with unique values to exclude from desired array
  const int arraySize = 5;
  int exclusions[arraySize];  
  for (int i = 0; i &lt; arraySize; i++) {
    // fill the array with unique values...
    int val;
    do {
      val = random(100, 200);
    } while([&amp;]() {
      for (auto j : exclusions) {
        if (val == j) {
          return true;
        }
      }
      return false;
    }());
    exclusions[i] = val;
  }
  Serial.print(F(""Exclusion Array: ""));
  for (int i = 0; i &lt; arraySize; i++) {
    Serial.print(exclusions[i]);
    if (i &lt; arraySize - 1)
    Serial.print(F("", ""));
  }
  Serial.println();
  // create a new array of arbitrary length of unique random numbers in &gt;&gt;&gt;the same&lt;&lt;&lt; range as above (but not necessary)
  Serial.print(F(""Starting...\n""));
  uint32_t start = millis();
  const int listSize = 32;
  int list[listSize];
  for (int i = 0; i &lt; listSize; i++) {
    // fill the array with unique values that will exclude exclusions[]
    int val;
    do {
      val = random(100, 200);
    } while([&amp;]() {
      for (auto j : list) {
        if (val == j) {
          return true;
        }
        for (auto k : exclusions) {
          if (val == k) {
            return true;
          }
        }
      }
      return false;
    }());
    list[i] = val;
  }
  uint32_t end = millis();
  Serial.println(end - start);
  // OPTIONAL -&gt; lets sort the final arry to make spotting the duplicates easier:
  for (int i = 0; i &lt; listSize; i++) {
    for (int j = i + 1; j &lt; listSize; j++) {
      if (list[j] &lt; list[i]) {
        int temp = list[i];
        list[i] = list[j];
        list[j] = temp;
      }
    }
  }

  // output the final array
  Serial.print(F(""Final Array: ""));
  for (int i = 0; i &lt; listSize; i++) {
    Serial.print(list[i]);
    if (i &lt; listSize - 1)
    Serial.print(F("", ""));
  }
  Serial.print(F(""\n\n\n""));
  delay(1000);
}
</code></pre>
",,55804381,6127
46633184,2,46631256,2017-10-08T16:07:16.170,1,,7994837,,2017-10-08T16:07:16.170,,1,,"<pre><code>void loop() {
  // put your main code here, to run repeatedly:
  vsstring = Serial.read();
  delay(10);
  Serial.println(vsstring);
}
</code></pre>

<p>In your loop you are reading from serial without first checking to see if there is anything to read (available()).  When you call Serial.read() and there is nothing in the receive buffer it returns -1.  That's where the -1 is coming from.  </p>

<p>As for the 49, you're getting that because you are sending the number as ascii text.  Look up the ascii table and see if the numbers you are getting don't suddenly make a ton of sense.  You are reading from Serial into a String and not a char.  read() returns an int.  String does allow for an int on the RHS of an =.  And when it sees one, it converts the int to ascii.  So you get an ascii representation of the ascii code.  </p>
",,55817008,692
46633243,2,46632608,2017-10-08T16:13:19.710,0,,4013258,,2017-10-08T16:13:19.710,,6,,"<p>Is this in essence what your problem looks like?</p>

<pre><code>int dugme = 1; // one and only definition of this (ODR)

void otoac() {
    long duration, distance;
    while(dugme==1) { 
    }
}

void otokapa() {
    dugme=0;
} 

void loop(){
   if(Serial.available() &gt; 0){ 
    command = Serial.read(); 
    Stop(); 
    switch(command){
     case 'X':  
      otoac();
      break;
    case 'x':  
      otokapa();
      break;
    }
  } 
}
</code></pre>

<p>Possible errors violation of ODR.</p>

<p>if <code>loop</code> and <code>otoac</code> runs in the same thread you will never get to the serial again.</p>
",,55838136,192
46699284,2,46695060,2017-10-11T23:56:23.053,0,,7467472,,2017-10-12T16:54:53.133,2017-10-12T16:54:53.133,0,,"<p>(one) correct code would be</p>

<pre><code>#include &lt;WiFiClient.h&gt;
#include &lt;ESP8266WiFi.h&gt;
#include &lt;Wire.h&gt;
#include &lt;string.h&gt;

#define TCP_RESPONSE_L 1024

struct parsed_query{
  String command;
  String arguments;
};

struct parsed_query parser(void){
  // this function receives and parses a query
  struct parsed_query result;
  result.command=""entered command"";
  result.arguments=""entered arguments""
  return result
}

int str2char(char *as_char, String as_string, int max_length){
  int i_0=0;
  while(as_string[i_0]!='\0'){
    if(i_0&gt;=max_length){as_string=""error: caught an overflow! increase TCP_BUFFER_L"";break;}
    i_0++;
  }
  as_char[i_0]='\0';
  for(int i=0;i&lt;i_0;i++){
    as_char[i]=as_string[i];
  }
  return 1;
}

String executor(String command,String arguments){
  String response;
  if(command==""dim""){
    response=""dimming"";
  }
  else if(command==""on""){
    response=""switching ON"";
  }
  else{
    response=""error: unknown command"";
  }
  return response;
}

void setup(){
// initialize serial interface, wifi &amp; tcp-server
  Serial.begin(115200);
  WiFi.begin(""&lt;SSID&gt;"",""&lt;PASSWORD&gt;"");
  while (WiFi.status() != WL_CONNECTED){delay(500);}
  TCPserver.begin();
  }

void loop() {
  if(!client.connected()){
    client=TCPserver.available();
  }else{
    struct parsed_query query=parser();
    char response[TCP_RESPONSE_L];

    str2char(response,executor(query.command,query.arguments),TCP_RESPONSE_L);

    //prints fine
    Serial.println(str2char(executor(query.command,query.arguments)));

    //correctly sending to client
    client.write(str2char(executor(query.command,query.arguments))));
  }
}
</code></pre>
",,55865432,79
46720245,2,46701115,2017-10-12T23:15:45.973,4,,7994837,,2017-10-12T23:15:45.973,,0,,"<p>You need an if statement to test if the number is less than 10 and if so add your own 0.  </p>

<pre><code>String myMonthString = """";
int mon = now.mon;
if(mon &lt; 10){
   myMonthString += '0';
}
myMonthString += mon;
</code></pre>

<p>A far more elegant solution would be to use sprintf.  This also doesn't use the String class which can do some bad things on little microcontrollers and is generally to be avoided on Arduino. </p>

<pre><code>char fileName[12];
sprintf(fileName, ""%d%02d%02d.csv"", now.year, now.mon, now.dow);
</code></pre>
",,55932766,192
46880723,2,46755747,2017-10-23T01:16:30.533,0,,8816668,,2017-10-24T00:58:31.077,2017-10-24T00:58:31.077,4,,"<p>I didn't get out my Arduino UNO board, but I am pretty sure your main problem is the fact that you are trying to call the default constructor from within another constructor.  Edit: The call to LEDChannel() you did actually constructed a new instance of the class which then never gets used or assigned. The version of the C++ standard being used by default by Arduino doesn't support that feature, see the following <a href=""https://stackoverflow.com/questions/308276/can-i-call-a-constructor-from-another-constructor-do-constructor-chaining-in-c"">answer</a> for more information (It also demonstraits the correct syntax for calling a constructor from another constructor if you are using a version of the standard which supports it).  This means that the CurrentState variable is uninitialized and will be some random value as you are observing.  Uncommenting out the line:</p>

<pre><code>nNbLEDChannel = 1;
</code></pre>

<p>really doesn't have anything to do with the error and just rearranges the memory which apparently happens to put the CurrentState variable to a valid value.</p>

<p>Similar functionality, having common code within a constructor, can be achieved by moving your common initialization code out of the default constructor and into another function like this, which is then called by both constructors (don't forget to initialize all of the member variables of the class in this function to a default value and then do any other ""special"" initialization after it):</p>

<pre><code>LEDChannel::LEDChannel(byte DigitalPIN, AquariumSimulator* pSim)
{
    // Initialize default values
    commonInitFunction();

    //Do other ""special"" initialization
    pAquariumSim = pSim;
    //pinMode(DigitalPIN, OUTPUT);// Configure Digital pin that control LED Channel
}

LEDChannel::LEDChannel()
{
    // Initialize default values
    commonInitFunction();

    //Do other ""special"" initialization
}

void LEDChannel::commonInitFunction()
{
    CurrentState = NoAction;
    //make sure all other member variables have been initialized to something either in here or
    //in your constructors to keep from having unexpected behavior
}
</code></pre>

<p>Although it is a good idea to initialize variables in an initializer list, as stated <a href=""https://stackoverflow.com/questions/926752/why-should-i-prefer-to-use-member-initialization-list"">here</a>, which would then change your constructors to be the following (Note: I just picked some random default values):</p>

<pre><code>LEDChannel::LEDChannel(byte DigitalPIN, AquariumSimulator* pSim):
  MaxBrightness(255),
  lastTick(0),
  CurrentBrightness(0),
  CurrentState(NoAction),
  DigitalPin(DigitalPIN),
  ManualSunsetDuration(60),
  ManualSunriseDuration(60),
  pAquariumSim(pSim)
{
    //pinMode(DigitalPIN, OUTPUT);// Configure Digital pin that control LED Channel
}

LEDChannel::LEDChannel():
  MaxBrightness(255),
  lastTick(0),
  CurrentBrightness(0),
  CurrentState(NoAction),
  DigitalPin(0),
  ManualSunsetDuration(60),
  ManualSunriseDuration(60),
  pAquariumSim(NULL)
{
    CurrentState = NoAction;
}
</code></pre>

<p>This ensures all values are initialized (including in the proper order) for the instantiation of the class.</p>

<p>On a side note, I did notice a few other items in the code you provided which might cause you some unexpected behavior.</p>

<p>Since CurrentBrightness is a byte (i.e. uint8_t), in your void LEDChannel::IncreaseCurrentBrightness(byte value) method, your check to see if the CurrentBrightness + value is &lt;= 255.  This will only ever be false if the sum is equal to 255 because of overflow.  Basically, if the CurrentBrightness is 250 and I add the value of 10 to it then I will get a value of 4 if I am not mistaken.  This is probably not the desired behavior of this check.</p>

<p>The second is that the typedef keyword for your enum is not doing anything since you didn't specify a type.  In C++, you don't need the typedef for an enumeration or struct if you only want to refer to it by the original name you gave it, like you did here.  See some of the answers <a href=""https://stackoverflow.com/questions/385023/why-do-you-use-typedef-when-declaring-an-enum-in-c"">here</a>, even though none of them were accepted the first few are </p>
",,55962132,52
46803691,2,46795446,2017-10-18T05:59:21.163,0,,235698,,2017-10-18T05:59:21.163,,2,,"<p>Untested, but illustrates what you need to do.  I assumed Python 3, but Python 2 is similar.</p>

<pre><code>#!python3
import ctypes

# import the DLL
dll = ctypes.CDLL('RFIDAPI')

# declare the argument and return value types
dll.SAAT_TCPInit.argtypes = ctypes.POINTER(ctypes.c_void_p),ctypes.c_char_p,ctypes.c_int)
dll.SAAT_TCPInit.restype = ctypes.c_bool

# For the output parameter, create an instance to be passed by reference.
hp = ctypes.c_void_p()
if not dll.SAAT_TCPInit(ctypes.byref(hp),b'192.168.0.238',7086):
    print('reader initialization failed!')
</code></pre>

<p>Note the byte string for the IP.  In Python 3 byte strings are the correct input for <code>c_char_p</code>.</p>
",,55974470,285
46892346,2,46867766,2017-10-23T14:51:00.560,1,,506186,,2017-10-23T14:51:00.560,,2,,"<p>OK, it turns out that I had to load the certs/key <em>before</em> creating the SSL session, not <em>after</em>:</p>

<pre><code>ssl_ctx = wolfSSL_CTX_new(method);
result = wolfSSL_CTX_load_verify_locations(ssl_ctx, root_ca_filepath, NULL);
result = wolfSSL_CTX_use_PrivateKey_file(ssl_ctx, dev_prvkey_filepath,
                                         cert_container_format);
result = wolfSSL_CTX_use_certificate_file(ssl_ctx, dev_cert_filepath, cert_container_format);
session = wolfSSL_new(ssl_ctx);
</code></pre>

<p>instead of:</p>

<pre><code>ssl_ctx = wolfSSL_CTX_new(method);
session = wolfSSL_new(ssl_ctx);
result = wolfSSL_CTX_load_verify_locations(ssl_ctx, root_ca_filepath, NULL);
result = wolfSSL_CTX_use_PrivateKey_file(ssl_ctx, dev_prvkey_filepath,
                                         cert_container_format);
result = wolfSSL_CTX_use_certificate_file(ssl_ctx, dev_cert_filepath, cert_container_format);
</code></pre>
",,55976683,2468
46875940,2,46875890,2017-10-22T15:38:24.727,1,,3817790,,2017-10-22T16:16:36.490,2017-10-22T16:16:36.490,4,,"<p>No, it'll not work if you copy files from raspbian. You have to use library which is equivalent for windows. For example, the equivalent of <code>#include &lt;sys/socket.h&gt;</code> in windows it is <code>#include &lt;winsock2.h&gt;</code>. You can use compile time condition code blocks. For example - </p>

<pre><code>#ifdef _WIN32 //true for all windows
#include &lt;winsock2.h&gt;
#else
#include &lt;sys/socket.h&gt;
#endif
</code></pre>

<p>You can also write other codes using this type of condition. First of all you need to find out what are the alternatives of functions and libraries in windows you are using in debian.</p>
",,56026771,115
46896313,2,46895781,2017-10-23T18:40:29.707,5,,1475548,,2017-10-23T21:27:51.097,2017-10-23T21:27:51.097,7,,"<p>Update: This answer has changed slightly from the original</p>

<p>For an Arduino where resources are tight, this code would suffice, no need to link in extra libraries:</p>

<pre><code>int a[8] = { 0,0,0,0,1,1,1,1 };


void setup() {

  randomSeed(analogRead(A0));

  for (int n=7;n&gt;0;n--) {
    int r = random(n+1);
    int t = a[n];
    a[n] = a[r];
    a[r] = t;
  }

}
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/algorithm/shuffle/"" rel=""nofollow noreferrer"">This is exactly how the std::shuffle function is implemented</a>, limited only by the effectiveness of the implementation of the builtin Arduino <code>random()</code> function</p>
",,56027387,1405
46896365,2,46895781,2017-10-23T18:43:59.107,4,,187690,,2017-10-23T21:19:44.323,2017-10-23T21:19:44.323,0,,"<p>If you need to generate <code>m</code> random ones in an array of zeroes, you can simply iterate through the entire array and set the current element to 1 with the following probability <code>P</code></p>

<pre><code>           number of 1's that remains to be set
P = ----------------------------------------------------
    number of array elements that remains to be iterated
</code></pre>

<p>In your case you need to set 4 random 1's in an array of 8 elements</p>

<pre><code>const unsigned N = 8, M = 4;
int array[N];

for (unsigned i = 0, m = M; i &lt; N; ++i)
  if (rand() % (N - i) &lt; m)
  {
    array[i] = 1;
    --m;
  }
  else
    array[i] = 0;
</code></pre>

<p>This generates the random array in one pass - no need to post-shuffle anything.</p>

<p>P.S. In order to make the decision with the above probability <code>P</code> I used the oft-criticized <code>rand() % (N - i) &lt; m</code> method. This is besides the point, of course. You can use any other method of your choice.</p>
",,56042093,139
46908848,2,46908301,2017-10-24T11:02:49.733,1,,878532,,2017-10-24T11:15:52.260,2017-10-24T11:15:52.260,3,,"<p>You simply can use runtime polymorphism for the job.</p>

<p>Example:</p>

<pre><code>class SensorBase
{   
    public:
    virtual void readSensor() = 0;
    virtual void getData(char*) = 0;
};  

class Sensor1: public SensorBase
{   
    void readSensor() { std::cout &lt;&lt; ""read for Sensor1 called"" &lt;&lt; std::endl; }
    void getData(char* ptr) { std::cout &lt;&lt; ""get for Sensor1 called"" &lt;&lt; std::endl; }
};  

class Sensor2: public SensorBase
{   
    void readSensor() { std::cout &lt;&lt; ""read for Sensor2 called"" &lt;&lt; std::endl; }
    void getData(char* ptr) { std::cout &lt;&lt; ""get for Sensor2 called"" &lt;&lt; std::endl; }
};  

// Static allocate objects, new is not a good idea for small embedded devices 
// cause of significant overhead. Global objects are typically a design problem,
// but small embedded systems have different requirements ;)

Sensor1 sensor1;
Sensor2 sensor2;

// lets have array to objects, statically allocated
SensorBase* arr[] = { &amp;sensor1, &amp;sensor2 };


int main()
{   
    char htmlString[256];

    for ( auto ptr: arr )
    {   
        ptr-&gt;readSensor();
        ptr-&gt;getData( htmlString );
    }   
}
</code></pre>

<p>You have to remove the content of the example functions to your needs. std::cout is only used here to let the app run with visible output as an example how the things work.</p>

<p>You use a <code>setup</code> method in your code. That is maybe a good idea on bigger systems, but not on avr! If you use static allocation as in my given example, your code will be smaller and faster. And you can speed up it more, if you give the compiler some hints to store some of your data fields or classes in flash. For that topic please consider <code>#include &lt;avr/pgmspace.h&gt;</code></p>

<p>Maybe you have to write your classes with <code>constexpr</code> constructors to be able to store data in flash. Attention must be payed by using virtual methods: gcc can NOT store them in flash. This is an very old bug/design problem and wastes a lot of ram of your small device. One reason to switch to arm devices! See <a href=""https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43745"" rel=""nofollow noreferrer"">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43745</a>. That makes avr gcc unusable if you need a lot of polymorphic classes in your code. This bug will NOT be fixed!</p>
",,56050370,49
57134295,2,46979992,2019-07-21T14:52:41.650,1,,7255959,,2019-07-21T14:52:41.650,,0,,"<p>You can't reuse models but you can reuse datastructures. This can help you reuse up to 80% of your definitions.
You can design JSON structure as a set of DECLARE_STRUCT like this in separate file:</p>

<pre><code>DECLARE_STRUCT(MyCommon,
   EDM_DATE_TIME_OFFSET, datetime,
   ascii_char_ptr, deviceid, 
   ascii_char_ptr, vin,
   int32_t, message_id, 
   int32_t, request_messageid 
);
</code></pre>

<p>After that you can use #include to reuse DECLARE_STRUCT for different models in С files:</p>

<pre><code>BEGIN_NAMESPACE(cctcp);
 #include ""MyCommon_json.inc""
DECLARE_MODEL(Message,
  WITH_DATA(EDM_GUID, edge_message_id),  
  WITH_DATA(int8_t, message_type),   
   WITH_DATA(MyCommon, tcu_common)
);
</code></pre>
",,56054661,156
47001850,2,47001618,2017-10-29T15:19:02.943,1,,,user6357139,2017-10-29T15:19:02.943,,0,,"<p>It is not necessary to use <code>std::shared_ptr</code> unless you need the resource to have shared ownership and it appears that in your example that's not the case. Most of the time it is only necessary to use <code>std::unique_ptr</code> which will take ownership of a pointer in its constructor then destroy the pointer with <code>delete</code> in its destructor. You say your library is implemented mostly in C so the pointer returned by <code>gpiod_chip_open()</code> is probably allocated with <code>malloc</code> so destroying it with <code>delete</code> which be undefined behavior. To solve this, you can specify a custom deleter functor for <code>std::unique_ptr</code> will call <code>gpiod_chip_close()</code> its destructor rather than <code>delete</code>.</p>

<p>You can do something like this:</p>

<pre><code>#include &lt;memory&gt;

struct gpiod_chip_deleter {
    void operator()(::gpiod_chip* chip) noexcept {
        ::gpiod_chip_close(chip);
    } 
};

using gpiod_chip_ptr = std::unique_ptr&lt;::gpiod_chip, gpiod_chip_deleter&gt;;

// ...

gpiod_chip_ptr chip(::gpiod_chip_open());

// ...
</code></pre>
",,56107735,73
47002070,2,47001618,2017-10-29T15:40:55.553,0,,6923555,,2017-10-29T15:40:55.553,,0,,"<p>I don't know your exact requirements, but is there any problem in making <code>chip</code> non-copyable, just movable?</p>

<pre><code>class chip {
  int* handle;
public:
  chip(const chip&amp;) = delete;
  chip&amp; operator=(const chip&amp;) = delete;

  chip(chip&amp;&amp; c) { operator=(std::move(c)); }
  chip&amp; operator=(chip&amp;&amp; c) {
    handle = c.handle;
    c.handle = nullptr;
    return *this;
  }

  chip() : handle(gpiod_chip_open()) { }

  ~chip() { gpiod_chip_close(handle); }
};
</code></pre>
",,56113435,425
47002628,2,47001618,2017-10-29T16:36:51.607,1,,3313064,,2017-10-29T16:36:51.607,,4,,"<p>You should use <code>std::shared_ptr</code> only if you actually need shared ownership semantics, which tends to be rare.</p>

<blockquote>
  <p>A pointer to an allocated chip object is returned to the user from one
  of the <code>gpiod_chip_open()</code> variants. The user is responsible for
  freeing the allocated resources with <code>gpiod_chip_close()</code></p>
</blockquote>

<p>The C API does not seem to provide shared ownership. There's no need for you to add it, is it?</p>

<p>You should instead use <code>std::unique_ptr</code> with a custom deleter or write your own small wrapper class with move semantics, which has a similar effect but provides a more problem-specific interface. Or you implement such a wrapper class in terms of a private <code>std::unique_ptr</code> with a custom deleter. The key is really to utilise <strong>move semantics</strong>.</p>

<p>Here is an example to understand what that means:</p>

<pre><code>class Chip final
{
public:
    Chip() :
        ptr(gpiod_chip_open())
    {
        // throw if gpiod_chip_open reported an error
    }

    // add other constructors for additional variants of gpiod_chip_open()

    ~Chip()
    {
        gpiod_chip_close(ptr); // add nullptr check if gpiod_chip_close requires one
    }

    Chip(Chip const&amp;) = delete;
    Chip&amp; operator=(Chip const&amp;) = delete;

    Chip(Chip&amp;&amp; other) :
        ptr(other.ptr)
    {
        other.ptr = nullptr;
    }

    gpiod_chip* Get()
    {
        return ptr;
    }

private:
    gpiod_chip* ptr;
};
</code></pre>

<p>That's basically all you need to start. Add other operations (e.g. a move assignment operator) if you need it. You may also want to get rid of the <code>Get</code> member function and completely wrap all other API functions inside of the class; it depends on the level of wrapping you require.</p>

<blockquote>
  <p>The library is explicitly made thread-aware (in that there's no global
  state) but not thread-safe.</p>
</blockquote>

<p>Correct synchronisation is an entirely different problem, which <code>std::shared_ptr</code> could not magically make go away in any case.</p>

<p>All which <code>std::shared_ptr</code> guarantees is that the shared-ownership mechanics themselves will work in a multi-threaded context - i.e. that the reference count is safely incremented and decremented and that no multiple deletions occur if the reference count reaches zero.</p>

<p>It does not guarantee that the managed object itself can safely be used from multiple threads. Whether that's safe or not depends on the managed object. If a <code>gpiod_chip</code> (that is, its operations) cannot safely be used from multiple threads, then neither could a <code>std::shared_ptr&lt;gpiod_chip&gt;</code>.</p>

<p>You would practically have safe access to a <code>gpiod_chip*</code> in both thread A and thread B pointing to the same <code>gpiod_chip</code>, but you'd still need to synchronise operations on that <code>gpiod_chip</code>.</p>
",,56133361,158
47041355,2,47007018,2017-10-31T17:35:01.807,0,,7847202,,2017-10-31T17:35:01.807,,0,,"<p>Problem solved. The issue here was the fact that array <code>song1</code> is declared in <code>main()</code> function. I had to declare array as global data before function definitions:</p>

<pre><code>#include (...)
#define (...)

const int8 song1[] PROGMEM = {
C,4, E1,4, F1,3, E1,3, F1,2,
F1,2, F1, 2, B1,2, A1,2, G1,1, F1,2, G1,5,
G1,4, B1,4, C1,3, F1,3, E1,2,
B1,2, B1,2, G1,2, B1,2,
B1,3, C1,13, 0};

void playNote(int8 wavelength, int16 duration){...}
void playSong( int8 *song, int16 tempo){...}
int main(void){...}
</code></pre>

<p>It was hard to see the problem in my question above, because I wrote code in misleading way (in second quote I wrote array before function definition - but in original code it was in the same place as before). I'm sorry for that.</p>
",,56152672,240
47047311,2,47007151,2017-11-01T02:27:40.373,0,,1762404,,2017-11-01T02:27:40.373,,2,,"<p>The following settings fixed my issue. </p>

<p><strong>Platformio.ini</strong></p>

<pre><code>[env:mightycore324]
platform = atmelavr
board = mightycore324
framework = arduino
upload_protocol = usbtiny
board_f_cpu = 800000L
</code></pre>
",,56166622,1294
47015400,2,47015224,2017-10-30T12:33:14.403,0,,7049845,,2017-10-30T12:33:14.403,,1,,"<p>That is the syntax to typecast a variable
e.g.:</p>

<pre><code>float x = 5.55;
int y = (int)x; // in this case, the casting would have happened implicitly
// or 
printf(""%d"",(int)x);
// this will display 5
</code></pre>

<p>Here by specifying constant/variable will be converted to whatever type you mention inside your first pair of brackets. </p>
",,56196903,205
47021899,2,47021714,2017-10-30T18:24:55.220,1,,969365,,2017-10-30T18:24:55.220,,0,,"<p>There are multiple problems with your code. You are picking 8 random numbers because you want to have all 8 LEDs lit at the end, but what if you get the same number twice? So you have to somehow make sure that you pick a number that corresponds to a LED that is not already lit. Another problem with your code is that you read each LED pin only once, outside the loop. So when you are checking each pin in your large if-statement the values are not up to date.</p>

<p>Here is a quick but bad way of solving both these issues:</p>

<pre><code>int numberOfLEDsLit = 0;
while (numberOfLEDsLit &lt; 8) {
    int index = random(8);
    int ledLit = digitalRead(ledPins[index]);
    if (ledLit == LOW) {
        digitalWrite(ledPinds[index], HIGH);
        numberOfLEDsLit++;
    }
}
</code></pre>

<p>Basically you pick a random led, if it is not lit then light it otherwise do nothing. Continue until all 8 LEDs are lit.</p>
",,56210248,215
47024802,2,47024738,2017-10-30T21:54:52.513,-3,,4459429,,2017-10-30T21:54:52.513,,3,,"<p>It is because of wrong syntax. 
You've used If then again If .It should be : if ..else if ..else</p>

<p>Additionally, ""="" should be replace by ""=="". Sign ""="" assigns a varibale value, bu ""=="" test if it is equal
Change :</p>

<pre><code> if (relayValue = 0)
</code></pre>

<p>To: </p>

<pre><code>else if (relayValue = 0)
</code></pre>

<p>Syntax(<a href=""https://www.tutorialspoint.com/cplusplus/cpp_if_else_statement.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/cplusplus/cpp_if_else_statement.htm</a>)
The syntax of an if...else if...else statement in C++ is −</p>

<pre><code>if(boolean_expression 1) {
   // Executes when the boolean expression 1 is true
} else if( boolean_expression 2) {
   // Executes when the boolean expression 2 is true
} else if( boolean_expression 3) {
   // Executes when the boolean expression 3 is true
} else {
   // executes when the none of the above condition is true.
}
</code></pre>
",,56210292,30
47058948,2,47057966,2017-11-01T16:01:28.283,1,,3336541,,2017-11-01T16:01:28.283,,0,,"<p>You need to open file ""/sys/class/gpio/gpio971/direction"" and not ""/sys/class/gpio971/direction""</p>

<pre><code>   directionfd = open(""/sys/class/gpio/gpio971/direction"", O_RDWR);

    if(directionfd &lt; 0)
    {
        printf(""Cannot open GPIO direction it\n"");
        exit(1);
    }
</code></pre>

<p>You can refer [1], and get the code to export/unexport/set direction/read/write gpio pin.</p>

<p>[1] <a href=""https://elinux.org/RPi_GPIO_Code_Samples#sysfs"" rel=""nofollow noreferrer"">https://elinux.org/RPi_GPIO_Code_Samples#sysfs</a></p>
",,56244100,105
47096906,2,47095300,2017-11-03T13:27:30.013,0,,3368201,,2017-11-03T13:27:30.013,,2,,"<p>This code is not doing what you think it is. Particularly, the loop code you wrote means:</p>

<ol>
<li>if there is something in the serial buffer, then if Go is 1 blink</li>
<li>otherwise turn off the led.</li>
</ol>

<p>In the setup, you clear the buffer. Consequently you will need another char in the queue to trigger the action.</p>

<p>From what you wrote, I think what you wanted to do is</p>

<ol>
<li>if I wrote a 1 then blink</li>
<li>if I wrote a 0, then stop</li>
<li>if I wrote something else ... you did not specify, but I'll ignore this command</li>
</ol>

<p>In order to do this, you'd want something like this:</p>

<pre><code>#define LEDPIN 2
// #include &lt;SPI.h&gt; Not needed here

byte Go = 0; // Please, use the correct size for variables

void setup() {
    Serial.begin(9600);
    pinMode(LEDPIN, OUTPUT);
    digitalWrite(LEDPIN, LOW);
    delay(1000);
    digitalWrite(LEDPIN, HIGH);
    delay(1000);
    digitalWrite(LEDPIN, LOW);

    Go = 0;
}

void loop() {
    if (Serial.available() &gt; 0){
        // Something was received, so let's check it out
        byte tempGo = Serial.read();
        Serial.println(Go);         //a 1 will print 49, a 0 should print 48

        // this way if you did not receive any valid char nothing will change
        if (tempGo == '0')
            Go = 0;
        else if (tempGo == '1')
            Go = 1;

        Serial.println(Go);
    }

    if (Go){
        delay(1000);
        digitalWrite(LEDPIN, HIGH);
        delay(1000);
        digitalWrite(LEDPIN, LOW); 
    }else{
        digitalWrite(LEDPIN, LOW);
    }
}
</code></pre>

<p>Moreover the delays are a really bad habit; you don't want to wait for two seconds before seeing the correct output. In order to get rid of the delays, you can follow the example from the BlinkWithoutDelay example:</p>

<pre><code>#define LEDPIN 2
// #include &lt;SPI.h&gt; Not needed here

byte Go = 0; // Please, use the correct size for variables
unsigned long prevMillis;

void setup() {
    Serial.begin(9600);
    pinMode(LEDPIN, OUTPUT);
    digitalWrite(LEDPIN, LOW);
    delay(1000);
    digitalWrite(LEDPIN, HIGH);
    delay(1000);
    digitalWrite(LEDPIN, LOW);

    Go = 0;
}

void loop() {
    if (Serial.available() &gt; 0){
        // Something was received, so let's check it out
        byte tempGo = Serial.read();
        Serial.println(Go);         //a 1 will print 49, a 0 should print 48

        // this way if you did not receive any valid char nothing will change
        if (tempGo == '0')
            Go = 0;
        else if (tempGo == '1') {
            if (!Go) prevMillis = millis() - 1000; // This is in order to flash immediately
            Go = 1;
        }

        Serial.println(Go);
    }

    if (Go){
        while ((millis() - prevMillis) &gt;= 1000){
            prevMillis += 1000;
            digitalWrite(LEDPIN, !digitalRead(LEDPIN));
        }
    }else{
        digitalWrite(LEDPIN, LOW);
    }
}
</code></pre>

<p>DISCLAIMER: this code is not tested; there may be some bugs inside</p>
",,56293608,142
47096619,2,47095769,2017-11-03T13:13:46.970,0,,3368201,,2017-11-03T13:13:46.970,,5,,"<p>If I understood the problem, here you have two issues (one is blocking, the other not).</p>

<p>As for the simplest problem, <code>Sensor_2 sensorHall = new Sensor_2;</code> is not valid, since the <code>new</code> keyword generates a pointer to the object. You have two ways to generate an object and to pass it to the sensor manager (I assume the sensor manager accepts pointer to sensors):</p>

<pre><code>// Solution 1
Sensor_2 *sensorHall = new Sensor_2;
sensorManager-&gt;addSensor(sensorHall);

// Solution 2
Sensor_2 sensorHall;
sensorManager-&gt;addSensor(&amp;sensorHall);
</code></pre>

<p>Please note, however, that if you use solution 2 you must put the sensor definition outside the function. If, for instance, you write</p>

<pre><code>void setup() {
  Sensor_2 sensorHall;
  sensorManager-&gt;addSensor(&amp;sensorHall);
}
</code></pre>

<p>then the sensor object will be destroyed after you exit the <code>setup</code>. In order to avoid this, write</p>

<pre><code>Sensor_2 sensorHall;
void setup() {
  sensorManager-&gt;addSensor(&amp;sensorHall);
}
</code></pre>

<p>As for the main problem, I think that arduino does not compile source files outside the main sketch folder (and it does not recursively, so subfolders are not scanned).</p>

<p>However, what you are trying to do is usually done by implementing libraries. You can find different libraries and resources to understand how a library work (for instance, there is a <a href=""https://www.arduino.cc/en/Hacking/LibraryTutorial"" rel=""nofollow noreferrer"">library tutorial</a> on the arduino website). You will have to create a folder inside the library folder, then put inside the source files (in this case you can use subfolders); the compilation will be successful. This way you won't need to copy these files in future projects: they will already be there.</p>

<p>If you don't want to make them shared, and still want to put them in a separate folder, IIRC you can make a special folder called src and put the source files there (again, not in subfolders). The src folder gets merged with the sketch folder when compiling.</p>

<p>My suggestion: make it a library. Fully reusable, easy to maintain, even a bit of highlighting...</p>
",,56314418,250
47104802,2,47095927,2017-11-03T21:42:56.860,3,,4694206,,2017-11-03T21:42:56.860,,0,,"<p>I had to parse the request body using a json parser.</p>

<pre><code>server.on(""/connect"", HTTP_POST, [](AsyncWebServerRequest *request){
    request-&gt;send(200, ""text/plain"", ""SUCCESS"");
}, NULL, onConnectBody);

void onConnectBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total)
{
StaticJsonBuffer&lt;200&gt; jsonBuffer;
JsonObject&amp; root = jsonBuffer.parseObject(data);

if (!root.success())
{
  Serial.println(""parseObject() failed"");
  return;
}

String ssid = root[""ssid""];
String password = root[""password""];
bool secure = root[""secure""];

Serial.print(""ssid: "");
Serial.println(ssid);
Serial.print(""password: "");
Serial.println(password);
Serial.println(secure);
setNetworkCredentials(ssid, password, secure);
}
</code></pre>
",,56347508,454
48358895,2,47147491,2018-01-20T17:11:29.000,1,,9242287,,2018-01-20T17:11:29.000,,2,,"<p><strong>Short supposition:</strong> your Makefile doesn't name properly user1.bin and user2.bin OR the output of gen_appbin.py isn't handled properly.</p>

<hr>

<p>I had exactly the same problem. It happened that I mistakenly load the same userN.bin file as the current running version (e.g. the current running firmware is user1.bin and the updater tried to download the same user1.bin and to flash it).</p>

<p>Here is the <strong>output of the broken updater</strong>:</p>

<pre><code>connected with WIFINETWORK, channel 3
dhcp client start...
event 0
ip:192.168.0.103,mask:255.255.255.0,gw:192.168.0.1
event 3
we have IP!
handleUpgrade()
current fw is user1.bin
[OTA]Upgrade available version: 2
[OTA]Server 8.8.8.8:80. Path: /user1.bin
[OTA][URL] GET /user1.bin HTTP/1.1
Host: your.site.com:80
Connection: keep-alive
Cache-Control: no-cache
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko)                                                                                                              Chrome/30.0.1599.101 Safari/537.36
Accept: */*
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8
/**/
system_upgrade_start
upgrade_connect 40840
[OTA]Upgrading...
upgrade_connect_cb
pusrdata = HTTP/1.1 200 OK
Server: nginx/1.10.3 (Ubuntu)
Date: Fri, 19 Jan 2018 18:22:59 GMT
Content-Type: application/octet-stream
Content-Length: 327252
Last-Modified: Fri, 19 Jan 2018 18:22:04 GMT
Connection: close
ETag: ""5a62374c-4fe54""
Accept-Ranges: bytes


sumlength = 327252
sec_block 80
................................................................................                                                                                                             upgrade_get_sum_disconcb 38568
erase sector=257 ok
...
erase sector=336 ok

ALL=80 sectors erase ok!
upgrade_connect_cb
sumlength = 327252
upgrade file download start.
please check the bin file
totallen = 2653
totallen = 4113
upgrade_check
[OTA]failed!
pm open,type:2 0
</code></pre>

<p>After I changed the code so as to use the correct bin file, the updater succeeded in flashing the firmware over the air.</p>

<p>Here is the output of the working updater:</p>

<pre><code>connected with WIFINETWORK, channel 3
dhcp client start...
event 0
ip:192.168.0.103,mask:255.255.255.0,gw:192.168.0.1
event 3
we have IP!
handleUpgrade()
current fw is user1.bin
[OTA]Upgrade available version: 2
[OTA]Server 8.8.8.8:80. Path: /user2.bin
[OTA][URL] GET /user2.bin HTTP/1.1
Host: your.site.com:80
Connection: keep-alive
Cache-Control: no-cache
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36
Accept: */*
Accept-Encoding: gzip,deflate
Accept-Language: en-US,en;q=0.8
/**/
system_upgrade_start
upgrade_connect 40872
[OTA]Upgrading...
upgrade_connect_cb
pusrdata = HTTP/1.1 200 OK
Server: nginx/1.10.3 (Ubuntu)
Date: Sat, 20 Jan 2018 08:28:42 GMT
Content-Type: application/octet-stream
Content-Length: 327188
Last-Modified: Sat, 20 Jan 2018 08:27:57 GMT
Connection: close
ETag: ""5a62fd8d-4fe14""
Accept-Ranges: bytes


sumlength = 327188
sec_block 80
................................................................................upgrade_get_sum_disconcb 38736
erase sector=257 ok
...
erase sector=336 ok

ALL=80 sectors erase ok!
upgrade_connect_cb
sumlength = 327188
upgrade file download start.
totallen = 2653
totallen = 4113
totallen = 5573
...
totallen = 325313
totallen = 326773
totallen = 327188
upgrade file download finished.
flash_crc = 1177058584
img_crc = 1177058584
upgrade_check
[OTA]success; rebooting!
reboot to use2
state: 5 -&gt; 0 (0)
rm 0
del if0
usl
event 1

 ets Jan  8 2013,rst cause:2, boot mode:(3,6)

load 0x40100000, len 2408, room 16
tail 8
chksum 0xe5
load 0x3ffe8000, len 776, room 0
tail 8
chksum 0x84
load 0x3ffe8310, len 632, room 0
tail 8
chksum 0xd8
csum 0xd8

2nd boot version : 1.6
  SPI Speed      : 40MHz
  SPI Mode       : QIO
  SPI Flash Size &amp; Map: 32Mbit(1024KB+1024KB)
jump to run user2 @ 101000
</code></pre>

<p>Here is my code:</p>

<pre><code>// credits to Martin Harizanov, IoT_Demo
#include ""fota.h""
#include ""ets_sys.h""
#include ""upgrade.h"" //for struct update
#include ""ip_addr.h"" //for ip_addr_t and etc.
#include ""espconn.h"" //for struct espconn
#include ""mem.h"" //os_free()
#include ""osapi.h"" //os_memcpy

#define pheadbuffer ""Connection: keep-alive\r\n\
Cache-Control: no-cache\r\n\
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36 \r\n\
Accept: */*\r\n\
Accept-Encoding: gzip,deflate\r\n\
Accept-Language: en-US,en;q=0.8\r\n\r\n""
/* dummy comment to debug npp code highlighting */

static void ICACHE_FLASH_ATTR ota_finished_callback(void *arg) {
    struct upgrade_server_info *update = arg;
    if (update-&gt;upgrade_flag == true) {
        os_printf(""[OTA]success; rebooting!\n"");
        system_upgrade_reboot();
    }
    else { os_printf(""[OTA]failed!\n""); }

    os_free(update-&gt;pespconn);
    os_free(update-&gt;url);
    os_free(update);
}

static void ICACHE_FLASH_ATTR handleUpgrade(uint8_t serverVersion, const char *server_ip, uint16_t port, const char *path) {
    const char* file;
    os_printf(""handleUpgrade()\r\n"");
    uint8_t userBin = system_upgrade_userbin_check();
    switch( userBin ) {
        case UPGRADE_FW_BIN1: file = ""user2.bin""; break;
        case UPGRADE_FW_BIN2: file = ""user1.bin""; break;
        default: os_printf(""[OTA]Invalid userbin number!\n""); return;
    }
    os_printf( ""[OTA]current fw is %s\r\n"" , file );

    uint16_t version=1;
    if (serverVersion &lt;= version) {
        os_printf(""[OTA]No update. Server version:%d, local version %d\n"", serverVersion, version);
        return;
    }

    os_printf(""[OTA]Upgrade available version: %d\n"", serverVersion);

    struct upgrade_server_info* update = (struct upgrade_server_info *)os_zalloc(sizeof(struct upgrade_server_info));
    update-&gt;pespconn = (struct espconn *)os_zalloc(sizeof(struct espconn));

    os_memcpy(update-&gt;ip, server_ip, 4);
    update-&gt;port = port;

    os_printf(""[OTA]Server ""IPSTR"":%d. Path: %s%s\n"", IP2STR(update-&gt;ip), update-&gt;port, path, file);

    update-&gt;check_cb = ota_finished_callback;
    update-&gt;check_times = 120000;
    update-&gt;url = (uint8 *)os_zalloc(512);

    os_sprintf( update-&gt;url , ""GET /%s HTTP/1.1\r\nHost: 

your.site.com:80\r\n""pheadbuffer, file );
    os_printf( ""[OTA][URL] %s"" , update-&gt;url );
    if (system_upgrade_start(update) == false) {
        os_printf(""[OTA]Could not start upgrade\n"");

        os_free(update-&gt;pespconn);
        os_free(update-&gt;url);
        os_free(update);
    }
    else { os_printf(""[OTA]Upgrading...\n""); }
}

void ICACHE_FLASH_ATTR doFotaUpdate() {
    const char remote_ip[4] = {8, 8, 8, 8};
    handleUpgrade( 2, remote_ip , 80 , ""/"" );
    return;
}
</code></pre>
",,56351072,469
47190696,2,47189881,2017-11-08T22:20:33.543,3,,2630032,,2017-11-08T22:20:33.543,,1,,"<p>You can detect ""local maxima"" or peaks in a single loop without the need of  copying something into another array. You just have to ignore repeating values, and you just have to keep track if the values considered are currently increasing or decreasing. Each value after which this status switches from increasing to decreasing is then a peak:</p>

<pre><code>int main() {

    int Array1[] = {1,2,3,4,4,4,3,2,7,8,9,10};

    int prevVal = INT_MIN;
    enum {
        Ascending,
        Descending
    } direction = Ascending;

    for (int i=0; i&lt;sizeof(Array1)/sizeof(*Array1); i++) {
        int curVal = Array1[i];
        if (prevVal &lt; curVal) {  // (still) ascending?
            direction = Ascending;
        }
        else if (prevVal &gt; curVal) { // (still) descending?
            if (direction != Descending) { // starts descending?
                cout &lt;&lt; ""peak at index "" &lt;&lt; i-1 &lt;&lt; "": "" &lt;&lt; prevVal &lt;&lt; endl;
                direction = Descending;
            }
        }
        // prevVal == curVal is simply ignored...

        prevVal = curVal;
    }
}
</code></pre>
",,56378428,902
47245400,2,47244709,2017-11-12T04:21:32.010,2,,939557,,2017-11-12T22:05:08.613,2017-11-12T22:05:08.613,12,,"<p>That message means make can't figure out how to build that target (<code>RumPi.o</code>).  Do you have a <code>Components/Implementations/RumPi.cpp</code> file?  Do all the header files you've listed in the <code>$(HEADERS)</code> variable actually exist?  If either of those is not true, then your pattern rule will not match.  If your pattern rule doesn't match (and the default rule doesn't match) then make can't figure out how to build the object file.</p>

<p>If you want full details you can run <code>make -d</code> and examine the debug output.  You might want to redirect it to a file so you can look at it with <code>less</code> or a text editor since there's a lot of output.</p>

<p>By the way, you should not add the <code>-lwiringPi</code> option to your compile line.  Libraries are only used at link time, not compile time.</p>

<p><em>ETA</em></p>

<p>Something else you should consider is rewriting your pattern rule so that only the source file is listed as a prerequisite and moving the headers to a separate line:</p>

<pre><code>%.o: Components/Implementations/%.cpp
        gcc -c $&lt; -o $@ -lwiringPi

$(OBJECTS): $(HEADERS)
</code></pre>

<p>The advantage to this is you'll get a clearer error message if one of the headers is not found.  When you use a pattern rule, make will try to match <em>all</em> the patterns it can and if none match it tells you it doesn't know how to build the target.  Since there are usually many different ways to build a target, make doesn't show an error for every one that doesn't match.</p>

<p>But if you declare a direct <em>explicit</em> prerequisite relationship between two files, rather than using a pattern that may or may not match, then if there is a missing file make will tell you directly.</p>

<p><em>ETA2</em></p>

<p>In your original makefile you had a rule like this:</p>

<pre><code>RumPi: $(OBJECTS)
        gcc $(OBJECTS) -o $@ -lwiringPi
</code></pre>

<p>but then later you removed it.  Why did you take this out?  You need this rule to tell make how to link your executable file <code>RumPi</code>.</p>

<p>Also, you shouldn't be using <code>gcc</code> as the compiler/linker for C++ code; <code>gcc</code> is for C, not C++.  You should use <code>g++</code> for C++ code.  And it's best to contain this information in variables so it's easy to find and modify (even from the command line if you like).  The standard variable names for the C++ compiler is <code>CXX</code> etc.</p>

<p>Your makefile should look something like this:</p>

<pre><code>CXX = g++
CXXFLAGS = -std=c++11
LDLIBS = -lwiringPi

HEADERS = Components/Headers/RumPi.h ./Common.h Components/Headers/Component.h \
    Components/Headers/Vehicle.h Components/Headers/Motor.h Components/Headers/Receiver.h \
    Components/Headers/DualLED.h Components/Headers/LED.h Components/Headers/RGBLED.h \
    Components/Headers/Relay.h 
OBJECTS = RumPi.o Vehicle.o Motor.o Receiver.o DualLED.o LED.o RGBLED.o Relay.o

default: RumPi

RumPi: $(OBJECTS)
        $(CXX) $(CXXFLAGS) $^ $(LDLIBS) -o $@

%.o: Components/Implementations/%.cpp
        $(CXX) $(CXXFLAGS) -c -o $@ $&lt;

$(OBJECTS): $(HEADERS)

clean:
        -rm -f $(OBJECTS)
        -rm -f RumPi
</code></pre>
",,56387774,1148
47358047,2,47357656,2017-11-17T19:34:53.393,0,,794749,,2017-11-17T19:59:02.660,2017-11-17T19:59:02.660,0,,"<p>The constructor gets called before the serial interface is initialized.</p>

<p>You need to have a <code>begin</code> method that is then called inside <code>setup()</code>.</p>

<p>Client.h</p>

<pre><code>#include &lt;HardwareSerial.h&gt;

class Client {
  private:
    HardwareSerial * serial;

  public:
    Client(HardwareSerial * serial);
    void begin();
};
</code></pre>

<p>Client.cpp</p>

<pre><code>#include ""Client.h""

Client::Client(HardwareSerial * serial) {
  this-&gt;serial = serial;
}

void Client::begin() {
  this-&gt;serial-&gt;begin(115200);
}
</code></pre>

<p>Your program:</p>

<pre><code>#include ""Client.h""

Client * client = new Client(&amp;Serial2);

void setup() {
  client-&gt;begin();
}
</code></pre>
",,56413144,100
47392485,2,47392427,2017-11-20T12:50:44.950,2,,440558,,2017-11-20T13:17:45.460,2017-11-20T13:17:45.460,0,,"<p>The preporocessor and the <code>#include</code> directive is kind of misguided. It will quite literally paste the code from the included file into the file doing the <code>#include</code>.</p>

<p>After preprocessing, your code will look something like</p>

<pre><code>mul64x64asm:
      MOVW R0,0x12f4
      MOVT R0,0x5678

int main(void) {
    extern  void mul64x64asm();
    mul64x64asm();
    return 1;

}
</code></pre>

<p>That is certainly not valid C code.</p>

<p>If you want to do inline-assembly you have to do it in a way that the compiler understands. <a href=""http://gcc.gnu.org/onlinedocs/"" rel=""nofollow noreferrer"">Find the documentation for your version of GCC</a>, and read more about it.</p>

<p>Another and possibly better choice is to build the <code>asm.S</code> source file into an object file with an assembler. Then link your main program with this object file to create the executable program.</p>
",,56424722,79
47392916,2,47392427,2017-11-20T13:13:52.887,5,,417501,,2017-11-21T22:15:19.550,2017-11-21T22:15:19.550,0,,"<p>You're almost there.  To add a function written in assembly to your program, place it in a separate file as you already did.</p>

<p>Make sure to mark all symbols you want to use elsewhere in your program as global so the linker considers them while linking:</p>

<pre><code>    .globl mul64x64asm
    .type mul64x64asm,%function
mul64x64asm:
    MOVW R0,0x12f4
    MOVT R0,0x5678
    bx lr                        @ don't forget to return instead of fallthrough
    .size mul64x64asm,.-mul64x64asm
</code></pre>

<p>The <code>.globl</code> directive adjusts the symbol visibility to <em>global.</em> The <code>.type</code> directive marks the symbol type as <em>function,</em> this is important when you use dynamic linking.  The <code>.size</code> directive sets the symbol size of <code>mul64x64asm</code> to the difference between here (<code>.</code>) and the beginning of the function.  This is useful for debugging but can be omitted if you are too lazy.</p>

<p>On non-ARM, <code>.type mul64x64asm,@function</code> would be used, but <code>@</code> is the comment character on ARM so gas uses <code>%</code> instead.</p>

<p>Now assemble this and link it into your program like any other object file.</p>
",,56426827,592
47401076,2,47400913,2017-11-20T21:08:03.047,0,,4896472,,2017-11-20T21:08:03.047,,0,,"<p>You cannot change any varables outside the setup or run methods unless you are defining them at yhe same time. This is the arduino way of doing things which is only a problem because the background code is all hidden, otherwise, you could do the equivalent. I suggest either :</p>

<pre><code>int var1 = 1, var2 = 2;
</code></pre>

<p>Or put it in setup:</p>

<pre><code>int var1, var2;

void setup() {
    var1 = 1;
    var2 = 2;
}
</code></pre>

<p>Hope it helps!</p>
",,56439555,631
47410370,2,47410236,2017-11-21T10:09:14.060,1,,5470596,,2017-11-21T10:32:16.697,2017-11-21T10:32:16.697,0,,"<p>First, your comparison is undefined behaviour. The right way to go is with a <a href=""http://en.cppreference.com/w/cpp/string/byte/memcmp"" rel=""nofollow noreferrer""><code>std::memcmp</code></a>. You also need to take care of endianness.</p>

<p>In order to attach properties (like color) to your tags, simply define a struct:</p>

<pre><code>struct rfid_tag
{
    uint8_t value[4];
    enum { ... } color;
};
</code></pre>

<p>Once you got a struct, you can enrich it with <code>operator==</code> so you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow noreferrer""><code>std::find()</code></a> to lookup the appropriate tag in one line:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

struct rfid_tag
{
    enum color_type { red = 10, blue = 11 };

    std::array&lt;uint8_t, 4&gt; value;
    color_type             color;
};

bool operator==(std::array&lt;uint8_t, 4&gt; const&amp; tagvalue, rfid_tag const&amp; rhs)
{
    return std::memcmp(tagvalue.data(), rhs.value.data(), rhs.value.size()) == 0;
}

bool operator==(rfid_tag const&amp; lhs, std::array&lt;uint8_t, 4&gt; const&amp; tagvalue)
{
    return tagvalue == lhs;
}


static const std::array&lt;rfid_tag, 3&gt; known_tags = {
    rfid_tag{ { 0x00, 0x01, 0x02, 0x03 }, rfid_tag::red },
    rfid_tag{ { 0x10, 0x11, 0x12, 0x13 }, rfid_tag::blue },
    rfid_tag{ { 0x20, 0x21, 0x22, 0x23 }, rfid_tag::red }
};

int main()
{
    const std::array&lt;uint8_t, 4&gt; tag_to_find{ 0x10, 0x11, 0x12, 0x13 };
    std::cout &lt;&lt; std::find(begin(known_tags), end(known_tags), tag_to_find)-&gt;color &lt;&lt; ""\n""; // outputs ""11"" as expected
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/fc070dbb0be3d7ba"" rel=""nofollow noreferrer"">demo</a></p>
",,56460727,586
47410450,2,47410236,2017-11-21T10:12:57.673,1,,2805305,,2017-11-21T10:12:57.673,,1,,"<p>You can create a structure with id and a color enum:</p>

<pre><code>enum class Color { red, green };

struct Tag
{
    uint8_t id[4];
    Color color;
};

Tag RED1 = { { 0x73, 0xD5, 0xB7, 0xAC }, Color::red } ;
Tag RED2 = { { 0x7E, 0x27, 0x49, 0x4E }, Color::red } ;
Tag RED3 = { { 0x02, 0xFD, 0x06, 0x40 }, Color::red } ;
Tag GREEN1 = { { 0xAB, 0xEC, 0x68, 0x80 }, Color::green } ;
Tag GREEN2 = { { 0xEE, 0x20, 0x50, 0x4E }, Color::green } ;
Tag GREEN3 = { { 0x27, 0x06, 0x40, 0x73 }, Color::green } ;

void test(Tag tag)
{
    if (tag.color == Color::red)
    {
        //
    }
    else if (tag.color == Color::green)
    {

    }
}
</code></pre>
",,56471826,118
47410575,2,47410236,2017-11-21T10:19:08.427,0,,8874817,,2017-11-21T10:33:54.697,2017-11-21T10:33:54.697,0,,"<p>There are multiple ways.</p>

<p>You could write a struct which contains your tag along with your color, like this:</p>

<pre><code>struct ColoredTag
{
    uint8_t[4] value;
    std::string color;

} typename ColoredTag_t;

ColoredTag_t RED1 = {{ 0x73, 0xD5, 0xB7, 0xAC }, ""Red""};
ColoredTag_t RED2 = {{ 0x7E, 0x27, 0x49, 0x4E }, ""Red""};
ColoredTag_t RED3 = {{ 0x02, 0xFD, 0x06, 0x40  }, ""Red""};
ColoredTag_t GREEN1 = {{ 0xAB, 0xEC, 0x68, 0x80 }, ""Green""};
ColoredTag_t GREEN2 = {{ 0xEE, 0x20, 0x50, 0x4E }, ""Green""};
ColoredTag_t GREEN3 = {{ 0x27, 0x06, 0x40, 0x73 }, ""Green""};
</code></pre>

<p>Or, you can use a <a href=""http://www.cplusplus.com/reference/map/map/"" rel=""nofollow noreferrer""><code>std::map</code></a> to assign a color to a tag, like this</p>

<pre><code>std map&lt;uint8_t[4], std::string&gt; tags;

public void fillTags()
{
    tags[RED1] = ""Red"";
    tags[RED2] = ""Red"";
    //...

}

std::string getColor(uint8_t tag)
{
    return tags[tag];

}
</code></pre>

<p>There might be some more solutions for this issue, but these are the ones that came to my mind first.</p>
",,56498186,1167
47420286,2,47420121,2017-11-21T18:34:14.697,1,,1754322,,2017-11-22T10:47:56.813,2017-11-22T10:47:56.813,4,,"<p>I believe you can do it like this.</p>

<pre><code>String arr[3];
arr[0] = ""one"";
arr[1] = ""two"";
arr[2] = ""three"";
</code></pre>

<p>If the array needs to grow in number of elements use std::vector.</p>

<pre><code>#include &lt;vector&gt;  // include this header
// ...

std::vector&lt;String&gt; arr;  // declare the array
arr.push_back(""one"");  // add as many elements as you want
arr.push_back(""two"");
arr.push_back(""three"");
arr[0];  // you can access the elements just like if it was a regular array
</code></pre>

<p>EDIT:</p>

<p>Since there are no vectors available.
I believe the best option is to allocate a large enough array of pointers to <code>String</code>s. Then keep an index to the next String to allocate.</p>

<pre><code>const unsigned MAX_PHONES = 1024;
String* arr = new String*[MAX_PHONES];
unsinged arrSize = 0;

// ...

// add new string
if(arrSize &lt; MAX_PHONES)
    arr[arrSize++] = new String;
else
    assert(false &amp;&amp; ""MAX_PHONES exceeded"");


// releasing memory
for(int i=0; i&lt;arrSize; i++) delete arr[i];
delete[] arr;
</code></pre>
",,56511761,158
47432251,2,47423859,2017-11-22T10:26:18.700,0,,5341319,,2017-11-24T08:42:54.300,2017-11-24T08:42:54.300,0,,"<p>After days of banging my heading head to get it work I've decided to make the array a private static member.  This solves the initialization issue I was having and I don't have to specify the number of elements in the array.    </p>

<pre><code>#ifndef MENU_H
#define MENU_H

#if defined(ARDUINO) &amp;&amp; ARDUINO &gt;= 100
    #include ""Arduino.h""
#else
    #include ""WProgram.h""
#endif

struct menuItem_t {
    char heading[16];
    char item[16];
    configItem_t* configItem;
};

class menu_t {
    public:
        menu_t();
        void test();
    private:
        static menuItem_t _items[];
};

#endif
</code></pre>

<p>Here is the .cpp</p>

<pre><code>#include ""Menu.h""

menu_t::menu_t(){

}

void menu_t::test(){
    Serial.println(""test:"");
    Serial.println((sizeof(_items)/sizeof(_items[0])));
    Serial.println(""first heading:"");
    Serial.println(_items[0].heading);
}

menuItem_t menu_t::_items[] = { 
    {""TIME"", """", NULL},
    {""H"", ""Hour"", NULL},
    {""M"", ""Minute"", NULL},
};
</code></pre>
",,56511826,65
47438684,2,47423859,2017-11-22T15:42:14.587,0,,10077,,2017-11-22T15:42:14.587,,1,,"<p>You have two problems. First, you're not giving a dimension to your array. This is a zero-length array, which is not permitted in standard C++ but allowed as an extension by many compilers. This allocates no space for the array, but assumes you will use the class or struct as an overlay to interpret properly allocated memory of sufficient size. You are doing no such allocation.</p>

<p>Second, your attempted initialization is not initializing your member variable at all, but creating a separate array.</p>

<p>To correct your code, you must provide a dimension to the array and use a member initializer in the constructor. Here's an example, but using standard C++ since I don't have Arduino C++. I can't guarantee that it will work for Arduino, but it should at least get you closer:</p>

<pre><code>#include &lt;iostream&gt;

struct configItem_t;

struct menuItem_t {
    char heading[16];
    char item[16];
    configItem_t* configItem;
};

class menu_t {
    public:
        menu_t();
        void test();
        menuItem_t _items[3];
    private:

};

menu_t::menu_t() :
        _items{
          { ""TIME"", """", NULL },
          { ""H"", ""Hour"", NULL },
          { ""M"", ""Minute"", NULL }
        }
{
    // Empty implementation
}

void menu_t::test(){
//    Serial.println(""test:"");
//    Serial.println((sizeof(_items)/sizeof(_items[0])));
//    Serial.println(""first heading:"");
//    Serial.println(_items[0].heading);
    std::cout &lt;&lt; ""test:\n"";
    std::cout &lt;&lt; (sizeof(_items)/sizeof(_items[0])) &lt;&lt; '\n';
    std::cout &lt;&lt; ""first heading:\n"";
    std::cout &lt;&lt; _items[0].heading &lt;&lt; '\n';
}

//menuItem_t _items[] = {
//    {""TIME"", """", NULL},
//    {""H"", ""Hour"", NULL},
//    {""M"", ""Minute"", NULL},
//};

int main()
{
    menu_t m;
    m.test();
}
</code></pre>

<p>Output:</p>

<pre><code>test:
3
first heading:
TIME
</code></pre>

<p>If you really don't know the size array you need until run time, you will have to use dynamic allocation with <code>new</code> or <code>malloc</code> (my Googling suggests that <code>new</code> is indeed available with Arduino C++, but dynamic allocation is not generally recommended).</p>
",,56599335,232
47474855,2,47473644,2017-11-24T13:59:34.790,2,,6700019,,2017-11-24T13:59:34.790,,4,,"<p>Finally I found a solution according to paddy's <a href=""https://stackoverflow.com/questions/20227472/declare-class-object-globally-but-without-parameters"">answer</a> I had to use a pointer from my static instance. Here is the modified <code>AM_2301.cpp</code>:</p>

<pre><code>#include ""Arduino.h""
#include ""AM_2301.h""
#include ""DHT.h""

static DHT *dht = NULL;  //define the pointer


AM_2301::AM_2301(int pin)
{
    pinMode(pin, OUTPUT);
    Serial.print(""_pin: "");
    Serial.println(_pin);
    _pin = pin;
    dht = new DHT(_pin, DHT21);  //pass the initialization
}


void AM_2301::begin(){
    dht-&gt;begin();
}

struct Two_float AM_2301::read()
{
    struct Two_float output;
    float h = dht-&gt;readHumidity();
    float t = dht-&gt;readTemperature();
    // check if returns are valid, if they are NaN (not a number) then something went wrong!
    if (isnan(t) || isnan(h))
    {
        Serial.println(""Failed to read from DHT"");
        t = 0;
        h = 0;
    }
    output = {t, h};
    return output;
}
</code></pre>
",,56618546,174
47475409,2,47473644,2017-11-24T14:35:44.583,2,,794749,,2017-11-24T15:00:15.323,2017-11-24T15:00:15.323,6,,"<p>You need to make the <code>DHT</code> object part of the <code>AM_2301</code> class and then initialize it using <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer"">member initializer list</a>.</p>

<p>AM_2301.h</p>

<pre><code>#ifndef AM2301_h
#define AM2301_h

#include ""Arduino.h""

struct Two_float {
    float temp;
    float humidity;
};

class AM_2301
{
  public:
    AM_2301(int pin);
    void begin();
    struct Two_float read();
  private:
    DHT dht; // add a DHT object
};

#endif
</code></pre>

<p>AM_2301.cpp</p>

<pre><code>#include ""Arduino.h""
#include ""AM_2301.h""
#include ""DHT.h""

AM_2301::AM_2301(int pin) : dht(pin, DHT21) {} // initialize the DHT object

// other code stays the same
</code></pre>
",,56621670,102
47490594,2,47490481,2017-11-25T21:16:30.947,2,,413337,,2017-11-25T21:16:30.947,,1,,"<p>The ESP8266 can only read <code>float</code>s (and 16 bit <code>int</code>s, 32 bit <code>int</code>s, <code>double</code>s) from properly aligned addresses, i.e. addresses that are a multiple of the data types. As <code>float</code> is 4 bytes long, it can only be read from an address that is a multiple of 4. Otherwise you get the mentioned exception.</p>

<p>You are working with a <code>uint8_t</code> array. <code>uint8_t</code> is 1 byte long and therefore does not need and probably is not aligned in any way. The array might start at address 170001. If you now have a <code>float</code> value at position 40 within the array, your code tries to read a <code>float</code> value from address 170041, which is not properly aligned and causes an exception.</p>

<p>The solution is to first copy the bytes for the <code>float</code> value to a local, properly aligned variable. That's what you do but then you access it again in the non-aligned location and get an exception.</p>

<pre><code>    float* fTmp = (float*)iCurrentPos; // does not copy; takes a pointer to the orignal location

    float f;
    memcpy(&amp;f, fTmp, sizeof(float)); // copies data to aligned variable

    Serial.println(f); // prints value from aligned variable

    Serial.println(*fTmp); // prints value for original, non-aligned location
</code></pre>

<p>Just get rid of the last line.</p>
",,56631246,107
47511662,2,47503285,2017-11-27T13:04:25.683,1,,1158977,,2017-11-27T13:04:25.683,,0,,"<p>Maybe it's bad form to answer my own question but I hope it helps someone.</p>

<p>Thanks to the comment from @old_timer I search the <a href=""https://www.raspberrypi.org/forums/viewforum.php?f=72&amp;sid=0336afe301622b6425f79f0f63c1e7b7"" rel=""nofollow noreferrer"">bare metal</a> forum and found this <a href=""https://www.raspberrypi.org/forums/viewtopic.php?t=169582#p1193028"" rel=""nofollow noreferrer"">solution</a>:</p>

<pre><code>void set_PI3LED(bool on) {
    uint32_t __attribute__((aligned(16))) mailbox_message[8];
    mailbox_message[0] = sizeof(mailbox_message);
    mailbox_message[1] = 0;
    mailbox_message[2] = 0x38041;
    mailbox_message[3] = 8;
    mailbox_message[4] = 8;
    mailbox_message[5] = 130;
    mailbox_message[6] = (uint32_t)on;
    mailbox_message[7] = 0;
    mailbox_write(MB_CHANNEL_TAGS, mailbox_ARM_to_VC(&amp;mailbox_message[0]));
    mailbox_read(MB_CHANNEL_TAGS);
}
</code></pre>

<p>It's nice to know I wasn't too far off and it's good to know I now have the exact syntax I need.</p>
",,56631611,413
47514957,2,47514938,2017-11-27T15:55:27.783,3,,338904,,2017-11-27T16:04:35.617,2017-11-27T16:04:35.617,2,,"<p><code>##</code> is the concatenation</p>

<pre><code>#define TIMER_PASTE_B(lft,t,rgt)  lft##t##_##rgt
</code></pre>

<p>The preprocessor expands the definition to the concatenation of <code>lft</code>, <code>t</code>, <code>_</code> and <code>rgt</code>.</p>

<p>For instance</p>

<pre><code>TIMER_PASTE_B(ABC,DEF,GHI) 
</code></pre>

<p>would concatenate the tokens ABC, DEF, GHI and _ to</p>

<pre><code>ABCDEF_GHI
</code></pre>

<p>Edit</p>

<p>Say you define TIMER_TO_USE_FOR_TONE to be timer 3, for instance</p>

<pre><code>#define TIMER_TO_USE_FOR_TONE 3
</code></pre>

<p>the result would be</p>

<pre><code>void tone( uint8_t _pin, unsigned int frequency, unsigned long duration )
{
  timer3_ocr_t ocr;
  timer3_prescale_value_t csv;
  timer3_cs_t csi;
}
</code></pre>
",,56638490,189
47574292,2,47574054,2017-11-30T13:09:24.547,1,,7640269,,2017-11-30T13:09:24.547,,0,,"<p>You have the problem on <code>strlen()</code> which doesn't give null-terminated byte length.</p>

<pre><code>  char foo[400] = ""hello world"";
 // here you allocated the less width, in  C strings are the sequence of character bytes terminated with NULL in the end.
  char number[4]; 

  sprintf(number, ""value: %zu\n"", strlen(foo));
</code></pre>
",,56642550,1124
47631898,2,47617637,2017-12-04T11:04:21.580,0,,1720972,,2017-12-04T11:04:21.580,,0,,"<p>The pin is badly commented in <a href=""https://github.com/espressif/ESP8266_RTOS_SDK"" rel=""nofollow noreferrer"">ESP8266 RTOS SDK</a> and other documentation, however, I've managed to set it up via:</p>

<pre><code>void ICACHE_FLASH_ATTR gpio16_output_conf(void)
{
    WRITE_PERI_REG(PAD_XPD_DCDC_CONF,
                   (READ_PERI_REG(PAD_XPD_DCDC_CONF) &amp; 0xffffffbc) | (uint32)0x1);      // mux configuration for XPD_DCDC to output rtc_gpio0

    WRITE_PERI_REG(RTC_GPIO_CONF,
                   (READ_PERI_REG(RTC_GPIO_CONF) &amp; (uint32)0xfffffffe) | (uint32)0x0);      // mux configuration for out enable

    WRITE_PERI_REG(RTC_GPIO_ENABLE,
                   (READ_PERI_REG(RTC_GPIO_ENABLE) &amp; (uint32)0xfffffffe) | (uint32)0x1);    //out enable
}
</code></pre>

<p>taken from <a href=""https://github.com/willemwouters/ESP8266/blob/master/sdk/esp_iot_sdk_v0.9.3/IoT_Demo/driver/gpio16.c"" rel=""nofollow noreferrer"">IoT Demo GPIO16.c</a> implementation file.</p>
",,56662192,49
47719243,2,47716719,2017-12-08T17:18:07.980,1,,7478597,,2017-12-10T14:02:15.650,2017-12-10T14:02:15.650,1,,"<p>Actually, I considered the question a little bit too broad. On the other hand, I couldn't resist to ""try out"".</p>

<h1>Preface</h1>

<p>First, I want to criticize (a little bit) the question title. <strong><em>simple logic parser</em></strong> sounds for me like an interpreter of <a href=""https://en.wikipedia.org/wiki/Boolean_expression"" rel=""nofollow noreferrer""><em>boolean expressions</em></a>. However, I remember that my engineering colleagues are often talking about ""program logic"" (and I've not yet achieved that they get rid of this). Hence, my recommendation: If you (the questioner) are talking with computer scientists, use the term ""logic"" sensible (or they might look confused sometimes...)</p>

<p>The sample code <code>MD1,TP,RP5,TT,RP10</code> looks somehow familiar to me. A short google/wikipedia research cleared my mind: The Wikipedia article <a href=""https://en.wikipedia.org/wiki/Numerical_control"" rel=""nofollow noreferrer"">Numerical control</a> is about CNC machines. Close to the end of the article, the programming is mentioned. (The German ""sibling"" article provides even more.) IMHO, the code really looks similar a bit but seems to be even simpler. (No offense &ndash; I consider it as good to keep things as simple as possible.)</p>

<p>The program notation which seems to be intended is somehow like <a href=""https://en.wikipedia.org/wiki/Reverse_Polish_notation"" rel=""nofollow noreferrer"">Reverse Polish notation</a>. I wanted at least mention that term as googling for ""rpn interpreter"" throws a lot of sufficient hits including github sites. Actually, the description of the intended language is a little bit too short to decide certainly which existing S/W project could be appropriate. </p>

<p>Having said this, I want to show what I got...</p>

<h1>Parser</h1>

<p>I started first with a parser (as the questioner didn't dare to expose his). This is the code of <code>mci1.cc</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

using namespace std;

typedef unsigned char uchar;

enum Token {
  TkMD = 'M' | 'D' &lt;&lt; 8,
  TkRP = 'R' | 'P' &lt;&lt; 8,
  TkTP = 'T' | 'P' &lt;&lt; 8,
  TkTT = 'T' | 'T' &lt;&lt; 8
};

inline Token tokenize(uchar c0, uchar c1) { return (Token)(c0 | c1 &lt;&lt; 8); }

bool parse(istream &amp;in)
{
  for (;;) {
    // read command (2 chars)
    char cmd[2];
    if (in &gt;&gt; cmd[0] &gt;&gt; cmd[1]) {
      //cout &lt;&lt; ""DEBUG: token: "" &lt;&lt; hex &lt;&lt; tokenize(cmd[0], cmd[1]) &lt;&lt; endl;
      switch (tokenize(cmd[0], cmd[1])) {
        case TkMD: { // MD&lt;num&gt;
          int num;
          if (in &gt;&gt; num) {
            cout &lt;&lt; ""Received 'MD"" &lt;&lt; dec &lt;&lt; num &lt;&lt; ""'."" &lt;&lt; endl;
          } else {
            cerr &lt;&lt; ""ERROR: Number expected after 'MD'!"" &lt;&lt; endl;
            return false;
          }
        } break;
        case TkRP:  { // RP&lt;num&gt;
          int num;
          if (in &gt;&gt; num) {
            cout &lt;&lt; ""Received 'RP"" &lt;&lt; dec &lt;&lt; num &lt;&lt; ""'."" &lt;&lt; endl;
          } else {
            cerr &lt;&lt; ""ERROR: Number expected after 'RP'!"" &lt;&lt; endl;
            return false;
          }
        } break;
        case TkTP: // TP
          cout &lt;&lt; ""Received 'TP'."" &lt;&lt; endl;
          break;
        case TkTT: // TT
          cout &lt;&lt; ""Received 'TT'."" &lt;&lt; endl;
          break;
        default:
          cerr &lt;&lt; ""ERROR: Wrong command '"" &lt;&lt; cmd[0] &lt;&lt; cmd[1] &lt;&lt; ""'!"" &lt;&lt; endl;
          return false;
      }
    } else {
      cerr &lt;&lt; ""ERROR: Command expected!"" &lt;&lt; endl;
      return false;
    }
    // try to read separator
    char sep;
    if (!(in &gt;&gt; sep)) break; // probably EOF (further checks possible)
    if (sep != ',') {
      cerr &lt;&lt; ""ERROR: ',' expected!"" &lt;&lt; endl;
      return false;
    }
  }
  return true;
}

int main()
{
  // test string
  string sample(""MD1,TP,RP5,TT,RP10"");
  // read test string
  istringstream in(sample);
  if (parse(in)) cout &lt;&lt; ""Done."" &lt;&lt; endl;
  else cerr &lt;&lt; ""Interpreting aborted!"" &lt;&lt; endl;
  // done
  return 0;
}
</code></pre>

<p>I compiled and tested with <code>g++</code> and <code>bash</code> in Cygwin on Windows 10:</p>



<pre><code>$ g++ --version
g++ (GCC) 6.4.0

$ g++ -std=c++11 -o mci mci1.cc

$ ./mci
Received 'MD1'.
Received 'TP'.
Received 'RP5'.
Received 'TT'.
Received 'RP10'.
Done.

$
</code></pre>

<p>Uploaded for life demo on <a href=""https://ideone.com/ljANSE"" rel=""nofollow noreferrer""><strong>ideone</strong></a>.</p>

<p>I introduced the function <code>tokenize()</code> as part of an update. (I got the idea when I was tooth brushing and poring how to get rid of the ugly nested <code>switch</code>es of the previous version.) <a href=""https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization"" rel=""nofollow noreferrer"">Tokenizing</a> is a common technique in parsing &ndash; however, the implementation is usually a little bit different.</p>

<p>Thus, the parser seems to work. Not yet the next big thing but sufficient for the next step...</p>

<h1>Interpreter</h1>

<p>To interprete the parsed commands, I started to make a resp. back-end &ndash; a set of classes which may store and execute the required operations.</p>

<p>The <code>parse()</code> function of the first step became the <code>compile()</code> function where simple standard output was replaced by code building and nesting the operations. <code>mci2.cc</code>:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

// super class of all operations
class Op {
  protected:
    Op() = default;
  public:
    virtual ~Op() = default;
    virtual void exec() const = 0;
  // disabled: (to prevent accidental usage)
    Op(const Op&amp;) = delete;
    Op&amp; operator=(const Op&amp;) = delete;
};

// super class of grouping operations
class Grp: public Op {
  protected:
    vector&lt;Op*&gt; _pOps; // nested operations

  protected:
    Grp() = default;
    virtual ~Grp()
    {
      for (Op *pOp : _pOps) delete pOp;
    }
  public:
    void add(Op *pOp) { _pOps.push_back(pOp); }
  // disabled: (to prevent accidental usage)
    Grp(const Grp&amp;) = delete;
    Grp&amp; operator=(const Grp&amp;) = delete;
};

// class for repeat op.
class RP: public Grp {
  private:
    unsigned _n; // repeat count
  public:
    RP(unsigned n): Grp(), _n(n) { }
    virtual ~RP() = default;
    virtual void exec() const
    {
      cout &lt;&lt; ""Exec. RP"" &lt;&lt; _n &lt;&lt; endl;
      for (unsigned i = 0; i &lt; _n; ++i) {
        for (const Op *pOp : _pOps) pOp-&gt;exec();
      }
    }
  // disabled: (to prevent accidental usage)
    RP(const RP&amp;) = delete;
    RP&amp; operator=(const RP&amp;) = delete;
};

// class for TP op.
class TP: public Op {
  public:
    TP() = default;
    virtual ~TP() = default;
    virtual void exec() const
    {
      cout &lt;&lt; ""Exec. TP"" &lt;&lt; endl;
    }    
};

// class for TT op.
class TT: public Op {
  public:
    TT() = default;
    virtual ~TT() = default;
    virtual void exec() const
    {
      cout &lt;&lt; ""Exec. TT"" &lt;&lt; endl;
    }    
};

// class for MD sequence
class MD: public Grp {
  private:
    unsigned _axis;
  public:
    MD(unsigned axis): Grp(), _axis(axis) { }
    virtual ~MD() = default;
    virtual void exec() const
    {
      cout &lt;&lt; ""Exec. MD"" &lt;&lt; _axis &lt;&lt; endl;
      for (const Op *pOp : _pOps) pOp-&gt;exec();
    }
};

typedef unsigned char uchar;

enum Token {
  TkMD = 'M' | 'D' &lt;&lt; 8,
  TkRP = 'R' | 'P' &lt;&lt; 8,
  TkTP = 'T' | 'P' &lt;&lt; 8,
  TkTT = 'T' | 'T' &lt;&lt; 8
};

inline Token tokenize(uchar c0, uchar c1) { return (Token)(c0 | c1 &lt;&lt; 8); }

MD* compile(istream &amp;in)
{
  MD *pMD = nullptr;
  stack&lt;Op*&gt; pOpsNested;
#define ERROR \
  delete pMD; \
  while (pOpsNested.size()) { delete pOpsNested.top(); pOpsNested.pop(); } \
  return nullptr
  for (;;) {
    // read command (2 chars)
    char cmd[2];
    if (in &gt;&gt; cmd[0] &gt;&gt; cmd[1]) {
      //cout &lt;&lt; ""DEBUG: token: "" &lt;&lt; hex &lt;&lt; tokenize(cmd[0], cmd[1]) &lt;&lt; dec &lt;&lt; endl;
      switch (tokenize(cmd[0], cmd[1])) {
        case TkMD: { // MD&lt;num&gt;
          int num;
          if (in &gt;&gt; num) {
            if (pMD) {
              cerr &lt;&lt; ""ERROR: Unexpected command 'MD"" &lt;&lt; num &lt;&lt; ""'!"" &lt;&lt; endl;
              ERROR;
            }
            pMD = new MD(num);
          } else {
            cerr &lt;&lt; ""ERROR: Number expected after 'MD'!"" &lt;&lt; endl;
            ERROR;
          }
        } break;
        case TkRP:  { // RP&lt;num&gt;
          int num;
          if (in &gt;&gt; num) {
            if (!pMD) {
              cerr &lt;&lt; ""ERROR: Unexpected command 'RP"" &lt;&lt; num &lt;&lt; ""'!"" &lt;&lt; endl;
              ERROR;
            }
            RP *pRP = new RP(num);
            while (pOpsNested.size()) {
              pRP-&gt;add(pOpsNested.top());
              pOpsNested.pop();
            }
            pOpsNested.push(pRP);
          } else {
            cerr &lt;&lt; ""ERROR: Number expected after 'RP'!"" &lt;&lt; endl;
            ERROR;
          }
        } break;
        case TkTP: { // TP
          if (!pMD) {
            cerr &lt;&lt; ""ERROR: Unexpected command 'TP'!"" &lt;&lt; endl;
            ERROR;
          }
          pOpsNested.push(new TP());
        } break;
        case TkTT: { // TT
          if (pOpsNested.empty()) {
            cerr &lt;&lt; ""ERROR: Unexpected command 'TT'!"" &lt;&lt; endl;
            ERROR;
          }
          pOpsNested.push(new TT());
        } break;
        default:
          cerr &lt;&lt; ""ERROR: Wrong command '"" &lt;&lt; cmd[0] &lt;&lt; cmd[1] &lt;&lt; ""'!"" &lt;&lt; endl;
          ERROR;
      }
    } else {
      cerr &lt;&lt; ""ERROR: Command expected!"" &lt;&lt; endl;
      ERROR;
    }
    // try to read separator
    char sep;
    if (!(in &gt;&gt; sep)) break; // probably EOF (further checks possible)
    if (sep != ',') {
      cerr &lt;&lt; ""ERROR: ',' expected!"" &lt;&lt; endl;
      ERROR;
    }
  }
#undef ERROR
  assert(pMD != nullptr);
  while (pOpsNested.size()) {
    pMD-&gt;add(pOpsNested.top());
    pOpsNested.pop();
  }
  return pMD;
}

int main()
{
  // test string
  string sample(""MD1,TP,RP3,TT,RP2"");
  // read test string
  istringstream in(sample);
  MD *pMD = compile(in);
  if (!pMD) {
    cerr &lt;&lt; ""Interpreting aborted!"" &lt;&lt; endl;
    return 1;
  }
  // execute sequence
  pMD-&gt;exec();
  delete pMD;
  // done
  return 0;
}
</code></pre>

<p>Again, I compiled and tested with <code>g++</code> and <code>bash</code> in Cygwin on Windows 10:</p>



<pre><code>$ g++ -std=c++11 -o mci mci2.cc

$ ./mci
Exec. MD1
Exec. RP2
Exec. TT
Exec. RP3
Exec. TP
Exec. TP
Exec. TP
Exec. TT
Exec. RP3
Exec. TP
Exec. TP
Exec. TP

$
</code></pre>

<p>Uploaded for life demo on <a href=""https://ideone.com/FSJUHr"" rel=""nofollow noreferrer""><strong>ideone</strong></a>.</p>

<p>The trick with the nesting is rather simple done in the <code>compile()</code> function:</p>

<ul>
<li><p>commands <code>TP</code> and <code>TT</code> are added to a temporary stack <code>pOpsNested</code></p></li>
<li><p>for command <code>RP</code>, all collected operations are added to the <code>RP</code> instance popping the <code>pOpsNested</code> stack (and thus reversing their order),<br/>
afterwards, the <code>RP</code> instance itself is pushed into <code>pOpsNested</code> stack instead</p></li>
<li><p>finally the contents of buffer <code>pOpsNested</code> is added to sequence <code>MD</code> (as these are the top-level ops).</p></li>
</ul>
",,56667451,221
47823268,2,47823215,2017-12-14T22:44:24.600,1,,2634818,,2017-12-14T22:44:24.600,,0,,"<p>Since writing this post I found the answer so I thought I would post to help others anyway.</p>

<p>To fix the issue, you just need to move the initialisation of the static members from the definition file (.h) to the declaration file (.cpp)</p>

<p><strong>Module.h</strong> looks as follows:</p>

<pre><code>#ifndef _MODULE_h
#define _MODULE_h

class Module {
public:
    enum CmdKeys { Forward, Left, Back, Right, Stop };
    static const CmdKeys AvailableCommandKeys[2];

    // other definitions...
}
<b><s>const Module::CmdKeys Module::AvailableCommandKeys[] = { Forward, Back };</s></b>

#endif</code></pre>

<p><strong>Module.cpp</strong> looks as follows:</p>

<pre><code>#include ""Module.h""

<b>const Module::CmdKeys Module::AvailableCommandKeys[] = { Forward, Back };</b>

// Other code...
</code></pre>
",,56687570,33
47842188,2,47834740,2017-12-16T03:09:48.033,2,,794749,,2017-12-16T03:09:48.033,,0,,"<p>You need to convert your desired string ""hello world"" into a hexadecimal string.</p>

<p>The conversion function:</p>

<pre class=""lang-cpp prettyprint-override""><code>bool string_to_hexstring(char *string, char *hexstring, uint16_t hexstring_length)
{
    uint16_t hexstring_index = 0;
    while(string[hexstring_index/2] != 0 &amp;&amp; hexstring_index &lt; hexstring_length-2)
    {
        char c = string[hexstring_index/2];
        byte nib1 = (c &gt;&gt; 4) &amp; 0x0F;
        byte nib2 = (c &gt;&gt; 0) &amp; 0x0F;
        hexstring[hexstring_index++] = nib1  &lt; 0xA ? '0' + nib1  : 'A' + nib1  - 0xA;
        hexstring[hexstring_index++] = nib2  &lt; 0xA ? '0' + nib2  : 'A' + nib2  - 0xA;
    }
    hexstring[hexstring_index++] = 0;
    return string[hexstring_index/2] == 0;
}
</code></pre>

<p>And later in your code:</p>

<pre class=""lang-cpp prettyprint-override""><code>char buffer[32]; // needs to be at least two times the string size + 1
if (!string_to_hexstring(""hello world"", buffer, sizeof(buffer))) {
    // buffer size too small
}
error = LoRaWAN.sendRadio(buffer);
</code></pre>
",,56696428,102
47885242,2,47873551,2017-12-19T10:49:08.663,1,,797152,,2017-12-19T10:49:08.663,,0,,"<p>It's hard to say for sure but it looks like the HID report descriptor does not match your HID_SerialTouchReport structure. The following is how I decoded your descriptor:</p>

<pre><code>//--------------------------------------------------------------------------------
// Decoded Application Collection
//--------------------------------------------------------------------------------

/*
05 0D        (GLOBAL) USAGE_PAGE         0x000D Digitizer Device Page 
09 04        (LOCAL)  USAGE              0x000D0004 Touch Screen (CA=Application Collection) 
A1 01        (MAIN)   COLLECTION         0x00000001 Application (Usage=0x000D0004: Page=Digitizer Device Page, Usage=Touch Screen, Type=CA)
85 01          (GLOBAL) REPORT_ID          0x01 (1) 
09 22          (LOCAL)  USAGE              0x000D0022 Finger (CL=Logical Collection) 
A1 00          (MAIN)   COLLECTION         0x00000000 Physical (Usage=0x000D0022: Page=Digitizer Device Page, Usage=Finger, Type=CL) &lt;-- Warning: USAGE type should be CP (Physical)
09 42            (LOCAL)  USAGE              0x000D0042 Tip Switch (MC=Momentary Control) 
15 00            (GLOBAL) LOGICAL_MINIMUM    0x00 (0) &lt;-- Redundant: LOGICAL_MINIMUM is already 0 &lt;-- Info: Consider replacing 15 00 with 14
25 01            (GLOBAL) LOGICAL_MAXIMUM    0x01 (1)  
75 01            (GLOBAL) REPORT_SIZE        0x01 (1) Number of bits per field  
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (1 field x 1 bit) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
95 03            (GLOBAL) REPORT_COUNT       0x03 (3) Number of fields  
81 03            (MAIN)   INPUT              0x00000003 (3 fields x 1 bit) 1=Constant 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 32            (LOCAL)  USAGE              0x000D0032 In Range (MC=Momentary Control) 
09 47            (LOCAL)  USAGE              0x000D0047 Confidence (DV=Dynamic Value) 
95 02            (GLOBAL) REPORT_COUNT       0x02 (2) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (2 fields x 1 bit) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
95 0A            (GLOBAL) REPORT_COUNT       0x0A (10) Number of fields  
81 03            (MAIN)   INPUT              0x00000003 (10 fields x 1 bit) 1=Constant 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
05 01            (GLOBAL) USAGE_PAGE         0x0001 Generic Desktop Page 
26 FF7F          (GLOBAL) LOGICAL_MAXIMUM    0x7FFF (32767)  
75 10            (GLOBAL) REPORT_SIZE        0x10 (16) Number of bits per field  
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
65 00            (GLOBAL) UNIT               0x00000000 No unit (0=None) &lt;-- Redundant: UNIT is already 0x00000000
09 30            (LOCAL)  USAGE              0x00010030 X (DV=Dynamic Value) 
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 31            (LOCAL)  USAGE              0x00010031 Y (DV=Dynamic Value) 
46 0000          (GLOBAL) PHYSICAL_MAXIMUM   0x0000 (0) &lt;-- Redundant: PHYSICAL_MAXIMUM is already 0 &lt;-- Info: Consider replacing 46 0000 with 44
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
05 0D            (GLOBAL) USAGE_PAGE         0x000D Digitizer Device Page 
09 48            (LOCAL)  USAGE              0x000D0048 Width (DV=Dynamic Value) 
09 49            (LOCAL)  USAGE              0x000D0049 Height (DV=Dynamic Value) 
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields &lt;-- Redundant: REPORT_COUNT is already 1 
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
81 03            (MAIN)   INPUT              0x00000003 (1 field x 16 bits) 1=Constant 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 51            (LOCAL)  USAGE              0x000D0051 Contact Identifier (DV=Dynamic Value) 
75 10            (GLOBAL) REPORT_SIZE        0x10 (16) Number of bits per field &lt;-- Redundant: REPORT_SIZE is already 16 
95 02            (GLOBAL) REPORT_COUNT       0x02 (2) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (2 fields x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 55            (LOCAL)  USAGE              0x000D0055 Contact Count Maximum (SV=Static Value) 
15 00            (GLOBAL) LOGICAL_MINIMUM    0x00 (0) &lt;-- Redundant: LOGICAL_MINIMUM is already 0 &lt;-- Info: Consider replacing 15 00 with 14
25 08            (GLOBAL) LOGICAL_MAXIMUM    0x08 (8)  
75 08            (GLOBAL) REPORT_SIZE        0x08 (8) Number of bits per field  
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
B1 02            (MAIN)   FEATURE            0x00000002 (1 field x 8 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
C0             (MAIN)   END_COLLECTION     Physical 
C0           (MAIN)   END_COLLECTION     Application 
*/

//--------------------------------------------------------------------------------
// Digitizer Device Page featureReport 01 (Device &lt;-&gt; Host)
//--------------------------------------------------------------------------------

typedef struct
{
  uint8_t  reportId;                                 // Report ID = 0x01 (1)
                                                     // Collection: TouchScreen Finger
  uint8_t  DIG_TouchScreenFingerContactCountMaximum; // Usage 0x000D0055: Contact Count Maximum, Value = 0 to 8
} featureReport01_t;


//--------------------------------------------------------------------------------
// Digitizer Device Page inputReport 01 (Device --&gt; Host)
//--------------------------------------------------------------------------------

typedef struct
{
  uint8_t  reportId;                                 // Report ID = 0x01 (1)
                                                     // Collection: TouchScreen Finger
  uint8_t  DIG_TouchScreenFingerTipSwitch : 1;       // Usage 0x000D0042: Tip Switch, Value = 0 to 1
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  DIG_TouchScreenFingerInRange : 1;         // Usage 0x000D0032: In Range, Value = 0 to 1
  uint8_t  DIG_TouchScreenFingerConfidence : 1;      // Usage 0x000D0047: Confidence, Value = 0 to 1
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint16_t GD_TouchScreenFingerX;                    // Usage 0x00010030: X, Value = 0 to 32767
  uint16_t GD_TouchScreenFingerY;                    // Usage 0x00010031: Y, Value = 0 to 32767
  uint16_t DIG_TouchScreenFingerWidth;               // Usage 0x000D0048: Width, Value = 0 to 32767
                                                     // Usage 0x000D0049 Height (DV=Dynamic Value) Value = 0 to 32767 &lt;-- Ignored: REPORT_COUNT (1) is too small
  uint16_t pad_8;                                    // Pad
  uint16_t DIG_TouchScreenFingerContactIdentifier[2]; // Usage 0x000D0051: Contact Identifier, Value = 0 to 32767
} inputReport01_t;
</code></pre>

<p>When I set the correct report count for Width and Height and remove the (unnecessary?) pad byte, the unnecessary UNIT and PHYSICAL_MAXIMUM, and redundant GLOBAL items, and change the contact identifier REPORT_COUNT from 2 to 1, it looks better to me:</p>

<pre><code>//--------------------------------------------------------------------------------
// Decoded Application Collection
//--------------------------------------------------------------------------------

/*
05 0D        (GLOBAL) USAGE_PAGE         0x000D Digitizer Device Page 
09 04        (LOCAL)  USAGE              0x000D0004 Touch Screen (CA=Application Collection) 
A1 01        (MAIN)   COLLECTION         0x00000001 Application (Usage=0x000D0004: Page=Digitizer Device Page, Usage=Touch Screen, Type=CA)
85 01          (GLOBAL) REPORT_ID          0x01 (1) 
09 22          (LOCAL)  USAGE              0x000D0022 Finger (CL=Logical Collection) 
A1 00          (MAIN)   COLLECTION         0x00000000 Physical (Usage=0x000D0022: Page=Digitizer Device Page, Usage=Finger, Type=CL) &lt;-- Warning: USAGE type should be CP (Physical)
09 42            (LOCAL)  USAGE              0x000D0042 Tip Switch (MC=Momentary Control) 
15 00            (GLOBAL) LOGICAL_MINIMUM    0x00 (0) &lt;-- Redundant: LOGICAL_MINIMUM is already 0 &lt;-- Info: Consider replacing 15 00 with 14
25 01            (GLOBAL) LOGICAL_MAXIMUM    0x01 (1)  
75 01            (GLOBAL) REPORT_SIZE        0x01 (1) Number of bits per field  
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (1 field x 1 bit) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
95 03            (GLOBAL) REPORT_COUNT       0x03 (3) Number of fields  
81 03            (MAIN)   INPUT              0x00000003 (3 fields x 1 bit) 1=Constant 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 32            (LOCAL)  USAGE              0x000D0032 In Range (MC=Momentary Control) 
09 47            (LOCAL)  USAGE              0x000D0047 Confidence (DV=Dynamic Value) 
95 02            (GLOBAL) REPORT_COUNT       0x02 (2) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (2 fields x 1 bit) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
95 0A            (GLOBAL) REPORT_COUNT       0x0A (10) Number of fields  
81 03            (MAIN)   INPUT              0x00000003 (10 fields x 1 bit) 1=Constant 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
05 01            (GLOBAL) USAGE_PAGE         0x0001 Generic Desktop Page 
26 FF7F          (GLOBAL) LOGICAL_MAXIMUM    0x7FFF (32767)  
75 10            (GLOBAL) REPORT_SIZE        0x10 (16) Number of bits per field  
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
09 30            (LOCAL)  USAGE              0x00010030 X (DV=Dynamic Value) 
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 31            (LOCAL)  USAGE              0x00010031 Y (DV=Dynamic Value) 
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
05 0D            (GLOBAL) USAGE_PAGE         0x000D Digitizer Device Page 
09 48            (LOCAL)  USAGE              0x000D0048 Width (DV=Dynamic Value) 
09 49            (LOCAL)  USAGE              0x000D0049 Height (DV=Dynamic Value) 
95 02            (GLOBAL) REPORT_COUNT       0x02 (2) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (2 fields x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 51            (LOCAL)  USAGE              0x000D0051 Contact Identifier (DV=Dynamic Value) 
95 01            (GLOBAL) REPORT_COUNT       0x01 (1) Number of fields  
81 02            (MAIN)   INPUT              0x00000002 (1 field x 16 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
09 55            (LOCAL)  USAGE              0x000D0055 Contact Count Maximum (SV=Static Value) 
25 08            (GLOBAL) LOGICAL_MAXIMUM    0x08 (8)  
75 08            (GLOBAL) REPORT_SIZE        0x08 (8) Number of bits per field  
B1 02            (MAIN)   FEATURE            0x00000002 (1 field x 8 bits) 0=Data 1=Variable 0=Absolute 0=NoWrap 0=Linear 0=PrefState 0=NoNull 0=NonVolatile 0=Bitmap 
C0             (MAIN)   END_COLLECTION     Physical 
C0           (MAIN)   END_COLLECTION     Application 
*/

//--------------------------------------------------------------------------------
// Digitizer Device Page featureReport 01 (Device &lt;-&gt; Host)
//--------------------------------------------------------------------------------

typedef struct
{
  uint8_t  reportId;                                 // Report ID = 0x01 (1)
                                                     // Collection: TouchScreen Finger
  uint8_t  DIG_TouchScreenFingerContactCountMaximum; // Usage 0x000D0055: Contact Count Maximum, Value = 0 to 8
} featureReport01_t;


//--------------------------------------------------------------------------------
// Digitizer Device Page inputReport 01 (Device --&gt; Host)
//--------------------------------------------------------------------------------

typedef struct
{
  uint8_t  reportId;                                 // Report ID = 0x01 (1)
                                                     // Collection: TouchScreen Finger
  uint8_t  DIG_TouchScreenFingerTipSwitch : 1;       // Usage 0x000D0042: Tip Switch, Value = 0 to 1
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  DIG_TouchScreenFingerInRange : 1;         // Usage 0x000D0032: In Range, Value = 0 to 1
  uint8_t  DIG_TouchScreenFingerConfidence : 1;      // Usage 0x000D0047: Confidence, Value = 0 to 1
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint8_t  : 1;                                      // Pad
  uint16_t GD_TouchScreenFingerX;                    // Usage 0x00010030: X, Value = 0 to 32767
  uint16_t GD_TouchScreenFingerY;                    // Usage 0x00010031: Y, Value = 0 to 32767
  uint16_t DIG_TouchScreenFingerWidth;               // Usage 0x000D0048: Width, Value = 0 to 32767
  uint16_t DIG_TouchScreenFingerHeight;              // Usage 0x000D0049: Height, Value = 0 to 32767
  uint16_t DIG_TouchScreenFingerContactIdentifier;   // Usage 0x000D0051: Contact Identifier, Value = 0 to 32767
} inputReport01_t;
</code></pre>

<p>These HID report descriptors are so tricky to handcraft that I'm not surprised that even Microsoft gets it wrong from time to time. If only some programming whiz (i.e way better than me) could come up with some decent software to create them I think the world would be a better place :)</p>

<p>Disclosure: I decoded your report descriptor using some free software I wrote called <a href=""https://sourceforge.net/projects/hidrdd/"" rel=""nofollow noreferrer"">hidrdd</a>. I've been meaning to port it to Python but haven't got around to learning Python yet.</p>

<p>BTW, the difference between var and ary can be best understood as the difference between C declarations:</p>

<pre><code>// var is like:
uint8_t my_value1;
uint8_t my_value2;

// ary is like:
uint8_t my_value[2];
</code></pre>

<p>The maximumcount thing appears to be the ""Contact Count Maximum"" usage - i.e. the maximum number of fingers pressed concurrently and is part of a feature report (that can be sent or received from the device). The report descriptor indicates that it can have a value of between 0 fingers and 8 fingers concurrently pressed.</p>
",,56708674,483
47892850,2,47889506,2017-12-19T18:08:33.337,0,,7699452,,2017-12-19T18:08:33.337,,0,,"<p>Everything in the code seems easy to understand. Along with the comment it is clear as a crystal. But as you said, you need an explanation, I will provide an answer :</p>

<pre><code>const byte numRows= 4; //number of rows on the keypad
const byte numCols= 4; //number of columns on the keypad
</code></pre>

<p>In the above given piece of code, two byte vaiables would be declared named <code>numRows</code> and <code>numCols</code> and initialized each with the value 4.</p>

<pre><code>byte rowPins[numRows] = {9, 8, 7, 6}; //Rows 0 to 3
byte colPins[numCols]= {5, 4, 3, 2}; //Columns 0 to 3
</code></pre>

<p>So here is the code that you are stuck at. Two byte array would be declared named <code>rowPins</code> and <code>colPins</code> each of size 4 (since value of <code>numRows</code> and <code>numCols</code> are 4). Which would range from 0 to 3 (like array in c or java). In this numbers 9,8,7,6 would be assigned to array <code>rowPins</code> and 5,4,3,2 will be assigned to array <code>colPins</code>. Now how or where will these values be. They will be stored in a sequential way from index 0 to index 3. i.e </p>

<pre><code>rowPins[0]=9
rowPins[1]=8
rowPins[2]=7
rowPins[3]=6
colPins[0]=5
colPins[1]=4
colPins[2]=3
colPins[3]=2
</code></pre>

<p>This is how they get those numbers.</p>
",,56748323,1133
47901638,2,47900395,2017-12-20T08:23:39.170,1,,6700019,,2017-12-20T08:23:39.170,,0,,"<p>Thanks to @Someprogrammerdude to help. I needed to declare the <code>read</code> function as static.</p>

<p>SRF08.h</p>

<pre><code>#ifndef SRF08_h
#define SRF08_h

#include ""Arduino.h""

class SRF08
{
public:
    //main constructor
    SRF08(uint8_t address=address_1);
    // init the sensor
    void begin(void);

    //change sensor address from oldAddress to newAddress
    void changeAddress(uint16_t oldAddress, uint16_t newAddress);
    // scan for a single sensor address
    int8_t scanner(void);
    // scan for multiple sensors and return the table of addresses
    struct table_value scan_all(void);
    static uint16_t output_value;
    static void read(void);
    static uint16_t static_address;

private:
    // the main I2C address of Sensor
    uint16_t _address;
    //read sansor value base on centimiter
};
#endif
</code></pre>

<p>SRF08.cpp</p>

<pre><code>#include ""Wire.h""
#include ""SRF08.h""
// Include Scheduler since we want to manage multiple tasks.
#include ""Scheduler.h""

//initilize static members

uint16_t SRF08::output_value;
uint16_t SRF08::static_address;

SRF08::SRF08(uint8_t address)
{
    //main constructor, address is the sensor address if u dont know it try scanner first
    //address must be an integer number between 1 to 9
    if (address == 1) _address = address_1;
    else _address = address_1;
    static_address = _address;
    //begin();
}

void SRF08::begin(){
    //initilize I2C
    Wire.begin();
    output_value = 0;
    Scheduler.startLoop(read);  //here is my error
}


void SRF08::read(){
    int reading = 0;
    // step 1: instruct sensor to read echoes
    Wire.beginTransmission(static_address); // transmit to device #112 (0x70)
    // the address specified in the datasheet is 224 (0xE0)
    // but i2c adressing uses the high 7 bits so it's 112
    Wire.write(byte(0x00));      // sets register pointer to the command register (0x00)
    Wire.write(byte(0x51));      // command sensor to measure in ""inches"" (0x50)
    // use 0x51 for centimeters
    // use 0x52 for ping microseconds
    Wire.endTransmission();      // stop transmitting

    // step 2: wait for readings to happen
    delay(70);                   // datasheet suggests at least 65 milliseconds

    // step 3: instruct sensor to return a particular echo reading
    Wire.beginTransmission(static_address); // transmit to device #112
    Wire.write(byte(0x02));      // sets register pointer to echo #1 register (0x02)
    Wire.endTransmission();      // stop transmitting

    // step 4: request reading from sensor
    Wire.requestFrom(static_address, 2);    // request 2 bytes from slave device #112

    // step 5: receive reading from sensor
    if (2 &lt;= Wire.available()) { // if two bytes were received
        reading = Wire.read();  // receive high byte (overwrites previous reading)
        reading = reading &lt;&lt; 8;    // shift high byte to be high 8 bits
        reading |= Wire.read(); // receive low byte as lower 8 bits
        output_value = reading;   // print the reading
        //output_value = reading;
    }
    yield();
}
</code></pre>
",,56756589,492
47914137,2,47913591,2017-12-20T20:47:40.933,7,,1475978,,2017-12-20T20:47:40.933,,9,,"<p>The cause of the strange error is the lack of correct headers, specifically <code>&lt;unistd.h&gt;</code>. This causes the parameters to <a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""noreferrer""><code>write()</code></a> to be of incorrect types, especially the <code>count</code> parameter.</p>

<p>Try this corrected version of your program:</p>

<pre><code>#define _POSIX_C_SOURCE 200809L
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    long long int value = 89;
    ssize_t n;
    int descriptor;

    if (argc != 2) {
        fprintf(stderr, ""\nUsage: %s FILENAME\n\n"", argv[0]);
        return EXIT_FAILURE;
    }

    descriptor = open(argv[1], O_RDWR | O_CREAT, 0666);
    if (descriptor == -1) {
        fprintf(stderr, ""%s: %s.\n"", argv[1], strerror(errno));
        return EXIT_FAILURE;
    }

    n = write(descriptor, &amp;value, sizeof value);
    if (n != sizeof value) {
        if (n == -1)
            fprintf(stderr, ""%s: %s.\n"", argv[1], strerror(errno));
        else
            fprintf(stderr, ""%s: Partial write (%zd bytes).\n"", argv[1], n);
        close(descriptor);
        return EXIT_FAILURE;
    }

    if (close(descriptor)) {
        fprintf(stderr, ""%s: Error closing file.\n"", argv[1]);
        return EXIT_FAILURE;
    }

    printf(""%zd bytes written successfully to '%s'.\n"", n, argv[1]);
    return EXIT_SUCCESS;
}
</code></pre>

<p>Always, <strong>always</strong> enable warnings when compiling code. With GCC, I use <code>gcc -Wall -O2</code> (for both warnings and compiler-optimized results). I warmly recommend you do the same. If you save the above as <code>fixed.c</code>, then compile it using</p>

<pre><code>gcc -Wall -O2 fixed.c -o fixed-example
</code></pre>

<p>and run it using</p>

<pre><code>./fixed-example output-file
</code></pre>

<p>If you need to compile against e.g. the math library, include the options just before the <code>-o</code> flag; i.e. <code>gcc -Wall -O2 fixed.c -lm -o fixed-example</code> for the above program. The order of options do matter for GCC.</p>
",,56767642,31
47959952,2,47959824,2017-12-24T10:52:48.640,1,,8970365,,2017-12-24T10:52:48.640,,0,,"<p>Try this code</p>

<pre><code> int ledPin = 13;
String readString;

void setup() {
  Serial.begin(115200);
  pinMode(ledPin, OUTPUT);
  Serial.println(""Serial Blinker (Input 'on' to blink and 'off' to stop blinking)"");
}
void loop() {
  readString = """";
  while (Serial.available()) {
    delay(3);
    char c = Serial.read();
    readString += c;
  }
  readString.trim();
  if (readString.length() &gt; 0) {
    if (readString == ""on"") {
      Serial.println(""switching on"");
      next();
    }
    else if(readString == ""off""){
      digitalWrite(ledPin, LOW);
    }
  }
}
void next() {
  digitalWrite(ledPin, HIGH);
  delay(500);
  digitalWrite(ledPin, LOW);
  delay(500);
  digitalWrite(ledPin, HIGH);
  delay(500);
  digitalWrite(ledPin, LOW);
  delay(500);
   readString = """";
  while (Serial.available()) {
    delay(3);
    char c = Serial.read();
    readString += c;
  }
  readString.trim();

    if (readString == ""off"") {
      Serial.print(""off"");
      digitalWrite(ledPin, LOW);
      off();
    }
    else {
            next();
    }

}

void off(){
  Serial.print(""in off"");
  digitalWrite(ledPin, LOW);

}
</code></pre>
",,56771664,474
47972318,2,47969304,2017-12-25T22:05:45.923,0,,9138960,,2017-12-25T22:05:45.923,,0,,"<p>I fixed that ... there was problem with ..</p>

<pre><code>      if(finalstr.length()  == 4) onlyone = true;
  if(onlyone)
  {
      finalchar = (charToVal(hex[0]) &lt;&lt; 4) + charToVal(hex[1]); 
      utf8 += String(finalchar);

      finalchar = (charToVal(hex[2]) &lt;&lt; 4) + charToVal(hex[3]); 
      utf8 += String(finalchar);
  }
  else
  {
    finalchar = (charToVal(hex[0]) &lt;&lt; 4) + charToVal(hex[1]); 
    utf8 += String(finalchar);
  }
</code></pre>
",,56784110,116
48016807,2,47984333,2017-12-29T02:48:54.337,2,,1466970,,2017-12-29T02:48:54.337,,0,,"<p>The <code>libcoap</code> functions for creating a server and a client require a few more steps as part of formatting and retrieving the URI and the URI query information into/from a CoAP request.</p>

<p>The complete sample applications, client.c and server.c, are in my GitHub repository at <a href=""https://github.com/RichardChambers/raspberrypi/tree/master/coap"" rel=""nofollow noreferrer"">https://github.com/RichardChambers/raspberrypi/tree/master/coap</a> .</p>

<p>On the server side the message handler will use an option iterator, a <code>coap_opt_iterator_t</code> struct object, to iterate over the options of the <code>coap_pdu_t</code> struct request object. While iterating, the server will be looking for options of type <code>COAP_OPTION_URI_QUERY</code> which will contain a query argument, usually a keyword equal value pair.</p>

<p>So the function <code>hello_handler()</code> of the posted question could be rewritten with a helper function to obtain the list of URI query items as follows:</p>

<pre><code>/*
 * The following helper function, printQueryOption(), is used to
 * iterate over the list of options looking for query type options
 * to the base URI. This is analogous to a web URL that contains
 * a question mark followed by options such as:
 *    http://www.server.com/hello?type=1,id=2345
 *
 * We will return a value of 1 (true) if we found something or a value
 * of 0 (false) if we do not.
*/
static int
printQueryOption (coap_pdu_t *request, coap_opt_iterator_t * popt_iter )
{
        int  iRet = 0;
        coap_opt_t *option;

        // iterate over the options looking for queries. If we find one
        // then print it and return a value of 1, true, to indicate we
        // found one. If we don't find any then return the default value
        // of 0, false.
        while (option = coap_option_next(popt_iter)) {
                // found an option, is it a query option or not.
                if (popt_iter-&gt;type != COAP_OPTION_URI_QUERY) continue;
                // it is a query option so print out the query text.
                char xBuff[128] = {0};
                strncpy (xBuff, COAP_OPT_VALUE(option), COAP_OPT_LENGTH(option));
                printf (""    option  len %d\n         %s \n"", COAP_OPT_LENGTH(option), xBuff);

                // indicate that we found a query option.
                iRet = 1;
                break;
        }

        return iRet;
}

/*
 * The resource handler which the libcoap library will invoke when the registered
 * URI is specified. This is a simple request handler which will just display some
 * of the information from the request.
 */
static void
hello_handler(coap_context_t *ctx, struct coap_resource_t *resource,
              const coap_endpoint_t *local_interface, coap_address_t *peer,
              coap_pdu_t *request, str *token, coap_pdu_t *response)
{
        static  int iCount = 0;   // a simple count to provide some kind of response data.
        unsigned char buf[3];
        const char* response_data     = ""{\""device\"": \""DEV-01-123\"", \""item\"" : %d }"";
        char response_buf[256] = {0};

        // generate a response to this request. we have a hard coded JSON text that
        // we are using as a stub for testing.
        response-&gt;hdr-&gt;code           = COAP_RESPONSE_CODE(205);
        coap_add_option(response, COAP_OPTION_CONTENT_TYPE, coap_encode_var_bytes(buf, COAP_MEDIATYPE_TEXT_PLAIN), buf);

        sprintf (response_buf, response_data, iCount);
        coap_add_data  (response, strlen(response_buf), (unsigned char *)response_buf);
        iCount++;    // this count is some type of varying data so that we can see things are working.

        if (request != NULL) {
                // there is a request URI so lets print out the base URI and then
                // iterate over the options looking for the Query type options.
                coap_opt_iterator_t  opt_iter;

                printf ("" request %s\n"", resource-&gt;uri.s);
                coap_option_iterator_init (request, &amp;opt_iter, COAP_OPT_ALL);

                // iterate over the options of the request printing out any
                // query text that may exist.
                while (printQueryOption (request, &amp;opt_iter));
        } else {
                printf ("" request - NONE\n"");
        }
}
</code></pre>

<p>On the client side we would build our request adding the queries we want to include in the request with a series of calls of function <code>coap_add_option()</code> as in:</p>

<pre><code>coap_split_uri(server_uri, strlen(server_uri), &amp;uri);
request            = coap_new_pdu();
request-&gt;hdr-&gt;type = COAP_MESSAGE_CON;
request-&gt;hdr-&gt;id   = coap_new_message_id(ctx);
request-&gt;hdr-&gt;code = get_method;

printf ("" Request URI: path %d %s\n"", uri.path.length, uri.path.s);

coap_add_option(request, COAP_OPTION_URI_PATH, uri.path.length, uri.path.s);
sprintf (server_query, ""item=%d"", iItem);
coap_add_option(request, COAP_OPTION_URI_QUERY, strlen(server_query), server_query);
printf (""         Query: len %d %s\n"", strlen(server_query), server_query);
sprintf (server_query, ""device=%s"", aszDevName);
coap_add_option(request, COAP_OPTION_URI_QUERY, strlen(server_query), server_query);
printf (""         Query: len %d %s\n"", strlen(server_query), server_query);
sprintf (server_query, ""tempo=%s"", aszTempoName);
coap_add_option(request, COAP_OPTION_URI_QUERY, strlen(server_query), server_query);
printf (""         Query: len %d %s\n"", strlen(server_query), server_query);
</code></pre>

<p>These statements create a CoAP request to a particular URI with a set of arguments or query options so that the server's handler of the URI can provide a specific response back to the request. For this example the variables used are hard coded with values like the following:</p>

<pre><code>char *aszDevName = ""DEV-01-203"";
char *aszTempoName = ""TEMPO-12345"";
int  iItem = 5;

const char*       server_uri = ""coap://127.0.0.1/hello"";
</code></pre>

<p>The two sample programs can be run in two separate terminal windows, starting the server first. Trying the client three times, the first with a URI of ""hello"", the second with a URI of ""goodbye"", and the third time again with a URI of ""hello"" we see the following output.</p>

<p>From the server:</p>

<pre><code>pi@raspberrypi:~/Documents/raspberrypi/coap $ ./server
 request hello
    option  len 6
         item=5 
    option  len 17
         device=DEV-01-203 
    option  len 17
         tempo=TEMPO-12345 
 request hello
    option  len 6
         item=5 
    option  len 17
         device=DEV-01-203 
    option  len 17
         tempo=TEMPO-12345 
</code></pre>

<p>From the terminal window of the client:</p>

<pre><code>pi@raspberrypi:~/Documents/raspberrypi/coap $ ./client
 Request URI: path 5 hello
         Query: len 6 item=5
         Query: len 17 device=DEV-01-203
         Query: len 17 tempo=TEMPO-12345
Received: {""device"": ""DEV-01-123"", ""item"" : 0 } -&gt; item = 0
pi@raspberrypi:~/Documents/raspberrypi/coap $ ./client goodbye
 Request URI: path 7 goodbye
         Query: len 6 item=5
         Query: len 17 device=DEV-01-203
         Query: len 17 tempo=TEMPO-12345

COAP_RESPONSE_CLASS() unknown.
pi@raspberrypi:~/Documents/raspberrypi/coap $ ./client
 Request URI: path 5 hello
         Query: len 6 item=5
         Query: len 17 device=DEV-01-203
         Query: len 17 tempo=TEMPO-12345
Received: {""device"": ""DEV-01-123"", ""item"" : 1 } -&gt; item = 1
pi@raspberrypi:~/Documents/raspberrypi/coap $ 
</code></pre>
",,56793937,38
48532563,2,48067283,2018-01-31T00:16:42.330,1,,4474230,,2018-01-31T00:16:42.330,,0,,"<p>You could go with</p>

<pre><code>class SenseStateNode
{
    ...
    virtual ObservableValue&amp; getValue(); //or pointer, comes with different tradeoffs
};
</code></pre>

<p>That way, each <code>SenseObservable</code> can return a type derived from <code>ObservableValue</code>. Then, you just have to come up with a usable, generic API for this observable value.</p>

<p>For example, it could be:</p>

<pre><code>class SenseObservable
{
    DateTime* asDateTime(); //returns NULL if not a date
    float* asFloat(); //returns NULL if not a float

};
</code></pre>

<p>The trick is to come with a usable, extensible and generic API for the various observable values. Also, you hve to return them by pointer or reference to not slice them. Then, either the user or the owner has to manage memory.</p>
",,56797493,86
48549454,2,48067283,2018-01-31T18:51:44.913,0,,1475331,,2018-01-31T18:51:44.913,,0,,"<p>It may not be the most elegant solution, but the following is an option: define an <code>EventArgs</code> structure that can hold any kind of data, then do a cast in <code>EventHandlers</code>. Here's a snippet I just wrote (not a native speaker of CPP though):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

using namespace std;

struct EventArgs;

typedef void (*EventHandler)(EventArgs args);
typedef std::vector&lt;EventHandler&gt; BunchOfHandlers;
typedef std::map&lt;string, BunchOfHandlers&gt; HandlersBySubject;

struct EventArgs
{
    void* data;

    EventArgs(void* data)
    {
        this-&gt;data = data;
    }
};

class AppEvents
{
    HandlersBySubject handlersBySubject;

    public:
    AppEvents()
    {
    }

    void defineSubject(string subject)
    {
        handlersBySubject[subject] = BunchOfHandlers();
    }

    void on(string subject, EventHandler handler)
    {
        handlersBySubject[subject].push_back(handler);
    }

    void trigger(string subject, EventArgs args)
    {
        BunchOfHandlers&amp; handlers = handlersBySubject[subject];

        for (const EventHandler&amp; handler : handlers)
        {
            handler(args);
        }
    }
};

struct FooData
{
    int x = 42;
    string str = ""Test"";
};

struct BarData
{
    long y = 123;
    char c = 'x';
};

void foo_handler_a(EventArgs args)
{
    FooData* data = (FooData*)args.data;
    cout &lt;&lt; ""foo_handler_a: "" &lt;&lt; data-&gt;x &lt;&lt; "" "" &lt;&lt; data-&gt;str &lt;&lt; endl;
}

void foo_handler_b(EventArgs args)
{
    FooData* data = (FooData*)args.data;
    cout &lt;&lt; ""foo_handler_b: "" &lt;&lt; data-&gt;x &lt;&lt; "" "" &lt;&lt; data-&gt;str &lt;&lt; endl;
}

void bar_handler_a(EventArgs args)
{
    BarData* data = (BarData*)args.data;
    cout &lt;&lt; ""bar_handler_a: "" &lt;&lt; data-&gt;y &lt;&lt; "" "" &lt;&lt; data-&gt;c &lt;&lt; endl;
}

void bar_handler_b(EventArgs args)
{
    BarData* data = (BarData*)args.data;
    cout &lt;&lt; ""bar_handler_b: "" &lt;&lt; data-&gt;y &lt;&lt; "" "" &lt;&lt; data-&gt;c &lt;&lt; endl;
}

int main()
{
    AppEvents* events = new AppEvents();

    events-&gt;defineSubject(""foo"");
    events-&gt;defineSubject(""bar"");

    events-&gt;on(""foo"", foo_handler_a);
    events-&gt;on(""foo"", foo_handler_a);
    events-&gt;on(""bar"", bar_handler_b);
    events-&gt;on(""bar"", bar_handler_b);

    events-&gt;trigger(""foo"", EventArgs(new FooData()));
    events-&gt;trigger(""bar"", EventArgs(new BarData()));

    return 0;
}
</code></pre>

<p>Inspired by <a href=""http://backbonejs.org/"" rel=""nofollow noreferrer"">Backbone</a> events and the general <em>Event Bus</em> pattern.</p>
",,56871626,174
48549518,2,48067283,2018-01-31T18:56:53.530,2,,1463922,,2018-02-05T15:28:42.987,2018-02-05T15:28:42.987,4,,"<p>If the number of sensor types is more or less stable (and it is - the changes are pretty rare in most cases) - then just be prepared on Observer side to get several kind of notifications:</p>

<pre><code>class Observer 
{
public:
     virtual void notify(SenseNode&amp; node) {
        // implement here general actions - like printing: not interested in this

     } 
     virtual void notify(RealTimeClock&amp; node) {
          notify(static_cast&lt;SenseNode&amp;&gt;(node)); 
         // by default go to more general function
     } 
     // and follow this pattern - for all nodes you want to handle
     // add corresponding notify(T&amp;) function
};
</code></pre>

<p>When it happens you have to add new node type - then just add new virtual function to your base Observer class.</p>

<p>To implement this mechanism on Observable side - use <a href=""https://stackoverflow.com/questions/9818132/difference-betwen-visitor-pattern-double-dispatch"">double dispatch pattern</a>:</p>

<pre><code>class SenseNode {
public:
    virtual void notifyObserver(Observer&amp; observer) {
       observer.notify(*this);
    }
};

class RealTimeClock : public virtual SenseNode {
public:
    virtual void notifyObserver(Observer&amp; observer) {
       observer.notify(*this); 
        // this will select proper Observer::notify(RealTimeClock&amp;)
        // because *this is RealTimeCLock
    }
};


class SenseObservable: public SenseStateNode
{
public:
  virtual void notifyObservers() {
      for (auto&amp; observer : observers) 
         notifyObserver(observer); 
  }
};
</code></pre>

<p>How it works in practice, see <a href=""https://wandbox.org/permlink/84rPgMyBYDlljENx"" rel=""nofollow noreferrer"">live demo</a></p>
",,56901397,144
48557412,2,48067283,2018-02-01T07:26:51.637,1,,1598163,,2018-02-01T07:39:32.130,2018-02-01T07:39:32.130,2,,"<p>Here is my take. If I understand correctly, each observer knows what concrete observable is monitoring; the problem is that the observer only gets a base class pointer to the concrete observable and hence cannot access the full interface. Assuming you can use <code>static_cast</code> as previous answers have assumed, my idea is to create an additional class which will be responsible for casting the base class pointer to the concrete one, thus giving you access to the concrete interface. The code below uses different names than the ones in your post, but it illustrates the idea:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class observable;

class observer {

public:

    virtual void notify(observable&amp;) = 0;
};

// For simplicity, I will give some default implementation for storing the observers
class observable {

    // assumping plain pointers
    // leaving it to you to take of memory
    std::vector&lt;observer*&gt; m_observers;

public:

    observable() = default;

    void notifyObservers() {
        for(auto&amp; obs : m_observers) obs-&gt;notify(*this);
    }

    void registerObserver(observer* x) {
        m_observers.push_back(x);
    }

    void unregisterObserver(observer* x) {
        // give your implementation here
    }

    virtual ~observable() = default;
};

// our first observable with its own interface
class clock_observable
: public observable {

    int m_time;

public:

    clock_observable(int time)
    : m_time(time){}

    void change_time() {
        m_time++;
        notifyObservers(); // notify observes of time change
    }

    int get_time() const {
        return m_time;
    }
};

// another observable
class account_observable
: public observable {

    double m_balance;

public:

    account_observable(double balance)
    : m_balance(balance){}

    void deposit_amount(double x) {
        m_balance += x;
        notifyObservers(); // notify observes of time change
    }

    int get_balance() const {
        return m_balance;
    }
};

// this wrapper will be inherited and allows you to access the interface of the concrete observable
// all concrete observers should inherit from this class
template &lt;class Observable&gt;
class observer_wrapper
: public observer {

    virtual void notify_impl(Observable&amp; x) = 0;

public:

    void notify(observable&amp; x) {
        notify_impl(static_cast&lt;Observable&amp;&gt;(x));
    }
};

// our first clock_observer
class clock_observer1
: public observer_wrapper&lt;clock_observable&gt; {

    void notify_impl(clock_observable&amp; x) override {
        std::cout &lt;&lt; ""clock_observer1 says time is "" &lt;&lt; x.get_time() &lt;&lt; std::endl;
    }
};

// our second clock_observer
class clock_observer2
: public observer_wrapper&lt;clock_observable&gt; {

    void notify_impl(clock_observable&amp; x) override {
        std::cout &lt;&lt; ""clock_observer2 says time is "" &lt;&lt; x.get_time() &lt;&lt; std::endl;
    }
};

// our first account_observer
class account_observer1
: public observer_wrapper&lt;account_observable&gt; {

    void notify_impl(account_observable&amp; x) override {
        std::cout &lt;&lt; ""account_observer1 says balance is "" &lt;&lt; x.get_balance() &lt;&lt; std::endl;
    }
};

// our second account_observer
class account_observer2
: public observer_wrapper&lt;account_observable&gt; {

    void notify_impl(account_observable&amp; x) override {
        std::cout &lt;&lt; ""account_observer2 says balance is "" &lt;&lt; x.get_balance() &lt;&lt; std::endl;
    }
};


int main() {

    auto clock = new clock_observable(100);
    auto account = new account_observable(100.0);

    observer* clock_obs1 = new clock_observer1();
    observer* clock_obs2 = new clock_observer2();

    observer* account_obs1 = new account_observer1();
    observer* account_obs2 = new account_observer2();

    clock-&gt;registerObserver(clock_obs1);
    clock-&gt;registerObserver(clock_obs2);

    account-&gt;registerObserver(account_obs1);
    account-&gt;registerObserver(account_obs2);

    clock-&gt;change_time();
    account-&gt;deposit_amount(10);
}
</code></pre>

<p>As you can see, you do not need to cast every time you create a new observable; the wrapper class does this for you. One issue you may face is registering an observer to the wrong observable; in this case the static_cast would fail but you would get no compilation issues. One way around it is to have the observable expose a string that identifies it and have the observer check that string when it's registering itself. Hope it helps.</p>
",,56929233,1972
48566767,2,48067283,2018-02-01T15:52:29.207,1,,1598163,,2018-02-01T16:01:37.653,2018-02-01T16:01:37.653,1,,"<p>My previous answer does not take into account that the same observer might me registered with different observables. I'll try to give a full solution here. The solution is very flexible and scalable but a bit hard to understand as it involves template meta programming (TMP). I'll start by outlining what the end result will look like and then move into the TMP stuff. Brace yourself, this is a LONG answer. Here we go:</p>

<p>We first have, for the sake of the example, three observables, each with its own unique interface which we will want later to access from the observer.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

class observable;

class observer {

public:

    virtual void notify(observable&amp; x) = 0;
};

// For simplicity, I will give some default implementation for storing the observers
class observable {

    // assumping plain pointers
    // leaving it to you to take of memory
    std::vector&lt;observer*&gt; m_observers;

public:

    observable() = default;

    // string id for identifying the concrete observable at runtime
    virtual std::string id() = 0;

    void notifyObservers() {
        for(auto&amp; obs : m_observers) obs-&gt;notify(*this);
    }

    void registerObserver(observer* x) {
        m_observers.push_back(x);
    }

    void unregisterObserver(observer*) {
        // give your implementation here
    }

    virtual ~observable() = default;
};

// our first observable with its own interface
class clock_observable
: public observable {

    int m_time;

public:

    clock_observable(int time)
    : m_time(time){}

    // we will use this later
    static constexpr auto string_id() {
        return ""clock_observable"";
    }

    std::string id() override {
        return string_id();
    }

    void change_time() {
        m_time++;
        notifyObservers(); // notify observes of time change
    }

    int get_time() const {
        return m_time;
    }
};

// another observable
class account_observable
: public observable {

    double m_balance;

public:

    account_observable(double balance)
    : m_balance(balance){}

    // we will use this later
    static constexpr auto string_id() {
        return ""account_observable"";
    }

    std::string id() override {
        return string_id();
    }

    void deposit_amount(double x) {
        m_balance += x;
        notifyObservers(); // notify observes of time change
    }

    int get_balance() const {
        return m_balance;
    }
};

class temperature_observable
: public observable {

    double m_value;

public:

    temperature_observable(double value)
    : m_value(value){}

    // we will use this later
    static constexpr auto string_id() {
        return ""temperature_observable"";
    }

    std::string id() override {
        return string_id();
    }

    void increase_temperature(double x) {
        m_value += x;
        notifyObservers(); // notify observes of time change
    }

    int get_temperature() const {
        return m_value;
    }
};
</code></pre>

<p>Notice that each observer exposes an id function returning a string which identifies it. Now, let's assume we want to create an observer which monitors the clock and the account. We could have something like this:</p>

<pre><code>class simple_observer_clock_account
: public observer {

    std::unordered_map&lt;std::string, void (simple_observer_clock_account::*) (observable&amp;)&gt; m_map;

    void notify_impl(clock_observable&amp; x) {
        std::cout &lt;&lt; ""observer says time is "" &lt;&lt; x.get_time() &lt;&lt; std::endl;
    }

    void notify_impl(account_observable&amp; x) {
        std::cout &lt;&lt; ""observer says balance is "" &lt;&lt; x.get_balance() &lt;&lt; std::endl;
    }

    // casts the observable into the concrete type and passes it to the notify_impl
    template &lt;class X&gt;
    void dispatcher_function(observable&amp; x) {
        auto&amp; concrete = static_cast&lt;X&amp;&gt;(x);
        notify_impl(concrete);
    }

public:

    simple_observer_clock_account() {
        m_map[clock_observable::string_id()] = &amp;simple_observer_clock_account::dispatcher_function&lt;clock_observable&gt;;
        m_map[account_observable::string_id()] = &amp;simple_observer_clock_account::dispatcher_function&lt;account_observable&gt;;
    }

    void notify(observable&amp; x) override {
        auto f = m_map.at(x.id());
        (this-&gt;*f)(x);
    }
};
</code></pre>

<p>I am using an unoderded_map so that the correct dispatcher_function will be called depending on the id of the observable. Confirm that this works:</p>

<pre><code>int main() {

    auto clock = new clock_observable(100);
    auto account = new account_observable(100.0);

    auto obs1 = new simple_observer_clock_account();

    clock-&gt;registerObserver(obs1);
    account-&gt;registerObserver(obs1);

    clock-&gt;change_time();
    account-&gt;deposit_amount(10);
}
</code></pre>

<p>A nice thing about this implementation is that if you try to register the observer to a temperature_observable you will get a runtime exception (as the m_map will not contain the relevant temperature_observable id).</p>

<p>This works fine but if you try now to adjust this observer so that it can monitor temperature_observables, things get messy. You either have to go edit the simple_observer_clock_account (which goes against the closed for modification, open for extension principle), or create a new observer as follows:</p>

<pre><code>class simple_observer_clock_account_temperature
: public observer {

    std::unordered_map&lt;std::string, void (simple_observer_clock_account_temperature::*) (observable&amp;)&gt; m_map;

    // repetition
    void notify_impl(clock_observable&amp; x) {
        std::cout &lt;&lt; ""observer1 says time is "" &lt;&lt; x.get_time() &lt;&lt; std::endl;
    }

    // repetition
    void notify_impl(account_observable&amp; x) {
        std::cout &lt;&lt; ""observer1 says balance is "" &lt;&lt; x.get_balance() &lt;&lt; std::endl;
    }

    // genuine addition
    void notify_impl(temperature_observable&amp; x) {
        std::cout &lt;&lt; ""observer1 says temperature is "" &lt;&lt; x.get_temperature() &lt;&lt; std::endl;
    }

    // repetition
    template &lt;class X&gt;
    void dispatcher_function(observable&amp; x) {
        auto&amp; concrete = static_cast&lt;X&amp;&gt;(x);
        notify_impl(concrete);
    }

public:

    // lots of repetition only to add an extra observable
    simple_observer_clock_account_temperature() {
        m_map[clock_observable::string_id()] = &amp;simple_observer_clock_account_temperature::dispatcher_function&lt;clock_observable&gt;;
        m_map[account_observable::string_id()] = &amp;simple_observer_clock_account_temperature::dispatcher_function&lt;account_observable&gt;;
        m_map[temperature_observable::string_id()] = &amp;simple_observer_clock_account_temperature::dispatcher_function&lt;temperature_observable&gt;;
    }

    void notify(observable&amp; x) override {
        auto f = m_map.at(x.id());
        (this-&gt;*f)(x);
    }
};
</code></pre>

<p>This works but it is a hell of a lot repetitive for just adding one additional observable. You can also imagine what would happen if you wanted to create any combination (ie account + temperature observable, clock + temp observable, etc). It does not scale at all.</p>

<p>The TMP solution essentially provides a way to do all the above automatically and re-using the overriden implementations as opposed to replicating them again and again. Here is how it works: </p>

<p>We want to build a class hierarchy where the base class will expose a number of virtual <code>notify_impl(T&amp;)</code> method, one for each <code>T</code> concrete observable type that we want to observe. This is achieved as follows:</p>

<pre><code>template &lt;class Observable&gt;
class interface_unit {

public:

    virtual void notify_impl(Observable&amp;) = 0;
};

// combined_interface&lt;T1, T2, T3&gt; would result in a class with the following members:
// notify_impl(T1&amp;)
// notify_impl(T2&amp;)
// notify_impl(T3&amp;)
template &lt;class... Observable&gt;
class combined_interface
: public interface_unit&lt;Observable&gt;...{

    using self_type = combined_interface&lt;Observable...&gt;;
    using dispatcher_type = void (self_type::*)(observable&amp;);
    std::unordered_map&lt;std::string, dispatcher_type&gt; m_map;

public:

    void map_register(std::string s, dispatcher_type dispatcher) {
        m_map[s] = dispatcher;
    }

    auto get_dispatcher(std::string s) {
        return m_map.at(s);
    }

    template &lt;class X&gt;
    void notify_impl(observable&amp; x) {
        interface_unit&lt;X&gt;&amp; unit = *this;
        // transform the observable to the concrete type and pass to the relevant interface_unit.
        unit.notify_impl(static_cast&lt;X&amp;&gt;(x));
    }
};
</code></pre>

<p>The combined_interface class inherits from each interface_unit and also allows us to register functions to the map, similarly to what we did earlier for the simple_observer_clock_account. Now we need to create a recursive hierarchy where at each step of the recursion we override <code>notify_impl(T&amp;)</code> for each <code>T</code> we are interested in.</p>

<pre><code>// forward declaration
// Iface will be combined_interface&lt;T1, T2&gt;
// The purpose of this class is to implement the virtual methods found in the Iface class, ie notify_impl(T1&amp;), notify_impl(T2&amp;)
// Each ImplUnit provides an override for a single notify_impl(T&amp;)
// Root is the base class of the hierarchy; this will be the data (if any) held by the observer
template &lt;class Root, class Iface, template &lt;class, class&gt; class... ImplUnits&gt;
struct hierarchy;

// recursive
template &lt;class Root, class Iface, template &lt;class, class&gt; class ImplUnit, template &lt;class, class&gt; class... ImplUnits&gt;
struct hierarchy&lt;Root, Iface, ImplUnit, ImplUnits...&gt;
: public ImplUnit&lt; hierarchy&lt;Root, Iface, ImplUnits...&gt;, Root &gt; {

    using self_type = hierarchy&lt;Root, Iface, ImplUnit, ImplUnits...&gt;;
    using base_type = ImplUnit&lt; hierarchy&lt;Root, Iface, ImplUnits...&gt;, Root &gt;;

public:

    template &lt;class... Args&gt;
    hierarchy(Args&amp;&amp;... args)
    : base_type{std::forward&lt;Args&gt;(args)...} {

        using observable_type = typename base_type::observable_type;
        Iface::map_register(observable_type::string_id(), &amp;Iface::template notify_impl&lt;observable_type&gt;);
    }
};

// specialise if we have iterated through all ImplUnits
template &lt;class Root, class Iface&gt;
struct hierarchy&lt;Root, Iface&gt;
: public Root
, public observer
, public Iface {

public:

    template &lt;class... Args&gt;
    hierarchy(Args&amp;&amp;... args)
    : Root(std::forward&lt;Args&gt;(args)...)
    , Iface(){}
};
</code></pre>

<p>At each step of the recursion, we register the dispatcher_function to our map. </p>

<p>Finally, we create a class which will be used for our observers:</p>

<pre><code>template &lt;class Root, class Iface, template &lt;class, class&gt; class... ImplUnits&gt;
class observer_base
: public hierarchy&lt;Root, Iface, ImplUnits...&gt; {

public:

    using base_type = hierarchy&lt;Root, Iface, ImplUnits...&gt;;

    void notify(observable&amp; x) override {
        auto f = this-&gt;get_dispatcher(x.id());
        return (this-&gt;*f)(x);
    }

    template &lt;class... Args&gt;
    observer_base(Args&amp;&amp;... args)
    : base_type(std::forward&lt;Args&gt;(args)...) {}
};
</code></pre>

<p>Let's now create some observables. For simplicity, I assume that the observer has not data:</p>

<pre><code>class observer1_data {};

// this is the ImplUnit for notify_impl(clock_observable&amp;)
// all such implementations must inherit from the Super argument and expose the observable_type type member
template &lt;class Super, class ObserverData&gt;
class clock_impl
: public Super {

public:

    using Super::Super;
    using observable_type = clock_observable;

    void notify_impl(clock_observable&amp; x) override {
        std::cout &lt;&lt; ""observer says time is "" &lt;&lt; x.get_time() &lt;&lt; std::endl;
    }
};

template &lt;class Super, class ObserverdData&gt;
class account_impl
: public Super {

public:

    using Super::Super;
    using observable_type = account_observable;

    void notify_impl(account_observable&amp; x) override {
        std::cout &lt;&lt; ""observer says balance is "" &lt;&lt; x.get_balance() &lt;&lt; std::endl;
    }
};

template &lt;class Super, class ObserverdData&gt;
class temperature_impl
: public Super {

public:

    using Super::Super;
    using observable_type = temperature_observable;

    void notify_impl(temperature_observable&amp; x) override {
        std::cout &lt;&lt; ""observer says temperature is "" &lt;&lt; x.get_temperature() &lt;&lt; std::endl;
    }
};
</code></pre>

<p>Now we can easily create any observer we want, no matter what combinations we want to use:</p>

<pre><code>using observer_clock =  observer_base&lt;observer1_data,
combined_interface&lt;clock_observable&gt;,
clock_impl&gt;;

using observer_clock_account =  observer_base&lt;observer1_data,
combined_interface&lt;clock_observable, account_observable&gt;,
clock_impl, account_impl&gt;;

using observer_clock_account_temperature =  observer_base&lt;observer1_data,
combined_interface&lt;clock_observable, account_observable, temperature_observable&gt;,
clock_impl, account_impl, temperature_impl&gt;;

int main() {

    auto clock = new clock_observable(100);
    auto account = new account_observable(100.0);
    auto temp = new temperature_observable(36.6);

    auto obs1 = new observer_clock_account_temperature();

    clock-&gt;registerObserver(obs1);
    account-&gt;registerObserver(obs1);
    temp-&gt;registerObserver(obs1);


    clock-&gt;change_time();
    account-&gt;deposit_amount(10);
    temp-&gt;increase_temperature(2);
}
</code></pre>

<p>I can appreciate there is a lot to digest. Anyway, I hope it is helpful. If you want to understand in detail the TMP ideas above have a look at the <a href=""https://www.amazon.co.uk/Modern-Design-Programming-Patterns-Depth-ebook/dp/B00AU3JUHG/ref=sr_1_2?ie=UTF8&amp;qid=1517500994&amp;sr=8-2&amp;keywords=modern%20c%2B%2B%20design"" rel=""nofollow noreferrer"">Modern C++ design</a> by Alexandrescu. One of the best I've read.</p>

<p>Let me know if anything is not clear and I will edit the answer.</p>
",,56939302,280
48593586,2,48067283,2018-02-03T03:16:05.373,0,,2684539,,2018-02-03T03:16:05.373,,0,,"<p>Difficulty of Observer Pattern in C++ is to handle life-time and un-registration.</p>

<p>You might use the following:</p>

<pre><code>class Observer;

class IObserverNotifier
{
public:
    virtual ~IObserverNotifier() = default;
    virtual void UnRegister(Observer&amp;) = 0;
};

class Observer
{
public:
    explicit Observer() = default;
    virtual ~Observer() {
        for (auto* abstractObserverNotifier : mAbstractObserverNotifiers)
            abstractObserverNotifier-&gt;UnRegister(*this);   
    }

    Observer(const Observer&amp;) = delete;
    Observer(Observer&amp;&amp;) = delete;
    Observer&amp; operator=(const Observer&amp;) = delete;
    Observer&amp; operator=(Observer&amp;&amp;) = delete;

    void AddObserverNotifier(IObserverNotifier&amp; observerNotifier)
    {
        mAbstractObserverNotifiers.insert(&amp;observerNotifier);
    }

    void RemoveObserverNotifier(IObserverNotifier&amp; observerNotifier)
    {
        mAbstractObserverNotifiers.erase(&amp;observerNotifier);
    }

private:
    std::set&lt;IObserverNotifier*&gt; mAbstractObserverNotifiers;
};

template&lt;typename ... Params&gt;
class ObserverNotifier : private IObserverNotifier
{
public:
    ObserverNotifier() = default;
    ~ObserverNotifier() {
        for (const auto&amp; p : mObserverCallbacks) {
            p.first-&gt;RemoveObserverNotifier(*this);
        }
    }

    ObserverNotifier(const ObserverNotifier&amp;) = delete;
    ObserverNotifier(ObserverNotifier&amp;&amp;) = delete;

    ObserverNotifier&amp; operator=(const ObserverNotifier&amp;) = delete;
    ObserverNotifier&amp; operator=(ObserverNotifier&amp;&amp;) = delete;

    void Register(Observer&amp; observer, std::function&lt;void(Params...)&gt; f) {
        mObserverCallbacks.emplace_back(&amp;observer, f);
        observer.AddObserverNotifier(*this);
    }

    void NotifyObservers(Params... args) const
    {
        for (const auto&amp; p : mObserverCallbacks)
        {
            const auto&amp; callback = p.second;

            callback(args...);
        }
    }

    void UnRegister(Observer&amp; observer) override
    {
        mObserverCallbacks.erase(std::remove_if(mObserverCallbacks.begin(),
                                                mObserverCallbacks.end(),
                                                [&amp;](const auto&amp; p) { return p.first == &amp;observer;}),
                                 mObserverCallbacks.end());
    }

private:
    std::vector&lt;std::pair&lt;Observer*, std::function&lt;void(Params...)&gt;&gt;&gt; mObserverCallbacks;
};
</code></pre>

<p>And then usage would be something like:    </p>

<pre><code>class Sensor
{
public:
    void ChangeTime() {
        ++mTime;
        mOnTimeChange.NotifyObservers(mTime);
    }

    void ChangeTemperature(double delta) {
        mTemperature += delta;
        mOnTemperatureChange.NotifyObservers(mTemperature);
    }

    void RegisterTimeChange(Observer&amp; observer, std::function&lt;void(double)&gt; f) { mOnTimeChange.Register(observer, f); }
    void RegisterTemperatureChange(Observer&amp; observer, std::function&lt;void(double)&gt; f) { mOnTemperatureChange.Register(observer, f); }

private:
    ObserverNotifier&lt;int&gt; mOnTimeChange;
    ObserverNotifier&lt;double&gt; mOnTemperatureChange;
    int mTime = 0;
    double mTemperature = 0;
};

class Ice : public Observer {
public:

    void OnTimeChanged(int time) {
        mVolume -= mLose;
        mOnVolumeChange.NotifyObservers(mVolume);
    }

    void OnTemperatureChanged(double t) {
        if (t &lt;= 0) {
            mLose = 0;
        } else if (t &lt; 15) {
            mLose = 5;
        } else {
            mLose = 21;
        }
    }

    void RegisterVolumeChange(Observer&amp; observer, std::function&lt;void(double)&gt; f) { mOnVolumeChange.Register(observer, f); }


private:
    ObserverNotifier&lt;double&gt; mOnVolumeChange;
    double mVolume = 42;
    double mLose = 0;
};

class MyObserver : public Observer {
public:
    static void OnTimeChange(int t) {
        std::cout &lt;&lt; ""observer says time is "" &lt;&lt; t &lt;&lt; std::endl;
    }

    static void OnTemperatureChange(double temperature) {
        std::cout &lt;&lt; ""observer says temperature is "" &lt;&lt; temperature &lt;&lt; std::endl;
    }

    static void OnIceChange(double volume) {
        std::cout &lt;&lt; ""observer says Ice volume is "" &lt;&lt; volume &lt;&lt; std::endl;
    }

};
</code></pre>

<p>And test it:</p>

<pre><code>int main()
{
    Sensor sensor;
    Ice ice;
    MyObserver observer;

    sensor.RegisterTimeChange(observer, &amp;MyObserver::OnTimeChange);
    sensor.RegisterTemperatureChange(observer, &amp;MyObserver::OnTemperatureChange);
    ice.RegisterVolumeChange(observer, &amp;MyObserver::OnIceChange);
    sensor.RegisterTimeChange(ice, [&amp;](int t){ice.OnTimeChanged(t);});
    sensor.RegisterTemperatureChange(ice, [&amp;](double t){ice.OnTemperatureChanged(t);});

    sensor.ChangeTemperature(0);
    sensor.ChangeTime();
    sensor.ChangeTemperature(10.3);
    sensor.ChangeTime();
    sensor.ChangeTime();
    sensor.ChangeTemperature(42.1);
    sensor.ChangeTime();
}
</code></pre>

<p><a href=""https://ideone.com/3OasIr"" rel=""nofollow noreferrer"">Demo</a></p>
",,56961041,94
48115697,2,48113637,2018-01-05T14:33:59.910,1,,8970365,,2018-01-05T14:33:59.910,,0,,"<pre><code>    #include &lt;SoftwareSerial.h&gt;

SoftwareSerial hc(2, 3); // RX | TX

void setup()
{
  pinMode(4, OUTPUT);  
  digitalWrite(4, HIGH);
  Serial.begin(9600);
  Serial.println(""Enter AT commands:"");
  hc.begin(38400);  // HC-05 default speed in AT command more
}

void loop()
{

  // Keep reading from HC-05 and send to Arduino Serial Monitor
  if (hc.available())
    Serial.write(hc.read());

  // Keep reading from Arduino Serial Monitor and send to HC-05
  if (Serial.available())
    hc.write(Serial.read());
}
</code></pre>

<p>Use this code to test the bluetooth module in command mode.there are two modes in hc-05. one is command mode and other is data mode.
Press the button which is on bluetooth module for few sec. then the led Toggles slowly at this point the module is in command mode and in this you can test the AT commands.
Note: Open the serial monitor in 9600 baud rate</p>
",,56962670,52
48120193,2,48113637,2018-01-05T19:36:14.127,2,,9137556,,2018-01-05T19:49:57.960,2018-01-05T19:49:57.960,0,,"<p>I will go step by step-
<strong>The connection</strong>
Arduino Pins           Bluetooth Pins</p>

<p>RX (Pin 0)     ———->      TX</p>

<p>TX (Pin 1)      ———->      RX</p>

<p>5V                ———->      VCC</p>

<p>GND             ———->      GND</p>

<p>Connect a LED negative to GND of arduino and positive to pin 13 with a resistance valued between 220Ω – 1KΩ. And your done with the circuit.
Note : Don’t  Connect RX to RX and TX to TX of Bluetooth to arduinoyou will receive no data , Here TX means Transmit and RX means Receive.</p>

<pre><code>/*
* This program lets you to control a LED on pin 13 of arduino using a bluetooth module
*/
char data = 0;            //Variable for storing received data
void setup()
{
    Serial.begin(9600);   //Sets the baud for serial data transmission                               
    pinMode(13, OUTPUT);  //Sets digital pin 13 as output pin
}
void loop()
{
   if(Serial.available() &gt; 0) // Send data only when you receive data:
   {
      data = Serial.read();   //Read the incoming data &amp; store into data

      Serial.print(data);     //Print Value inside data in Serial monitor

      Serial.print(""\n"");        

      if(data == '1') // Checks whether value of data is equal to 1

         digitalWrite(13, HIGH);   //If value is 1 then LED turns ON

      else if(data == '0')  //  Checks whether value of data is equal to 0

         digitalWrite(13, LOW);    //If value is 0 then LED turns OFF
   }
}
</code></pre>

<p>Link to Connection : <a href=""https://halckemy.s3.amazonaws.com/uploads/image_file/file/153200/hc-05-LED%20blink%20Circuit.png"" rel=""nofollow noreferrer"">https://halckemy.s3.amazonaws.com/uploads/image_file/file/153200/hc-05-LED%20blink%20Circuit.png</a></p>

<p>NOTE : <strong>While uploading the code , remove the TX and RX wires of Bluetooth Module from Arduino, once upload is completed, connect them.</strong></p>
",,56969573,116
48153833,2,48135954,2018-01-08T15:59:01.207,3,,16007,,2018-01-08T15:59:01.207,,3,,"<p>Did you check to see that the fpu coprocessor(s) were enabled?</p>

<p>On the original pi1/pi-zero I use this </p>

<pre><code>;@ enable fpu
mrc p15, 0, r0, c1, c0, 2
orr r0,r0,#0x300000 ;@ single precision
orr r0,r0,#0xC00000 ;@ double precision
mcr p15, 0, r0, c1, c0, 2
mov r0,#0x40000000
fmxr fpexc,r0
</code></pre>

<p>the last couple of lines were probably there to intentionally crash if it didnt work.</p>

<p>you may have an armv7 or an armv8 core in the pi2 unfortunately as there are two variations.  I suspect either way the specific register and instructions may vary from those above for the armv6 based raspberry pi.</p>
",,56981860,120
48137835,2,48137670,2018-01-07T13:58:17.760,2,,2648679,,2018-01-07T13:58:17.760,,0,,"<p>You need to qualify it with <code>Stepper</code> scope -</p>

<pre><code>class Stepper {
    public:
    enum microstepping {
        FULL,
        HALF,
        QUARTER
    };
    int stepsPerStep;

    Stepper(microstepping _microstepping) {
        switch(_microstepping){
        case FULL:
            stepsPerStep = 1;
            break;
        case HALF:
            stepsPerStep = 2;
            break;
        case QUARTER:
            stepsPerStep = 4;
            break;
        }
    }

};

int main() {
    Stepper stepperA(Stepper::FULL);
}
</code></pre>

<p>and use <code>enum class</code> if possible -</p>

<pre><code>class Stepper {
    public:
    enum class microstepping {
        FULL,
        HALF,
        QUARTER
    };
    int stepsPerStep;

    Stepper(microstepping _microstepping) {
        switch(_microstepping){
        case microstepping::FULL:
            stepsPerStep = 1;
            break;
        case microstepping::HALF:
            stepsPerStep = 2;
            break;
        case microstepping::QUARTER:
            stepsPerStep = 4;
            break;
        }
    }

};

int main() {
    Stepper stepperA(Stepper::microstepping::FULL);
}
</code></pre>
",,56989254,60
48171070,2,48169949,2018-01-09T15:05:37.683,0,,8841866,,2018-01-09T15:05:37.683,,0,,"<p>As your server can't know what and how the data is being send you need to specify a common message or some kind of seperator between words if you choose to use strings.</p>

<p>For example you could use a <code>|</code> as a seperator so that you would input the following on your client: <code>testing|123</code></p>

<p>On your server you would now need to search for the <code>|</code> seperator and divide the incoming data so you have a string ""testing"" and a int ""123"".</p>

<p>As another aproach you could define yourself a interface based on numbers with the help of a struct.
For example:</p>

<pre><code>typedef struct
{
    int cmd;
    int subCmd;
} cmdStruct;
</code></pre>

<p>In this you would need to deserialize the incoming bytes and parse them to the command structure and act upon the received command. This would include that you send the command accordingly.</p>
",,57026300,503
48606185,2,48169949,2018-02-04T08:28:59.770,0,,6548780,,2018-02-04T08:28:59.770,,0,,"<p>Trivial excercise as it turns out. The <code>netbuf</code> structure have 'placeholders' for the contents of incoming data and it's lenght;</p>

<p><code>netbuf_data(nb, &amp;data, &amp;len);</code></p>

<p>In my case;</p>

<pre><code>/* INTERPRETE INCOMING DATA HERE?? */

void *data;
u16_t len;
netbuf_data(nb, &amp;data, &amp;len);

char * theData = data;
printf(""%s\n"", theData);
</code></pre>

<p>prints the incoming string on-screen.</p>
",,57033281,143
48194107,2,48193700,2018-01-10T18:42:21.877,3,,16007,,2018-01-10T18:42:21.877,,0,,"<p>since this function is portable did you test it?  did you instrument it to see what was going on?  We are not here for code reviews nor to debug code.</p>

<pre><code>#include &lt;stdio.h&gt;

int bin2dec(const char *bin)
{
  int result=0;
  for(;*bin;bin++)
  {
    if((*bin!='0')&amp;&amp;(*bin!='1'))
      return -1;
    result=result*2+(*bin-'0');
    if(result&lt;=0) return -1;
  }
  return result;
}


int main ( void )
{
    printf(""%d\n"",bin2dec(""1000000100000101111101""));
    return(0);
}
</code></pre>

<p>I get 2113917 as a result.</p>

<p>your code could use a couple of shortcuts but functionally it is sound.  you didnt show us how you called it.</p>

<p>ahh yes, plus one gre_gor's answer that is the problem.</p>

<pre><code>#include &lt;stdio.h&gt;

short bin2dec(const char *bin)
{
  short result=0;
  for(;*bin;bin++)
  {
    if((*bin!='0')&amp;&amp;(*bin!='1'))
      return -1;
    result=result*2+(*bin-'0');
    if(result&lt;=0) return -1;
  }
  return result;
}


int main ( void )
{
    printf(""%d\n"",bin2dec(""1000000100000101111101""));
    return(0);
}
</code></pre>

<p>results in -1 because you have this line in it</p>

<pre><code>    if(result&lt;=0) return -1;
</code></pre>

<p>which limits you to size of int - 1 bits. so 15 for a 16 bit int and 31 for a 32 bit.</p>

<pre><code>#include &lt;stdio.h&gt;

short bin2dec(const char *bin)
{
  short result=0;
  for(;*bin;bin++)
  {
    if((*bin!='0')&amp;&amp;(*bin!='1'))
    {
        printf(""here\n"");
        return -1;
    }
    result=result*2+(*bin-'0');
    printf(""0x%04X\n"",result);
    if(result&lt;=0)
    {
        printf(""there\n"");
        return -1;
    }
  }
  return result;
}


int main ( void )
{
    printf(""%d\n"",bin2dec(""1000000100000101111101""));
    return(0);
}


0x0001
0x0002
0x0004
0x0008
0x0010
0x0020
0x0040
0x0081
0x0102
0x0204
0x0408
0x0810
0x1020
0x2041
0x4082
0xFFFF8105
there
-1
</code></pre>

<p>remember, plus one/accept gre_gor's answer not mine...</p>
",,57047065,216
48194199,2,48193931,2018-01-10T18:48:48.413,0,,1835601,,2018-01-10T18:53:52.383,2018-01-10T18:53:52.383,0,,"<p>If <strong>analogRead</strong> and <strong>delay</strong> works as you expected, it should be somewhat ok. One big issue with the function is that it can't be called with argument 2. This would cause zero-division exception and probably also a black hole. Why not something like:</p>

<pre><code>... 
} // the for-loop closes here. 

if (numberOfMeasurements == 0)
  return 0;
// Must have at least 3 measurements in order to remove 2 of them.
else if (numberOfMeasurements &gt; 2) 
{
  temperatureMeasurementValueSum -= maxMeasuredTempValue;
  temperatureMeasurementValueSum -= minMeasuredTempValue;
  numberOfMeasurements -= 2; // Compensate removing two measurements.
}

// Average is sum divided by measurements.
int temperatureMeasurementAverageValue = temperatureMeasurementValueSum / numberOfMeasurements;

return temperatureMeasurementAverageValue;
</code></pre>
",,57052902,53
48466571,2,48194617,2018-01-26T17:31:39.690,0,,6697622,,2018-01-26T17:31:39.690,,0,,"<p>I have found the answer of my problem. When i tried to debug it, it was found that the clock frequency of I2C protocol is very less and was about <strong>1 Khz</strong> where as it should be in range of <strong>4 Khz</strong> for proper operation and performance efficiency. I tried to consult the datasheet and i found that the issue was with Timing Register of I2C module. In the I2C timing register the last 4bits are dedicated to clock frequency prescaler and my case it was set to full and hence the frequency was divided to maximum extent possible. so in the initialization segment of the I2C module</p>

<pre><code>    void  initializeI2C(){

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

    I2C_InitTypeDef I2C_InitStructure;
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStructure.I2C_OwnAddress1 = 0;
    I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
    I2C_InitStructure.I2C_DigitalFilter = 0x00;
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    I2C_InitStructure.I2C_Timing = 0xF062121F;
    I2C_Init(I2C1, &amp;I2C_InitStructure);

    I2C_Cmd(I2C1, ENABLE);

}
</code></pre>

<p>I changed the value of I2C_Timing register to 0x0062121F and the clock frequency of the I2C was restored and hence I was able to get maximum sampling time of almost <strong>4 ms</strong></p>

<pre><code>I2C_InitStructure.I2C_Timing = 0x0062121F;
</code></pre>
",,57058805,312
48208023,2,48207893,2018-01-11T13:16:15.773,3,,4008060,,2018-01-11T13:16:15.773,,1,,"<p>As you said, <code>int</code> on Arduino are 16 bit.
Inside your function <code>int bin2dec</code>, you return an <code>int</code> and <code>result</code> is a int, so in Arduino your number is truncated to the 16 lsb (100000101010011) that in dec are 16723.
Use <code>long</code> instead</p>

<pre><code>long bin2dec(const char *bin)
{
  long result=0;
  for(;*bin;bin++)
  {
    if((*bin!='0')&amp;&amp;(*bin!='1'))
      return -1;
    result=result*2+(*bin-'0');
    //if(result&lt;=0) return -1;
  }
  return result;
}
</code></pre>
",,57061737,51
48226095,2,48212593,2018-01-12T12:13:54.730,0,,5230735,,2018-01-12T19:26:46.117,2018-01-12T19:26:46.117,1,,"<p>on the arduino you receive the data in a buffer as raw bytes</p>

<p>now you have to parse this, you can do this using <code>memcpy</code> to copy the data in the <code>struct</code></p>

<p>however for doing this the data has to be <strong>aligned</strong> meaning that you have to know exactly where it begins. so you should send a <em>synchronization byte ( start / stop bytes )</em> to be able to fix where the data begins</p>

<p>then you can use the code in <a href=""https://stackoverflow.com/questions/41671618/parsing-buffer-data-into-struct"">parsing buffer data into struct</a> :</p>

<pre><code>struct abc {
    char a;
    char b;
    char c;
    char d[2];
};

int main() {

    char arr[5] = { 'a', 'b', 'c', 'd', 'e' };
    struct abc sa;
    memcpy(&amp;sa, arr, 5);


    return 0;
}
</code></pre>

<blockquote>
  <p>here <code>arr</code> is incoming buffer, and with memcpy all the contents are copied appropriately.</p>
</blockquote>

<p><code>ser.write((const uint8_t *)&amp;mp, sizeof(mp));</code> is correct </p>

<p>you can create an identical structure <code>mp_arduino</code> on the arduino and copy the content of the receive buffer into this structure with </p>

<p><code>memcpy ( &amp;mp_arduino, receive_buffer+n, sizeof(mp_arduino) );</code> where <code>n</code> indicates the position / byte in <code>receive_buffer</code> where your data begins and <code>receive_buffer</code> is defined as <code>uint8_t receive_buffer[]</code> ( or <code>uint8_t* receive_buffer</code> is the same... )</p>

<p>( <a href=""http://www.cplusplus.com/reference/cstring/memcpy/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstring/memcpy/</a> )</p>

<p>this is how a <code>struct</code> is stored in memory : <a href=""https://stackoverflow.com/questions/20198002/how-is-a-struct-stored-in-memory"">How is a struct stored in memory?</a></p>

<p>on both systems a float should be 32 bit <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/float/"" rel=""nofollow noreferrer"">https://www.arduino.cc/reference/en/language/variables/data-types/float/</a></p>
",,57083604,143
48246129,2,48219079,2018-01-14T02:19:46.670,0,,16007,,2018-01-14T14:20:07.313,2018-01-14T14:20:07.313,0,,"<p>Not able to repeat the issue.  Where is your disassembly to show the value fed to printf?</p>

<pre><code>#include &lt;math.h&gt;
double fun1 ( void )
{
    return(log(2));
}
double fun2 ( void )
{
    return(log(2.0));
}


00000000 &lt;fun1&gt;:
   0:   e30309ef    movw    r0, #14831  ; 0x39ef
   4:   e3021e42    movw    r1, #11842  ; 0x2e42
   8:   e34f0efa    movt    r0, #65274  ; 0xfefa
   c:   e3431fe6    movt    r1, #16358  ; 0x3fe6
  10:   e12fff1e    bx  lr

00000014 &lt;fun2&gt;:
  14:   e30309ef    movw    r0, #14831  ; 0x39ef
  18:   e3021e42    movw    r1, #11842  ; 0x2e42
  1c:   e34f0efa    movt    r0, #65274  ; 0xfefa
  20:   e3431fe6    movt    r1, #16358  ; 0x3fe6
  24:   e12fff1e    bx  lr

00000000 &lt;fun1&gt;:
   0:   ed9f 0b01   vldr    d0, [pc, #4]    ; 8 &lt;fun1+0x8&gt;
   4:   4770        bx  lr
   6:   bf00        
   8:   fefa39ef    
   c:   3fe62e42    

00000010 &lt;fun2&gt;:
  10:   ed9f 0b01   vldr    d0, [pc, #4]    ; 18 &lt;fun2+0x8&gt;
  14:   4770        bx  lr
  16:   bf00        
  18:   fefa39ef    
  1c:   3fe62e42    

0000000000000000 &lt;fun1&gt;:
   0:   f2 0f 10 05 00 00 00    movsd  0x0(%rip),%xmm0        # 8 &lt;fun1+0x8&gt;
   7:   00 
   8:   c3                      retq   

0000000000000010 &lt;fun2&gt;:
  10:   f2 0f 10 05 00 00 00    movsd  0x0(%rip),%xmm0        # 18 &lt;fun2+0x8&gt;
  17:   00 
  18:   c3                      retq   


0000000000000000 &lt;.LC0&gt;:
   0:   ef                
   1:   39 fa             
   3:   fe 42 2e          
   6:   e6 3f             
</code></pre>

<p>Now causing an int to float conversion vs building in the float version (2) vs (2.0) as well as adding in (2.0F).  Compile time or runtime can cause differences. </p>

<p>Start by eliminating the printf, divide this problem in half, am I seeing some printf thing or not printf thing.  then is this a compile time thing or is this a runtime thing, is this a hard float thing or a soft float thing.  Is this a c library thing or not a C library thing.  </p>

<p>What if anything have you done so far to debug this?</p>

<p>Eventually someone is going to link the ""whatever programmer should know about floating point"" whether it applies or not...</p>

<p>EDIT</p>

<pre><code>#include &lt;math.h&gt;
double fun ( void )
{
    return(log(2.0));
}

00000000 &lt;fun&gt;:
   0:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   4:   e28db000    add fp, sp, #0
   8:   e30329ef    movw    r2, #14831  ; 0x39ef
   c:   e34f2efa    movt    r2, #65274  ; 0xfefa
  10:   e3023e42    movw    r3, #11842  ; 0x2e42
  14:   e3433fe6    movt    r3, #16358  ; 0x3fe6
  18:   ec432b17    vmov    d7, r2, r3
  1c:   eeb00b47    vmov.f64    d0, d7
  20:   e24bd000    sub sp, fp, #0
  24:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
  28:   e12fff1e    bx  lr

00000000 &lt;fun&gt;:
   0:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   4:   e28db000    add fp, sp, #0
   8:   e30329ef    movw    r2, #14831  ; 0x39ef
   c:   e34f2efa    movt    r2, #65274  ; 0xfefa
  10:   e3023e42    movw    r3, #11842  ; 0x2e42
  14:   e3433fe6    movt    r3, #16358  ; 0x3fe6
  18:   e1a00002    mov r0, r2
  1c:   e1a01003    mov r1, r3
  20:   e24bd000    sub sp, fp, #0
  24:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
  28:   e12fff1e    bx  lr
</code></pre>

<p>well there goes the notion of constant folding explaining why to calls to log() give vastly different results.  (arguably a different version of the toolchain (or different command line arguments) you could just get lucky, so far we dont know what version of the toolchains, build options, etc were used to be able to repeat this).</p>

<p>EDIT 2</p>

<pre><code>#include &lt;math.h&gt;
double fun ( void )
{
    return(log(2));
}

00000000 &lt;fun&gt;:
   0:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   4:   e28db000    add fp, sp, #0
   8:   e30329ef    movw    r2, #14831  ; 0x39ef
   c:   e34f2efa    movt    r2, #65274  ; 0xfefa
  10:   e3023e42    movw    r3, #11842  ; 0x2e42
  14:   e3433fe6    movt    r3, #16358  ; 0x3fe6
  18:   ec432b17    vmov    d7, r2, r3
  1c:   eeb00b47    vmov.f64    d0, d7
  20:   e24bd000    sub sp, fp, #0
  24:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
  28:   e12fff1e    bx  lr




00000000 &lt;fun&gt;:
   0:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   4:   e28db000    add fp, sp, #0
   8:   e30329ef    movw    r2, #14831  ; 0x39ef
   c:   e34f2efa    movt    r2, #65274  ; 0xfefa
  10:   e3023e42    movw    r3, #11842  ; 0x2e42
  14:   e3433fe6    movt    r3, #16358  ; 0x3fe6
  18:   e1a00002    mov r0, r2
  1c:   e1a01003    mov r1, r3
  20:   e24bd000    sub sp, fp, #0
  24:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
  28:   e12fff1e    bx  lr
</code></pre>

<p>around 60 seconds worth of work to contemplate constant folding maybe being a factor, so far it doesnt apply, but there is potential dumb luck there, but the same dumb luck could/would apply to both calls to log</p>

<p>A few seconds of work by the OP to disassemble that program would quickly cover this side topic.</p>
",,57106262,295
48268575,2,48266329,2018-01-15T18:14:54.673,0,,9131550,,2018-01-15T18:21:33.567,2018-01-15T18:21:33.567,0,,"<p>Thank you I have found the solution:</p>

<pre><code>while (client.available()) { 
   delay(3);
   char c = client.read();
   readString += c;
} 
readString.trim();
int i1 = readString.indexOf("","");
int i2 = readString.indexOf(""*"");
int i3 = readString.indexOf(""/"");
String 1= readString.substring(0, i1--);
String 2= readString.substring(i1 + 2, i2); 
String 3= readString.substring(i2 + 3, i3--);
</code></pre>
",,57123169,24
48279010,2,48278201,2018-01-16T10:23:18.293,0,,8874817,,2018-01-16T10:23:18.293,,2,,"<p>That error is weird. The solution i found is even weirder.</p>

<p>It seems the qt3 installations from <a href=""https://download.qt.io/archive/qt/3/"" rel=""nofollow noreferrer"">https://download.qt.io/archive/qt/3/</a> contain different header files than the debian packages from <a href=""https://launchpad.net/ubuntu/precise/armhf"" rel=""nofollow noreferrer"">https://launchpad.net/ubuntu/precise/armhf</a>.</p>

<p>After installing qt3 from the debian packages instead of compiling the source from the qt page my code compiled fine.</p>

<p>I looked at both header files and the line causing the error now contains an additional cast.</p>

<p>From qt.io</p>

<pre><code>class Q_EXPORT QChar {
    ...
#ifdef Q_NO_PACKED_REFERENCE
    ushort &amp;unicode() { return *(&amp;ucs); }
#else
    ushort &amp;unicode() { return ucs; } // Throws error
#endif
    ...
}
</code></pre>

<p>From launchpad</p>

<pre><code>class Q_EXPORT QChar {
    ...
#ifdef Q_NO_PACKED_REFERENCE
    ushort &amp;unicode() { return *((ushort*)&amp;ucs); }
#else
    ushort &amp;unicode() { return ucs; } // Throws error
#endif
    ...
}
</code></pre>

<p>There seem to be even more differences between both sets of headers. If someone else has any problems regarding qt header files it also might be to these differences.</p>
",,57123174,204
48300323,2,48300192,2018-01-17T11:42:27.473,0,,2319299,,2018-01-17T11:47:49.973,2018-01-17T11:47:49.973,0,,"<p>The error seems to be legit, looking at the <a href=""https://github.com/guillaume-rico/SharpIR/blob/master/SharpIR.h#L29"" rel=""nofollow noreferrer"">SharpIR declaration</a>. Maybe the guide that you are following is deprecated and not compatible with your installed library?</p>

<pre><code>class SharpIR
{
  public:

    SharpIR (int irPin, long sensorModel);
    int distance();

  private:

    void sort(int a[], int size);

    int _irPin;
    long _model;
};
</code></pre>

<p>The object initialization requires only a pin number and a long that identifies the sensor model. <strong>BUT</strong> looking at the error in your question it seems that the declarations is implemented with the sensor identification number as first argument and the pin number as second. I think you should really open up the source in your local installation and check it out. You can print it in terminal with:</p>

<pre><code>cat /Users/jeroenturkstra/Documents/Arduino/libraries/SharpIR/src/SharpIR.h
</code></pre>

<p>(I cannot open Dropbox link right now...)</p>
",,57155294,89
48310827,2,48310713,2018-01-17T22:09:16.653,3,,857132,,2018-01-17T22:38:38.517,2018-01-17T22:38:38.517,2,,"<p>Here is the low tech way you could do it in normal C.</p>

<pre><code>char* toString(byte* bytes, int nbytes)
{
    // Has to be static so it doesn't go out of scope at the end of the call.
    // You could dynamically allocate memory based on nbytes.
    // Size of 128 is arbitrary - pick something you know is big enough.
    static char buffer[128];
    char*       bp = buffer;
    *bp = 0;  // means return will be valid even if nbytes is 0.
    for(int i = 0; i &lt; nbytes; i++)
    {
        if (i &gt; 0) {
            *bp = ','; bp++;
        }
        // sprintf can have errors, so probably want to check for a +ve
        // result.
        bp += sprintf(bp, ""%d"", bytes[i])
    }
    return buffer;
} 
</code></pre>
",,57175348,3952
48310846,2,48310713,2018-01-17T22:10:22.070,1,,6451573,,2018-01-17T22:10:22.070,,0,,"<p>an implementation, assuming that <code>timer</code> is an array (else, size would have to be passed as a parameter) with the special handling of the comma.</p>

<p>Basically, print the integer in a temp buffer, then concatenate to the final buffer. Pepper with commas where needed.</p>

<p>The size of the output buffer isn't tested, mind.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;

typedef unsigned char byte;

int main()
{
   byte timer[4] = {1,5,23,120};
   int i;

   char buf[30] = """";
   int first_item = 1;

   for (i=0;i&lt;sizeof(timer)/sizeof(timer[0]);i++)
   {
      char t[10];
      if (!first_item)
      {
         strcat(buf,"","");   
      }
      first_item = 0;

      sprintf(t,""%d"",timer[i]);
      strcat(buf,t);
    }

   printf(buf);

}
</code></pre>
",,57215422,2060
48313876,2,48313690,2018-01-18T04:30:26.450,2,,6407320,,2018-01-18T05:12:13.047,2018-01-18T05:12:13.047,11,,"<p>I think just converting a String <code>response</code> to <code>char *</code> array is enough:</p>

<pre><code>...
String str = response.substring(contentBodyIndex);
int respLen = str.length() + 1
char charArr[respLen];
str.toCharArray(charArr, respLen);

text = ""Smoke was detected in your apartment unit"";
error=GSM.sendSms(charArr ,text);
...
</code></pre>
",,57217187,201
48340177,2,48339770,2018-01-19T11:33:52.627,0,,1469714,,2018-01-19T11:42:23.383,2018-01-19T11:42:23.383,4,,"<p>It's hard to say without a better description of symptoms.
Are the LED still blinking ?</p>

<p>If yes, the socket code seems wrong to me:</p>

<pre><code>void getMovement() {
client.stop();
</code></pre>

<p>You must remember that TCP requires connection tracking, so you can't immediately stop a socket, it has to linger a bit for acknowledging packets sent.</p>

<p>If you look at the implementation:</p>

<pre><code>void EthernetClient::stop() {
  if (_sock == MAX_SOCK_NUM)
    return;
[...]
}
</code></pre>

<p><code>stop()</code> will fail if you have more than <code>MAX_SOCK_NUM</code> (which is 4 on your platform) opened at a time. Can this happen?</p>

<p>In all case, you should avoid as much as possible dynamic allocations, you should have a single function <code>sendMovement(bool detected)</code> that's writing the detected value (<code>getMovement</code> and <code>getNoMovement</code> are the same function, so factorize them). You should re-use the client as much as possible (avoid closing the socket and re-opening it unless you get an error from any socket function). Finally, you might want to set up an interrupt on the digital input pin (with some software debouncing) to avoid polling on it, that would release CPU, and, depending on the configuration, might release more time to process SPI messages. </p>

<p>If the LED are not blinking, try to comment out the SPI related code (<code>EthernetClient</code>'s code) and check if it works (in that case, I would check the HW for errors, some of the socket code is busy looping (<code>socket::send</code> does this) that would never finish and stop your <code>loop</code> function from progressing. In that case, if you use JTAG to pause the CPU, it'll be in the <code>client.connect</code> or <code>client.println</code> method. </p>

<p>If it still does not work (LED not blinking with no SPI code), then the issue is likely hardware, check voltage / temperature / JTAG connect to the board to interrupt the CPU to figure out where it's struck.</p>

<p>BTW, if you are doing HTTP, the request is wrong and should be:</p>

<pre><code>GET url HTTP/1.1\r\n
Host: yourserverhost.com\r\n
Connection: Keep-Alive\r\n
\r\n
</code></pre>

<p>The part <code>HTTP/1.x</code> after the <code>GET url</code> is absolutely required even for HTTP/1.0. Unless you've written your own server (in that case, there's no need to mimick HTTP), it should not work at all, not even once.</p>
",,57294369,66
51003253,2,48353981,2018-06-23T16:53:21.503,2,,6565061,,2018-06-23T16:53:21.503,,0,,"<p>static_cast because for dynamic_cast you have to enable RTTI</p>

<pre><code>bool hwSerial;
Stream * port;
SBUS::SBUS(SoftwareSerial * serial)    {hwserial = false; port = serial;}
SBUS::SBUS(HardwareSerial * serial)          {swserial = true;  port = serial;}

Then you can do something like this: 
SBUS::portBegin(long baudrate) {
if(hwserial) {
  static_cast&lt;HardwareSerial*&gt;(port)-&gt;begin(baudrate);
} else {
  static_cast&lt;SoftwareSerial*&gt;(port)-&gt;begin(baudrate);
}
</code></pre>
",,57300672,37
48367246,2,48366479,2018-01-21T13:22:17.803,2,,5271927,,2018-01-21T13:29:06.523,2018-01-21T13:29:06.523,1,,"<p>It's almost correct, but <code>DHT _dht(uint8_t, uint8_t);</code> is the method prototype (instead of <code>DHT</code> instance). And you have to initialize this instance in the constructors initializer list:</p>

<pre class=""lang-cpp prettyprint-override""><code>class Thermostat {
  public:
    Thermostat();
    void DHTstart();
  private:
    DHT _dht; //// Initialize DHT sensor for normal 16mhz Arduino

};

// class initialization 
Thermostat::Thermostat()
: _dht(7,DHT22)  // construct DHT instance with expected parameters
{ ; }

void Thermostat::DHTstart(){
  _dht.begin();
}
</code></pre>

<p>or shorter version:</p>

<pre class=""lang-cpp prettyprint-override""><code>class Thermostat {
  public:
    Thermostat() : _dht(7, DHT22) {;}
    void DHTstart() { _dht.begin(); }
  private:
    DHT _dht;
};
</code></pre>

<p>In this case (magic values for the DHT class) you can use c++11 features (since Arduino 1.6.5) and specify it directly, so the default constructor can be used:</p>

<pre class=""lang-cpp prettyprint-override""><code>class Thermostat {
  public:
    void DHTstart() { _dht.begin(); }
  private:
    DHT _dht{7, DHT22};
};
</code></pre>
",,57308789,591
48374006,2,48373705,2018-01-22T02:42:28.363,1,,225074,,2018-01-22T02:42:28.363,,1,,"<p>I recommend debugging Arduino programs on the PC as much as possible before trying out on the Arduino.  </p>

<p>That said,</p>

<p>1) Read the text into <code>std::string</code> variable:  </p>

<pre><code>std::string text;
std::getline(cin, text);
</code></pre>

<p>2) Loop through the string, processing each character:</p>

<pre><code>uint8_t checksum = 0;
unsigned int index = 1; // Skip $ character at beginning
const unsigned int length = text.length();
for (; (index &lt; length); ++index)
{
  const char c = text[index];
  if (c == '*')
    break;
  checksum = checksum ^ c;
}
</code></pre>

<p>The remaining part is to output the data and the <code>checksum</code>, which is left as an exercise for the reader.  </p>
",,57313478,102
48380857,2,48380286,2018-01-22T11:45:40.020,-2,,9225659,,2018-01-22T11:45:40.020,,3,,"<pre><code>char * itoa (int value, char *result, int base)
{
// check that the base if valid
if (base &lt; 2 || base &gt; 36) { *result = '\0'; return result; }

char* ptr = result, *ptr1 = result, tmp_char;
int tmp_value;

do {
    tmp_value = value;
    value /= base;
    *ptr++ = ""zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"" [35 + (tmp_value - value * base)];
} while ( value );

// Apply negative sign
if (tmp_value &lt; 0) *ptr++ = '-';
*ptr-- = '\0';
while (ptr1 &lt; ptr) {
    tmp_char = *ptr;
    *ptr--= *ptr1;
    *ptr1++ = tmp_char;
}
return result;
}
</code></pre>

<blockquote>
  <p>Hope this would be helpful</p>
</blockquote>
",,57315755,374
48667574,2,48430316,2018-02-07T15:32:58.853,0,,438117,,2018-02-07T15:32:58.853,,0,,"<p>The <code>pixels</code> buffer isn't large enough to accept all the data.</p>

<pre class=""lang-cpp prettyprint-override""><code>size_t pixels_size = img.columns() // Width
                   * img.rows()    // Height
                   * sizeof(char)  // Size of storage
                   * 3;            // Number of parts per pixel (""RGB"")
char * pixels = new char [pixels_size];
img.write(0,0,img.columns(), img.rows(), ""RGB"", MagickCore::StorageType::CharPixel, pixels);
</code></pre>
",,57337789,58
48475418,2,48474509,2018-01-27T11:40:15.063,1,,8631381,,2018-01-27T11:48:17.297,2018-01-27T11:48:17.297,0,,"<p>Boost is mostly header only, so, unless your platform lacks language level support, boost variant/any/type-erasure/containers should work for you out of the box ...</p>

<p>Anyway, if you still want to write your own type-erasure solution, the idea is to incapsulate the 'generic' behaviour behind an abstract interface, and let the virtual dispatch mechanism invoke the actual, templated implementation, something like:</p>

<pre><code>struct variable
{
  virtual ~variable() = default;
  virtual void print_me() const = 0;
};

template&lt;typename T&gt;
struct variable_of_type:
  variable
{
  T const&amp; var;

  variable_of_type(T const&amp; v)
    :var{v}{}

  virtual void print_me() const override
    { std::cout &lt;&lt; var &lt;&lt; std::endl; }
};

template&lt;typename T&gt;
auto make_var(T const&amp; v) // beware of v's lifetime !
  { return std::make_unique&lt;variable_of_type&lt;T&gt;&gt;(v); }

int main()
{
  auto a = 0;
  auto b = std::string{""hallo""};
  auto vars = std::unordered_map&lt;std::string,std::unique_ptr&lt;variable&gt;&gt;{};

  vars[""a""] = make_var(a);
  vars[""b""] = make_var(b);
  vars[""a""]-&gt;print_me();
  vars[""b""]-&gt;print_me();
}
</code></pre>

<p>more precisely, a truly type-erased solution would hide the unique_ptr layer behind some <em>regular</em> type (eg. see <code>std::any</code>, <code>std::function&lt;void()&gt;</code>, ...), anyway, I hope you got the basic idea ...</p>
",,57349244,91
48503503,2,48503330,2018-01-29T14:25:44.567,5,,4323,,2018-01-29T14:25:44.567,,0,,"<p>One way that old-school programmers save resources even in debug builds is by using enums:</p>

<pre><code>enum {
    _titleHeight = 30,
    _leftOffset = 22,
    _charHeight = 15
};
</code></pre>

<p>Now there is certainly no memory used by these values.  However, an optimizing compiler should arrive at the same end result with your <code>const int</code> values.</p>

<p>The only way to be sure is to try it, and measure.</p>
",,57378093,61
48510912,2,48509755,2018-01-29T22:17:25.093,0,,5162472,,2018-01-29T22:17:25.093,,1,,"<p>calling any function which is not speficied as signal-safe from a signal handler is <em>undefined behaviour</em>. I suppose there is no such guarantee about <code>pinMode</code>.</p>

<p>The proper way would be to set a <code>volatile int</code> flag that you periodically check in your main loop.</p>

<pre><code>volatile int terminating = 0;

void terminate(int sign) {
  signal(SIGINT, SIG_DFL);
  terminating = 1;
}


int main() {

  for (...) {
    if (terminating) {
       // cleanup
       exit(1);
    }

  }

}
</code></pre>

<p>the call to <code>signal</code> inside the handler is to allow force terminating the program with a second ctrl+c in case proper clenup takes too long or is stuck for any reason.</p>
",,57402680,392
48590949,2,48590787,2018-02-02T21:14:20.917,1,,1774667,,2018-02-02T21:14:20.917,,2,,"<p>Your problem is two things.  You have some typos and misunderstanding.  And the C++ standard is somewhat broken in this area.</p>

<p>I'll try to fix both.</p>

<p>First, a helper function called <code>laundry_pods</code>.  It takes raw memory and ""launders"" it into an array of a type of your choice, so long as you pick a pod type:</p>

<pre><code>template&lt;class T, std::size_t N&gt;
T* laundry_pods( void* ptr ) {
  static_assert( std::is_pod&lt;std::remove_cv_t&lt;T&gt;&gt;{} );
  char optimized_away[sizeof(T)*N];
  std::memcpy( optimized_away, ptr , sizeof(T)*N );
  T* r = ::new( ptr ) T[N];
  assert( r == ptr );
  std::memcpy( r, optimized_away, sizeof(T)*N );
  return r;
}
</code></pre>

<p>now simply do</p>

<pre><code>void Manager::byteArrayToDoubleArray(byte ch[]) {
  double* pdouble = laundry_pods&lt;double, 8&gt;(ch);
}
</code></pre>

<p>and <code>pdouble</code> is a pointer to memory of <code>ch</code> interpreted as an array of 8 doubles.  (It is not a copy of it, it interprets those bytes in-place).</p>

<p>While <code>laundry_pods</code> appears to copy the bytes around, both g++ and clang optimize it down into a binary noop.  The seeming copying of bytes around is a way to get around aliasing restrictions and object lifetime rules in the C++ standard.</p>

<p>It relies on arrays of pod not having extra bookkeeping overhead (which C++ implementations are free to do; none do that I know of.  That is what the non-static assert double-checks), but it returns a pointer to a real honest to goodness array of double.  If you want to avoid that assumption, you could instead create each <code>doulbe</code> as a separate object.  However, then they aren't an array, and pointer arithmetic over non-arrays is fraught as far as the standard is concerned.</p>

<p>The use of the term ""launder"" has to do with getting around aliasing and object lifetime requirements.  The function <em>does nothing</em> at runtime, but in the C++ abstract machine it takes the memory and converts it into binary identical memory that is now a bunch of <code>double</code>s.</p>
",,57430102,579
48591197,2,48590787,2018-02-02T21:36:50.010,1,,3807729,,2018-02-02T21:36:50.010,,5,,"<p>The trick of doing this kind of ""conversion"" is to always cast the <code>double*</code> to a <code>char*</code> (or <code>unsigned char</code> or <code>std::byte</code>). Never the other way round.</p>

<p>You should be able to do something like this:</p>

<pre><code>void byteArrayToDoubleArray(byte* in, std::size_t n, double* out)
{
    for(auto out_bytes = (byte*) out; n--;)
        *out_bytes++ = *in++;
}

// ...

byte ch[64];

// .. fill ch with double data somehow

double res[8];

byteArrayToDoubleArray(ch, 64, res);
</code></pre>

<p>Assuming that type <code>byte</code> is an alias of <code>char</code> or <code>unsigned char</code> or <code>std::byte</code>.</p>
",,57434935,355
48602748,2,48590787,2018-02-03T22:31:02.873,0,,6172310,,2018-02-03T22:31:02.873,,2,,"<p>I am not completly sure what you are trying to achieve here because of the code <code>(sizeof(ch) / sizeof(*ch))</code> which does not make sense for an array of undefined size.</p>

<p>If you have a byte-Array (POD data type; something like a <code>typedef char byte;</code>) then this most simple solution would be a reinterpret_cast:</p>

<pre><code>double *result = reinterpret_cast&lt;double*&gt;(ch);
</code></pre>

<p>This allows you to use result[0]..result[7] as long as <code>ch[]</code> is valid and contains at least 64 bytes. Be aware that this construct does not generate code. It tells the compiler that result[0] corresponds to ch[0..7] and so on. An access to result[] will result in an access to ch[].</p>

<p>But you have to know the number of elements in <code>ch[]</code> to calculate the number of valid double elements in <code>result</code>.</p>

<p>If you need a copy (because - for example - the ch[] is a temporary array) you could use </p>

<pre><code>std::vector&lt;double&gt; result(reinterpret_cast&lt;double*&gt;(ch), reinterpret_cast&lt;double*&gt;(ch) + itemsInCh * sizeof(*ch) / sizeof(double));
</code></pre>

<p>So if ch[] is an array with 64 items and a byte is really an 8-bit value, then</p>

<pre><code>std::vector&lt;double&gt; result(reinterpret_cast&lt;double*&gt;(ch), reinterpet_cast&lt;double*&gt;(ch) + 8);
</code></pre>

<p>will provide a <code>std::vector</code> containing 8 double values.</p>

<p>There is another possible method using a union:</p>

<pre><code>union ByteToDouble
{
  byte b[64];
  double d[8];
} byteToDouble;
</code></pre>

<p>the 8 double values will occupie the same memory as the 64 byte values. So you can write the byte values to <code>byteToDouble.b[]</code> and read the resultingdouble values from <code>byteToDouble.d[]</code>.</p>
",,57499440,207
48603804,2,48603627,2018-02-04T01:25:59.617,2,,1480131,,2018-02-04T02:25:48.517,2018-02-04T02:25:48.517,2,,"<p>You get this error because of this:</p>

<pre><code>void setupWifi(char* *aiduser, char* *aidkey, char* *ssid, char* *pass)
{
    ...
    aiduser = strtok(char_array, s);
    aidpass = strtok(NULL, s);
    ssid = strtok(NULL, s);
    pass = strtok(NULL, s);
}
</code></pre>

<p>This variables are double pointers, <code>strtok</code> returns a pointer to <code>char</code>, those
are not compatible types.</p>

<p>Because <code>strtok</code> returns <code>char_array + some_offset</code> and <code>char_array</code> is a local
variable in <code>setupWifi</code>, you need to do a copy for each of them and return the
copy instead. You can do it with <code>strdup</code>.</p>

<pre><code>    *aiduser = strdup(strtok(char_array, s));
    *aidpass = strdup(strtok(NULL, s));
    *ssid = strdup(strtok(NULL, s));
    *pass = strdup(strtok(NULL, s));
</code></pre>

<p>I encourage you to always check the return value of <code>strdup</code>, because it can
return <code>NULL</code>.<sup>1</sup></p>

<p>If your system does not have <code>strdup</code>, then you can write your own:</p>

<pre><code>char *strdup(const char *text)
{
    if(text == NULL)
        return NULL;

    char *copy = calloc(strlen(text) + 1, 1);
    if(copy == NULL)
        return NULL;

    return strcpy(copy, text);
}
</code></pre>

<p>One last thing: </p>

<pre><code>void setupWifi(char* *aiduser, char* *aidkey, char* *ssid, char* *pass);
</code></pre>

<p>It looks really awkward, never seen declaring double pointer this way. Much
easier to read would be</p>

<pre><code>void setupWifi(char **aiduser, char **aidkey, char **ssid, char **pass);
</code></pre>

<hr>

<p><strong>Fotenotes</strong></p>

<p><sup>1</sup>While the syntax is correct, I still consider this bad practice,
because you should always check the return values of functions that return
pointers. If they return <code>NULL</code>, you cannot access the memory. This adds a
little bit of more code, but your program will not die of segfaults and it can
recover from the errors.</p>

<p>I'd also change your function to return 1 on success, 0 otherwise:</p>

<pre><code>int parse_and_set(char *txt, const char *delim, char **var)
{
    if(delim == NULL || var == NULL)
        return 0;

    char *token = strtok(txt, delim);

    if(token == NULL)
        return 0;

    token = strdup(token);

    if(token == NULL)
        return NULL;

    *var = token;
    return 1;
}

void init_parse(char ***vars, size_t len)
{
    for(size_t i = 0; i &lt; len; ++i)
        **(vars + i) = NULL;
}

int cleanup_parse(char ***vars, size_t len, int retval)
{
        for(size_t i = 0; i &lt; len; ++i)
        {
            free(**(vars + i));
            **(vars + i) = NULL;
        }
}

int setupWifi(char **aiduser, char **aidkey, char **ssid, char **pass)
{
    if(aiduser == NULL || aidkey == NULL || ssid == NULL || pass == NULL)
        return 0;

    ...

    /* get the token token */

    char **vars[] = { aiduser, aidkey, ssid, pass };
    size_t len = sizeof vars / sizeof *vars;

    init_parse(vars, len);

    if(parse_and_set(char_array, s, aiduser) == 0)
        return cleanup_parse(vars, len, 0);

    if(parse_and_set(NULL, s, aidpass) == 0)
        return cleanup_parse(vars, len, 0);

    if(parse_and_set(NULL, s, ssid) == 0)
        return cleanup_parse(vars, len, 0);

    if(parse_and_set(NULL, s, pass) == 0)
        return cleanup_parse(vars, len, 0);



    ...

    return 1;
}
</code></pre>
",,57500244,100
48617982,2,48612546,2018-02-05T07:56:13.793,2,,4927891,,2018-02-07T17:58:38.800,2020-06-20T09:12:55.060,5,,"<p>You must not call <code>pthread_exit()</code> in the cleanup functions, because <code>pthread_exit()</code> will also call the cleanup function registered for the thread.</p>
<p>So, in your program, the cleanup function is called recursively and the threads never exit.</p>
<p>About the kill from another terminal, the command <code>kill -9</code> and the pid of the process should always work because SIGKILL can't be ignored nor caught.</p>
<p>And in the signal handler function, you have to use async-signal-safe functions, <code>printf()</code> isn't async-signal-safe.</p>
<p>Another way to wait for a signal in the main thread is to use <code>sigwait()</code> or <code>sigwaitinfo()</code> instead of <code>pause()</code>, like you did for SIGALARM in a thread. So it won't need to register a handler function, but it will need to block the signals to be caught in all threads.</p>
<h3>EDIT: To answer your last comment.</h3>
<p>Exiting the threads <code>task2()</code> and <code>task3()</code> with a flag seems to be complex, because the main thread have to send SIGALRM to <code>task2</code> in order to wake it up, and also signal the condition in order to wake up <code>task3</code>.</p>
<p>I modified your code to try to use a flag, but i may have missed an eventual problem because synchronizing threads may be complex.</p>
<p>In the case of your program, I haven't enough knwoledge to say if it is better to use <code>pthread_cancel()</code> and <code>pthread_testcancel()</code>, or to use flags. However, <code>pthread_cancel()</code> seems to be able to cancel without synchronization problems, threads that are waiting for signals or for a condition.</p>
<p>Using a flag, for <code>task3</code>, there could be the following problem:</p>
<ol>
<li>task3 check the flag that is <code>0</code></li>
<li>main thread set the flag to <code>1</code></li>
<li>main thread signal the condition</li>
<li>task3 begin to wait for the condition</li>
</ol>
<p>In this case, thread <code>task3</code> won't exit, because it wasn't waiting when the condition was signaled. I'am not sure, but this problem is maybe avoided by protecting the flag with the same mutex we use for the condition. Because when the flag will be set and the condition signaled, <code>task3</code> will be waiting for the condition or doing work out of the critical section.</p>
<p>I don't know if there may be a problem for <code>task2</code>, for example if the signal is lost due to an internal problem, but normally, the signal will be pending.</p>
<p>Here is the code of my test. I placed <code>1</code> as argument for the function <code>pthread_cleanup_pop()</code>, to make the threads execute the cleanup functions.</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdint.h&gt;
#include&lt;pthread.h&gt;

#define FALSE 0
volatile sig_atomic_t g_new_pic_flag=FALSE;
pthread_cond_t g_new_pic_cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t g_new_pic_m = PTHREAD_MUTEX_INITIALIZER;
volatile int g_shutdown_task_3 = 0;

volatile int g_shutdown_task_1_2 = 0;
pthread_mutex_t g_shutdown_mutex = PTHREAD_MUTEX_INITIALIZER;
/* FUNCTION DECLARATION */

/*We define thread exit functions so that each pin 
is lowered by the thread in which it is used avoiding
race condition between the signal handler of the main thread
and the other threads*/
void exitingThreadTask1(void* arg);
void exitingThreadTask2(void* arg);
void exitingThreadTask3(void* arg);

void* task1(void *arg); //thread function for the motion sensor
void* task2(void *arg); //thread function for the temperature reading
void* task3(void *arg); //thread function to post data on IOT platforms

/*Signal handler to return from pause*/
void sig_handler(int signo);

void err_exit(char err, char *msg) {
  printf(&quot;\nError: %s\n&quot;,msg);
  exit(1);
}

int main()
{
    int err;
    sigset_t omask, mask;
    pthread_t thread_motionSensor;
    pthread_t thread_tempReading;
    pthread_t thread_platformPost;

    printf(&quot;Created threads IDs\n&quot;);
    /*
    if (wiringPiSetup()&lt;0)
    {
        printf(&quot;WiringPi error\n&quot;);
        return -1;
    }
    */
    printf(&quot;WiringPi is ok\n&quot;);

    if (signal(SIGQUIT, sig_handler)==SIG_ERR)
        printf(&quot;Error on recording SIGQUITHANDLER\n&quot;);
    if (signal(SIGINT, sig_handler)==SIG_ERR)
        printf(&quot;Error on recording SIGQUITHANDLER\n&quot;);
    if (signal(SIGTERM, sig_handler)==SIG_ERR)
        printf(&quot;Error on recording SIGQUITHANDLER\n&quot;);

    /*Create a new mask to block all signals for the following thread*/
    sigfillset(&amp;mask);
    pthread_sigmask(SIG_SETMASK, &amp;mask, &amp;omask);
    printf(&quot;Trying to create threads\n&quot;);
    if ((err = pthread_create (&amp;thread_motionSensor, NULL, task1, NULL))!=0)
    {
    printf(&quot;Thread 1 not created: error %d\n&quot;, err);
        err_exit((const char)err, &quot;pthread_create error&quot;);
    }
    printf(&quot;Thread 1 created. Trying to create Thread 2\n&quot;);
    if((err = pthread_create (&amp;thread_tempReading,   NULL, task2, NULL))!=0)
    {
    printf(&quot;Thread 2 not created: error %d\n&quot;, err);
        err_exit((const char)err, &quot;pthread_create error&quot;);
    }
    printf(&quot;Thread 2 created. Trying to create Thread 3\n&quot;);
    if ((err = pthread_create (&amp;thread_platformPost, NULL, task3, NULL))!=0)
    {
     printf(&quot;Thread 3 not created: error %d %d\n&quot;, err);
         err_exit((const char)err, &quot;pthread_create error&quot;);
    }
    printf(&quot;Thread 3 created\n&quot;);
    /*The main thread must block the SIGALRM but catch SIGINT
    SIGQUIT, SIGTERM, SIgkILL*/
    sigemptyset(&amp;omask);
    sigaddset(&amp;omask, SIGINT);
    sigaddset(&amp;omask, SIGQUIT);
    sigaddset(&amp;omask, SIGKILL);
    sigaddset(&amp;omask, SIGTERM);

    pthread_sigmask(SIG_UNBLOCK, &amp;omask, NULL);
    printf(&quot;Main thread waiting for signal\n&quot;);
    pause();
    printf(&quot;Exit signal received: cancelling threads\n&quot;);
    
    
    pthread_mutex_lock(&amp;g_shutdown_mutex);
    g_shutdown_task_1_2 = 1;
    pthread_mutex_unlock(&amp;g_shutdown_mutex);
    pthread_mutex_lock(&amp;g_new_pic_m);
    g_shutdown_task_3 = 1;
    pthread_cond_signal(&amp;g_new_pic_cond);
    pthread_mutex_unlock(&amp;g_new_pic_m);
    
    pthread_kill(thread_tempReading,SIGALRM);
    

    pthread_join(thread_motionSensor, NULL);
    pthread_join(thread_tempReading,  NULL);
    pthread_join(thread_platformPost, NULL);
    printf(&quot;Exiting from main thread and process\n&quot;);
    exit(0);
}

void* task1(void *arg)
{
    //INITIALIZING
    pthread_cleanup_push(exitingThreadTask1, NULL);
    while(1)
    {
        pthread_mutex_lock(&amp;g_shutdown_mutex);
        if(g_shutdown_task_1_2) {
          pthread_mutex_unlock(&amp;g_shutdown_mutex);
          break;
        }
        pthread_mutex_unlock(&amp;g_shutdown_mutex);
        //do stuff1
        sleep(1);
    }
    pthread_cleanup_pop(1);
    pthread_exit(0);

}

void* task2(void *arg)
{
    static const unsigned char schedule_time = 5;
    int signo, err;
    /*
    We set a local mask with SIGALARM for the function sigwait
    All signals have already been blocked
    */
    sigset_t alarm_mask;
    sigemptyset(&amp;alarm_mask);
    sigaddset(&amp;alarm_mask, SIGALRM);
    alarm(schedule_time);
    pthread_cleanup_push(exitingThreadTask2, NULL);
    while (1)
    {
        pthread_mutex_lock(&amp;g_shutdown_mutex);
        if(g_shutdown_task_1_2) {
          pthread_mutex_unlock(&amp;g_shutdown_mutex);
          break;
        }
        pthread_mutex_unlock(&amp;g_shutdown_mutex);
        
        err = sigwait(&amp;alarm_mask, &amp;signo); //signo == SIGALRM check
        if (err!=0)
            err_exit(err, &quot;sigwait failed\n&quot;);
        
        pthread_mutex_lock(&amp;g_shutdown_mutex);
        if(g_shutdown_task_1_2) {
          pthread_mutex_unlock(&amp;g_shutdown_mutex);
          break;
        }
        pthread_mutex_unlock(&amp;g_shutdown_mutex);
        
        //do stuff
        alarm(schedule_time);
    }
    pthread_cleanup_pop(1);
    pthread_exit(0);
}

void* task3(void *arg)
{
    pthread_cleanup_push(exitingThreadTask3, NULL);
    while(1)
    {
        pthread_mutex_lock(&amp;g_new_pic_m);
        if(g_shutdown_task_3) {
          pthread_mutex_unlock(&amp;g_new_pic_m);
          break;
        }
        while(g_new_pic_flag==FALSE)
        {
            if(g_shutdown_task_3) break;
                        
            pthread_cond_wait(&amp;g_new_pic_cond, &amp;g_new_pic_m);
            
            if(g_shutdown_task_3) break;
        }
        if(g_shutdown_task_3) {
          pthread_mutex_unlock(&amp;g_new_pic_m);
          break;
        }
        pthread_mutex_unlock(&amp;g_new_pic_m);
        //do stuff
    }
    pthread_cleanup_pop(1);
    pthread_exit(0);

}

void exitingThreadTask1(void* arg)
{
    printf(&quot;Thread of task 1 exiting\n&quot;);
    //digitalWrite(OUTPIN, LOW);
    //digitalWrite(INPIN, LOW);
    printf(&quot;Pins lowered\n&quot;);
}

void exitingThreadTask2(void* arg)
{
    printf(&quot;Thread of task 2 exiting\n&quot;);
    //digitalWrite(DHTPIN, LOW);
    printf(&quot;Pin lowered\n&quot;);
}

void exitingThreadTask3(void* arg)
{
    printf(&quot;Thread of task 3 exiting\n&quot;);
}

void sig_handler(int signo)
{
    return;
}
</code></pre>
",,57529214,181
48713169,2,48713066,2018-02-09T19:54:40.570,1,,8866606,,2018-02-09T20:18:49.707,2018-02-09T20:18:49.707,4,,"<p>Your code expects a NULL terminated array, but your array is not. I would try</p>

<pre><code>$ cat dummy.c
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

size_t arraySize(const int *arr) {
  const int *p = arr;
  while (1) {
    if (*p == 0)
      break;
    // commented out for testing the code..
    //Serial.println(*p);
    printf(""%d\n"", *p);
    p++;
  }
  return p - arr;
}

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv)
{
  int stuff[3] = {5, 6, 0};
  printf(""size: %ld\n"", arraySize(stuff));

  return(0);
}
$ gcc -Wall -Wextra -Werror -o dummy dummy.c
$ ./dummy 
5
6
size: 2
</code></pre>

<p>I've commented out the <code>Serial.println()</code> part, because I guess that is some API on your system (Arduino?).</p>
",,57536768,422
48754592,2,48754533,2018-02-12T19:59:46.463,5,,2630032,,2018-02-12T20:06:21.543,2018-02-12T20:06:21.543,5,,"<p>You are returning a pointer to a ""local"" variable, i.e. one which's lifetime ends when the function is finished. Using such a pointer then is UB, which may be, for example, the behaviour you are seeing.</p>

<p>To overcome this, you could pass the array as parameter; then the caller is responsible for memory management.
BTW: you could use format <code>%hhx</code> to read in directly into an 8 bit unsigned data type:</p>

<pre><code>int str2mac(const char* mac, uint8_t* values){
    if( 6 == sscanf( mac, ""%hhx:%hhx:%hhx:%hhx:%hhx:%hhx"",&amp;values[0], &amp;values[1], &amp;values[2],&amp;values[3], &amp;values[4], &amp;values[5] ) ){
        return 1;
    }else{
        return 0;
    }
}

int main() {

    uint8_t values[6] = { 0 };
    int success = str2mac(""AA:00:00:00:00:01"", values);
    if (success) {
        for (int i=0; i&lt;6; i++) {
            printf(""%02X:"",values[i]);
        }
    }
}
</code></pre>
",,,
48756619,2,48754533,2018-02-12T22:31:09.333,0,,8746007,,2018-02-12T22:36:16.160,2018-02-12T22:36:16.160,0,,"<p>Your code doesn't seem to be compatible with <code>wifi_set_macaddr</code> (I looked up API documentation). It expects a <code>uint8</code> pointer to mac address, which means the way you wrote it is not going to work (returning pointer to local variable etc). Here is an example which you should be able to adapt to your purpouse:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

// mock up/print result
bool wifi_set_macaddr(uint8_t index, uint8_t *mac) 
{
    std::cout &lt;&lt; ""index: "" &lt;&lt; (int)index &lt;&lt; "" mac: ""; 
    for (int i = 0; i &lt; 6; ++i)
        std::cout &lt;&lt; std::hex &lt;&lt; (int)mac[i] &lt;&lt; "" "";
    std::cout &lt;&lt; std::endl;

    return true;
}


// test file
void writeTestFile()
{   
    std::ofstream ofs(""mac.txt"");
    if (!(ofs &lt;&lt; ""AA:00:00:00:00:01"" &lt;&lt; std::endl))
    {
        std::cout &lt;&lt; ""File error"" &lt;&lt; std::endl;
    }
    ofs.close();
}

int main() 
{
    writeTestFile();

    uint8_t mac[6];
    int i = 0, x;

    std::ifstream ifs(""mac.txt"");
    for (; i &lt; 6 &amp;&amp; ifs &gt;&gt; std::hex &gt;&gt; x; ++i)
    {
        mac[i] = static_cast&lt;uint8_t&gt;(x);
        ifs.ignore();
    }

    if (i &lt; 6)
    {
        std::cout &lt;&lt; ""File error or invalid MAC address"" &lt;&lt; std::endl;
        return 1;
    }

    wifi_set_macaddr(0x00, mac);

    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/view?id=d387c628e590a467"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/view?id=d387c628e590a467</a> </p>
",,,
49037170,2,48795429,2018-02-28T19:28:21.083,0,,648658,,2018-02-28T19:28:21.083,,0,,"<p>This is for C, but probably works for C++ as well.</p>

<p>The idea is to test one or more of the <code>FLT_*</code> macros against their <code>DBL_*</code> brethren. If they are the same, you are likely on the system that does not distinguish between float32 and float64. What about</p>

<pre><code>#include &lt;float.h&gt; /* or &lt;cfloat&gt;?  */

#if FLT_MANT_DIG == DBL_MANT_DIG
  /* Funny system */
#else
  /* Sane system */
#endif
</code></pre>

<p>Check your float.h contents for a suitable pair.</p>
",,,
48799181,2,48798902,2018-02-15T02:28:05.637,0,,6389133,,2018-02-15T06:59:42.350,2018-02-15T06:59:42.350,2,,"<p><strong>Your client is pointing to localhost</strong>, how would you connect to another device if you are pointing to localhost?</p>

<p>As for <strong>Connection Refused</strong> output, you should check if there is a <strong>Firewall</strong> and also <strong>if you are on the same network</strong>... (if you werent connecting to a listenting port on localhost and you were <strong><em>trying to connect to another device</em></strong>).</p>

<p>But you said that you were connecting to a netcat server on localhost, you should check if netcat is being well used... why dont you post the output of the verbose -v?</p>

<p>When writting a socket <strong>client</strong> on the <strong>C</strong> language (<strong>UNIX</strong> networking implementation), you need the following libs...
<strong>sys/socket.h</strong> for the <strong>socket</strong>, <strong>connect</strong>, <strong>send</strong>, <strong>recv</strong> and <strong>close</strong> functions.</p>

<p>You are using <strong>netinet/in.h</strong> and <strong>arpa/inet.h</strong> for <strong>sockaddr_in</strong>, this structure is used for defining the address for the socket... also, this structure is part of the old UNIX networking implementation.</p>

<p><strong>netdb.h</strong> for the <strong>addrinfo</strong> structure (which you should be using instead of sockaddr_in because its overall easier to use and also, <em>its IP version agnostic</em>, <strong>sockaddr_in</strong> works in IPv4, with this said, using addrinfo is part of the newer implementation you should be using as it works in both IPv4 and IPv6)...</p>

<p>Also... you are using write(), which is good as you are writting into a file descriptor (which in this case is the socket), but the send() function would be more apropiate.</p>

<p>This was my <strong>client</strong> implementation... I used it on both Android as a compiled binary and in my Archlinux x86_64 PC.</p>

<pre><code>#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt; // for memset()

#define PORT ""1234""
#define IP ""127.0.0.1""

int main(void)
{
    int sockfd;
    struct addrinfo hints, *res;

    memset(&amp;hints, 0, sizeof(hints));

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    hints.ai_flags = 0;

    getaddrinfo(IP, PORT, &amp;hints, &amp;res);

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_flags);

    connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

    close(sockfd);

    return 0;
}
</code></pre>

<p>The next one is my <strong>server</strong> implementation.</p>

<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define PORT ""7654""

int main(void){
    int sockfd, newsockfd;
    struct addrinfo hints, *res;

    memset(&amp;hints, 0, sizeof(struct addrinfo));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE;

    getaddrinfo(NULL, PORT, &amp;hints, &amp;res);

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    freeaddrinfo(res);
    listen(sockfd, 1);

    struct sockaddr_in c_addr;
    socklen_t c_addrlen = sizeof(c_addr);

    newsockfd = accept(sockfd, (struct sockaddr *) &amp;c_addr, &amp;c_addrlen);

    close(newsockfd);
    close(sockfd);

    return 0;
}
</code></pre>
",,,
48848599,2,48848435,2018-02-18T04:57:44.067,2,,6059867,,2018-02-18T04:57:44.067,,2,,"<p>There are a number of problems with your code, some of which I have commented here. I encourage you to read up on some literature to familiarize yourself with the C language. As writing C code without much experience can be frustrating especially if you're not even sure with what your doing to begin with. </p>

<pre><code>#include &lt;stdio.h&gt;


/*
    changed this function to take a length argument
    which will probably stop runtime errors with your version
    and added print for a newline at the end so that the lines dont pile up.
    could change that to a \r which would overwrite the line
*/
void printArray(char array[], int length)
{
    for(int i = 0; i &lt; length; i++) // changed to use new length variable
    {
        printf(""%c "", array[i]); // changed this to %c to print characters
    }

    printf(""\n"");
}

/* 
    added this function which shifts the contents of the array.
    take a look at what it does, and try to understand why the temp variable is needed
*/
void scrollLeft(char array[], int length) {
    int temp = array[0];
    for(int i = 0; i &lt; length-1; i++)
    {
        array[i] = array[i+1];
    }
    array[length-1] = temp;
}

int main(void)
{
    /* 
        this array should be of type char because you're assigning it with character values
        changed this so that the array is initialized with the proper size
        and added the length variable to store how long the a is
    */
    char a [16] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0'};
    int length = 16;

    printArray(a, length);

    int i = 0;

    /*  changed from i = 0 to proper i == 0
        i = 0 assigns i to be equal to zero
        i == 0 checks to see if i is equal to zero
    */
    while (i == 0) 
    {
        printArray(a, length);
        scrollLeft(a, length);
    }
 }
</code></pre>

<p>And there are some ways to get this code to run faster if you want to create some of your own optimizations, as the scrollLeft code that I wrote doesn't take into account that the array only has one <code>'0'</code> and all other elements are <code>' '</code>.</p>
",,,
48905224,2,48905062,2018-02-21T11:52:14.383,1,,7592072,,2018-02-21T11:52:14.383,,0,,"<p>You cannot convert int implicitly to anonymous enum. 
Possible solution is to use static cast from int to, but you should declare yout enum as not anonymous.</p>

<pre><code>enum EnumName {S, // SECURITE
N, // NUIT
J1_1, J1_2, J1_3,  // Luminosité 1
J2_1, J2_2, J2_3,  // Luminosité 2
J3_1, J3_2, J3_3, // Luminosité 3
} CYCLE_ARROSAGE; // SECURITE

...

CYCLE_ARROSAGE = static_cast&lt; EnumName &gt;( NouveauCycle );
</code></pre>
",,,
48933155,2,48931886,2018-02-22T16:59:05.520,0,,5230735,,2018-02-22T16:59:05.520,,0,,"<p>in arduino language there is <code>toFloat()</code> ( <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tofloat/"" rel=""nofollow noreferrer"">https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tofloat/</a> ) </p>

<p>else <code>atof()</code> should work as it in the <em>avr-gcc</em> <code>stdlib.h</code> library for 8-bit AVR CPU like on arduino</p>

<p>( <a href=""https://www.nongnu.org/avr-libc/user-manual/group__avr__stdlib.html"" rel=""nofollow noreferrer"">https://www.nongnu.org/avr-libc/user-manual/group__avr__stdlib.html</a> ) :</p>

<pre><code>#include &lt;stdlib.h&gt;

char s[] = ""11.248""
double f = 0;

f=atof(s);
</code></pre>

<p>also see <strong><a href=""http://www.ethernut.de/nutwiki/index.php/Converting_Strings_to_Floating_Point_Values"" rel=""nofollow noreferrer"">http://www.ethernut.de/nutwiki/index.php/Converting_Strings_to_Floating_Point_Values</a></strong> ( ethernut is for 8 bit CPUs )</p>

<p>possibly check if the content of <code>Data</code> is really a float ...</p>

<p>another <code>atof</code> example in avr-gcc / arduino : <a href=""https://forum.arduino.cc/index.php?topic=98595.0"" rel=""nofollow noreferrer"">https://forum.arduino.cc/index.php?topic=98595.0</a> </p>
",,,
48936742,2,48936208,2018-02-22T20:37:16.737,1,,6205379,,2018-02-23T15:59:46.173,2018-02-23T15:59:46.173,6,,"<p>You can write a small parser for your string, like:</p>

<pre><code>#include&lt;cstdlib&gt;
#include&lt;cctype&gt;
#include&lt;iterator&gt;
#include&lt;vector&gt;

std::vector&lt;int&gt; values(1);
char separator = ',';

// read every char from the stream and store it in i
for (int i = Serial.read(); i &gt;= 0; i = Serial.read())
{
    // check if i is a digit (and if so, append it to the previous digit)
    if (std::isdigit(i))
    {
        values.back() = values.back() * 10 + std::atoi(i);
    }
    // check if i is a letter [A-Z][a-z]
    else if (std::isalpha(i))
    {
        values.back() = i;
        i = separator;
    }

    // check if i is the separator 
    if (i == separator)
    {
        values.push_back(0);
    }    
}

A = values[0];
B = values[1]
// ...
</code></pre>
",,,
48953269,2,48936208,2018-02-23T17:28:33.847,1,,794749,,2018-02-23T17:28:33.847,,0,,"<p>Assuming the strings are sent as lines (with a new line character <code>\n</code> at the end).</p>

<pre class=""lang-cpp prettyprint-override""><code>typedef struct {
    int A = 0;
    int B = 0;
    int C = 0;
    int D = 0;
    int E = 0;
    int F = 0;
    char G = 0;
    int H = 0;
} Line;

typedef void (*LineHandler)(Line data);

bool line_parser(char c, LineHandler line_handler) {
    static Line data;
    static int value = 0;
    static byte state = 0;
    bool complete = false;

    // ignore the carriage return character
    if (c == '\r') return complete;

    if (state &lt; 8) {
        if (isdigit(c)) {
            value = value*10 + c-'0';  // add the digit
        }
        else if (c == ',' || c == '\n') {
            // if a comma or end of line is found, save the value
            switch (state) {
                case 0: data.A = value; break;
                case 1: data.B = value; break;
                case 2: data.C = value; break;
                case 3: data.D = value; break;
                case 4: data.E = value; break;
                // the F and G are set when the letter is found
                case 7: data.H = value; break;
            }
            // advance the parsing state and reset the value
            state++;
            value = 0;
        }
        else if (state == 5 &amp;&amp; isalpha(c)) { // if parsing the 6th number and a letter is found
            data.F = value; // save the 6th number
            data.G = c; // save the letter
            state += 2; // advance to parsing the 8th value
            value = 0; // reset the value
        }
        else
            state = 10; // unexpected character; stop the parser
    }
    if (c == '\n') {
        if (state == 8) {
            //got complete line
            line_handler(data);
            complete = true;
        }
        else {
            // parsing failed
        }
        // reset the parser
        value = 0;
        state = 0;
    }
    return complete;
}

void handle_line(Line data) {
    // just print out the data
    Serial.println(""Line:"");
    Serial.print(""A = "");
    Serial.println(data.A);
    Serial.print(""B = "");
    Serial.println(data.B);
    Serial.print(""C = "");
    Serial.println(data.C);
    Serial.print(""D = "");
    Serial.println(data.D);
    Serial.print(""E = "");
    Serial.println(data.E);
    Serial.print(""F = "");
    Serial.println(data.F);
    Serial.print(""G = "");
    Serial.println(data.G);
    Serial.print(""H = "");
    Serial.println(data.H);
    Serial.println();
}

void setup() {
    Serial.begin(115200);
}

void loop() {
    if (Serial.available()) {
        line_parser(Serial.read(), handle_line);
    }
}
</code></pre>

<p>This parser is non-blocking and is feed character by character and after it receives the whole line, it calls a function that should handle the parsed data.</p>

<p>Sending it:</p>

<pre class=""lang-none prettyprint-override""><code>54,125,11045,11,78,4H45
invalid line
11,22,33,44,55,66K88
30,30,20,10,50,50M20
</code></pre>

<p>should send back:</p>

<pre class=""lang-none prettyprint-override""><code>Line:
A = 54
B = 125
C = 11045
D = 11
E = 78
F = 4
G = H
H = 45

Line:
A = 11
B = 22
C = 33
D = 44
E = 55
F = 66
G = K
H = 88

Line:
A = 30
B = 30
C = 20
D = 10
E = 50
F = 50
G = M
H = 20
</code></pre>
",,,
48951197,2,48942615,2018-02-23T15:28:53.537,0,,3882323,,2018-02-23T15:28:53.537,,0,,"<p>Thanks to Zebrafish for pointing me to <a href=""https://stackoverflow.com/questions/41378849/linking-error-using-arduino-library-with-cs-stringstream"">this question about sstream with Arduino</a>. Apparently it is difficult to include a lot of std c++ in Arduino projects, including stringstream.</p>

<p>This led me to find <a href=""https://arduino.stackexchange.com/questions/1013/how-do-i-split-an-incoming-string"">this answer, which recommends staying away from Arduino String</a>. I used it to revise my function to this:</p>

<pre><code>#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;

void SimpleKeyPairs::deserializeKeyPairs(std::string input, std::map&lt;std::string, std::string&gt;* output)
{
  char* inputChars = const_cast&lt;char*&gt;(input.c_str());

  char* key;
  char* value;

  key = strtok(inputChars, "":"");
  value = strtok(NULL, "";"");

  while(key != NULL &amp;&amp; value != NULL) {
    output-&gt;insert(std::make_pair(key, value));

    key = strtok(NULL, "":"");
    value = strtok(NULL, "";"");
  }
}
</code></pre>
",,,
48961421,2,48961265,2018-02-24T09:40:55.987,4,,5577765,,2018-02-25T07:05:11.710,2018-02-25T07:05:11.710,4,,"<p>You have to setup a rotation matrix. Depending on what you want, either transform the vertex coordinates or the texture coordinates by the rotation matrix, in the vertex shader.</p>

<p>Create a vertex shader like this:</p>

<pre><code>attribute vec3 texPosition;
....

uniform mat4 u_rotateMat44;

void main()
{
    ....

    vec4 rotPos = u_rotateMat44 * vec4(texPosition, 1.0);
    gl_Position = rotPos;
}
</code></pre>

<p>or this:</p>

<pre><code>attribute vec2 texCoord;
....

varying vec2 outTexCoord:

uniform mat4 u_rotateMat44;

void main()
{
    ....

    vec4 rotCoord = u_rotateMat44 * vec4(texCoord, 0.0, 1.0);
    outTexCoord   = rotCoord.st;

    ....
}
</code></pre>

<p>The rotation matrix can be setup like this:</p>

<pre><code>#include &lt;math.h&gt; // sin, cos
</code></pre>

<p></p>

<pre><code>float ang_rad ....; // angle in radians

float rotMat[16] =
{
     cos(ang_rad), sin(ang_rad),  0.0f, 0.0f,
    -sin(ang_rad), cos(ang_rad ), 0.0f, 0.0f,
     0.0f,         0.0f,          1.0f, 0.0f,
     0.0f,         0.0f,          0.0f, 1.0f
};
</code></pre>

<p>Set the uniform by <a href=""https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glUniform.xml"" rel=""nofollow noreferrer""><code>glUniformMatrix4fv</code></a>:</p>

<pre><code>GLuint program = ....; // the shader program

GLint rotMatLoc = glGetUniformLocation( program, ""u_rotateMat44"" );

glUniformMatrix4fv( rotMatLoc, 1, GL_FALSE, rotMat );
</code></pre>
",,,
48972475,2,48970911,2018-02-25T10:30:03.667,3,,637874,,2018-02-25T10:48:40.627,2018-02-25T10:48:40.627,1,,"<p>You are not using fixed size types between architectures. For example on a 32-bit platform <code>long</code> is 32 bit, but on 64-bit <code>long</code> is 64 bit, which is why on a 64-bit platform it can not read the headers correctly. The solution is to use the defines in <code>stdint</code>.</p>

<pre><code>#include &lt;stdint.h&gt;

#pragma pack(push, 1)
typedef struct Pix
{
    uint8_t R, G, B;
    int32_t BW;
}
Pix;

typedef struct BitMap
{
    int16_t Signature;                        
    int32_t Reserved1;             
    int32_t Reserved2;             
    int32_t DataOffSet;            

    int32_t Size;                  
    int32_t Width;             
    int32_t Height;                
    int16_t Planes;               
    int16_t BitsPerPixel;         
    int32_t Compression;           
    int32_t SizeImage;                 
    int32_t XPixelsPreMeter;       
    int32_t YPixelsPreMeter;       
    int32_t ColorsUsed;            
    int32_t ColorsImportant;       
    struct Pix *pixels;         
}
BitMap;
#pragma pack(pop)
</code></pre>
",,,
48974794,2,48974656,2018-02-25T14:52:05.013,3,,882003,,2018-02-25T14:59:33.793,2018-02-25T14:59:33.793,5,,"<p>The problem is nothing to do with types (which are correct). The issue is that you are using a data member in <code>Derived</code> in the constructor for <code>DisplayDriver</code>. When the <code>DisplayDriver</code> constructor is called the <code>Derived</code> object has <em>not been constructed yet</em>, so the values are garbage.</p>

<p>Simple solution is to make <code>_colorTable</code> static.</p>

<pre><code>class Derived : public DisplayDriver
{
public:
    Derived(const int xResolution, const int yResolution);

private:
    static const unsigned int _colorTable[18][2];
};
</code></pre>

<p>and</p>

<pre><code>const unsigned int Derived::_colorTable[18][2] =
{
    {4, 2},
    {9, 31},
    ...
};
</code></pre>
",,,
48979379,2,48974656,2018-02-25T22:58:08.140,2,,9408921,,2018-02-25T23:12:46.503,2018-02-25T23:12:46.503,3,,"<p>As others have said, your problem is that your using <code>_colorTable</code> before it has been initialised. If you don't mind all instances <code>Derived</code> sharing a common <code>_colorTable</code> (which is what <code>static</code> in the context of a class declaration means) then making <code>_colorTable</code> static works. </p>

<p>If you however want each instance to have its own <code>_colorTable</code> then one way to get around your problem is to use the <a href=""https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Base-from-Member"" rel=""nofollow noreferrer"">base-from-member idiom</a>. This idiom utilize the initialisation order of base classes. When a class has multiple base classes...:</p>

<pre><code>class A {  };
class B {  };
class C {  };

class D : public A, public C, public virtual B {  }; // note virtual
</code></pre>

<p>...C++ says that the initialisation order is:</p>

<ol>
<li><p>All virtual base classes in the order of declaration (left to
right).</p></li>
<li><p>All non-virtual base classes in the order of declaration (left to
right).</p></li>
</ol>

<p>Therefore if you if create an instance of <code>D</code> then <code>D</code>'s base classes gets initialised in the following order: first <code>B</code>, then <code>A</code> and then <code>C</code>. If your just starting out (and perhaps more so if you're using C++ on microcontrollers) then you don't have have to worry about virtual base classes. </p>

<p>So in your case, using your knowledge of base class initialisation order, you can use the base-from-member idiom. Create a new class and move <code>_colorTable</code> from <code>Derived</code> to your new class:</p>

<pre><code>// Derived.hpp

// namespace detail {

class DerivedDMembers 
{
protected:
  const unsigned int _colorTable[18][2] =
  {
    {4, 2},
    {9, 31},
    ... // 16 other lines.
  };
};

// } // namespace detail

// if you feel that DerivedDMembers is polluting your namespace
// you can put it in a namespace called ""detail"". there's nothing
// special about 'detail' other than that ""internal details"" by
// convention are put in it.    
</code></pre>

<p>Have <code>Derived</code> derive from your new class (<code>DerivedDMembers</code>):</p>

<pre><code>// Derived.hpp

// note how DerivedDMembers is listed before DisplayDriver, which
// is crucial
class Derived : protected DerivedDMembers, public DisplayDriver
{
public:
  Derived(const int xResolution, const int yResolution);

  // note, _colorTable is now in DerivedDMembers  
};
</code></pre>

<p>Now you can safely pass <code>_colorTable</code> to your base class <code>DisplayDriver</code>:</p>

<pre><code>// Derived.cpp

Derived(const int xResolution, const int yResolution) : DisplayDriver(xResolution, yResolution, _colorTable) {  }
</code></pre>

<p>You don't have to explicitly call <code>DerivedDMembers</code>'s default constructor in <code>Derived</code>'s constructors initialiser list because if a base class constructor call is omitted its default constructor is implicitly called. </p>

<p>Now each instance of <code>Derived</code> has its own <code>_colorTable</code> and you can use <code>_colorTable</code> to initialise <code>DisplayDriver</code>.  </p>
",,,
49229274,2,49104206,2018-03-12T06:29:03.660,0,,6721865,,2018-03-12T06:42:07.243,2018-03-12T06:42:07.243,1,,"<p>But it is a blocking call. Your function is stuck for 5 seconds, and depending on how delay() is implemented it might make your whole app unresponsive to any other calls and events.</p>

<p>Pseudocode:</p>

<pre><code>if (obstacle is near) {
  if (last_operation == ""wait"") {
    last_operation = ""Action"";
    takeAction();
  } else {
    last_operation = ""wait"";
    wait();
  }
} else { // no obstacle
  last_operation = ""go"";
  go();
}
</code></pre>

<p>Is that what you're looking after?</p>
",,,
49134749,2,49119236,2018-03-06T15:43:16.273,0,,2858170,,2018-03-06T15:43:16.273,,2,,"<p>I guess the simple option is:
You declare a global pointer and use the new operator to create your instance on the heap. Many people discourage this though unless absolutely necessary.
You'll find plenty of discussions about the use of new in Arduino if you care why.</p>

<pre><code>SomeClass * pMyInstance; 

void setup(void) {
    pMyInstance = new SomeClass(1);
}
</code></pre>

<p>Another option would move that particular initialization from setup into loop an more or less treat loop as your global environment.</p>

<pre><code>void setup(void) {
}
void loop(void){
   SomeClass myInstance(1);
   while(1){
   // do the loopy stuff in here
   }

}
</code></pre>

<p>I'm sure there are many better solutions. My C/C++/Arduino is pretty rusty ;)</p>
",,,
50102331,2,49119236,2018-04-30T14:12:56.180,1,,9721435,,2018-05-04T18:26:50.567,2018-05-04T18:26:50.567,1,,"<p>You can Setup a oneWire instance with a ""dummy"" pin value (ex: Pin=13).</p>

<p>At runtime, in setup(), change it to a different value.</p>

<pre><code>OneWire oneWire(13); // Pin=13 (we'll not actually use pin13)
DallasTemperature sensors(&amp;oneWire);

void setup(void)  {
  Serial.begin(115200);

  // Runtime: 
  //  Change PIN value associated with OneWire 
  //  bus - From now on Pin 4 will be used
  oneWire.begin(4); 

  sensors.begin();
}
</code></pre>

<p>EDITED to clarify comment from Brahma Fear:</p>

<blockquote>
  <p>Are we sure that the library does not modify the state of the GPIO ""dummy"" pin? Ie, could the pin referenced be in use by something  else? – Brahma Fear </p>
</blockquote>

<p>The Constructor for the OneWire class is
    OneWire(uint8_t pin) { begin(pin); }
so a call to ""OneWire::begin(pin)"" is made and into begin(pin) there is a call to <BR>
    <code>pinMode(pin, INPUT);</code></p>

<p>Note:
   Arduino pins are by default configured as inputs (high-impedance state)</p>

<p>So, you can set, as ""dummy"", a pin of the board that your app is not going 
to use. If, for example, you have nothing connected to pin D13 (BUILTIN LED on many Arduino board):</p>

<pre><code>OneWire oneWire(D13);
</code></pre>

<p>Or set a PIN you actually use but, in setup(), set it to whatever is needed:</p>

<pre><code>OneWire oneWire(D5);
...
setup(){
    pinMode(D5, OUTPUT);
}
</code></pre>

<p>Please Note:<BR>
Depending on the BOARD/Architecture you use (Arduino-AVR, ESP32, ...) some pins may be used for board-specific hardware. For example, PIN 0,1 are used in many Arduino boards as Serial:(RX),(TX)<BR>
In sample code i provided in the first place i used PIN=1<BR>
This is the same than SET (TX) as an INPUT. Not a clever thing to do.
BUT in setup() there is a call to ""Serial.begin(115200);"" so PIN 1 is reset to whatever Serial.begin() needs (probably OUTPUT...).</p>

<blockquote>
  <p>Another option and is to ADD ONE LINE in the OneWire lib...</p>
</blockquote>

<p>The code proposed above is a workaround needed 'cause the OneWire Class Constructor have PIN as a parameter.
This means the code below <strong>does not compiles</strong>:</p>

<pre><code>OneWire oneWire(); // NO PIN 
void setup(void)
    {
    Serial.begin(115200);
    oneWire.begin(2); 
    .....
    }
</code></pre>

<p>You find the Constructor definition into OneWire lib'e header file (...Arduino/libraries/OneWire/OneWire.h - line 72 in the version i have)</p>

<p>If you add there a line where you <strong>Overload the constructor</strong> to accept no parameters:</p>

<p>OneWire() { ; }</p>

<p>than the code above does compiles and everything works ok <strong>with no need for dummy pin</strong>.
If you are going this way, i would strongly recomend to NOT CHANGE the OneWire lib installed in your development computer.
Copy it in a subdir of your project, modify it there and include the modified 
version in the project.
Or fork the gitHub repo and edit the code.</p>
",,,
49121546,2,49121119,2018-03-06T00:19:47.247,1,,2584754,,2018-03-06T00:33:47.017,2018-03-06T00:33:47.017,2,,"<p>The algorithm would look like this. This example only print the tokens, but you should be able to modify it to handle the keys, the values and the exception cases.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;

#define MESSAGE_TOKENS (""=&amp;?"")

int main()
{
    char *msg = ""?A=data1&amp;B=data2"";
    char *msg_dup = strdup(msg);
    char *tok = strtok(msg_dup, MESSAGE_TOKENS);

    while (tok != NULL)
    {
        char delim = msg[tok - msg_dup - 1];

        switch(delim)
        {
            case '?':
            case '&amp;':
                printf(""key=%s\n"", tok);
                break;
            case '=':
                printf(""val=%s\n"", tok);
                break;
            default:
                break;
        }

        tok = strtok(NULL, MESSAGE_TOKENS);
    }

    free(msg_dup);
}
</code></pre>

<p>As for data types, you can use methods of the <code>ctype.h</code> header file (<a href=""https://www.unix.com/man-page/all/3/ctype/"" rel=""nofollow noreferrer"">link</a>). For example, you can verify if a string is a number by iterating through all characters of the string and verifying that all chars are numbers (the <code>isnumber()</code> method).</p>
",,,
49134452,2,49134190,2018-03-06T15:29:32.097,2,,6451573,,2018-03-06T15:29:32.097,,1,,"<p>First, your comparison should use <code>strcmp</code> else it'll be always wrong.</p>

<p>Then, I would read the string 2-char by 2-char and convert each ""digit"" to its value (0-15), then compose the result with shifting</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// helper function to convert a char 0-9 or a-f to its decimal value (0-16)
// if something else is passed returns 0...
int a2v(char c)
{
    if ((c&gt;='0')&amp;&amp;(c&lt;='9'))
    {
        return c-'0';
    }
    if ((c&gt;='a')&amp;&amp;(c&lt;='f'))
    {
        return c-'a'+10;
    }
    else return 0;
}

int main() {
    const char* goal = ""\xaa\xbb\xcc\xdd\xee\xff"";
    printf(""Goal: %s\n"", goal);

    const char* input = ""aabbccddeeff"";
    int i;

    char output[strlen(input)/2 + 1];
    char *ptr = output;

    for (i=0;i&lt;strlen(input);i+=2)
    {

       *ptr++ = (a2v(input[i])&lt;&lt;4) + a2v(input[i]);
    }
    *ptr = '\0';
    printf(""Goal: %s\n"", output);

    if (strcmp(output,goal)==0) {
        printf(""Did work! Yay!"");
    } else {
        printf(""Did not work, keep trying"");
    }
}
</code></pre>
",,,
49191686,2,49191443,2018-03-09T10:29:13.380,4,,878532,,2018-03-09T13:26:52.577,2018-03-09T13:26:52.577,5,,"<p>Your problem starts at this point:</p>

<pre><code>startupTimer.setTimeout(5000, endInit);
</code></pre>

<p>It looks like, that your method needs to get a function which can be called without any object, so that you have to use a static function.</p>

<p>But a static function, defined in a class, can not access data members from an object! Simply there is no object involved while calling a static function from a class.</p>

<p>If you do not want to make your variable also static, which will end up in making everything static, and has the effect that you can not longer use multiple instances of your class you need a way to bind a object and a method to your callback.</p>

<p>I have no idea how your <code>startupTimer.setTimeout</code> is defined. But if it simply takes a pointer to a callable object, it can be made as this:</p>

<pre><code> startupTimer.setTimeout(5000, [this](){ endInit(); } );
</code></pre>

<p>And the <code>endInit</code> method must be NOT static anymore.</p>

<p>If your timer interface did not providing adding some user data to the callback, you have no chance to set the object data to the callback. Such an interface for a timer object is nearly useless. This makes it impossible to use any kind of OOP. So there is only a chance to make a list of static/ global scope helper functions. <em>THIS IS VERY BAD DESIGN</em></p>

<p>Here a very bad work around:</p>

<pre><code>template &lt;typename T, int n&gt;
class UglyObjectCallbackHandler
{
    static T* obj;
    static void(T::*callback)();

    public:

    static void SetObj( T* _obj ) { obj = _obj; }
    static void SetCallback( void(T::* _callback)() ) { callback = _callback; }

    static void ForwardCallback() { (obj-&gt;*callback)(); }
};

template &lt;typename T, int n&gt; T* UglyObjectCallbackHandler&lt;T,n&gt;::obj;
template &lt;typename T, int n&gt; void(T::* UglyObjectCallbackHandler&lt;T,n&gt;::callback)();

class A
{
    private:
        int i;
        void(*callback)();
        std::function&lt;void()&gt; callback_func= [this](){ f(); };


    public:
        A( int _i ): i{_i} { }

        void f() { std::cout &lt;&lt; ""Callback fired"" &lt;&lt; i &lt;&lt; std::endl; }
};

class TimerFake
{   
    private:
        void (*ptr)();

    public:
        void SetCallback( void (*_ptr)() ) { ptr = _ptr; }

        void Fire() { (*ptr)(); }


};

int main()
{
    // multiple client instances possible
    A a(9);
    UglyObjectCallbackHandler&lt;A,0&gt;::SetObj( &amp;a );
    UglyObjectCallbackHandler&lt;A,0&gt;::SetCallback( &amp;A::f );

    A b(77);
    UglyObjectCallbackHandler&lt;A,1&gt;::SetObj( &amp;b );
    UglyObjectCallbackHandler&lt;A,1&gt;::SetCallback( &amp;A::f );

    TimerFake timer0;
    timer0.SetCallback( &amp;UglyObjectCallbackHandler&lt;A,0&gt;::ForwardCallback );

    TimerFake timer1;
    timer1.SetCallback( &amp;UglyObjectCallbackHandler&lt;A,1&gt;::ForwardCallback );

    timer0.Fire();
    timer1.Fire();
}
</code></pre>

<p>The idea is to keep multiple runtime objects ( like your ESC objects ) into a list which is generated in compile time. So here a template provides the second parameter which is an index to the instance you want to call.
Because the template provides a static callback method ( forwarder ), it can be used to be used itself as callback to bad designed interfaces. As said: This is a very bad idea. Better use a full featured Timer lib!</p>
",,,
49226416,2,49204265,2018-03-12T00:00:03.410,0,,8400707,,2018-03-12T00:00:03.410,,0,,"<p>I think that the code has some the memory problems. The node's address(pointer) is duplicated (double free problem). If you want to copy the structure, it needs new memory allocation and readdressing of the nodes for linked list.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;

using namespace std ;

template &lt;class T&gt; 
class LinkedList {
  struct Node {
      T *x;
      Node *next;
  };
  private:
    Node *head;
  public:
    LinkedList(){
        printf(""constructor:%p\n"", this) ;
        head = NULL;
    }

    ~LinkedList(){
        printf(""destructor:%p\n"", this) ;
        Node *next = head;
        while(next) {  
            Node *deleteMe = next;
            next = next-&gt;next;
            printf(""delete node:%p\n"", deleteMe) ;
            delete deleteMe-&gt;x ;    // x
            delete deleteMe;
        }
    }

    LinkedList* Dup() {
        LinkedList *newList = new LinkedList&lt;T&gt;() ;
        Node *n = head ;
        while (n != NULL) {
            T *newx = new T(); 
            *newx=*(n-&gt;x) ;
//          newList-&gt;addTail(n-&gt;x) ;
            newList-&gt;addTail(newx) ;
            n = n-&gt;next;
        }
        return newList ;
    }

    // prepend a new value to the beginning of the list
    // val : caller must allocate memory.
    void add(T *val){
        Node *n = new Node();
        printf("" addhead: new alloc node %p\n"", n) ;
//      T *newval = new T();
//      *newval = *val ;
//        n-&gt;x = newval;
        n-&gt;x = val ;
        n-&gt;next = head;
        head = n;
    }

    // add to end
    // val : caller must allocate memory.
    void addTail(T *val) {
        Node *n = new Node();
        Node *l = head ;

        printf("" addtail: new alloc node %p\n"", n) ;
//      T *newval = new T();
//      *newval = *val ;
//        n-&gt;x = newval;
        n-&gt;x = val ;
        n-&gt;next = NULL ;
        if ( l==NULL ) {
            head = n ;
            return ;
        }
        while(l-&gt;next!=NULL) {
            l = l-&gt;next ;
        }
        l-&gt;next = n ;
    }

    void forEach(void (*callback)(T*)) {
      Node *n = head;
      while (n != NULL) {
        (*callback)(n-&gt;x);
        n = n-&gt;next;
      }
      printf(""\n"");
    }
};

void printInt(int *x) {
//  Serial.print(x);
    printf(""%d "", *x) ;
}

void printBoard(LinkedList&lt;int&gt; *x) {
  x-&gt;forEach(printInt);
}

int main() {
  //Serial.begin(9600); 

  printf(""make A\n"") ;
  int avail_Afree=0 ;

#if 0
    // use stack memory
  LinkedList&lt;int&gt; A;
  LinkedList&lt;int&gt; *pA=&amp;A;
#else
    // use heap
  LinkedList&lt;int&gt; *pA = new LinkedList&lt;int&gt;();
  avail_Afree=1 ;
#endif
  int val=0 ;

  for (int i=1; i&lt;=7; i++) {
    printf(""add node:%d\n"", i) ;
//    val=i ;
    int *pval = new int() ;
    *pval = i ;
//    pA-&gt;add(&amp;val);
    pA-&gt;add(pval);
  }
  pA-&gt;forEach(printInt);


    // prepare copied data.
  LinkedList&lt;int&gt; *pA2, *pA3 ;
printf(""make A2\n"") ;
  pA2 = pA-&gt;Dup() ;
  pA2-&gt;forEach(printInt) ;

printf(""make A3\n"") ;
  pA3 = pA-&gt;Dup() ;
  pA3-&gt;forEach(printInt) ;


    // make board
  LinkedList&lt;LinkedList&lt;int&gt; &gt; *pBoard;
  printf(""make Board\n"") ;
  pBoard = new LinkedList&lt;LinkedList&lt;int&gt; &gt; () ;

    printf(""  Board add: A2\n"") ;
  pBoard-&gt;add(pA2);

    printf(""  Board add: A3\n"") ;
  pBoard-&gt;add(pA3);

    printf("" print Board\n"") ;
  pBoard-&gt;forEach(printBoard); // returns nothing

  if ( avail_Afree ) {
    printf(""delete pA:%p\n"", pA) ;
    delete pA ;
  }

/* 
  printf(""delete pA2:%p\n"", pA2) ;
  delete pA2 ;
  printf(""delete pA3:%p\n"", pA3) ;
  delete pA3 ;
  // pBoard will free A2,A3.
*/
  printf(""delete pBoard:%p\n"", pBoard) ;
  delete pBoard ;

  return 0 ;
}
</code></pre>

<p>output is this</p>

<pre><code>make A
constructor:0x7fb8f8d00000
add node:1
 addhead: new alloc node 0x7fb8f8d00020
add node:2
 addhead: new alloc node 0x7fb8f8d00040
add node:3
 addhead: new alloc node 0x7fb8f8d00060
add node:4
 addhead: new alloc node 0x7fb8f8d00080
add node:5
 addhead: new alloc node 0x7fb8f8d000a0
add node:6
 addhead: new alloc node 0x7fb8f8d000c0
add node:7
 addhead: new alloc node 0x7fb8f8d000e0
7 6 5 4 3 2 1 
make A2
constructor:0x7fb8f8d000f0
 addtail: new alloc node 0x7fb8f8d00110
 addtail: new alloc node 0x7fb8f8d00130
 addtail: new alloc node 0x7fb8f8d00150
 addtail: new alloc node 0x7fb8f8d00170
 addtail: new alloc node 0x7fb8f8d00190
 addtail: new alloc node 0x7fb8f8d001b0
 addtail: new alloc node 0x7fb8f8d001d0
7 6 5 4 3 2 1 
make A3
constructor:0x7fb8f8d001e0
 addtail: new alloc node 0x7fb8f8d00200
 addtail: new alloc node 0x7fb8f8d00220
 addtail: new alloc node 0x7fb8f8d00240
 addtail: new alloc node 0x7fb8f8d00260
 addtail: new alloc node 0x7fb8f8d00280
 addtail: new alloc node 0x7fb8f8d002a0
 addtail: new alloc node 0x7fb8f8d002c0
7 6 5 4 3 2 1 
make Board
constructor:0x7fb8f8d002d0
  Board add: A2
 addhead: new alloc node 0x7fb8f8d002e0
  Board add: A3
 addhead: new alloc node 0x7fb8f8d002f0
 print Board
7 6 5 4 3 2 1 
7 6 5 4 3 2 1 

delete pA:0x7fb8f8d00000
destructor:0x7fb8f8d00000
delete node:0x7fb8f8d000e0
delete node:0x7fb8f8d000c0
delete node:0x7fb8f8d000a0
delete node:0x7fb8f8d00080
delete node:0x7fb8f8d00060
delete node:0x7fb8f8d00040
delete node:0x7fb8f8d00020
delete pBoard:0x7fb8f8d002d0
destructor:0x7fb8f8d002d0
delete node:0x7fb8f8d002f0
destructor:0x7fb8f8d001e0
delete node:0x7fb8f8d00200
delete node:0x7fb8f8d00220
delete node:0x7fb8f8d00240
delete node:0x7fb8f8d00260
delete node:0x7fb8f8d00280
delete node:0x7fb8f8d002a0
delete node:0x7fb8f8d002c0
delete node:0x7fb8f8d002e0
destructor:0x7fb8f8d000f0
delete node:0x7fb8f8d00110
delete node:0x7fb8f8d00130
delete node:0x7fb8f8d00150
delete node:0x7fb8f8d00170
delete node:0x7fb8f8d00190
delete node:0x7fb8f8d001b0
delete node:0x7fb8f8d001d0
</code></pre>
",,,
49718055,2,49244535,2018-04-08T12:55:58.110,0,,5603942,,2018-04-08T12:55:58.110,,0,,"<p>I solved my problem using following code:</p>

<pre><code>#include &lt;EtherCard.h&gt;
#define REQUEST_RATE 5000 // milliseconds

// ethernet interface mac address
static byte mymac[] = { 0x74,0x69,0x69,0x2D,0x30,0x33 };
static byte myip[] = { 192,168,1,15 };
static byte gwip[] = { 192,168,1,1 };
static byte netmask[] = { 255,255,255,255 };//
static byte dnsip[] = { 8,8,8,8 };
static byte hisip[] = { 192,168,1,1 };//

const char website[] PROGMEM = ""192.168.1.1"";


byte Ethernet::buffer[500];
static long timer;

void setup () {
Serial.begin(9600);
Serial.println(""\n[getStaticIP]"");

if (ether.begin(sizeof Ethernet::buffer, mymac, 10) == 0) 
Serial.println( ""Failed to access Ethernet controller"");

ether.staticSetup(myip, gwip);

if(ether.dnsLookup (website, false)){
Serial.println( ""dnsLookup ok"");
}else{
Serial.println( ""dnsLookup faild"");
 ether.parseIp(ether.hisip, ""192.168.1.1""); //IP do servidor manual
}

while (ether.clientWaitingGw())
ether.packetLoop(ether.packetReceive());
Serial.println(""Gateway found"");

ether.printIp(""My IP: "", ether.myip);
ether.printIp(""Netmask: "", ether.netmask);
ether.printIp(""GW IP: "", ether.gwip);
ether.printIp(""DNS IP: "", ether.dnsip);
ether.printIp(""SRV: "", ether.hisip);

timer = - REQUEST_RATE; // start timing out right away
}

void loop () {
ether.packetLoop(ether.packetReceive());

if (millis() &gt; timer + REQUEST_RATE) {
timer = millis();
Serial.println(""\n&gt;&gt;&gt; REQ"");
ether.hisport = 90;//to access  local host

/*char *PATH=""/SafeHome/addevent"";
char *contentType = ""Content-Type: application/json"";
String postDataStr =  """";
char *postDataChar = postDataStr.c_str();*/

ether.httpPost(PSTR(""/SafeHome/addcommand""), website,PSTR(""Content-Type: application/json""), PSTR(""""), my_result_cb);


}
}

// called when the client request is complete
static void my_result_cb (byte status, word off, word len) {

// JSON Body of my post request
Serial.print(""&lt;&lt;&lt;&lt; {\""EXECUTADO\"": \""0\"", \""INSTALACAO_ID\"": \""1\"",\""TPCOMANDO_ID\"": \""1\""}"");
//Serial.print(millis() - timer);
Serial.println("" ms"");
Serial.println((const char*) Ethernet::buffer + off);
}
</code></pre>
",,,
49267783,2,49246446,2018-03-14T00:00:40.390,0,,7054858,,2018-03-14T00:00:40.390,,0,,"<p>The compiler has to know the size of the array when you declare it. It can find it out either directly from the value in <code>[]</code> (e.g. <code>uint8_t message [2]</code>) either, if there isn’t any value there, from the length of a braced-enclosed initializer, i.e. the list of comma-separated values inside a <code>{ }</code> that you may assign to the array at declaration.</p>

<p>That aside, you can’t directly store an int value (2 bytes, signed) in an uint8_t (1 byte, unsigned). Since (I suppose) you need to transmit data as an uint8_t array you can do as follows:</p>

<pre><code>int temp = 25;
// store temp in a uint8_t array with two elements (needed to store two bytes)
uint8_t message[2];
 message[0] = temp &gt;&gt; 8; // Most significant byte, MSB
 message[1] = temp; // Least significant byte, LSB
</code></pre>

<p>or</p>

<pre><code>int temp = 25;
// store temp in a uint8_t array with two elements (needed to store two bytes)
uint8_t message[2] = {(temp &gt;&gt; 8), temp};

 message[0] = temp &gt;&gt; 8; // Most significant byte, MSB
 message[1] = temp; // Least significant byte, LSB
</code></pre>

<p>Theb transmit <code>message</code>, and on the receiver “reconvert” it to an int: <code>temp = (message[0] &lt;&lt; 8) | message[1];</code>.</p>
",,,
49258173,2,49254838,2018-03-13T14:00:43.360,0,,2612259,,2018-03-13T14:00:43.360,,2,,"<p>I have some different calculations which I recently implemented based on a ruby implementation I did sometime back.  I don't have the details at hand, I can try and find them and add them later, but I think your issue might be the use of atan2 for the pitch.
I think your calculations are based on the following equations in the data sheet you linked to.</p>

<blockquote>
<pre><code>tan(φ) = (Gpy/Gpx)  // eq 13
tan(θ) = (-Gpx / (Gpy sin(φ) + Gpz cos(φ))  // eq 15
</code></pre>
</blockquote>

<p>where the doc says.</p>

<blockquote>
  <p>Since Equations 13, 15 and 22 have an infinite number of solutions at
  multiples of 360°, it is standard convention to restrict the solutions
  for roll, pitch and yaw to the range -180° to 180°. A further
  constraint is imposed on the pitch angle to limit it to the range -90°
  to 90°. This ensures only one unique solution exists for the compass,
  pitch and roll angles for any phone orientation. Equations <strong>13</strong> and 22
  are therefore computed with a software <strong>ATAN2</strong> function (with output
  angle range <strong>-180° to 180°</strong>) and Equation <strong>15</strong> is computed with a software
  ATAN function (with output angle range <strong>-90° to 90°</strong>).</p>
</blockquote>

<p>Here are my calculations if you are interested. (as I said I don't have the documentation handy as to how I came up with these.</p>

<pre><code>float xM = magCurrent[0] - magOffsets[0];
float yM = magCurrent[1] - magOffsets[1];
float zM = magCurrent[2] - magOffsets[2];
float heading = (atan2(yM, xM) * 180) / Pi;
if (heading &lt; 0) {
  heading = 360 + heading;
}
logger.infoln(""Compass Heading: %f"", heading);
float g = 9.8;
float xG = (accelCurrent[0] - accelOffsets[0]) / g; 
float yG = (accelCurrent[1] - accelOffsets[1]) / g; 
float zG = (accelCurrent[2] - accelOffsets[2]) / g;
float pitch = atan2(-xG, sqrt(yG * yG + zG * zG));
float roll = atan2(yG, zG);
logger.infoln(""pitch: %f"", pitch * 180 / Pi);
logger.infoln(""roll: %f"", roll * 180 / Pi);
float xM2 = xM * cos(pitch) + zM * sin(pitch);
float yM2 = xM * sin(roll) * sin(pitch) + yM * cos(roll) - zM * sin(roll) * cos(pitch);
float compHeading = (atan2(yM2, xM2) * 180 / Pi);
if (compHeading &lt; 0) {
  compHeading = 360 + compHeading;
}
logger.infoln(""tilt compensated Compass Heading: %f"", compHeading);
</code></pre>
",,,
49281947,2,49277375,2018-03-14T15:38:07.543,0,,3515931,,2018-03-14T15:52:39.603,2018-03-14T15:52:39.603,3,,"<p>You need to only call <code>wiringPiI2CSetup()</code> once in the process.  One way this can be achieved by using a static variable for <code>xio</code> so that it will retain the value between calls:</p>

<pre><code>int read_eeprom(unsigned char address)
{
    int i, value;
    static int xio = -1;

    if( xio == -1 ) {
       xio = wiringPiI2CSetup (address);
       if (xio &lt; 0) {
           fprintf (stderr, ""xio: Can't initialise I2C: %s\n"",
                    strerror (errno));
           return 1;
       }
    }

    for(i=0; i &lt;128; i++) {
        value = wiringPiI2CReadReg8 (xio,i);
        if( value &gt; 0 ) {
            if (address == 0x50)
                A50[i] = value;
            else 
                A51[i] = value;
        }
        else {
            fprintf (stderr, ""xio: Can't read i2c address 0x%x: %s\n"",
                     address, strerror (errno));
            return 1;
        }
    }
    return 0;
}
</code></pre>

<p>Another way would be to call <code>wiringPiI2CSetup()</code> each time you enter the routune, but then to close it between each call:</p>

<pre><code>int read_eeprom(unsigned char address)
{
    int xio, i, value;
    xio = wiringPiI2CSetup (address);
    if (xio &lt; 0) {
       fprintf (stderr, ""xio: Can't initialise I2C: %s\n"",
                strerror (errno));
       return 1;
    }

    for(i=0; i &lt;128; i++) {
        value = wiringPiI2CReadReg8 (xio,i);
        if( value &gt; 0 ) {
            if (address == 0x50)
                A50[i] = value;
            else 
                A51[i] = value;
        }
        else {
            fprintf (stderr, ""xio: Can't read i2c address 0x%x: %s\n"",
                     address, strerror (errno));
            close(xio);
            return 1;
        }
    }
    close(xio);
    return 0;
}
</code></pre>
",,,
49281950,2,49277375,2018-03-14T15:38:16.233,0,,6470290,,2018-03-14T15:38:16.233,,3,,"<p>Solved by adding <code>close(fd1);</code> at the end of <code>read_eeprom</code> as follows:</p>

<pre><code>int read_eeprom(unsigned char address)
{
    int xio,i,fd1;
    xio = wiringPiI2CSetup (address);
    if (xio &lt; 0) 
    {
        fprintf (stderr, ""xio: Can't initialise I2C: %s\n"",
                 strerror (errno));
        return 1;
    }
    //loop through addresses and extract data from eeprom
    for(i=0; i &lt;128; i++) 
        {
        fd1 = wiringPiI2CReadReg8 (xio,i);
        if  (address == 0x50) 
            {
                A50[i] = fd1;
            }
        else 
            {
                A51[i] = fd1;
            }
        if (fd1 &lt;0) 
            {
                fprintf (stderr, ""xio: Can't read i2c address 0x%x: %s\n"",
                         address, strerror (errno));
                return 1;
            }
        }
    //close fd1 to prevent segfault and ""too many files open"" errors
    close(fd1);
    return 0;
}
</code></pre>

<p>Credits to @Mat for identifying the <strong><em>FD leak</em></strong></p>
",,,
49435174,2,49433454,2018-03-22T17:40:15.087,0,,1564026,,2018-03-22T17:50:26.900,2018-03-22T17:50:26.900,0,,"<p>I think the issue lies with the fact that bit 0 tells the device whether it's read or write. I'm not familiar with the notation of the bar above the W (feel free to correct me), but from my results I guess it has to be a 1 for read, which is why 0x00 became 0x01, 0x01 became 0x03, 0x02 became 0x05 etc as the register address needs to be shifted up 1 bit to allow for the RW bit.</p>

<p><a href=""https://i.stack.imgur.com/fBwjw.png"" rel=""nofollow noreferrer"">ADXL355 SPI Protocol</a></p>

<p>In case it's helpful to anyone else, by changing the transfer function as shown below the registers now match up:</p>

<pre><code>void transfer(char charToTransfer, int read)
{
    char buffer[] = { (charToTransfer &lt;&lt; 1) + read , 0x00};
    bcm2835_spi_transfern(buffer, sizeof(buffer));
    if(read)
    {
        printf(""Rx:  %02X \n"", buffer[1]);
    }
}
</code></pre>
",,,
49434164,2,49433775,2018-03-22T16:47:00.460,4,,9532550,,2018-03-24T08:56:01.013,2018-03-24T08:56:01.013,3,,"<p>In C, there is a feature called <strong>Variadic functions</strong>. This feature is almost equivalent to <strong>C# params</strong> except that you have to give the params size or something like that, which is because of the nature of low level array in C.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void use_params(int number_of_params, ...) {
    va_list args;
    va_start(args, number_of_params);

    for(int i = 0; i &lt; number_of_params; ++i) {
        some_type element = va_arg(args, some_type);
        do_something_with(element);
    }

    va_end(args);
}

void main() {
    use_params(4, 'a', 'b', 'c', 'd');
}
</code></pre>

<p>This way is the best option about either performance or flexibility (you can have multiple params of multiple types).</p>

<p>But if you do not love using <code>va_list</code>, <code>va_start</code>,... and prefer something easier to read, <code>std::vector</code> is where to go. Note that <code>std::vector</code> is a C++ feature, so it will be not available if your system supports only C, in which <strong>variadic functions</strong> is the only choice.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

void use_params(const std::vector&lt;int&gt;&amp; params) {
    for(size_t i = 0; i &lt; params.size(); ++i) {
        do_something_with(params[i]);
    }
}

void main() {
    use_params({1, 2, 3, 5});
}
</code></pre>
",,,
49445055,2,49441368,2018-03-23T08:12:26.460,0,,2836621,,2018-03-28T18:40:01.030,2018-03-28T18:40:01.030,6,,"<p>There are lots of ways of doing this. First off, if you are a beginner with setting up webpages, I would recommend you install <a href=""http://www.lighttpd.net"" rel=""nofollow noreferrer"">lighttpd</a> instead of <code>Apache</code> as it is very easy to configure.</p>

<p>So you would do:</p>

<pre><code>sudo apt-get install lighttpd php-cgi
</code></pre>

<p>Then save the following as <code>lighttpd-local.conf</code></p>

<pre><code>################################################################################
# lighttpd-local.conf
# 
# Simple config file for lighttpd without needing to install Apache or configure
# any system-wide stuff in ""/etc"".
#
# Allows running Perl and PHP scripts as CGI. You may need:
#
# sudo apt-get php-cgi
#
# Just start serving the current directory by running:
#
# lighttpd -f lighttpd-local.conf
# 
# And access it in your browser (Safari, Chrome, Firefox) at:
#
# http://&lt;IP_ADDRESS&gt;:8000
#
################################################################################
# To see your PHP settings and configured modules, create a file in this
# directory called ""phpinfo.php"" which contains:
#
# &lt;?php
# phpinfo();
# ?&gt;
#
# And then in your browser, navigate to:
# 
# http://&lt;IP-ADDRESS&gt;:8000/phpinfo.php
################################################################################
# Bind to all interfaces - wired, wifi and be accessible anywhere
server.bind          = ""0.0.0.0""
server.port          = 8000
server.document-root = CWD
server.errorlog          = CWD + ""/lighttpd.error.log""
accesslog.filename       = CWD + ""/lighttpd.access.log""
server.breakagelog       = CWD + ""/lighttpd.breakage.log"" 

index-file.names = ( ""index.php"", ""index.html"", ""index.htm"", ""default.htm"" )

server.modules = (""mod_cgi"", ""mod_accesslog"")

# Ensure Perl and PHP scripts are executed rather than have their contents displayed
static-file.exclude-extensions = ("".pl"","".php"")
cgi.assign = ( "".pl""  =&gt; ""/usr/bin/perl"",
               "".php"" =&gt; ""/usr/bin/php-cgi"" )

mimetype.assign = (  
  "".css""        =&gt;  ""text/css"",
  "".gif""        =&gt;  ""image/gif"",
  "".htm""        =&gt;  ""text/html"",
  "".html""       =&gt;  ""text/html"",
  "".jpeg""       =&gt;  ""image/jpeg"",
  "".jpg""        =&gt;  ""image/jpeg"",
  "".js""         =&gt;  ""text/javascript"",
  "".png""        =&gt;  ""image/png"",
  "".txt""        =&gt;  ""text/plain""
)
</code></pre>

<p>And finally start your web server, serving the contents of the local directory:</p>

<pre><code>lighttpd -f lighttpd-local.conf
</code></pre>

<hr>

<p>Then you want to consider how your webpage will interact with your C program. Some possibilities are:</p>

<ul>
<li>via the filesystem</li>
<li>via a messaging system</li>
<li>via a database</li>
</ul>

<hr>

<p>If you want to use the filesystem, basically you make a CGI-type program that writes the variable into a file whenever the user presses a button - in the example below that file is called <code>""setting.txt""</code>. Your C program then reads the variable from that file. It could either read the file every time through its main loop, or your CGI-type program could send your C program a signal (e.g. kill -HUP ) and it could have  signal handler that re-reads the file.</p>

<p>So, you would save this as <code>index.php</code>:</p>

<pre><code>&lt;?php
// If we were POSTed, save the value in file on server for C program to see
if ( $_SERVER['REQUEST_METHOD'] == 'POST' ) {
   file_put_contents(""setting.txt"",$_POST['val']);
   // *** MARKER ***
   return;
}
?&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Simple Control&lt;/title&gt;
  &lt;script src=""https://code.jquery.com/jquery-1.12.4.js""&gt;&lt;/script&gt;

&lt;?php
   // PHP - executed on server before webpage is loaded
   // Get setting from previous run to pass to Javascript
   $s = file_get_contents(""setting.txt"");
   $s = intval($s);
?&gt;

&lt;script type=""text/javascript""&gt;
    // Javascript - executed on client in browser

    // Put PHP variable into Javascript global
    var gblSetting=&lt;?php echo $s; ?&gt;;

    // This function is run when webpage is loaded
    $(document).ready(function() {

       // Display current value on webpage
       $(""#idCurrent"").html(""Current value: "" + gblSetting);

       // This function is run when button is clicked
       $('#idButton').click(function()
       {
          // Toggle the global Javascript variable
          gblSetting=1-gblSetting;

          // Send its new value to server to save for C program to see
          // See POST code at start of this file
          $.ajax({
            type: 'POST',
            url: 'index.php', 
            data:'val='+ gblSetting
          })

          // Update value on webpage
          $(""#idCurrent"").html(""Current value: "" + gblSetting);
       });
    });
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;
&lt;div id=""idCurrent""&gt;Unknown&lt;/div&gt;
&lt;button id=""idButton""&gt;Toggle value&lt;/button&gt;
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>and then navigate in your browser to:</p>

<pre><code>http://&lt;IP_ADDRESS&gt;:8000/index.php
</code></pre>

<p>If you have got everything correct, it will look like this:</p>

<p><a href=""https://i.stack.imgur.com/bQ2ro.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bQ2ro.png"" alt=""enter image description here""></a></p>

<p>If you wanted to send a signal to your C program whenever the file changes, you would go to the line with <code>*** MARKER ***</code> and insert a call to <a href=""http://php.net/manual/en/function.posix-kill.php"" rel=""nofollow noreferrer"">kill</a>. Then set up a signal handler in your C program that handles <code>SIGHUP</code> for example. Signal handler setup is described <a href=""https://en.wikipedia.org/wiki/C_signal_handling"" rel=""nofollow noreferrer"">here</a>. Here is a quick example:</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;csignal&gt;
#include &lt;iostream&gt;

int nSignals;

void signal_handler(int signal)
{
   std::signal(SIGHUP, signal_handler);
   std::cout &lt;&lt; ""Got signal"" &lt;&lt; std::endl;
   nSignals++;
}

int main()
{
   // Install a signal handler
   std::signal(SIGHUP, signal_handler);

   std::cout &lt;&lt; ""Send me a signal with: kill -HUP "" &lt;&lt; (int)getpid() &lt;&lt; std::endl;

   while(nSignals&lt;5){
      std::cout &lt;&lt; ""Received "" &lt;&lt; nSignals &lt;&lt; "" of 5 signals, sleeping..."" &lt;&lt; std::endl;
      std::this_thread::sleep_for(std::chrono::seconds(5));
   }
}
</code></pre>

<hr>

<p>If you want to use a messaging program, your C program would subscribe to a messaging system (nanomsg, zeromq, mosquitto) and your CGI-type program would send a message when the user clicks a button. You would insert that code into the above file where it says <code>*** MARKER ***</code>.</p>

<hr>

<p>If you want to use a database (e.g. <code>sqlite</code> is small and easy, or <code>Redis</code> is small and easy), your C program would read its values from the database and your CGI-type program would write the value in the database when the user clicks a button. You would insert that code into the above file where it says <code>*** MARKER ***</code>. So, if you used <strong>Redis</strong>, that code might be something like:</p>

<pre><code>$redis-&gt;connect('127.0.0.1'); // port 6379 by default
...
$redis-&gt;set('value', 1);
</code></pre>

<p>Then in your C program, you use <a href=""https://github.com/redis/hiredis"" rel=""nofollow noreferrer"">hiredis</a> and code like this to retrieve the current value:</p>

<pre><code>redisContext *c = redisConnect(""127.0.0.1"", 6379);
reply = redisCommand(c,""GET value"");
printf(""GET value: %s\n"", reply-&gt;str);
</code></pre>

<p><a href=""https://stackoverflow.com/a/47963630/2836621"">Here</a> is a link to a Redis-type of setup that could be adapted.</p>
",,,
49506365,2,49504923,2018-03-27T07:06:20.393,1,,3386109,,2018-03-27T07:06:20.393,,0,,"<p>The pins are nicely labeled: <code>A1Pin</code>, <code>A0Pin</code>, etc. The variable names should follow that same convention: <code>a1Value</code>, <code>a0Value</code>, etc. That will make the <code>if</code> statements easier to understand. </p>

<p>Then you just need to be systematic about the <code>if</code> statements. With 4 inputs, there are sixteen possible combinations, and you need an <code>if</code> statement for each one. And every <code>if</code> statement should check <strong>every</strong> input value. </p>

<p>So the first two <code>if</code> statements are</p>

<pre><code>if (a1Value == LOW &amp;&amp; a0Value == LOW &amp;&amp; b1Value == LOW &amp;&amp; b0Value == LOW)
{
    digitalWrite(LED0Pin,LOW);   // 0 + 0 = 0
    digitalWrite(LED1Pin,LOW);
    digitalWrite(LED2Pin,LOW);
}
else if a1Value == LOW &amp;&amp; a0Value == LOW &amp;&amp; b1Value == LOW &amp;&amp; b0Value == HIGH) 
{
    digitalWrite(LED0Pin,HIGH);  // 0 + 1 = 1
    digitalWrite(LED1Pin,LOW);
    digitalWrite(LED2Pin,LOW);
}
</code></pre>

<p>and the last <code>if</code> statement is</p>

<pre><code>else if (a1Value == HIGH &amp;&amp; a0Value == HIGH &amp;&amp; b1Value == HIGH &amp;&amp; b0Value == HIGH)
{
    digitalWrite(LED0Pin,LOW);   // 3 + 3 = 6
    digitalWrite(LED1Pin,HIGH);
    digitalWrite(LED2Pin,HIGH);
}
</code></pre>

<p>and there are 13 more to go.</p>

<p>Now of course there are other ways to do this, but I thought I would  just help you finish what you started.</p>

<p>Once you get the code working, you can post it on <a href=""https://codereview.stackexchange.com/"">code review</a> and you'll get all sorts of suggestions on how to optimize it. </p>
",,,
49506621,2,49504923,2018-03-27T07:20:44.520,1,,8979940,,2018-03-27T07:20:44.520,,0,,"<p>following  Yunnosch comment this is what he meant you can pre calculate the valu of the addition and then display it to the LEDs this simplefies the code greatly
the code below should work - or at least serve as a guideline
I commented in an example for you to understand the logic, hope it helps</p>

<p>NOTE: since i am not infront of an Arduino this code is not tested - but it does compile</p>

<pre><code>int A0Pin = 12;
int A1Pin = 11;
int B0Pin = 10;
int B1Pin = 9;

int LED0Pin = 6;
int LED1Pin = 5;
int LED2Pin = 4;

void setup()
{
  pinMode(A0Pin, INPUT);
  pinMode(A1Pin, INPUT);
  pinMode(B0Pin, INPUT);
  pinMode(B1Pin, INPUT);

  pinMode(LED0Pin, OUTPUT);
  pinMode(LED1Pin, OUTPUT);
  pinMode(LED2Pin, OUTPUT);
}

void loop()
{
  int b1Value = digitalRead(A0Pin);
  int b2Value = digitalRead(A1Pin);
  int b3Value = digitalRead(B0Pin);
  int b4Value = digitalRead(B1Pin);

  // b1 is set to represent 1 and b2 will represent 2 same with b3 and b4 pair
  // lets assume b1 = 1 b2 = 0 the number is 1
  // b3 is set to 1 and b4 is set to 1
  // input : b2|b1 + b4|b3
  //          0| 1    1| 1
  // sum = 1*1 + 0*2 + 1*1 + 1*2 = 4 - which is represented in binary as b100
  int sum = (b1Value * 1) + (b2Value * 2) + (b3Value * 1) + (b4Value * 2);

  if (sum &amp; 0x1) //binary rep b001 - following the example will result in 0
    digitalWrite(LED0Pin, HIGH);
  else
    digitalWrite(LED0Pin, LOW);

  if (sum &amp; 0x2) //binary rep b010 - following the example will result in 0
    digitalWrite(LED1Pin, HIGH);
  else
    digitalWrite(LED1Pin, LOW);

  if (sum &amp; 0x4) //binary rep b100 - following the example will result in 1
    digitalWrite(LED2Pin, HIGH);
  else
    digitalWrite(LED2Pin, LOW);

  delay(10);
}
</code></pre>
",,,
49508896,2,49504923,2018-03-27T09:17:53.040,2,,4386427,,2018-03-27T09:17:53.040,,0,,"<p>Well, first of all: There are much better approaches than the one you have chosen. However, this answer will stick to your approach and explain why your code is failing.</p>

<p>As far as I can tell the idea behind your approach is:</p>

<p>1) Cover the case where no input is HIGH (i.e. you start by turning of all LEDs). 1 case.</p>

<p>2) Cover the cases where exactly 1 input is high. 4 cases.</p>

<p>3) Cover the cases where exactly 2 inputs are high. 6 cases.</p>

<p>4) Cover the cases where exactly 3 inputs are high. 4 cases.</p>

<p>5) Cover the case where all 4 inputs are high. 1 case.</p>

<p>That approach will work because step 5 takes priority over step 4 and step 4 takes priority over step 3 and so on. That is, even if you set an incorrect output in e.g. step 4, it will be corrected by step 5 (if all inputs are HIGH).</p>

<blockquote>
  <p>So what is wrong with your code?</p>
</blockquote>

<p><strong>The problem is that you don't cover all cases.</strong> For instance you never cover <code>b1</code> and <code>b4</code> both being HIGH.</p>

<p>Also you have a typo bug here:</p>

<pre><code>if(b2Value == HIGH &amp;&amp; b4Value == HIGH &amp;&amp; b2Value == HIGH)
   ^^^                                   ^^^
</code></pre>

<p>Further, your code shall never check for LOW like you do here:</p>

<pre><code>if(b2Value == HIGH &amp;&amp; b3Value == LOW &amp;&amp; b4Value == LOW)
</code></pre>

<p>The LOW value is handled implicit by the priority of the if-statements.</p>

<p>In total you must have the initialization plus 15 if-statements.</p>

<p>So your code should be:</p>

<pre><code>  // Handle 1 case with no input high
  digitalWrite(LED0Pin, LOW);
  digitalWrite(LED1Pin, LOW);
  digitalWrite(LED2Pin, LOW);

  // Handle 4 cases with exactly 1 input being high
  if (b1Value == HIGH)
  {
      ...
  }
  else if (b2Value == HIGH)
  {
      ...
  }
  else if (b3Value == HIGH)
  {
      ...
  }
  else if (b4Value == HIGH)
  {
      ...
  }

  // Handle 6 cases with exactly 2 input being high
  if(b1Value == HIGH &amp;&amp; b2Value == HIGH )
  {
    ...
  }
  else if(b1Value == HIGH &amp;&amp; b3Value == HIGH )
  {
    ...
  }
  else if(b1Value == HIGH &amp;&amp; b4Value == HIGH)
  {
    ...
  }
  else if(b2Value == HIGH &amp;&amp; b3Value == HIGH)
  {
    ...
  }
  else if(b2Value == HIGH &amp;&amp; b4Value == HIGH)
  {
    ...
  }
  else if(b3Value == HIGH &amp;&amp; b4Value == HIGH)
  {
    ...
  }

  // Handle 4 cases with exactly 3 input being high
  if(b1Value == HIGH &amp;&amp; b2Value == HIGH  &amp;&amp; b3Value == HIGH)
  {
      ...
  }
  else if(b1Value == HIGH &amp;&amp; b2Value == HIGH  &amp;&amp; b4Value == HIGH)
  {
      ...
  }
  else if(b1Value == HIGH &amp;&amp; b3Value == HIGH  &amp;&amp; b4Value == HIGH)
  {
      ...
  }
  else if(b2Value == HIGH &amp;&amp; b3Value == HIGH  &amp;&amp; b4Value == HIGH)
  {
      ...
  }

  // Handle 1 cases with exactly 4 input being high
  if(b1Value == HIGH &amp;&amp; b2Value == HIGH &amp;&amp; b3Value == HIGH &amp;&amp; b4Value == HIGH)
  {
      ...
  }
</code></pre>

<p>The above explains why your code isn't working and how to fix it.</p>

<p>But as you can see the approach is very error prone (i.e. it's so easy to miss a case). Besides that it also has bad performance. So I'll recommend a more simple approach.</p>

<pre><code>int temp = 2 * digitalRead(A1Pin) +
               digitalRead(A0Pin) +
           2 * digitalRead(B1Pin) +
               digitalRead(B0Pin);

output0 = (temp &amp; 1) == 1;
output1 = (temp &amp; 2) == 2;
output2 = (temp &amp; 4) == 4;
</code></pre>
",,,
49513944,2,49504923,2018-03-27T13:17:23.483,1,,1527,,2018-03-27T13:17:23.483,,0,,"<p>It rather depends whether you're tasked with simulating a full adder or emulating one. If you're emulating one, you can use the fact that the pins are (at least for most variants) assigned to the AVR ports and just have.</p>

<pre><code>void loop() {
    int a = (PORTB &gt;&gt; 3) &amp; 3; // take the two 'A' bits from the input port and make a number between 0 and 3
    int b = (PORTB &gt;&gt; 1) &amp; 3; // likewise for 'B'
    PORTD = ( a + b ) &lt;&lt; 4;   // add them together and shift to light the LEDs
}
</code></pre>

<p>Which is what I'd do if I didn't have a 7482 and wanted to emulate one.</p>

<p>If the objective is to demonstrate how a full adder is created by combining logic, then create that using the half adder logic <code>sum = a xor b</code> and <code>carry = a and b</code> and the full-adder logic <code>sum = ( a xor b ) xor c</code> and
<code>carry = ( a and b ) or ( c and ( a xor b ) )</code>.</p>

<pre><code>void loop() {
    // input a as two separate bits
    bool a0 = digitalRead(A0Pin);
    bool a1 = digitalRead(A1Pin);

    // input b as two separate bits
    bool b0 = digitalRead(B0Pin);
    bool b1 = digitalRead(B1Pin);

    // half adder for digit 0 of output sum and carry
    bool s0 = a0 ^ b0;
    bool c0 = a0 &amp; b0;

    // full adder for digit 1 of output sum and carry
    bool s1 = (a1 ^ b1) ^ c0;
    bool c1 = (a1 &amp; b1) | (c0 &amp; (a1 ^ b1));

    digitalWrite(LED0Pin, s0);
    digitalWrite(LED1Pin, s1);
    digitalWrite(LED2Pin, c1); // digit2 of output will be carry from digit 1
}
</code></pre>

<p>The difference here is that it's showing the working, and tells the instructor you've understood what an adder is for rather than just turning the truth table into a set of if statements. You might get away with it for a two-bit adder, but you don't want to be writing out all possible inputs and outputs of, say, an 8-bit adder by hand.</p>
",,,
49535098,2,49534008,2018-03-28T12:52:24.147,0,,865150,,2018-03-28T12:52:24.147,,0,,"<p>here is the answer to my question:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int convert(int dec)
{
    if (dec == 0)
    {
        printf(""Base c\n"");
        return 0;
    }
    else
    {
        printf(""Rec call\n"");
        return ((dec % 2) + 10 * convert(dec / 2));
    }
}

int main(int argc, char *argv[]) 
{
    // argc is number of arguments given including a.out in command line
    // argv is a list of string containing command line arguments

    int v = atoi(argv[2]);
    printf(""the number is:%d \n"", v);


    int bin = 0;

    if(v &gt;= 0 &amp;&amp; v &lt;= 15){
        printf(""Correct input \n"");
        bin = convert(v);
        printf(""Binary is: %04d \n"", bin);
    }
    else{
        printf(""Inorrect input, number cant be accepted"");
    }
}                                                       
</code></pre>

<p>the input: <code>$./a.out 3</code>
the output:</p>

<pre><code>the number is:3                                                                                                                    
Correct input                                                                                                                      
Rec call                                                                                                                           
Rec call                                                                                                                           
Base c                                                                                                                             
Binary is: 0011
</code></pre>
",,,
49541834,2,49540852,2018-03-28T18:37:33.050,1,,794749,,2018-03-28T18:37:33.050,,0,,"<p><code>alexander-productions.de/mysql</code> is not a valid host.<br>
Change it to <code>alexander-productions.de</code>.</p>

<p>Then add the folder to the request path i.e. <code>/mysql/post.php</code>.</p>

<p>It should look like:</p>

<pre class=""lang-cpp prettyprint-override""><code>const char* host = ""alexander-productions.de"";
</code></pre>

<pre class=""lang-cpp prettyprint-override""><code>client.println(""POST /mysql/post.php HTTP/1.1"");
client.print(""Host: "");
client.println(host); // non hardcoded host header
client.println(""Content-Type: application/x-www-form-urlencoded"");
client.print(""Content-Length: "");
client.println(data.length());
client.println();
client.print(data);
</code></pre>
",,,
49603544,2,49603470,2018-04-01T23:21:30.197,2,,2338547,,2018-04-01T23:21:30.197,,9,,"<p>I'll go ahead and give an answer here, there's an easier way to do this, which might be easier to get working in C.</p>

<pre><code>public class ConvertToBytes {
   public static void main( String[] args ) {
      final int i = 2000;
      System.out.println( ""Low byte:"" + (i &amp; 0xFF) );
      System.out.println( ""High byte:"" + (i&gt;&gt;8 &amp; 0xFF) );
   }
}
</code></pre>

<p>Output:</p>

<pre><code>run:
Low byte:208
High byte:7
BUILD SUCCESSFUL (total time: 2 seconds)
</code></pre>
",,,
49603814,2,49603470,2018-04-02T00:08:12.460,0,,1714692,,2018-04-02T00:08:12.460,,0,,"<p>Your C code is correct (on my PC it gives the result you expect). Also your output seems ok: divide the 2 bytes and check yourself.</p>

<pre><code>0: 0.00
0: 0.00
0: 0.00
0: 0.00
0: 0.00
1: 4.00
1: 2.00
1: 1.00

1: 128.00
1: 64.00
0: 0.00
1: 16.00
0: 0.00
0: 0.00
0: 0.00
0: 0.00
</code></pre>

<p>Rerun and Recheck the result of arduino. If the error persists might depend on the platform.</p>

<p>One thing I can think of is that int variables might be 16 bits so there might be problems summing/subtracting 2^15. I dont think its your case but use unsigned int type or long type.</p>
",,,
49636633,2,49635710,2018-04-03T18:11:35.487,0,,7726783,,2018-04-03T18:11:35.487,,0,,"<p>Solved it by using a simple for loop</p>

<pre><code>uint8_t i;

for (i = 0; i &lt; (uint8_t)(sizeof(privateKey)); i++) {
if (privateKey[i] &lt; 0x10) { /* To print ""0F"", not ""F"" */
  Serial.write('0');
}
Serial.print(privateKey[i], HEX);
}
</code></pre>
",,,
49854965,2,49749112,2018-04-16T10:23:00.710,0,,6721865,,2018-04-16T10:23:00.710,,2,,"<p>Once you know that the ports are ready to read or write, you can use the <code>read()</code> or <code>write()</code> methods. Alternatively, the <code>readLine()</code> and <code>readAll()</code> convenience methods can also be invoked. </p>

<p>If not all the data is read at once, the remaining data will be available for later as new incoming data is appended to the QSerialPort's internal read buffer. You can limit the size of the read buffer using <code>setReadBufferSize()</code>. </p>

<p>create a signal and slot. // do your stuff</p>

<p>// This is the answer for your question. read data from qt like this (given below).</p>

<pre><code>if(serial -&gt; canReadLine())
{
    QString str = serial -&gt; readAll();

    int var = str.toInt(); // convert into int

    // Read data and print or use progressBar to print data
}
</code></pre>
",,,
49785616,2,49785570,2018-04-11T23:05:13.583,3,,8731135,,2018-04-11T23:17:56.653,2018-04-11T23:17:56.653,0,,"<p>You should be able to do all you need using the std::chrono library (since c++11)</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt; 
int main()
{
    auto start = std::chrono::system_clock::now();
    do_sth();
    auto end = std::chrono::system_clock::now();
    std::cout &lt;&lt; ""do_sth() ""
                  &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()
                  &lt;&lt; ""ms.\n"";
}
</code></pre>
",,,
49801993,2,49801361,2018-04-12T16:47:01.187,0,,7958185,,2018-04-12T16:47:01.187,,0,,"<p>I have temporary really massy way to fix it but if this is possible any other way let me know</p>

<pre><code>string = """"
final = """"
num = 0

while(True):
   string = sock.recv(4096)
   if str(string) == ""b'$'"":
      num=1
   elif num == 1:
      final+=str(string)
      num = 2
   elif num == 2:
      final += str(string)
      final = final.replace((""b""), """")
      final = final.replace((""'""), """")
      print(final)
      final = """"
      num == 0
</code></pre>
",,,
49807739,2,49807644,2018-04-13T00:46:11.407,1,,3629249,,2018-04-14T04:40:20.950,2018-04-14T04:40:20.950,3,,"<p>regarding: </p>

<pre><code>{ system(""irsend SEND_ONCE newremote KEY_2 &amp;&amp; gpio mode 6 output &amp;&amp; gpio write 6 1""); }
</code></pre>

<p>It would be much better to place such a statement in a separate function <code>yourexitfun</code>, then the first statement in main() should be: </p>

<pre><code>atexit( yourexitfun );
</code></pre>

<p>====================</p>

<p>regarding:</p>

<pre><code>int main( int argc, char **argv )
{
     {
          system(""irsend SEND_ONCE newremote KEY_2 &amp;&amp; gpio mode 6 output  &amp;&amp; gpio write 6 1"");
     }
     {
         atexit( system(""irsend SEND_ONCE newremote KEY_1 &amp;&amp; gpio write 6 0"") );
     }
</code></pre>

<p>is, as you have seen, not correct.  Suggest:</p>

<pre><code>// prototypes
void myexitFunction( void );

int main( int argc, char **argv )
{
     atexit( myexitFunction );

     system(...);

     //.... rest of your code;
     return 0;
}

void myexitFunction( void )
{
    system( system( ""irsend SEND_ONCE newremote KEY_2 &amp;&amp; gpio mode 6 output &amp;&amp; gpio write 6 1"" );
}
</code></pre>
",,,
49807822,2,49807644,2018-04-13T01:00:01.130,-1,,4178713,,2018-04-13T01:00:01.130,,4,,"<p>You can try to use SIGTERM and run you command inside handler function</p>

<pre><code>    #include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void term(int signum)
{
system(""irsend SEND_ONCE newremote KEY_2 &amp;&amp; gpio mode 6 output &amp;&amp; gpio write 6 1);
}

int main(int argc, char *argv[])
{
    struct sigaction action;
    memset(&amp;action, 0, sizeof(struct sigaction));
    action.sa_handler = term;
    sigaction(SIGTERM, &amp;action, NULL);
    return 0;
} 
</code></pre>
",,,
49807859,2,49807644,2018-04-13T01:06:09.340,5,,4756299,,2018-04-13T01:06:09.340,,7,,"<p>This code is almost certainly a syntax error:</p>

<pre><code>{
  atexit( system(""irsend SEND_ONCE newremote KEY_1 &amp;&amp; gpio mode 6 output &amp;&amp; gpio write 6 0"") );
}
</code></pre>

<p>I'm not certain what part(s) of the C standard it violates, but it's not valid C code.</p>

<p>The <a href=""https://port70.net/~nsz/c/c11/n1570.html#7.22.4.2"" rel=""noreferrer"">prototype for <code>atexit()</code></a> is</p>

<pre><code>int atexit(void (*func)(void));
</code></pre>

<p>With this as part of its description:</p>

<blockquote>
  <p>The <code>atexit</code> function registers the function pointed to by <code>func</code>, to
  be called without arguments at normal program termination.</p>
</blockquote>

<p>That means something like this:</p>

<pre><code>void myExitFunc( void )
{
    system( ""irsend ..."" )
}

...

    atexit( myExitFunc );

...
</code></pre>

<p>The function registered with <code>atexit()</code> takes no arguments, and it does not return a value - that's what <code>void (*func)(void)</code> mean: ""a pointer to a function that takes no arguments and returns no value"".</p>

<p>You certainly can't specify arguments at the time you call <code>atexit()</code> to be supplied to such a function when it's called upon program termination.</p>
",,,
49851511,2,49849983,2018-04-16T07:16:00.177,0,,3308570,,2018-04-16T07:50:19.873,2018-04-16T07:50:19.873,0,,"<p>Here is a basic demo of making HTTP request(GET) with Qt GUI by using <a href=""http://doc.qt.io/qt-5/qnetworkaccessmanager.html"" rel=""nofollow noreferrer"">QNetworkAccessManager</a>. For further implementation, you can catch 
 reply via <code>QNetworkReply</code> from the <code>WiFiServer</code>.</p>

<pre><code>#include &lt;QApplication&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QWidget* w = new QWidget;
    QVBoxLayout* layout = new QVBoxLayout;
    QPushButton* on = new QPushButton(""On"");
    QPushButton* off = new QPushButton(""Off"");
    layout-&gt;addWidget(on);
    layout-&gt;addWidget(off);
    w-&gt;setLayout(layout);

    QNetworkAccessManager *manager = new QNetworkAccessManager();

    QObject::connect(on, &amp;QPushButton::clicked,
                     [manager](){
        manager-&gt;get(QNetworkRequest(QUrl(""http://192.168.1.xxx/LED=ON"")));
    });

    QObject::connect(off, &amp;QPushButton::clicked,
                     [manager](){
        manager-&gt;get(QNetworkRequest(QUrl(""http://192.168.1.xxx/LED=OFF"")));
    });

    w-&gt;show();

    return a.exec();
}
</code></pre>
",,,
50115162,2,49860173,2018-05-01T10:46:35.097,2,,8386985,,2018-05-01T10:46:35.097,,0,,"<p>You can use <a href=""https://www.arduino.cc/en/Reference/Ethernet"" rel=""nofollow noreferrer"">Ethernet / Ethernet 2 library</a> in order to make RESTful API calls from Arduino to a Thingworx server through ethernet or wifi shields.</p>

<p>Here is a sample (ethernet) implementation for your reference:</p>

<pre><code>#include &lt;Ethernet2.h&gt;
#include &lt;EthernetClient.h&gt;
#include &lt;EthernetUdp2.h&gt;
#include &lt;util.h&gt;

IPAddress _ip(192, 168, 1, 12); // Client (Arduino) IP address
byte _mac[] = {0x90, 0xA2, 0xDA, 0x11, 0x3C, 0x69}; // Arduino mac address
char _server[] = ""192.168.1.10""; // Server IP address
int _port = 9200; // Server port number
EthernetClient _client;

void setup() {    
  Ethernet.begin(_mac, _ip);
  delay(1000);
  Serial.print(""Local IP: "");
  Serial.println(Ethernet.localIP());

  if (_client.connect(_server, _port)) {
    Serial.println(""SUCCESS: Connected to the server!"");
  } else {
    Serial.println(""ERROR: Connection failed to the server!"");
    return;
  }
  delay(1000);
}

void loop() {       
  // JSON formatted data package including sample UID and newValue 
  String payload = ""{\""uid\"": "" + String(uid) + "", "" +
                   ""\""data\"": "" + String(newValue) + ""}"";

  String url = ""/my-api/updatedata""; // API url hosted on the server

  // Finally, make an API call: PUT request
  _client.print(""PUT "" + url + "" HTTP/1.1 \r\n"" +
    ""Content-Type: application/json \r\n"" +
    ""Content-Length: "" + payload.length() + "" \r\n"" +
    ""\r\n"" + payload);

  delay(500); // Give the network some time

  // Read all the lines of the reply from server and 
  // print them to Serial to validate your API call
  while (_client.available()) {
    String reply = _client.readStringUntil('\r');
    Serial.print(reply);
  }
  Serial.println();
}
</code></pre>
",,,
49868924,2,49868762,2018-04-17T02:26:11.533,2,,6575139,,2018-04-17T02:26:11.533,,0,,"<p>You could use a <code>while</code>-loop and only increment when the chip is found:</p>

<pre><code> int i = 0;

 while (i &lt; 5)
 {
    delay(1000);
    if(nfc.tagPresent())
    {
      int myPins[] = {2, 4, 8, 3, 6};
      Serial.println(myPins[i]);
      i = i + 1; // increment only if tag is present.
    }
  }
</code></pre>

<p>Note that <code>myPins</code> could be defined once outside of the loop, which would make the loop faster:</p>

<pre><code> int i = 0;
 int myPins[] = {2, 4, 8, 3, 6};

 while (i &lt; 5)
 {
    delay(1000);
    if(nfc.tagPresent())
    {
      Serial.println(myPins[i]);
      i = i + 1; // increment only if tag is present.
    }
  }
</code></pre>
",,,
49910938,2,49910084,2018-04-19T00:35:28.200,1,,773334,,2018-04-19T04:57:34.283,2018-04-19T04:57:34.283,2,,"<p>To answer the question:</p>

<p><strong>You can't, because C++ is a compiled language</strong>, and as such, the names of the functions, objects and variables become meaningless (instead, they become just addresses)</p>

<p>For example, you may see in your code</p>

<pre><code> int myVariable = 6;
</code></pre>

<p>but the compiler sees:</p>

<pre><code> mov [6], [0x6874]
</code></pre>

<p>Read <a href=""https://stackoverflow.com/questions/3265357/compiled-vs-interpreted-languages"">Compiled vs. Interpreted Languages</a> for more reference.</p>

<p><em>[For your particular case]</em></p>

<p>You'll be better off if you use interfaces and a factory.</p>

<pre><code>class Mode {
    virtual int getAttribute() = 0;
}

class AMeaningfulName : public Mode {
    int getAttribute()  { return 1; }
}

class SelectAnotherMeaningfulNamePlease : public Mode {
    int getAttribute() { return 2; }
}

class ModeFactory {
    Mode getMode(int userSelectedMode) {

        if (userSelectedMode == MODE_1) {
            return new AMeaningfulMode();
        } else if (userSelectedMode == MODE_2) {
            return new SelectAnotherMeaningulNamePlease();
        } else {
            //send an exception so the user knows he selected something invalid
        }
    }
}


///now, in your main or elsewhere
ModeFactory factory = new ModeFactory();
Mode mode = factory.getMode(userSelectedValue);
int theAtttributeIWanted = mode.getAttribute();
</code></pre>

<p>Take a look at virtual functions
<a href=""https://en.wikipedia.org/wiki/Virtual_function"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Virtual_function</a></p>

<p>And also at factory pattern
<a href=""https://www.tutorialspoint.com/design_pattern/factory_pattern.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/design_pattern/factory_pattern.htm</a></p>
",,,
49949088,2,49945681,2018-04-20T20:13:14.877,0,,9409372,,2018-04-20T20:13:14.877,,1,,"<p>I assume that your keyboard is detected by the kernel.</p>

<p>If you want to read read a character from the standard input you can choose one of the following functions which do so</p>

<ul>
<li>int fgetc(FILE *stream);</li>
<li>int getc(FILE *stream);</li>
<li>int getchar(void);</li>
</ul>

<p>These functions are listed in the <a href=""https://linux.die.net/man/3/getchar"" rel=""nofollow noreferrer"">manual page section 3 of getchar</a>.
Here is a little program that serves to provide an idea how to use one of these functions. It takes an input string from your console and prints the individual characters one per line.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])  
{
    printf(""Enter some keys\n"");
    char c;
    while((c = getchar()) != 13)   /* 13 is carriage ret in ascii, enter key */     
        printf(""%c\n"", c); 

    return 0;
}
</code></pre>
",,,
49959012,2,49958758,2018-04-21T18:33:59.470,0,,9296351,,2018-04-21T18:43:47.427,2018-04-21T18:43:47.427,1,,"<p>Suppose if you have a 2-D array of (m x n) order then create a new array of order (n x m). This can be done by using a nested loop to iterate through the array of order (n x m) and copy the elements of the array of order (m x n) so all you have to do is---></p>

<p>a[m][n] -----> Initial array(Input)
b[n][m] -----> New required array(output-Transpose)</p>

<pre><code>for(int i=0;i&lt;n;i++)
{
    for(int j=0;j&lt;m;j++)
    {
        b[i][j]=a[j][i];
    }
}
</code></pre>

<p>Thus, this gives you the required array b[n][m] which is the transpose of a.</p>
",,,
50004515,2,49973341,2018-04-24T14:42:59.290,1,,4100891,,2018-04-24T14:42:59.290,,2,,"<blockquote>
  <p>it shows the current speed once, then fails to update. Any idea?</p>
</blockquote>

<p>Your sketch is spending all its time updating the display and waiting.  Here's what's happening:</p>

<p>1)  When one character is available, it gets read and passed to <code>encode</code>.</p>

<p>2)  Then it updates the display, which takes some amount of time.  You didn't give us the whole program nor identify the hardware, so I cant really say how long it takes.</p>

<p>3)  Then it waits 50ms.  During this time, GPS characters continue to arrive.  They will be stored in the input buffer until <code>read()</code> is called, <em>OR</em> until 64 characters have been stored.  THEN THEY WILL BE DROPPED.</p>

<p>At 9600 (I am guessing), 50 characters could have arrived.  Now the input buffer is almost full.</p>

<p>4)  The <code>while</code> loop test executes again, and a second character is read and parsed (step 1), the display is updated (no new info is available, step 2), and it waits another 50ms.</p>

<p>After 15ms, the input buffer is full, and the Arduino begins ignoring characters.  When the 50ms delay completes, 35 characters have been lost (at 9600).</p>

<p>This prevents a successful parse of the received (partial) NMEA sentences, and the speed will not get updated.  The sketch will continue to update the display with old information, and then wait some more, which causes more character loss.</p>

<p>The loop structure needs to be reworked so that the display is only updated when new information is available, and you should never use delay:</p>

<pre><code>#include &lt;LiquidCrystal.h&gt; ???
LiquidCrystal display;     ???

#include &lt;NMEAGPS.h&gt;

NMEAGPS gps;
gps_fix fix;

//  Here are three different ways to connect the GPS:
#define gpsPort Serial1

//#include &lt;AltSoftSerial.h&gt;
//AltSoftSerial gpsPort; // two specific pins required (8 &amp; 9 on an UNO)

//#include &lt;NeoSWSerial.h&gt;
//NeoSWSerial gpsPort( 3, 4 );


void setup()
{
  Serial.begin( 9600 );
  gpsPort.begin( 9600 );
}

void loop()
{
  // Read and parse any available characters from the GPS device
  if (gps.available( gpsPort )) {

    // Once per second, a complete fix structure is ready.
    fix = gps.read();

    Serial.print( F(""Speed: "") );
    float speed = 0.0;
    if (fix.valid.speed) {
      speed = fix.speed_kph() * 1000.0 / 3600.0;
      Serial.print( speed );
    }
    Serial.println();

    Serial.print( F(""Sats: "") );
    if (fix.valid.satellites)
      Serial.println( fix.satellites );
    Serial.println();

    //  Update the display ONCE PER SECOND

    display.clearDisplay();  // clears last number
    display.display();  // writes clear to screen
    display.setCursor(10, 5);  //Set drawing posision
    if (fix.valid.speed)
      display.print( speed );  // what to draw
    display.setCursor(35, 5);
    display.print("" MPS"");
    display.setCursor(10, 18);
    if (fix.valid.satellites)
      display.print( fix.satellites );
    display.setCursor(35, 18);
    display.print("" Sat"");
    display.display(); // writes to the screen
  }
}
</code></pre>

<p>This uses my <a href=""https://github.com/SlashDevin/NeoGPS"" rel=""nofollow noreferrer"">NeoGPS</a> library.  It is smaller, faster, more reliable and more accurate than all other GPS libraries.  Even if you don't use it, you should read the related pages about <a href=""https://github.com/SlashDevin/NeoGPS/blob/master/extras/doc/Installing.md#2-choose-a-serial-port"" rel=""nofollow noreferrer"">choosing a serial port</a> and <a href=""https://github.com/SlashDevin/NeoGPS/blob/master/extras/doc/Troubleshooting.md"" rel=""nofollow noreferrer"">troubleshooting</a>.</p>

<p>NeoGPS, AltSoftSerial and NeoSWSerial are all available from the Arduino IDE Library Manager, under the menu <strong>Sketch -> Include Library -> Manage Libraries</strong>.</p>
",,,
49992358,2,49989844,2018-04-24T01:58:52.933,0,,9687941,,2018-04-24T01:58:52.933,,0,,"<p>The issue was using delay(). How exactly the hardware works, I'm not sure, but I believe blocking it in such a way threw off the hardware so that it was outputting null. Below is the corrected code using millis().</p>

<pre><code>#include &lt;Wire.h&gt;
#include &lt;Adafruit_MotorShield.h&gt;
#include ""utility/Adafruit_MS_PWMServoDriver.h""
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *myMotor = AFMS.getMotor(1);
#include &lt;SPI.h&gt;
#include &lt;Adafruit_LIS3DH.h&gt;
#include &lt;Adafruit_Sensor.h&gt;
Adafruit_LIS3DH lis = Adafruit_LIS3DH();
//The sample code for driving one way motor encoder
const byte encoder0pinA = 2;//A pin -&gt; the interrupt pin 0
//byte encoder0PinALast;
int duration;//the number of the pulses
//unsigned long timeold;
unsigned int pulsesperturn = 56 * 64 / 2;
float widthDetector = 10; //distance needed, in cm
float circumference = 5.25 * 3.14159;
float pulses;
int count = 0;
#define pi 3.14159
float angle;
const long interval = 1000;
unsigned long previousMillis;


//bool answered = 0;
//float distanceTotal = 100;
//float waitTime = 0.01;
//unsigned int pulsesper100forward = 56 * 64 ;
//unsigned int pulsesper100back = 56 * 64 ;
int b = 0;
float conversion = 171 / 169;


#if defined(ARDUINO_ARCH_SAMD)
// for Zero, output on USB Serial console, remove line below if using programming port to program the Zero!
#define Serial SerialUSB
#endif



void setup(void)
{
#ifndef ESP8266
  while (!Serial);     // will pause Zero, Leonardo, etc until serial console opens
#endif


  Serial.begin(9600);
  AFMS.begin();
  Serial.println(""LIS3DH test!"");
  if (! lis.begin(0x19)) {   // change this to 0x19 for alternative i2c address
    Serial.println(""Couldnt start"");
    while (1);
  }
  Serial.println(""LIS3DH found!"");
  lis.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!


  //  myMotor-&gt;run(FORWARD);
  myMotor-&gt;setSpeed(255); // this will end up changing but is constant for testing validation purposes
}

void loop() {
  motorDirection();
  //    stoppedAccel();
}

void counter()
{
  pulses++;
}

void bcounter()
{
  b++;
}

void motorDirection()
{
  //serial.write
  while (b &lt; 6) {
    myMotor-&gt;run(FORWARD);
    readInt();
    if (500 * conversion &lt;= pulses) {
      myMotor-&gt;run(RELEASE);
      bcounter();
      previousMillis = millis();
      timing();
      //      previousMillis = currentMillis;

      pulses = 0;

      if (b == 6) {
        stoppedAccel();
      }
    }
    break;

  }

  while (b == 6) {
    myMotor-&gt;run(BACKWARD);
    readInt();
    if (500 * b &lt;= pulses) {
      myMotor-&gt;run(RELEASE);
      pulses = 0;
      bcounter();
      stoppedAccel();

      break;
    }
  }
  while (b &gt; 6) {
    b = 0;
    break;
  }

}

// 169 forward per 1000, 171 backward

void stoppedAccel()
{
  for (int a = 1; a &lt; 200; a = a + 1) {
    lis.read();      // get X Y and Z data at once
    sensors_event_t event;
    lis.getEvent(&amp;event);
    angle = asin(event.acceleration.z / 9.81) * 180  / pi  ;

    Serial.print(""  \tAngle:  ""); Serial.print(angle);
    //
    //  Serial.print(""\t\tX: ""); Serial.print(event.acceleration.x);
    //    Serial.print("" \tY: ""); Serial.print(event.acceleration.y);
    //    Serial.print("" \tZ: ""); Serial.print(event.acceleration.z);
    //      Serial.println("" m/s^2 "");
    Serial.println();
    //
    //  char buffer[5];
    //  Serial.print(""#S|WRITEDATA|["");
    //  Serial.print(angle); // accels
    //  Serial.println(""]#"");
    delay(10);
  }
}

void readInt()
{
  attachInterrupt(digitalPinToInterrupt(encoder0pinA), counter, RISING);
  Serial.print(""pulses = "");
  Serial.println(pulses);
}

void timing()
{
  while (millis() - previousMillis &lt;= interval) {
    myMotor-&gt;run(RELEASE);
  }
}
</code></pre>
",,,
50123250,2,50063974,2018-05-01T20:19:17.447,0,,2802266,,2018-05-02T05:50:48.547,2018-05-02T05:50:48.547,0,,"<p>Two approaches suggested: </p>

<ol>
<li><p>Array pre-defined with fixed size</p>

<pre><code>#define MAX_ITENS 50       // The size of buffer
uint8_t buffer[MAX_ITENS]; // The Buffer
uint8_t posBuffer = 0;     // Pointer to actual position

loop() {
    .... 
    // Add data to buffer
    posBuffer++;

    if (posBuffer == MAX_ITENS) {
        // Buffer overflow - You can set position to 0 
        // or give some error
    } else {
        buffer[posBuffer] = data; // Save the data
    }
}
</code></pre></li>
<li><p>Use a dynamic array library I like <a href=""https://github.com/zacsketches/Arduino_Vector"" rel=""nofollow noreferrer"">this one</a>.</p></li>
</ol>
",,,
50133916,2,50091499,2018-05-02T11:45:22.187,1,,2539867,,2018-07-19T05:51:41.627,2018-07-19T05:51:41.627,2,,"<p>Seems like you caught a real compiler bug here!</p>

<p><strong>GCC version:</strong></p>

<p>avr-gcc (GCC) 4.8.1</p>

<p><em>(with -O1 or -O2 optimizations enabled, at -O0 the problem doesn't seem to be present)</em></p>

<p><strong>Reduced test case:</strong></p>

<pre><code>#include &lt;stdint.h&gt;


uint8_t volatile tmp;


__attribute__((noinline)) void test_64(uint64_t d64)
{
 if ((d64 &amp; 0xFF800000UL) == 0xFF800000UL){
  tmp ++;
 }
}

__attribute__((noinline)) void test_32(uint32_t d32)
{
 if ((d32 &amp; 0xFF800000UL) == 0xFF800000UL){
  tmp ++;
 }
}


int main(void)
{
 test_64(0);
 test_32(0);

 while(1);
}
</code></pre>

<p><strong>Assembler output for the critical part:</strong></p>

<pre><code>00000228 &lt;test_64&gt;:
 228:   08 95           ret

0000022a &lt;test_32&gt;:
 22a:   66 27           eor r22, r22
 22c:   77 27           eor r23, r23
 22e:   80 78           andi    r24, 0x80   ; 128
 230:   61 15           cp  r22, r1
 232:   71 05           cpc r23, r1
 234:   80 48           sbci    r24, 0x80   ; 128
 236:   9f 4f           sbci    r25, 0xFF   ; 255
 238:   09 f0           breq    .+2         ; 0x23c &lt;test_32+0x12&gt;
 23a:   08 95           ret
 23c:   80 91 00 20     lds r24, 0x2000
 240:   8f 5f           subi    r24, 0xFF   ; 255
 242:   80 93 00 20     sts 0x2000, r24
 246:   08 95           ret

00000248 &lt;main&gt;:
 248:   20 e0           ldi r18, 0x00   ; 0
 24a:   30 e0           ldi r19, 0x00   ; 0
 24c:   40 e0           ldi r20, 0x00   ; 0
 24e:   50 e0           ldi r21, 0x00   ; 0
 250:   60 e0           ldi r22, 0x00   ; 0
 252:   70 e0           ldi r23, 0x00   ; 0
 254:   80 e0           ldi r24, 0x00   ; 0
 256:   90 e0           ldi r25, 0x00   ; 0
 258:   0e 94 14 01     call    0x228   ; 0x228 &lt;test_64&gt;
 25c:   60 e0           ldi r22, 0x00   ; 0
 25e:   70 e0           ldi r23, 0x00   ; 0
 260:   cb 01           movw    r24, r22
 262:   0e 94 15 01     call    0x22a   ; 0x22a &lt;test_32&gt;
 266:   ff cf           rjmp    .-2         ; 0x266 &lt;main+0x1e&gt;
</code></pre>

<p><strong>Observation</strong></p>

<p>For 32 bits the correct code is generated. For 64 bits, no comparison is performed at all, the code compiles as if the result of the <code>if</code> was always false. A native GCC compiles both functions correctly.</p>

<p>You should probably avoid using 64 bits variables in your code.</p>

<p>The bug is now confirmed on the GCC bugtracker, you may follow it here:</p>

<p><a href=""https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85805"" rel=""nofollow noreferrer"">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85805</a></p>

<p>So at the time of writing all sufficiently modern avr-gcc versions are affected until this gets fixed.</p>
",,,
50106880,2,50106781,2018-04-30T19:22:10.410,0,,9710796,,2018-04-30T19:22:10.410,,3,,"<p>As pointed out in the comment you are basically missing the point of curly braces. But since you mentioned you are new to all of this:
A conditional can be written the following way and the curly braces cover the scope for it. (Infact they cover scope anywhere else too).</p>

<pre><code>if (something)
{
    Do some other thing.
    Do some thing else.
}
Do this anyways.
</code></pre>

<p>And by modifying your code with this logic, you should be able to fix your issues.</p>
",,,
50144915,2,50144855,2018-05-02T23:29:09.823,2,,1854114,,2018-05-02T23:52:29.603,2018-05-02T23:52:29.603,8,,"<p>Yes there is.</p>

<p>Do something like this:</p>

<pre><code>String testString = ""Test String"";
uint8_t* pointer = (uint8_t*)testString.c_str();
int length = testString.length();
</code></pre>

<p>EDIT:</p>

<p>You should apply it to your problem as follows:</p>

<pre><code>String testString = ""Test String"";
uint8_t* pointer = (uint8_t*)testString.c_str();
int length = testString.length();

ZBTxRequest txReq = ZBTxRequest(coordinatorAddr64, pointer, length);   
ZBTxStatusResponse txResp = ZBTxStatusResponse();

xbee.send(txReq);
</code></pre>
",,,
50144935,2,50144855,2018-05-02T23:32:44.853,1,,8746007,,2018-05-02T23:58:24.220,2018-05-02T23:58:24.220,0,,"<p>You can write your array like this:</p>

<pre><code>uint8_t testCmd[] = R""({""T"":""A1"",""E"":-1,""I"":[[1,[[[[250,2],[0,4]]]]]]})"";
</code></pre>

<p>The difference is that it will have 48 elements instead of 47 like your original one, because of terminating 0. Since you are providing the length of packet you could -1 it:</p>

<pre><code>ZBTxRequest txReq = ZBTxRequest(coordinatorAddr64, testCmd, sizeof(testCmd) - 1);   
ZBTxStatusResponse txResp = ZBTxStatusResponse();

xbee.send(txReq);
</code></pre>

<p>Looking at Arduino reference. <code>String</code> object has <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/c_str/"" rel=""nofollow noreferrer"">c_str()</a> method as well as <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/length/"" rel=""nofollow noreferrer"">length()</a>. So you can simply try:</p>

<pre><code>String testCmd R""({""T"":""A1"",""E"":-1,""I"":[[1,[[[[250,2],[0,4]]]]]]})"";

ZBTxRequest txReq = ZBTxRequest(coordinatorAddr64, (uint8_t *)testCmd.c_str(), (uint8_t)testCmd.length());   
ZBTxStatusResponse txResp = ZBTxStatusResponse();

xbee.send(txReq);
</code></pre>
",,,
50169703,2,50155041,2018-05-04T07:41:44.500,0,,8546089,,2018-05-04T07:54:28.553,2018-05-04T07:54:28.553,1,,"<p>In the Azure IoT SDK for C,it uses serializer library to serialize messages to send, but there is no couterpart(DESERIALIZE) for receiving messages.Please see 
<a href=""https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-device-sdk-c-serializer"" rel=""nofollow noreferrer"">more about serializer</a>. In serializer component, you will find <strong>jsondecoder.c</strong>, it defines some method for decode json data.</p>

<p>And more, you will find the <a href=""https://github.com/kgabis/parson/tree/bef4969d258d5bcce0d686b7bf514550e2ac346d"" rel=""nofollow noreferrer"">parson</a> component. It can be used to deserialize the object from json string.You can refer to the following code.</p>

<p><strong>jsonstr</strong></p>

<pre><code>{""desString"":""P7svG%2BLoUZEbB8Le5jP1%2BpuX2OVWLE4xWMzFcYFCRvNvDlcFVm%2B8z2VFO%2F%2BaEB8UAMa%2FZ0GGhooGNMWFE98Zmw%3D%3D"",""caller"":{""mobile"":""13996130361""},""accountId"":""b5091dc91d700c6bf714e5fc446797d3"",""tmpTime"":1428545890,""otherParam"":""{id:12}"",""participant"":[{""mobile"":""18623582801""}],""servletUrl"":""http://192.168.1.1:8090/xdr""}
</code></pre>

<p><strong>C Code</strong></p>

<pre><code>JSON_Value *root_value=NULL;
root_value = json_parse_string(jsonstr);
JSON_Object *root_object;
if(json_value_get_type(root_value) == JSONObject)
{
    root_object = json_value_get_object(root_value);
    const char *desString = json_object_get_string(root_object, ""desString"");
    if(desString!=NULL)strncpy(pPost-&gt;desString,desString,LENGTH128-1);
    const char *accountId = json_object_get_string(root_object, ""accountId"");
    if(accountId!=NULL)strncpy(pPost-&gt;accountId,accountId,LENGTH32);
    double tmpTime = json_object_get_number(root_object, ""tmpTime"");
    const char *caller = json_object_dotget_string(root_object,""caller.mobile"");
    if(caller!=NULL)strncpy(pPost-&gt;caller,caller,LENGTH16-1);
    const char *servletUrl = json_object_dotget_string(root_object,""servletUrl"");
    if(servletUrl!=NULL)strncpy(pPost-&gt;servletUrl,servletUrl,LENGTH128-1);
    const char *otherParam = json_object_dotget_string(root_object,""otherParam"");
    if(otherParam!=NULL)strncpy(pPost-&gt;otherParam,otherParam,LENGTH128-1);

    JSON_Array *array;
    array = json_object_get_array(root_object, ""participant"");
    int i =0;
    for(i;i&lt;json_array_get_count(array);i++)
    {
        JSON_Object *tmp = json_array_get_object(array,i);
        if(tmp!=NULL)
        {
            const char *mobile = json_object_get_string(tmp,""mobile"");
            if(mobile!=NULL)strncpy(pPost-&gt;callee,mobile,LENGTH16-1);
        }
    }
}
if(root_value)json_value_free(root_value);
</code></pre>
",,,
50158247,2,50158033,2018-05-03T15:03:02.150,1,,9657552,,2018-05-03T15:03:02.150,,3,,"<p>Use <code>std::thread</code> to launch <code>call5sFunct();</code> in other thread, like this:</p>

<pre><code>//...
initFirst();

//here I need to call ""non-blocking"" function with no delay and process immediatelly further
std::thread t1(call5sFunct);
t1.detach();  
...do other functions here immediatelly without 5s delay...

//...
</code></pre>

<p>You need to include <code>#include &lt;thread&gt;</code></p>
",,,
50170987,2,50158033,2018-05-04T08:54:43.373,0,,1168733,,2018-05-04T08:54:43.373,,0,,"<p>You must not sleep at all, but just call your function after 5 seconds have passed, in the loop function. Something like this (untested):</p>

<pre><code>unsigned long start_time = 0;
bool call5sFunct_executed = false;

void meInit()
{ 
  if (total &gt; 20) total = 20;
  value = EEPROM.read(1);

  Serial.begin(115200);
  Serial.setTimeout(10);

  loadSettings(true);

  buildMe();

  initFirst();

  // You cannot call it here, but in loop()
  // call5sFunct();  

  // ...do other functions here immediatelly without 5s delay...
}

void call5sFunct()
{
  DEBUG_PRINTLN(""I am back again"");
}

void loop()
{
   unsigned long loop_time = millis();
   if (!call5sFunct_executed &amp;&amp; (loop_time - start_time &gt;= 5000))
   {
      call5sFunct();
      call5sFunct_executed = true;
   }
   // .... the rest of your loop function ...
}
</code></pre>

<p>However, this template must be used extensively programming microcontrollers. It would be really coumbersome and error-prone to write production code like this - but it's important you get the point.</p>

<p>There are many libraries that make it easy to implement asynchronous operations on arduino, hiding this mechanism. For example take a look to <a href=""https://playground.arduino.cc/Code/TaskScheduler"" rel=""nofollow noreferrer"">TaskScheduler</a>.</p>

<p>Google for ""arduino asynchronous functions"" and you will find a lot of alternatives.</p>
",,,
50179256,2,50178804,2018-05-04T16:16:55.357,4,,434551,,2018-05-04T16:16:55.357,,2,,"<p>Unless there is a pressing need for you to use a <code>union</code>, don't use it. Simplify your class to:</p>

<pre><code>struct twoSixByte
{
   twoSixByte(uint8_t in) : twoPart((in &amp; 0xC0) &gt;&gt; 6), sixPart(in &amp; 0x3F) {}
   uint8_t twoPart : 2;
   uint8_t sixPart : 6;
};
</code></pre>

<p>If there is a need to get the full byte, you can use:</p>

<pre><code>uint8_t fullByte(twoSixByte mixedByte)
{
   return ((mixedByte.twoPart &lt;&lt; 6) | mixedByte.sixPart);
}
</code></pre>
",,,
50179291,2,50178804,2018-05-04T16:18:59.087,2,,1460794,,2018-05-04T16:24:46.503,2018-05-04T16:24:46.503,2,,"<p>You could avoid the <code>union</code> and <a href=""https://stackoverflow.com/a/25672839/1460794"">type punning</a> and use a struct with the relevant member function. Note that we don't need a constructor if the <code>struct</code> is regarded as an <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow noreferrer"">aggregate to be initialized</a>:</p>

<pre><code>#include &lt;cstdint&gt;

struct twoSixByte {
    uint8_t fullByte; // no constructor needed, initializing as an aggregate
    uint32_t extractByte(){
        return ((fullByte &amp; 0b1100'0000) &gt;&gt; 6) * (fullByte &amp; 0b0011'1111);
    }
};


int main()
{
    twoSixByte tnum{182};
    auto test = tnum.extractByte(); // test == 2 * 54 == 108
}
</code></pre>
",,,
50190846,2,50190574,2018-05-05T15:04:33.380,4,,1084774,,2018-05-05T15:04:33.380,,0,,"<p>The implicit declaration error just means your compiler proper doesn't have a declaration for <code>printf</code>. Unless you're also getting a linker error, the linker (linking usually follows compilation, unless you pass <code>-c</code> to disable it) is probably slapping the standard lib right on, in which case you can simply solve your warning by including <code>stdio.h</code> or less preferably by declaring <code>int printf(char const*, ...);</code>.</p>

<p>If you trully don't have the standard lib, you'll need to convert the integer to a string manually with something like:</p>

<pre><code>int n = 42;
char buf[20];
char *end = buf+(sizeof(buf)-1), *p = end;
*p--=0;
if(n==0) *p=='0';
else{
    while(n){
        printf(""%d\n"", n%10);
        *p--=n%10+'0'; 
        n/=10;
    }
    p++;
}
</code></pre>

<p>and then pass it to your system's raw IO routine for which you'll need to have set up the system-entering assembly.</p>

<p>If you don't have a system, it'd be even more technical, and you probably wouldn't be asking this question.</p>
",,,
50203140,2,50203086,2018-05-06T18:25:37.083,2,,7735711,,2018-05-06T18:25:37.083,,2,,"<p>Years ago when I was working on a C++ project happened to me too. Defining classes solved the problem.</p>

<p>You can see my example files here:</p>

<p><a href=""https://github.com/tkduman/project-x/blob/master/monster.h"" rel=""nofollow noreferrer"">https://github.com/tkduman/project-x/blob/master/monster.h</a></p>

<p><a href=""https://github.com/tkduman/project-x/blob/master/player.h"" rel=""nofollow noreferrer"">https://github.com/tkduman/project-x/blob/master/player.h</a></p>

<p>They have <code>class monster;</code> and <code>class player;</code> in each other, otherwise it won't work.</p>

<p>Try to update your files as:</p>

<p>CDFrame.h file:</p>

<pre><code>class CDScreen; // add this
#include ""CDScreen.h""
#include &lt;stdint.h&gt;

class CDFrame {
public:
    CDFrame(uint8_t capacity);
    virtual ~CDFrame();

private:
    uint8_t capacity = 0;
    CDScreen* parent = nullptr; //&lt;- Parent property of CDScreen class
}
</code></pre>

<p>CDScreen.h file:</p>

<pre><code>class CDFrame; // add this
#include ""CDFrame.h""
#include &lt;stdint.h&gt;

class CDScreen {
public:
    CDScreen(uint8_t capacity);
    virtual ~CDScreen();
    void addFrame(CDFrame* frame); // Sets the frame's parent (this CDScreen) when a new frame is added 

private:
    uint8_t capacity = 0;
    uint8_t size = 0;
    CDFrame** frames;   
}
</code></pre>
",,,
50203306,2,50203086,2018-05-06T18:43:51.670,2,,4402721,,2018-05-06T18:54:58.070,2018-05-06T18:54:58.070,1,,"<p>The problem is that C++ is declare before use, so any type must be declared before it can be used. (Where ""before"" means ""above in the source text"".) For types with circular dependencies, that means that the types need to be <em>declared</em> before they can be <em>defined</em>. That is done with a <em>forward declaration</em>, which simply introduces the name, without defining the type. In this case, such a declaration would be <code>class CDScreen;</code>.</p>

<p>(Note that after a forward declaration, you can use <em>pointers to</em> the type, but not actual objects of the type as it is not yet defined.)</p>

<p>As opposed to Java, C++ does not require you to place each class in a separate file. In fact, it is often preferable to put a group of classes that belong/operate together in a single header file.</p>

<p>In particular in cases like yours with circular dependencies, putting each class in a separate header file/compilation unit can turn quite brittle. For instance, the order in which the user includes the header files can matter, leading to seemingly random compilation errors.</p>

<p>In your case, I would argue that the best option is to put the classes in the same file, and add forward declarations at the top.</p>

<pre><code>#include &lt;stdint.h&gt;
class CDScreen;  // forward declarations
class CDFrame;   // (this one is not strictly necessary but put in for symmetry/consistency)

class CDFrame {
public:
    CDFrame(uint8_t capacity);
    virtual ~CDFrame();

private:
    uint8_t capacity = 0;
    CDScreen* parent = nullptr; //&lt;- Parent property of CDScreen class
}

class CDScreen {
public:
    CDScreen(uint8_t capacity);
    virtual ~CDScreen();
    void addFrame(CDFrame* frame); // Sets the frame's parent (this CDScreen) when a new frame is added 

private:
    uint8_t capacity = 0;
    uint8_t size = 0;
    CDFrame** frames;   
}
</code></pre>
",,,
50235325,2,50234614,2018-05-08T13:52:09.467,0,,9720723,,2018-05-09T12:32:40.850,2018-05-09T12:32:40.850,1,,"<p>weatherTask wants a function pointer and not a pointer to a member. A possible way to solve this problem is to create a helper struct and bind the function to a <code>std::function</code>.</p>

<pre><code>#include &lt;functional&gt;

template &lt;typename T&gt;
struct Callback;

template &lt;typename Ret, typename... Params&gt;
struct Callback&lt;Ret(Params...)&gt; {
   template &lt;typename... Args&gt; 
   static Ret callback(Args... args) {                    
      func(args...);  
   }
   static std::function&lt;Ret(Params...)&gt; func; 
};

template &lt;typename Ret, typename... Params&gt;
std::function&lt;Ret(Params...)&gt; Callback&lt;Ret(Params...)&gt;::func;
</code></pre>

<p>When creating the weatherTask use the following to bind the member function to your callback:</p>

<pre><code>Callback&lt;void(void)&gt;::func = std::bind(&amp;Weather::updateWeatherCallback, this);
TaskCallback func = static_cast&lt;TaskCallback&gt;(Callback&lt;void(void)&gt;::callback);
weatherTask(interval, TASK_FOREVER, func, *scheduler, true);
</code></pre>

<p>The solution was presented as an anwser to <a href=""https://stackoverflow.com/a/29817048/9720723"">this</a> question. Since I cannot comment I decided to provide this as an answer.</p>

<hr>

<p>Alternatively you can make use of a trampoline like function. Therefore you would be required to store an global pointer to your <code>Weather</code> object.</p>

<pre><code>Weather global_ptr;
</code></pre>

<p>Then you would be able to create a <code>weatherTask</code> using a lambda function.</p>

<pre><code>weatherTask(interval, TASK_FOREVER, [](){global_ptr-&gt;updateWeatherCallback();}, *scheduler, true);
</code></pre>
",,,
50245676,2,50234692,2018-05-09T04:44:38.727,0,,8546089,,2018-05-09T04:44:38.727,,3,,"<p>IoT Hub SDK for C does not provide the method for that.It provides utility functions in <strong><em>x509_schannel.c</em></strong>.You can use OpenSSL library like following code. </p>

<p><strong>Use OpenSSL:</strong></p>

<pre><code>static X509 *load_cert(const char *file)
{
    X509 *x=NULL;
    BIO *cert;

    if ((cert=BIO_new(BIO_s_file())) == NULL)
        goto end;

    if (BIO_read_filename(cert,file) &lt;= 0)
        goto end;

    x=PEM_read_bio_X509_AUX(cert,NULL, NULL, NULL);
end:
    if (cert != NULL) BIO_free(cert);
    return(x);
}
</code></pre>

<p>BTW, you can download the openssl source code and compile the library to use for azure iothub sdk project.</p>
",,,
50244048,2,50243704,2018-05-09T00:53:24.203,0,,8767209,,2018-05-09T00:53:24.203,,1,,"<p>I don't know which implementation of Arduino HashMap you are using, but if it's <a href=""https://github.com/ARISGames/arduino/blob/master/libraries/ArduinoPusherClient/HashMap/HashMap.h"" rel=""nofollow noreferrer"">this one</a>, this is the best I can come up with given the API.  It is certainly not optimal, and a better data structure would be faster.</p>

<p>Assuming I understand the problem correctly, I would just do a linear search.  You know how to get the highest point.  You know the location of the second highest point must be below the highest. (I'm adding here, you might need to subtract if your coordinate system is different). Assume the minimum difference in positions has to be <code>min_dist</code> (some value 2-10).  </p>

<pre><code>HashMap&lt;int, int, N&gt; points = ...;
int key_low = upper_position + min_dist;
int peak_location = -1;
for(int i=0; i &lt; points.size(); ++i)
{ 
    int location = points.keyAt(i);
    if (location &lt; key_low) continue;
    int resistance = points[location];
    if (peak_location &lt; 0 || resistance &gt; points[peak_location])
    {
        peak_location = location; 
    }
}
</code></pre>
",,,
50252223,2,50251876,2018-05-09T11:26:02.357,0,,5686835,,2018-05-09T12:41:37.400,2018-05-09T12:41:37.400,4,,"<p>You should create a global state of the application. This state is where you remember if you are blinking at 50hz/60hz/off. Then you can use a switch to do the right thing. </p>

<p>Then you check if the button is pressed and change the application state. </p>

<p>See my example below:</p>

<pre><code>// constants won't change. They're used here to set pin numbers:
const int buttonPin = 7;     // the number of the pushbutton pin
const int ledPin =  6;      // the number of the LED pin
// variables will change:
int applicationState = 0;  
bool lightOn = true;

int currentDelay = 1000;

unsigned long currentMillis = 0;
unsigned long previousMillis = 0;

// variable for reading the pushbutton status
void setup() {
  // initialize the LED pin as an output:
  pinMode(ledPin, OUTPUT);
  // initialize the pushbutton pin as an input:
  pinMode(buttonPin, INPUT);
}

void loop() {

    if (digitalRead(buttonPin) == HIGH) {
        applicationState++;
        if(applicationState &gt;= 3) {
            applicationState = 0;
        }
        delay(100);
    }

    switch(applicationState){
        case 0:
            currentDelay = 1000;
            lightOn = true;
            break;
        case 1:
            currentDelay = 2000;
            lightOn = true;
            break;
        case 2:
            digitalWrite(ledPin, LOW);
            lightOn = false;
            break;
    }


    currentMillis = millis();
    if (currentMillis - previousMillis &gt;= currentDelay &amp;&amp; lightOn) {
        previousMillis = currentMillis;
        digitalWrite(ledPin, !digitalRead(ledPin));
    }      
}
</code></pre>

<p>I hope you understand what I try to say and demo with the example code.</p>
",,,
50252272,2,50251876,2018-05-09T11:28:40.020,0,,4058889,,2018-05-09T11:51:57.897,2018-05-09T11:51:57.897,5,,"<p>Right now your logic checks 3 times for the value of x in a single loop.
Below code toggles light whenever x is greater than zero. x's value is changed when button is pressed. </p>

<p>But there is a big problem here: If button is pressed when there's something else going on in the processor or it is sleeping (like the long delays you want to use), it may be ignored. So you better study interrupts and implement this behavior using them.</p>

<pre><code>if (x &gt; 0)
{
    digitalWrite(ledPin, HIGH);
    delay(1000 * x);
    digitalWrite(ledPin, LOW);
}
if (buttonState == HIGH)
{
    x++;
    if (x &gt; 3)
        x = 0;
}
</code></pre>
",,,
50252764,2,50251876,2018-05-09T11:55:20.243,0,,6082851,,2018-05-09T15:31:07.547,2018-05-09T15:31:07.547,4,,"<p>Your code can not work: </p>

<ol>
<li><p>You do need to check if the button state changes, detect when there is a edge. And make sure you detect a single edge only once.</p></li>
<li><p>You must repeat the blinking it in a loop till the button is pressed, then you can change the frequency.</p></li>
<li><p>You must check the button while you sleep, otherwise your program do not recognize when you press the button.</p></li>
</ol>

<p>To make it work, you must change the complete program.</p>

<pre><code>#define BLINK_SLEEP_TIME &lt;some value&gt; // insert value for 16.6666ms

//return 1 after a positive edge
bool button_read(void)
{
  static bool lastState=1; //set this to 1, so that a pressed button at startup does not trigger a instant reaction
  bool state = digitalRead(buttonPin);
  if(state != lastState)
    {
      state=lastState;
      return state;
    }
 return 0;
}

//Blink the LED with a given period, till button is pressed
//Times are in x*16.666ms or x/60Hz
//At least one time should be more than 0
void blink(uint8_t ontime, uint8_t offtime) 
{
  while(1)
  {
    for(uint8_t i=0;i&lt;ontime;i++)
    {
      led_setOn();
      delay(BLINK_SLEEP_TIME);
      if(button_read())
      {
        return;
      }
    }
    for(uint8_t i=0;i&lt;offtime;i++)
    {
      led_setOff();
      delay(BLINK_SLEEP_TIME);
      if(button_read())
      {
        return;
      }
    }
  }
}

const uint8_t time_table[][]=
{
  {0,50},//LED is off
  {6,6}, //LED blinks with 5Hz, 60Hz/2/6=5Hz
  {5,5}, //LED blinks with 6Hz, 60Hz/2/5=6Hz
}

void endless(void)
{
  uint8_t i=0;
  for(;;)
    {
      i++;
      if(i&gt;2)
      {
        i=0;
      }
      blink(time_table[i][0],time_table[i][1]);
    }
}
</code></pre>

<p>A better approach would be to use a hardware PWM-Module and change the values after a edge on the button.</p>
",,,
50259528,2,50251876,2018-05-09T18:03:00.200,0,,7816750,,2018-05-09T18:03:00.200,,0,,"<p>Firstly this is your circuit. I tried this circuit and code and worked for me. I used interrupt for checking button state. And millis calculation is simple. </p>

<p>Frequency = 1 / Period </p>

<p>Period = Ton + Toff</p>

<p>6Hz = 1000  millis / T => T = 166 millis</p>

<p>166 = Ton + Toff (for %50 duty cycle Ton=Toff) => Ton = Toff = 83 millis</p>

<p><a href=""https://i.stack.imgur.com/LdjLH.png"" rel=""nofollow noreferrer"">enter image description here</a></p>

<pre><code>const int ledPin = 13;
const int buttonPin = 2;
int state = -1;
bool willLightOn = false;

unsigned long currentDelay = 0;
unsigned long currentMillis = 0;
unsigned long previousMillis = 0;

void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(buttonPin), changeState, FALLING);
}

void loop() {
  if(state % 3 == 0) { //6Hz 
    currentDelay = 83;
    willLightOn = true;
  } else if (state % 3 == 1) { //5Hz
    currentDelay = 100;
    willLightOn = true;
  } else if (state % 3 == 2) { //LED off
    currentDelay = 0;
    willLightOn = false;
    digitalWrite(ledPin, LOW);
  }

  currentMillis = millis();
    if (currentMillis - previousMillis &gt;= currentDelay &amp;&amp; willLightOn) {
        previousMillis = currentMillis;
        digitalWrite(ledPin, !digitalRead(ledPin));
    } 
}

void changeState() {
  state++;
}
</code></pre>
",,,
50270771,2,50270367,2018-05-10T10:27:17.327,1,,9769568,,2018-05-10T18:09:24.523,2018-05-10T18:09:24.523,3,,"<p>As other have pointed out, all you have to do is interpret the raw data as an (unsigned) long long and then store the value in a string, for instance:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;

int main(void)
{
    unsigned char testData[8] = {0xFF,0xF0,0x00,0xA0,0x00,0x00,0x00,0x99};
    unsigned long long data = *reinterpret_cast&lt;unsigned long long*&gt;(testData);

    std::stringstream str;
    //str &lt;&lt; std::hex &lt;&lt; data;
    str &lt;&lt; data;

    std::cout &lt;&lt; str.str() &lt;&lt; '\n';

    return EXIT_SUCCESS;
}
</code></pre>

<p>EDIT</p>

<p>The following solution relies on the <code>String</code> constructor to convert the original 64-bit value into 2 32-bit value representations that can either be concatenated or used separately if you need to.
This assumes that the platform is little-endian.</p>

<pre><code>String lsdw = String(*reinterpret_cast&lt;unsigned long*&gt;(&amp;testData[0]), HEX);
String msdw = String(*reinterpret_cast&lt;unsigned long*&gt;(&amp;testData[4]), HEX);
String message = lsdw + msdw;
</code></pre>
",,,
50271284,2,50270367,2018-05-10T10:55:10.530,0,,3600304,,2018-05-10T10:55:10.530,,0,,"<p>I think with bitset this can be accomplished easily and here is sample code for the same :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;
#include &lt;bitset&gt;
int main(void)
{
    unsigned char testData[8] = {0xFF,0xF0,0x00,0xA0,0x00,0x00,0x00,0x99};
    std::cout&lt;&lt;""size of array is ""&lt;&lt;sizeof(testData)&lt;&lt;std::endl;
    std::stringstream strStream;
    for(unsigned int i=0;i&lt;sizeof(testData);i++)
    {
      std::bitset&lt;16&gt; test(testData[i]);
      strStream&lt;&lt;test.to_ullong();

    }
    std::cout&lt;&lt;""Final string corresponding to this unsigned char array is ""&lt;&lt;strStream.str()&lt;&lt;std::endl;

    return EXIT_SUCCESS;
}
</code></pre>
",,,
50284116,2,50283768,2018-05-11T02:22:41.180,2,,5245033,,2018-05-11T02:38:56.973,2018-05-11T02:38:56.973,2,,"<p>Your program is not behaving correctly because <code>f.read()</code> is not guaranteed to read the whole buffer. Moreover, it is bound to happen when you read the last chunk of the file, unless the file size is a factor of buffer size (3072 in your case).</p>

<p>While Arduino specification (<a href=""https://www.arduino.cc/en/Reference/FileRead"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Reference/FileRead</a>) doesn't say so, <code>SD.read</code> function returns the number of bytes read. See code of the library here: <a href=""https://github.com/arduino-libraries/SD/blob/master/src/utility/SdFile.cpp"" rel=""nofollow noreferrer"">https://github.com/arduino-libraries/SD/blob/master/src/utility/SdFile.cpp</a>, <code>int16_t SdFile::read(void* buf, uint16_t nbyte)</code></p>

<p>Knowing that, you should change your loop as following (while also rewriting it as a <code>for</code> loop for better readability and removing <code>q</code> definition above):</p>

<pre><code>while(f.available()) {
    uint16_t sz = f.read(buffer, sizeof(buffer));

    for (uint16_t q = 0; q &lt; sz; ++q) {
        doStuffWithInformation(buffer[q]);
    }
}
</code></pre>

<p>On a side note, now, when you have this logic in place, it would make sense for you to do away with variable length array and use a fixed buffer of size 512 - the standard sector size on the SD card. Most likely, it will yield the same performance in regards to read, and slightly better performance in regards to <code>sizeof</code>, which will becomes a compile-time constant rather than a run-time calculation. This also makes your program simpler. This makes for following code:</p>

<pre><code>f = SD.open(filename);
...
uint8_t buffer[512];
</code></pre>
",,,
50319652,2,50319029,2018-05-13T19:00:33.833,0,,8746007,,2018-05-13T19:20:10.963,2018-05-13T19:20:10.963,2,,"<p>You probably wanted to write <code>12.5</code> instead of <code>12,5</code> in these expressions:  <code>leftInput = analogRead(A0)/12,5; rightInput = analogRead(A1)/12,5;</code> But even then, the <code>analogRead</code> returns value from <code>0</code> to <code>1023</code> (including). So the value for <code>left/rightInput</code> would range from <code>0</code> to about <code>81</code>, while you need it to be in range of <code>0...4</code>. I suggest to have another array of threshold values and depending on the strength of the signal light up all LEDs that are above threshold, for example (not tested) add this instead of your <code>loop()</code>:  </p>

<pre><code>const int thresholdsLeftLed[leftLedCount] = { 4, 208, 412, 616, 820 };
const int thresholdsRightLed[rightLedCount] = { 4, 208, 412, 616, 820 };

void LightLEDs(int signalLeft, int signalRight)
{
    for (int l = 0; l &lt; leftLedCount; ++l)
        digitalWrite(leftLed[l], signalLeft &gt; thresholdsLeftLed[l] ? HIGH : LOW);
    for (int r = 0; r &lt; rightLedCount; ++r)
        digitalWrite(rightLed[r], signalRight &gt; thresholdsRightLed[r] ? HIGH : LOW);
}

void loop()
{
    LightLEDs(analogRead(A0), analogRead(A1));
}
</code></pre>

<p>Note that you probably don't need to turn all LEDs off as they are turned off in the loop if the signal is below threshold</p>
",,,
50321026,2,50320870,2018-05-13T22:05:21.577,-1,,95306,,2018-05-13T22:05:21.577,,1,,"<p>The problem stems from the abstract constructors and destructors. When I removed all ""virtual"" keys, it works fine:</p>

<pre><code>class FooBar {
    public:
        char foobar[7] = { 'f','o','o','b','a','r' };   //  Should be publically visible
        FooBar() {
            Serial.println(""\nConstructing FooBar"");
        }
        void begin() {
            Serial.println(""\nFrom FooBar:"");
            Serial.print(""foobar="");
            Serial.println(foobar);
        }
    };

    class Foo : public FooBar {
    public:
        const char foo[4] = { 'f','o','o' };

        Foo() {
            Serial.println(""\nConstructing Foo"");
        }

        void begin() {
            Serial.println(""\nFrom Foo:"");

            Serial.print(""foo="");
            Serial.println(foo);

            Serial.print(""FooBar="");
            Serial.println(FooBar::foobar);
        }

    };

    class Bar : public Foo {
    public:
        const char bar[4] = { 'b', 'a', 'r' };

        Bar() {
            Serial.println(""\nConstructing Bar"");
        }

        void begin() {
            Serial.println(""\nFrom Bar:"");

            Serial.print(""bar="");
            Serial.println(bar);

            Serial.print(""foo="");
            Serial.println(foo);

            Serial.print(""FooBar="");
            Serial.println(foobar);
        }
    };

    FooBar *foobar;
    Foo *foo;
    Bar *bar;

    void setup() {
        Serial.begin(115200);
        Serial.println(""Beginning..."");

        foobar = new FooBar();
        foo = new Foo();
        bar = new Bar();

        foobar-&gt;begin();
        foo-&gt;begin();
        bar-&gt;begin();
    }

    void loop() {

    }
</code></pre>
",,,
50332349,2,50331275,2018-05-14T14:06:16.880,1,,7816750,,2018-05-14T14:06:16.880,,0,,"<p>You can use this code. I tried this on simulation and it worked well. You can see data changes on serial monitor. storeValues() function does what you want. you need to call it first in loop function.</p>

<pre><code>int firsPin = A0;
int secondPin = A1;
int u = 0, y = 0, lastU = 0, lastY = 0;

//0 : u(n-1) 1 : u(n-2) 2 : y(n-1) 3 : y(n-2) 
int z[] = {0, 0, 0, 0};

void setup() {
  Serial.begin(9600);
  pinMode(firsPin, INPUT);
  pinMode(secondPin, INPUT);
}

void loop() {
  storeValues();
  u = analogRead(firsPin);
  y = analogRead(secondPin);    
  Serial.println(""u: "" + String(u));
  Serial.println(""y: "" + String(y));
  Serial.println(""u(n-1): "" + String(z[0]));
  Serial.println(""y(n-1): "" + String(z[2]));
  Serial.println(""u(n-2): "" + String(z[1]));
  Serial.println(""y(n-2): "" + String(z[3]));
  delay(100);
}

void storeValues() {
  z[1] = z[0];
  z[3] = z[2];
  z[0] = u;
  z[2] = y;
}
</code></pre>
",,,
50332415,2,50331275,2018-05-14T14:09:14.093,0,,7977138,,2018-05-15T05:38:03.417,2018-05-15T05:38:03.417,2,,"<p>you'll need to copy the values. As mentioned in a comment why is the second dimension 1? I have left that one out. </p>

<p>How I usually do it is:</p>

<pre><code> z[1] = z[0];
 z[0] = u;
 z[3] = z[2];
 z[2] = y;
</code></pre>

<p>this will shift the previous value into the other value of the matrix, to put it in your code: </p>

<pre><code>int pinU = A0;
int pinY = A1;
int u = 0;
int y = 0;
float z[4] = {0,0,0,0}

void setup() {
   Serial.begin(9600);
   pinMode(pinU, INPUT);
   pinMode(pinY, INPUT);
}

void loop() {
    u = analogRead(A0);
    y = analogRead(A1);
    z[1] = z[0];
    z[0] = u;
    z[3] = z[2];
    z[2] = y;

} 
</code></pre>

<p>This wil effectively make z = {u(n), u(n-1), y(n), y(n-1)}</p>
",,,
50342492,2,50342360,2018-05-15T04:46:18.983,2,,434551,,2018-05-15T05:15:30.607,2018-05-15T05:15:30.607,2,,"<p>I would a add check to make sure the file was opened successfully. Also, the results of executing <code>less</code> on the file is not a reliable method to test the contents of the file while you are running the program. <code>usleep(100)</code> does not give you enough time to check the contents of the file before it is opened again.</p>

<p>I suggest the following change to your code.</p>

<pre><code>while(buttonCounter &lt; 100){

   if (buttonState == 1 &amp;&amp; pastButtonState == 0) buttonCounter++;

   writeToFile(buttonCounter, FILE_PATH);
   showContentsOfFile(FILE_PATH);
   `
   pastButtonState = buttonState;
}
</code></pre>

<p>where <code>writeToFile</code> is:</p>

<pre><code>void writeToFile(int buttonState, std::string const&amp; file)
{
   std::ofstream outputfile(file);
   if ( outputfile )
   {
      outputfile &lt;&lt; buttonCounter &lt;&lt; std::endl;
   }
   else
   {
      std::cerr &lt;&lt; ""Unable to open "" &lt;&lt; file &lt;&lt; "" for writing to.\n"";
   }
}
</code></pre>

<p>and <code>showContentsOfFile</code> is:</p>

<pre><code>void showContentsOfFile(std::string const&amp; file)
{
   std::ifstream inputfile(file);
   if ( outputfile )
   {
      int buttonCounter;
      if ( inputfile &gt;&gt; buttonCounter )
      {
         std::cout &lt;&lt; ""Button counter: "" &lt;&lt; buttonCounter &lt;&lt; std::endl;
      }
      else
      {
         std::cerr &lt;&lt; ""Unable to read buttonCounter from file "" &lt;&lt; file &lt;&lt; std::endl;
      }
   }
   else
   {
      std::cerr &lt;&lt; ""Unable to open "" &lt;&lt; file &lt;&lt; "" for reading from.\n"";
   }
}
</code></pre>
",,,
50405341,2,50343741,2018-05-18T06:47:42.170,0,,1177848,,2018-05-18T06:47:42.170,,0,,"<p>There was basically 2 problems with the code.
1. I should have used the canfd_frame struct, and I should've 0'ed the values. Here is the code that worked at the end</p>

<pre><code>void *CANUpdate(void *userParam)
{
    struct sockaddr_can addr;
    struct ifreq ifr;
    const char *ifname = ""can0"";
    int can_s;

    if ((can_s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; 0)
    {
        LogEntry(LOG_ERR, ""Error while opening socket\n"");
        return 0;
    }

    strcpy(ifr.ifr_name, ifname);
    ioctl(can_s, SIOCGIFINDEX, &amp;ifr);

    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    setsockopt(can_s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);

    if (bind(can_s, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)
    {
        LogEntry(LOG_ERR, ""Error in CAN socket bind\n"");
        return 0;
    }

    while (!stopServer)
    {
        if (can_s)
        {
        struct canfd_frame frame;
        memset(&amp;frame, 0, sizeof(frame)); /* init CAN FD frame, e.g. LEN = 0 */
        frame.can_id = 0x01f801f2;
        frame.len = 8;

        if (!(frame.can_id &amp; CAN_ERR_FLAG)) /* 8 digits but no errorframe?  */
            frame.can_id |= CAN_EFF_FLAG;   /* then it is an extended frame */

            frame.data[0] = 0x12;
            frame.data[1] = 0x12;
            frame.data[2] = 0x12;
            frame.data[3] = 0x12;
            frame.data[4] = 0x34;
            frame.data[5] = 0x34;
            frame.data[6] = 0x34;
            frame.data[7] = 0x34;

            if(write(can_s, &amp;frame, sizeof(struct can_frame)) != sizeof(struct can_frame);
            LogEntry(LOG_ERR, ""Unable to write CAN message\n"");
        }
        msleep(800);
    }
}
</code></pre>
",,,
51560872,2,50350334,2018-07-27T15:12:23.063,6,,1968,,2018-07-27T15:12:23.063,,7,,"<p>I’ve tried reproducing your setup as closely as possible. I therefore installed Raspbian (The Raspberry Pi operating system) in a VirtualBox image and used Geany to create, compile and execute a C file. Here is the code in its entirety:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    printf(""Setup successful\n"");
}
</code></pre>

<ol>
<li><p>Save this file as <code>test.c</code>:</p>

<p><a href=""https://i.stack.imgur.com/Zqiov.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Zqiov.png"" alt=""test.c saved""></a></p></li>
<li><p>Next, click on “Build” (the brick icon):</p>

<p><a href=""https://i.stack.imgur.com/KqIlx.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/KqIlx.png"" alt=""build test.c""></a></p></li>
<li><p>And finally, run it (click on the paper plane icon):</p>

<p><a href=""https://i.stack.imgur.com/cGWXA.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/cGWXA.png"" alt=""enter image description here""></a></p></li>
</ol>

<p>As you can see, this code compiles correctly, executes, and prints the message. No explicit flushing is necessary (<a href=""https://stackoverflow.com/q/22385671/1968""><code>printf</code> to stdout automatically flushes when encountering a newline character</a>). This behaviour is standardised and correctly implemented by the tools installed by Raspbian so it’s reliable.</p>
",,,
50360815,2,50359875,2018-05-16T00:19:03.460,0,,2670348,,2018-05-17T03:32:16.603,2018-05-17T03:32:16.603,3,,"<p>Documentation isn't clear on this, but <code>WiFiClient</code> only supports <code>http</code>, not <code>https</code>.</p>

<p>It's great that you're using <code>https</code>! But you'll need to use <code>WiFiClientSecure</code> instead of <code>WifiClient</code>.</p>

<p>You'll most likely want to verify the server's identity once you connect. You'll do that using the <code>verify</code> method on the <code>client</code> object. To do that you'll need to know the fingerprint of the certificate the web server uses.</p>

<p>So your code would look something like this:</p>

<pre><code>#include ""ESP8266WiFi.h""
//General Definition

#define SERVER_FINGERPRINT ""C0 5D 08 5E E1 3E E0 66 F3 79 27 1A CA 1F FC 09 24 11 61 62""

const char server[] = ""https://7751b6b1.ngrok.io"";
 //localhost into server via ngrok
const char* MY_SSID = ""Gastzugang"";
const char* MY_PWD =  ""12345678"";
String mov; //create Text string
WiFiClientSecure client; //Create Wifi client

//Setup
void setup()
{
 Serial.begin(115200);
 Serial.println(""Connecting to ""+*MY_SSID);
 WiFi.begin(MY_SSID, MY_PWD);
Serial.println(""going into wl connect"");
 int PIR_output=16; // output of pir sensor 
 while (WiFi.status() != WL_CONNECTED) //not connected,  ...waiting to 
 connect
 {
  delay(1000);
  Serial.print(""."");
 }
 Serial.println(""wl connected"");
 Serial.println("""");
 Serial.println(""Credentials accepted! Connected to wifi\n "");
 Serial.println("""");
 }

 void loop() {
 if(digitalRead(16) == HIGH) // reading the data from the pir sensor
 {
 mov = ""1"";
 Serial.println(""1"");
 }
 else {
 mov = ""0"" ;
 Serial.println(""0"");
 }

 if (client.connect(server, 8095)) { //Connecting at the IP address and port

 Serial.println(""connected to server"");

 if (client.verify(SERVER_FINGERPRINT, host)) {
   Serial.println(""certificate matches"");
  } else {
   Serial.println(""certificate doesn't match"");
 }

 WiFi.printDiag(Serial);
 client.println(""Get /ethernet/data.php?"");
 //Connecting and Sending values to database
 client.print(""movement="");
 client.print(mov);
 client.stop();
 }
 else {
 // if you didn't get a connection to the server:
 Serial.println(""connection failed"");
 }
 delay(50);
 }
</code></pre>

<p>The three important changes are:
- defining <code>client</code> to be <code>WiFiClientSecure</code> rather than <code>WiFiClient</code>
- adding a call to <code>client.verify</code> after the connection succeeds
- providing a constant server finger print to compare with</p>

<p>The fingerprint I provided won't work with your server. You'll need to find its fingerprint yourself. You can do this going to it with a web browser like Chrome and clicking on the ""Secure"" field in the address bar (in Chrome's case). Click on ""Certificate"", then expand ""Details"" in the view of the certificate. Scroll to the end and you'll see two fingerprints, SHA-256 and SHA-1. Copy the SHA-1 fingerprint and provide it as a string like the <code>SERVER_FINGERPRINT</code> I included.</p>

<p>You can skip verifying the certificate if you want but then you won't be certain you're actually connecting to the real server instead of a server impersonating it.</p>

<p>There's more info on <code>WiFiClientSecure</code> at <a href=""https://github.com/esp8266/Arduino/blob/master/doc/esp8266wifi/client-secure-examples.rst"" rel=""nofollow noreferrer"">Client Secure</a>, including another example of how to find a server's fingerprint under Windows.</p>

<p>If you run into problems, I'd recommend stripping your program down to just the basics - <code>WiFi</code> connect and then <code>WiFiClientSecure</code>; don't worry about the PIR sensor or anything else. Once you get the stripped down version working with your server, transpose the changes you made back into the real program you're trying to get working.</p>

<p><em>Update</em></p>

<p>For your revised code, it's written right now as:</p>

<pre><code>client.println(""Get /ethernet/data.php?""); //making a http request
Serial.println(""Get /ethernet/data.php?"");
//Connecting and Sending values to database
if(digitalRead(16) == HIGH) // reading the data from the pir sensor
{
 mov = ""1"";
client.println(""movement=1"");
Serial.println(""movement=1"");
 }
 else {
  mov = ""0"" ;
  client.println(""movement=0"");
  Serial.println(""movement=0"");
  }
  delay(5000);
  client.stop();
}
</code></pre>

<p>Try:</p>

<pre><code>client.print(""Get /ethernet/data.php?""); //making a http request
Serial.println(""Get /ethernet/data.php?"");
//Connecting and Sending values to database
if(digitalRead(16) == HIGH) // reading the data from the pir sensor
{
 mov = ""1"";
client.print(""movement=1"");
Serial.println(""movement=1"");
 }
 else {
  mov = ""0"" ;
  client.print(""movement=0"");
  Serial.println(""movement=0"");
  }

  client.println("" HTTP/1.1"");
  client.println(""Host: 7751b6b1.ngrok.io"");

  delay(5000);
  client.stop();
}
</code></pre>

<p>The way it's written now it cuts off the parameters in the URL with a newline, omits the ""HTTP/1.1"" tag at the end of the line and doesn't specify the virtual host you're trying to contact (may or may not be an issue depending on your server). It needs to send two lines to the web server, looking like:</p>

<pre><code>GET /ethernet/data.php?movement=1 HTTP/1.1
HOST: 7751b6b1.ngrok.io
</code></pre>
",,,
50365547,2,50365333,2018-05-16T08:10:19.700,1,,2742717,,2018-05-16T08:49:12.540,2018-05-16T08:49:12.540,2,,"<p>Is that Arduino API? That way you cause UB, String demolishes its resources on exit from closure.</p>

<p>Technically if you redesign type</p>

<pre><code>typedef  std::function&lt;String(void)&gt; GetMessageLog;
</code></pre>

<p>then you can write </p>

<pre><code>addLog(LOG_LEVEL_INFO, [&amp;]() -&gt; String
{
  String log = F(""HX711: GPIO: SCL="");
  log += pinSCL;
  log += F("" DOUT="");
  log += pinDOUT;
  return log;
});
</code></pre>

<p>If compiler doesn't support named return value optimization, convert that in a one-liner to reduce amount of copy operations.</p>
",,,
50373794,2,50370487,2018-05-16T14:38:44.743,2,,8078317,,2018-05-16T14:38:44.743,,0,,"<p>You are getting the error because you have bounded the scope of your led_pin variable inside the if and else condition.</p>

<p>Also you are trying to change the whole variable, you should not do that.</p>

<p>Try this out.</p>

<pre><code>void count(int a){
    int led_pin[2][4]={{3,4,5,6},{4,5,6,9}};
    if( a !=0)
    {
        a=1;
    }
    for(int i=0;i&lt;4;i++) //I don't know why you used 7 in your code.
    {
        digitalWrite(led_pin[a][i],HIGH);
    }
}
</code></pre>

<p>I hope this helps.</p>
",,,
50414495,2,50414164,2018-05-18T15:18:44.617,2,,6387170,,2018-05-18T15:18:44.617,,0,,"<p>Your issue revolves around your argument.  </p>

<pre><code>char* string2char(String command){   
       // create a new string that's a copy of the thing you pass in, and call it command
    if (command.length() != 0) {
        char *p = const_cast&lt;char*&gt;(command.c_str());  
             // get the const char* that this string contains.  
             // It's valid only while the string command does; and is invalidated on changing the string.

        return p;   /// and destroy command - making p invalid
    }
}
</code></pre>

<p>There are 2 ways to resolve this.   The first and most complex, is to pass command in by reference.  Thus <code>const String&amp; command</code> and then work with that.</p>

<p>The alternative, which is much simpler, is to completely delete your function; make your <code>char*</code> <code>const char*</code>  and just call <code>c_str()</code> on the string; ie</p>

<pre><code>String string1 = ""Bob"";
const char *string1Char = string1.c_str();
</code></pre>
",,,
50414534,2,50414164,2018-05-18T15:20:35.470,4,,3655463,,2018-05-18T16:20:08.923,2018-05-18T16:20:08.923,2,,"<p>This function :</p>

<pre><code>char* string2char(String command){
    if (command.length() != 0) {
        char *p = const_cast&lt;char*&gt;(command.c_str());
        return p;
    }
}
</code></pre>

<p>Does not make much sense, it takes string by value and returns pointer to its internal buffer, with cased away constnes(don't do it). You are getting some odd behaviour as you are returning values of object that already was destroyed, pass it by ref. Also I'm curious why you need to do all this stuff, can't you just pass:</p>

<pre><code>Serial.println(string1.c_str());
Serial.println(string2.c_str());
</code></pre>
",,,
50441207,2,50440789,2018-05-21T02:25:47.213,0,,4645334,,2018-05-21T11:24:43.700,2018-05-21T11:24:43.700,0,,"<p>Yes, you can run a webserver with Arduino. This is the example from <a href=""https://www.arduino.cc/en/Tutorial/WebServer"" rel=""nofollow noreferrer"">https://www.arduino.cc/en/Tutorial/WebServer</a></p>

<pre><code>/*
  Web Server

 A simple web server that shows the value of the analog input pins.
 using an Arduino Wiznet Ethernet shield.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13
 * Analog inputs attached to pins A0 through A5 (optional)

 created 18 Dec 2009
 by David A. Mellis
 modified 9 Apr 2012
 by Tom Igoe
 modified 02 Sept 2015
 by Arturo Guadalupi

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);

// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(80);

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  // start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);
  server.begin();
  Serial.print(""server is at "");
  Serial.println(Ethernet.localIP());
}


void loop() {
  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    Serial.println(""new client"");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\n' &amp;&amp; currentLineIsBlank) {
          // send a standard http response header
          client.println(""HTTP/1.1 200 OK"");
          client.println(""Content-Type: text/html"");
          client.println(""Connection: close"");  // the connection will be closed after completion of the response
          client.println(""Refresh: 5"");  // refresh the page automatically every 5 sec
          client.println();
          client.println(""&lt;!DOCTYPE HTML&gt;"");
          client.println(""&lt;html&gt;"");
          // output the value of each analog input pin
          for (int analogChannel = 0; analogChannel &lt; 6; analogChannel++) {
            int sensorReading = analogRead(analogChannel);
            client.print(""analog input "");
            client.print(analogChannel);
            client.print("" is "");
            client.print(sensorReading);
            client.println(""&lt;br /&gt;"");
          }
          client.println(""&lt;/html&gt;"");
          break;
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    Serial.println(""client disconnected"");
  }
}
</code></pre>

<p>Save the states in a global variable and initialize them in <code>setup()</code>. When a client sends its request, it has to send its id or ip and the server can response with the state.</p>
",,,
50527679,2,50459582,2018-05-25T11:00:34.790,0,,2521214,,2018-05-25T11:32:44.227,2018-05-25T11:32:44.227,3,,"<p>Please do not post duplicate questions.</p>

<ol>
<li><p><strong>The output of your solver (color commands) does not make much sense</strong></p>

<p>will give you headaches on the <strong>MCU</strong> side latter. Better way is to use the standard notation of rotation commands <code>L,R,U,D,F,B</code> like in here </p>

<ul>
<li><a href=""https://stackoverflow.com/a/39024016/2521214"">Quaternion rotation do not works as excepted</a>.</li>
</ul>

<p><img src=""https://i.stack.imgur.com/3DOt8.png"" alt=""rotations""></p>

<p>You can distinct between <strong>CW/CCW</strong> directions by using lower/uppercase characters. This way you know exactly which slice and in which direction to rotate.</p>

<p>Running solver code directly on <strong>MCU</strong> might be slow (especially if it is genere&amp;test + backtracking based). In case of simple human like solver (like I used in the link above) <strong>MCU</strong> processing power should be more than enough.</p></li>
<li><p><strong>Now how to feed your data from solver (assuming Windows PC) into MCU?</strong></p>

<p>The easiest way is use <strong>RS232</strong> but for that you need voltage converter like <strong>MAX232</strong> (your <strong>MCU</strong> board probably has it or it use some <strong>USB</strong> chip as <strong>USB2RS232</strong> converter in <strong>TTL</strong> voltages like <strong>FTDI</strong> or another small <strong>MCU</strong>).</p>

<p>So what you should do is  to write a parser that take in your file (or stream or what ever) on PC side (can be the same executable where you solve) convert the commands to single char <code>U,D,L,R,F,B</code> style and send that to <strong>RS232</strong>.</p>

<p>The same can be done with <strong>USB</strong> but that is magnitude more complicated due to need for drivers and much much more on both <strong>PC</strong> and <strong>MCU</strong> side which is not a good idea to start with for a rookie.</p>

<p>In windows you simply open file like <code>COM1</code> set its properties and read/write your stuff from/to it (the same way like it would be a file). Here is a small <strong>Win32 C++/VCL</strong> lib <code>port.h</code> I wrote ages ago for stuff like this:</p>

<pre class=""lang-cpp prettyprint-override""><code>//---------------------------------------------------------------------------
//--- port class ver: 2.0 ------------------------------------------------
//---------------------------------------------------------------------------
#ifndef _port_h
#define _port_h
//---------------------------------------------------------------------------
class port
        {
public: HANDLE       hnd;
        DWORD        error;
        DWORD        rlen,wlen;
        DCB          rs232_state;
        COMMPROP     properties;
        COMMTIMEOUTS timeouts;
        COMSTAT      stat;
        port();
        ~port();
        int  open(AnsiString name);
        void close();
        int  get_stat();        // err,stat
        int  get_timeouts();    // timeouts
        int  set_timeouts();
        int  get_properties();  // properties
        int  get_rs232_state(); // rs232_state
        int  set_rs232_state();
        void rst_rs232_state();
        void out(BYTE data)  { WriteFile(hnd,&amp;data,1,&amp;wlen,NULL); }
        void in (BYTE *data) { ReadFile (hnd, data,1,&amp;rlen,NULL); }
        void in (char *data) { ReadFile (hnd, data,1,&amp;rlen,NULL); }
        void out(BYTE *data,DWORD len) { WriteFile(hnd,data,len,&amp;wlen,NULL); }
        void in (BYTE *data,DWORD len) { ReadFile (hnd,data,len,&amp;rlen,NULL); }
        };
//---------------------------------------------------------------------------
port::port()
        {
        rlen=0;
        wlen=0;
        error=0;
        hnd=(void*)0xFFFFFFFF;
        rst_rs232_state();
        }
//---------------------------------------------------------------------------
port::~port()
        {
        close();
        }
//---------------------------------------------------------------------------
int port::open(AnsiString name)
        {
        close();
        error=0;
        rlen=0;
        wlen=0;
        hnd=CreateFile( name.c_str(),GENERIC_READ | GENERIC_WRITE,0,NULL,OPEN_ALWAYS,0,NULL);
        error=GetLastError();
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        get_timeouts();
        get_properties();
        get_rs232_state();

        timeouts.ReadIntervalTimeout;
        timeouts.ReadTotalTimeoutMultiplier;
        timeouts.ReadTotalTimeoutConstant;
        timeouts.WriteTotalTimeoutMultiplier;
        timeouts.WriteTotalTimeoutConstant;

        properties.wPacketLength;
        properties.wPacketVersion;
        properties.dwServiceMask;
        properties.dwReserved1;
        properties.dwMaxTxQueue;
        properties.dwMaxRxQueue;
        properties.dwMaxBaud;
        properties.dwProvSubType;
        properties.dwProvCapabilities;
        properties.dwSettableParams;
        properties.dwSettableBaud;
        properties.wSettableData;
        properties.wSettableStopParity;
        properties.dwCurrentTxQueue;
        properties.dwCurrentRxQueue;
        properties.dwProvSpec1;
        properties.dwProvSpec2;
        properties.wcProvChar[1];

        return 1;
        }
//---------------------------------------------------------------------------
void port::close()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return;
        CloseHandle(hnd);
        error=GetLastError();
        hnd=(void*)0xFFFFFFFF;
        }
//---------------------------------------------------------------------------
int port::get_stat()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        DWORD err;
        if (ClearCommError(hnd,&amp;err,&amp;stat)) return 1;
        error=GetLastError();
        return 0;
        }
//---------------------------------------------------------------------------
int port::get_timeouts()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        if (GetCommTimeouts(hnd,&amp;timeouts)) return 1;
        error=GetLastError();
        get_stat();
        return 0;
        }
//---------------------------------------------------------------------------
int port::set_timeouts()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        if (SetCommTimeouts(hnd,&amp;timeouts)) return 1;
        error=GetLastError();
        get_stat();
        return 0;
        }
//---------------------------------------------------------------------------
int port::get_properties()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        if (GetCommProperties(hnd,&amp;properties)) return 1;
        error=GetLastError();
        get_stat();
        return 0;
        }
//---------------------------------------------------------------------------
int port::get_rs232_state()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        if (GetCommState(hnd,&amp;rs232_state)) return 1;
        error=GetLastError();
        get_stat();
        return 0;
        }
//---------------------------------------------------------------------------
int port::set_rs232_state()
        {
        if ((DWORD)hnd==0xFFFFFFFF) return 0;
        if (SetCommState(hnd,&amp;rs232_state)) return 1;
        error=GetLastError();
        get_stat();
        return 0;
        }
//---------------------------------------------------------------------------
void port::rst_rs232_state()
        {
        rs232_state.BaudRate    = CBR_9600;
        rs232_state.ByteSize    = 8;
        rs232_state.Parity      = NOPARITY;
        rs232_state.StopBits    = ONESTOPBIT;
        rs232_state.fOutxCtsFlow= FALSE;
        rs232_state.fOutxDsrFlow= FALSE;
        rs232_state.fOutX       = FALSE;
        rs232_state.fInX        = FALSE;
        rs232_state.fBinary     = FALSE;
        rs232_state.fRtsControl = RTS_CONTROL_DISABLE;
        }
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
#endif
//---------------------------------------------------------------------------
</code></pre>

<p>The only stuff it uses from <strong>VCL</strong> is <code>AnsiString</code> which is string datatype with character access indexed from <code>1</code> instead of <code>0</code>. The <code>AnsiString s; s.c_str();</code> just returns <code>char*</code> pointer so you can directly port all this to <code>char*</code> or string type you got at your disposal.</p>

<p>When dealing with <strong>RS232</strong> you should take in mind you need some sort of synchronization because the other side never knows if it receives data from the beginning or some data was send already prior to initialization.  So you should add some start/end commands to your solver stream.</p>

<p>You can also simultaneously read and write the <strong>RS232</strong> but you need to use threads to implement this correctly. This is how I usually do it:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;windows.h&gt;
//typedef uint32_t DWORD;           // uncomment this if no DWORD type is present
//typedef uint16_t WORD;            // uncomment this if no WORD type is present
//typedef uint8_t BYTE;             // uncomment this if no BYTE type is present
#include ""port.h""

port com;
const int _timeout=1;
const BYTE _id_timeout=0;
unsigned char q;

// init or reconnect
com.open(""COM1""); // use number of your COM port to use can be different than 1 especially for USB converters see device manager)
com.timeouts.ReadIntervalTimeout        =_timeout;
com.timeouts.ReadTotalTimeoutMultiplier =_timeout;
com.timeouts.ReadTotalTimeoutConstant   =_timeout;
com.timeouts.WriteTotalTimeoutMultiplier=_timeout;
com.timeouts.WriteTotalTimeoutConstant  =_timeout;
com.set_timeouts();
com.rs232_state.BaudRate=CBR_9600;
com.set_rs232_state();

// write
q='L';
com.out(q);

// read (this can freeze if no data in RS232 and timeout set too big)
q=_id_timeout;
com.in (&amp;q);
if (q==_id_timeout) /* do something if timeout*/ ;
else /* handle valid data*/ ;

// exit
com.close();
</code></pre>

<p>In case your environment does not know <code>BYTE, WORD, DWORD</code> then change them with <code>uint8_t, uint16_t, uint32_t</code> or use <code>typedef</code>. The <strong>WinAPI</strong> functions need to include <code>windows.h</code>.</p>

<p>As I mentioned before beware that reading <strong>COM</strong> port without actual data sending from other side might freeze your code so it is better to separate reads and writes to threads or have short timeouts and account for the loss of data due to freeze ups.</p>

<p>Before moving to <strong>MCU</strong> you should check if your <strong>PC</strong> side code is working (as you can much easily debug the <strong>PC</strong> side than the <strong>MCU</strong> side). So code emulator of your <strong>MCU</strong> which will read the <strong>RS232</strong> feed from your solver and print it somewhere like console or whatever so you can see if data is correct. Then connect <strong>RS232</strong> by loop-link (short circuit RxD and Txd pins by a wire) ...</p></li>
<li><p><strong>The code on the MCU side</strong></p>

<p>should do more or less the same thing but you do not have winapi at your disposal so you need to use framework you have. Most <strong>MCU</strong> have overloaded <code>iostream</code> to <strong>RS232</strong> so you just use <code>cin/cout</code> instead all of this.  I do not code in Arduino framework (I use C++ (<strong>GCC</strong>) for <strong>MCU</strong>s) and there <strong>RS232/UART</strong> access depends on <strong>MCU</strong> chip architecture and version so can not help you there.</p>

<p>The important thing to remember is that you need to set the RS232 protocol the same way as in the PC side. So the same number of start/stop/parity bits, the same BaudRate etc ...</p></li>
</ol>
",,,
50493289,2,50487431,2018-05-23T16:28:27.837,0,,9834051,,2018-05-23T17:33:55.643,2018-05-23T17:33:55.643,0,,"<p>Well, after a few tests i came up that i can only send float numbers betwwen 8-bit Arduino and Python with maximum 3 decimal places with accuracy.
I also wrote a non-struct code:</p>

<p><strong>Edit:added code</strong></p>

<p>NON_STRUCT</p>

<p>Arduino side:<a href=""https://drive.google.com/file/d/1lvgT-LqQa7DxDorFF0MTe7UMpBfHn6LA/view?usp=sharing"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/1lvgT-LqQa7DxDorFF0MTe7UMpBfHn6LA/view?usp=sharing</a></p>

<pre><code>//values to send//
int32_t aa=53; 
int32_t bb=-2121;
float cc=4112.3; //each float must have max 3 decimal places else it will 
#rounded to 3!!
float dd=-7631.23;
////***/////

///values to receive////
int32_t a; //it will not work with int 
int32_t b;
float c;
float d;
int i,e;
/////****////

void setup() {
 Serial.begin(9600);
  pinMode(13,OUTPUT); //Arduino Mega ledpin
  }


void loop() {

}

void serialEvent() { //Called each time Serial data is received
  a=Serial.parseInt();
  b=Serial.parseInt();
  c=Serial.parseFloat();
  d=Serial.parseFloat();
  if (a==22){ //Access each struct number.
     if (b==-22){
         if (c==2212.113){
            if (d==-3131.111){ //If the password is right
                Serial.println(aa);
                Serial.println(bb);
                Serial.println(cc,3); //must be &lt;=3 decimal places else it 
//will 
//rounded
                Serial.println(dd,3); //must be &lt;=3 decimal places else it 
//will 
//rounded
                delay(100);
                digitalWrite(13,HIGH);//Turn ON LED.
            }
         }
      }
   }
}
</code></pre>

<p>Python side:<a href=""https://drive.google.com/file/d/1gPKfhTvbd4vp4L4VrZuns95yQoekg-vn/view?usp=sharing"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/1gPKfhTvbd4vp4L4VrZuns95yQoekg-vn/view?usp=sharing</a></p>

<pre><code>import os 
import struct 
import serial
import time
print('HELLO WORLD!!!!\nI AM PYTHON READY TO TALK WITH ARDUINO\nINSERT 
PASSWORD PLEASE.')
ser=serial.Serial(""COM5"", 9600) #Serial port COM5, baudrate=9600
ser.close()
ser.open() #open Serial Port
a = int(raw_input(""Enter number: "")) #integer object
b = int(raw_input(""Enter number: "")) #integer object
c = float(format(float(raw_input(""Enter number: "")), '.3f'))#float object # 
#&lt;=3 
#decimal places
d = float(format(float(raw_input(""Enter number: "")), '.3f'))
time.sleep(2) #wait 
ser.write(str(a).encode()) #convert int to string and write it to port 
ser.write('\n'.encode())
ser.write(str(b).encode())
ser.write('\n'.encode())
ser.write(str(c).encode())
ser.write('\n'.encode())
ser.write(str(d).encode())
ser.write('\n'.encode())
if str(a) == ""22"" :
 if str(b) == ""-22"" :
  if str(c) == ""2212.113"" :
   if str(d) == ""-3131.111"" :
    print(""Congratulations!!! Check the ledpin should be ON!!!"")
    number1=int(ser.readline()) #read from Serial port convert to int
    number2=int(ser.readline())
    number3=float(ser.readline()) ##read from Serial port convert to float 
#(3 
#decimal places from arduino)
    number4=float(ser.readline())
    print ""Arduino also send me back 
"",str(number1),"","",str(number2),"","",str(number3),"","",str(number4)
   else :
      print(""WRONG PASSWORD"")
os.system(""pause"") #wait for user to press enter
</code></pre>

<p>WITH_STRUCT better performance</p>

<p>Arduino side:<a href=""https://drive.google.com/file/d/153fuSVeMz2apI-JbDNjdkw9PQKHfGDGI/view?usp=sharing"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/153fuSVeMz2apI-JbDNjdkw9PQKHfGDGI/view?usp=sharing</a></p>

<pre><code>struct sendata { //data to send
  volatile int32_t a=53;
  volatile int32_t b=-2121;
  volatile float c=4112.3;
  volatile float d=-7631.4;
 };

struct receive { //data to receive
  volatile int32_t a; //it will not work with int 
  volatile int32_t b;
  volatile float c;
  volatile float d;
};

struct receive bytes;
struct sendata values;


const int total_bytes=16; //total bytes to send
int i;
byte buf[total_bytes]; //each received Serial byte saved into byte array


void setup() {
  Serial.begin(9600);
  pinMode(13,OUTPUT); //Arduino Mega ledpin
 }


void loop() {

}

void serialEvent() { //Called each time Serial data is received
  if (Serial.available()==total_bytes){ //Receive data first saved to Serial 
//buffer,Serial.available return how many bytes are saved.The Serial buffer 
//space 
//is limited.
       while(i&lt;=total_bytes-1){
           buf[i] = Serial.read(); //Save each byte from Serial buffer to 
//byte 
//array
            i++;
       }
       memmove(&amp;bytes,buf,sizeof(bytes)); //Move each single byte memory 
//location of array to memory field of the struct,the numbers are 
//reconstructed 
//from bytes.
      if (bytes.a==22){ //Access each struct number.
        if (bytes.b==-22){
          if (bytes.c==2212.113){
             if (bytes.d==-3131.111){ //If the password is right
                Serial.write((const uint8_t*)&amp;values,sizeof(values)); //Write 
//struct to Serial port.
                delay(100);
                digitalWrite(13,HIGH);//Turn ON LED.
             }
           }
         }
      }
   }
}
</code></pre>

<p>Python side:<a href=""https://drive.google.com/file/d/1M6iWnluXdNzTKO1hfcsk3qi9omzMiYeh/view?usp=sharing"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/1M6iWnluXdNzTKO1hfcsk3qi9omzMiYeh/view?usp=sharing</a></p>

<pre><code>import os 
import struct 
import serial
import time
print('HELLO WORLD!!!!\nI AM PYTHON READY TO TALK WITH ARDUINO\nINSERT 
PASSWORD PLEASE.')
ser=serial.Serial(""COM5"", 9600) #Serial port COM5, baudrate=9600
ser.close()
ser.open() #open Serial Port
a = int(raw_input(""Enter number: "")) #integer object
b = int(raw_input(""Enter number: "")) #integer object
c = float(format(float(raw_input(""Enter number: "")), '.3f'))#float object 
#&lt;=3 
#decimal places
d = float(format(float(raw_input(""Enter number: "")), '.3f'))
time.sleep(2) #wait 
ser.write(struct.pack(""2i2f"",a,b,c,d)) #write to port all all number bytes
if a == 22 :
 if b == -22 :
  if c == 2212.113 :
   if d == -3131.111 :
    print(""Congratulations!!! Check the ledpin should be ON!!!"")
    receivedbytes=ser.read(16) #read from Serial port 16 bytes=2 int32_t + 2 
#floats from arduino
    (number1,number2,number3,number4,)=struct.unpack(""2i2f"",receivedbytes) 
#convert bytes to numbers
   number3=float(format(number3, '.3f')) #floats must be under 3 decimal 
#points else will be rounded
    number4=float(format(number4, '.3f'))
    print ""Arduino also send me back 
"",str(number1),"","",str(number2),"","",str(number3),"","",str(number4)
   else :
      print(""WRONG PASSWORD"")
os.system(""pause"") #wait for user to press enter
</code></pre>

<p>Youtube video: <a href=""https://www.youtube.com/watch?v=yjfHwO3qSgY&amp;t=170s"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=yjfHwO3qSgY&amp;t=170s</a></p>
",,,
50494185,2,50494121,2018-05-23T17:25:34.940,3,,1782465,,2018-05-23T17:53:13.520,2018-05-23T17:53:13.520,7,,"<p><code>newReading</code> returns the <code>InuReading</code> by value, which means that <code>r</code> in <code>addTemperatureReading</code> is a local object and has no relationship whatsoever to the objects stored in the task's <code>readings</code> vector.</p>

<p>You probably want <code>newReading</code> to return a reference, and change <code>addTemperatureReading</code> to use a reference too:</p>

<pre><code>void InuTask::addTemperatureReading(String sensor, float temperature){
    InuReading &amp;r = newReading(""temperature"", sensor);
    r.set(""d"", temperature);
    // Size here after setting ""d"" to 30.0 is 1, which is proper
    Serial.printf(""Size of %s is now: %i \n"", r.type.c_str(), r.data.size());
}
</code></pre>

<p>Note that this change also requires you to return a reference <em>into</em> the <code>readings</code> vector from <code>newReading</code>:</p>

<pre><code>InuReading&amp; InuTask::newReading(String t, String l){
    readings.push_back(InuReading(t, l);
    return readings.back();
}
</code></pre>
",,,
50504426,2,50500328,2018-05-24T08:23:40.927,1,,8653951,,2018-05-24T08:23:40.927,,2,,"<p>The definition for sprintf is  </p>

<pre><code>int sprintf ( char * str, const char * format, ... );
</code></pre>

<p>So if you want to convert your number into a string (and that is what sprintf does) you have to give it an array of char where to put the string:</p>

<pre><code>char output[9];
uint32_t a = dec_to_bin(100);

sprintf(output, ""%08lu"", a);
</code></pre>

<p>That should solve your compile error.</p>

<p>The second problem is you dec_to_bin function. The return values does not matches the value you are returning.</p>

<pre><code>uint32_t dec_to_bin( uint32_t n ){

    uint32_t binaryNumber = 0;
    uint32_t remainder, i = 1;

    //prevent overflow
    if ( n &gt; 255) {
        return 0;
    }

    while (n!=0){
        remainder = n%2;
        n /= 2;
        binaryNumber += remainder*i;
        i *= 10;
    }
    return binaryNumber;
}
</code></pre>
",,,
50523570,2,50523515,2018-05-25T07:20:02.743,31,,9500171,,2020-01-13T19:46:16.703,2020-01-13T19:46:16.703,13,,"<p>You're looking for bitfields.</p>

<p>They look like this:</p>

<pre><code>typedef struct {
  uint32_t month  : 4;   // 1..12 [4 bits]
  uint32_t date   : 5;   // 1..31 [5 bits]
  uint32_t hour   : 5;   // 00..23 [5 bits]
  uint32_t minute : 6;   // 00..59 [6 bits]
  uint32_t second : 6;   // 00..59 [6 bits]
} TimeStamp;
</code></pre>

<p><em>Depending on your compiler, in order to fit into four bytes with no padding, the size of the members must be four bytes (i.e. <code>uint32_t</code>) in this case. Otherwise, the struct members will get padded to not overflow on each byte boundary, resulting in a struct of five bytes, if using <code>uint8_t</code>. Using this as a general rule should help prevent compiler discrepancies.</em></p>

<p>Here's an MSDN link that goes a bit in depth into bitfields:</p>

<p><em><a href=""https://msdn.microsoft.com/en-us/library/ewwyfdbe.aspx"" rel=""nofollow noreferrer"">C++ Bit Fields</a></em></p>
",,,
50525741,2,50523515,2018-05-25T09:21:10.413,13,,1866300,,2018-05-25T09:21:10.413,,5,,"<p>Another solution is to store the values in one 32 bits variable and retrieve the individual items with bitshifting.</p>

<pre><code>uint32_t timestamp = xxxx;

uint8_t month = timestamp &amp; 0x0F;
uint8_t date = (timestamp &amp; 0x1F0) &gt;&gt; 4;
uint8_t hour = (timestamp &amp; 0x3E00) &gt;&gt; 9;
uint8_t minute = (timestamp &amp; 0xFC000) &gt;&gt; 14;
uint8_t second = (timestamp &amp; 0x3F00000) &gt;&gt; 20;
</code></pre>
",,,
50555808,2,50547181,2018-05-27T19:35:36.227,1,,28128,,2018-05-28T05:14:47.817,2018-05-28T05:14:47.817,1,,"<p>It would generally help if you could provide an <a href=""https://stackoverflow.com/help/mcve"">MCVE</a> so others can easily compile your code, see how it works, and try tweaking it.</p>

<p>You should not need to define things like <code>DDRA</code> and <code>PA1</code> in your code.  Just pass the appropriate option to the compiler to specify what AVR you are using (e.g. <code>-mmcu=atmega1284p</code>) and then add <code>#include &lt;avr/io.h&gt;</code> at the top of your program to get those definitions.  And there is usually not much point in copying those definitions from <code>io.h</code> into questions on StackOverflow since they are pretty standard.  Those definitions come from avr-libc, so if you really want to provide those details, you could just say what version of avr-libc you are using.</p>

<p>One of the main premises of your question is that the code you posted with arrays and macros is equivalent to <code>DDRA |= (1 &lt;&lt; PA1);</code>.  Unfortunately, that premise is incorrect.  When GCC sees <code>DDRA |= (1 &lt;&lt; PA1);</code>, it can actually compile that down to a single, atomic AVR instruction that sets bit 1 of the DDRA register.  When GCC sees your code, it does something much more complicated that ends up reading, writing, and modifying the register.  So the array code wastes CPU cycles and is not safe to use if interrupts might modify the DDRA register.</p>

<p>If you don't believe me, you can take a look at this godbolt.org link which compares the assembly for the two methods:</p>

<p><a href=""https://godbolt.org/g/jddzpK"" rel=""nofollow noreferrer"">https://godbolt.org/g/jddzpK</a></p>

<p>It looks like you can actually fix this problem by just adding <code>const</code> qualifiers to your arrays.  Then the compiler will know what values your arrays are holding at compile time and can generate good code.</p>

<pre><code>volatile uint8_t * const FOO_DDR[] = {&amp;DDRA, &amp;DDRA};
uint8_t const FOO[] = {PA1, PA2};
</code></pre>

<p>Now on to your main question, which is how to get rid of redundant arrays.  I don't think there is an easy way to do this, and having two const arrays in your program is not a big deal and they will probably be optimized away at compile time anyway.  What you could do is expand those arrays so that they contain entries for every pin on your chip.  Then when you want to write to a pin, you would simply use a pin number which is an index into the arrays (instead of needing to define new arrays).  The vast majority of your code would then deal with these pin numbers and not worry about the arrays.  So here is how I would write it:</p>

<pre><code>#include &lt;avr/io.h&gt;

// Here is a general GPIO library for your chip.
// TODO: expand these arrays to cover every pin on the chip

#define setAsOutput(i)   { *pin_dir[i] |= (1 &lt;&lt; pin_bit[i]); }
#define setHigh(i)   { *pin_value[i] |= (1 &lt;&lt; pin_bit[i]); }

static volatile uint8_t * const pin_dir[] = {
  &amp;DDRA,  // Pin 0
  &amp;DDRA,  // Pin 1
};

static volatile uint8_t * const pin_value[] = {
  &amp;PORTA,  // Pin 0
  &amp;PORTA,  // Pin 1
};

static const uint8_t pin_bit[] = {
  PA1,    // Pin 0
  PA2,    // Pin 1
};

// Pin definitions for your particular project.
// (e.g. pin 0 is connected to a green LED)

#define GREEN_LED_PIN 0

void nice()
{
  setAsOutput(GREEN_LED_PIN);
  setHigh(GREEN_LED_PIN);
}
</code></pre>

<p>Each GPIO function call above ultimately compiles down into one assembly instruction.</p>

<p>If you dig around in the Arduino Core code, you'll find arrays just like this.  (But the Arduino people make the mistake of accessing those arrays in a wasteful way in their <code>pinMode</code> and <code>digitalWrite</code> functions.)</p>

<p>Note that with the code I provided above, there is a big risk that you will accidentally pass a pin number that is not a compile-time constant, and therefore the compiler will not be able to optimize it, and produce wasteful/unsafe code.  That's one reason why it would be better to use inline assembly and C++ templates like the <a href=""https://github.com/pololu/fastgpio-arduino"" rel=""nofollow noreferrer"">FastGPIO library</a> does.</p>
",,,
50568289,2,50547181,2018-05-28T14:11:15.077,1,,4931630,,2018-06-07T09:50:02.550,2018-06-07T09:50:02.550,1,,"<p>If you want the code to be equivalent to <code>DDRA |= (1 &lt;&lt; PA1);</code> - i.e. the simplest instruction that made at compile time without reading/writing arrays and pointers to IO registers. You may do it like this.</p>

<p>1) Let's assume we have definded somewhere (e.g. thru <code>&lt;avr/io.h&gt;</code>)</p>

<pre><code>#define PA1     1
#define PA2     2
...
#define DDRA    _SFR_IO8(0X01)
#define PB1     1
#define PB2     2
...
#define DDRB    _SFR_IO8(0X01)
</code></pre>

<p>2) You want to have some kind of declaration like this:</p>

<pre><code>#define BIG_RED_LED PA1
#define SMALL_GREEN_LED PB2
</code></pre>

<p>for then just to use them like</p>

<pre><code>setAsOutput(BIG_RED_LED);
setAsOutput(SMALL_GREEN_LED);
setLow(BIG_RED_LED);
setHigh(SMALL_GREEN_LED);
</code></pre>

<p>etc., where each line is a simple write to a BIT in corresponding IO register.</p>

<p>To achieve that you can define tons of</p>

<pre><code>#define DDR_PA0 DDRA
#define PORT_PA0 PORTA
#define PIN_PA0 PINA
#define DDR_PA1 DDRA
#define PORT_PA1 PORTA
#define PIN_PA1 PINA
...
#define DDR_PB0 DDRB
#define PORT_PB0 PORTB
#define PIN_PB0 PINB
...
</code></pre>

<p>and then    </p>

<pre><code>#define setAsOutput(px)   { DDR_ ## px |= (1 &lt;&lt; px); }
#define setHigh(px)   { PORT_ ## px |= (1 &lt;&lt; px); }
#define setLow(px)   { PORT_ ## px &amp;= ~(1 &lt;&lt; px); }
etc.
</code></pre>

<p>then, each time in your code happened something like <code>setAsOutput(PA1)</code> it will be compiled <strong>exactly</strong> the same as DDRA |= (1 &lt;&lt; PA1);</p>

<p><em>But</em>
if you want to store them in the array and access by array index, as it is in your example, then you have no other way except as defining two arrays, or array of structs, where both elements will contain the bit number, or bit mask, and the pointer to the IO/register.
Since, although name <code>PA1</code> <code>PA2</code> etc. have <code>A</code> letter in it, at the runtime it will be compiled into it's value. I.e. 'PA1' will be 1, but also <code>PB1</code> will be 1 too. So it is no way for the compiler to know which register is accessed, considering only the index inside that array.</p>

<p>But here I can give you several little life-hacks: 
1) since registers PINx, DDRx, PORTx are almsot always going in succession in that order (refer to the register set summary in the datasheet), you do not need to store them all, it is enough to store only reference to PINx register, and calculate location of DDRx and PORTx just adding 1 or 2 to the address, since AVR have instructions to inderect memory access with displacement, the code will be effective enough.
2) those registers are located in the lower memory addresses, so instead of storing 2/4-byte pointers you can cast them to <code>byte</code> and cast them back to pointer when accessing. It will not only save space but also speed up. Also it is always a good practice to store that kind of tables in the flash memory, instead of wasting RAM.
3) AVR architecture has only one position bit shifting instructions, so (1 &lt;&lt; x) where x is not known at the compile time - is compiled as a loop, which may be the part requiring the most of time in such kind of code. So, instead of storing <code>uint8_t FOO[] = {PA1, PA2};</code> you may want to store <code>uint8_t FOO[] = {(1 &lt;&lt; PA1), (1 &lt;&lt; PA2)};</code> - i.e. precalculated mask values.</p>
",,,
51834073,2,50547181,2018-08-14T05:08:26.303,0,,1470749,,2018-08-14T05:08:26.303,,0,,"<p>In the end I made use of the <code>_MMIO_BYTE</code> macro function in <code>avr/sfr_defs.h</code> to base new bit manipulation functions on:</p>

<pre><code>#define SET_OUTPUT(pin)     (_MMIO_BYTE(OFFSET_ADDR((pin)[0] + 0x1)) |=  _BV((pin)[1]))
#define SET_INPUT(pin)      (_MMIO_BYTE(OFFSET_ADDR((pin)[0] + 0x1)) &amp;= ~_BV((pin)[1]))
// etc
</code></pre>

<p>This gives easy pin definitions as arrays of pins or single pins:</p>

<pre><code>#define NUM_LEDS 3

const uint16_t LEDS[NUM_LEDS][2] = {
    {PB, 4},
    {PB, 5},
    {PB, 6}
};
const uint16_t BUTTON[2] = {PB, 7};
</code></pre>

<p>Pins can then be manipulated like such:</p>

<pre><code>SET_INPUT(BUTTON);
ENABLE_PULLUP(BUTTON);

for (int i = 0; i &lt; NUM_LEDS; ++i) {
    SET_OUTPUT(LEDS[i]);
    SET_HIGH(LEDS[i]);
}
</code></pre>

<p><strong>Source code</strong> is here: <a href=""https://github.com/morefigs/avr-bit-funcs"" rel=""nofollow noreferrer"">https://github.com/morefigs/avr-bit-funcs</a>.</p>

<p>This was only written for a Mega 2560, but should be easily adaptable to other boards.</p>
",,,
50575312,2,50575239,2018-05-29T01:51:09.917,1,,5429584,,2018-05-29T01:51:09.917,,2,,"<p>In your code you did not initialize a serial connection to your shield.</p>

<p>Depending on Arduino board usied you should select the serial port used by th eshiled.</p>

<p>If youo use Uno yo umust use SoftwareSerial Library to communicate with your code as in this example</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;  
#define RxD 7
#define TxD 6
SoftwareSerial BlueToothSerial(RxD,TxD);
void setup()
{
   Serial.begin(38400);     
   BlueToothSerial.begin(38400); 
   delay(500);
}
void loop()
{
    if(BlueToothSerial.available())
    {
      Serial.print(char(BlueToothSerial.read()));
    }
    if(Serial.available())
    {
      BlueToothSerial.print(char(Serial.read()));
    }       
}
</code></pre>

<p>If you use Mega - check serial used by the shield and mopdify the code above.</p>

<p>You did not say which OS runs on your PC Depending on OS you have to select communication method. For Windows if you would like to use COM ports you must pair with arduino first. Then add COM port for the service provided by the shield (it is SPP once).</p>

<p>Once you get the COM number you can use it in your script on PC side and read data from Arduino.</p>

<p>Better way is to communicate with Bluetooth device without COM ports. If you use Windows it can be done with <a href=""http://www.btframework.com/bluetoothframework.htm"" rel=""nofollow noreferrer"">Bluetooth Framework</a></p>
",,,
50578670,2,50576918,2018-05-29T07:27:06.283,0,,4603670,,2018-05-29T07:27:06.283,,1,,"<p>Looking at this information:</p>

<pre><code>`""$GPRMC,050229.000,A,3008.647,N,11001.282,W,0.1,0.0,140518,11.7,E*4B""`
</code></pre>

<p>Use <code>strtok</code> for parsing:</p>

<pre><code>int main(void)
{
    FILE *fp = fopen(""test.txt"", ""r"");

    char buf[256];
    char *array[20];
    while(fgets(buf, sizeof(buf), fp))
    {
        if(strstr(buf, ""$GPRMC""))
        {
            int count = 0;
            char *token;
            token = strtok(buf, "","");
            while(token != NULL)
            {
                array[count++] = token;
                token = strtok(NULL, "","");
                if(count == 20)
                    break;
            }

            printf(""Latitude : %s %s\n"", array[3], array[4]);
            printf(""Longitude : %s %s\n"", array[5], array[6]);
        }
    }

    return 0;
}
</code></pre>

<p>Result:</p>

<pre><code>Latitude : 3008.647 N
Longitude : 11001.282 W
</code></pre>
",,,
50627567,2,50626605,2018-05-31T15:13:16.310,1,,3545273,,2018-05-31T15:21:16.933,2018-05-31T15:21:16.933,0,,"<p>C++ does not like variable length arrays (never defined in standard even if supported in some implementations) nor raw 2D arrays. If you do not require true <code>[]</code> operator support, my advice is to use accessor functions:</p>

<pre><code>class Array2D {
    size_t width, height;
    uint8_t *data;

public:
    Array2D(size_t width, size_t height): width(width), height(height() {
        data = new uint8_t[width * height];
    }
    ~Arrayt2D() {
        delete[] data;
    }
    // copy/move ctor-assignment operator omitted for brievety but REQUIRED (law of three/five)

    uint8_t getVal(size_t i, size_t j) const {
        return data[i + j * width];
    }
    uint8_t setVal(uint8_t val, size_t i, size_t j) {
        data[i + j * width] = val;
    }
    /* alternatively to use arr.val(i, j) = value :
    uint8_t&amp; val(size_t i, size_t j) {
        return data[i + j * width];
    }
    */
    // other accessors (height, width) omitted but probably useful...
};
</code></pre>

<p>Rather C-ish, but as you cannot use vectors and prefer to avoid templates, it could be a basic skeleton...</p>
",,,
50632605,2,50629966,2018-05-31T20:51:42.423,1,,1503645,,2018-05-31T20:51:42.423,,1,,"<p>If your application is not numerically sensitive, you could use the following approach:  </p>

<p>Instead of using doubles within your struct (which aren't strictly standardized, as mentioned in the comments), you could use two <code>int32_t</code>, <code>a</code> and <code>b</code> for representing a significant and an exponent such that<br>
<em>a*2^b = original_double</em></p>

<p>So your struct will look something like this:</p>

<pre><code>    struct SamplePayload {
    int32_t A_sig;
    int32_t A_exp;
    //B,C...
} payload;
</code></pre>

<p>Then on the receiving side, you will only have to multiply according to the formula above to get the original double.</p>

<p>C provides you with a neat function, <strong><code>frexp</code></strong>, to ease things up.<br>
But since we store both <code>a</code> and <code>b</code> as integers, we need to modify the results a bit in order to get high precision.   </p>

<p>Specifically, since <code>a</code> is guaranteed to be between 0.5 and 1, you need to multiply <code>a</code> by 2^30, and subtract 30 from <code>b</code> in order not to overflow.</p>

<p>Here's an example:</p>

<pre><code>#include &lt;stdio.h&gt;      /* printf */
#include &lt;math.h&gt;       /* frexp */
#include &lt;stdint.h&gt;

int main ()
{
  double param, result;
  int32_t a,b;

  param = +235.0123123;
  result = frexp (param , &amp;b);
  a=(result*(1&lt;&lt;30)) /*2^30*/; b-=30;
  printf (""%f = %d * 2^%d\n"", param, a, b); //235.012312 = 985713081 * 2^-22                                                                                                                 

  return 0;
}
</code></pre>
",,,
50654959,2,50653822,2018-06-02T08:26:54.147,0,,2646880,,2018-06-02T08:26:54.147,,0,,"<p>When a byte(or you call it character, a data that is 8 bit long) is fetched by uart block(the hardware), it is buffered to input buffer so that programmer can read and process it. </p>

<p>In your case, when you send a character, it is fetched and put to the buffer and when you read it there is no more byte available to read unless you send to new one.</p>

<p>In short, read the pin state once. You can do something like:</p>

<pre><code>int matrixPinState = 0

void setup() {

    // do all your setup settings  first

    while (Serial.available() &lt; 0) {

    // wait here for the input

     delay(30);
}

    // got your input, read it

     matrixPinState = Serial.read();
}

void loop() 
{

        if (matrixPinState == 1) 
        {
            matrix.fillScreen(0);
            matrix.setCursor(x, 0);
            matrix.print(F(""Im kind""));

            if (--x &lt; -30) 
            {
                x = matrix.width();

                if (++pass &gt;= 8) pass = 0;
                matrix.setTextColor(colors[pass]);
            }
        matrix.show();
        delay(30);
        }
}
</code></pre>
",,,
50662046,2,50658105,2018-06-02T23:30:25.957,4,,4931630,,2018-06-02T23:30:25.957,,0,,"<p>There are many aspects hidden in your question.</p>

<p><strong>1.</strong> First of all, the counter variable should be marked <code>volatile</code>. The compiler is applying different optimizations to variables, so it may, say, load a variable into a register and continue to work with register, assuming it is only the place, where content of the variable is stored. If a variable is declared with the keyword <code>volatile</code>, then the compiler knows that it could be changed occasionally in any time, therefore the compiler will reload and/or rewrite the variable each time it is accessed. So, it may be declared like this</p>

<pre><code>volatile uint16_t overflow_counter;
</code></pre>

<p>The same goes for the <code>paused</code> variable.</p>

<p><strong>2.</strong> You should remember that, if interrupts are not disabled, then timer interrupt can occur between any two processor's instructions. Since processor is 8bit, it access the memory using 8-bit wide bus. That means, to read 16-bit data, it requires 2 instructions. Let's say we copy the counter value into a local variable:</p>

<pre><code>uint16_t counter_snapshot = overflow_counter;
</code></pre>

<p>The local variable will allocate two registers and two memory read operations will be performed. Let's imagine the interrupt is happened after first of them, but before second. So, on output you'll have half of the number copied from it's previous value, while the second half from it's new. I.e. the value will be damaged. It will not be happened, if variable is 8-bit and copied by one instruction. But if it is wider, or if it is read-modified-written, then precautions should be taken:</p>

<pre><code> uint8_t old_sreg = SREG; // SREG i/o register contains processor state flags, including ""interrupt flag"", which allows interrupt
 cli(); // clear the ""interrupt flag"", preventing interrupts from happening
 uint16_t counter_snapshot = overflow_counter; // safely taking the snapshot
 SREG = old_sreg; // restoring the ""interrupt flag"" to it's previous state. Other flags also restored but we do not care about them.
</code></pre>

<p><strong>3.</strong> As said above, interrupt can happen in any time. That means if you try to read overflow_counter and TCNT1 both, the interrupt can be happened in between, so, result will be not as expected. Especially if reading of those two values is separated by such a long operation as floating-point multiplication. So, workaround may be as follows:</p>

<pre><code> uint8_t old_sreg = SREG; // saving state
 cli(); // locking interrupts
 // latching values we are interested in
 uint16_t latch_overflow_counter = overflow_counter;
 uint16_t latch_tcnt1 = TCNT1; 
 uint8_t latch_tifr1 = TIFR1;
 SREG = old_sreg; // restoring interrupts
 /* We are disabling interrupts, but it do not stop the timer from counting,
 therefore TCNT1 value continue changing, and timer could overflow in any time
 within that block above. But which moment exactly? Before we read TCNT1 or just after? 
 Let's assume if TCNT1 have high values then we got it's value just before the timer overflow;
 otherwise, overflow happened before that */
 if ((latch_tifr1 &amp; (1 &lt;&lt; TOV1)) &amp;&amp; // we got the overflow flag set
     (latch_tcnt &lt; 32768) { // we are within the low values
     latch_overflow_counter++; // increasing the latched value
 }

double time = ( latch_overflow_counter * 65536.0 + latch_tcnt1 ) * PRESCALE  / FREQ; // now using latched values to calculate...
</code></pre>

<p>By the way, throughput can be much improved, if avoid using floating point where it is not necessary.</p>
",,,
50704259,2,50703901,2018-06-05T15:51:19.160,1,,6755083,,2018-06-05T17:22:17.613,2018-06-05T17:22:17.613,5,,"<p>Use custom delay function like so :</p>

<pre><code>bool LedOn;

void MyDelay(int ms) {
   for(int i=0;i&lt;ms;i++){
      if (Serial.available())
      {
        LightOff();
        LedOn = false;
        break;
      }
      delay(1);
   }
}

void LightON() {
    digitalWrite(red, HIGH);
    MyDelay(1000);
    if(! LedOn) return;
    digitalWrite(yellow, HIGH);
    MyDelay(1000);
    if(! LedOn) return;
    digitalWrite(red, LOW);
    MyDelay(1000);
}
void loop() {
  LedOn = true;
  LightON();
  if (Serial.available())
  {
    LightOff();
    LedOn = false;
  }
}
</code></pre>
",,,
50704271,2,50703901,2018-06-05T15:51:39.883,1,,669576,,2018-06-05T16:23:10.167,2018-06-05T16:23:10.167,0,,"<p><code>LightON</code> will always take 3 seconds. To avoid this, things get more complicated. You can use a state machine to keep track of where the blink sequence is at any given time. This also has the benefit of allowing your code to do other things instead of busy-looping or waiting on <code>delay()</code>.</p>

<pre><code>// This class represents the led state machine
class blinker {
    public:
    // Possible states
    enum {START, RED_ON, YELLOW_ON, RED_OFF, INACTIVE};

    // Constructor
    blinker(byte red_pin, byte yellow_pin, long timeout=1000) :
            red(red_pin), yellow(yellow_pin), timeout(timeout), state(INACTIVE) {
        pinMode(red, OUTPUT);
        pinMode(yellow, OUTPUT);
    }

    // Start the loop from the beginning
    void start() {
        stop();
        state = START;
    }
    // Stop the loop
    void stop() {
        digitalWrite(red, LOW);
        digitalWrite(yellow, LOW);
        state = INACTIVE;
    }

    // Update
    void loop() {
        // Only change if started and time is up
        if (state != INACTIVE &amp;&amp; timer_expired()) {
            switch (state) {
                // Starting over?
                case START:
                    state = RED_ON;
                    digitalWrite(red,HIGH);
                    break;
                // Red is on, turn yellow on
                case RED_ON:
                    state = YELLOW_ON;
                    digitalWrite(yellow,HIGH);
                    break;
                // Yellow is on, turn red off
                case YELLOW_ON:
                    state = RED_OFF;
                    digitalWrite(red,LOW);
                    break;
                // Red is off, start over
                case RED_OFF:
                    state = START;
            }
        }
    }    

    protected:
    byte red, yellow;
    long timeout;

    // Returns true when time is up. 
    // Also resets the timer    
    bool timer_expired() {
        if ((millis() - last_time) &gt;= timeout) {
            last_time = millis();
            return true;
        }
        return false;
    }
};

// Create the state machine
blinker blinky(9, 8);
void setup() {
    Serial.begin(9600);
    // Start loop
    blinky.start();
}

void loop() {
    // Call this everytime
    blinky.loop();

    // Stop?
    if (Serial.available()) {  
        blinky.stop();
    }

    // Can do other stuff here
}
</code></pre>

<p>I just threw this together. You can improve on it.</p>
",,,
50709074,2,50708707,2018-06-05T21:18:24.520,2,,8746007,,2018-06-05T21:18:24.520,,3,,"<p>Not sure what Arduino supports and what not, maybe try something like this and see if it works:</p>

<pre><code>struct Product
{
    float price;
    char const *name;
    float volume;
};

Product const products[4] =
{
    { 1.09, ""Coke"", 0.33 },
    { 0.71, ""Coke Zero"", 0.33 },
    { 0.44, ""Water"", 0.5 },
    { 1.09, ""Sprite"", 0.33 }
};
</code></pre>

<p>And then you could refer to your products as </p>

<p><code>products[0].name</code>, <code>products[0].price</code>, <code>products[0].volume</code> etc.</p>
",,,
50747618,2,50747457,2018-06-07T18:08:06.017,4,,5245033,,2018-06-07T18:08:06.017,,3,,"<p>Only a handful of things are allowed in global scope, and assignment is not one of them.</p>

<p>You are allowed to declare or define variables (and initialize them), so this is why you can define your array. One way of achieving your goal would be to initialize the array, instead of assign values to it:</p>

<pre><code>int angles[5][3] {
                  {1, 2, 3},
                  {3, 4, 5},
                  {5, 6, 7},
                  {8, 9, 10},
                  {11, 12, 13}
                 };
</code></pre>
",,,
50788128,2,50787947,2018-06-10T21:18:45.900,2,,485343,,2018-06-13T12:35:42.317,2018-06-13T12:35:42.317,3,,"<p>It depends on whether <code>char txt[19]</code> is declared in <a href=""http://en.cppreference.com/w/cpp/language/scope"" rel=""nofollow noreferrer"">scope</a> of a function or at a global (or namespace) scope.</p>

<p>If in scope of a function, then <code>txt</code> will be allocated on the stack and initialized at run time from a copy of the <em>string literal</em> residing in a (read-only) data segment.</p>

<p>If at global scope, then it will be allocated at build time in the data segment.</p>

<p>Bonus: if it's allocated in some sub-scope, like a loop body, then you should assume it will be initialized during every loop iteration (the optimizer might do some tricks but don't count on it).</p>

<p><strong>Example 1:</strong></p>

<pre><code>int len = 18;
char txt[19] = ""The cake is a lie."";
int main() {
    write(len,txt);
}
</code></pre>

<p>Here <code>len</code> (an <code>int</code>) and <code>txt</code> (19 bytes + alignment padding) will be allocated in the program's data segment at build time.</p>

<p><strong>Example 2:</strong></p>

<pre><code>int main() {
    int len = 18;
    char txt[19] = ""The cake is a lie."";
    write(len,txt);
}
</code></pre>

<p>Here the string literal <code>""The cake is a lie.""</code> will be allocated in the program's data segment at build time. In addition, <code>len</code> and <code>txt</code> (19 bytes + padding) may be allocated on the stack at run time. The optimizer may omit the <code>len</code> allocation and maybe even <code>txt</code>, but don't count on it, as it's going to depend on many factors, like whether <code>write</code> body is available, what it does exactly, the quality of the optimizer, etc. When in doubt, <em>look</em> at the generated code (<a href=""https://godbolt.org/"" rel=""nofollow noreferrer"">godbolt</a> now supports AVR targets).</p>

<p><strong>Example 3:</strong></p>

<pre><code>int main() {
    write(18,""The cake is a lie."");
}
</code></pre>

<p>Here the string literal <code>""The cake is a lie.""</code> will be allocated in the program's data segment at build time. The <code>18</code> will be embedded in the program code.</p>

<hr>

<p>Since you're developing on AVR, there are some additional specifics worth mentioning, namely the application's executable is initially stored in the <a href=""http://playground.arduino.cc/Learning/Memory"" rel=""nofollow noreferrer"">Flash</a>, and once you ""run"" it, it is copied to the RAM. It is possible to avoid copying to RAM and keep the data in the Flash using the <a href=""https://www.arduino.cc/reference/en/language/variables/utilities/progmem/"" rel=""nofollow noreferrer""><code>PROGMEM</code></a> keyword (though to do anything meaningful with the data you will need to copy it to RAM).</p>
",,,
50894035,2,50892571,2018-06-17T05:44:03.740,0,,9347417,,2018-06-17T05:44:03.740,,0,,"<p>First things first. Design your system! What's the smart way of communication? Sending so many bytes? or just one byte? If I am to do it, I would think of 4 different possible states : 1- Both LEDs should be on -> I would send A to Arduino to indicate this state  2- Left LED is on, while right LED is off -> send B to Arduino  3- Right LED is on, while left LED is off -> send C to Arduino  4- Both LEDs are off -> send D to Arduino</p>

<p>Now your processing code can be something like this: </p>

<pre><code>import processing.serial.*;

Serial myPort;

boolean leftLed;
boolean rightLed;

void setup() {
    size(640, 360);
    background(100); 
    noStroke();

    String portName = Serial.list() [1];
    myPort = new Serial(this, portName, 9600);

    leftLed=false;
    rightLed=false;
} 


void draw() { 

    fill(value1); 
    rect(150, 50, 50, 50); 
    fill(value2); 
    rect(50, 210, 50, 50); 
}

void updateArduino(){
    if(rightLed &amp;&amp; leftLed) myPort.write(""A"");
    else if(leftLed) myPort.write(""B"");
    else if(rightLed) myPort.write(""C"");
    else myPort.write(""D"");
}

void mousePressed() { 
    if (mouseX &gt; 149 &amp;&amp; mouseX &lt; 200 &amp;&amp; mouseY &gt; 49 &amp;&amp; mouseY &lt; 101) 
        leftLed = !leftLed;
    else if (mouseX &gt; 49 &amp;&amp; mouseX &lt; 100 &amp;&amp; mouseY &gt; 209 &amp;&amp; mouseY &lt; 250) 
        rightLed=!rightLed;
    updateArduino();
}
</code></pre>

<p>And in Arduino, read them like this:</p>

<pre><code>if (Serial.available()){
  char temp=Serial.read();
  if(temp=='A') {
    //turn on both lights
  }
  else if(temp=='B'){
    //turn on left light
  }
  else if(temp=='C'){
    //turn on right light
  }
  else if(temp=='D'){
   //turn off both lights
  }
}
</code></pre>
",,,
50944191,2,50940362,2018-06-20T08:57:36.617,1,,1644446,,2018-06-20T11:24:59.687,2018-06-20T11:24:59.687,2,,"<p>Try something like this.</p>

<pre><code>HTTPClient http;
http.begin(""http://localhost:8080/ApparelProject/device/saveDistance/125"");
http.addHeader(""Content-Type"", ""text/plain;charset=UTF-8"");
int httpCode = http.POST();

Serial.println(httpCode);
http.end();
</code></pre>

<p>Try something like this to ensure the connection is working.</p>

<pre><code>    void setup() {

  Serial.begin(115200);
  delay(4000);   //Delay needed before calling the WiFi.begin

  WiFi.begin(ssid, password); 

  while (WiFi.status() != WL_CONNECTED) { //Check for the connection
    delay(1000);
    Serial.println(""Connecting to WiFi.."");
  }

  Serial.println(""Connected to the WiFi network"");

}
</code></pre>
",,,
50953936,2,50940362,2018-06-20T17:29:23.917,1,,6689345,,2018-06-20T17:36:15.067,2018-06-20T17:36:15.067,0,,"<p>Try this...
You will needed <code>ArduinoJSON</code> Library for this.</p>

<pre><code>StaticJsonBuffer&lt;300&gt; JSONbuffer;   //Declaring static JSON buffer
  JsonObject&amp; JSONencoder = JSONbuffer.createObject();

  JSONencoder[""value""] = ""125""; //or some variable
  char JSONmessageBuffer[300];
  JSONencoder.prettyPrintTo(JSONmessageBuffer, sizeof(JSONmessageBuffer));

  HTTPClient http;    //Declare object of class HTTPClient

  http.begin(""http://Your_PC_IP_Address:8080/ApparelProject/device/saveDistance"");      //Specify request destination
  http.addHeader(""Content-Type"", ""application/json"");  //Specify content-type header

  int httpCode = http.POST(JSONmessageBuffer);   //Send the request
  String payload = http.getString();                  //Get the response payload
</code></pre>

<p>It gives you this kind of JSON array.</p>

<pre><code>{
   value:""125""
}
</code></pre>

<p>According to that change your Backend API sorry I don't have much knowledge about Spring Endpoint.</p>
",,,
50989387,2,50983952,2018-06-22T13:44:30.203,1,,9271481,,2018-06-22T13:44:30.203,,6,,"<p>In the SPI connection, a master have to send some data to receive data from a slave. It is like circular buffer(<a href=""https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Data_transmission"" rel=""nofollow noreferrer"">See an image of ""Data transmission"" section</a>).</p>

<p>To accomplish what you want, the master has to send 5 more bytes to get 'h', 'e', 'l', 'l', 'o' from the slave.</p>

<p>Here is the example of sketch.</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;stdlib.h&gt;

char in_buf[100];
char out_buf[20] = ""hello"";
volatile int in_pos;
volatile int out_pos;
volatile boolean is_sending;
volatile boolean process_it;

void setup (void)
{
  //Start the Serial for the debugging
  Serial.begin (115200);

  // have to send on master in, *slave out*
  pinMode(MISO, OUTPUT);
  pinMode(SS,INPUT);

  //Setting up the LED pin as OUTPUT
  pinMode(7,OUTPUT);
  pinMode(6,OUTPUT);

  // turn on SPI in slave mode
  SPCR |= _BV(SPE);

  // get ready for an interrupt
  in_pos = 0;   // in_buf empty
  out_pos = 0;   // out_buf empty
  is_sending = false;

  // now turn on interrupts
  SPI.attachInterrupt();

}  // end of setup


// SPI interrupt routine
ISR (SPI_STC_vect)
{
  byte c = SPDR; // grab byte from SPI Data Register

  if(is_sending == false){
    // add to in_buf if room
    if (in_pos &lt; sizeof(in_buf))
    {
      in_buf[in_pos++] = c;

      // example: newline means time to process buffer and to send out_buf
      if (c == '\n')
      {
        is_sending = true;
        process_it = true;
        SPDR = out_buf[out_pos++]; // send first byte
      }
    }  // end of room available
  }
  else
  {
    SPDR = out_buf[out_pos];
    if(out_buf[out_pos] == 0 || ++out_pos &gt;= sizeof(out_buf))
    {
      is_sending = false;
      out_pos = 0;
    }
  }
}  // end of interrupt routine SPI_STC_vect

// main loop - wait for flag set in interrupt routine
void loop (void)
{
  if(process_it)
  {
    in_buf[in_pos] = 0;
    int buff = atoi(in_buf);
    Serial.println(buff);
    switch(buff){
      case 10:
        digitalWrite(6,HIGH);
        digitalWrite(7,LOW);
        break;
      case 11:
        digitalWrite(6,LOW);
        digitalWrite(7,HIGH);
        break;
    }
    in_pos = 0;
    process_it = false;
  }  // end of flag set
}
</code></pre>

<p>Here is the example of python code.</p>

<pre><code>import time
import spidev

spi = spidev.SpiDev()
spi.open(0, 0)
spi.max_speed_hz = 100000

while True:
  resp = spi.xfer([0x31, 0X31, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x01])
  print(''.join([chr(_) for _ in resp[-5:]]))
  time.sleep(1)
  resp1 = spi.xfer([0x31, 0x30, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x01])
  print(''.join([chr(_) for _ in resp1[-5:]]))
  time.sleep(1)
</code></pre>

<p>I think this following website is also useful for you.
<a href=""https://arduino.stackexchange.com/questions/33086/how-do-i-send-a-string-from-an-arduino-slave-using-spi"">How do I send a string from an Arduino Slave using SPI?</a></p>
",,,
51023233,2,51022682,2018-06-25T12:13:08.550,0,,9913960,,2018-06-25T12:13:08.550,,0,,"<p>The problem is your label declaration. You create a local variable label wich is destroyed at the end of the EDLController constructor.
You can confirm that by inheriting QLabel like this :</p>

<hr>

<pre><code>class MyLabel : public QLabel
{
    Q_OBJECT
public:
    MyLabel(const QString&amp; str, QWidget* parent = nullptr) : QLabel(str,parent){}
    ~MyLabel() {qDebug() &lt;&lt; ""LABEL DELETED"";}
};
</code></pre>

<hr>

<p>The ""LABEL DELETED"" message will be logged when the QDialog is instanced. 
And, of course, you cannot display a deleted widget.</p>

<p>The correct code is the following :</p>

<hr>

<pre><code> QLabel* label = new  QLabel(""text"");
 vBoxLayout.addWidget(label);
</code></pre>

<hr>

<p>The label will be destoyed when the parent item (your dialog) will be destroyed.</p>
",,,
51060936,2,51022682,2018-06-27T10:50:51.793,0,,8106002,,2018-06-27T10:50:51.793,,0,,"<p><code>vBoxLayout</code> and <code>label</code> will be destroyed when <code>EDLController</code> constructor exits because they are local variables. Create new instances on heap to avoid that:</p>

<pre><code>EDLController::EDLController(QWidget *parent)
    : QDialog(parent)
{
    QVBoxLayout * vBoxLayout = new QVBoxLayout(this);
    QLabel * label = new QLabel(this);
    label-&gt;setText(""test"");
    vBoxLayout-&gt;addWidget(label);

    setLayout(vBoxLayout);
    setWindowTitle(""test"");
}
</code></pre>
",,,
51049421,2,51043477,2018-06-26T18:32:17.587,0,,1983409,,2018-06-26T20:28:32.243,2018-06-26T20:28:32.243,0,,"<p>I am not sure I understood your question.</p>

<ul>
<li><em>""How do I implement <code>seekg</code>?""</em> There is not <a href=""https://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow noreferrer""><code>seekg</code></a>. There is however, a <a href=""https://www.arduino.cc/en/Reference/FileSeek"" rel=""nofollow noreferrer""><code>seek</code></a>.</li>
<li><a href=""https://www.arduino.cc/en/Reference/SD"" rel=""nofollow noreferrer"">This</a> is the documentation page for the SD library. In the right side of the page there is a list of all <code>File</code> class methods (<code>seek</code> among others).</li>
<li><em>"" How do I read the last line...""</em> There is no line reading in your code. If you just want to go to the end of file use: <code>SD_File.seek( SD_File.size() );</code> If you want to read the last line, the simplest way is to write a <code>getline</code> function and read the whole file line by line until end. Assuming <code>MAX_LINE</code> is <strong>large enough</strong> and <code>getline</code> returns zero on success:</li>
</ul>

<p></p>

<pre><code>//...
char s[ MAX_LINE ];
while ( getline( f, s, MAX_LINE , '\n' ) == 0 )
  ;

// when reaching this point, s contains the last line
Serial.print( ""This is the last line: "" );
Serial.print( s );
</code></pre>

<p>Here's a <code>getline</code> idea (no warranty - not tested):</p>

<pre><code>/*
  s     - destination
  count - maximum number of characters to write to s, including the null terminator. If 
          the limit is reached, it returns -2.
  delim - delimiting character ('\n' in your case)

  returns:
     0 - no error
    -1 - eof reached
    -2 - full buffer
*/
int getline( File&amp; f, char* s, int count, char delim )
{
  int ccount = 0;
  int result = 0;
  if ( 0 &lt; count )
    while ( 1 )
    {
      char c = f.peek();
      if ( c == -1 )
      {
        f.read(); // extract
        result = -1;
        break;  // eof reached
      }
      else if ( c == delim )
      {
        f.read(); // extract
        ++ccount;
        break; // eol reached
      }
      else if ( --count &lt;= 0 )
      {
        result = -2;
        break; // end of buffer reached
      }
      else
      {
        f.read(); // extract
        *s++ = c;
        ++ccount;
      }
    }

  *s = '\0'; // end of string
  return ccount == 0 ? -1 : result;
}
</code></pre>
",,,
51047992,2,51047481,2018-06-26T16:53:20.183,-1,,9276160,,2018-06-26T16:53:20.183,,0,,"<p>Use the following programs to send and receive serial data from Arduino:</p>

<p><a href=""https://www.codeproject.com/Questions/718340/C-program-to-Linux-Serial-port-read-write"" rel=""nofollow noreferrer"">Original Source</a></p>

<p><strong>SEND.c</strong></p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;termios.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;




#define BAUDRATE B115200 //Baud Rate Here
#define MODEMDEVICE ""/dev/ttyUSB0"" //Serial Port Here
#define _POSIX_SOURCE 1 /* POSIX compliant source */
#define FALSE 0
#define TRUE 1

FILE *file;
int fileLen;
char *tmpbuffer;
void openport(void);
void readport(void);
void sendport(void);
int fd=0;
struct termios oldtp, newtp;
//char sendcmd1[256]=""\0"";
char buffer[512];

void main()
{


    openport();
    sleep(1);
//  readport();
    sendport();




}

void sendport(void)
{
        printf(""enter write\n"");
        int n;
     //   sem_wait(&amp;len);
                file = fopen(""sample.txt"", ""r"");

                //get file size

                fseek(file, 0, SEEK_END);
                fileLen = ftell(file);
                fseek(file, 0, SEEK_SET);

                tmpbuffer = (char *)malloc(fileLen + 1);

                //read file contents
                printf(""Start send\n"");
                fread(tmpbuffer, fileLen, 1, file);
                fclose(file);

                n = write(fd, tmpbuffer, fileLen + 1);

                if (n &lt; 0)
                {
                        fputs(""write() of bytes failed!\n"", stderr);
                }
                else
                {
                        printf(""File sent successfully %d\n"",n);
                }
                close(fd);

}

void openport(void)
{
         fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY |O_NDELAY );
    printf(""Oviya %d\n"",fd);
         if (fd &lt;0)
         {
         perror(MODEMDEVICE);         }

         fcntl(fd,F_SETFL,0);
        tcgetattr(fd,&amp;oldtp); /* save current serial port settings */
        // tcgetattr(fd,&amp;newtp); /* save current serial port settings */
         bzero(&amp;newtp, sizeof(newtp));
        // bzero(&amp;oldtp, sizeof(oldtp));

         newtp.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;

         newtp.c_iflag = IGNPAR | ICRNL;

         newtp.c_oflag = 0;

         newtp.c_lflag = ICANON;

         newtp.c_cc[VINTR]    = 0;     /* Ctrl-c */
         newtp.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
         newtp.c_cc[VERASE]   = 0;     /* del */
         newtp.c_cc[VKILL]    = 0;     /* @ */
         //newtp.c_cc[VEOF]     = 4;     /* Ctrl-d */
         newtp.c_cc[VEOF]     = 0;     /* Ctrl-d */
         newtp.c_cc[VTIME]    = 0;     /* inter-character timer unused */
         newtp.c_cc[VMIN]     = 1;     /* blocking read until 1 character arrives */
         newtp.c_cc[VSWTC]    = 0;     /* '\0' */
         newtp.c_cc[VSTART]   = 0;     /* Ctrl-q */
         newtp.c_cc[VSTOP]    = 0;     /* Ctrl-s */
         newtp.c_cc[VSUSP]    = 0;     /* Ctrl-z */
         newtp.c_cc[VEOL]     = 0;     /* '\0' */
         newtp.c_cc[VREPRINT] = 0;     /* Ctrl-r */
         newtp.c_cc[VDISCARD] = 0;     /* Ctrl-u */
         newtp.c_cc[VWERASE]  = 0;     /* Ctrl-w */
         newtp.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
         newtp.c_cc[VEOL2]    = 0;     /* '\0' */


   //     tcflush(fd, TCIFLUSH);
//  tcsetattr(fd,TCSANOW,&amp;newtp);
}
</code></pre>

<p>Go through the code and modify it according to your will.<br>
This code expects a .txt file as input.</p>

<p>This answer is written from <a href=""https://www.codeproject.com/Questions/718340/C-program-to-Linux-Serial-port-read-write"" rel=""nofollow noreferrer"">https://www.codeproject.com/Questions/718340/C-program-to-Linux-Serial-port-read-write</a> </p>

<p>Visit the original site for additional information</p>
",,,
51058647,2,51052223,2018-06-27T09:02:35.343,2,,1168733,,2018-06-27T09:02:35.343,,1,,"<p>You cannot initialize members in the class declaration. Try with:</p>

<pre><code>class LCD
{   
  public:
    LCD();
    void firstLine();
    void secondLine(float tempInCelsius);

  private:
    LiquidCrystal_I2C lcd; 
};
</code></pre>

<p>But you can initialize such members (<strong>must</strong>, if they do not provide a default constructor) in the constructor(s). Try with:</p>

<pre><code>LCD::LCD() : lcd(0x27, 16, 2) {
    Serial.begin(9600);
    Serial.println(""Test 01"");
    lcd.init();
    lcd.backlight();
    lcd.setCursor(0, 0);
}
</code></pre>
",,,
51067148,2,51055140,2018-06-27T16:04:54.437,0,,28128,,2018-06-27T16:04:54.437,,0,,"<p>The error message from the compiler is very useful and if you would follow its advice of replacing <code>.</code> with <code>-&gt;</code> it would probably fix your immediate problem.  Since <code>canbus_esc</code> is a pointer, you must dereference it before accessing its members or functions.  So if it has a function named <code>begin</code> that can be called with zero arguments, you might write:</p>

<pre><code>canbus_esc-&gt;begin();
</code></pre>

<p>That line is equivalent to:</p>

<pre><code>(*canbus_esc).begin();
</code></pre>

<p>Also, get rid of the word <code>extern</code> on the line that defined <code>canbus_esc</code>, or else you will get an undefined reference error for it.</p>

<p>However, I have two issues with the code you have presented:  First of all, you are using <code>new</code>, which does dynamic memory allocation.  It's a good idea to avoid dynamic memory allocation on small devices like AVRs if you can, since you never know if those allocations are going to fail until you actually run the program (you might be using up too much memory in other parts of your program).  Secondly, you defined your <code>canbus_esc</code> at the file scope, so there can only be one of them.  This means you can't really create multiple <code>HSBC_CAN</code> objects; the second one will overwrite the <code>canbus_esc</code> create by the first.  Although that might be fine for your application, it seems like a needless limitation.</p>

<p>I'd suggest writing your code like this instead:</p>

<p>Header file:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;mcp_can.h&gt;
class HSBC_CAN {
public:
  HSBC_CAN(uint8_t int_pin, uint8_t cs_pin);
  void begin();
private:
  uint8_t _int_pin;
  MCP_CAN can;
};
</code></pre>

<p>Source file:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;HSBC_CAN.h&gt;

HSBC_CAN::HSBC_CAN(uint8_t int_pin, uint8_t cs_pin)
  : can(cs_pin)  // This line constructs the MCP_CAN object
{
  _int_pin = int_pin;
}

HSBC_CAN::begin()
{
  can.begin(42, 42, 42);  // TODO: fix arguments
}
</code></pre>

<p>Another idea, which might be better, would be for you to have your HSBC_CAN object take a pointer to an MBC_CAN object and store the pointer as a member variable in the HSBC_CAN class.  That option would make a lot of sense if there are multiple devices on the CAN bus that you want to talk to using that MBC_CAN object.  You could have multiple classes using a single MBC_CAN object via pointers.</p>
",,,
51059301,2,51058615,2018-06-27T09:35:15.097,0,,4706785,,2018-06-27T09:35:15.097,,0,,"<blockquote>
  <p>I can also set the buffer to 0 (unsigned char data[0];),</p>
</blockquote>

<p>If this is true, you're just getting lucky (or unlucky, depending on how you look at it).   The behaviour of your code doing this is undefined, in both C and C++.    Which, among other things, means it is not guaranteed to work (e.g.  it might break if your compiler is ever updated).</p>

<p>As to better options ....   Your question is tagged C++ and C, and different approaches are preferable in different languages.</p>

<p>Assuming you are using C, and your implementation complies with the 1999 standard or later, you can use <code>snprintf()</code>.</p>

<pre><code>  char *buffer;
  int length = snprintf((char *)NULL, 0, ""This is the int value: %d"",  myValue);
  buffer = malloc(length + 1);    /*   +1 allows for terminator */
  snprintf(buffer, length, ""This is the int value: %d"", myValue);

   /*  use buffer  */
  free(buffer);
</code></pre>

<p>The first call of <code>sprintf()</code> is used to recover the buffer length.   The second to actually write to the allocated buffer.    Remember to release the dynamically allocated buffer when done.   (The above also does not check for errors - <code>snprintf()</code> returns a negative value if an error occurs).</p>

<p>If your C library does not include <code>snprintf()</code> then (AFAIK) there is no standard way to work out the length automatically - you will need to estimate an upper bound on length by hand (e.g. work out the length of output of the largest negative or positive <code>int</code>, and add that to the length of other content in your format string).</p>

<p>In C++, use a string stream</p>

<pre><code> #include &lt;sstream&gt;
 #include &lt;string&gt;

 std::ostringstream oss;
 oss &lt;&lt; ""This is the int value: "" &lt;&lt; myValue);
 std::string str = oss.str();

 const char *buffer = str.data();

 //   readonly access to buffer here

 //   the objects above will be cleaned up when they pass out of scope.
</code></pre>

<p>If you insist on using the C approach in C++, the approach above using <code>snprintf()</code> can be used in C++ if your implementation complies with the 2011 standard (or later).     However, in general terms, I would NOT recommend this.</p>
",,,
51082491,2,51081508,2018-06-28T12:05:27.967,1,,1256234,,2018-07-04T11:00:27.057,2018-07-04T11:00:27.057,4,,"<p>Step 1: Add wifi setup to your <code>mos.yml</code> so it can connect to your wireless AP:</p>

<pre><code>config_schema:
  - [""wifi.sta.enable"", true]
  - [""wifi.sta.ssid"", ""MyAP""]
  - [""wifi.sta.pass"", ""Passwd""]
</code></pre>

<p>Step 2: Add these to your <code>mos.yml</code>.  Leave off <code>rpc-uart</code> if you have no intention of making rpc calls over UART.</p>

<pre><code>libs:
  - origin: https://github.com/mongoose-os-libs/sntp
  - origin: https://github.com/mongoose-os-libs/crontab
  - origin: https://github.com/mongoose-os-libs/rpc-service-cron
  - origin: https://github.com/mongoose-os-libs/rpc-service-config
  - origin: https://github.com/mongoose-os-libs/wifi
  - origin: https://github.com/mongoose-os-libs/rpc-uart
</code></pre>

<p>Step 3: Add crontab handlers for LED on and LED off:</p>

<pre><code>enum mgos_app_init_result mgos_app_init(void) {
  /* Set LED GPIOs as outputs */
  mgos_gpio_set_mode(YOUR_LED_GPIO, MGOS_GPIO_MODE_OUTPUT);

  /* Register crontab handler - LED OFF */
  mgos_crontab_register_handler(mg_mk_str(""ledoff""), ledoff, NULL);

  /* Register crontab handler - LED ON */
  mgos_crontab_register_handler(mg_mk_str(""ledon""), ledon, NULL);

  return MGOS_APP_INIT_SUCCESS;
}
</code></pre>

<p>Step 4: Add callbacks:</p>

<pre><code>void ledoff(struct mg_str action, struct mg_str payload, void *userdata) {
  mgos_gpio_write(YOUR_LED_GPIO, 0);
  (void) payload;
  (void) userdata;
  (void) action;
}

void ledon(struct mg_str action, struct mg_str payload, void *userdata) {
  mgos_gpio_write(YOUR_LED_GPIO, 1);
  (void) payload;
  (void) userdata;
  (void) action;
}
</code></pre>

<p>Step 5: From Web UI or UART:</p>

<pre><code>call Cron.Add '{""at"":""0 0 10 00 * *"", ""action"":""ledon""}'
call Cron.Add '{""at"":""0 0 16 00 * *"", ""action"":""ledoff""}'
</code></pre>

<p>See <a href=""https://github.com/mongoose-os-libs/cron"" rel=""nofollow noreferrer"">https://github.com/mongoose-os-libs/cron</a> as a reference for the syntax of cron expressions on mgos.</p>
",,,
51085386,2,51083259,2018-06-28T14:26:30.390,1,,794749,,2018-06-28T14:26:30.390,,0,,"<p><code>'DEL'</code> and <code>'BACK'</code> are not valid characters.</p>

<p>You could chose different characters or you could define them as constants for readability's sake:</p>

<pre><code>const char DEL  = 0x7F; // ASCII code for delete
const char BACK = 0x08; // ASCII code for backspace
</code></pre>

<p>And then use them as <code>DEL</code> and <code>BACK</code> (without single quotes):</p>

<pre><code>char keymap[numRows][numCols]= { 
    {'1','2','3','A'}, // A B C for future use
    {'4','5','6','B'},
    {'7','8','9','C'},
    {'.','0',DEL,BACK} 
};
</code></pre>



<pre><code>char key = matrix.getKey();
if (key == DEL) {
    ...
}
else if (key == BACK) {
    ...
}
else if (('0' &lt;= key &amp;&amp; key &lt;= '9') || key == '.') {
    ...
}
</code></pre>
",,,
51088121,2,51087056,2018-06-28T16:59:51.787,2,,8078317,,2018-06-28T17:05:20.993,2018-06-28T17:05:20.993,0,,"<p>It's not about what's happening inside the loop, but what's happening outside.</p>

<p>The C++ compiler that comes bundled with Arduino is pretty smart. It figures out whether it is possible to reach an instruction or not. If a large declared variable is only referenced in a part of the code which will never be reached, it does not calculate the memory required for that variable while calculating dynamic memory.</p>

<p>A simple test case would be the following. </p>

<pre><code>int test[100],test2[100];
void loop() {
  bool data=true;
#ifdef WHILE_COMPARE
  while(data == true ){
#else
  while(data = true){
#endif
    for(int i=0;i&lt;100;i++){
      test[i]=0;
    }
    data=false;
  }
#ifdef USE_TEST2
    for(int i=0;i&lt;100;i++){
      test2[i]=0;
    }
#endif
}
</code></pre>

<p>Now depending on which of the following combination are declared, the dynamic memory changes in the following manner.</p>

<p>WHILE_COMPARE is defined, USE_TEST2 is defined, the DM shoots to 402 bytes</p>

<p>WHILE_COMPARE is not defined, USE_TEST2 is defined, the DM is 209 bytes</p>

<p>WHILE_COMPARE is defined, USE_TEST2 is  not defined, the DM is 209 bytes</p>

<p>WHILE_COMPARE is not defined, USE_TEST2 is not defined, the DM is 209 bytes</p>

<p>I hope this helps.</p>
",,,
51124251,2,51100805,2018-07-01T14:36:16.783,0,,9560424,,2018-07-01T14:36:16.783,,0,,"<p>I kept trying and found it out myself.</p>

<p>On the ESP32 you have to do:</p>

<pre><code>int msg_counter = 15;
unsigned char iv[16];
unsigned char bytes[4];
bytes[0] = (msg_counter &gt;&gt; 24) &amp; 0xFF;
bytes[1] = (msg_counter &gt;&gt; 16) &amp; 0xFF;
bytes[2] = (msg_counter &gt;&gt; 8) &amp; 0xFF;
bytes[3] = msg_counter &amp; 0xFF;
memcpy(iv+12, bytes, sizeof(bytes));
</code></pre>

<p>On Django:</p>

<pre><code>counter = 15;
iv = counter.to_bytes(16, byteorder = 'big')
</code></pre>
",,,
51111397,2,51111377,2018-06-30T03:08:19.163,2,,3309790,,2018-06-30T03:43:26.257,2018-06-30T03:43:26.257,0,,"<p>You're defining a local variable <code>alphabet</code> and <code>push_back</code> one element into it. This has nothing to do with the member variable <code>alphabet</code>. Then <code>this-&gt;alphabet[0].glyph</code> leads to UB, member variable <code>alphabet</code> is still empty.</p>

<p>You might want</p>

<pre><code>Language::Language() {

    Letter symbol = Letter();
    this-&gt;alphabet.push_back(symbol);
    // or just alphabet.push_back(symbol); 

    delay(2000);
    Serial.println(""hello world"");//prints in the arduino monitor
    Serial.println(this-&gt;alphabet[0].glyph);
    Serial.println(""line of interest executed"");
}
</code></pre>
",,,
51147701,2,51147145,2018-07-03T06:13:20.050,0,,1312382,,2018-07-03T06:13:20.050,,0,,"<p>As far as I understand, you are using Arduino's <a href=""https://www.arduino.cc/reference/en/language/functions/time/delay/"" rel=""nofollow noreferrer""><code>delay()</code></a> function. Bad idea as you block the all the rest of your application, well, you noticed already...</p>

<p>Better approach just checking if some time elapsed, e. g. using <a href=""https://www.arduino.cc/reference/en/language/functions/time/millis/"" rel=""nofollow noreferrer""><code>millis</code></a> function:</p>

<pre><code>static bool isDelay = false;
static unsigned long timestamp;

if(detect())
{
    isDelay = true;
    timestamp = millis();
}

if(isDelay &amp;&amp; millis() - timestamp &gt; 1000)
{
    isDelay = false;
}
if(!isDelay)
{
    // actions to be taken...
}
</code></pre>

<p>Always use subtraction between the timestamp and the current time &ndash; the time counter might overflow, subtraction result is unaffected, though, and you are safe...</p>

<p>You can simply skip the <code>isDelay</code> variable if you are sure enough that the relevant event always occurs at least once in between overflow period (around 50 days):</p>

<pre><code>static unsigned long timestamp = millis() - 1000;

if(detect())
{
    timestamp = millis();
}
if(millis() - timestamp &gt; 1000)
{
    // actions to be taken...
}
</code></pre>

<p>Both variants: static variables as assuming you have this code in Arduino's <code>loop</code> function (or one being called from <code>loop</code>). Yet prefer replacing the magic number 1000 with a macro and you're fine...</p>
",,,
51286729,2,51215229,2018-07-11T13:28:27.327,1,,9462744,,2018-07-11T13:28:27.327,,0,,"<p>For anyone who came here, I've found the solution. It looks like the bipolar stepper motor just move with certain speeds {80,100, 160, 180, 200,220, 255}, and my code goes all over 0-255, so I just altered the code to go to certain speeds based on the time the Switch is pressed! Thanks for the help xD</p>

<pre><code>#include &lt;Stepper.h&gt;

/*
  const int ForwardLimitSwitchPin = 2;
  const int ReverseLimitSwitchPin = 3;
  const int StepperStepPin = 4;
  const int StepperDirection = 5;
*/
const int StepperMaxRPM = 255; //default = 100

const int swDireita = 13;
const int swEsquerda = 12;
int velMotor = 80;

static const unsigned long REFRESH_INTERVAL = 1000; //ms
static unsigned long lastRefreshTime = 0;

//Stepper stepper(200, StepperStepPin, StepperDirectionPin);
Stepper stepper(200, 8, 9, 10, 11);

void setup() {
  Serial.begin(115200);

  pinMode(swDireita, INPUT);
  pinMode(swEsquerda, INPUT);

  digitalWrite(swDireita, HIGH);
  digitalWrite(swEsquerda, HIGH);

  stepper.setSpeed(StepperMaxRPM);
}

void loop() {
  while (digitalRead(swDireita) == 0) {
    motorDireita();
  }
  while (digitalRead(swEsquerda) == 0) {
    motorEsquerda();
  }
  while (digitalRead(swEsquerda) == 1 &amp;&amp; digitalRead(swDireita) == 1) {
    Serial.print(""to aqui"");
    velMotor = 0;
    stepper.setSpeed(velMotor);
    Serial.print(velMotor);
  }
}

void motorDireita() {
  if (millis() - lastRefreshTime &gt;= REFRESH_INTERVAL) {
    lastRefreshTime += REFRESH_INTERVAL;
    switch (velMotor) { //80//100//160//180//200//220//255
      case 0:
        Serial.print(""antes: "");
        Serial.print(velMotor);
        velMotor = 80;
        stepper.setSpeed(velMotor);
        break;
      case 80:
        velMotor = 100;
        stepper.setSpeed(velMotor);
        break;
      case 100:
        velMotor = 160;
        stepper.setSpeed(velMotor);
        break;
      case 160:
        velMotor = 180;
        stepper.setSpeed(velMotor);
        break;
      case 180:
        velMotor = 200;
        stepper.setSpeed(velMotor);
        break;
      case 200:
        velMotor = 220;
        stepper.setSpeed(velMotor);
        break;
      case 220:
        velMotor = 255;
        stepper.setSpeed(velMotor);
        break;
    }
  }
  Serial.print(velMotor);
  Serial.print(""\n"");
  stepper.step(1);
}

void motorEsquerda() {
  if (millis() - lastRefreshTime &gt;= REFRESH_INTERVAL) {
    lastRefreshTime += REFRESH_INTERVAL;
    switch (velMotor) { //80//100//160//180//200//220//255
      case 0:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 80;
        stepper.setSpeed(velMotor);
        break;
      case 80:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 100;
        stepper.setSpeed(velMotor);
        break;
      case 100:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 160;
        stepper.setSpeed(velMotor);
        break;
      case 160:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 180;
        stepper.setSpeed(velMotor);
        break;
      case 180:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 200;
        stepper.setSpeed(velMotor);
        break;
      case 200:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 220;
        stepper.setSpeed(velMotor);
        break;
      case 220:
        Serial.print(""antes "");
        Serial.print(velMotor);
        velMotor = 255;
        stepper.setSpeed(velMotor);
        break;
    }
  }

  Serial.print(velMotor);
  Serial.print(""\n"");
  stepper.step(-1);
}
</code></pre>
",,,
51287560,2,51270065,2018-07-11T14:04:10.687,0,,2182248,,2018-07-11T14:13:11.647,2018-07-11T14:13:11.647,0,,"<p>Ok so this solved it. All I had to do was create a new StaticJsonBuffer for the second string parse. For anyone who is having a similar issue here's the working code.</p>

<pre><code>    #include &lt;ArduinoJson.h&gt;
#include &lt;EEPROM.h&gt;

StaticJsonBuffer&lt;512&gt; jsonBuffer;
JsonObject *jsonObject;
JsonObject *config;

String dummyJson = ""{\""name\"":\""RGB LED 1\"",\""io\"":[\""pwm1\"",\""pwm2\"",\""pwm3\""],\""io_type\"":\""output\"",\""device\"":\""pwm_output\"",\""uuid\"":\""5a81f424aaf8d1e951ae78d270668337\"",\""ip\"":\""255.255.255.255\""}"";

void setup()
{
  Serial.begin(9600);
  while (!Serial)
  {
    continue;
  }
  EEPROM.begin(512);

  clearEEPROM();
  createDummyJsonObject();
  writeJsonToEEPROM();
  readJsonFromEEPROM();
}

void createDummyJsonObject()
{
  jsonObject = &amp;jsonBuffer.parseObject(dummyJson);
  if (!jsonObject-&gt;success())
  {
    Serial.println(""jsonBuffer.parseObject() failed"");
    return;
  }
  else
  {
    Serial.println(""JSON object generated from dummy string"");
  }
}

void loop()
{
  // not used
}

void clearEEPROM()
{
  for (int i = 0; i &lt; 512 + 1; i++)
  {
    EEPROM.write(i, 0);
  }
  EEPROM.commit();
}

void writeJsonToEEPROM()
{
  String jsonStr;
  jsonObject-&gt;printTo(jsonStr);
  for (int i = 0; i &lt; jsonStr.length(); ++i)
  {
    EEPROM.write(i, jsonStr[i]);
  }
  EEPROM.write(jsonStr.length(), byte(0));
  EEPROM.commit();
}

void readJsonFromEEPROM()
{
  String jsonStr;
  for (int i = 0; i &lt; 512; ++i)
  {
    char c = char(EEPROM.read(i));
    if (c != 0)
    {
      jsonStr += c;
      delay(1);
    }
    else
    {
      break;
    }
  }

  StaticJsonBuffer&lt;512&gt; jsonBuffer2;
  config = &amp;jsonBuffer2.parseObject(jsonStr);
  if (!config-&gt;success())
  {
    Serial.println(""jsonObject.parseObject() failed "");
    return;
  }
  else
  {
    Serial.println(""\nJSON object generated from EEPROM data"");
    config-&gt;prettyPrintTo(Serial);
    Serial.println(""\n\n"");
  }
}
</code></pre>
",,,
51275703,2,51275675,2018-07-11T00:42:54.347,2,,65863,,2018-07-11T00:42:54.347,,0,,"<p>In C++11 and later, you can use a <a href=""https://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations"" rel=""nofollow noreferrer"">scoped <code>enum</code></a>, eg:</p>



<pre class=""lang-cpp prettyprint-override""><code>enum class HttpStatusCode { // Top10
    OK = 200,
    Created = 201,
    NoContent = 204,
    NotModified = 304,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    Conflict = 409,
    InternalServerError = 500
};
</code></pre>

<p>Otherwise, use a <code>class</code> or <code>struct</code> with <code>static</code> constants in it, eg:</p>

<pre class=""lang-cpp prettyprint-override""><code>struct HttpStatusCode {
    static const int OK = 200;
    static const int Created = 201;
    static const int NoContent = 204;
    static const int NotModified = 304;
    static const int BadRequest = 400;
    static const int Unauthorized = 401;
    static const int Forbidden = 403;
    static const int NotFound = 404;
    static const int Conflict = 409;
    static const int InternalServerError = 500;
};
</code></pre>

<p>Either way, you can then use them like this:</p>

<pre class=""lang-cpp prettyprint-override""><code>if( status == HttpStatusCode::OK )
</code></pre>
",,,
51305368,2,51297371,2018-07-12T12:10:12.080,1,,9466270,,2018-07-12T12:10:12.080,,0,,"<p>I would try to restructure the code a little. This is mainly to separate the speed and direction, as they don't rely on each other. For example:</p>

<pre><code>long encoder_pulse_counter = 0;
long direction = 1


void setup() {
    Serial.begin(9600);
    pinMode(encoder_a, INPUT_PULLUP);
    pinMode(encoder_b, INPUT_PULLUP);

    attachInterrupt(0, encoderPinChangeA, CHANGE);
    attachInterrupt(1, encoderPinChangeB, CHANGE);
}

void loop(){
    long speed = encoder_pulse_counter/2400.00*60; // Not sure, encoder not specified
    Serial.println(direction*speed);
    encoder_pulse_counter = 0; // Clear variable just before counting again 
    delay(1000);
}


void encoderPinChangeA(){
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) == digitalRead(encoder_b) ? -1 : 1;
}

void encoderPinChangeB(){
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) != digitalRead(encoder_b) ? -1 : 1;
}
</code></pre>

<p>I didn't test this code, so there might be small bugs. But I think separating the calculations will be much easier. Hope this helps!</p>
",,,
52778644,2,51297371,2018-10-12T11:33:12.880,1,,10494864,,2018-10-12T11:33:12.880,,0,,"<p>Good answer by Wessels. Some small bugs in the code provided, complete working and tested code:</p>

<pre><code>const int encoder_a = 3; // Pin 3
const int encoder_b = 5; // Pin 5
long encoder_pulse_counter = 0;
long direction = 1;

void encoderPinChangeA()
{
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) == digitalRead(encoder_b) ? -1 : 1;
}

void encoderPinChangeB()
{
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) != digitalRead(encoder_b) ? -1 : 1;
}

void setup() 
{
    Serial.begin(9600);
    pinMode(encoder_a, INPUT_PULLUP);
    pinMode(encoder_b, INPUT_PULLUP);
    attachInterrupt(0, encoderPinChangeA, CHANGE);
    attachInterrupt(1, encoderPinChangeB, CHANGE);
}

void loop()
{
    long speed = encoder_pulse_counter/1024.00*60; // For encoder plate with 1024 Pulses per Revolution
    Serial.print(""RPM: "");
    Serial.println(direction*speed);
    encoder_pulse_counter = 0; // Clear variable just before counting again 
    delay(1000);
}
</code></pre>
",,,
54965253,2,51297371,2019-03-03T03:17:45.023,0,,708569,,2019-03-03T03:17:45.023,,0,,"<pre><code>volatile long encoder_pulse_counter = 0;
volatile long direction = 1


void setup() {
    Serial.begin(9600);
    pinMode(encoder_a, INPUT_PULLUP);
    pinMode(encoder_b, INPUT_PULLUP);

    attachInterrupt(0, encoderPinChangeA, CHANGE);
    attachInterrupt(1, encoderPinChangeB, CHANGE);
}

void loop(){
    long speed = encoder_pulse_counter/2400.00*60; // Not sure, encoder not specified
    Serial.println(direction*speed);
    encoder_pulse_counter = 0; // Clear variable just before counting again 
    delay(1000);
}


void encoderPinChangeA(){
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) == digitalRead(encoder_b) ? -1 : 1;
}

void encoderPinChangeB(){
    encoder_pulse_counter += 1;
    direction = digitalRead(encoder_a) != digitalRead(encoder_b) ? -1 : 1;
}
</code></pre>

<p>agree it looks good just add volatile to any variable used in a ISR..</p>
",,,
51331639,2,51331486,2018-07-13T19:24:20.653,2,,9125195,,2018-07-13T19:30:10.847,2018-07-13T19:30:10.847,1,,"<p><code>EthernetServer ArduinoTcpServer(uint16_t);</code> declares a member function named <code>ArduinoTcpServer</code>.  To declare a member variable, omit the parameter type and parentheses.  Also add a constructor to initialize the member variable, e.g. :</p>

<pre><code>class LinxArduinoEthernetListener : public LinxListener
{
    public:
        EthernetServer ArduinoTcpServer;

        LinxArduinoEthernetListener(uint16_t port)
        : ArduinoTcpServer(port)
        {
        }
};
</code></pre>
",,,
51371687,2,51371559,2018-07-17T00:38:09.620,5,,4151599,,2018-07-17T00:38:09.620,,0,,"<p>You can do this using templates with the help of <a href=""https://en.cppreference.com/w/cpp/utility/integer_sequence"" rel=""noreferrer""><code>std::index_sequence</code></a>:</p>

<pre><code>constexpr size_t NUM_WIDGETS = 4;

template &lt;size_t N&gt;
void foo() {
    std::cout &lt;&lt; N &lt;&lt; '\n';
}

template &lt;size_t... Ns&gt;
void call_foo_helper(std::index_sequence&lt;Ns...&gt;) {
    (foo&lt;Ns&gt;(), ...);
}

template &lt;size_t N&gt;
void call_foo() {
    call_foo_helper(std::make_index_sequence&lt;N&gt;());
}

int main() {
    call_foo&lt;NUM_WIDGETS&gt;();
}
</code></pre>

<p>This uses C++17 fold expressions.  If you don't have C++17 available, you could use a recursive template instead:</p>

<pre><code>constexpr size_t NUM_WIDGETS = 4;

template &lt;size_t N&gt;
void foo() {
    std::cout &lt;&lt; N &lt;&lt; '\n';
}

template &lt;size_t N&gt;
void call_foo() {
    foo&lt;N&gt;();
    call_foo&lt;N - 1&gt;();
}

template &lt;&gt;
void call_foo&lt;0&gt;() { }

int main() {
    call_foo&lt;NUM_WIDGETS&gt;();
}
</code></pre>
",,,
51371901,2,51371559,2018-07-17T01:11:44.913,1,,315052,,2018-07-17T01:30:02.403,2018-07-17T01:30:02.403,0,,"<p>The fold expression based or recursive template solution is superior. But, if you wanted a preprocessor solution, you can see if your compiler provides the inclusion depth as a predefined macro. For example, GCC provides <code>__INCLUDE_LEVEL__</code> (and MSVC provides <code>__COUNTER__</code>). You can then use recursive inclusion up to a limit to generate your template function calls.</p>

<pre><code>$ gcc -E r.cc | grep -v '^#' | sed '/^ *$/d'
int main()
{
   Library.function&lt;1&gt;();
   Library.function&lt;2&gt;();
   Library.function&lt;3&gt;();
   Library.function&lt;4&gt;();
}
$ cat r.cc
int main()
{
    #define NUM_WIDGETS 4
    #include ""r.i""
}
$ cat r.i
#ifndef NUM_WIDGETS
# error ""NUM_WIDGETS needs to be defined!""
#else
# if (__INCLUDE_LEVEL__) &lt; ((NUM_WIDGETS) + 1)
   Library.function&lt;__INCLUDE_LEVEL__&gt;();
#  include __FILE__
# endif
#endif
</code></pre>

<p>This technique is limited to the nested inclusion limits of your compiler.</p>
",,,
51371923,2,51371559,2018-07-17T01:15:30.930,1,,459640,,2018-07-17T01:15:30.930,,0,,"<p>The template solutions in <a href=""https://stackoverflow.com/a/51371687/459640"">Miles' answer</a> are definitely the way to go.</p>

<p>But just for kicks, you can in fact also do it with the preprocessor:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;

template &lt;int N&gt; void function() { std::cout &lt;&lt; N &lt;&lt; ""\n""; }

#define NUM_WIDGETS 4

int main()
{
#define CALL_FUNC(z,n,d) function&lt;n+1&gt;();
    BOOST_PP_REPEAT(NUM_WIDGETS, CALL_FUNC, ~)
#undef CALL_FUNC
}
</code></pre>

<p>This isn't as good, because the count <code>NUM_WIDGETS</code> needs to be known to the preprocessor as a plain string of digits. Not <code>(4)</code>, not <code>4U</code>, not a <code>constexpr</code> variable, and so on.  And Boost.Preprocessor does have a limit of 256 repetitions (or slightly less if using MSVC).</p>
",,,
51422042,2,51421763,2018-07-19T11:53:44.563,1,,10025445,,2018-07-19T11:53:44.563,,3,,"<p>You can use variadic templates:</p>

<p>In <code>ManyObjects</code> class:</p>

<pre><code>template &lt;typename... _Args&gt;
ManyObjects(_Args&amp;&amp;... arguments) :
    objects { arguments... }
{
}
</code></pre>

<p>More <a href=""https://en.cppreference.com/w/cpp/language/parameter_pack"" rel=""nofollow noreferrer"">here</a></p>
",,,
51422839,2,51421763,2018-07-19T12:34:42.240,0,,1122645,,2018-07-19T13:31:47.997,2018-07-19T13:31:47.997,3,,"<p>Yes variadic templates work but it is a bit tricky : </p>

<pre><code>template &lt;size_t N&gt;
class ManyObjects {
  public:
    template&lt;typename T, typename ...Args&gt;
    ManyObjects(const T&amp; x, Args&amp;&amp;... args) : objects{x, args...}{}

  private:
    Object objects[N];
};

int main() {
    ManyObjects&lt;3&gt; many{1, 2, 3};
    ManyObjects&lt;3&gt; copymany{many};
    copymany.print();
}
</code></pre>

<p>For any fixed N it can be interpreted as :</p>

<pre><code>template &lt;size_t N=3&gt;
class ManyObjects {
  public:
        ManyObjects(int x, int y, int z) : objects{x, y, z}{} 
...
};
</code></pre>

<p>What is at play here : </p>

<ol>
<li>Object cannot be default initialized due to the definition of the constructor <code>Object(int)</code></li>
<li>Object assignment operator is implicitly deleted because number is const</li>
<li>Thus any array <code>Object arr[N]</code> must be explicitly initialized using an aggregate initialization.</li>
<li>The only way I think of is to perform extended initialization via the variadic templates.</li>
<li><p>To prevent matching the copy constructor you can specify the first argument outside the parameter pack. You loose the construction of size 0, which can be enabled with a template specialization.</p>

<pre><code> ManyObjects&lt;0&gt; noneof;
 noneof.print();
</code></pre></li>
</ol>
",,,
51425069,2,51421763,2018-07-19T14:19:49.297,0,,6356744,,2018-07-20T16:09:29.393,2018-07-20T16:09:29.393,0,,"<p>I ended up following the advice of VTT, and creating my own array wrapper.</p>

<p>I'd love to hear some feedback if there are things that I have to look out for, or possible bugs, etc.</p>

<pre><code>#include &lt;iostream&gt;

class Object {
public:
  Object(int number) : number{number} {}
  void print() { std::cout &lt;&lt; ""The number is "" &lt;&lt; number &lt;&lt; std::endl; }

private:
  const int number;
};

// -------------------------------------------------------------------------- //

template &lt;class T, size_t N&gt; class ArrayWrapper {
public:
    T &amp;operator[](size_t index) { return data[index]; }
    const T &amp;operator[](size_t index) const { return data[index]; }
    T *begin() { return &amp;data[0]; }
    const T *begin() const { return &amp;data[0]; }
    T *end() { return &amp;data[N]; }
    const T *end() const { return &amp;data[N]; }

  T data[N];
};

// -------------------------------------------------------------------------- //

template &lt;size_t N&gt; class ManyObjects {
public:
  ManyObjects(const ArrayWrapper&lt;Object, N&gt; &amp;objects, const char *name)
      : objects{objects}, name{name} {}
  void print() {
    std::cout &lt;&lt; name &lt;&lt; std::endl;
    for (auto &amp;object : objects)
      object.print();
  }

private:
  ArrayWrapper&lt;Object, N&gt; objects;
  const char *name;
};

// -------------------------------------------------------------------------- //

int main() {
    ManyObjects&lt;3&gt; many = {{1, 2, 3}, ""Many""};
    many.print();
}
</code></pre>
",,,
51525135,2,51525070,2018-07-25T18:03:42.737,5,,1687119,,2018-07-25T18:03:42.737,,1,,"<p>The <code>strtok</code> function uses an internal static variable to keep track of its current state.  When you use the function for multiple different substrings interleaved like you're doing, you step on the internal state.</p>

<p>You need to instead use <code>strtok_r</code>, which uses an external variable to keep track of state.  </p>

<pre><code>  char *ptr, *sav1 = NULL;
  ptr = strtok_r(params, ""&amp;"", &amp;sav1);    // outer strtok_r, use sav1

  while (ptr != NULL) {

    char *paramKey;
    char *paramValue;
    char *sav2 = NULL;
    paramKey = strtok_r(ptr, ""="", &amp;sav2);   // inner strtok_r, use sav2
    Serial.println(paramKey);

    if (!strcmp(paramKey, ""ssid"")) {
      paramValue = strtok_r(NULL, ""="", &amp;sav2);  // inner strtok_r, use sav2
      Serial.println(paramValue);       

      ssidName = paramValue;
    }

    if (!strcmp(paramKey, ""pwd"")) {
      ...
    }

    if (!strcmp(paramKey, ""userId"")) {
      ...
    }       

    ptr = strtok_r(NULL, ""&amp;"", &amp;sav1);    // outer strtok_r, use sav1
  }
</code></pre>

<p>Not related to the parsing issue, you also can't compare strings with <code>==</code>.  You need to use <code>strcmp</code> instead, and string constants are surrounded in double quotes, not single quotes.</p>
",,,
51525713,2,51525070,2018-07-25T18:43:38.090,0,,,user4853414,2018-07-25T18:43:38.090,,0,,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct split_result {
    char first_part[64];
    char second_part[64];
};

split_result return_left(char splitter, const char *str);

int main() {
    /*
        ssid=SSID
        pwd=PASSWORD
        userId=1234
    */
    char *str = ""ssid=109304905995"";
    split_result result = return_left('=', str);

    printf(""first part: %s \n second part: %s\n"", result.first_part, result.second_part);

    return 0;
}

split_result return_left(char splitter, const char *str) {
    int i = 0;

    split_result split_ptr;

    while (str[i] != 0) {
        //we found splitter
        if ((char)str[i] == splitter) {
            //remove first half
            strncpy_s(split_ptr.first_part, str, (int)(&amp;str[i]-str));
            break;
        }

        //we need to remove second half now
        i++;
    }
    strcpy_s(split_ptr.second_part, &amp;str[i+1]);
    return split_ptr;
}
</code></pre>

<p>I hope this will be helpful to anyone.</p>
",,,
51527503,2,51527458,2018-07-25T20:55:42.853,2,,1687119,,2018-07-25T20:55:42.853,,1,,"<p><code>func1</code> is taking a <code>struct struct1</code>, i.e. a <em>copy</em> of a struct as a parameter.  As a result, changes made in the function are not visible in the calling code.  Even then, you're not actually changing the parameter but a local variable.</p>

<p>You need to declare the parameter as a reference to link the parameter to the variable in the calling function.  Then you'll see the changes.</p>

<pre><code>void func1(struct1 &amp;dataSet)
{
    dataSet.val1 = dataSet.val2;
    dataSet.val2 = dataSet.val3;
    dataSet.val3++;
}
</code></pre>
",,,
51527532,2,51527458,2018-07-25T20:57:16.727,0,,882003,,2018-07-25T20:57:16.727,,0,,"<p>I'm guessing a bit on the detail of what you want, but the essense of the answer is that your function must take a <em>reference</em> to the struct.</p>

<pre><code>void func1(struct1&amp; dataSet)
{
    dataSet.val1 = dataSet.val2;
    dataSet.val2 = dataSet.val3;
    dataSet.val3++;
}
</code></pre>

<p>The <code>&amp;</code> makes <code>dataSet</code> a reference. Your code was passing a <em>copy</em> of the structure (among other errors) which is why it could never alter the original structure.</p>
",,,
51531557,2,51531033,2018-07-26T05:24:39.303,1,,5330223,,2018-07-26T08:18:19.007,2018-07-26T08:18:19.007,2,,"<blockquote>
<pre><code>char charssId[AP_NameString.length()+1] = string2char(AP_NameString);
</code></pre>
</blockquote>

<p>This line is will not work. Because <code>char charssId[AP_NameString.length()+1]</code> this means you are declaring an array of certain size and at the same time replacing it with the returned array from the method.</p>

<p>You can do as follows,</p>

<pre><code>char* string2char(String ipString){ // make it to return pointer not a single char
  char* opChar = new char[ipString.length() + 1]; // local array should not be returned as it will be destroyed outside of the scope of this function. So create it with new operator.
  memset(opChar, 0, ipString.length() + 1);

  for (int i = 0; i &lt; ipString.length(); i++)
    opChar[i] = ipString.charAt(i);
  return opChar; //Add this return statement.
}

// Now call this as below,
char* charssId = string2char(AP_NameString); // make the variable as pointer so that it can hold an array address.
// use it as a char array.
delete[] charssId; // Remember to delete it after finished using it.
</code></pre>
",,,
51533979,2,51531033,2018-07-26T08:07:52.340,1,,65863,,2018-07-26T08:16:45.030,2018-07-26T08:16:45.030,0,,"<p>There are many problems with your code. </p>

<p>Your function is declared as returning a <em>single</em> <code>char</code>, not an <em>array</em> of <code>char</code>s.  And it is missing an actual <code>return</code> statement. But even if it weren't, you would be returning a local array that goes out of scope when the function exits, leaving the caller with a dangling pointer to invalid data.</p>

<p>You are declaring the <code>opChar</code> array in a non-standard way known as a ""variable-length array"".  VLAs are a compiler-specific extension, and thus not portable.  You need to dynamically allocate the array using <code>new[]</code> instead.</p>

<p>Try this:</p>

<pre><code>char* string2char(const String &amp;ipString){
    char *opChar = new char[ipString.length() + 1];
    /*
    for (int i = 0; i &lt; ipString.length(); i++)
        opChar[i] = ipString.charAt(i);
    */
    ipString.toCharArray(opChar, ipString.length());
    opChar[ipString.length()] = '\0';
    return opChar;
}

char *charssId = string2char(AP_NameString);
// use charssId as needed...
delete[] charssId;
</code></pre>

<p>A safer option is to use <code>std::string</code> instead:</p>

<pre><code>std::string string2char(const String &amp;ipString){
    std::string opChar;
    opChar.resize(ipString.length());
    /*
    for (int i = 0; i &lt; ipString.length(); i++)
        opChar[i] = ipString.charAt(i);
    */
    ipString.toCharArray(opChar, ipString.length());
    return opChar;

    // alternatively:
    // return std::string(ipString.c_str(), ipString.length());
}

std::string charssId = string2char(AP_NameString);
// use charssId.c_str() as needed...
</code></pre>

<p>But a conversion is actually not needed at all:</p>

<pre><code>const char *charssId = AP_NameString.c_str();
// use charssId as needed...
</code></pre>
",,,
51535420,2,51535285,2018-07-26T09:26:07.260,5,,752976,,2018-07-26T09:38:48.207,2018-07-26T09:38:48.207,2,,"<p>The canonical answer to that would be <code>std::variant</code>. I'd get rid of that enum then, though, as that introduces multiple sources-of-truth:</p>

<pre><code>using PrimitiveValue = std::variant&lt;bool, String, int8_t, int16_t, int32_t, uint8_t, uint16_t, uint32_t&gt;;

struct MyValue {
    String id;
    PrimitiveValue val;
};
</code></pre>

<p>If you absolutely need to produce that enum value, you'll need a mapping:</p>

<pre><code>PrimitiveType MyValue::getPrimitiveType() const {
    if (val.holds_alternative&lt;bool&gt;()) { return BOOL; }
    else if (val.holds_alternative&lt;String&gt;()) { return STRING; }
    else if (val.holds_alternative&lt;int8_t&gt;()) { return INT8; }
    // else ...
}
</code></pre>

<p>Doing it this way ensures that there might never occur a state in which the type descriptor doesn't match the actually stored value, because the <code>variant</code> guarantees that.</p>

<p>That being said, your ""C# way"" of acting upon such value isn't the best option here. A much nicer one is <a href=""https://en.cppreference.com/w/cpp/utility/variant/visit"" rel=""nofollow noreferrer""><code>std::visit</code></a> which together with the <code>overloaded</code> helper from that page can produce really concise code that acts differently depending on the stored value.</p>
",,,
51546238,2,51545872,2018-07-26T19:28:24.953,0,,795636,,2018-07-27T07:42:16.530,2018-07-27T07:42:16.530,1,,"<p>Maybe you could read from Serial, but take digits only? And then parse string? Dirty example:</p>

<pre><code>val = 0;
while (Serial.available() &gt; 0) {
    int c = Serial.read();
    if (isDigit(c)) {
        val = val * 10 + c; // Thanks to @Danny_ds for this
    }
}
// Print *val*
</code></pre>
",,,
51640003,2,51545872,2018-08-01T18:26:57.617,0,,4563900,,2018-08-01T18:26:57.617,,0,,"<p>I ended up using a very different method to get it working by using char arrays and not relying on timing. So far it has worked perfectly. I was using this to get my arduino to work as a temp monitor.</p>

<hr>

<p><strong>How it communicates the temperatures</strong></p>

<p>PC > OpenHardwaremonitor > WMI > Batch Script (shown below) > COM Port > Arduino > LCD</p>

<p>This was the only way that I could get cpu temps correctly because it's so old</p>

<p>Batch code:</p>

<pre><code>@echo off
mode COM3: baud=9600 data=8 &gt;nul
wmic /namespace:\\root\openhardwaremonitor path sensor where ""Identifier='/intelcpu/0/temperature/0' or Identifier='/nvidiagpu/0/temperature/0'"" get Value /every:2|findstr [0-9]&gt;COM3
</code></pre>

<p>Arduino code:</p>

<pre><code>#include &lt;LiquidCrystal.h&gt;

LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

bool sounded = false;
int cpu = 0;
int gpu = 0;

char invalids[3] = {10, 32, '\0'}; // line feed, space
boolean newData = false;
const byte numChars = 8;
char charMap[numChars];
char tempChars[numChars];

void setup() {
  pinMode(6, OUTPUT); // character intensity
  pinMode(8, OUTPUT); // buzzer
  pinMode(10, OUTPUT); // backlight
  lcd.begin(16, 2);
  Serial.begin(9600);
  analogWrite(6, 100); // set intensity without POT
  analogWrite(10, 168); // ~3.3v
  analogReference(EXTERNAL);
  lcd.print(""CPU:   "");
  lcd.print((char)223);
  lcd.print(""C  AIR:"");
  lcd.setCursor(0, 1);
  lcd.print(""GPU:   "");
  lcd.print((char)223);
  lcd.print(""C     "");
  lcd.print((char)223);
  lcd.print(""F"");
}

void loop() {
  recvWithoutWhitespace();
  if (newData == true) {
    parseData();
    lcd.setCursor(4, 0);
    lcd.print(cpu);
    lcd.setCursor(4, 1);
    lcd.print(gpu);
    int reading = analogRead(A0);
    float degreesF = (((reading * 3.3 / 1024 - 0.5) * 100) * 1.8) + 32.0;
    lcd.setCursor(11, 1);
    lcd.print((int)(degreesF+0.5));
    if(!sounded &amp;&amp; (cpu &gt; 75 || gpu &gt; 85)) { // used for buzzer alarm
      tone(8, 500);
      delay(250);
      noTone(8);
      delay(250);
      tone(8, 500);
      delay(250);
      noTone(8);
      delay(250);
      tone(8, 500);
      delay(250);
      noTone(8);
      sounded = true;
    } else if(sounded &amp;&amp; (cpu &lt;= 75 &amp;&amp; gpu &lt;= 85)) {
      sounded = false;
    }
    newData = false;
  } 
}
void recvWithoutWhitespace() {
    static byte ndx = 0;
    static byte control = 0; // switch control variable
    char endMarker = 13; // ASCII code for carriage return
    char rc;
    char * check;

    while (Serial.available() &gt; 0 &amp;&amp; newData == false) {
        rc = Serial.read();
        check=strchr(invalids,rc); //checks if any spaces or line feeds get in

            if (check==NULL){ 
              if (rc != endMarker) {
                  charMap[ndx] = rc;
                  ndx++;
                 if (ndx &gt;= numChars) {
                      ndx = numChars - 1;
                  }
             }
              else {
                switch(control) { // expect 4 CRs in format: (num)CRCR(num)CRCR
                  case 0:
                    control = 1; // skip first of 2 CRs
                    break;
                  case 1:
                    charMap[ndx] = 44; // put comma in place of CR between numbers as delimeter
                    ndx++;
                      if (ndx &gt;= numChars) {
                        ndx = numChars - 1;
                      }
                    control = 2;
                    break;
                  case 2:
                    control = 3; // skip first of 2 CRs
                    break;
                  case 3:
                    charMap[ndx] = '\0'; // string terminator in place of last CR
                    ndx = 0;
                    control = 0;
                    newData = true;
                    break;
                }
              }
            }
    }
}
void parseData() {

    strcpy(tempChars, charMap); //strtok is destructive so copy string temporarily

    char * strtokIndx; // this is used by strtok() as an index

    strtokIndx = strtok(tempChars, "","");
    cpu = atoi(strtokIndx);     // convert cpu to an integer

    strtokIndx = strtok(NULL, "","");
    gpu = atoi(strtokIndx);     // convert gpu to an integer

}
</code></pre>
",,,
51560447,2,51559653,2018-07-27T14:46:56.123,1,,698679,,2018-07-27T14:46:56.123,,0,,"<p>Move the code in a function and call it:</p>

<pre><code>void test() {
    params.test= 2;  
    params.cc_num = {22, 23, 24};
    params.reverse = {false, false, false};
    params.sensor_range = {150, 150, 150}; 
    params.default_value = {64, 64, 64};  
    params.min_value = {0, 0, 0};
    params.max_value = {127, 127, 127};
}
</code></pre>

<p>In c and c++ pre c++11 you cannot initialize non static member as global vars.</p>
",,,
51630148,2,51598345,2018-08-01T09:45:18.593,0,,753426,,2018-08-02T12:17:20.583,2018-08-02T12:17:20.583,2,,"<p>I think you need to send the argument as a reference or a pointer to the constructer.</p>

<p>In main, It should look something like:</p>

<pre><code>Uart* serPort = new Uart();
serPort.setName(""COMX"");
serPort.setBaud(9600);
Sender s = new Sender(serPort);

....

delete serPort;
</code></pre>

<p>Hope it helps.</p>
",,,
51611129,2,51609813,2018-07-31T10:23:30.957,0,,7640269,,2018-07-31T10:23:30.957,,1,,"<p>Get some inspiration from this code. This is very generic canonical serial programming using C.</p>

<p>NOTE: Canonical input processing can also handle the erase, delete word, and reprint characters, translate CR to NL, etc..</p>

<hr>

<p>I suggest you to read this article in order to know more about the serial programming settings, different mode. </p>

<p><a href=""http://www.tldp.org/HOWTO/Serial-Programming-HOWTO/x56.html"" rel=""nofollow noreferrer"">HowTo serial programming.</a></p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;termios.h&gt;
#include &lt;stdio.h&gt;

/* baudrate settings are defined in &lt;asm/termbits.h&gt;, which is
included by &lt;termios.h&gt; */
#define BAUDRATE B38400            
/* change this definition for the correct port */
#define SERIAL_DEVICE ""/dev/ttyS1""


#define FALSE 0
#define TRUE 1

volatile int STOP=FALSE; 

int main(void)
{
  int fd,c, res;
  struct termios oldtio,newtio;
  char buf[255];
/* 
  Open modem device for reading and writing and not as controlling tty
  because we don't want to get killed if linenoise sends CTRL-C.
*/
 fd = open(SERIAL_DEVICE, O_RDWR | O_NOCTTY ); 
 if (fd &lt;0) {perror(SERIAL_DEVICE); exit(-1); }

 tcgetattr(fd,&amp;oldtio); /* save current serial port settings */
 memset(&amp;newtio, sizeof(newtio)); /* clear struct for new port settings */

/* 
  BAUDRATE: Set bps rate. You could also use cfsetispeed and cfsetospeed.
  CRTSCTS : output hardware flow control (only used if the cable has
            all necessary lines. See sect. 7 of Serial-HOWTO)
  CS8     : 8n1 (8bit,no parity,1 stopbit)
  CLOCAL  : local connection, no modem contol
  CREAD   : enable receiving characters
*/
 newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;

/*
  IGNPAR  : ignore bytes with parity errors
  ICRNL   : map CR to NL (otherwise a CR input on the other computer
            will not terminate input)
  otherwise make device raw (no other input processing)
*/
 newtio.c_iflag = IGNPAR | ICRNL;

/*
 Raw output.
*/
 newtio.c_oflag = 0;

/*
  ICANON  : enable canonical input
  disable all echo functionality, and don't send signals to calling program
*/
 newtio.c_lflag = ICANON;

/* 
  initialize all control characters 
  default values can be found in /usr/include/termios.h, and are given
  in the comments, but we don't need them here
*/
 newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */ 
 newtio.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
 newtio.c_cc[VERASE]   = 0;     /* del */
 newtio.c_cc[VKILL]    = 0;     /* @ */
 newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */
 newtio.c_cc[VTIME]    = 0;     /* inter-character timer unused */
 newtio.c_cc[VMIN]     = 1;     /* blocking read until 1 character arrives */
 newtio.c_cc[VSWTC]    = 0;     /* '\0' */
 newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */ 
 newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */
 newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
 newtio.c_cc[VEOL]     = 0;     /* '\0' */
 newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */
 newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */
 newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */
 newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
 newtio.c_cc[VEOL2]    = 0;     /* '\0' */

/* 
  now clean the modem line and activate the settings for the port
*/
 tcflush(fd, TCIFLUSH);
 tcsetattr(fd,TCSANOW,&amp;newtio);

/*
  terminal settings done, now handle input
  In this example, inputting a 'z' at the beginning of a line will 
  exit the program.
*/
 while (STOP==FALSE) {     /* loop until we have a terminating condition */
 /* read blocks program execution until a line terminating character is 
    input, even if more than 255 chars are input. If the number
    of characters read is smaller than the number of chars available,
    subsequent reads will return the remaining chars. res will be set
    to the actual number of characters actually read */
    res = read(fd,buf,255); 
    buf[res]=0;             /* set end of string, so we can printf */
    printf("":%s:%d\n"", buf, res);
    if (buf[0]=='z') STOP=TRUE;
 }
 /* restore the old port settings */
 tcsetattr(fd,TCSANOW,&amp;oldtio);
 return 0;
}
</code></pre>
",,,
51629147,2,51609813,2018-08-01T08:54:45.847,0,,4950584,,2018-08-01T08:54:45.847,,1,,"<p>If you don't want the connection to be non-blocking, you probably want to remove the O_NDELAY option you've added to your call to <code>open</code> that turns on non-blocking. Just like this...</p>

<pre><code>uart0_filestream = open(""/dev/ttyUSB0"", O_RDWR | O_NOCTTY);
</code></pre>

<p>Also, <code>read</code> doesn't return a string, it returns the number of bytes read in so your calls to <code>read</code> should look more like</p>

<pre><code>bytecount = read(uart0_filestream, str, 20);
if(bytecount&gt;0)
   {
   str[bytecount]='\0';
   }
else
   {
   // Something bad happened?
   }
</code></pre>
",,,
51667609,2,51666435,2018-08-03T07:41:37.193,0,,1312382,,2018-08-03T08:52:00.787,2018-08-03T08:52:00.787,0,,"<p>Sounds as if (well, I don't know nodeMCU, so answering in general terms...) callbacks are just called one after the other from within the main loop.</p>

<p>If so, naturally each callback delay blocks the other callbacks. Instead of delaying by busy-wait (<code>delay</code> function), you might restart the timer and exit the function, that would unblock the other callbacks.</p>

<p>It might look similar to the following pattern:</p>

<pre><code>#define INTERVAL 1000
#define INTERMEDIATE_DELAY 100

void callback()
{
    static bool isDelay = false;

    if(!isDelay)
    {
        restartTimer(INTERMEDIATE_DELAY);

        // part of code BEFORE delay
    }
    else
    {
        restartTimer(INTERVAL - INTERMEDIATE_DELAY);

        // part of code AFTER delay
    }
    isDelay = !isDelay;
}
</code></pre>

<p>Restarting the timer before the code executed will not add execution time to the intervals, so you get slightly higher precision...</p>

<p>Side note: As denoted in the comments already, avoid code duplication:</p>

<pre><code>void callbackHandler(unsigned int index)
{
    Serial.print(""rak "");
    Serial.print(index + 1);
    Serial.println(millis[index];
    {
        //logselenoid[2 * index] = logselenoid[2 * index] + 1;
        // simpler:
        ++logselenoid[2 * index];
    }
}

// just a shortened sample, add further parameters as needed

void t2Callback()
{
    callbackHandler(0, t2); // tx as additional parameter?
}
</code></pre>

<p>With this intermediate function the code to execute exists only once (unless you make it inline), bought with an additional function call. Instead of inlining the intermediate function, a template function is a more elegant approach:</p>

<pre><code>template &lt;unsigned int Index, WhatEver&amp; Tx&gt;
//                            ^^^^^^^^^ can be done since one of the
//                                      recent standards, C++14 or 17(?)
void callbackHandler()
{
    // just as the handler above
}
</code></pre>
",,,
51741580,2,51740716,2018-08-08T08:06:15.467,0,,7931856,,2018-08-08T08:20:37.293,2018-08-08T08:20:37.293,6,,"<pre><code>int check(int x[], int y[]){
    if(x!=y){
        return i;    
    } else {

    }
}
</code></pre>

<p>First in this function you don't have <code>i</code> variable. You wait for two arrays in entry, but when you call this function you pass only integers. Then all path of the function doesn't return value. </p>

<p>What you should try is to make the <code>x</code> table as boolean table and then remove your check function to do something like :</p>

<pre><code>for (i=0; i&lt;8; i++){
    x[i] = (b[i]==d[i]);
}
</code></pre>

<p>You will get a table where value at the index <code>i</code> is true where the value of <code>b[i]</code> and <code>d[i]</code> is the same.</p>
",,,
51829596,2,51787696,2018-08-13T19:48:42.987,0,,1329652,,2018-08-20T05:33:07.533,2018-08-20T05:33:07.533,0,,"<p>The <code>Read</code> method is incorrect and unnecessary. You should never use the <code>waitFor</code> methods. You also shouldn't be using <code>QString</code> when dealing with simple ASCII data that <code>QByteArray</code> handles fine:</p>

<pre><code>class MainWindow : ... {
  QByteArray m_inBuffer;
  ...
};

void MainWindow::ReadData() {
  m_inBuffer.append(arduino-&gt;readAll());
  QByteArray match;
  while (true) {
    if (m_inBuffer.startsWith((match = ARDUINO_TURNED_LED_ON))) {
      qDebug() &lt;&lt; ""led on"";
    } else if (m_inBuffer.startsWith((match = ARDUINO_TURNED_LED_OFF))) {
      qDebug() &lt;&lt; ""led off"";
    } else {
      match = {};
      break;
    }
  }
  m_inBuffer.remove(0, match.size());
}
</code></pre>

<p>The deal is simple: <code>ReadData</code> can be called with any number of bytes available - even a single byte. Thus you must accumulate data until a full ""packet"" is received. In your case, packets can only be delineated by matching a full response string.</p>

<p>You'd make your life much easier if Arduino sent full lines - replace <code>Serial.write</code> with <code>Serial.println</code>. Then the lines are packets, and you don't need to buffer the data yourself:</p>

<pre><code>void MainWindow::ReadData() {
  while (arduino-&gt;canReadLine()) {
    auto line = arduino-&gt;readLine();
    line.chop(1); // remove the terminating '\n'
    QDebug dbg; // keeps everything on a single line
    dbg &lt;&lt; ""LINE="" &lt;&lt; line;
    if (line == ARDUINO_TURNED_LED_ON)
      dbg &lt;&lt; ""led on"";
    else if (line == ARDUINO_TURNED_LED_OFF)
      dbg &lt;&lt; ""led off"";
  }
}
</code></pre>

<p>See? It's much simpler that way.</p>

<p>You can also leverage Qt to ""simulate"" Arduino code without running real Arduino hardware, see <a href=""https://stackoverflow.com/a/43703784/1329652"">this answer</a> for an example.</p>
",,,
51808361,2,51808029,2018-08-12T11:28:41.560,0,,2072611,,2018-08-12T11:28:41.560,,1,,"<p>Looks like a pointer problem, try this</p>

<pre><code>void ChangeValue(String value) {
        int RATES[3] = {300, 1500, 3600};
        DeviceDataObject new_data = {true, """", """", RATES[0], RATES[1], RATES[2]}
        value.toCharArray(new_data.data2, 20); //Convert to char

        WRITE_Device(new_data); 
}
</code></pre>

<p>(you were creating a string where the first character was the pointer to your stack variable charBuf, rather than copying the string)</p>
",,,
51846082,2,51808029,2018-08-14T16:37:14.280,0,,9973249,,2018-08-14T16:37:14.280,,0,,"<p>A somewhat long-winded approach would be to write each element of the structure to EEPROM individually. The code would look something like this and should allow you to isolate any issues more effectively.</p>

<pre><code>ee_address = 0;

EEPROM.put(ee_address, new_data.flag);
ee_address += sizeof(new_data.flag);  // Update address to store next variable

EEPROM.put(ee_address, new_data.data);
ee_address += sizeof(new_data.data);

EEPROM.put(ee_address, new_data.data2);
ee_address += sizeof(rawdata.data2);

EEPROM.put(ee_address, new_data.rate1);
ee_address += sizeof(new_data.rate1);

EEPROM.put(ee_address, new_data.rate2);
ee_address += sizeof(new_data.rate2);

EEPROM.put(ee_address, new_data.rate3);
ee_address += sizeof(rawdata.rate3);
</code></pre>

<p><strong>This will make it easier to troubleshoot whether variables are not being written to EEPROM correctly or whether the issue stems from something else.</strong></p>

<p>This is the approach I typically take when storing structures which I have defined to the EEPROM, as it gives more control when retrieving this information from the EEPROM at a later point.</p>

<p><em>I'll be the first to admit this is perhaps not the most elegant solution, but it should help address your issues.</em></p>
",,,
51823413,2,51822921,2018-08-13T13:22:54.190,0,,7640269,,2018-08-13T14:13:26.537,2018-08-13T14:13:26.537,2,,"<p>I found the problem, what is <code>url.c_str()</code> doing?</p>

<pre><code>curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
</code></pre>

<p>change this to</p>

<pre><code>curl_easy_setopt(curl, CURLOPT_URL, url);
</code></pre>

<hr>

<p><strong>Example : Curl program that download the text file.</strong></p>

<p>Offcourse you need to add this neccessary header file here.</p>

<pre><code>size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}

int main(void) {
    CURL *curl;
    FILE *fp;
    CURLcode res;
    const char *url = ""http://localhost/yourfile.txt"";
    char outfilename[FILENAME_MAX] = ""C:\\outfile.txt"";
    curl = curl_easy_init();
    if (curl) {
        fp = fopen(outfilename,""wb"");
        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1); /* enable failure on http errors */
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        res = curl_easy_perform(curl);
        if(res != CURLE_OK) { /* check that the operation was successful */
          printf(""curl_easy_perform(): %s\n"", curl_easy_strerror(res));
        }
        /* always cleanup */
        curl_easy_cleanup(curl);
        fclose(fp);
    }
    return 0;
}
</code></pre>
",,,
51852338,2,51838526,2018-08-15T02:54:42.333,1,,1329652,,2018-08-15T02:54:42.333,,9,,"<p>First of all, you don't need explicit multithreading (it's optional), second of all you don't need any manually managed synchronization primitives.</p>

<p>Then, model each procedure using a state machine. Hopefully the communication protocol allows each procedure recognize the responses to its own commands, so that even though you'd be replicating the incoming data to all of the procedures, they'd ignore the data irrelevant to them.</p>

<p><a href=""https://stackoverflow.com/a/32595398/1329652"">This answer</a> has a sketch of a solution that does exactly what you want, sans multiplexing. Multiplexing a <code>QIODevice</code> is trivial when you expose it via <a href=""https://stackoverflow.com/a/32317276/1329652"">local pipes</a>: everything incoming from the port is written to one end of one or more local pipes. Everything incoming from the pipes is written to the port. The pipes will maintain the integrity of the packets as long as you open their procedure end in <code>Unbuffered</code> mode. That way each <code>write</code> will arrive at the serial port as a contiguous block of bytes, and will be written to the port in the same manner.</p>

<p>How would you multiplex? Like so:</p>

<pre><code>class IODeviceMux : public QObject {
  Q_OBJECT
  QVector&lt;QPointer&lt;AppPipe&gt;&gt; m_portPipes;
  QVector&lt;QPointer&lt;AppPipe&gt;&gt; m_userPipes;
  QPointer&lt;QSerialPort&gt; m_port;
public:
  IODeviceMux(QObject *parent = {}) : QObject(parent) {}
  void setPort(QIODevice *port) {
    if (m_port) {
      disconnect(m_port.get(), 0, this, 0);
      m_userPipes.removeAll({});
      for (auto pipe : qAsConst(m_userPipes))
        disconnect(m_port.get(), 0, pipe.get(), 0);
    }
    m_port = port;
    connect(m_port.get(), &amp;QIODevice::readyRead, this, &amp;IODeviceMux::onPortRead);
  }
  AppPipe *getPipe() {
    QScopedPointer&lt;AppPipe&gt; user(new AppPipe(QIODevice::ReadWrite | QIODevice::Unbuffered));
    auto *port = new AppPipe(QIODevice::ReadWrite | QIODevice::Unbuffered, this);
    user-&gt;addOther(port);
    connect(port, &amp;QIODevice::readyRead, this, &amp;IODeviceMux::onPipeRead);
    connect(m_port.get(), &amp;QIODevice::bytesWritten, user.get(), &amp;QIODevice::bytesWritten);
    connect(user, &amp;QObject::destroyed, port, &amp;QObject::deleteLater);
    m_userPipes.push_back(user.get());
    m_portPipes.push_back(port);
    return user.take();
  } 
private:
  void onPortRead() {
    if (!m_port) return;
    auto data = m_port-&gt;readAll();
    m_portPipes.removeAll({});
    for (auto pipe : qAsConst(m_portPipes))
      pipe-&gt;write(data);
  }
  void onPipeRead() {
    auto *pipe = qobject_cast&lt;AppPipe*&gt;(sender());
    QByteArray data;
    if (pipe) data = pipe-&gt;readAll();
    if (m_port) m_port-&gt;write(data);
  }
};
</code></pre>

<p>The procedures would each <code>getPipe()</code> and treat the pipe as if it was a serial port device. Each <code>write</code> into a pipe gets faithfully executed on the port. Each <code>readyRead</code> on the port is faithfully forwarded, with same data amounts available immediately to read. Even the port's <code>bytesWritten</code> is forwarded. But <code>bytesToWrite</code> doesn't work - it always returns zero. This could be fixed by adding an option to <code>AppPipe</code> to query this value.</p>

<p>That's about all you need to get it to work, I'd think.</p>
",,,
51858623,2,51849401,2018-08-15T12:22:40.040,0,,6810069,,2018-08-15T12:22:40.040,,0,,"<p>I just add the code below, after open() and it's not blocked anymore when tx/rx pins are not connected. Probably the port was going blocked after open().</p>

<pre><code>  if (fd == -1)
    {
      /*
       * Could not open the port.
       */

      perror(""open_port: Unable to open /dev/serial0 - "");
    }
  else fcntl(fd, F_SETFL, O_NONBLOCK);
</code></pre>
",,,
51875291,2,51874205,2018-08-16T10:51:33.417,1,,4756299,,2018-08-16T10:51:33.417,,7,,"<p>Given these contents of <code>dispmanx.c</code>:</p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
</code></pre>

<p>and <code>main.cpp</code> starts with</p>

<pre><code>#include ""dispmanx.c""
</code></pre>

<p>You are going to have <em>serious</em> problems.</p>

<p>You've wrapped entire standard header files such as <code>unistd.h</code>  with <code>extern ""C""</code>, and then <code>#include</code>'d them in a C++ file.</p>

<p>They're not meant to be used that way in C++ code.</p>

<p><code>#include</code>'ing a source file (<code>.c</code>, <code>.cpp</code>, etc) is a fundamentally bad idea in the first place.  Doing it across different languages such a C and C++ and then improperly wrapping system headers with <code>extern ""C""</code> is even worse.  You can't safely compile C code as C++ code, and you certainly can't wrap system header files with <code>extern ""C""</code> for use in C++ code.</p>

<p><code>extern ""C""</code> does not make it safe to compile C code with a C++ compiler.   They are different languages, with subtle distinctions.</p>
",,,
51876952,2,51874205,2018-08-16T12:20:46.740,1,,509868,,2018-08-16T12:20:46.740,,0,,"<p>The problem is here:</p>

<pre><code>#include ""dispmanx.c""
</code></pre>

<p>Including a <code>*.c</code> file in a <code>*.cpp</code> file is not a good idea. C and C++ are similar languages, so it may look that it works at first (i.e. the compiler reports the error not at line 1 but at line 111), but actually it doesn't.</p>

<p>One correct way to call C code from C++ code is by providing a declaration like this:</p>

<pre><code>// C++ code
#include &lt;iostream&gt;

extern ""C"" {
    int run(unsigned char* fileData); // declaration for the C code
}

...
int main()
{
    ...
    run(image.data); // calling the C code
}
</code></pre>

<p>The declaration for the C code can be in the <code>*.cpp</code> file or, more conventionally, in a separate dedicated <code>*.h</code> file. If your C code is in <code>dispmanx.c</code>, then a conventional name is <code>dispmanx.h</code>:</p>

<pre><code>// dispmanx.h
extern ""C"" {
    int run(unsigned char* fileData); // declaration for the C code
}
</code></pre>



<pre><code>// main.cpp
#include &lt;iostream&gt;
#include ""dispmanx.h""
...
int main()
{
    ...
    run(image.data); // calling the C code
}
</code></pre>

<p>Also, another convention: if you want to make your new <code>dispmanx.h</code> file compilable in both C and C++, you should hide the <code>extern ""C""</code> part from the C compiler, as described in <a href=""https://stackoverflow.com/q/3789340/509868"">this question and answer</a>.</p>
",,,
51886845,2,51886824,2018-08-17T00:11:37.527,2,,1670129,,2018-08-17T00:11:37.527,,1,,"<pre><code>template &lt;typename T, size_t N&gt;
size_t length(T (&amp;input)[N])
{
    return N;
}
</code></pre>

<p>Or just use <code>std::extent</code></p>
",,,
51886848,2,51886824,2018-08-17T00:12:09.433,1,,4950448,,2018-08-17T00:16:12.077,2018-08-17T00:16:12.077,3,,"<p>You can't, because the array is decayed to a pointer to its first element.
However, you can do something like that :</p>

<pre><code>template&lt;size_t N&gt;
void foo(int (&amp;array)[N]) {
    for(auto elem : array) use(elem);
}

template&lt;typename T, size_t N&gt;
size_t length(T (&amp;)[N]) {
    return N;
}
</code></pre>

<p>Else you can use <code>std::array</code> that is the proper way to do static array in C++</p>
",,,
51898981,2,51897074,2018-08-17T15:50:33.150,0,,225074,,2018-08-17T15:50:33.150,,1,,"<p>Operate on the array as <em>bytes</em>, then assemble and place into integers:  </p>

<pre><code>void ConvertToInt(int OutArray[], byte InArray[], int InSize)
{
  int * p_output = &amp;OutArray[0];
  for (size_t i = 0; i &lt; inSize; ++i)
  {
    byte lsb = InArray[i++];
    byte msb = InArray[i];
    int value = (msb &lt;&lt; 8) | lsb;
    *p_output++ = value;
  }
}
</code></pre>

<p>You may need to convert to larger integers, depending on the warning level:  </p>

<pre><code>for (size_t i = 0U; i &lt; InSize; i += 2U)
{
  const byte lsb = InArray[i + 0U];
  const byte msb = InArray[i + 1U];
  const int lsb_as_int(static_cast&lt;int&gt;(lsb));
  const int msb_as_int(static_cast&lt;int&gt;(msb));
  *p_output++ = (msb_as_int * 256) + lsb_as_int;
}
</code></pre>

<p>In the above code, the promotion of <code>byte</code> to <code>int</code> is explicit.  The variables are temporary and the compiler should simplify this (so don't worry about the temporary variables).  Also, the temporary variables allow you to see the intermediate values when using a debugger.  </p>

<p>Print out the assembly language generated by the compiler, in both debug and release (optimized) versions, before optimizing or panicking. A good compiler should optimize the loop contents to a few instructions.  </p>
",,,
51899338,2,51897074,2018-08-17T16:12:29.467,0,,4955498,,2018-08-17T16:53:56.447,2018-08-17T16:53:56.447,0,,"<p>If your machine is little endian, then this can be done in O(1) time and additional-memory complexity.</p>

<pre><code>int16_t *ToInt(byte inArray[])
{
  return reinterpret_cast&lt;int16_t*&gt;(inArray);
}
</code></pre>

<p>If you either want it in a new array, or your machine is big endian, you must walk over all elements. In that case the best you can get is O(n) time complexity.</p>

<p>The only way to get around that, is to wrap the original array in an accessor class that will convert between byte pairs to int. Such a wrapper will speed the time for the first several accesses, but if at some point all the array has to be read, then the lazy evaluation will cost more than converting the array from the beginning.</p>

<p>On the positive sude, the wrapper costs only O(1) additional memory. Also, if you want to save the array as bytes, you don't have to convert.</p>

<pre><code>class as_int {
public:
   class proxy
   {
      public:
          proxy &amp; operator=(int16_t value)
          {
             pair_[0] = value&amp; 255;
             pair_[1] = ((unsigned)value &gt;&gt; 8) &amp; 255;
             return *this;
          }
         operator int16_t() ......
      private:
         proxy(byte*pair): pair_(pair) {}
         friend class as_int;
   };
   as_int(byte *arr, unsigned num_bytes) 
    : arr_(arr), size_(num_bytes/2)
   {}

   int16_t operator[] const (unsigned i)
   {
      assert(i &lt; size);
      byte *pair = arr_ + (i*2);
      return pair[0] + (pair[1]&lt;&lt;8);
   }
   proxy operator[] (unsigned i)
   {
      assert(i &lt; size);
      return proxy(arr_ + (i*2));
   }
  ....
</code></pre>

<p>And the use is quite trivial:</p>

<pre><code>as_int arr(InByteArray, InSize);
std::cout &lt;&lt; arr[3] &lt;&lt; '\n';
arr[5] = 30000;
arr[3] = arr[6] = 500;
</code></pre>
",,,
51904651,2,51904342,2018-08-18T02:02:18.290,0,,7229333,,2018-08-18T02:02:18.290,,4,,"<p>I don't think it is a good strategy to throw all those delays in the code. If you want to work with an RTC, you need to be mindful of those delays as they will affect the functionality of your program. If you don't account for delay properly, they will accumulate as errors. An error of 100 msecs will be seen as <code>error in seconds</code> easily within days.</p>

<p>I did not go through your code because it is hard to understand. I propose you have a look at this code which should be placed in your <code>loop()</code> function:</p>

<pre><code>  delay(100);
  parameters = parameters + 100;    

  long rtcSeconds = parameters / 1000;
  int seconds = (int) (rtcSeconds % 60);  // Range 0 . 59  units: Secs
  int minutes = (int)(((rtcSeconds - seconds) / 60) % 60);   // Range 0 . 59  units: Mins
  int hours =   (int) (((rtcSeconds -  minutes*60 - seconds) / (3600)) % 24);   // Range 0 . 23 units: Hrs
</code></pre>

<p>I am using your <code>parameters[0]</code> field to keep track of the time in your syste, in milliseconds units. The field increases every 100 msecs as you see. You can recover the different time values using a combination of the modulus (<code>%</code>) and division operations. Now, I know you need to increase the time in your program. To do so, it is easy:</p>

<ul>
<li>If you want to increase one second, do this: <code>parameters[0] += 1000;</code></li>
<li>If you want to increase one minute, do this: <code>parameters[0] += 1000 * 60;</code></li>
<li>If you want to increase one hour, do this: <code>parameters[0] += 1000 * 3600;</code></li>
</ul>

<p>Now, you might need to work with <strong>long</strong> variables as int have a limited range. You also need to watch for the time roll over when you change your time. If you are decreasing the time, you need to watch <code>pramaters[0]</code> doesn't become negative. In case it does, you need to add <code>3600 * 24 * 1000 msecs</code> to force it jump one day ahead (<code>3600 * 24</code> is one day in seconds). I hope you understand this is not a solution to your problem but an alternative approach using a little bit of a simpler code structure.  </p>
",,,
51921219,2,51920568,2018-08-19T19:38:26.470,0,,5955921,,2018-08-19T19:38:26.470,,0,,"<p>Ok, the only way I know to do this is to store char pointer, which is set to static-allocated array pointer by default and can be changed on runtime:</p>

<pre><code>struct Label {
    char stringArray[4];
    char *string = stringArray;
    int mode;
};

int main() {
    Label label;
    label.stringArray[0] = 'a';
    label.stringArray[1] = 'b';
    label.stringArray[2] = 'c';
    label.stringArray[3] = '\0';
    cout &lt;&lt; label.string &lt;&lt; endl;
    label.string = ""bbbbbb"";
    cout &lt;&lt; label.string &lt;&lt; endl;
    return 0;
}
</code></pre>
",,,
51928425,2,51927084,2018-08-20T10:07:35.167,0,,9072753,,2018-08-21T03:45:02.810,2018-08-21T03:45:02.810,5,,"<p>Hah, that was fun!</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;

struct num_s {
  // exponent
  int e;

  // v[0] is *10
  // v[1] is *0.01
  // v[2] is *0.0001
  // and so on...
  // to increase precision increase array count
  int v[6];
};

#define NUM_VALSCNT (sizeof(((struct num_s*)0)-&gt;v)/sizeof(((struct num_s*)0)-&gt;v[0]))

// creates num_s object from a double
struct num_s num_create(double v) {
  struct num_s t;

  // find exponent so that v &lt;= 10
  t.e = 0;
  while (fabs(v) &gt;= 10.0) {
    ++t.e;
    v /= 10.0;
  }

  // for each output number get the integral part of number
  // then multiply the rest by 100 and continue
  for (size_t i = 0; i &lt; sizeof(t.v) / sizeof(t.v[0]); ++i) {
    const double tmp = fmod(v, 1.0);
    t.v[i] = v - tmp;
    v = tmp * 100;
  }
  return t;
}

// converts back from num object to double
double num_get(struct num_s t) {
  double denom = 10;
  double ret = 0;
  for (size_t i = 0; i &lt; sizeof(t.v) / sizeof(t.v[0]); ++i) {
    ret += denom * t.v[i];
    denom /= 100;
  }
  return ret * pow(10, t.e - 1);
}

void num_println(struct num_s t) {
  printf(""%f ="", num_get(t));
  for (size_t i = 0; i &lt; sizeof(t.v) / sizeof(t.v[0]); ++i) {
    printf("" %d"", t.v[i]);
  }
  printf("" %d\n"", t.e);
}

// returns the precision of numbers
// the smallest number we can represent in num object
double num_precision(void) {
  return pow(0.1, (NUM_VALSCNT - 1) * 2) * 10;
}

int num_unittests(void) {
  const double tests[][3] = {
    { 123.49, 123.5, 123.51, }
  };
  for (size_t i = 0; i &lt; sizeof(tests) / sizeof(tests[0]); ++i) {
    const double tmp = num_get(num_create(tests[i][1]));
    if (!(tests[i][0] &lt;= tmp &amp;&amp; tmp &lt;= tests[i][2])) {
      return i + 1;
    }
  }
  return 0;
}

int main() {
  num_println(num_create(12.3456789));
  num_println(num_create(123.5));
  num_println(num_create(12.35));
  printf(""%d\n"", num_unittests());
  return 0;
}
</code></pre>
",,,
51983127,2,51982383,2018-08-23T09:58:48.180,2,,10240559,,2018-08-23T09:58:48.180,,1,,"<p>The explanation is that the memory is freed inside get_next_row function <a href=""https://github.com/ChuckBell/MySQL_Connector_Arduino/blob/master/src/MySQL_Cursor.cpp"" rel=""nofollow noreferrer"">https://github.com/ChuckBell/MySQL_Connector_Arduino/blob/master/src/MySQL_Cursor.cpp</a></p>

<pre><code>/*
  get_next_row - Iterator for reading rows from a result set
  This method returns an instance of a structure (row_values)
  that contains an array of strings representing the row
  values returned from the server.
  The caller can use the values however needed - by first
  converting them to a specific type or as a string.
*/
row_values *MySQL_Cursor::get_next_row() {
  int res = 0;

  free_row_buffer();

  // Read the rows
  res = get_row_values();
  if (res != MYSQL_EOF_PACKET) {
    return &amp;row;
  }
  return NULL;
}
</code></pre>

<p>At the second attempt to get rows <strong>free_row_buffer</strong> is called.</p>
",,,
52008709,2,51982383,2018-08-24T16:46:12.733,0,,7309335,,2018-08-24T16:46:12.733,,0,,"<p>I was able to find the solution myself thanks to the advices given by @Jabberwocky and @rantan pan. They provided me a direction on where to look for the solution.
By editting <code>sqldata</code> as shown below, I was able to store the strings instead of pointer into sqldata. </p>

<p>Re-declare sqldata as shown below.</p>

<pre><code>char **sqldata = new char*[11];     //to store 11 data for each query executed
for ( int i = 0; i &lt; 11; i++ )
{
    sqldata[i] = new char[11];
}
</code></pre>

<p>Then replace <code>sqldata[f] = row-&gt;values[f];</code> with <code>strcpy(sqldata[f], (*row).values[f]);</code> </p>

<p>All is working right now. Time to print this crap on an OLED LCD. 
Thanks again folks!</p>
",,,
55530199,2,51982383,2019-04-05T07:22:20.410,0,,7586301,,2019-04-05T07:22:20.410,,0,,"<p>Solution from @TK Ooi is ok, but as an improvement to it I would go safer with the size of the array where we want to store the data, and thus can be done instead of using</p>

<pre><code>int numberRows = 11;
char **sqldata = new char*[numberRows];
for(int i = 0; i &lt; numberRows; i++ ) {
    sqldata[i] = new char[numberChars];
}
strcpy(sqldata[f], (*row).values[f]);`
</code></pre>

<p>better declaring your array of char* as global but doing inside your query function the following:</p>

<pre><code>int numberChars = strlen((*row).values[f]);
sqldata[f] = new char[numberChars]; // implies already extra place for null terminator
snprintf(sqldata[f], strlen(sqldata[f]), ""%s"", (*row).values[f]);`
</code></pre>

<p>This way, we are assigning always the exact length to our array to store the recovered data. Note that using <code>numberChars</code> instead of <code>strlen(sqldata[f])</code> will fail because you need to pass the length according to the type stored in <code>sqldata</code>: it's not the same for <code>int</code> as for <code>char</code>...</p>
",,,
52002852,2,52002484,2018-08-24T10:49:00.403,0,,4062354,,2018-08-24T10:49:00.403,,0,,"<p><a href=""https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tochararray/"" rel=""nofollow noreferrer""><code>string.toCharArray(buf, len)</code> function</a> seems useful.</p>

<pre><code>void make_object(String strText1, String strText2){


  myObject vars;
  strText1.toCharArray(vars.dataA, sizeof(vars.dataA));
  strText2.toCharArray(vars.dataB, sizeof(vars.dataB));
  Serial.println(vars.dataA);
  Serial.println(vars.dataB);
}
</code></pre>
",,,
52004973,2,52002484,2018-08-24T12:53:54.677,0,,6644590,,2018-08-24T12:53:54.677,,0,,"<p>@MikeCAT</p>

<p>Thanks a lot that worked.</p>

<p>With your help I was able to store SSID object to EEPROM</p>

<pre><code>struct wifiConn {
  char eSsid[32];
  char ePasw[32];
};

void write_wifi_toEEPROM(uint8_t startAddr, String strSSID, String strPW){
  wifiConn vars;
  strSSID.toCharArray(vars.eSsid, sizeof(vars.eSsid));
  strPW.toCharArray(vars.ePasw, sizeof(vars.ePasw));
  EEPROM.put(startAddr, vars);
  EEPROM.commit();  
}
wifiConn read_wifi_fromEEPROM(uint8_t startAddr){
  wifiConn readEE;        //Variable to store custom object read from EEPROM.
  EEPROM.get(startAddr, readEE);
  Serial.println(""Read ssid object from EEPROM "");
  return readEE;    
}
</code></pre>

<p>I hope the code will also help other users.</p>
",,,
52019265,2,52017080,2018-08-25T16:36:24.457,1,,10272627,,2020-01-24T07:15:59.870,2020-01-24T07:15:59.870,0,,"<p>In your code, it looks like C++ is throwing an error to a function to create a <code>WString</code> instead of <code>uint8_t</code>, hence the stacktrace in a completely separate header. Searching the source code in the repository for arduino shows that there is an error in WString.cpp <a href=""https://github.com/esp8266/Arduino/issues/3516"" rel=""nofollow noreferrer"">here</a>, which is what your compiler's detecting.</p>

<p>The github users suggest using a different string library, and since the bug hasn't been fixed you'll have to change, probably to the standard <code>string</code> library defined by C++ and <strong>not</strong> arduino. As the users have stated on github, arduino strings are notoriously unreliable.</p>

<p>In other words, this error has nothing to do with your code, but a question that I'd like to ask is ""Why use unions in C++?"" If you want to define a generic type just use templates, ex:</p>

<pre><code> template&lt;class T&gt;

 class ValueDefinition&lt;T&gt; {
 private:
     T typeDat;
 public:
     Valuedefinition(T t);
     /* etc. */
 }
</code></pre>

<p>Unions were made so that C could have a way to use generic typing by having several types share the data in the union. Another common use is taking advantage of the data types using the same memory to find the underlying binary of more complex types, such as using individual <code>uint8_t</code> values underlying a <code>long long</code> to find the value of its bits or using an <code>int</code> to get the binary value of a <code>float</code>, ex:</p>

<pre><code>union foo {
   uint8_t bits[4]; /* Represent the bits of 'data' */

   long long int data;
}

union foo myLong = {.data = 12378591249169278l};
printf(""%d\n"", myLong.bits[0]); // Returns the value of the high bit of myLong
</code></pre>

<p>However note that this is <strong>undefined behavior</strong> because <a href=""https://stackoverflow.com/questions/46815865/are-c-unions-never-padded-at-the-beginning"">unions are usually padded</a> and architectures use a different form of endianess. Whatever you're doing, if you're using C++ there's a better way to implement your solution than using unions, since this was a feature meant for a language that had no generic typing <a href=""https://stackoverflow.com/questions/2310483/purpose-of-unions-in-c-and-c"">in order to save memory</a>.</p>

<p>Edit:
Initialize ValueDefinition using C's <code>malloc</code> like so:</p>

<pre><code>union ValueDefinition *value = malloc(sizeof(union ValueDefinition));
value-&gt;ValueUInt8 = malloc(sizeof(uint8_t));
/* more code */
</code></pre>

<p>Or with C++'s <code>new</code>:</p>

<pre><code>union ValueDefinition *value = new ValueDefinition();
value-&gt;ValueUInt8 = new uint8_t(/* Some number */);
/* more code */
</code></pre>
",,,
52081575,2,52079648,2018-08-29T15:52:56.550,0,,8919345,,2018-08-29T15:52:56.550,,0,,"<p>Not sure about your purpose here, to just count seconds until you reach the trigger and then convert to mm:ss? You could just count the seconds until trigger is reached and express trigger as mm:ss, it's basically the same thing.</p>

<p>Just by guessing, is something like this what you are looking for?</p>

<pre><code>unsigned int minutes = 0;
unsigned int seconds = 0;

unsigned int trigger = 360;
unsigned int elapsed_seconds = 0;

/* Count the seconds until #trigger seconds are reached (?)*/
clock_t start = clock();

do {

  clock_t difference = clock() - start;
  elapsed_seconds = difference * 1000 / CLOCKS_PER_SEC;

  /* Stop at trigger (?)*/
} while ( elapsed_seconds &lt; trigger );

/* Express in minutes and seconds */
minutes = elapsed_seconds / 60;
seconds = elapsed_seconds % 60;

printf(""Time: %02d:%02d\n"", minutes, seconds);
</code></pre>
",,,
55474761,2,52079648,2019-04-02T12:26:37.043,1,,8123906,,2019-04-02T20:27:00.187,2019-04-02T20:27:00.187,0,,"<p>A timer can be initiated using the Teensy system using its overflows and interrupts. The below code will set up and initiate a timer which will count up in. A struct is used to initiate a boolean value (among other possible things within the program) which can be used to control whether or not the overflow of the timer counts, effectively pausing the timer.</p>

<p>A function to draw a string</p>

<pre><code> // Render a string of printable ASCII characters into the screen buffer.
 // Parameters:
 // x - The horizontal position of the top-left corner of the displayed text.
 // y - The vertical position of the top-left corner of the displayed text.
 // character - The ASCII code of the character to render. Valid values range from 
 0x20 == 32 to 0x7f == 127.
 // colour - The colour, FG_COLOUR or BG_COLOUR. If colour is BG_COLOUR,
 the text is rendered as an inverse video block.

void draw_string(int top_left_x, int top_left_y, char *text, colour_t colour) {
    // Draw each character until the null terminator is reached
    for ( uint8_t x = top_left_x, i = 0; text[i] != 0; x += CHAR_WIDTH, i++ ) {
        draw_char(x, top_left_y, text[i], colour);
        // Add a column of spaces here if you want to space out the lettering.
        // (see lcd.c for a hint on how to do this)
    }
}
</code></pre>

<p>Below is a formatting function using the above function to draw a string, the formatting function is used to get the mm:ss layout</p>

<pre><code>// a formatting function to assist with printing to the screen
void draw_formatted(int x, int y, const char * format, ...) {
    va_list args;
    va_start(args, format);
    char buffer[1000];
    vsprintf(buffer, format, args);
    draw_string(x, y, buffer, FG_COLOUR);
}
</code></pre>

<p>With the formatting sorted, a struct should be created to initiate the values requiredto operate the timer, and the timer initiated</p>

<pre><code>// initiates a struct for the timer, which includes a minute, second and 
// validator accessed using tim
struct val_store {
    bool timer_validator;
    uint8_t time_passed
    uint8_t min;
    uint8_t sec;
} tim;

// initiates timer parameters, essentially setting up the timer to be able to function, 
// sets timer to begin, this should be included in the initial setup of a program
TCCR1A = 0;
TCCR1B = 2; 
TIMSK1 = 1;
sei();
tim.timer_validator = true;
</code></pre>

<p>Below is the hidden part of the timer, this is the heart, it creates the values which are the basis of this entire question, it is very important, and it will not work unless TCCR1A, TCCR1B, TIMSK1 and sei() are initiated beforehand, the values can vary from 0, 2, 1 respectively, however, the values used in the below timer must be adjusted accordingly using a bit chart</p>

<pre><code>// Create a volatile global variable called over_flow_count
volatile unsigned int over_flow_count = 0;
//  interrupt service routine to process timer overflow
//  interrupts for Timer 1.
ISR(TIMER1_OVF_vect) {
    // checks if timer is active or not
    if (tim.timer_validator) {
    over_flow_count++;
    }
}
// elapsed time since program start
// use float instead of double to save memory
float elapsed_time(void) {
    float current_time = (float)
        ( ( over_flow_count * 65536.0 + TCNT1 ) * 8.0  / 8000000 );
    return current_time;
}
</code></pre>

<p>Finally, the code that works with the above timer to produce an output in mm:ss format is simple due to the timer above doing all the work, all that remains is the formatting. time passed calls the previously created function, which is the total passed time frame, min and sec are then found using division and modulo, and formatted using the previously made formatting function</p>

<pre><code>tim.time_passed = elapsed_time();
tim.min = time_passed / 60;
tim.sec = time_passed % 60;
draw_formatted(x, y, ""Time: %02d:%02d"", tim.min, tim.sec);
</code></pre>

<p>A pause can be created by using similar</p>

<pre><code>if (BIT_VALUE(PINB, 0)) {
    // buffer before and after to prevent a single press activating
    // multiple instances of a joystick press, cheap interrupt
    _delay_ms(250);

    // pauses timer by setting the boolean to false, preventing the if statement passing
    tim.timer_validator = false;

    while(true) {
        clear_screen();
        #Put processes to occur while paused here

        // checks to see if the pause should resume
        if (BIT_VALUE(PINB, 0)) {
            break;
        }

    // continue timer
    tim.timer_validator = true;

    // once again a buffer for good measure
    _delay_ms(250);
    }
</code></pre>

<p>If the program is correctly created, the timer should retroactively update itself!
Hope it helps!</p>

<p>Relevant includes, not all includes may be used.</p>

<pre><code>// includes
#include &lt;assert.h&gt;
#include &lt;avr/interrupt.h&gt;
#include &lt;avr/io.h&gt;
#include &lt;cpu_speed.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;util/delay.h&gt;
</code></pre>
",,,
52088936,2,52083686,2018-08-30T03:44:00.193,1,,786489,,2018-08-30T03:44:00.193,,5,,"<p>Timer1 has 2 outputs, <code>OC1A</code> and <code>OC1B</code>. Both run off the same hardware timer and are therefore synchronized. The timer is capable to running in three different modes: Fast PWM Mode, Phase Corrected PWM Mode and Phase and Frequency Corrected Mode. You will need to chose the correct mode for you as well as the correct timer prescaler that fits your application. Below is an example.</p>

<pre><code>// Timer1 Resolution 16-bit
// Timer1 A output at 25% Duty Cycle, Fast PWM Mode
// Timer1 B output at 75% Duty Cycle, Fast PWM Mode 

#include &lt;avr/io.h&gt;

int main(void)
{
    // Set GPIO for timer1 output for OC1A and OC1B
    DDRB |= (1 &lt;&lt; DDB1) | (1 &lt;&lt; DDB2);

    ICR1 = 0xFFFF;

    // 25% duty cycle
    OCR1A = 0x3FFF;

    // 75% duty cycle
    OCR1B = 0xBFFF;

    // set none-inverting mode
    TCCR1A |= ((1 &lt;&lt; COM1A1) | (1 &lt;&lt; COM1B1));

    // Fast PWM mode
    TCCR1A |= (1 &lt;&lt; WGM11);
    TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13);

    // START the timer with no prescaler
    TCCR1B |= (1 &lt;&lt; CS10);

    while (1);
}
</code></pre>
",,,
52106681,2,52106452,2018-08-30T23:35:03.697,3,,9939363,,2018-08-30T23:35:03.697,,2,,"<p>One way is to include time.h header and use difftime function. It will be implemented to check if the elaspsed time reaches the set time.</p>

<p>example:</p>

<pre><code>#include &lt;time.h&gt;

void func(float delayInSeconds) {
    time_t startTime;
    time_t now;
    float elapsedTime;
    float setTime = delayInSeconds;

    time(&amp;startTime);
    while (elapsedTime &lt; setTime) {
        //do something...

        now = time(NULL);
        elapsedTime = difftime(now, startTime);
    }
}
</code></pre>
",,,
52134336,2,52134014,2018-09-02T05:49:49.037,1,,1566221,,2018-09-03T03:40:30.367,2020-06-20T09:12:55.060,8,,"<p>If the compiler knows what the denominator in a division is, it may be able to compute the division with a multiply (by the inverse of the denominator)  and a shift. Since division is really slow, even on CPUs which have divide instructions, this technique, often called reciprocal multiplication, can be a huge win.</p>
<p>Unfortunately, some denominators are easier to optimize than others, particularly when multiplication is restricted to 16 bits. So you're likely to see different behaviour with different constant divisors.</p>
<p>I gather that the compiler is not seeing the better optimisation available for that loop, which is to set a temporary to 0 and use it as the result of the division. When <code>i</code> reaches 56 (or 57 as the case may be), the temporary is incremented. I think this would radically reduce execution time.</p>
<hr />
<h3>Compilation test</h3>
<p>Curiosity got the best of me so I installed the current Ubuntu avr-gcc package, which is v5.4.0, and tried some compiles. My program is much simpler than the original:</p>
<pre><code>uint8_t dodiv(uint8_t d) {
  return d / DIVISOR;
}
</code></pre>
<p>Then I compiled it with commands like:</p>
<pre><code>avr-gcc -S -Wall -O3 -o - -mmcu=atmega32 -DDIVISOR=57 avrdiv.c
</code></pre>
<p>As far as I know, <code>-mmcu=atmega32</code> is correct for an Arduino Uno.</p>
<p>Here are a few results, restricted to the body of the <code>dodiv</code> function. I don't think it really explains the differential results in OP's test between 56 and 57, but I might be missing something. It certainly shows why 3 and 7 might have very different timings.</p>
<pre><code>/* DIVISOR 3 */     /* DIVISOR 7 */     /* DIVISOR 56 */    /* DIVISOR 57 */
dodiv:              dodiv:              dodiv:              dodiv:
    ldi r25,lo8(-85)    ldi r25,lo8(37)     lsr r24             ldi r25,lo8(9)
    mul r24,r25         mul r24,r25         lsr r24             mul r24,r25
    mov r24,r1          mov r25,r1          lsr r24             mov r24,r1
    clr __zero_reg__    clr __zero_reg__    ldi r25,lo8(37)     clr __zero_reg__
    lsr r24             sub r24,r25         mul r24,r25         lsr r24
    ret                 lsr r24             mov r24,r1          ret
                        add r24,r25         clr __zero_reg__
                        lsr r24             ret                                              
                        lsr r24                                         
                        ret                                                         
</code></pre>
",,,
52154938,2,52154443,2018-09-03T18:50:31.860,0,,9072753,,2018-09-03T18:50:31.860,,0,,"<p>There are two solutions that i've used. Remember, that xc8 in the lite version is a horrible compiler and produces strange, long, unoptimized, filled with horror assembly code, so switch to gcc+stm32 right away and toss xc8 into the trash.  </p>

<p>You can create a custom container/class to interact with the pin just like arduino does with DigitalIn classes. We can store a handle to a pin using pointer to the PORTA or PORTB or PORTX register and a bit position inside that register. Then we can calculate the needed bitmask to set the pin using simple bit operations. In my early programing days i did that and you can browse source <a href=""https://github.com/Kamilcuk/pic_projects/blob/master/xc8_pic/include/pinpointer.h"" rel=""nofollow noreferrer"">pinpointer.h</a>. Basically it works like this:</p>

<pre><code>pinpointer_t pp = PP_RB7;  // this is PORTBbits.RB7
PP_SET_PIN_AS_OUTPUT(pp); // set RB7 as output, equal to TRISBbits.RB7 = 0
PP_WRITE_PIN(pp, 1); // output 1 on this pin, equal to PORTBbits.RB7 = 1
</code></pre>

<p>A <code>pinpointer_t</code> has 2 bytes. The first byte is the position of the <code>{PORT,LAT,TRIS}{A,B,C,...}</code>. Nowing that microchip produces microcontrolers so that port registers are one after another <code>PORTB - PORTA = 1</code> the first byte stores the number that needs to be added to PORTA to get the address of the port. We could store a pointer here, but that would make pinpointer_t have 4 or maybe more bytes.
The second byte stores the pin position using a bitmask. Now the <code>PP_RB7</code> is equal o <code>0x180</code>, ie. the second port <code>PORTA + 1 = PORTB</code> with 0x80 bitmask, that is the 7th bit. <code>PP_SET_PIN_AS_OUTPUT(PP_RB7)</code> translates roughly to smth like <code>((TRISA) + (PP_RB7&gt;&gt;8)) &amp;= ~PP_RB7 )</code>.<br>
Knowing that the pin number is never greater then 7 and that there are never more than 7 ports, we can store the same information using single byte (first 4 bits for port, second 4 bits for pin), but i discovered that the XC8 free version compiler generates **** code for shift operations like <code>PP_RB7&gt;&gt;4</code> and usually using 2 bytes resulted in smaller code.<br>
So your foo library may look like this:  </p>

<pre><code>// foo.c
void foo_init(void) {
    PP_SET_PIN_AS_OUTPUT(foo_pin);
}

// foo.h
extern pinpointer_t foo_pin;
void foo_init(void);

// main.c
pinpointer_t foo_pin = PP_RB7;
void main() {
    foo_init(void);
}
</code></pre>

<p>But it's better without global variables:</p>

<pre><code>// foo.c
void foo_init(struct foo_s *foo, pinpointer_t pin) {
    foo-&gt;pin = pin;
    PP_SET_PIN_AS_OUTPUT(foo-&gt;pin);
}

// foo.h
struct foo_s {
     pinpointer_t pin;
};
void foo_init(struct foo_s *foo, pinpointer_t pin);

// main.c
void main() {
    struct foo_s foo;
    foo_init(&amp;foo, PP_RB7);
}
</code></pre>

<p>The other solution is to use macros. Macros produces significantly smaller and faster code, but are horrible to maintain. I would create a common <code>*-config</code> file, as macros are determined not by the compiler but by the proceprocessor. Errors are common. I would do it like this:</p>

<pre><code>// foo.c
#include &lt;foo.h&gt;
#ifndef FOO_CALLBACK_SET_PIN_AS_OUTPUT
#error You need to define FOO_CALLBACK_SET_PIN_AS_OUTPUT
#endif
void foo_init(void) {
   FOO_CALLBACK_SET_PIN_AS_OUTPUT();
}

// foo.h
#include &lt;foo-config.h&gt;
void foo_init(void);

// foo-config.h
#define FOO_CALLBACK_SET_PIN_AS_OUTPUT  do{ TRISBbits.RB7 = 1; }while(0)

// main.c
#include &lt;foo.h&gt;
int main() {
   foo_init();
}
</code></pre>

<p>The <code>foo-config.h</code> is a file created with your project that contains the definitions for macros used by the foo library. I have once written a library for <a href=""https://github.com/Kamilcuk/pic_projects/blob/master/xc8_pic/include/hd44780.h#L33"" rel=""nofollow noreferrer"">hd44780</a> which for all gpio/pin operations used macro callbacks. The application needs to add an include path to the compilation process with the <a href=""https://github.com/Kamilcuk/pic_projects/blob/master/xc8_pic/10_hd44780_test/hd44780-config-2xpcf8574.h#L219"" rel=""nofollow noreferrer"">configuration</a>.</p>
",,,
52157667,2,52154443,2018-09-04T01:26:06.210,0,,5001107,,2018-09-04T01:26:06.210,,5,,"<p>It is because the 'x' is really not defined in the foo library scope.</p>

<p>This only works when you have directly include the source (.c) file which do not need header file. </p>

<pre><code>#define x PortDbits.RD0 
#include ""foo.c""
#foo_init();
</code></pre>

<p>It is best if you have another header to define GPIO pins. For example GPIO_x.h</p>

<p>Then inside it.</p>

<pre><code>#ifndef GPIO_X_H
#define GPIO_X_H

#include ""MCUXXXXX.h""

#define x PortDbits.RD0 

#endif
</code></pre>

<p>after this, just include this file in  foo.c</p>

<pre><code>//this is foo.c

#include ""GPIO_x.h
#include ""foo.h""

/* your codes */
</code></pre>
",,,
52169370,2,52154566,2018-09-04T15:11:24.207,0,,10315540,,2018-09-04T15:11:24.207,,0,,"<p>Maybe you missed the fact, that <code>sqlite3_open()</code> needs a pointer to a variable pointing to a <code>sqlite3</code> object. In your original code you declared a pointer to such an object and gave the address of that pointer to the open-function.</p>

<p>When you declare a sub-function doing that job, you should also give it a pointer-pointer:</p>

<pre><code>void open_database (sqlite3 **db)
{
   int rc;
   rc = sqlite3_open(db_name, db);
   // ... now do error checking
}
</code></pre>

<p>And remember to not add that de-referencing ampersand before the <code>db</code> parameter in the call to <code>sqlite3_open()</code>!</p>
",,,
52162262,2,52159911,2018-09-04T08:43:28.887,2,,4165552,,2018-09-04T08:43:28.887,,0,,"<p>From <code>WiFi.h</code> header in arduino-esp32 master branch:</p>

<pre><code>class WiFiClass : public WiFiGenericClass, public WiFiSTAClass, public WiFiScanClass, public WiFiAPClass
{
// ...
};

// here global variable of class WiFiClass is defined
extern WiFiClass WiFi;
</code></pre>

<p>Now, when you execute <code>WiFi.begin(whatever)</code> you are invoking <code>begin</code> method from <code>WiFiSTAClass</code> that <code>WiFiClass</code> inherits.</p>

<p>From <code>WiFiSTA.h</code> :</p>

<pre><code>class WiFiSTAClass
{
public:

    wl_status_t begin(const char* ssid, const char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);
    wl_status_t begin(char* ssid, char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);
wl_status_t begin();

// ...
</code></pre>

<p>If you would like to create your own class and a global variable of this class in the header, just create a header e.g. <code>Myheader.hpp</code>:</p>

<pre><code>#pragma once
// MyHeader.hpp
class Messenger {
public:
    bool send() {
        // whatever
        return true;
    }
};

extern Messenger Msngr;
</code></pre>

<p>However, I strongly discourage you to follow this pattern. Using global variables is quite bad for many reasons. If for some reason you wish to avoid copying the objects of your class, just use smart pointers. If for some reason you wish the objects of your class to be created somewhere else, just create a Factory that will return the desired instances.</p>
",,,
52224684,2,52206882,2018-09-07T14:29:32.350,0,,2096986,,2018-09-07T14:29:32.350,,0,,"<p>I found a code to execute using bcm2835.</p>

<pre><code>static uint64_t cyclePulse(int trigger, int echo) {
    if (!bcm2835_init())
        return 1;

    // Set RPi pin echo to be an input pin
    bcm2835_gpio_fsel(echo, BCM2835_GPIO_FSEL_INPT);
    // Set RPi pin P1-11 to be an output pin
    bcm2835_gpio_fsel(trigger, BCM2835_GPIO_FSEL_OUTP);

    // Declare the unsigned int timer variables to measure pulses
    uint64_t width, begin, start, end;
    int max = 80, check;

    begin = bcm2835_st_read();

    // Emit pulse for 10 microseconds
    bcm2835_gpio_write(trigger, HIGH); // Set trigger state HIGH
    bcm2835_delayMicroseconds(10);  // Wait 10 microseconds
    bcm2835_gpio_write(trigger, LOW);  // Set trigger state LOW

    // Infinite loop until a pulse is received
    while (bcm2835_gpio_lev(echo) == LOW &amp;&amp; check &lt; max) {
        start = bcm2835_st_read();
        check = (int) begin - start;
    }

    // Loop and delay for one microsecond until falling edge detected
    while (bcm2835_gpio_lev(echo) == HIGH) {
        bcm2835_delayMicroseconds(1);
    }
    // Record the ending time of the pulse to get the pulse width
    end = bcm2835_st_read();

    // Get the final with of the pulse
    width = end - start;

    //Close the bcm2835 bridge
    bcm2835_close();

    // Return the total width of the returned pulse
    return width;
}
</code></pre>
",,,
52215990,2,52215722,2018-09-07T05:45:50.040,1,,198536,,2018-09-07T19:06:26.763,2018-09-07T19:06:26.763,0,,"<p>I am not familiar with the Raspberry-Pi, but if the code can directly sense the button state (instead of using a triggered interrupt) do something like this to react only on the enabling transition:</p>

<pre><code>int main (...)
{
     writingPiSetup ();
     bool  last_state = false;

     while (true)
     {
          bool this_state = wiringPiDigital (3);  // use correct function name
          if (last_state == false  &amp;&amp;  this_state == true) // button freshly pressed
          {
               std::cout &lt;&lt; ""Button freshly pressed"" &lt;&lt; std::endl;
          } 
          last_state = this_state;
     }
}
</code></pre>

<p>However, it is quite possible that the hardware is not <a href=""https://en.wikipedia.org/wiki/Switch#Contact_bounce"" rel=""nofollow noreferrer"">debounced</a>.  So inserting a little bit of delay might be called for.   I would experiment with delays in the 10 to 100 millisecond range depending on the particulars of the application.</p>
",,,
52232153,2,52231567,2018-09-08T04:59:12.173,1,,16007,,2018-09-08T19:58:58.123,2018-09-08T19:58:58.123,1,,"<p>So from the tags and such I assume this is a raspberry pi3, in aarch32 mode, probably HYP mode.  Note I do appreciate you reading/borrowing some of my code directly or indirectly.</p>

<p>With your code lets start here:</p>

<pre><code>ldr r0,=0x00080008
mov r1,#0x0000
</code></pre>

<p>this isnt technically a bug, but kinda missed the point of what that copy does.</p>

<pre><code>b   print_mem1
b   print_mem1
b   print_mem2
b   print_mem3
b   print_mem4
b   print_mem1
b   print_mem2
b   print_mem3
b   print_mem4
</code></pre>

<p>combined with these then yes it is a problem.  as they are position dependent and the whole idea of having the toolchain create the table for you then copying it is lost.</p>

<pre><code>Disassembly of section .text:

00080000 &lt;_ram_entry&gt;:
   80000:   eb00000a    bl  80030 &lt;kernel_init&gt;
   80004:   eafffffd    b   80000 &lt;_ram_entry&gt;
   80008:   e59ff074    ldr pc, [pc, #116]  ; 80084 &lt;print_c_mem4+0x4&gt;
   8000c:   ea000013    b   80060 &lt;print_mem1&gt;
   80010:   ea000012    b   80060 &lt;print_mem1&gt;
   80014:   ea000012    b   80064 &lt;print_mem2&gt;
   80018:   ea000012    b   80068 &lt;print_mem3&gt;
   8001c:   ea000012    b   8006c &lt;print_mem4&gt;
   80020:   ea00000e    b   80060 &lt;print_mem1&gt;
   80024:   ea00000e    b   80064 &lt;print_mem2&gt;
   80028:   ea00000e    b   80068 &lt;print_mem3&gt;
   8002c:   ea00000e    b   8006c &lt;print_mem4&gt;
</code></pre>

<p>When I assemble then disassemble, the ldr pc, which is the right way to do this, but landing in the wrong place shows 0x80084 which is 84-8 = 0x7C ahead which is 1111100 0x1F registers used to do a copy to get that far so ...</p>

<pre><code>ldmia r0!,{r2,r3,r4,r5}
stmia r1!,{r2,r3,r4,r5}
ldmia r0!,{r2,r3,r4,r5}
stmia r1!,{r2,r3,r4,r5}
ldmia r0!,{r2,r3,r4,r5}
stmia r1!,{r2,r3,r4,r5}
ldmia r0!,{r2,r3,r4,r5}
stmia r1!,{r2,r3,r4,r5}
</code></pre>

<p>32 registers, 0x80 bytes copied. technically that covers the first vector maybe the second, but certainly not the swi vector.</p>

<p>when you look at the arm documentation (again)(armv7-ar since this is aarch32 or armv7-a compatibility mode) 0x00000008 is where the entry point is for a supervisor/svc/swi call.</p>

<p>So you need an instruction that gets from 0x00000008 to the desired address/label.</p>

<p>so if you revert back to this example or whatever example you borrowed/learned from.</p>

<pre><code>.globl _start
_start:
    ldr pc,reset_handler
    ldr pc,undefined_handler
    ldr pc,swi_handler
    ldr pc,prefetch_handler
    ldr pc,data_handler
    ldr pc,unused_handler
    ldr pc,irq_handler
    ldr pc,fiq_handler
reset_handler:      .word reset
undefined_handler:  .word hang
swi_handler:        .word hang
prefetch_handler:   .word hang
data_handler:       .word hang
unused_handler:     .word hang
irq_handler:        .word irq
fiq_handler:        .word hang

reset:
    mov r0,#0x80000
    mov r1,#0x0000
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}




Disassembly of section .text:

00080000 &lt;_stack&gt;:
   80000:   e59ff018    ldr pc, [pc, #24]   ; 80020 &lt;reset_handler&gt;
   80004:   e59ff018    ldr pc, [pc, #24]   ; 80024 &lt;undefined_handler&gt;
   80008:   e59ff018    ldr pc, [pc, #24]   ; 80028 &lt;swi_handler&gt;
   8000c:   e59ff018    ldr pc, [pc, #24]   ; 8002c &lt;prefetch_handler&gt;
   80010:   e59ff018    ldr pc, [pc, #24]   ; 80030 &lt;data_handler&gt;
   80014:   e59ff018    ldr pc, [pc, #24]   ; 80034 &lt;unused_handler&gt;
   80018:   e59ff018    ldr pc, [pc, #24]   ; 80038 &lt;irq_handler&gt;
   8001c:   e59ff018    ldr pc, [pc, #24]   ; 8003c &lt;fiq_handler&gt;

00080020 &lt;reset_handler&gt;:
   80020:   00080040    andeq   r0, r8, r0, asr #32

00080024 &lt;undefined_handler&gt;:
   80024:   00080058    andeq   r0, r8, r8, asr r0

00080028 &lt;swi_handler&gt;:
   80028:   00080058    andeq   r0, r8, r8, asr r0

0008002c &lt;prefetch_handler&gt;:
   8002c:   00080058    andeq   r0, r8, r8, asr r0

00080030 &lt;data_handler&gt;:
   80030:   00080058    andeq   r0, r8, r8, asr r0

00080034 &lt;unused_handler&gt;:
   80034:   00080058    andeq   r0, r8, r8, asr r0

00080038 &lt;irq_handler&gt;:
   80038:   0008005c    andeq   r0, r8, ip, asr r0

0008003c &lt;fiq_handler&gt;:
   8003c:   00080058    andeq   r0, r8, r8, asr r0

00080040 &lt;reset&gt;:
   80040:   e3a00702    mov r0, #524288 ; 0x80000
   80044:   e3a01000    mov r1, #0
   80048:   e8b003fc    ldm r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
   8004c:   e8a103fc    stmia   r1!, {r2, r3, r4, r5, r6, r7, r8, r9}
   80050:   e8b003fc    ldm r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
   80054:   e8a103fc    stmia   r1!, {r2, r3, r4, r5, r6, r7, r8, r9}

00080058 &lt;hang&gt;:
   80058:   eafffffe    b   80058 &lt;hang&gt;

0008005c &lt;irq&gt;:
   8005c:   eafffffe    b   8005c &lt;irq&gt;
</code></pre>

<p>It both forces the 8 words of entry points to launch out of the exception handler table, and puts those addresses for pc relative access right after in the next 8 words so you need to copy 16 words to let the assembler do the work for you and not have to compute these things.  32 words, 4 instructions 8 registers each, thats 32 words.  or if you prefer 8 sets of instructions 4 words each that works too.</p>

<p>this is what you are after with this whole approach</p>

<pre><code>   80008:   e59ff018    ldr pc, [pc, #24]   ; 80028 &lt;swi_handler&gt;

00080028 &lt;swi_handler&gt;:
   80028:   00080058
</code></pre>

<p>making the tool do the work for you</p>

<p>what if I do this:</p>

<pre><code>.globl _start
_start:
    ldr pc,reset_handler
    ldr pc,undefined_handler
    ldr pc,swi_handler
    ldr pc,prefetch_handler
    ldr pc,data_handler
    ldr pc,unused_handler
    b irq
    ldr pc,fiq_handler
reset_handler:      .word reset
undefined_handler:  .word hang
swi_handler:        .word hang
prefetch_handler:   .word hang
data_handler:       .word hang
unused_handler:     .word hang
irq_handler:        .word irq
fiq_handler:        .word hang

reset:
    mov r0,#0x80000
    mov r1,#0x0000
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}

hang:
    b hang

irq:
    b irq
</code></pre>

<p>I get this</p>

<pre><code>   80018:   ea00000f    b   8005c &lt;irq&gt;
</code></pre>

<p>instead of this</p>

<pre><code>   80018:   e59ff018    ldr pc, [pc, #24]   ; 80038 &lt;irq_handler&gt;
</code></pre>

<p>the latter is saying read from pc+24 the pc in this case is 8 ahead of that so instruction address + 32 which is instruction address+0x20.</p>

<p>and this</p>

<pre><code>   80018:   ea00000f    b   8005c &lt;irq&gt;
</code></pre>

<p>is saying to branch to the address 0x44 ahead of the instruction address</p>

<p>Now lets disassemble from a different base address, the object for example (rather than the linked elf binary) is an excellent choice</p>

<pre><code>00000000 &lt;_start&gt;:
   0:   e59ff018    ldr pc, [pc, #24]   ; 20 &lt;reset_handler&gt;
   4:   e59ff018    ldr pc, [pc, #24]   ; 24 &lt;undefined_handler&gt;
   8:   e59ff018    ldr pc, [pc, #24]   ; 28 &lt;swi_handler&gt;
   c:   e59ff018    ldr pc, [pc, #24]   ; 2c &lt;prefetch_handler&gt;
  10:   e59ff018    ldr pc, [pc, #24]   ; 30 &lt;data_handler&gt;
  14:   e59ff018    ldr pc, [pc, #24]   ; 34 &lt;unused_handler&gt;
  18:   ea00000f    b   5c &lt;irq&gt;
  1c:   e59ff018    ldr pc, [pc, #24]   ; 3c &lt;fiq_handler&gt;
</code></pre>

<p>Notice the machine code for all the others, load the word 0x20 bytes ahead of this instruction into the pc.  </p>

<p>Where the branch says branch 0x44 byte ahead of the program counter.</p>

<p>We used the toolchain to make that table</p>

<pre><code>00080020 &lt;reset_handler&gt;:
   80020:   00080040    andeq   r0, r8, r0, asr #32

00080024 &lt;undefined_handler&gt;:
   80024:   00080058    andeq   r0, r8, r8, asr r0

00080028 &lt;swi_handler&gt;:
   80028:   00080058    andeq   r0, r8, r8, asr r0

0008002c &lt;prefetch_handler&gt;:
   8002c:   00080058    andeq   r0, r8, r8, asr r0

00080030 &lt;data_handler&gt;:
   80030:   00080058    andeq   r0, r8, r8, asr r0

00080034 &lt;unused_handler&gt;:
   80034:   00080058    andeq   r0, r8, r8, asr r0

00080038 &lt;irq_handler&gt;:
   80038:   0008005c    andeq   r0, r8, ip, asr r0

0008003c &lt;fiq_handler&gt;:
   8003c:   00080058    andeq   r0, r8, r8, asr r0
</code></pre>

<p>If we copy 0x40 bytes from 0x80000 to 0x00000 then when it hits the machine code at 0x18 that says read from 0x38 and put that in the program counter then it will get 0008005c which is the right place</p>

<p>but if instead it finds </p>

<pre><code>18: ea00000f    b   5c &lt;irq&gt;
</code></pre>

<p>that means branch to 0x5c where we have no handler.</p>

<p>so other than not setting a stack pointer and how did your code make it to the swi, but anyway, if you built this</p>

<pre><code>80008:  e59ff074    ldr pc, [pc, #116]  ; 80084 &lt;print_c_mem4+0x4&gt;
   8000c:   ea000013    b   80060 &lt;print_mem1&gt;
   80010:   ea000012    b   80060 &lt;print_mem1&gt;
   80014:   ea000012    b   80064 &lt;print_mem2&gt;
   80018:   ea000012    b   80068 &lt;print_mem3&gt;
   8001c:   ea000012    b   8006c &lt;print_mem4&gt;
   80020:   ea00000e    b   80060 &lt;print_mem1&gt;
   80024:   ea00000e    b   80064 &lt;print_mem2&gt;
   80028:   ea00000e    b   80068 &lt;print_mem3&gt;
   8002c:   ea00000e    b   8006c &lt;print_mem4&gt;
</code></pre>

<p>or something like it since your print_mems are not just placeholders to get this example to build for this answer. but still pc relative branches.</p>

<p>and you copied from 0x80008 for a while to 0x00000 then the instruction that ends up being at address 0x00000008 which is the svc/swi handler is</p>

<pre><code>   80010:   ea000012    b   80060 &lt;print_mem1&gt;
</code></pre>

<p>a branch to print_mem1, but it isnt going to go anywhere near print_mem1 because it is going to branch some number of bytes after 0x00000 which is going to be 0x80008 bytes away from the address you really wanted it to land on.</p>

<p>Now saying ALL of that, if you search for HVBAR in the arm documentation you will find that you dont have to do any of that copying you can setup an exception table in memory and change the base address of where the processor goes when an exception (other than reset) occurs.  but notice the lower 5 bits have to be zero so 0x80008 will not work.  So use .balign in your code, build the table there, use labels to get the address of that and stick it in HVBAR you can then use branch instead of ldr pc.  For armv6 and older the copy or build the table(s) needs to be done because other than a processor strap for a high address the vectors have to be at 0x00000000.  For armv7 and a number of the cortex-ms you can instead move/point at the table at some other address (until reset).</p>

<p>Its good to understand that copy trick I demonstrated, but you have to use it correctly for it to work.  Its not an uncommon solution.  Note another way to have done that and you can do that here to is:</p>

<pre><code>.globl _start
_start:
    b 0x80000
    b 0x80004
    b 0x80008
    b 0x8000C
</code></pre>

<p>when linked at 0x0000 </p>

<pre><code>00000000 &lt;_start&gt;:
   0:   ea01fffe    b   80000 &lt;_stack&gt;
   4:   ea01fffe    b   80004 &lt;*ABS*0x80004&gt;
   8:   ea01fffe    b   80008 &lt;*ABS*0x80008&gt;
   c:   ea01fffe    b   8000c &lt;*ABS*0x8000c&gt;
</code></pre>

<p>so this machine code ea01fffe means branch to 0x80000 relative to the address of that instruction, so instead of the copy you could just write the first 8 words starting at 0x00000000 and the processor will branch to your 0x80000 table.  If you want to build it at 0x80008 then let the tools do the work for you:</p>

<pre><code>.globl _start
_start:
    b 0x80008
    b 0x8000c
    b 0x80010
    b 0x80014
</code></pre>

<p>as expected, the immediate is number of words, 0x8 is two words add 2 to 1fffe you get 0x20000</p>

<pre><code>00000000 &lt;_start&gt;:
   0:   ea020000    b   80008 &lt;*ABS*0x80008&gt;
   4:   ea020000    b   8000c &lt;*ABS*0x8000c&gt;
   8:   ea020000    b   80010 &lt;*ABS*0x80010&gt;
   c:   ea020000    b   80014 &lt;*ABS*0x80014&gt;
</code></pre>

<p>also we know that the pc is two ahead so when executing at address 0 the pc when used in this way is 8 we want to go to 0x80008 that is 0x80000 ahead of the pc, the immediate in the instruction is in units of words so 0x20000 words ahead.</p>

<p>So instead of the copy </p>

<pre><code>ldr r0,=0xEA020000
ldr r1,=0x00000000
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
str r0,[r1],#4
</code></pre>

<p>or some other solution that will fill those 8 locations with a branch to the right place.</p>

<p>EDIT </p>

<p>Yet another approach that letting the tools do this for us:</p>

<p>Disassembly of section .text:</p>

<pre><code>00080000 &lt;_stack&gt;:
   80000:   e59ff018    ldr pc, [pc, #24]   ; 80020 &lt;reset_handler&gt;
   80004:   e59ff018    ldr pc, [pc, #24]   ; 80024 &lt;undefined_handler&gt;
   80008:   e59ff018    ldr pc, [pc, #24]   ; 80028 &lt;swi_handler&gt;
   8000c:   e59ff018    ldr pc, [pc, #24]   ; 8002c &lt;prefetch_handler&gt;
   80010:   e59ff018    ldr pc, [pc, #24]   ; 80030 &lt;data_handler&gt;
   80014:   e59ff018    ldr pc, [pc, #24]   ; 80034 &lt;unused_handler&gt;
   80018:   e59ff018    ldr pc, [pc, #24]   ; 80038 &lt;irq_handler&gt;
   8001c:   e59ff018    ldr pc, [pc, #24]   ; 8003c &lt;fiq_handler&gt;
</code></pre>

<p>Is that we can fill the first 8 words of memory with e59ff018 and then at some point before we need them can fill in the addresses later, before creating interrupts fill in 0x00000038 with the address to the handler, can use C or ASM or whatever.  Can change the handler each time, put 0xe59ff018 in memory at 0x00000008 and the address to your swi handler at 0x00000028 before executing an svc/swi instruction, change the handler at 0x00000028 and try again.  </p>
",,,
52261636,2,52248032,2018-09-10T16:04:46.860,0,,10338937,,2018-09-10T16:04:46.860,,0,,"<p>Caleb helped me very much. It's not really worked what i wanted, but i found another post on ubuntuforums.org (Keywords have been: c pid_t fork kill exec). And that was a really good answer. So Thanks to your help Caleb. It should be an vote up, but my rep isn't high enough. So sorry. But it said it has been recorded.</p>

<p>So heres the link to the post: <a href=""https://ubuntuforums.org/showthread.php?t=675734"" rel=""nofollow noreferrer"">https://ubuntuforums.org/showthread.php?t=675734</a></p>

<p>And here is the Code:</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    pid_t childPID = fork();

    if ( childPID == -1 )
    {
        printf( ""failed to fork child\n"" );
        _exit( 1 );
    }
    else if ( childPID == 0 )
    {
        char *args[] = { ""test"", ""hello"", ""world"", 0 };

        execv( ""test"", args );
    }

    while ( 1 )
    {
        printf( ""Enter 'q' to kill child process...\n"" );
//      char c = getchar();
        sleep( 10 );
        char c = 'q';
        if ( c == 'q' )
        {
            kill( childPID, SIGKILL );
            break;
        }

        sleep( 1 );
    }

    return 0;
}
</code></pre>

<p>I hope any other people with also this problem, could solve it with my question and answer.</p>

<p>But a big thanks to Caleb.</p>
",,,
52296511,2,52296003,2018-09-12T13:34:56.830,0,,2754173,,2018-09-12T15:53:01.283,2018-09-12T15:53:01.283,1,,"<p>If using <a href=""https://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>sscanf()</code></a> (<code>#include &lt;stdio.h&gt;</code>) is within your limitations then you can call with it <code>""%hhx""</code> to extract each individual hex value into an <code>unsigned char</code> like this:</p>

<pre><code>const int PAYLOAD_LENGTH = 14; // Known in advance
unsigned char gImage_test[PAYLOAD_LENGTH];

#include &lt;stdio.h&gt;

int main()
{
    const char* bufferPtr = ""{0X00,0X01,0XC8,0X00,0XC8,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF}"";
    for (int i = 0; i &lt; PAYLOAD_LENGTH &amp;&amp; sscanf(bufferPtr + 1, ""%hhx"", &amp;gImage_test[i]); i++, bufferPtr += 5);

    return 0;
}
</code></pre>
",,,
52333281,2,52332809,2018-09-14T13:43:42.963,1,,7266357,,2018-09-14T13:43:42.963,,0,,"<p>I guess that you're setting include_directories to the wrong path (it is set 2 times to ${CMAKE_SOURCE_DIR}/lib which must be the folder of libraries not the header files). Check again the correct location of the missing header file. </p>

<p>More precisely: you need to find the path of mirsdrapi-rsp.h and let CMake know it just like for find_library:</p>

<pre><code>find_path(MIRSDRAPI_INCLUDE_DIRS NAMES mirsdrapi-rsp.h PATHS {proper-location})

if (MIRSDRAPI_INCLUDE_DIRS)
  target_include_directories(raspberryPiDaemon PRIVATE ${MIRSDRAPI_INCLUDE_DIRS})
endif()
</code></pre>

<p>In addition, you can set the INTERFACE_INCLUDE_DIRECTORIES property to the library like this:</p>

<pre><code>set_property(TARGET mirsdrapi-rsp APPEND PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${MIRSDRAPI_INCLUDE_DIRS})
</code></pre>

<p>This way, target_include_directories might be unnecessary and target_link_directories should be enough. </p>
",,,
52337800,2,52336870,2018-09-14T18:56:30.030,2,,5023438,,2018-09-14T18:56:30.030,,2,,"<p>Currently, your <code>StepControl::move()</code> method is written to only accept arrays whose size is known at <em>compile time</em>. This means that if the compiler can figure out the size of an array, as in:</p>

<pre><code>// size is inferred at compile time to be 6
Stepper* robot[] = {&amp;J1,&amp;J2,&amp;J3,&amp;J4,&amp;J5,&amp;J6};
</code></pre>

<p>then the compiler can successfully match <code>controller.move(robot);</code> to the following template instantiation:</p>

<pre><code>void move&lt;&gt;(Stepper* (&amp;motors)[6], float relSpeed = 1);
</code></pre>

<p>But without knowing at compile time what your array size is going to be, the compiler can't match a call to <code>move</code> to a particular template instantiation. When you write</p>

<pre><code>int j = 4;
Stepper *robot[j];
</code></pre>

<p>Because <code>j</code> is not a compile-time constant, <code>robot</code> is actually a <a href=""https://stackoverflow.com/questions/1204521/dynamic-array-in-stack"">dynamically sized stack array</a> which is non-standard. Some compilers allow it, but a consequence is that the size of <code>robot</code> cannot be known at compile time.</p>

<hr/>

<p>To fix this, you could either always be certain of your array size at compile time, as in:</p>

<pre><code>if (needsToBeSix){
    Stepper *robots[6] = ...;
    controller.move(robots);
} else if (needsToBeFour){
    Stepper *robots[4] = ...;
    controller.move(robots);
}
</code></pre>

<p>Or, if you really need dynamically-sized arrays, use <a href=""https://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a>:</p>

<pre><code>class StepControl {
    ...
    void move(std::vector&lt;Stepper*&gt;&amp; motors, float relSpeed = 1){
        // size can be queried at runtime as follows
        const size_t N = motors.size();
        // rest of method;
    }
    ...
}

...

std::vector&lt;Stepper*&gt; robot { &amp;J1, &amp;J2, &amp;J3, &amp;J4 };
if (needTwoMore){
    robot.push_back(&amp;J5);
    robot.push_back(&amp;J6);
}
controller.move(robot);
</code></pre>
",,,
52352568,2,52348930,2018-09-16T08:59:56.300,6,,6519963,,2018-09-16T08:59:56.300,,2,,"<p>There are many ways to do this. I often do it pin-by-pin.</p>

<p>One simple way is to make your own 'register' by defining a variable. If the register is 8-bit wide, define byte variable:</p>

<pre><code>unsigned char disp_register;
</code></pre>

<p>Then you write to this register like it would exist in display hardware. Of course, next you must output this register to the GPIO pins of ESP32. Since the pins are all over, you must do this pin-by-pin. Define your hardware pins for readability:</p>

<pre><code>/* OUTPUTS (numbers mean GPIO port) */
#define REGISTER_BIT7_ON_PIN        9
#define REGISTER_BIT6_ON_PIN        10
#define REGISTER_BIT5_ON_PIN        5
// continue with all the pins you need
</code></pre>

<p>Somewhere at the beginning of your program, set these pins as output, and perhaps make their default value to '0':</p>

<pre><code>io_conf.intr_type = GPIO_PIN_INTR_DISABLE;
io_conf.mode = GPIO_MODE_OUTPUT;
io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
io_conf.pin_bit_mask =  ((1ULL&lt;&lt; REGISTER_BIT7_ON_PIN) | (1ULL&lt;&lt; REGISTER_BIT6_ON_PIN) | (1ULL&lt;&lt; REGISTER_BIT5_ON_PIN)); // of course, do like this all the pins
gpio_config(&amp;io_conf);

gpio_set_level(REGISTER_BIT7_ON_PIN, 0); // do like this all the pins you need to set the boot-up value, pin-by-pin
</code></pre>

<p>Next you need your function to copy your register to outside world of GPIO pins:</p>

<pre><code>/*
 * wrote this simply for ease of understanding, feel free to do this in a loop
 * or shifting bit by bit
 */
void copy_register_to_GPIO_pins(unsigned char disp_register)
{
    gpio_set_level(REGISTER_BIT7_ON_PIN, (disp_register &amp; 0x80) &gt;&gt; 7);
    gpio_set_level(REGISTER_BIT6_ON_PIN, (disp_register &amp; 0x40) &gt;&gt; 6);
    gpio_set_level(REGISTER_BIT5_ON_PIN, (disp_register &amp; 0x20) &gt;&gt; 5);
    gpio_set_level(REGISTER_BIT4_ON_PIN, (disp_register &amp; 0x10) &gt;&gt; 4);
    gpio_set_level(REGISTER_BIT3_ON_PIN, (disp_register &amp; 0x08) &gt;&gt; 3);
    gpio_set_level(REGISTER_BIT2_ON_PIN, (disp_register &amp; 0x04) &gt;&gt; 2);
    gpio_set_level(REGISTER_BIT1_ON_PIN, (disp_register &amp; 0x02) &gt;&gt; 1);
    gpio_set_level(REGISTER_BIT0_ON_PIN, (disp_register &amp; 0x01));
}
</code></pre>

<p>Then, after you wrote anything into your register, call your function to output it:</p>

<pre><code>disp_register = 0x2A; // example value you want to send to display
copy_register_to_GPIO_pins(disp_register);

// or, output byte WITHOUT using any register:
copy_register_to_GPIO_pins(0x2A);
</code></pre>

<p>Hopefully, you can do the reverse by yourself, reading the pins is done by another function, where you copy each GPIO pin value and assemble it into byte variable. Of course, pins have to be set to inputs at this point. In principle:</p>

<pre><code>/*
 * wrote this simply for ease of understanding
 */
unsigned char copy_GPIO_pins_to_register(void)
{
    unsigned char retval = 0;

    retval |= gpio_get_level(REGISTER_BIT7_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT6_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT5_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT4_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT3_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT2_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT1_ON_PIN);
    retval = retval &lt;&lt; 1;
    retval |= gpio_get_level(REGISTER_BIT0_ON_PIN);

    return retval;
}
</code></pre>
",,,
52976497,2,52348930,2018-10-24T19:21:19.703,8,,9306893,,2018-10-26T16:32:07.807,2018-10-26T16:32:07.807,0,,"<p>In order to minimize computational burden when operating the 8 pins, you will want these pins to correspond to consecutive GPIO numbers (e.g. GPIO12 to GPIO19).
Below is an implementation that operates multiple input/output pins in parallel and works if the above requirement (consecutive GPIO numbers) is met and if GPIO numbers are all in the range 0-31; I used GPIO12 to GPIO19 (GPIO12 corresponds to bit 0 in the input/output 8-bit values), which are handy to use if you have an ESP32 dev board with an ESP-WROOM-32 or ESP32-WROVER module.
So I defined the GPIO corresponding to bit 0 as below:</p>

<pre><code>#define PARALLEL_0  12
</code></pre>

<p>At initialization, you need to configure all 8 pins a GPIOs, e.g. by setting them all as inputs:</p>

<pre><code>void setup() {
  for (int i = 0; i &lt; 8; i++) {
    pinMode(PARALLEL_0 + i, INPUT);
  }
}
</code></pre>

<p>After that, you can use the following functions to set the 8 pins as inputs or outputs, and to read the input values and write the output values:</p>

<pre><code>void parallel_set_inputs(void) {
  REG_WRITE(GPIO_ENABLE_W1TC_REG, 0xFF &lt;&lt; PARALLEL_0);
}

void parallel_set_outputs(void) {
  REG_WRITE(GPIO_ENABLE_W1TS_REG, 0xFF &lt;&lt; PARALLEL_0);
}

uint8_t parallel_read(void) {
  uint32_t input = REG_READ(GPIO_IN_REG);

  return (input &gt;&gt; PARALLEL_0);
}

void parallel_write(uint8_t value) {
  uint32_t output =
    (REG_READ(GPIO_OUT_REG) &amp; ~(0xFF &lt;&lt; PARALLEL_0)) | (((uint32_t)value) &lt;&lt; PARALLEL_0);

  REG_WRITE(GPIO_OUT_REG, output);
}
</code></pre>
",,,
52374452,2,52371410,2018-09-17T19:23:59.267,1,,3671422,,2018-09-18T19:45:25.457,2020-06-20T09:12:55.060,4,,"<p>I took a look at your code, are you compiling it in your PC? Looks like the compiler is ignoring the declaration of the csPinset etc due to you #ifdef block -</p>
<p>I'm not familiar with AVR environment, but I recommend compiling your code with the correct compiler(eg AVR compliant) in the intended environment. Alternatively, you can also define __ AVR __ at compile time using the -D option:</p>
<p>g++ &lt; file_name.cpp &gt; -D__AVR__</p>
<h1>EDIT</h1>
<p>To make sure the variables you need are declared for all environment, you can change the header file to something like this-</p>
<pre><code>#ifndef USE_ADAFRUIT_SHIELD_PINOUT
  
    #ifdef AVR
        // &quot;Variable declaration for AVR goes here&quot;

    #elif defined SAM
       //&quot;Variable declaration for SAM goes here&quot;

    /*else block, in case ESP32 is not the correct macro name*/
    #else
      //&quot;General Variables for everything else other than SAM or AVR.&quot;
    #endif
  
//in case the ADA SHIELD PINOUT is defined
#else
//&quot;General Variables for when USE_ADAFRUIT_SHIELD_PINOUT is defined.&quot;

#endif
</code></pre>
<p>This should fix the &quot;variable not declared&quot; error. You can explore or ask in <a href=""https://arduino.stackexchange.com"">https://arduino.stackexchange.com</a> the right way to customise this header for the ESP32 env.</p>
",,,
52393430,2,52389255,2018-09-18T19:30:00.213,1,,2435820,,2018-09-18T19:30:00.213,,1,,"<p>The answer 0.0.0.0 is the correct one.</p>

<p>More precisely, when you open a server socket, it does not have a specific, well-defined address. Therefore if you ask any system calls to ""find the local address this socket is listening to"" they will return the wildcard address 0.0.0.0.
Furthermore, you can connect to the server using many different destination addresses: for example ""127.0.0.1"", ""127.1.2.3"", ""192.168.40.21"" (the address of your network interface), etc.</p>

<p>If you want to listen to a specific address, you need to pass that address to <code>bind()</code>. For example, this code listens to a specific local address 127.1.2.3:</p>

<pre><code>server_address.sin_family = AF_INET;
server_address.sin_addr.s_addr = inet_addr(""127.1.2.3"");
server_address.sin_port = htons(PORT);
if (bind(server_file_descriptor, (struct sockaddr *)&amp;server_address, sizeof(server_address)))
   ...
</code></pre>

<p>Output:</p>

<blockquote>
  <p>3 - Server runs on IP: 127.1.2.3, port: 5000</p>
</blockquote>

<p>The problem is that connections to ""127.0.0.1"", ""192.168.40.21"" and all of the other addresses are now going to fail, since you have restricted the server to be reachable only on a specific address.</p>

<p>However, there is a thing that does have a well-defined address in your initial example. It is the client socket created after the connection is accepted. If you add this code after the <code>accept()</code> call, you will see the address the client has connected to:</p>

<pre><code>    struct sockaddr_in addr;
    socklen_t len;
    len = sizeof(addr);
    getsockname(new_connection, (struct sockaddr *)&amp;addr, &amp;len);
    printf(""Client connected to: %s, port: %d\n\n"", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));
</code></pre>

<p>This address may be different for different clients: i.e. one client may connect to ""127.0.0.1"", another to ""192.168.40.21"". </p>
",,,
52473594,2,52399011,2018-09-24T06:16:03.987,0,,9664369,,2018-09-24T06:16:03.987,,0,,"<p>So this is the correct code that worked for me:</p>

<pre><code>void loop() {

 Wire.requestFrom(I2C_ESP_ADDRESS,18);
 while (Wire.available()){



 incoming = Wire.read();
Serial.print(incoming);
 //Serial.print(incoming);

 //sprintf (incomingArray, ""%.20"", incoming);

  if ( incoming == 'e') {
    modelArray[0] = 'e';


    for (int i = 1; i &lt; 18; i++ ){
      modelArray[i] = (char) Wire.read();
      Serial.print(modelArray[i-1]);
    }
  } 



    if ( incoming == 'a') {
    readingArray[0] = 'a';
   // Serial.print(""Got Reading: "");

    for (int j = 1; j &lt; 18; j++ ){
      readingArray[j] = (char) Wire.read();
      Serial.print(readingArray[j-1]);
    }

    Serial.println();

    }


}
</code></pre>
",,,
52544588,2,52449688,2018-09-27T20:21:59.093,0,,5823275,,2018-09-27T20:34:22.120,2018-09-27T20:34:22.120,0,,"<p>I've had the same problem and found a solution <a href=""http://www.raspberrypi-tutorials.de/software/wiringpi-auf-dem-raspberry-pi-installieren.html"" rel=""nofollow noreferrer"">here</a> (in German). Basically, the tutorial states to clone the <code>wiringPi.h</code> from git and build it.</p>

<p>Hint: It is not the fault of VisualStudio (see my comment below the answer of Huseyin Meric Yigit), but it is a missing library on the Raspberry Pi.</p>

<p>The commands I typed in the console of the RasPi were (please adapt the paths to your needs):</p>

<pre><code>cd /home/pi
mkdir lib
chmod 0777 lib
cd lib
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install git-core
git clone git://git.drogon.net/wiringPi
git pull origin
./build
</code></pre>

<p>Plan to have a coffee while executing the command on line 6 (upgrade). After it is finished, I could successfully compile the project in VisualStudio. Hope, this helps you, too.</p>
",,,
52456761,2,52456566,2018-09-22T12:41:21.330,0,,10223751,,2018-09-22T16:28:37.347,2018-09-22T16:28:37.347,2,,"<p>Unfortunately, you didn't specify the exact µC you are using. I just used the ATMEGA32 as a reference. Hopefully, your AVR has the same configuration.</p>

<p>ATMEGA32 also has an SPI interface on Port B.  You rely on the reset value of the DDRB-Register (which is zero). It would be nice to explicitly set all the desired values for your pin configuration. From the ATMEGA's datasheet it seems that you did not initialize the pins correctly. Only PB7 and PB5 of the SPI interface need to be set to output. In your intialization you set PB4, PB6 and PB7 to output. You mixed <strong>MISO</strong> and <strong>MOSI</strong>. </p>

<p>Here my initialization routine:</p>

<pre><code>/* 
SPI pin configuration:
PB7: SCK         Output
PB6: MISO        Input
PB5: MOSI        Output
PB4: Chip select Output
*/
void SPI_MasterInit(void){
  DDRB = 0x00;
  DDRB |= ((1 &lt;&lt; DDB2) | (1 &lt;&lt; DDB5) | (1 &lt;&lt; DDB7));
  PORTB |= (1&lt;&lt;PB2);
  /* Enable SPI, Master, set clock rate fck/16 */
  SPCR = (1&lt;&lt;SPE)|(1&lt;&lt;MSTR)|(1&lt;&lt;SPR0);
}
</code></pre>

<p>You also need to check the following:</p>

<ul>
<li>Does the display support your chosen SPI frequency?</li>
<li>What should the state of SCK be during IDLE?</li>
<li>When should SPI data be sampled? During the rising or the falling edge of SCK.</li>
<li>Is the CS set according to the timing diagram in the OLED display's data sheet?</li>
</ul>

<p>If you took care of all those things, please come back with a short feedback. I hope this answer gives you some guidelines how to proceed.</p>
",,,
52466052,2,52456566,2018-09-23T12:21:58.150,1,,4931630,,2018-09-25T07:38:16.463,2018-09-25T07:38:16.463,0,,"<p><strong>First.</strong> When you're using SPI on AVR ATmega in the master mode, the SS pin, although it is not used directly by the SPI module, should be <em>always</em> configured as output, otherwise, high level on the pin will switch the SPI module into the slave mode. In other words, if you're using, for example, ATmega328(P), the PB2 should be configured as output (DD2 bit in DDRB should be set). It is a good idea to connect CS# of SSD1306 to this pin.</p>

<p><strong>Second</strong>.
When connecting SSD1306 there are 4 lines should be connected (see page 17 of the <a href=""https://cdn.sparkfun.com/assets/learn_tutorials/3/0/8/SSD1306.pdf"" rel=""nofollow noreferrer"">datasheet</a>):
1) SCLK - serial clock - connect it to the SCK pin of the SPI port (e.g. PB5 for ATmega328)
2) SDAT - serial data - connect it to the MOSI pin (PB3)
3) CS# - chip select - connect it to the SS pin (PB2)
4) D/#C - data/command select - connect it to any free pin (as I suppose you have connected it to PB0)
Also the modules may have RESET input, I think you have it connected to the PB1.</p>

<p>So, sending a data or command byte to the SSD1306 should look like this:</p>

<pre><code>PORTB &amp;= ~(1 &lt;&lt; CS); // pulling the CS# line low
PORTB |= (1 &lt;&lt; D_C); // high for DATA
or
PORTB &amp;= ~(1 &lt;&lt; D_C); // low for COMMAND
SPDR = cData; // transmit the byte
while(!(SPSR &amp; (1&lt;&lt;SPIF))) {} // wait the transmission to complete
PORTB |= (1 &lt;&lt; CS); // pull the CS# line back high
</code></pre>

<p>CS# can be held low through several commands, without rising up. It helps to determine edges of the command.</p>

<p><strong>Third</strong>.
Command 0xAF will turn the display on but probably it will show nothing because there is no data in it, so you may see no difference.
Try to send command 0xA5 just after that, it will light up all the pixels - just for the test purposes.</p>

<p><strong>UPD</strong>
Also, there you have to turn on the DC-DC charge pump (see the application note, page 62 at the end of the <a href=""https://cdn.sparkfun.com/assets/learn_tutorials/3/0/8/SSD1306.pdf"" rel=""nofollow noreferrer"">datasheet</a>). It is done by a sequence of two command bytes 0x8D 0x14. Send it before the turining the display on (i.e. before 0xAF)</p>
",,,
52515308,2,52514784,2018-09-26T10:13:35.450,0,,9502067,,2018-09-26T10:54:10.827,2018-09-26T10:54:10.827,2,,"<p>Father and child processes do run concurrently, and it is not predictable which process is running at what time.</p>

<p>From a first inspection you have a loop that starts from the father process and creates 8 child processes, that on their hand each creates other child processes! You should terminate the child process after calling the function2, otherwise the child processes will create other processes.</p>

<p>I think the solution to your problem is something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

void function1() {
    //0.5 seconds sleep
    usleep(500000);
}

void function2(int n) {
    for(int i = 0; i &lt;= 8; i++)  {
        function1();
        printf(""LED(%d,%d)\n"", n, i);
    }
}
int main()
{
    pid_t pid;
    for(int num = 0; num &lt;= 7; num++) {
        pid = fork(); 
        if (pid == 0) {
            function2(num);
            exit(0);
        }
    }
    for (int num = 0; num &lt;= 7; num++){
        wait(NULL);
    }
    return 0;
}
</code></pre>

<p>Please for future questions please post a <a href=""https://stackoverflow.com/help/mcve"" title=""Minimal, Complete, and Verifiable example"">Minimal, Complete, and Verifiable example</a>.</p>

<p>The code could also have a concurrency problem, I don't think the <code>printf</code> is an atomic function, so a semaphore may be necessary to avoid having multiple processes calling the <code>printf</code>.</p>

<p>Another note is that a check should be <code>fork()</code> to check if the child process was successfully generated.</p>
",,,
52533092,2,52518638,2018-09-27T08:54:39.297,0,,1790864,,2018-09-27T08:54:39.297,,3,,"<p>A shared received buffer is NOT your problem. The problem occurs, because the execution time of </p>

<pre><code>printf(""**GOT** %d carattere %c \n"",z,data);
</code></pre>

<p>blocks the code for too long, while the rest of the string is being sent by the terminal. The XMEGA receive buffer consists of a two-level FIFO. </p>

<p>Lets take a look at the case where you tried to send ""fail"".</p>

<pre><code>while((data!='\r')){

    // This blocks until the first char 'f' is received, which is OK.
    while( !(USARTC1_STATUS &amp; USART_RXCIF_bm) );

    // At this point, 'f' is located in the DATA buffer.
    // The reception of the next char 'a' immediately starts next and is handled
    // by the UART receiver hardware.
    data = USARTC1_DATA; //Temporarly store received data

    // You just cleared the DATA buffer by reading it, so there is room for 'a'
    // after it has been received completely.

    // printf() blocks the code for a very long time
    printf(""**GOT** %d carattere %c \n"",z,data);

    // While you sent data using printf(), the terminal program sent the remaining
    // characters 'i' and 'l'. However, because DATA was already holding 'a' and
    // it wasn't cleared in between, the other chars got lost.

    line[z] = data;
    z++;

}
</code></pre>

<p>I hope this makes it clear.</p>
",,,
52554826,2,52553466,2018-09-28T11:56:42.997,0,,5271927,,2018-09-28T11:56:42.997,,0,,"<p>It's not really custom type, it's just <code>typedef uint8_t DeviceAddress[8];</code> and arrays can't be copy constructed unlike classes.</p>

<p>Basically you have two simple ways to do it:</p>

<pre><code>// #1
DeviceAddress test[] = { { 0x28, 0xCA, 0x98, 0xCF, 0x05, 0x0, 0x0, 0x51 }, { 0x28, 0xC4, 0xA8, 0xCF, 0x05, 0x0, 0x0, 0xC6 } };
// and eventually you can define:
DeviceAddress  *waterTempSensorAddress = test;
DeviceAddress  *heatWaterSystemTemSensorAddress = test + 1; 
</code></pre>

<p>But it's not so nice.  </p>

<p>Another way is using pointers:</p>

<pre><code>// #2
DeviceAddress waterTempSensorAddress = { 0x28, 0xCA, 0x98, 0xCF, 0x05, 0x0, 0x0, 0x51 };
DeviceAddress heatWaterSystemTemSensorAddress   = { 0x28, 0xC4, 0xA8, 0xCF, 0x05, 0x0, 0x0, 0xC6 };
DeviceAddress * test2[] = { &amp;waterTempSensorAddress, &amp;heatWaterSystemTemSensorAddress };
</code></pre>

<p>The first one is easier to use, second one is little bit less readable:</p>

<pre><code>void da(DeviceAddress const&amp; addr) { /*  ....  */ }

void something() {
  da(test[0]);  // #1

  da(*(test2[0])); // #2 
  da(test2[0][0]); // #2 (it's basically two dimensional array of DeviceAddress)
}
</code></pre>

<p>Anyway, it's all about the C++ basics.</p>

<p>Little bit harder way is to use container class.</p>
",,,
52560467,2,52553508,2018-09-28T17:52:15.540,0,,6271889,,2020-07-21T17:39:48.753,2020-07-21T17:39:48.753,0,,"<p>If you think about it, there are 256 possible combinations, but you're only interested in 8 fans, so all that you need to check is 8 bits:</p>
<pre><code>#include &lt;stdio.h&gt;

#define STATE_ON    0x01
#define STATE_OFF    0x00

void enable_relay(unsigned char relay, unsigned char state)
{
    /* This is a brute force approach that enables any relay/port combination:
     * relay 8: PB2
     * relay 7: PB4
     * (...)
     * relay 1: PA1
     */

    switch(relay)
    {
        case 8:
            if(state == STATE_ON)
                GPIOB-&gt;ODR |= 0x0004;
            else
                GPIOB-&gt;ODR &amp;= ~0x0004;
            break;
        case 7:
            if(state == STATE_ON)
                GPIOB-&gt;ODR |= 0x0010;
            else
                GPIOB-&gt;ODR &amp;= ~0x0010;
            break;
        case 1:
            if(state == STATE_ON)
                GPIOA-&gt;ODR |= 0x0002;
            else
                GPIOA-&gt;ODR &amp;= ~0x0002;
            break;
    }

}

void check_relay(unsigned char fan_map)
{
int i;
unsigned char bit;
unsigned char state;

    for(i=0; i &lt; 8; i++) {
        bit = (fan_map&amp;(0x01&lt;&lt;i));
        state = ((bit != 0)? STATE_ON : STATE_OFF);
        enable_relay( (8-i), state);
    }
}

int main(void)
{
    unsigned char fan_map = 0x0B; /* 0x0B = 00001011 */
    check_relay(fan_map);
}
</code></pre>
<p>You need the <code>8-i</code> part as your bit order is in reverse (fan1 as the leftmost bit) with the value order (MSB is the leftmost bit).</p>
",,,
55620319,2,52572703,2019-04-10T19:50:52.793,1,,4843677,,2019-04-10T19:50:52.793,,6,,"<p>After a few tries I got esp_bt_gap_read_rssi_delta() to work.</p>

<p>First thing to understand (in case you have not got it yet) is the callback/event thing. A callback function is a function in your code that will be called by the ESP-IDF when something special (an event) happens. You register your callback function by calling esp_bt_gap_register_callback() after initializing the bluetooth stack.</p>

<p>When you call esp_bt_gap_read_rssi_delta() (after connecting to the device), it returns immediately with an Ok or error status. The actual RSSI reading will be returned later by the framework calling your callback function.</p>

<p>The callback function has two parameters. The first identifies the event that happened, the second the data associated to the event. This second parameter is a pointer to one of the structures defined in the esp_bt_gap_cb_param_t union.</p>

<p>Here is some skeleton code (not testing return codes, etc) for the Arduino IDE, using the BluetoothSerial for the connection:</p>

<pre><code>#include ""esp_gap_bt_api.h""
#include ""BluetoothSerial.h""

BluetoothSerial SerialBT;
byte addr[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

void setup() {
  Serial.begin (115200);
  SerialBT.begin();
  esp_bt_gap_register_callback (gap_callback);
}

void loop() {
  delay(100);
  if (SerialBT.hasClient()) {
    esp_bt_gap_read_rssi_delta (addr);
    delay (10000);    
  }
}

void gap_callback (esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param) {
  if (event == ESP_BT_GAP_READ_RSSI_DELTA_EVT) {
    Serial.println (param-&gt;read_rssi_delta.rssi_delta);
  }
}
</code></pre>
",,,
55756518,2,52572703,2019-04-19T04:13:24.303,0,,10434825,,2019-04-19T04:13:24.303,,0,,"<p>So the final solution of my question (thanks to @dquadros) is:  </p>

<pre><code>//ESP32, Classic Bluetooth, SPP
#include ""BluetoothSerial.h""
#include ""esp_gap_bt_api.h""
#include &lt;esp_spp_api.h&gt;

BluetoothSerial SerialBT;
byte rssi; //RSSI
byte addr[6] = {0,0,0,0,0,0}; //to keep MAC address of the remote device

//RSSI callback function
void gap_callback (esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)
{
  if (event == ESP_BT_GAP_READ_RSSI_DELTA_EVT) rssi = param-&gt;read_rssi_delta.rssi_delta;
}

//SPP service callback function (to get remote MAC address)
void spp_callback (esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
{
  if (event == ESP_SPP_SRV_OPEN_EVT) memcpy(addr, param-&gt;srv_open.rem_bda, 6);
}

void setup()
{
  Serial.begin(9600);
  SerialBT.begin(""ESP32"");
  //register RSSI callback function:
  esp_bt_gap_register_callback (gap_callback);
  //register SPP service callback to get remote address:
  SerialBT.register_callback(spp_callback);
}

void loop()
{
  //when we need RSSI call this:
  esp_bt_gap_read_rssi_delta (addr); //now variable rssi contains RSSI level
  byte b = rssi; //etc....
}
</code></pre>
",,,
52586408,2,52580643,2018-10-01T07:31:07.597,1,,2205264,,2018-10-01T07:31:07.597,,0,,"<p>As @Azeem mentioned, you're redefining the SSID to an empty value. Using preprocessor like this, you must first check if the value exist and if not, assign it a default value.</p>

<p>Here is a simple C++ example:</p>

<pre><code>#include &lt;iostream&gt;

#ifndef SSID
#define SSID ""(SSID not defined)""
#endif

int main() 
{
    std::cout &lt;&lt; ""SSID value: "" &lt;&lt; SSID &lt;&lt; std::endl;
    return 0;

}
</code></pre>

<p>You can compile and run the code with:</p>

<pre><code>g++ main.cpp -o main &amp;&amp; ./main
</code></pre>

<p>As you see it prints <code>(SSID not defined)</code>.</p>

<p>Now, compiling and running with the following:</p>

<pre><code>g++ main.cpp -o main -DSSID='""Hello, World!""' &amp;&amp; ./main
</code></pre>

<p>will output: <code>SSID value: Hello, World!</code></p>

<p>If you want to learn more about preprocessor directives, <a href=""http://www.cplusplus.com/doc/tutorial/preprocessor/"" rel=""nofollow noreferrer"">cplusplus.com has very nice tutorial</a></p>

<p>Also, don't forget to start your <code>Serial</code> in <code>void setup()</code>.</p>
",,,
52588944,2,52588676,2018-10-01T10:14:55.357,3,,9072753,,2018-10-01T10:23:50.840,2018-10-01T10:23:50.840,0,,"<pre><code>void un_a();
</code></pre>

<p>This is a <a href=""https://en.cppreference.com/w/c/language/function_declaration"" rel=""nofollow noreferrer"">function declaration</a>. It tells, that such symbol <code>un_a</code> exists, and it is a function of type <code>void (*)()</code>.<br>
If you want to call a function, you use a <a href=""https://en.cppreference.com/w/c/language/statements"" rel=""nofollow noreferrer"">expresssion statement</a>. Notice it does not have a returned type on the beginning as in a declaration:</p>

<pre><code>int a; // declaration
a = 1; // statement
un_a(); // statement, this executed the un_a function
1 + 1; // another statement, this adds 1 + 1
int func(int b); // declaration, this does nothing, just the compiler knows that a function `func` exists
int (*(*func2)(int a, int (*(*)(int arr[a]))[a]))[5]; // another declaration
(void)func2(5, (int (* (*)(int *))[5])0); // statement
</code></pre>

<p>Try calling the functions:</p>

<pre><code>void wave(){
  un_a();
  delay(2000);
  deux_a();
  delay(2000);
  trois_a();
}
</code></pre>
",,,
52653258,2,52629993,2018-10-04T18:43:05.357,0,,669576,,2018-10-04T18:43:05.357,,4,,"<p>A couple ideas that may help.</p>

<p>The display is 128 pixels, so you need a buffer no larger than that. I suggest you make that a single, global buffer (instead of each struct having its own buffer). This will never need to be re-sized with <code>new/delete</code>, no matter how many graphs you have.</p>

<pre><code>uint8_t global_graph_buffer[128];
</code></pre>

<p>Notice that I have changed it from <code>int</code> to <code>byte</code>. The height of the display is only 30 or 40 pixels (?) so there's no need to store any number bigger than that. Just scale the value down when it comes in on the port.</p>

<pre><code>graph_buffer[x] = map(incoming_data, 0, max_input, 0, height_of_graph);
</code></pre>

<p>See the Arduino <a href=""https://www.arduino.cc/reference/en/language/functions/math/map/"" rel=""nofollow noreferrer""><code>map()</code></a> function.</p>

<p>Next, do you really need the y_pos and height of the graphs? Do you plan on having more than 1 row of graphs? If not, get rid of those struct members. Also, you can get rid of the x_pos and width fields as well. These can be calculated based on the indexes.</p>

<pre><code>struct graphStruct {
  uint8_t gx;  // Removed
  uint8_t gy;  // Removed
  uint8_t gw;  // Removed
  uint8_t gh;  // Removed
  int gVal;              // What is this for?
  //int graphBuffer[graphBufferSize]; This is gone
  uint8_t start_index;   // First index in the global array
  uint8_t end_index;     // Last index
  bool isReady;          // What is this for?
};
</code></pre>

<p>To calc x_pos and width:</p>

<pre><code>x_pos = start_index
width = end_index - start_index
</code></pre>

<p>To handle incoming data, shift just the part of the buffer for the given graph and add the value:</p>

<pre><code>int incoming_data = some_value_from_serial;
// Shift
for (byte i = graph[graphNumber].start_index+1; i &lt; graph[graphNumber].end_index; i++) {
    global_graph_buffer[i] = global_graph_buffer[i-1]
 }
// Store
global_graph_buffer[i] = map(incoming_data, 0, graphMax, 0, 128);
</code></pre>

<p>Lastly, you need to consider: how many graphs can you realistically display at one time? Set a max, and create only that many structs at the start. If you use a global buffer, as I suggest, you can re-use a struct multiple times (without having to use <code>new/delete</code>). Just change the <code>start_index</code> and <code>end_index</code> fields.</p>

<p>Not sure if any of this helps, but maybe you can get some ideas from it.</p>
",,,
52673619,2,52670521,2018-10-05T21:42:55.533,6,,119527,,2018-10-05T21:54:50.180,2018-10-05T21:54:50.180,1,,"<p>That chip looks like a fairly typical <a href=""https://en.wikipedia.org/wiki/Super_I/O"" rel=""noreferrer""><em>Super I/O</em> controller</a>, which is basically the hub where all of the ""slow"" peripherals are combined into a single chipset.</p>

<p>Coreboot has a wiki page that talks about <a href=""https://www.coreboot.org/Developer_Manual/Super_IO"" rel=""noreferrer"">how to access the super I/O</a>.</p>

<hr>

<p>On the PC architecture, <em>Port I/O</em> is accomplished using special CPU instructions, namely <code>in</code> and <code>out</code>. These are privileged instructions, which can only be used from a kernel-mode driver (Ring 0), or a userspace process which has been given I/O privileges.</p>

<p>Luckily, this is easy in Linux. Check out the <a href=""http://man7.org/linux/man-pages/man2/outb.2.html"" rel=""noreferrer"">man page for <code>outb</code> and friends</a>.</p>

<blockquote>
  <p>You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I/O ports in question.  Failure to do this will cause the application to receive a segmentation fault.</p>
</blockquote>

<p>So we could adapt your function into a Linux environment like this:</p>

<pre><code>/* Untested: Use at your own risk! */
#include &lt;sys/io.h&gt;
#include &lt;stdio.h&gt;

#define ReadByte(port)          inb(port)
#define WriteByte(port, val)    outb(val, port)

int main(void)
{
    if (iopl(3) &lt; 0) {
        fprintf(stderr, ""Failed to get I/O privileges (are you root?)\n"");
        return 2;
    }


    /* Your code using ReadByte / WriteByte here */
}
</code></pre>

<h1>Warning</h1>

<p>You should be very careful when using this method to talk directly to the Super IO, because your operating system almost certainly has device drivers that are <em>also</em> talking to the chip.</p>

<p>The <em>right</em> way to accomplish this is to write a device driver that properly coordinates with other kernel code to avoid concurrent access to the device.</p>

<p>The Linux kernel provides GPIO access to at least some Super I/O devices; it should be straightforward to port one of these to your platform. See <a href=""https://lwn.net/Articles/487166/"" rel=""noreferrer"">this pull request for the IT87xx chipset</a>.</p>
",,,
52689605,2,52689172,2018-10-07T14:45:18.987,0,,6755083,,2018-10-08T09:24:43.327,2018-10-08T09:24:43.327,3,,"<p>Try this snippet:</p>

<pre><code>    #define signalToRelayPin              12
    #define sensorPin                      7

    int lastSoundValue;
    int soundValue;
    long lastNoiseTime = 0;
    long currentNoiseTime = 0;
    long lastLightChange = 0;
    int relayStatus = HIGH;
    int clap_interval = 500;
    int claps = 0;

    void setup() {
       pinMode(sensorPin, INPUT);
       pinMode(signalToRelayPin, OUTPUT);
       Serial.begin(115200);
    }

    struct DataBlockStruct  meting1,meting2;



void loop() {

    soundValue = digitalRead(sensorPin);
    currentNoiseTime = millis();

    if (soundValue == 1 &amp;&amp; lastSoundValue == 0) 
    { 
        if (claps == 0) // allow first to register without much condition
        {
            claps = 1;
            lastNoiseTime = currentNoiseTime;
        }
        else
        {
            if (currentNoiseTime &gt; lastNoiseTime + clap_interval)
            {
                claps++;
                lastNoiseTime = currentNoiseTime;
                            relayStatus = !relayStatus;
            }
        }           
    }
    else
    {
        if (currentNoiseTime &gt; lastNoiseTime + 2 * clap_interval) // no claps for a longer duration time to print and/or reset clap
        {
            if (claps &gt; 0)
            {
                Serial.print(claps);
                Serial.println("" CLAPS"");
                claps = 0; ///reset
            }
        }
    }

    //lastSoundValue = soundValue;
    delay(50); // delay polling
}
</code></pre>
",,,
52710028,2,52709911,2018-10-08T20:59:28.837,1,,2630032,,2018-10-09T08:42:10.697,2018-10-09T08:42:10.697,4,,"<p>For comparing strings like intended by <code>if (data == ""t"")</code>, you'll need a string comparison function like, for example, <code>strcmp</code>. For this to work, you must ensure that the arguments are actually (0-terminated) C-strings:</p>

<pre><code>uint8_t data[9];
uint8_t size = dma_serial1.get(data, 8);
data[size]='\0';
if (strcmp(data,""t"")==0) {
   ...
}
</code></pre>

<p>In case that the default character type in your environment is <code>signed char</code>, to pass <code>data</code> directly to string functions, a cast is needed from unsigned to signed:</p>

<pre><code>if (strcmp(reinterpret_cast&lt;const char*&gt;(data),""t"")==0) {
   ...
}
</code></pre>

<p>So a complete MVCE could look as follows:</p>

<pre><code>int get(uint8_t *data, int size) {
    data[0] = 't';
    return 1;
}

int main()
{
    uint8_t data[9];
    uint8_t size = get(data, 8);
    data[size]='\0';
    if (strcmp(reinterpret_cast&lt;const char*&gt;(data),""t"")==0) {
        cout &lt;&lt; ""found 't'"" &lt;&lt; endl;
    }
}
</code></pre>

<p>Output:</p>

<pre><code>found 't'
</code></pre>
",,,
52722146,2,52721674,2018-10-09T13:22:11.513,0,,898348,,2018-10-09T13:22:11.513,,0,,"<p>Maybe something like this:</p>

<pre><code>  byte *concatbytes(const byte *source, byte *destination, int length)
  {
    for (int i = 0; i &lt; length; i++)
    {
      *destination++ = *source++;
    }

    return destination;
  }

  ...

  byte MessageStart[] = { 0x02 };
  byte Next[] = { 0x5C , 0x73 };
  byte messgae[] = { 0x30 , 0x35 };
  byte BeforeEnd[] = { 0x5C , 0x3B };
  byte MessageEnd[] = { 0x03 };

  byte Final[8];       // 8 is the hardcoded length of sum of all 5 arrays

  byte *dest = Final;    
  dest = concatbytes(dest, MessageStart, sizeof(MessageStart));
  dest = concatbytes(dest, Next, sizeof(Next));
  dest = concatbytes(dest, messgae, sizeof(messgae));
  dest = concatbytes(dest, BeforeEnd, sizeof(BeforeEnd));
  dest = concatbytes(dest, MessageEnd, sizeof(Next));
</code></pre>

<p>The <code>Final</code> array may be obtained differently, for example by dynamic memory allocation. This is left as an exercise for the reader.</p>
",,,
52788720,2,52751103,2018-10-13T01:26:01.747,0,,2980966,,2018-10-14T01:24:40.567,2018-10-14T01:24:40.567,0,,"<p>A huge thanks to Jonathan Potter and Remy Lebeau for providing a working answer in the comments. I carried out your suggestions/answers and everything worked. I did not touch the Arduino code, and made the following changes in the CPP code:</p>

<p>In the CPP code in the question remove everything from (and including) <code>char buffer [20000] = {};</code> and replace it with:</p>

<pre><code>//***********receive the results**************************
//initialize a string
std::string totalResults;

//create a temp array. This will hold a single line recieved from
//the arduino.
char tempBuffer [300] = {};

//the number of lines I want to recieve from the arduino
int magicNumber = 100;

//recieve the arduino response
for(int i = 0; i &lt; magicNumber ; i++)
{
    //call the recv method over and over as it gets a single arduino line with
    //every iteration.
    if( recv(my_socket, tempBuffer , sizeof(tempBuffer) , 0) &lt; 0)
    {
    std::cout &lt;&lt; ""recv failed"" &lt;&lt; std::endl;
    }

    //write out the single line we recieved to a string (which grows on the fly)
    for(int i = 0; i &lt; 300; i++ )
    {
        totalResults = totalResults+tempBuffer[i];

        //kill the loop the moment there is a null character. When i created the
        //array i initialized it with NULL characters. so if I am seeing a null
        //character it means that the data I recieved from the arduino has all been
        //given to the string.
        if(tempBuffer[i] == NULL)
        {
            break;
        }
    }

    //empty array - see: https://stackoverflow.com/questions/632846/clearing-a-char-array-c
    std::fill(&amp;tempBuffer[0], &amp;tempBuffer[300], 0);

}

//print the results to the standard output.
std::cout &lt;&lt; totalResults &lt;&lt; std::endl;
</code></pre>

<p>These changes (which I am sure can be critiqued from here to the moon and back) allowed me to get the data the arduino was sending without missing a single ASCII character. Thanks!</p>

<p><a href=""https://i.stack.imgur.com/B3aXL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B3aXL.png"" alt=""enter image description here""></a> </p>

<p>On a separate note, thank you to David Schwartz and Remy Lebeau for pointing out that the HTTP protocol I was using is pretty bad. I used the HTTP as I knew it was a working example in the Arduino code; and now the objective is to remove the HTML and to find a more efficient way to pass the values to the cpp code (using only sockets). Thank you very much for your comments!</p>

<p>****EDIT****</p>

<p>OK, so if you are still reading this, you must be passing some information from an Arduino to a cpp program using Ethernet. If so read on. After I was guided on how to receive the full Arduino response, I removed all the HTML and HTTP, and simply sent the values I needed from the Arduino with letter padding (ex: Aint1B, Cint2D, Efloat1F, etc...). I marked the end of transmission from the Arduino with <code>~~~</code> characters. Cool. But, for some reason sometimes I would get the entire Arduino response, and sometimes it would be missing some amount of the tail of the message. Here is what I learned:</p>

<ol>
<li>The location (memory or system call I have no idea) that the recv reads from, can sometimes have only one char value.</li>
<li>sometimes the <code>\n</code> characters is all a recv fetches!</li>
<li>sometimes the location that the recv reads from can have multiple values! There were times when the recv method returned 6 characters, and there were times when it returned only 4. This behavior seemed unpredictable.</li>
</ol>

<p>Taking this behavior into account I modified my cpp code. This code receives the entire message, and when it does, the additional needless looping of the recv method is stopped. Hope you find it useful:</p>

<pre><code>//***********receive the results**************************
//initialize a string
std::string totalResults = """";

//create a temp array. This will hold a single line recieved from
//the arduino.
char tempBuffer [300] = {};

//the number of lines I want to receive from the Arduino. This is an unusual
//value for the following reasons (figured out via println):
//(1) sometimes the buffer where the recv method reads from has only one value.
//    ex: letter A only (as per my,*ahem"", ""protocol"".
//(2) sometimes the \n is all a recv fetches!
//(3) sometimes the buffer where the recv method reads has multiple values, so
//    the recv fetches many items that get unpacked in the second loop. This is
//    why sometimes we increase the value by only 1, but get WAY more values. I
//    observed this behaviour to be non repeating. Sometimes it reads 5 values,
//    and sometimes it reads only 3 values.
// At a value of 60 I am always getting the message, and run the recv command
// unnecesserily. For this reason I have implemented the ""end transmission""
// characters (~~~), which allow me to kill the for loop once the full message is
// retrieved.
int numberOfTimesRecvRuns = 60;

//number of characters per line. do not reduce as it is needed to be this size to
// get the full insult if the protocol is not followed.
int arduinoNumberOfCharsPerLine = 50;

bool fullResponseRecieved = false;

//recieve the entire arduino response. The magic number is the number of times
// we call the recv method (which reads a line from the socket).
for(int i = 0; i &lt; numberOfTimesRecvRuns; i++)
{
    //call the recv method over and over as it gets a single arduino line with
    //every iteration.
    if( recv(my_socket, tempBuffer , sizeof(tempBuffer) , 0) &lt; 0)
    {
    std::cout &lt;&lt; ""recv failed"" &lt;&lt; std::endl;
    }

    //write out the single line we recieved to a string (which grows on the fly). 300 because
    //i dont believe I will have more than 300 characters per line.
    for(int j = 0; j &lt; arduinoNumberOfCharsPerLine; j++ )
    {
        totalResults = totalResults+tempBuffer[j];
        std::cout &lt;&lt; ""i: "" &lt;&lt; j &lt;&lt; "" value recv read: "" &lt;&lt; tempBuffer[j]&lt;&lt; std::endl;

        //kill the loop the moment there is a null character. When i created the
        //array i initialized it with NULL characters. so if I am seeing a null
        //character it means that the data I recieved from the arduino has all been
        //given to the string.
        if(tempBuffer[j] == NULL )
        {
            std::cout &lt;&lt; ""I ran... See ya"" &lt;&lt; std::endl;
            break;
        }

        //end of transmission detected
        if(tempBuffer[j] == '~')
        {
            fullResponseRecieved = true;
        }
    }

    //empty array - see: https://stackoverflow.com/questions/632846/clearing-a-char-array-c
    std::fill(&amp;tempBuffer[0], &amp;tempBuffer[300], 0);

    // A '~' character means the full message has been recieved and there is no
    // need to keep looping for the purpose of running the recv method.
    if(fullResponseRecieved == true)
    {
        //reset the value
        fullResponseRecieved = false;
        std::cout &lt;&lt; ""killing recv loop"" &lt;&lt; std::endl;
        break;
    }

}

//print the results to the standard output.
std::cout &lt;&lt; totalResults &lt;&lt; std::endl;

return 0;
</code></pre>
",,,
52764847,2,52764806,2018-10-11T16:25:41.810,1,,2602718,,2018-10-11T16:25:41.810,,4,,"<p>If you want to validate user input and only allow 'a'-'z' or 'A'-'Z', you can do:</p>

<pre><code>char some_user_val
if(('a' &lt;= some_user_val &amp;&amp; some_user_val &lt;= 'z') || 
   ('A' &lt;= some_user_val &amp;&amp; some_user_val &lt;= 'Z') {
    //Input was validated!!
} else {
    //Bad input
}
</code></pre>
",,,
52764963,2,52764806,2018-10-11T16:32:21.530,0,,5650263,,2018-10-11T17:08:38.593,2018-10-11T17:08:38.593,6,,"<p><strong>This answer would not work, check comments.</strong></p>

<p><del>Would it not be possible to check this value after its already entered? You could do something like this, albeit with a more elegant execution.</del></p>

<pre><code>char value;
void setup() 
{ 
    Serial.begin(9600); 
    value = 'a';
}
void loop()
{ 
      Serial.println(value);
      delay(1000);
      if (Serial.available() &gt; 0 &amp;&amp; Serial.read().isalpha() != 0;) 
     { 
          value = Serial.read();
          Serial.println(value); 
     }
}
</code></pre>
",,,
52782004,2,52781387,2018-10-12T14:46:39.660,0,,669576,,2018-10-12T14:46:39.660,,0,,"<p>In this line:</p>

<pre><code>int insideThermometer = (int)insideThermometer;
</code></pre>

<p>You create a local variable and assign it to itself. Not what you wanted. The global var you are trying to use is </p>

<pre><code>DeviceAddress insideThermometer = { 0x28,  0xFF,  0x83,  0x51,  0xB2,  0x17,  0x4,  0x8A };
</code></pre>

<p>If you look at the <a href=""https://github.com/milesburton/Arduino-Temperature-Control-Library"" rel=""nofollow noreferrer"">source code</a>, <code>DeviceAddress</code> is typdef'd as </p>

<pre><code>typedef uint8_t DeviceAddress[8];
</code></pre>

<p>If you want to get the temperature you need to call <code>sensors.getTempC(insideThermometer)</code>, which you already do in the <code>printTemperature</code> function. Since you call that function before testing the temp, just modify it to return the temp:</p>

<pre><code>float printTemperature(DeviceAddress deviceAddress)
{
  float tempC = sensors.getTempC(deviceAddress);
  float tempF = 0;
  if (tempC == -127.00) {
    Serial.print(""Error getting temperature"");
  } else {
    Serial.print(""C: "");
    Serial.print(tempC);
    Serial.print("" F: "");
    tempF = DallasTemperature::toFahrenheit(tempC);
    Serial.print(tempF);
  }
  return tempF;
}
</code></pre>

<p>Then change to</p>

<pre><code>int insideTempF = printTemperature(insideThermometer);
....
if (insideTempF &gt; mintemp) {
    ....
</code></pre>

<p>(You may want to change the name of the function to something like <code>printAndReturnTemperature</code> as that more clearly states its new functionality.)</p>
",,,
52789041,2,52788897,2018-10-13T02:41:21.783,-1,,10497716,,2018-10-13T11:14:04.163,2018-10-13T11:14:04.163,0,,"<p>problem solved, just need to add a const before the type of the parameter as follows:</p>

<pre><code>boolean isCodeHaveEnd(const boolean (&amp;code)[126]) {
      boolean TCode[18] = { 1 , 1 , 1 , 1 , 1 ,1
                          , 0 , 1 , 0 , 0 , 0 , 0
                          , 0 , 1 , 0 , 0 , 0 , 0} ;
      boolean XCode[18] ;
      for (size_t i = 108; i &lt; 125; i++) {
           XCode[i] = code[i] ;
      }
      return equal(TCode, XCode, 18) ;
 }
</code></pre>
",,,
52858892,2,52840483,2018-10-17T15:49:38.517,1,,436275,,2018-10-17T15:49:38.517,,1,,"<p>Works for me.</p>

<p><a href=""https://i.stack.imgur.com/iOnkz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iOnkz.png"" alt=""enter image description here""></a></p>

<pre><code>#include &lt;cairo.h&gt;

int main()
{
    cairo_surface_t *s = cairo_image_surface_create(CAIRO_FORMAT_RGB24, 150, 50);
    cairo_t *cr = cairo_create(s);

    cairo_set_source_rgb(cr, 1, 0, 0);
    cairo_paint(cr);

    cairo_rectangle(cr, 0, 0, 100, 100);
    cairo_clip(cr);
    cairo_move_to(cr, 50, 25);
    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_show_text(cr, ""pretend that this string is &gt; 100px wide"");

    cairo_destroy(cr);
    cairo_surface_write_to_png(s, ""out.png"");
    cairo_surface_destroy(s);

    return 0;
}
</code></pre>
",,,
52856558,2,52843224,2018-10-17T13:51:29.177,0,,669576,,2018-10-17T13:51:29.177,,1,,"<p>You could add a parameter to the call back, as mentioned in the other answer. Another option is to eliminate the callbacks altogether and use OOP design. Create a wrapper class around an int, with virtual functions for get and set.</p>

<pre><code>class Parameter {
  public:
    Parameter(String n, int default_value = 0) :
        name(n), value(default_value) {}

    // Virtual functions that can be overridden but have default functionality
    virtual int read() {
        return value;
    }
    virtual int write(int new_value) {
        return value = new_value;
    }

    String name;
  protected:
    int value;

    // Below are static functions and variables
    // ----
    // std lib is not supported on Arduino, so use an array 
    // Arduino programs are small enough that you should be
    // able to make an educated guess at MAX_PARAMETERS
    // Also note it is an array of pointers for virtual functions to work
    static Parameter *all_values[MAX_PARAMETERS];
    static int parameter_count;
  public:
    static bool add_param(Parameter *p) {
        if (parameter_count &lt; MAX_PARAMETERS) {
            all_values[parameter_count++] = p;
            return true;
        }
        return false;
    }
    static Parameter * find_param(String name) {
         for (int i = 0; i &lt; parameter_count; i++) {
             if (all_values[i]-&gt;name == name) return all_values[i];
         }
         return nullptr;
    }
};
Parameter * Parameter::all_values[MAX_PARAMETERS];
int Parameter::parameter_count = 0;
</code></pre>

<p>For the i2c parameters, you can extend this class</p>

<pre><code>class Device : public Parameter
{
  protected:
     uint8_t address;
  public:
    Device(std::string n, uint8_t i2c_address) :
        address(i2c_address), Parameter(n) {}

    // Override these
    int read() {
        // Add your code here to read the value from the bus....
        return value;
    }
    int write(int new_value) {
        Parameter::write(new_value);
        // Add your code here to write the value to the bus....
        return value;
    }
};
</code></pre>

<p>To use it you could do something like:</p>

<pre><code>// Create and add regular param
Parameter::add_param(new Parameter(""test1""));
// Create and add i2c device param
Parameter::add_param(new Device(""test2"", 99));

Parameter::find_param(""test1"")-&gt;write(100);
int x = Parameter::find_param(""test1"")-&gt;read();

Parameter::find_param(""test2"")-&gt;write(123);
int y = Parameter::find_param(""test2"")-&gt;read();

// You can also use temp vars to simplify
Parameter *some_device = Parameter::find_param(""test2"");
some_device-&gt;write(100);
int z = some_device-&gt;read();
</code></pre>

<p>I know Arduinos are very limited on resources, so I would be interested to see how this code performs on the device. </p>
",,,
53676129,2,52863942,2018-12-07T20:00:26.080,2,,5483150,,2018-12-07T20:00:26.080,,0,,"

<p>For small arguments gcc-avr will unroll the while loop, effectively stringing together multiple 1µs-delays:</p>

<pre><code>delay_us(5):
    ldi r24,lo8(5)
    mov r25,r24
    1: dec r25
    brne 1b
    mov r25,r24
    1: dec r25
    brne 1b
    mov r25,r24
    1: dec r25
    brne 1b
    mov r25,r24
    1: dec r25
    brne 1b
    1: dec r24
    brne 1b
</code></pre>

<p>At some point however, the compiler changes its strategy from space-consuming unrolling to actually branching through the while loop:</p>

<pre><code>delay_us(6):
    ldi r24,lo8(6)
    ldi r25,hi8(6)
    ldi r19,lo8(5)
.L2:
    mov r18,r19
    1: dec r18
    brne 1b
    sbiw r24,1
    brne .L2
</code></pre>

<p>At that time, the carefully crafted <code>_delay_us()</code> function will be more or less defeated. The branch overhead is significant compared to the 16 clock cycles needed for a single <code>_delay_us(1)</code> and will be paid for every loop iteration.</p>

<p>The sudden increase in runtime you describe is basically the point at which your compiler stops to unroll the loop.</p>

<p>Compare this to calling <code>_delay_us(6)</code> directly:</p>

<pre><code>_delay_us(6):
    ldi r24,lo8(32)
    1: dec r24
    brne 1b
</code></pre>

<p>The assembly shown above might differ somewhat from what your compiler is doing since compiler output can vary significantly with version and flags but the listings should be reasonably close.
For the examples I assumed gcc-avr 4.6.4 with optimization level <code>-O2</code>. 
<a href=""https://godbolt.org/z/aOevfk"" rel=""nofollow noreferrer"">Try it out</a></p>
",,,
52932678,2,52932529,2018-10-22T15:17:21.520,2,,6517320,,2018-10-22T15:23:26.743,2018-10-22T15:23:26.743,0,,"<p>Assuming Max Langhof is correct and there are other names <code>ALL</code>, <code>LED1</code>, etc... in scope at the switch so that the <code>LED_References_e</code> ones are shadowed, this should help:</p>

<p>I'm not 100% certain about the differences between standard C++ and Arduino C++, but you should be able to do the following:</p>

<pre><code>enum LED_References_e
{
  ALL  = 0,
  LED1 = 1,
  LED2 = 2,
  LED3 = 3,
  LED4 = 4
};

switch (led) {

  case LED_References_e::ALL: {
    /* do stuff */
    break;
  }

  case LED_References_e::LED1: {
    /* do stuff */
    break;
  }

  case LED_References_e::LED2: {
    /* do stuff */
    break;
  }

  case LED_References_e::LED3: {
    /* do stuff */
    break;
  }

  case LED_References_e::LED4: {
    /* do stuff */
    break;
  }

  default: {
    break;
  }

}
</code></pre>

<p>What this does is it tells the compiler you explicitly want <code>LED1</code>...<code>LED4</code> from the <code>LED_References_e</code> enum.
If there are other <code>LEDx</code>es in the same scope, this should disambiguate.</p>
",,,
52963674,2,52963118,2018-10-24T07:56:48.193,0,,9752282,,2018-10-24T07:56:48.193,,1,,"<p>Yes, it is possible to put the classes in the main file and use the classes. 
You must initialize the classes before using them in void loop(), else the class won't be recognised. </p>

<p>For example:</p>

<pre><code>class serial
{
   public:
   serial(){Serial.begin(9600);}
   void printLine(String text){Serial.println(text);}
};

serial serialObject; //Must be a global variable to use in setup and loop function

void setup() {
serial serialObject;
}

void loop() {
serialObject.printLine(""Hello"");
}
</code></pre>

<p>Personally I think it is a better habit to put classes in separate .h and .cpp files for readability. </p>
",,,
52986135,2,52978879,2018-10-25T09:40:51.950,0,,5271927,,2018-10-25T09:48:18.313,2018-10-25T09:48:18.313,2,,"<blockquote>
  <p><strong>Variable shadowing.</strong></p>
  
  <p>In computer programming, variable shadowing occurs when a variable declared within a certain scope (decision block, method, or inner class) has the same name as a variable declared in an outer scope.</p>
</blockquote>

<p>You haven't posted minimal working example and you've probably ommited global variables. But if you are able to compile it, it must be definitely there. DROP both global variable declarations: <code>String NIRString;</code> and <code>String VISString;</code>. It will not compile now. But that also means you were changing completely different variables inside of if block <code>{}</code>.</p>

<p>Keep the variables as local as possible. It cannot be inside of if () { block; }.</p>

<pre><code>String returnMeasurements(int sensorType)
{
  String result;

  if (sensorType == 1 || sensorType == 3)
  {
    //do assay
    result += ""SOME DATA HERE""; // Gather data from sensor and append to NIRSTRING
  }

  if (sensorType == 2 || sensorType == 3)
  {
    //do assay
    result += ""SOME DATA HERE""; // Gather data from sensor and append to VISSTRING
  }
  Serial.print(""TEST"");
  Serial.print(result); //HERE IS WHEN THINGS SOMETIMES GO WRONG
  return result;
}
</code></pre>

<p>However this one is pretty memory intensive on Arduino platform, so it's not really reccomended at all to do String concatenations. Nice article about it: <a href=""https://hackingmajenkoblog.wordpress.com/2016/02/04/the-evils-of-arduino-strings/"" rel=""nofollow noreferrer"">The Evils od Arduino Strings</a> </p>
",,,
52990743,2,52982967,2018-10-25T13:40:03.287,0,,7019597,,2018-10-25T17:38:07.153,2018-10-25T17:38:07.153,3,,"<p>I have updated your code and is working fine now kindly take a look.</p>

<pre><code>#include &lt;ESP8266WiFi.h&gt;
#include &lt;Wire.h&gt;
#include &lt;ESP8266WebServer.h&gt;

// SHT31 I2C address is 0x44(68)
#define Addr 0x44

// Replace with your network credentials
const char* ssid     = ""DcubeAirtel"";
const char* password = ""D@Airtel190"";
float Ctemp,Ftemp,humid;

// Set web server port number to 80
WiFiServer server(80);

// Variable to store the HTTP request
String header;

void setup() 
{
  Wire.begin(2,14);
  Serial.begin(115200);
  // Connect to Wi-Fi network with SSID and password
  Serial.print(""Connecting to "");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
  delay(500);
  Serial.print(""."");
 }
  // Print local IP address and start web server
  Serial.println("""");
  Serial.println(""WiFi connected."");
  Serial.println(""IP address: "");
  Serial.println(WiFi.localIP());
  server.begin();
}

void loop(){
  temptask();
  WiFiClient client = server.available();   // Listen for incoming clients

  if (client) 
   {                             // If a new client connects,

    Serial.println(""New Client."");          // print a message out in the serial port
    String currentLine = """";                // make a String to hold incoming data 
     from the client
    while (client.connected()) {            // loop while the client's connected
      if (client.available()) {             // if there's bytes to read from the 
     client,
       String c = client.readStringUntil('\r');             // read a byte, then
       Serial.println(c);
     }                    // print it out the serial monitor
       // if the current line is blank, you got two newline characters in a row.
       // that's the end of the client HTTP request, so send a response:
        // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
        // and a content-type so the client knows what's coming, then a blank line:
        client.println(""HTTP/1.1 200 OK"");
        client.println(""Content-type:text/html"");
        client.println(""Connection: close"");
        client.println();

          String PAGE2 = 
 ""&lt;!DOCTYPE html&gt;""
 ""&lt;html&gt;""
 ""&lt;head&gt;""
 ""&lt;meta charset=\""utf-8\""&gt;""
 ""&lt;meta name = \""viewport\"" content = \""width = device-width, initial-scale = 1.0\""&gt;""
 ""&lt;title&gt; My first HTML page&lt;/title&gt;""
 ""&lt;/head&gt;""
 ""&lt;body style= \""background-color:#EDEEF2\""&gt;""
 ""&lt;h1 style= \""color:blue\""&gt;Temperature and Humidity&lt;/h1&gt;""
 ""&lt;h3 style= \""font-family:verdana; color:blue\""&gt;Temperature in Celcius:&lt;/h3&gt;""
 ""&lt;p style=\""font-size:160%; font-family:Lucida Console\""&gt;""+String(Ctemp,1)+
 ""&lt;/p&gt;""
 ""&lt;h3 style= \""font-family:verdana; color:blue\""&gt;Temperature in Fahrenheit:&lt;/h3&gt;""
 ""&lt;p style=\""font-size:160%; font-family:Lucida Console\""&gt;""+String(Ftemp,1)+
 ""&lt;/p&gt;""
 ""&lt;h3 style= \""font-family:verdana; color:blue\""&gt;Humidity:&lt;/h3&gt;""
 ""&lt;p style=\""font-size:160%; font-family:Lucida Console\""&gt;""+String(humid,1)+
 ""&lt;/p&gt;""
 ""&lt;/body&gt;""
 ""&lt;/html&gt;"";
        // Display the HTML web page
        client.println(PAGE2);

      } 
}
// Clear the header variable

// Close the connection
client.stop();
Serial.println(""Client disconnected."");
Serial.println("""");
 }
void temptask(){
  unsigned int data[6];

  // Start I2C Transmission
  Wire.beginTransmission(Addr);
  // Send 16-bit command byte
  Wire.write(0x2C);
  Wire.write(0x06);
  // Stop I2C transmission
  Wire.endTransmission();
  delay(300);

  // Start I2C Transmission
  Wire.beginTransmission(Addr);
  // Stop I2C Transmission
  Wire.endTransmission();

  // Request 6 bytes of data
  Wire.requestFrom(Addr, 6);

 // Read 6 bytes of data
 // temp msb, temp lsb, temp crc, hum msb, hum lsb, hum crc
 if (Wire.available() == 6)
 {
   data[0] = Wire.read();
   data[1] = Wire.read();
   data[2] = Wire.read();
   data[3] = Wire.read();
   data[4] = Wire.read();
   data[5] = Wire.read();
  }
  // Convert the data
  int temp = (data[0] * 256) + data[1];
  float cTemp = -45.0 + (175.0 * temp / 65535.0);
  float fTemp = (cTemp * 1.8) + 32.0;
  float humidity = (100.0 * ((data[3] * 256.0) + data[4])) / 65535.0;  
  Ctemp = cTemp;
  Ftemp = fTemp;
  humidity = humid;

  Serial.print(""Temperature in C:\t"");
  Serial.println(String(cTemp,1));
  Serial.print(""Temperature in F:\t"");
  Serial.println(String(fTemp,1));
  Serial.print(""Humidity:\t "");
  Serial.println(String(humidity,1));
}
</code></pre>

<p>This works as follows:</p>

<ol>
<li>First read the char sent by server till next line </li>
<li>Now flush the server    </li>
<li>Now write your content to the server.</li>
</ol>
",,,
52987769,2,52983680,2018-10-25T11:05:10.217,0,,9194018,,2018-10-25T11:05:10.217,,0,,"<p>Got some help from a mate. For whoever is wondering, here is the answer to the question. Special thanks to Jonathan.</p>

<pre><code>int8_t serial_comm_transmit(uint8_t c)
{
    uint8_t timeout, intr_state;

    if (!usb_configuration) return -1;

    intr_state = SREG;
    cli();
    UENUM = CDC_TX_ENDPOINT;

    if (transmit_previous_timeout) {
        if (!(UEINTX &amp; (1&lt;&lt;RWAL))) {
            SREG = intr_state;
            return -1;
        }
        transmit_previous_timeout = 0;
    }

    timeout = UDFNUML + TRANSMIT_TIMEOUT;
    while (1) {

        if (UEINTX &amp; (1&lt;&lt;RWAL)) break;
        SREG = intr_state;

        if (UDFNUML == timeout) {
            transmit_previous_timeout = 1;
            return -1;
        }

        if (!usb_configuration) return -1;

        intr_state = SREG;
        cli();
        UENUM = CDC_TX_ENDPOINT;
    }

    UEDATX = c;

    if (!(UEINTX &amp; (1&lt;&lt;RWAL))) UEINTX = 0x3A;
    transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    SREG = intr_state;
    return 0;
}

void usb_send_info(const char *data){
    for (int i = 0; i &lt; strlen_P(data); i ++){
        serial_comm_transmit(pgm_read_byte(&amp;data[i]));
    }
}

static char line1[] PROGMEM = ""This is stored in flash mem"";

usb_send_info(line1);
</code></pre>
",,,
53002782,2,52999277,2018-10-26T06:33:05.423,1,,7266357,,2018-10-26T06:33:05.423,,5,,"<p>First of all, I would propose to put CMakeLists.txt in your source root. Then:</p>

<pre><code>cmake_minimum_required (VERSION 2.6)
project(makeTest)

include_directories(src)

set (makeTest_VERSION_MAJOR 1)
set (makeTest_VERSION_MINOR 0)

add_executable(makeTest src/main.cpp forTest.cpp src/String.cpp src/parson.c)
</code></pre>

<p>Configure &amp; build:</p>

<pre><code>cd build
cmake ../
make
</code></pre>

<p>Even better if you use <strong>target_include_directories</strong> instead of include_directories:</p>

<pre><code>..
add_executable(makeTest src/main.cpp forTest.cpp src/String.cpp src/parson.c)
target_include_directories(makeTest PRIVATE src)
</code></pre>
",,,
53036560,2,53036331,2018-10-28T22:15:05.783,0,,2993960,,2018-10-28T23:06:41.093,2018-10-28T23:06:41.093,17,,"<p>Your <code>for</code> loop in <code>verify</code> is accessing outside the array:</p>

<pre><code>const int pass[4] = {1, 2, 3, 4};
int value[4] = {};

for(int i = 0; i &lt;= 4; i++){
    if(value[i] != pass[i]){
        falseCharacter = true;
    }
}
</code></pre>

<p>Change <code>i &lt;= 4</code> to <code>i &lt; 4</code>.  Also, when <code>falseCharacter</code> is set to <code>true</code>, <code>break</code> from the loop:</p>

<pre><code>for(int i = 0; i &lt; 4; i++)
{
    if(value[i] != pass[i])
    {
        falseCharacter = true;
        break;
    }
}
</code></pre>

<p><strong>Update</strong></p>

<p>You need an <code>else</code> statement in <code>loop</code>:</p>

<pre><code>void loop(void)
{
    if(irrecv.decode(&amp;results))
    {
        if (results.value == powBtn)
        {
            reset();
        }
        else if (results.value == zeroBtn)
        {
            input = 0;
        }
        else if (results.value == oneBtn)
        {
            input = 1;
        }
        else if (results.value == twoBtn)
        {
            input = 2;
        }
        else if (results.value == threeBtn)
        {
            input = 3;
        }
        else if (results.value == fourBtn)
        {
            input = 4;
        }
        else if (results.value == fiveBtn)
        {
            input = 5;
        }
        else if (results.value == sixBtn)
        {
            input = 6;
        }
        else if (results.value == sevenBtn)
        {
            input = 7;
        }
        else if (results.value == eightBtn)
        {
            input = 8;
        }
        else if (results.value == nineBtn)
        {
            input = 9;
        }
        else
        {
            return; /*** !!! Unrecognized Value !!! ***/
        }

        value[digitNum] = input;
        digitNum++;
        if(digitNum == 1)
        {
            digitalWrite(LED1, HIGH);
        }
        else if(digitNum == 2)
        {
            digitalWrite(LED2, HIGH);
        }
        else if(digitNum == 3)
        {
            digitalWrite(LED3, HIGH);
        }
        else if(digitNum == 4)
        {
            digitalWrite(LED4, HIGH);
            verify();
        }
        else
        {
            if (results.value == powBtn)
            {
                reset();
            }
        }

        // Receive the next value
        irrecv.resume();
    }
}
</code></pre>
",,,
54605788,2,53072356,2019-02-09T11:31:55.440,1,,23118,,2019-02-09T11:31:55.440,,1,,"<p>You seem to have two problems, one that both JoystickTest.ino and CPPM-Monitor.ino are compiled at the same time which this answer does not dive into further, and the compile error</p>

<pre><code>Joystick:14:15: error: variable or field 'readCPPM' declared void
void readCPPM(CPPMFrame* frame) {

Joystick:14:15: error: 'CPPMFrame' was not declared in this scope
Joystick:14:26: error: 'frame' was not declared in this scope
void readCPPM(CPPMFrame* frame) {
</code></pre>

<p>This looks like Arduino's special prototype handling. Normally in C and C++ if you try to use a function before its prototype has been declared you will get an compiler error. In order to make Arduino more newbie friendly when compiling it first scans the source file to <em>only</em> make a list of functions so that you can call a function in <code>setup</code> even if it is defined later in the file. This works fine when the functions only have basic types like <code>int</code>, <code>char *</code> etc but fails if you use enums, structs etc because the compiler does not have parsed those at that point.</p>

<p>The short term remedy is to force an explicit prototype generation, e.g. you can put one right in front:</p>

<pre><code>void readCPPM(CPPMFrame* frame);
void readCPPM(CPPMFrame* frame) {
...
</code></pre>

<p>although long term you are much better off not stuffing everything into the main ino file but instead put this code into separate source files with corresponding header files which then avoids the issue entirely.</p>
",,,
53091325,2,53091205,2018-10-31T20:17:36.523,2,,65863,,2018-11-01T15:08:14.147,2018-11-01T15:08:14.147,4,,"<p>According to <a href=""https://github.com/esp8266/Arduino/blob/master/libraries/Ticker/Ticker.h"" rel=""nofollow noreferrer"">this version of <code>Ticker.h</code></a>, <code>Ticker::attach_ms()</code> is overloaded to accept either a <code>std::function&lt;void(void)&gt;</code> or a <code>void (*)(TArg)</code> as the callback:</p>

<pre><code>typedef void (*callback_with_arg_t)(void*);
typedef std::function&lt;void(void)&gt; callback_function_t;

void attach_ms(uint32_t milliseconds, callback_function_t callback)
{
        _callback_function = callback;
        attach_ms(milliseconds, _static_callback, (void*)this);
}

template&lt;typename TArg&gt;
void attach_ms(uint32_t milliseconds, void (*callback)(TArg), TArg arg)
{
        static_assert(sizeof(TArg) &lt;= sizeof(uint32_t), ""attach_ms() callback argument size must be &lt;= 4 bytes"");
        uint32_t arg32 = (uint32_t)arg;
        _attach_ms(milliseconds, true, reinterpret_cast&lt;callback_with_arg_t&gt;(callback), arg32);
}
</code></pre>

<p>In the first case, you can use a lambda with <code>std::function</code>, you don't need <code>std::bind()</code> at all:</p>

<pre><code>tick-&gt;attach_ms(tickLength, [this](){ this-&gt;tickerCallbackLed(); });
</code></pre>

<p>In the second case, the <code>callback</code> takes a user-defined argument that is passed to <code>Ticker::attach_ms()</code>, so you can pass <code>this</code> as that argument (which, as you can see above, is exactly what the <code>std::function</code> version of <code>Ticker::attach_ms()</code> does internally):</p>

<pre><code>class Led {
...
private:
    ...
    static void staticTickerCallbackLed(Led *pThis);
    void tickerCallbackLed();
    ...
};

void Led::staticTickerCallbackLed(Led *pThis)
{
    pThis-&gt;TickerCallbackLed();
}

...

tick-&gt;attach_ms(tickLength, &amp;Led::staticTickerCallbackLed, this);
</code></pre>

<p>Do note, though, that <code>Ticker::attach_ms()</code> does not allow a callback argument that is > 4 bytes in size, which means either approach will not work when compiling for 64-bit, where pointers are 8 bytes!  IMHO, that seems like a bug in the implementation of the internal <code>Ticker::_attach_ms()</code> method, which takes in a callback argument as <code>uint32_t</code> instead of as <code>uintptr_t</code>:</p>

<pre><code>void _attach_ms(uint32_t milliseconds, bool repeat, callback_with_arg_t callback, uint32_t arg);
</code></pre>
",,,
53121168,2,53116860,2018-11-02T15:10:29.623,0,,168986,,2018-11-02T15:21:21.440,2018-11-02T15:21:21.440,1,,"<p>Your existing solution can be extended to handle multiple photo-diodes simply by using an array of <code>DiodeResult</code> instances:</p>

<pre><code>void loop()
{
    static DiodeResult diodeResult[DIODE_COUNT];

    for( int i = 0; i &lt; DIODE_COUNT; i++ )
    {
        bool diodePassed = readDiode( i ) ;

        if( diodePassed )
        {
            diodeResult[i].diodePassed = true;
            diodeResult[i].timeOfSet = millis();
        }
        else
        {
            if( (millis() - diodeResult[i].timeOfSet) &gt; (5 * 1000)
            {
                diodeResult[i].diodePassed = false;
            }
        }
    }
}
</code></pre>

<p>Or perhaps more ""Arduino-like"":</p>

<pre><code>void loop()
{
    static DiodeResult diodeResult[DIODE_COUNT];
    static int i= 0 ;

    bool diodePassed = readDiode( i ) ;

    if( diodePassed )
    {
        diodeResult[i].diodePassed = true;
        diodeResult[i].timeOfSet = millis();
    }
    else
    {
        if( (millis() - diodeResult[i].timeOfSet) &gt; (5 * 1000)
        {
            diodeResult[i].diodePassed = false;
        }
    }

    // Next diode on next loop iteration
    i = (i + 1) % DIODE_COUNT ; 
}
</code></pre>

<p>However it relies on the photo-diode state remaining active for at least as long as it takes to iterate all ten sensors.  This may be the case, but it highly dependent on your application and possibly the implementation of <code>readDiode()</code>.  It may be necessary if polling is not fast enough to use interrupts.</p>

<p>Moreover the solution could arguably be improved by a little OOP:</p>

<pre><code>class cMonoStable
{
    public : 
        cMonoStable( unsigned long period_ms ) : m_time_ms(time_ms)
        {
        }

        void trigger()
        {
            m_start_ms = millis() ;
        }

        bool getState()
        {
            return m_start_ms - millis() &lt; m_time_ms ;
        }

    private :
        unsigned long m_time_ms;
        unsigned long m_start_ms
};

class cPhotoDiodeTriggeredMonostable : public cMonoStable
{
    public :
        cPhotoDiodeTriggeredMonostable( unsigned long period_ms, int diode = 0 ) : cMonoStable( period_ms ) : m_diode(diode)
        {
        }

        void update()
        {
            if( readDiode( m_diode ) )
            { 
                trigger() ;
            }
        }

    private:
        int m_diode ;
} ;

static const int DIODE_COUNT = 10 ;
static cPhotoDiodeTriggeredMonostable* photo_diode_state[DIODE_COUNT];

void setup()
{
    for( int i = 0; i &lt; DIODE_COUNT; i++ )
    {
        photo_diode_state[i] = new cPhotoDiodeTriggeredMonostable( 5000, i ) ;
    }
}

void loop()
{
    static int i = 0 ;
    photo_diode_state[i]-&gt;update() ;

    if( photo_diode_state[i].getState() )
    {
        // do whatever - state remains true for 5 seconds after diode was last active.
    }
}
</code></pre>

<p>It looks a little long winded, but not how simple the individual elements are, and the <code>cMonoStable</code> class can be applied to other sensor types with similar characteristics, just be implementing a super-class with a different <code>update()</code> implementation.</p>
",,,
53123121,2,53122140,2018-11-02T17:15:31.100,1,,3410010,,2018-11-02T17:15:31.100,,1,,"<p>As <code>@Lightness Races in Orbit</code> mentioned in the comments. You can declare pointer to a Foo in global context and in the setUp function you can initialize in the global pointer with new'd object of Foo.</p>

<p>Using <code>struct</code> doesn't make it Bar immutable. In C++, structure is equivalent to a class just with an exception of default access specifier being public. One way to make Bar immutable is to make members private and make sure only the constructor can modify it. </p>

<p>Following example gives one such example with immutable Bar as member of Foo class. I hope you find it useful.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class Bar {
private:
    int A,B,C;
public:
    Bar(int a,int b, int c):A(a),B(b),C(c){};

    int getA() const { return A; }
    int getB() const { return B; }
    int getC() const { return C; }

};

class Foo {
private:
    Bar *mBar;
public:
    Foo(Bar barInstance) {
        mBar = new Bar(barInstance.getA(),barInstance.getB(),barInstance.getC());
    }
    void DoSomething() {
        std::cout&lt;&lt;""Doing something"";
    }
};

Foo *fooPointer;

void setUpArduino() {
    Bar myBar(1,2,3);
    fooPointer = new Foo(myBar);
    fooPointer-&gt;DoSomething();
}

int main() {
    setUpArduino();
}
</code></pre>
",,,
53128513,2,53128423,2018-11-03T04:52:52.997,3,,390913,,2018-11-03T05:15:47.967,2018-11-03T05:15:47.967,2,,"<p>I don't know if this reduces the binary size, and not tested. You can still do something like this:</p>

<pre><code> unsigned char mask[] = {
     0b01000000, 0b10000000, 0b00000001, 0b00000010,
     0b00000100, 0b00001000, 0b00010000, 0b00100000};
 while(PIND &amp; 0b00100000) {
     for (int i = 7, v = 128; i &gt; -1; --i, v /= 2) {
         if (clickCount &gt;= v &amp;&amp; clickCount &gt; 0) {
             if (clickCount &gt;= 4) {
               PORTB = PORTB | mask[i];
             } else {
               PORTD = PORTD | mask[i];
             }
             clickCount -= v;
             break;
         }
     }
 }
</code></pre>

<p>Or you can use a single loop:</p>

<pre><code>int v = 128, i = 7;
while (v &gt; 0 &amp;&amp; (PIND &amp; 0b00100000)) {
    if (clickCount &gt;= v) {
         if (clickCount &gt;= 4) {
           PORTB = PORTB | mask[i];
         } else {
           PORTD = PORTD | mask[i];
         }
        clickCount -= v;
    } else {
        --i;
        v /= 2;
    }
}
</code></pre>
",,,
56290139,2,53128423,2019-05-24T09:51:55.720,1,,10988580,,2019-05-24T10:07:30.470,2019-05-24T10:07:30.470,6,,"<p>To handle the output, I would do something like:</p>

<pre><code>clickCount %= 256; /* because the output is 8-bit */
PORTB = clickCount;
</code></pre>

<p>To make the output exactly 1 instruction long:</p>

<pre><code>unsigned char clickCount = 0;

... /* do things, handle increment, handle 2nd button */

PORTB = clickCount; /* modulo 256 no longer needed, ClickCount cannot be more than 8 bits anyway */
</code></pre>

<p>I see no reason for doing it bit by bit.</p>
",,,
53138943,2,53138067,2018-11-04T08:18:02.863,0,,4603670,,2018-11-04T08:18:02.863,,2,,"<p>Encrypt first with key and IV, and then encode to base64. On the decoder side, decode base64, and decrypt with the same key and IV.</p>

<p>Note that AES functions change IV, so you have to keep it a constant and copy to a mutable if you are testing in the same function.</p>

<p>For simplicity, remove the base64 part and just try to encrypt and decrypt: </p>

<pre><code>int msglen = strlen(msg);
int msglen_padded = msglen  + (N_BLOCK - ((msglen - 1) % 16));
byte cipher[msglen_padded];
byte msg_decoded[msglen_padded];
byte iv[N_BLOCK];

aes.iv_inc();
aes.set_IV(my_iv);
aes.get_IV(iv);
aes.do_aes_encrypt(msg, strlen(msg) + 1, cipher, key, 256, iv);//+1 to encrypt null

aes.set_IV(my_iv);
aes.get_IV(iv);
aes.do_aes_decrypt(cipher, cipher_len, msg_decoded, key, 256, iv);

if (aes.get_size())
{
    msg_decoded[aes.get_size() - 1] = 0;
    printf(""%s\n"", msg);
}
</code></pre>

<p>You then want to encode <code>cipher</code> to base64, and decode back to <code>cipher</code>, in between AES encrypt/decrypt</p>
",,,
53160877,2,53158896,2018-11-05T19:24:57.263,0,,10603574,,2018-11-05T19:24:57.263,,1,,"<p>Well, at the end i came up with this: </p>

<pre><code>short AnimationControl = 0;

void AnimationMain(){
  switch (AnimationControl){
    case 0:
    Animation1();
    break;

    case 1:
    Animation2();
    break;

    case 2:
    Animation3();
    break;

    case 3:
    Animation4();
    break;

    case 4:
    Animation5();
    break;

    case 5:
    Animation6();
    break;

    case 6:
    Animation7();
    break;

    case 7:
    Animation8();
    break;
  }
}

void Animation1()
  max7219.clr();
  if(InternetStatus){
    max7219.setColumn(0, B11111111);
    for(int i=1; i&lt;7; i++){
      max7219.setColumn(i, B10000001);
    }
    AnUp = B10011101;
    AnCenter = B10111001;
    AnDown = B11110001;
    max7219.setColumn(10, B10000001);
    max7219.setColumn(11, B10000001);
    max7219.setColumn(15, B10000001);
    max7219.setColumn(16, B10000001);
    max7219.setColumn(20, B10000001);
    max7219.setColumn(21, B10000001);
    for(int i=25; i&lt;31; i++){
      max7219.setColumn(i, B10000001);
    }
    max7219.setColumn(31, B11111111);
  } else {
    AnUp = B00011100;
    AnCenter = B00111000;
    AnDown = B01110000;
  }
  max7219.setColumn(7, AnCenter);
  max7219.setColumn(8, AnCenter);
  max7219.setColumn(9, AnCenter);
  max7219.setColumn(12, AnCenter);
  max7219.setColumn(13, AnCenter);
  max7219.setColumn(14, AnCenter);
  max7219.setColumn(17, AnCenter);
  max7219.setColumn(18, AnCenter);
  max7219.setColumn(19, AnCenter);
  max7219.setColumn(22, AnCenter);
  max7219.setColumn(23, AnCenter);
  max7219.setColumn(24, AnCenter);
  max7219.refreshAll();
  AnimationControl=1;
}


void Animation2(){
   AnIndex = 0;
   max7219.setColumn(7+(AnIndex*5), AnUp);
   max7219.setColumn(8+(AnIndex*5), AnUp);
   max7219.setColumn(9+(AnIndex*5), AnUp);
   max7219.refreshAll();
   AnimationControl=2;
}

void Animation3(){
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex = 1;
   max7219.setColumn(7+(AnIndex*5), AnUp);
   max7219.setColumn(8+(AnIndex*5), AnUp);
   max7219.setColumn(9+(AnIndex*5), AnUp);
   max7219.refreshAll();
   AnimationControl=3;
}

void Animation4(){
   AnIndex=0;
   max7219.setColumn(7+(AnIndex*5), AnDown);
   max7219.setColumn(8+(AnIndex*5), AnDown);
   max7219.setColumn(9+(AnIndex*5), AnDown);
   AnIndex=1;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex=2;
   max7219.setColumn(7+(AnIndex*5), AnUp);
   max7219.setColumn(8+(AnIndex*5), AnUp);
   max7219.setColumn(9+(AnIndex*5), AnUp);
   max7219.refreshAll();
   AnimationControl = 4;
}

void Animation5(){
   AnIndex=0;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex=1;
   max7219.setColumn(7+(AnIndex*5), AnDown);
   max7219.setColumn(8+(AnIndex*5), AnDown);
   max7219.setColumn(9+(AnIndex*5), AnDown);
   AnIndex=2;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex=3;
   max7219.setColumn(7+(AnIndex*5), AnUp);
   max7219.setColumn(8+(AnIndex*5), AnUp);
   max7219.setColumn(9+(AnIndex*5), AnUp);
   max7219.refreshAll();
   AnimationControl = 5;
}

void Animation6(){
   AnIndex=1;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex=2;
   max7219.setColumn(7+(AnIndex*5), AnDown);
   max7219.setColumn(8+(AnIndex*5), AnDown);
   max7219.setColumn(9+(AnIndex*5), AnDown);
   AnIndex=3;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   max7219.refreshAll();
   AnimationControl = 6;
}

void Animation7(){
   AnIndex=2;
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   AnIndex=3;
   max7219.setColumn(7+(AnIndex*5), AnDown);
   max7219.setColumn(8+(AnIndex*5), AnDown);
   max7219.setColumn(9+(AnIndex*5), AnDown);
   max7219.refreshAll();
   AnimationControl = 7;
}

void Animation8(){
   max7219.setColumn(7+(AnIndex*5), AnCenter);
   max7219.setColumn(8+(AnIndex*5), AnCenter);
   max7219.setColumn(9+(AnIndex*5), AnCenter);
   max7219.refreshAll();
   AnimationControl = 0;
}
</code></pre>

<p>And i called AnimationMain with the Ticker library every setted interval (in my case 125ms).</p>

<p>Hopefully helps someone.</p>
",,,
53237093,2,53174085,2018-11-10T07:59:45.630,0,,5820440,,2018-11-10T07:59:45.630,,2,,"<p>It seems like you want to have a h.264 stream from the camera.</p>

<p>OpenCV is unbeatable when you want to do some processing on the camera frames, but I would not necessarily use it for a task requiring to get H.264, since the Pi has a hardware h.264 encoder and I am not sure that gets used in your case.</p>

<p>For getting a h.264 output to a file, or to stream it somewhere, you can either use the standard raspivid application and pipe its output where you want, or if you need more control, you can take it's source code and modify it.</p>

<p>I got lazy and did the former. The code below streams the H.264 stream to a TCP socket.
If there is congestion (i.e. the data can't be written to the socket fast enough, the code will close the socket, after which my client re-connects). The approach may not be extremely elegant, but I have been using this for a while and it seems to work OK.</p>

<pre><code>#include ""CameraRelay.h""
#include &lt;arpa/inet.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;memory&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;

#define READ 0
#define WRITE 1

pid_t popen2(const char *command, char * const args[], int *infp, int *outfp) {
  int p_stdin[2], p_stdout[2];
  pid_t pid;

  if (pipe(p_stdin) != 0 || pipe(p_stdout) != 0)
    return -1;

  pid = fork();

  if (pid &lt; 0)
    return pid;
  else if (pid == 0)
  {
    close(p_stdin[WRITE]);
    dup2(p_stdin[READ], READ);
    close(p_stdout[READ]);
    dup2(p_stdout[WRITE], WRITE);

    execv(command, args);
    perror(""execl"");
    exit(1);
  }

  if (infp == NULL)
    close(p_stdin[WRITE]);
  else
    *infp = p_stdin[WRITE];

  if (outfp == NULL)
    close(p_stdout[READ]);
  else
    *outfp = p_stdout[READ];

  return pid;
}

namespace CameraRelay {
  static std::unique_ptr&lt;std::thread&gt; s_thread;
  static std::mutex s_startStopMutex;
  static bool s_bRun;
  int s_listensock = -1;

  void RelayThread() {
    signal(SIGPIPE, SIG_IGN);
    s_listensock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s_listensock &lt; 0) {
      perror(""socket() for camera relay failed"");
      return;
    }

    int on = 1;
    setsockopt(s_listensock, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));
    ioctl(s_listensock, FIONBIO, (char *)&amp;on);

    unsigned int bufsz = 1024; // small buffer to control latency
    setsockopt(s_listensock, SOL_SOCKET, SO_SNDBUF, (void *)&amp;bufsz, sizeof(bufsz));

    struct sockaddr_in sa;
    memset((char *)&amp;sa, 0, sizeof(sa));
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = htonl(INADDR_ANY);
    sa.sin_port = htons(7124);
    if (bind(s_listensock, (struct sockaddr *)&amp;sa, sizeof(struct sockaddr)) &lt; 0) {
      perror(""bind() for camera relay failed"");
      return;
    }
    bufsz = 1024; // small buffer to control latency
    setsockopt(s_listensock, SOL_SOCKET, SO_SNDBUF, (void *)&amp;bufsz, sizeof(bufsz));
    if (listen(s_listensock, 1)) {
      perror(""listen() for camera relay failed"");
      return;
    }
    while (s_bRun) {
      sockaddr_in sa;
      memset((char *)&amp;sa, 0, sizeof(sa));
      socklen_t len = sizeof(sa);
      struct pollfd pfd;
      memset(&amp;pfd, 0, sizeof(pfd));
      pfd.fd = s_listensock;
      pfd.events = POLLIN;
      int ret = poll(&amp;pfd, 1, 500);
      if (ret &gt; 0) {        
        int sock = accept(s_listensock, (struct sockaddr *)&amp;sa, &amp;len);
        unsigned int bufsz = 16384; // small buffer to control latency
        setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void *)&amp;bufsz, sizeof(bufsz));
        fcntl(sock, F_SETFL, fcntl(sock, F_GETFL, 0) | O_NONBLOCK);
        printf(""camera relay socket got new connection.\n"");
        char buffer[512];
        std::string cmd = ""/usr/bin/raspivid"";
        const char *args[] = { ""/usr/bin/raspivid"", ""-o"", ""-"", ""-n"" , ""-s"", ""-t"" ,""0"", ""-fl"", ""-hf"", ""-b"", ""5000000"", ""-w"", ""1280"", ""-h"",  ""720"", ""-fps"", ""25"", nullptr };
        int pin = 0;
        int pout = 0;
        pid_t pid = popen2(cmd.c_str(), const_cast&lt;char **&gt;(args), &amp;pin, &amp;pout);
        if (pid &lt;= 0) {
          perror(""popen() failed!"");
          break;
        }
        fcntl(pout, F_SETPIPE_SZ, 1024); // small buffer to control latency
        bool bFailed = false;
        int nWait = 0;
        while (s_bRun &amp;&amp; !bFailed) {
          struct pollfd pfd2[2];
          memset(&amp;pfd2, 0, sizeof(pfd2));
          pfd2[0].fd = sock;
          pfd2[0].events = POLLIN;
          pfd2[1].fd = pout;
          pfd2[1].events = POLLIN;
          poll(pfd2, 2, 500);

          if (pfd2[0].revents) {
            char rcv;
            if (recv(sock, &amp;rcv, 1, 0)) {
            }
          }

          if (pfd2[1].revents) {
            int nRead = read(pout, buffer, sizeof(buffer));
            if (nRead &lt;= 0) {
              break;
            }
            int nSent = 0;
            while (nSent &lt; nRead) {
              int ret = send(sock, buffer + nSent, nRead - nSent, 0);
              if ((ret &lt; 0 &amp;&amp; errno != EWOULDBLOCK) || !s_bRun) {
                perror(""camera relay send() failed"");
                bFailed = true;
                break;
              }
              if (!nSent &amp;&amp; ret == nRead) {
                nWait = 0;
              }
              nSent += ret;
              if (nSent &lt; nRead) {
                memset(&amp;pfd, 0, sizeof(pfd));
                pfd.fd = sock;
                pfd.events = POLLOUT;                
                poll(&amp;pfd, 1, 500);
                nWait++;
                if (nWait &gt; 2) {
                  bFailed = true;
                  break;
                }
              } 
            }
          }
        }
        if (pout &gt; 0)
          close(pout);
        if (pin &gt; 0)
          close(pin);
        if (pid &gt; 0) {                    
          printf(""Killing raspivid child process %d with SIGKILL...\n"", pid);
          kill(pid, SIGINT);
          sleep(1);
          kill(pid, SIGKILL);
          int status = 0;
          printf(""Waiting for process to end...\n"");
          waitpid(pid, &amp;status, 0);
          printf(""Killed raspivid child process\n"");
        }
        if (sock &gt; 0)
          close(sock);        
      }
    }    
  }

  bool Open() {
    if (s_thread)
      return false;
    system(""killall raspivid"");
    s_bRun = true;
    s_thread = std::unique_ptr&lt;std::thread&gt;(new std::thread(RelayThread));
    return true;
  }

  void Close() {
     if (!s_thread)
      return;
    s_bRun = false;
    s_thread-&gt;join();
  }
};
</code></pre>
",,,
56940474,2,53179916,2019-07-08T18:12:19.037,0,,8006258,,2019-07-08T18:12:19.037,,0,,"<p>The Wt include files do not have the .h extension on some OSs.
Try <code>#include &lt;Wt/WApplication&gt;</code></p>

<pre><code>root@08c7a05c8129:/usr/lib/Wt/examples/hello# ls /usr/include/Wt
Auth                       WBatchEditProxyModel       WDateValidator            WHTML5Audio          WLocalizedStrings         WPopupWidget           WSslInfo            WTimePicker
Chart                      WBoostAny                  WDefaultLayout            WHTML5Video          WLogger                   WProgressBar           WStackedWidget      WTimeValidator
Dbo                        WBootstrapTheme            WDefaultLoadingIndicator  WIOService           WMatrix4x4                WPushButton            WStandardItem       WTimer
Ext                        WBorder                    WDialog                   WIcon                WMeasurePaintDevice       WRadioButton           WStandardItemModel  WTimerWidget
Http                       WBorderLayout              WDllDefs.h                WIconPair            WMediaPlayer              WRandom                WStatelessSlot      WToolBar
Json                       WBoxLayout                 WDoubleSpinBox            WIdentityProxyModel  WMemoryResource           WRasterImage           WStreamResource     WTransform
Mail                       WBreak                     WDoubleValidator          WImage               WMenu                     WReadOnlyProxyModel    WString             WTree
Payment                    WBrush                     WEnvironment              WInPlaceEdit         WMenuItem                 WRectArea              WStringListModel    WTreeNode
Render                     WButtonGroup               WEvent                    WIntValidator        WMessageBox               WRectF                 WStringStream       WTreeTable
Utils                      WCalendar                  WException                WInteractWidget      WMessageResourceBundle    WRegExp                WStringUtil         WTreeTableNode
WAbstractArea              WCanvasPaintDevice         WFileResource             WItemDelegate        WMessageResources         WRegExpValidator       WSubMenuItem        WTreeView
WAbstractGLImplementation  WCheckBox                  WFileUpload               WItemSelectionModel  WModelIndex               WResource              WSuggestionPopup    WVBoxLayout
WAbstractItemDelegate      WCircleArea                WFitLayout                WJavaScript          WNavigationBar            WScrollArea            WSvgImage           WValidationStatus
WAbstractItemModel         WClientGLWidget            WFlags                    WJavaScriptPreamble  WObject                   WScrollBar             WTabWidget          WValidator
WAbstractItemView          WColor                     WFlashObject              WJavaScriptSlot      WOverlayLoadingIndicator  WSelectionBox          WTable              WVector3
WAbstractListModel         WCombinedLocalizedStrings  WFont                     WLabel               WPaintDevice              WServer                WTableCell          WVector4
WAbstractMedia             WComboBox                  WFontMetrics              WLayout              WPaintedWidget            WServerGLWidget        WTableColumn        WVectorImage
WAbstractProxyModel        WCompositeWidget           WFormModel                WLayoutItem          WPainter                  WShadow                WTableRow           WVideo
WAbstractSpinBox           WConfig.h                  WFormWidget               WLayoutItemImpl      WPainterPath              WSignal                WTableView          WViewWidget
WAbstractTableModel        WContainerWidget           WGLWidget                 WLength              WPanel                    WSignalMapper          WTemplate           WVirtualImage
WAbstractToggleButton      WCssDecorationStyle        WGenericMatrix            WLengthValidator     WPdfImage                 WSlider                WTemplateFormView   WVmlImage
WAccordionLayout           WCssStyleSheet             WGlobal                   WLineEdit            WPen                      WSocketNotifier        WText               WWebWidget
WAggregateProxyModel       WCssTheme                  WGoogleMap                WLineF               WPoint                    WSortFilterProxyModel  WTextArea           WWidget
WAnchor                    WDate                      WGradient                 WLink                WPointF                   WSound                 WTextEdit           WWidgetItem
WAnimation                 WDateEdit                  WGridLayout               WLoadingIndicator    WPolygonArea              WSpinBox               WTheme
WApplication               WDatePicker                WGroupBox                 WLocalDateTime       WPopupMenu                WSplitButton           WTime
WAudio                     WDateTime                  WHBoxLayout               WLocale              WPopupMenuItem            WSslCertificate        WTimeEdit
</code></pre>
",,,
53197670,2,53197443,2018-11-07T20:55:27.230,2,,9017315,,2018-11-07T20:55:27.230,,0,,"<p>The problem is that you define <code>payload</code> as an array of size <code>1</code>. You can not store your data into it.</p>

<p>On Arduino you can use the <code>String</code> type: </p>

<pre><code>String payload;

while (client.connected())
{
  if (client.available())
  {
    char data = client.read();
    payload += data;
  }
}

Serial.println(payload);
client.stop();
</code></pre>
",,,
53226584,2,53225192,2018-11-09T13:25:56.650,3,,930640,,2018-11-09T13:25:56.650,,1,,"<p>Since the Arduino IDE by default doesn't seem to include <code>&lt;functional.h&gt;</code>, I wasn't able to use the answer using <code>std::function&lt;void()&gt;</code>. However, after some experimenting I realized there was an easier way, which also has the benefit of being able to model the listener.</p>

<p>The listener class simply contains function pointers to each listener callback function, and a constructor that takes an argument for each callback. Then it's very convenient to just create a new instance of the listener class and pass each callback as a lambda.</p>

<pre><code>class MyButton{
    public:
        inline void setListener(MyButtonListener* listener) { _listener = listener; }

    private:
        MyButtonListener* _listener;          
 }


class MyButtonListener{
    public:
        MyButtonListener(void* onPressed, void* onToggled) : onPressed(onPressed), onToggled(onToggled) {};
        void (*onPressed)();
        void (*onToggled)();
};



void MyButton::eventLoop(){
    if( _listener ){
        if( wasPressed() ){
            _listener-&gt;onPressed();
        }

        if( wasToggled() ){
            _listener-&gt;onToggled();
        }        
    }
}



myBtn.setListener( 
    new MyButtonListener( 
        // onPressed
        [](){
            Serial.println(""Pressed"");
            toggleLed();
        },
        // onToggled
        [](){
            Serial.println(""Toggled"");
        }            
    )
);
</code></pre>

<p>Not sure if there are any drawbacks with this solution, but it works, is readable and is fit for use on Arduino.</p>
",,,
53238790,2,53237642,2018-11-10T12:08:00.027,2,,3518383,,2018-11-10T12:41:03.270,2018-11-10T12:41:03.270,9,,"<p>Don't use the String class. It fragments the memory heap, which leads to crash. Use C strings (zero terminated char array). If you are not experienced with <code>strcat</code> and <code>sprintf</code> functions, you can use CStringBuilder from my StreamLib library. The library is available in Library Manager in Arduino IDE.</p>

<pre><code>char PostData[200];
CStringBuilder sb(PostData, sizeof(PostData));

sb.print(""{\""Druppel\"": \"""");
for (uint8_t i=0; i &lt; uidLength; i++)
{
  sb.print(uid[i]);
  //sb.printf(""%02x"", uid[i]); // for hex aligned with 0
}
sb.print(""\""}"");

Serial.println(sb.length());
Serial.println(PostData);
</code></pre>
",,,
53579277,2,53267340,2018-12-02T10:12:42.960,0,,2668038,,2018-12-02T10:12:42.960,,0,,"<p>After having learned a couple of things, here is the solution:</p>

<ol>
<li>Arduino uses its USB communication for both burning the sketch and performing data transmission back and forth the PC. The boot sequence foresees that for 2 seconds (for new Arduino versions and standard boot loader) the communication towards the boot loader is active. After that time, the sketch is executed.</li>
<li>Windows API allows to set all connection parameters at once via the <code>SetCommState</code> function and to retrieve them in a similar fashion with the <code>GetCommState</code> one. That is the method the <code>set_option</code> function uses to set the parameters, but it happens that calling <code>GetCommState</code>-<code>SetCommState</code> multiple times in a row slows down the process a lot (maybe by resetting the Arduino multiple times).</li>
</ol>

<p>I ended writing the following function:</p>

<pre><code>    #include &lt;Windows.h&gt;
    #include &lt;chrono&gt;

    void init_arduino(boost::asio::serial_port&amp; port, std::chrono::milliseconds const&amp; sleep = 2000)
    {
      DCB dcbSerialParams = { 0 };
      GetCommState(port.native_handle(), &amp;dcbSerialParams);
      // this is the optimal way to set the whole serial port configuration
      // just in one shot.
      dcbSerialParams.BaudRate = CBR_9600;
      dcbSerialParams.ByteSize = 8;
      dcbSerialParams.StopBits = ONESTOPBIT;
      dcbSerialParams.Parity = NOPARITY;
      //Setting the DTR to Control_Enable ensures that the Arduino is properly
      //reset upon establishing a connection
      dcbSerialParams.fDtrControl = DTR_CONTROL_ENABLE;
      SetCommState(port.native_handle(), &amp;dcbSerialParams);
      PurgeComm(port.native_handle(), PURGE_RXCLEAR | PURGE_TXCLEAR);

      // Wait for Arduino to boot the sketch
      Sleep(sleep.count());
    }
</code></pre>

<p>and using it to replace the <code>port.set_option(</code> lines in the question example.</p>

<p>I also set the flow control to <code>DTR_CONTROL_ENABLE</code> instead of the original <code>none</code> in order to reset the Arduino upon connection.</p>
",,,
53383304,2,53366240,2018-11-19T22:05:16.193,0,,5719485,,2018-11-19T22:05:16.193,,0,,"<p>Here's code, you just need to adjust code for yourself, but logic Works, at least car will stop if is something in front. Also watch how you write your code. In if statment instead of <code>==</code> you have <code>=</code>
Also give proper names for variables and functions.</p>

<pre><code>if (distanceF &lt; 50)
{
    // Code that will stop the car
}
else
{
    // Code that will drive car forward
}

if (Fwd)
{
    if (distanceL &gt; distanceR)
    {
        // Code that will drive car left
    }
    else
    {
        // Code that will drive car right
    }
}
</code></pre>
",,,
53383622,2,53366240,2018-11-19T22:34:31.283,1,,1386054,,2018-11-19T22:34:31.283,,0,,"<p>In the comments, you said that that <code>Fwd</code> variable never changes.  Note that you have three different variables name <code>Fwd</code>, though it seems you probably intended to have one global one.</p>

<p>The first is in <code>setup</code>:</p>

<pre><code>void setup() {
  Serial.begin(9600);
  int Fwd = false;
  // ...
}
</code></pre>

<p>This <code>Fwd</code> is local to setup.  It's set but never read.  Once <code>setup</code> is finished, it no longer exists.</p>

<p>The other two are here:</p>

<pre><code>if (distanceF &gt; 50 ) {
  int Fwd = true;
  Serial.print(""true"");
} else {
  int Fwd = false;
  Serial.print(""false"");
  Stp();
}
</code></pre>

<p>Each of those is a new variable that's local to the scope in which it's defined (from the definition until the closing curly brace).  Again, these are set but never inspected.</p>

<p>I think what you intended is to declare a global variable outside of any function:</p>

<pre><code>int Fwd = false;
</code></pre>

<p>Then, whenever you want to change it, you'd just assign to it without repeating the type:</p>

<pre><code>Fwd = true;
</code></pre>

<p>Then you have lines like this:</p>

<pre><code>if ((distanceF = true) &amp;&amp; (distanceL &gt; distanceR))
</code></pre>

<p>I'm not sure what you intended by <code>(distanceF = true)</code>, but I don't think that code does what you think it does.  Since you used a single <code>=</code>, that's an assignment not a comparison.  So your if-condition is actually changing the value of <code>distanceF</code> to <code>true</code> rather than checking to see if it is true (or non-zero).  I suspect you wanted <code>Fwd</code> there:</p>

<pre><code>if (Fwd &amp;&amp; (distanceL &gt; distanceR))
</code></pre>

<p>None of that explains why the car doesn't actually stop though.  I suspect you also have a problem reading the data from the ultrasonic sensor.  Perhaps the units aren't what is expressed in the code or you need to do some averaging (or other filtering) of the readings in order to reduce noise and faulty readings.</p>
",,,
53385932,2,53385750,2018-11-20T03:47:37.750,0,,4958351,,2018-11-20T03:47:37.750,,2,,"<p>dispatch should called with an instance.</p>

<pre><code>template&lt;class T&gt;
void dispatch(T&amp; instance, void(T::*func)(char, char), char param1, char param2  )
{
  instance.*func(param1, param2);
}
</code></pre>

<p>call dispatch:</p>

<pre><code>dispatch(*this, cmdMethods[0], 'a', 'b');
</code></pre>
",,,
53408571,2,53408016,2018-11-21T09:09:30.500,0,,6782754,,2018-11-21T09:09:30.500,,0,,"<p>You provide a full URI to the <code>GET</code> field:</p>

<pre><code>char *page = ""http://plankter.cz/iot/list.json"";
...
snprintf(sendline, MAXSUB,
            ""GET %s\r\n""
            ""Host: %s\r\n""
            ""Connection: close\n""
            ""\n"", page, host);
</code></pre>

<p>You should not include protocol and host name.</p>

<p>Try this instead:</p>

<pre><code>char *page = ""/iot/list.json"";
</code></pre>
",,,
53413784,2,53413090,2018-11-21T14:01:47.687,3,,645128,,2018-11-21T14:38:50.240,2018-11-21T14:38:50.240,2,,"<p>Sequential constructs in code are often the most efficient in terms of speed.  If you are looking for improvements in readability (eg, how many lines of code) then looping will help, but likely reduce efficiency in other ways.  That said, to reduce number of lines, say in a loop...</p>

<p>Use a combination of <code>enum</code>, <code>const char</code> array and <code>struct</code>.   (struct is optional here, but something I often use for readability when working with a large number of members) </p>

<p>I do not have your environment, but for illustration using ANSI C, the following shows how enumerated values can tie string descriptions together with measurement values into the same struct instance, allowing results to be  reported in a loop:</p>

<pre><code>enum {
    FLAME_SENSOR,    // enumerated from 0 to max_sensor
    DISTANCE_SENSOR,
    MOTION_SENSOR,
    TOUCH_SENSOR,
    SOUND_SENSOR,
    // add more sensors???
    MAX_SENSOR
};

typedef struct { // optional struct
    int val;
    char descr[20];
}PARAM;

const char str[MAX_SENSOR][20] = {""flame"",""distance"",""motion"",""touch"",""noise""};

//simulation prototype    
int analogRead(int type); 

int main(void)
{
    int i;
    PARAM p;
    char buf[20];
    int result = 0;

    for(i=0;i&lt;MAX_SENSOR;i++)
    {
        p.val = analogRead(i);// for use with struct
        result = analogRead(i);//for use without struct
        if(p.val /*(or result)*/ == some error)
        {
            //handle error
        }
        strcpy(p.descr, str[i]);//for use without struct
        sprintf(buf, ""%s: %d\n"", p.descr, p.val);//for use with struct
        sprintf(buf, ""%s: %d\n"", str[i], result);//for use without struct
        printf(buf);
        sleep(10);  //10ms delay, For simulation only, to allow clock tick for rand() function 
    }           
    return 0;
}

//simple simulation of  analog read function
int analogRead(int type)
{
    int meas = 0;
    srand(clock());
    switch(type)  {
        case FLAME_SENSOR:
            // meas = read flame sensor instrument
            meas = rand()%10;
            break;
        case DISTANCE_SENSOR:
            // meas = read dist sensor instrument
            meas = rand()%10;
            break;
        case MOTION_SENSOR:
            // meas = read motion sensor instrument
            meas = rand()%10;
            break;
        case TOUCH_SENSOR:
            // meas = read touch sensor instrument
            meas = rand()%10;
            break;
        case SOUND_SENSOR:
            // meas = read sound sensor instrument
            meas = rand()%10;
            break;
        // add more case statements ???
        default:
            meas = some error
            break;
    }
    return meas;
}
</code></pre>
",,,
53414211,2,53413090,2018-11-21T14:24:46.800,2,,9072753,,2018-11-21T14:24:46.800,,0,,"<p>From <a href=""https://www.arduino.cc/reference/en/language/functions/analog-io/analogread/"" rel=""nofollow noreferrer"">arduino reference</a>:</p>

<pre><code>&gt; analogRead()
&gt;  
&gt; Returns  
&gt; int(0 to 1023)
</code></pre>

<p>So you are getting integers anyway.</p>

<p>Usually I create a temporary structure will all the different data and context I need to iterate through. Then a simple loop is sufficient.</p>

<pre><code>struct data_s {
   const char *desc;
   int pin;
   enum data_type_s {
      DATA_INT,
      DATA_BOOL,
   } data_type;
} const datas[] = {
     { SOUND_SENSOR, ""sound"", DATA_INT },
     { DISTANCE_SENSOR, ""distance"", DATA_INT },
     { SOMEBOOLEAN_SENSOR, ""someboolean"", DATA_BOOL },
      ... and so on ...
};

for (size_t i = 0; i &lt; sizeof(datas)/sizeof(*datas); ++i) {
     Serial.print(data[i].desc);
     Serial.print("";"");
     const int readed_value = analogRead(data[i].pin);
     switch (data[i].type) {
     case DATA_BOOL:
          // custom int-&gt;bool conversion
          Serial.print(value ? ""true"" : ""false"");
          break;
     case DATA_INT:
          Serial.print(value);
          break;
     }
     Serial.print(""\n"");
}
</code></pre>
",,,
53499230,2,53498564,2018-11-27T12:00:46.767,2,,7582247,,2018-11-28T20:09:27.293,2018-11-28T20:09:27.293,8,,"<p>It looks like <a href=""https://www.arduinolibraries.info/libraries/arduino-stl"" rel=""nofollow noreferrer"">ArduinoSTL 1.1.0</a> doesn't include <code>unordered_map</code> so you could create a <code>map</code> like this.</p>

<ol>
<li>Download the Arduino STL ZIP file and put it somewhere good</li>
<li>Sketch\Include Library\Add ZIP library and give it the full path to the ZIP file.</li>
</ol>

<p>Then this should compile, albeit with a lot of STL warnings about unused variables.</p>

<pre><code>#include &lt;ArduinoSTL.h&gt;    
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

struct key_entry {
    std::string name;
    std::string down;
    std::string up;
    key_entry() : name(), down(), up() {}
    key_entry(const std::string&amp; n, const std::string&amp; d, const std::string&amp; u) :
        name(n),
        down(d),
        up(u)
    {}
};

using keydict = std::map&lt;unsigned int, key_entry&gt;;

keydict kd = {
    {0x28, {""KEY_ENTER"",  ""\x5a"", ""\xf0\x5a""}},
    {0x29, {""KEY_ESC"",    ""\x76"", ""\xf0\x76""}}
};

void setup() {
    Serial.begin( 115200 );  
}

void loop() {
    auto&amp; a = kd[0x29];
    // use a.down or a.up (or a.name for debugging)
    Serial.write(a.up.c_str(), a.up.size());
}
</code></pre>
",,,
53585255,2,53562803,2018-12-02T22:32:29.147,0,,10728915,,2018-12-03T01:50:13.217,2018-12-03T01:50:13.217,0,,"<p>i missed an unsigned byte in do_undelta7
so now it's decoding well
c#</p>

<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Media;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using NAudio.Wave;


public class UDPListener
{
    uint current_recv_data_buf;
    static int NB_DATA_BUFS = 5;
    static UInt16[] data_buf = new UInt16[700];

    uint current_play_data_buf; // current data buf being played
    uint play_data_buf_pos; // position in the ADC data buffer


    private const int listenPort = 45990;



    public static unsafe int Main()
    {
        bool done = false;
        UdpClient listener = new UdpClient(listenPort);
        IPEndPoint groupEP = new IPEndPoint(IPAddress.Parse(""192.168.1.3""), listenPort);
        int BUFSIZE = 700;
        byte[] receive_byte_array;
        uint current_recv_data_buf = 1;
        List&lt;byte&gt; tenBuffsToPlay = new List&lt;byte&gt;();
        int iterBuffsToPLay = 0;
        byte[] byteArrToPlay = new byte[data_buf.Length * 2];
        byte[] byte10ArrToPlay;
        int pktcount = 0;

        var sampleRate = 20000;
        var frequency = 500;
        var amplitude = 0.2;
        var seconds = 5;

        while (!done)
        {
            receive_byte_array = listener.Receive(ref groupEP);
            if (receive_byte_array.Length &gt; 0)
            {
                Console.WriteLine(""received !""+pktcount++);
                int sz = receive_byte_array.Length;
                unsafe
                {

                    byte[] buf = new byte[sz];

                    buf = receive_byte_array;
                   fixed (UInt16* data_bufPtr = &amp;data_buf[0])
                   fixed (byte* ptrbuf = buf)
                   do_undelta7(ptrbuf, sz, data_bufPtr);

                    //string firstPart = """";
                    //string secondPart = """";

                    for (int i =0;i&lt;data_buf.Length;i++)
                    {
                        //Console.WriteLine(""Hex: {0:X}"", data_buf[i]);

                        byteArrToPlay[i*2] = (byte)((data_buf[i] &gt;&gt; 8)&amp;0x0f);
                        byteArrToPlay[(i*2)+1] = (byte)(data_buf[i] &amp; 0xff);
                        //firstPart = Convert.ToString(byteArrToPlay[i], 2).PadLeft(4, '0');
                        //Console.Write(firstPart);
                        //secondPart = Convert.ToString(byteArrToPlay[i+1], 2).PadLeft(4, '0');
                        //Console.Write(secondPart+""\n"");
                    }

                    //byteArrToPlay = data_buf.SelectMany(BitConverter.GetBytes).ToArray();

                    //foreach (var Arr in byteArrToPlay)
                    // {
                    // Console.WriteLine(""Hex: {0:X}"", Arr);
                    // }
                    tenBuffsToPlay.AddRange(byteArrToPlay);
                    iterBuffsToPLay++;
                    if (iterBuffsToPLay == 3)
                    {
                        byte10ArrToPlay = tenBuffsToPlay.ToArray();


                        /*var raw = new byte[sampleRate * seconds * 2];

                        var multiple = 2.0 * frequency / sampleRate;
                        for (int n = 0; n &lt; sampleRate * seconds; n++)
                        {
                            var sampleSaw = ((n * multiple) % 2) - 1;
                            var sampleValue = sampleSaw &gt; 0 ? amplitude : -amplitude;
                            var sample = (short)(sampleValue * Int16.MaxValue);
                            var bytes = BitConverter.GetBytes(sample);
                            raw[n * 2] = bytes[0];
                            raw[n * 2 + 1] = bytes[1];
                        }*/


                        var ms = new MemoryStream(byte10ArrToPlay);
                        var rs = new RawSourceWaveStream(ms, new WaveFormat(sampleRate, 16, 1));


                        var wo = new WaveOutEvent();
                        wo.Init(rs);
                        wo.Play();
                        /*while (wo.PlaybackState == PlaybackState.Playing)
                        {
                            Thread.Sleep(1);
                        }*/
                        //wo.Dispose();







                        /*using (MemoryStream ms = new MemoryStream())
                        {
                            WriteWavHeader(ms, false, 1, 16, 20000, (byte10ArrToPlay.Length / 2 - 45));
                            // Construct the sound player
                            ms.Write(byte10ArrToPlay, 0, byte10ArrToPlay.Length);
                            ms.Position = 0;
                            SoundPlayer player = new SoundPlayer(ms);
                            player.Play();
                        }*/
                        tenBuffsToPlay.Clear();
                       iterBuffsToPLay = 0;
                    }

                }

            }
        }

        listener.Close();
        return 0;
    }


    static unsafe long do_undelta7(byte* val, int sz, UInt16* outArray)
    {
        // Implement delta 7 decompression.
        // First bit = 0 &lt;=&gt; uncompressed 15 bits following 
        // First bit = 1 &lt;=&gt; 7 bits follow representing delta
        // must switch to big endian...
        UInt16 last = 0;
        byte* ptr = (byte*)&amp;outArray[0];
        byte* start = ptr;
        for (int i = 0; i &lt; sz; i++)
        {
            UInt16* ptr16 = (UInt16*)ptr;
            byte firstbyte = val[i];
            var bit = (firstbyte &amp; (1 &lt;&lt; 8 - 1)) != 0;
            if (bit == true)
            {
                // Delta7 compressed
                // byte is CSMMMMMM
                sbyte delta = (sbyte)(firstbyte &amp; 0x3f);
                bit = (firstbyte &amp; (1 &lt;&lt; 7 - 1)) != 0;
                if (bit == true)
                {
                    delta = (sbyte)(0x0 - delta);
                }
                UInt16 value = (UInt16)(last + delta);
                *ptr16 = value;
                ptr += 2;

                last = value;
            }
            else
            {
                // uncompressed -- switch bytes back to LE

                *ptr++ = val[i + 1];
                *ptr++ = val[i];
                last = (UInt16)(val[i + 1] | val[i] &lt;&lt; 8);
                i++;
            }
        }

        return ptr - start;

    }
    private static void WriteWavHeader(MemoryStream stream, bool isFloatingPoint, ushort channelCount, ushort bitDepth, int sampleRate, int totalSampleCount)
    {
        stream.Position = 0;
        stream.Write(Encoding.ASCII.GetBytes(""RIFF""), 0, 4);
        stream.Write(BitConverter.GetBytes((2* totalSampleCount) + 36), 0, 4);
        stream.Write(Encoding.ASCII.GetBytes(""WAVE""), 0, 4);
        stream.Write(Encoding.ASCII.GetBytes(""fmt ""), 0, 4);
        stream.Write(BitConverter.GetBytes(16), 0, 4);
        stream.Write(BitConverter.GetBytes((ushort)(isFloatingPoint ? 3 : 1)), 0, 2);
        stream.Write(BitConverter.GetBytes(channelCount), 0, 2);
        stream.Write(BitConverter.GetBytes(sampleRate), 0, 4);
        stream.Write(BitConverter.GetBytes(sampleRate * 2), 0, 4);
        stream.Write(BitConverter.GetBytes((ushort)2), 0, 2);
        stream.Write(BitConverter.GetBytes(16), 0, 2);
        stream.Write(Encoding.ASCII.GetBytes(""data""), 0, 4);
        stream.Write(BitConverter.GetBytes(2 * totalSampleCount), 0, 4);
    }


} // end of class UDPListener
</code></pre>
",,,
53705334,2,53567099,2018-12-10T12:06:44.297,1,,5388805,,2018-12-10T12:06:44.297,,0,,"<p>Assuming your <code>Port0-&gt;DATA[0]</code> is pointing to Base-Address <code>0x5000 0000</code> and defined as aligned 8bit array then your Pin-Port addressing/masking is wrong.</p>

<p>See <a href=""https://www.nxp.com/docs/en/user-guide/UM10398.pdf"" rel=""nofollow noreferrer"">LPC111x user manual UM10398 Rev. 12.4 p196 Chapter 12.4.1 write/read data operation</a>:</p>

<blockquote>
  <p>In order for software to be able to set GPIO bits without affecting any other pins in a single 
  write operation, bits [13:2] of a 14-bit wide address bus are used to create a 12-bit wide 
  mask for write and read operations on the 12 GPIO pins for each port.</p>
</blockquote>

<p>So there is an offset of 2 bit in the address to get/set the value of your desired pin.
Therefore you must shift your addressing by 2 bit, the following should do the trick:</p>

<pre><code>Port0-&gt;DATA[1&lt;&lt;(7+2)] &amp;= ~(1&lt;&lt;7); // output initially low 

while (1) {
    if((Port0-&gt;DATA[1&lt;&lt;(1+2)]) &amp; (1&lt;&lt;1)) //When input is high
    {
        Port0-&gt;DATA[1&lt;&lt;(7+2)] |= (1&lt;&lt;7); //drive PIO0_7 High
    }
    else
    {
         Port0-&gt;DATA[1&lt;&lt;(7+2)] &amp;= ~(1&lt;&lt;7); //Drive PIO0_7 Low
    }
}
</code></pre>
",,,
53591508,2,53591324,2018-12-03T10:10:29.300,2,,10673387,,2018-12-03T12:25:45.740,2018-12-03T12:25:45.740,1,,"<p>Use <code>itoa()</code> and <code>ftoa()</code> to convert <code>int</code> and <code>float</code> values to stings, then use <code>strcat</code>.</p>

<p><code>itoa</code> will work in <strong>arduino.</strong></p>

<p>The <code>ftoa</code> function is provided below:</p>

<pre><code>char buff1[10];
char buff2[10];

itoa(test3,buff1,10);
ftoa(test2,buff2,3);

void ftoa(float n, char *res, int afterpoint) 
{ 
    // Extract integer part 
    int ipart = (int)n; 

    // Extract floating part 
    float fpart = n - (float)ipart; 

    // convert integer part to string 
    itoa(ipart, res, 10); 

    int i = strlen(res);

    // check for display option after point 
    if (afterpoint != 0) 
    { 
        res[i] = '.';  // add dot 

        // Get the value of fraction part upto given no. 
        // of points after dot. The third parameter is needed 
        // to handle cases like 233.007 
        fpart = fpart * pow(10, afterpoint); 

        itoa((int)fpart, res + i + 1, 10); 
    } 
}
</code></pre>
",,,
53634263,2,53602625,2018-12-05T14:13:02.317,1,,9752282,,2020-04-29T09:44:32.817,2020-04-29T09:44:32.817,0,,"<p>This following code should let the LCD blink once per second. The blinking speed can be changed by changing the <code>blinkSpeed_ms</code> variable. </p>

<pre><code>void blink(int cursorIndex, int val) {
   lcd.setCursor(cursorIndex, 0);
   blinkSpeed_ms = 1000; //This variable defines the blinking speed

   if ((millis() - blinkTime &gt; blinkSpeed_ms) &amp;&amp; (millis() - blinkTime &lt; blinkSpeed_ms * 2)) {
      printValOnLCD(val);
   } else if(millis() - blinkTime &gt; (blinkSpeed_ms * 2)) {
      blinkTime = millis()
   }else {
      lcd.print("" "");
      lcd.print("" "");
   }
}
</code></pre>
",,,
53613013,2,53609809,2018-12-04T12:27:32.017,1,,7582247,,2018-12-04T18:10:40.153,2018-12-04T18:10:40.153,3,,"<p>As others have said, a pointer to a local variable becomes invalid as soon as the local variable goes out of scope, so it shouldn't be returned. You can instead create a <code>ByteArray</code> object that you can return-by-value from your functions. Example using ArduinoSTL:   </p>

<pre><code>#include &lt;ArduinoSTL.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;

struct ByteArray {
    uint32_t m_value;
    bool m_valid;

    // convert hex string to uint32_t value
    ByteArray(const std::string&amp; uid) :
        m_value(std::strtoul(uid.c_str(), nullptr, 16)),
        m_valid(true)
    {
        if(uid.size()!=8) m_valid = false;
    }

    // converting assignment operator
    ByteArray&amp; operator=(const std::string&amp; uid) {
        m_value = std::strtoul(uid.c_str(), nullptr, 16);
        if(uid.size()==8) m_valid = true;
        else m_valid = false;
        return *this;
    }

    // subscript operator to access the individual bytes (as ints)
    int operator[](size_t x) const {
        if(x&gt;3) return -1;
        return (m_value&gt;&gt;((3-x)*8))&amp;0xFF;
    }
};

struct AccessPortal {
    // change the getByteArray signature to this
    ByteArray getByteArray(const std::string&amp;);
};

ByteArray AccessPortal::getByteArray(const std::string&amp; uid) {
    // return by value - copy elision
    return ByteArray(uid);
}

void setup() {
    AccessPortal access; //default constructing
    ByteArray h = access.getByteArray(""1234ABCD"");

    Serial.println(h.m_value); // dec: 305441741  hex: 1234ABCD

    for(int i = 0; i &lt; 4; i++) {
        Serial.println(h[i]); // dec: 18, 52, 171, 205  hex: 12, 34, AB, CD
    }
}

void loop() {
    //
}
</code></pre>
",,,
53625958,2,53613064,2018-12-05T05:52:51.350,1,,1094998,,2018-12-05T05:52:51.350,,0,,"<p>I suggest you check out various Arduino tutorials.
However, based on your request, I have included example code below.
Please note that this has not been tested. However, you should get an idea of the logic and adapt accordingly.
There are many other ways to achieve the same result.</p>

<pre><code>int relayState = RELAY_STATE_OFF; // track state of the relay
unsigned long relayOnAt = 0; // time at which relay was turned ON

void relay(int turnOn)
{
  if( turnOn == ON ) digitalWrite(3,HIGH);
  else digitalWrite(3,LOW);
}

void processRelay(int operateRelay) 
{
  switch(relayState){
    case RELAY_STATE_OFF: 
           if( operateRelay == 1) {
             relay(ON);
             relayState = RELAY_STATE_ON;
             relayOnAt = millis(); // remember when the relay was turned on
           }
           break;
    case RELAY_STATE_ON: // wait here for interval seconds to elapse
          if( millis() - relayOnAt &gt;= interval) {
            relay(OFF);
            relayState = RELAY_STATE_OFF; // go back to checking key input
          }
          break;
    default:
        relayState = RELAY_STATE_OFF;
        break;
  }
}

int operateRelay = 0;
void loop(){  
   lcd.setCursor(0,1);             
   lcd_key = read_LCD_buttons();  

   operateRelay = 0;
   if( lcd_key == U ) {
     operateRelay = 1;
   }
   processRelay(operateRelay);

}
</code></pre>
",,,
53628638,2,53622380,2018-12-05T09:06:49.340,2,,6601582,,2018-12-05T09:06:49.340,,1,,"<p>I test serial.writeSerialPort on Windows 10 desktop with Arduino Uno. It works for me.</p>

<p>The following is the code I used:</p>

<p>On windows:</p>

<pre><code>#include &lt;iostream&gt;
#include ""serialport.h""

using namespace std;

int main()
{
    SerialPort serial(""COM4"", 115200);

    while (1) {
        unsigned char buffer[] = { 255,3, 254, 0, 0 };
        serial.writeSerialPort((char*)buffer, 5);


        unsigned char buffer2[] = { 255,5, 0, 254, 0 };
        serial.writeSerialPort((char*)buffer2, 5);

        unsigned char buffer3[] = { 255,7, 0, 0, 254 };
        serial.writeSerialPort((char*)buffer3, 5);
    }
    return 0;
} 
</code></pre>

<p>On Arduino:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

SoftwareSerial mySerial(10, 11); // RX, TX

#define BAUDRATE 115200
#define N_BYTES_MSG 4
#define N_LEDS 120
#define DATA_PIN 6

void setup() {
  Serial.begin(BAUDRATE);
  mySerial.begin(BAUDRATE);
  mySerial.println(""Start reading."");
  delay(5000);
}

void loop() { 
  //Check for a quadruplet of bytes (iLED R G B) led by start byte
  if(Serial.available() &gt;= N_BYTES_MSG+1 &amp;&amp; Serial.read() == 255) {    
    //Read message
    unsigned char buf[N_BYTES_MSG] = {0};
    for(unsigned char i=0; i &lt; N_BYTES_MSG; i++) {
      buf[i] = Serial.read();
    }

    for(unsigned char i=0; i &lt; N_BYTES_MSG; i++) {
      mySerial.print(buf[i]);
      mySerial.print("","");
    }

      mySerial.print(""\r\n"");

      //Serial.write(""Read complete!"");
  }
}
</code></pre>

<p>I print the received data on Arduino:</p>

<p><a href=""https://i.stack.imgur.com/24vE1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/24vE1.png"" alt=""enter image description here""></a></p>

<p><strong>I notice that the printed data messed up when the Windows sends fast as you did in the while(1) without delay. So try adding a delay between two writes to see if it works.</strong></p>

<p><strong>Add also note the problem as @paddy pointed out.</strong></p>

<p><a href=""https://i.stack.imgur.com/Yvu0u.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Yvu0u.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>I didn't manage to make readSerialPort() work yet</p>
</blockquote>

<p>Set <code>unsigned int toRead = buf_size;</code> in SerialPort.cpp works for me. Use the following code to read:</p>

<pre><code>    unsigned char readBuffer[20] = {};
    serial.readSerialPort((char*)readBuffer, 20);
    printf((char*)readBuffer);
    printf(""\n"");
</code></pre>

<p>Read from Arduino result:</p>

<p><a href=""https://i.stack.imgur.com/RZlVh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RZlVh.png"" alt=""enter image description here""></a></p>
",,,
53636782,2,53636279,2018-12-05T16:34:24.433,0,,1707083,,2018-12-05T16:34:24.433,,1,,"<p>It is pretty simple in opencv</p>

<pre><code>#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;iostream&gt;

using namespace cv;
using namespace std;

 int main( int argc, char** argv )
 {
        VideoCapture cap(0); // open the default camera
    if(!cap.isOpened())  // check if we succeeded
        return -1;

    Mat edges;
    namedWindow(""edges"",1);
    for(;;)
    {
        Mat frame;

        cap &gt;&gt; frame; // get a new frame from camera

        imshow(""edges"", frame);
        if(waitKey(30) &gt;= 0) break;
    }
return 0;
}
</code></pre>
",,,
53677466,2,53676929,2018-12-07T22:17:39.657,-1,,2670348,,2018-12-07T22:17:39.657,,1,,"<p>You're using <code>sizeof()</code> incorrectly.</p>

<p><a href=""https://en.cppreference.com/w/cpp/language/sizeof"" rel=""nofollow noreferrer""><code>sizeof()</code> tells you the size of the object, at compile time.</a> </p>

<p>Try this experiment - run this code:</p>

<pre><code>#include &lt;Arduino.h&gt;

void setup() {
  String x("""");
  String y(""abc"");
  String z(""abcdef"");

  Serial.begin(115200);

  delay(1000);

  Serial.println(sizeof(x));
  Serial.println(sizeof(y));
  Serial.println(sizeof(z));
}

void loop() {
}
</code></pre>

<p>On my ESP8266 this outputs:</p>

<pre><code>12
12
12
</code></pre>

<p>That's because it takes 12 bytes using this development environment to represent a <code>String</code> object (it might be different on a different CPU and compiler). The <code>String</code> class dynamically allocates storage, so <code>sizeof</code> can tell you nothing about how long the string itself is, only the compile-time size of the object.</p>

<p>For the <code>String</code> class, you should use its <code>length()</code> method. Your lines:</p>

<pre><code>char _data[sizeof(value)];
value.toCharArray(_data, sizeof(value));
for(int i = memoffset; i &lt; memoffset + sizeof(value); i++)
</code></pre>

<p>should be written as</p>

<pre><code>char _data[value.length()];
value.toCharArray(_data, value.length());
for(int i = memoffset; i &lt; memoffset + value.length(); i++)
</code></pre>

<p>For more information see the <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/stringobject/"" rel=""nofollow noreferrer"">documentation on the String class</a>.</p>

<p>You'll likely still have issues with string terminators. C and C++ terminate <code>char</code> array strings with the null character '\0', adding an extra byte to the length of the strings. So your code should more likely be:</p>

<pre><code>void changeConfig(String parameter, String value){
  int memoffset = 0;
  if(parameter == ""ssid"")
    memoffset = 0;
  else if(parameter == ""pass"")
    memoffset = 33;
  else
    return;
  #ifdef DEBUG
  Serial.println(""Updating Data"");
  Serial.print(""Param: "");
  Serial.println(parameter);
  Serial.print(""Value: "");
  Serial.println(value);
  #endif
  EEPROM.begin(66);
  char _data[value.length() + 1];
  value.toCharArray(_data, value.length() + 1);
  for(int i = memoffset; i &lt; memoffset + value.length() + 1; i++)
  {
    #ifdef DEBUG
      Serial.print(""addr "");
      Serial.print(i);
      Serial.print("" data "");
      Serial.println(_data[i]);
      #endif 
      EEPROM.write(i,_data[i]);
  }
  EEPROM.end();
}
</code></pre>

<p>to allow the string terminators to work correctly for 32 character SSIDs and passwords. But the fundamental issue that's breaking your code is the incorrect use of <code>sizeof</code>.</p>
",,,
53677608,2,53676929,2018-12-07T22:33:39.600,0,,5245033,,2018-12-07T22:33:39.600,,1,,"<p>You have two problems with your code.</p>

<p>First, you are using <code>sizeof</code> incorrectly. Sizeof returns the size of the <code>String</code> object, but you are trying to get the length of the contained string. Sizeof is not the right tool for that, instead you should use whatever API <code>String</code> offers to read the size of the string.</p>

<p>The next problem is your usage of offsets. The following code snippet is all wrong:</p>

<pre><code>char _data[sizeof(value)];
value.toCharArray(_data, sizeof(value));
for(int i = memoffset; i &lt; memoffset + sizeof(value); i++)
{
  ...
  EEPROM.write(i,_data[i]);
</code></pre>

<p>Your <code>i</code> starts with offset of 32, so you are trying to access element with index 32 in your <code>_data</code> array. But <code>_data</code> stores characters starting from the index 0, and since the length of array is actually 12 (sizeof of <code>String</code> is always 12) by accessing element with index 32 you are going beyond it's bounds, and obviously find garbage there (in C++ parlance, it is called undefined behavior).</p>

<p>Last, but not the least, C++ is an extremely complicated language, which can't be learned by 'trial and error'. Instead, you need to methodically study, preferably using one of the good C++ books. The list of those can be found here: <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">The Definitive C++ Book Guide and List</a></p>
",,,
53682673,2,53682029,2018-12-08T12:48:00.837,0,,4117728,,2018-12-08T12:54:52.323,2018-12-08T12:54:52.323,0,,"<blockquote>
  <p>I want to create a reusable class that describes an array of structs
  which contain a pointer to a method in a class. The class also
  contains ""execute"" and ""show"" methods. I think the execute method
  needs to be templated as well, but I am still struggling to learn
  templates.</p>
</blockquote>

<p>I have to say that I dont understand what you want to do exactly. However, looking at your code it seems you want a <code>std::map</code>, rather than an array (so you can map ""commands"" to the function pointers). If all methods you want to call have the same signature (<code>void(char,char)</code>) then you dont need to deal much with templates. Instead I'd suggest you to take a look at <a href=""https://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow noreferrer""><code>std::function</code></a> and lambdas.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
struct command_center {
    using command = std::string;
    using comment = std::string;    
    using action = std::function&lt; void(char,char) &gt;;
    std::map&lt; command,action &gt; action_commands;
    void register_action_command( command c, action a) { 
        action_commands[c] = a; 
    }
    void execute( command c, char a,char b) { 
        auto it = action_commands.find(c);
        if (it == action_commands.end()) {
            std::cout &lt;&lt; ""command not found: "" &lt;&lt; c &lt;&lt; ""\n"";
            return;
        }
        it-&gt;second(a,b);
    }
};

struct foo{
    void bar(char a,char b) { std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; "" foo\n"";}
};

int main(){
    command_center cc;
    cc.register_action_command(""test1"",[](char a,char b){ std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; ""\n"";});
    cc.execute(""test1"",'a','b');
    cc.execute(""unknown"",'a','b');
    foo f;
    cc.register_action_command(""foobar"",[&amp;f](char a,char b){ f.bar(a,b); });
    cc.execute(""foobar"",'a','b');
}
</code></pre>

<p>Output:</p>

<pre><code>ab
command not found: unknown
ab foo
</code></pre>

<p>Note that it could work without lamdbas and without <code>std::function</code> when you restrict yourself to a fixed signature, ie function pointers of type</p>

<pre><code>using my_function_pointer_type = void(*)(char,char);
</code></pre>

<p>However, by passing a lambda to <code>std::function</code> you can wrap any callable with the right signature and register it to be called later (no matter if it is a free function or some member method as in the example).</p>

<p>PS: It is possible to parametrize the above <code>command_center</code> to work with function pointers of different signature. Only after writing this answer I realized that maybe this is what the question is about, is it?</p>
",,,
53693089,2,53691292,2018-12-09T13:58:26.420,2,,5483150,,2018-12-09T15:55:53.373,2018-12-09T15:55:53.373,1,,"<p>Constant data can be made addressable by declaring it as <code>PROGMEM</code>. Since AVR program memory is organized as 16-bit words in a separate address space, <a href=""http://www.nongnu.org/avr-libc/user-manual/group__avr__pgmspace.html"" rel=""nofollow noreferrer"">special functions</a> have to be used for reading.</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;assert.h&gt;
#include &lt;string.h&gt;                        // memcpy
#include &lt;avr/pgmspace.h&gt;                  // AVR PROGMEM, memcpy_P

#define SIZE 1000
struct large {                             // arbitrary large data structure
  unsigned char data[SIZE];
};

struct large l;                            // global variable (in SRAM)

const struct large l_default PROGMEM = {   // default value (in PROGMEM)
  { 0xaa, 0xab, 0x0ac, 0xad, 0xae, 0xaf }
};

void setup(void)                           // load values from EEPROM
{
  memset(&amp;l, 1, SIZE);                     // simulate reading from real EEPROM
}

int main(void)
{
  setup();                                 // initialize from EEPROM
  assert(l.data[0] == 1);

  memcpy_P(l.data, &amp;l_default, SIZE);      // reset to defaults (from PROGMEM)
  assert(l.data[0] == 0xaa);

  return 0;
}
</code></pre>

<p>Confirming that sizes from the above example are as expected: 1000 additional bytes in <code>Program</code> for the default data, 1000 bytes total in <code>Data</code> for the global variable. </p>

<pre class=""lang-none prettyprint-override""><code>$ avr-size -C -x main.bin
AVR Memory Usage
----------------
Device: Unknown

Program:    1252 bytes
(.text + .data + .bootloader)

Data:       1000 bytes
(.data + .bss + .noinit)
</code></pre>

<p>The default data (starting with <code>aaabacadaeaf</code> and continuing with 994 zeros) has been placed in program memory right after the interrupt vectors. It can be accessed at runtime through the <code>pgm_read_</code> family of functions.</p>

<pre class=""lang-none prettyprint-override""><code>$ avr-objdump -s main.bin

main.bin:     file format elf32-avr

Contents of section .text:
0000 0c942802 0c943a02 0c943a02 0c943a02  ..(...:...:...:.
0010 0c943a02 0c943a02 0c943a02 0c943a02  ..:...:...:...:.
0020 0c943a02 0c943a02 0c943a02 0c943a02  ..:...:...:...:.
0030 0c943a02 0c943a02 0c943a02 0c943a02  ..:...:...:...:.
0040 0c943a02 0c943a02 0c943a02 0c943a02  ..:...:...:...:.
0050 0c943a02 0c943a02 0c943a02 0c943a02  ..:...:...:...:.
0060 0c943a02 0c943a02 aaabacad aeaf0000  ..:...:.........
0070 00000000 00000000 00000000 00000000  ................
0080 00000000 00000000 00000000 00000000  ................
0090 00000000 00000000 00000000 00000000  ................
[...]
</code></pre>
",,,
53693529,2,53693424,2018-12-09T14:54:49.270,1,,1502345,,2018-12-09T14:54:49.270,,0,,"<p>In C++, as in most other languages, it is possible to early-out from a loop using a <code>break</code> statement, so you can do something like this:</p>

<pre><code>// A loop condition that will never terminate on its own
while(true)
{
  // Exit the loop when the sensor is triggered again
  if (sensorPressed()) {
    break;
  }

  // Otherwise, continue doing whatever is needed
}

// After the break, execution will resume here
</code></pre>

<p>Note that you will probably also want another loop to ensure that the sensor is not still reading as triggered before you enter the main loop.</p>
",,,
53694881,2,53693424,2018-12-09T17:33:38.797,0,,10754130,,2018-12-09T17:40:29.957,2018-12-09T17:40:29.957,1,,"<p>You really should consider making your code little bit easier to read. It was quite hard to follow along. Even its not code writing service I feel like have to make it more readable as a example. Functionality should be same excluding added loop for that state. ofc I cant try it out here. This is not perfect but I used already a while rewriting this so yeah hopefully you get something out of it. cheers.</p>

<pre><code>#include &lt;Servo.h&gt;


/*
   Here I have added couple of definitions,
   like max servo position and speed of sound.
   Good rule is to name definitions in capital letters.
 */

#define TOUCHSENSOR 13
#define STEPSIZE 40
#define SPEED_OF_SOUND 0.034
#define MAX_SERVO_POS 160
const int trigPin = 4;
const int echoPin = 5;

int relay = 2;

/*
   its good to name variables so they indicate usage if possible,
   Here I have renamed motor PIN variables and enable pins.
   Not only for others but you will also eventually forget.
 */
int enableMotorOne = 10;
int motorOneTerminalOne = 6;
int motorOneTerminalTwo = 7;
// motor two
int enableMotorTwo = 5;
int motorTwoTerminalOne = 8;
int motorTwoTerminalTwo = 9;

boolean currentState = LOW;
boolean lastState = LOW;
boolean relayState = LOW;

Servo servo;

void setup() {
        Serial.begin(9600);
        pinMode(enableMotorOne, OUTPUT);
        pinMode(motorOneTerminalOne, OUTPUT);
        pinMode(motorOneTerminalTwo, OUTPUT);

        pinMode(enableMotorTwo, OUTPUT);
        pinMode(motorTwoTerminalOne, OUTPUT);
        pinMode(motorTwoTerminalTwo, OUTPUT);

        pinMode(TOUCHSENSOR, INPUT);
        servo.attach(3);
        pinMode(trigPin, OUTPUT);
        pinMode(echoPin, INPUT);
}


void getDistance()
{
        /*
           Whole function for getting distance from ultrasonic sensor is moved Here
           usage in older implementation was repetitive and unnecessary
         */

        long duration;
        int distance;

        digitalWrite(trigPin, LOW);
        delayMicroseconds(2);
        digitalWrite(trigPin, HIGH);
        delayMicroseconds(10);
        digitalWrite(trigPin, LOW);

        duration = pulseIn(echoPin, HIGH);
        distance= duration*(SPEED_OF_SOUND/2);
        Serial.print(""Distance: "");
        Serial.println(distance);
}

void scanState()
{
        Serial.println(""pressed"");
        digitalWrite(motorOneTerminalOne, LOW);
        digitalWrite(motorOneTerminalTwo, HIGH);
        digitalWrite(motorTwoTerminalOne, HIGH);
        digitalWrite(motorTwoTerminalTwo, LOW);

        while(currentState == HIGH &amp;&amp; lastState == LOW)
        {
                /*
                   I think this is what you were asking, to loop this functionality
                   until state pins change state.
                 */

                for (size_t servoPos = 40; servoPos &lt;= MAX_SERVO_POS; servoPos+=STEPSIZE) {
                        /*
                           This code in for loop here should do kinda 
                           same as you old code rows 
                           48-91. Please get familiar.
                         */
                        servo.write(servoPos);
                        getDistance();
                        delay(500);
                }

                if (relayState == HIGH) {
                        digitalWrite(relay, LOW);
                        relayState = LOW;
                        digitalWrite(motorOneTerminalOne, LOW);
                        digitalWrite(motorOneTerminalTwo, LOW);
                        digitalWrite(motorTwoTerminalOne, LOW);
                        digitalWrite(motorTwoTerminalTwo, LOW);
                } else {
                        digitalWrite(relay, HIGH);
                        relayState = HIGH;
                }
        }
        delay(1);
}

void loop() {

        /*
           This is your new loop function, much easier to understand what is
           going on..
         */
        currentState = digitalRead(TOUCHSENSOR);
        if (currentState == HIGH &amp;&amp; lastState == LOW) {
                scanState();
        }
        lastState = currentState;
}
</code></pre>
",,,
53702426,2,53702425,2018-12-10T09:07:57.580,1,,5550507,,2018-12-10T09:07:57.580,,0,,"<p>It was really a strange behavior, a simple workaround just fixed the issue. I just run clicked F1 again, type and select IoT Workbench: Device, then select Device Upload. And it was working fine again. </p>

<p>If it doesn't work for you,</p>

<ol>
<li>Disconnect MXChip</li>
<li>Reopen the Workspace in VSCode </li>
<li>Do Azure Provisioning </li>
<li>Do device upload</li>
</ol>

<p>Once it is done, you will get the message as below. </p>

<pre><code>Programming Finished
Verify Started
target halted due to breakpoint, current mode: Thread 
xPSR: 0x61000000 pc: 0x2000002e msp: 0x200073fc
[Done] Uploaded the sketch: GetStarted.ino
</code></pre>
",,,
53728861,2,53719200,2018-12-11T16:56:24.207,1,,1475978,,2018-12-11T16:56:24.207,,0,,"<p>Yes, there are things wrong with it.</p>

<ol>
<li><p><a href=""http://wiringpi.com/reference/serial-library/"" rel=""nofollow noreferrer""><code>serialOpen()</code></a> returns -1 if the operation fails, with <code>errno</code> set to indicate the error.</p>

<p>Make sure you include <code>&lt;stdlib.h&gt;</code>, <code>&lt;stdio.h&gt;</code>, <code>&lt;string.h&gt;</code>, <code>&lt;errno.h&gt;</code>, and <code>&lt;wiringSerial.h&gt;</code> at the beginning of your program, and open the serial port using e.g.</p>

<pre><code>    int fd;

    fd = serialOpen(""/dev/ttyS0"", 115200);
    if (fd == -1) {
        fprintf(stderr, ""Cannot open /dev/ttyS0: %s.\n"", strerror(errno));
        exit(EXIT_FAILURE);
    }
</code></pre></li>
<li><p><a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow noreferrer""><code>write()</code></a> may return a short count. You cannot just assume it sent everything successfully. I recommend you use a helper function, for example</p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif

int writeall(const int fd, const void *data, const size_t len)
{
    const char        *ptr = (const char *)data;
    const char *const  end = (const char *)data + len;
    ssize_t            n;

    while (ptr &lt; end) {
        n = write(fd, ptr, (size_t)(end - ptr));
        if (n &gt; 0)
            ptr += n;
        else
        if (n != -1)
            return errno = EIO;
        else
        if (errno != EINTR)
            return errno;
    }

    return 0;
}

#ifdef __cplusplus
}
#endif
</code></pre>

<p>which returns 0 for success, and nonzero for errors. You can use it thus:</p>

<pre><code>    if (writeall(fd, ""\x3E\x52\x01\x53\x01\x01"", 6)) {
        fprintf(stderr, ""Serial write error: %s.\n"", strerror(errno));
        /* If this is fatal, do exit(EXIT_FAILURE) here.
           If the error is not a fatal one, let the program continue.
        */
    }
</code></pre></li>
<li><p>Don't do <code>sleep()</code>. At minimum, make sure you include <code>&lt;termios.h&gt;</code>, and do</p>

<pre><code>    tcdrain(fd);
</code></pre>

<p>to ensure the kernel sends all serial data; it will return only after everything written thus far to <code>fd</code> (<code>fd</code> being open to a serial port or tty).</p></li>
</ol>

<p>Also, I recommend against using <code>serialPutchar()</code>, <code>serialPuts()</code>, <code>serialPrintf()</code>, and <code>serialGetchar()</code>, because <a href=""https://git.drogon.net/?p=wiringPi;a=blob;f=wiringPi/wiringSerial.c"" rel=""nofollow noreferrer"">they do not have any kind of error checking</a>.</p>
",,,
53736702,2,53735968,2018-12-12T05:40:13.350,2,,2752075,,2018-12-12T05:40:13.350,,0,,"<p>You can't do that in standard C++, but GCC has <a href=""https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html"" rel=""nofollow noreferrer"">Labels as Values</a> extension:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    void *arr[3] = {&amp;&amp;label1, &amp;&amp;label2, &amp;&amp;label3};

    int i;
    for (i = 0; i &lt; 3; i++)
    {
        goto *arr[i];
      ret:;
    }

    // Prints `123`

    return 0;

  label1:
    std::cout &lt;&lt; 1;
    goto ret;
  label2:
    std::cout &lt;&lt; 2;
    goto ret;
  label3:
    std::cout &lt;&lt; 3;
    goto ret;
}
</code></pre>

<hr>

<p>In standard C++ you could store an array of integers instead, and use <code>switch</code> to select actions based on those integers.</p>

<p>Alternatively, you could try using an array of function pointers (or even <code>std::function</code>s).</p>
",,,
53741182,2,53739494,2018-12-12T10:40:15.533,2,,3872145,,2018-12-12T10:40:15.533,,1,,"<p>Start by tidying up your code, and it may be obvious where things may be going wrong. For example, you are calling multiple checks to <code>Fwd</code> by doing:</p>

<pre class=""lang-cpp prettyprint-override""><code>if ((Fwd == true) &amp;&amp; ... ) {
    ...
} else if ((Fwd == true) &amp;&amp; ... ) {
    ...
} else if ((Fwd == true) &amp;&amp; ... ) {
    ... 
} else if ((Fwd == false) &amp;&amp; ... ) {
    ...
} else if ((Fwd == false) &amp;&amp; ... ) {
    ...
}
</code></pre>

<p>This uses up valuable resources in your program memory. It would be much more efficient to do a single check, and evaluate from there:</p>

<pre class=""lang-cpp prettyprint-override""><code>if (Fwd){
    // Check sensor conditions here
} else {
    // Check more sensor conditions here
}
</code></pre>

<p>In fact, you could probably omit the <code>Fwd</code> variable (unless you are using it elsewhere) altogether, saving you more memory space:</p>

<pre class=""lang-cpp prettyprint-override""><code>// Check whether to go forward or backwards.
// &gt;= 50 - forward
// &lt;  50 - backward
if (sensors[0] &gt;= 50) {
    // Check sensor conditions here 
} else {
    // Check more sensor conditions here
}
</code></pre>

<p>Overall, you could end up with something like:</p>

<pre class=""lang-cpp prettyprint-override""><code>// Check whether to go forward or backwards.
// &gt;= 50 - forward
// &lt;  50 - backward
if (sensors[0] &gt;= 50) {
    // Going forward, but which direction?
    if (sensors[1] &lt; 50) {
        fwdRight();
    } else if (sensors[2] &lt; 50) {
        fwdLeft();
    } else {
        // sensors[1] &gt;= 50 AND sensors[2] &gt;= 50
        // Going straight forward
        fwd();
    }
} else {
    // Check backward sensor conditions here
}
</code></pre>

<p>This answer might not directly answer your question, but it should help you diagnose better what is going on.</p>
",,,
53752316,2,53752096,2018-12-12T22:25:54.097,5,,4117728,,2018-12-12T22:25:54.097,,5,,"<p>I dont really understand your code. Please read <a href=""https://stackoverflow.com/help/mcve"">How to create a Minimal, Complete and Verifiable example</a>. Anyhow, the following is certainly wrong and likely the cause of your problem:</p>

<pre><code>void JFSF::addSwitchContinuous(int inputPin, int btnIndex)
{
    JFSF_PRIV::SwitchContinuousAction newBtnAction(_joystick, inputPin, btnIndex);
    _actions[_nextActionIndex++] = &amp;newBtnAction;
}
</code></pre>

<p>Lets rewrite it a bit for clarity:</p>

<pre><code>void foo(){
    T bar;
    container[index] = &amp;bar;
}
</code></pre>

<p>What happens here is that <code>bar</code> gets destroyed when it goes out of scope, hence the pointer you put into the container, points to garbage. Presumably somewhere else in your code you are dereferencing those pointers, which is undefined behaviour (aka anything can happen). </p>

<p>Long story short: It is a common pattern among c++ beginners to overuse pointers. Most likely you should make <code>container</code> a container of objects rather than pointers and make use of automatic memory managment instead of trying to fight it. </p>
",,,
53752915,2,53752096,2018-12-12T23:23:58.670,1,,3073859,,2018-12-12T23:23:58.670,,0,,"<p>Thanks to @user463035818 and @drescherjm for identifiying the actual problem.</p>

<p>So in the end I fixed it by simply moving the Action object creation up to the Arduino code (where it's essentially global) and passing references to those objects to the controller.</p>

<p>In code this translates to:</p>

<p><strong>JFSF.cpp</strong></p>

<pre><code>void JFSF::addAction(JFSF_PRIV::AbstractAction *action){
    _actions[_nextActionIndex++] = action;
}
</code></pre>

<p><strong>Arduino code (ino)</strong></p>

<pre><code>// See code in original post

JFSF controller(&amp;joystick, !DO_AUTO_SEND_STATE);

JFSF_PRIV::SwitchContinuousAction btnOne(&amp;joystick, 10, 0);
JFSF_PRIV::SwitchContinuousAction btnTwo(&amp;joystick, 9, 1);

void setup() {
  joystick.begin(DO_AUTO_SEND_STATE);
  //  controller.addSwitchContinuous(10, 0);  // Pin 10; btn index 0
  //  controller.addSwitchContinuous(9, 1);   // Pin 9 ; btn index 1 
  controller.addAction(&amp;btnOne);
  controller.addAction(&amp;btnTwo);
}
// loop() is unchanged
</code></pre>
",,,
53770529,2,53770145,2018-12-13T21:44:28.983,2,,14065,,2018-12-13T21:44:28.983,,1,,"<p>The response is a message which has a header:</p>

<blockquote>
  <p>Message format<br>
  Each command consists of the header and the body, both with checksum. Commands with the wrong header
  or body checksum, or with the body size that differs from expected, should be ignored. Parser should scan
  incoming datastream for the next start character and try to restore synchronization from it. </p>
</blockquote>

<pre><code>Header:
    Start Character    1u
    Command ID         1u
    Payload Size       1u
    Header Checksum    1u
Body
    18 bytes as defined by you.
    Body Checksum      1u
</code></pre>

<p>This gives you 23 bytes. 4 Bytes header. Body. 1 byte body checksum.</p>
",,,
53814307,2,53813914,2018-12-17T11:28:32.730,2,,1312382,,2018-12-17T16:42:17.283,2018-12-17T16:42:17.283,12,,"<p>Question is, how precise is your clock at all...</p>

<p>Still, I personally would rather go with the following approach:</p>

<pre><code>#define DELAY (5UL * 60UL * 1000UL) // or whatever is appropriate...

static unsigned long timestamp = millis();
if(millis() - timestamp &gt; DELAY)
{
    // adding a fix constant will prevent accumulating deviations over time
    timestamp += DELAY;
    // run the every-5-min task...
}
</code></pre>

<p><em>Edit: combined 1-min and 5-min task:</em></p>

<p>Variant 1:</p>

<pre><code>#define DELAY_SHORT (1UL * 60UL * 1000UL)
#define DELAY_LONG  (5UL * 60UL * 1000UL)

static unsigned long timestampS = millis();
static unsigned long timestampL = timestampS;
if(millis() - timestampS &gt; DELAY_SHORT)
{
    timestamp += DELAY_SHORT;
    // run the every-1-min task...
}
if(millis() - timestampL &gt; DELAY_LONG)
{
    timestamp += DELAY_LONG;
    // run the every-5-min task...
}
</code></pre>

<p>Variant 2:</p>

<pre><code>#define DELAY_1M (1UL * 60UL * 1000UL)

static unsigned long timestamp = millis();
if(millis() - timestamp &gt; DELAY)
{
    // adding a fix constant will prevent accumulating deviations over time
    timestamp += DELAY;
    // run the every-1-min task...

    static unsigned int counter = 0;
    if(++counter == 5)
    {
        counter = 0;
        // run the every-5-min task...
    }
}
</code></pre>
",,,
53814352,2,53813914,2018-12-17T11:31:18.283,1,,7703024,,2018-12-17T11:31:18.283,,5,,"<p>Instead of trying to measure a start time and adding delay depending on that, you could keep track of the timing for your next cycle.</p>

<pre><code>unsigned long next_cycle = DELAY;

...

void loop() {
    ...

    delay( next_cycle - millis() );
    next_cycle += DELAY;
}
</code></pre>

<p>If you also want to adjust for any time the program spends on initialization or similar, you can <code>next_cycle = millis() + DELAY;</code> before you enter your loop.</p>
",,,
53819404,2,53819340,2018-12-17T16:35:58.503,2,,2266772,,2018-12-17T16:46:54.877,2018-12-17T16:46:54.877,4,,"<p>If you want to keep a proper candle object in your class, use this in the header:</p>

<pre><code>Led* _led;
Candle _candle;
</code></pre>

<p>In which case the constructor becomes:</p>

<pre><code>CandleAnimation::CandleAnimation(Led *led, Color flameColor)
: _led(led)
, _candle(led, 0xFF0000)
{
   // Rest of the constructor
}
</code></pre>

<p>If you want to keep with dynamic allocation (you don't), declare <code>_candle</code> as a <code>unique_ptr</code>:</p>

<pre><code>std::unique_ptr&lt;Candle &gt; _candle ;
</code></pre>

<p>And then (if you have C++14):</p>

<pre><code>_candle  = std::make_unique(_led, 0xFF0000);
</code></pre>

<p>In C++11:</p>

<pre><code>_candle  = std::unique_ptr(new Candle(_led, 0xFF0000));
</code></pre>

<p>If you don't have modern C++ (not sure what arduino offers?), you need to do the same, but keep track on the <code>_candle</code> lifetime.</p>
",,,
53819439,2,53819340,2018-12-17T16:38:05.607,1,,10185183,,2018-12-17T16:53:06.713,2018-12-17T16:53:06.713,7,,"<pre><code>CandleAnimation::CandleAnimation(Led *led, Color flameColor)
    : _candle(new Candle(led, 0xFF0000)) // this is making you sure that your candle will be valid until being deleted
{
  _led = led;

  //  Candle candle(_led, 0xFF0000); this is a local variable and will be deleted after constructor execution. You don't need it anymore
  //  _candle = &amp;candle;

  _candle-&gt;play(); // shows red as expected
  delay(500); // this prevents the run loop from starting so I have to delete this code to get the animate to work
}
// don't forget to delete _candle in destructor
</code></pre>
",,,
53821828,2,53820936,2018-12-17T19:27:22.520,1,,168986,,2018-12-17T19:59:27.867,2018-12-17T19:59:27.867,0,,"<p>You need to use counter value as your analogue output value:</p>

<pre><code>void loop() 
{ 
    if( count &lt; 256 )
    {
        analogWrite( analogPin, count ) ;
        delay( 20000 );
        count++ ;
    }
}
</code></pre>

<p>Note that you do not need a <code>while</code> loop; the Arduino framework already calls <code>loop()</code> iteratively (the clue is in the name).  However if your teacher thinks you need one and is expecting one, you may need to use one just for the marks. Alternatively discuss it with your teacher, and explain why it is unnecessary  </p>

<p>In fact the delay too is arguably bad practice - it is unhelpful in applications where the <code>loop()</code> must do other things while controlling the motor.  The following allows other code to run whilst controlling the motor:</p>

<pre><code>unsigned long delay_start = 0 ;

void loop() 
{ 
    if( count &lt; 256 &amp;&amp;
        millis() - delay_start &gt;= 20000ul )
    {
        analogWrite( analogPin, count ) ;
        count++ ;
        delay_start = millis() ;
    }

    // Do other stuff here
}
</code></pre>

<p>Because the <code>loop()</code> now never blocks on the <code>delay()</code> function, you can have code that does other things such as read switch inputs and it can react to them instantly, whereas as in your solution, such inputs could be ignored for up-to 20 seconds!</p>

<p>A typical DC motor will not start moving at very low values - you may want to start <code>count</code> somewhat higher than zero to account for the ""dead-band"".  Analogue signals are also generally a poor way to drive a DC motor and varying speed; a PWM is generally a more efficient method, and will allow the motor to run at lower speeds.  With an analogue signal at low levels (lower than for PWM), your motor will not move and will just get warm and drain your battery.</p>

<p>For test purposes, reduce the delay time;  you don't want to sit there for an hour and 25 minutes just to find the code does not work!  Set it to say 500ms, then start it, time how long it takes before the motor starts to move.  If that is say 30 seconds, then yu know the motor starts to move when <code>count</code> is about 60; in which case that is a better starting value that zero.  Then you can increase your delay back to 20 seconds if you wish - though a DC power supply might be better than a battery - I'm not sure it will last that long.</p>
",,,
53823797,2,53822846,2018-12-17T22:18:13.230,0,,3138095,,2018-12-17T22:18:13.230,,1,,"<p>It doesn't look like you are ever writing to the actual file. Since you don't mention how you are generating the file, I'm assuming you are writing to an arbitrary file, not one created by the driver for /proc or something.</p>

<p>Review the post here: <a href=""https://stackoverflow.com/questions/1184274/read-write-files-within-a-linux-kernel-module"">Read/write files within a Linux kernel module</a></p>

<p>You can try this:</p>

<pre><code>int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size) 
{
    mm_segment_t oldfs;
    int ret;

    oldfs = get_fs();
    set_fs(get_ds());

    ret = vfs_write(file, data, size, &amp;offset);

    set_fs(oldfs);
    return ret;
}
</code></pre>

<p>Then call it instead of 'copy_to_user':</p>

<pre><code>/* Send data to user space. */
        if (file_write(filep, 0, gpio_driver_buffer, data_size) != 0)
        {
            return -EFAULT;
        }
</code></pre>
",,,
53847189,2,53847046,2018-12-19T08:25:34.323,0,,3264375,,2018-12-19T10:56:40.623,2018-12-19T10:56:40.623,4,,"<p>It is an expected behaviour. If you revise the am335x-bone-common.dtsi file. You will see that if the i2c is enabled. You can not use uart1 rts and cts pin. So that, you should disable the i2c or assign to other pins then, you should mux the cts and rts pin in the pin muxing. </p>

<pre><code>i2c2_pins: pinmux_i2c2_pins {
        pinctrl-single,pins = &lt;
            0x178 (PIN_INPUT_PULLUP | MUX_MODE3)    /* uart1_ctsn.i2c2_sda */
            0x17c (PIN_INPUT_PULLUP | MUX_MODE3)    /* uart1_rtsn.i2c2_scl */
        &gt;;
    };
</code></pre>

<p><code>https://github.com/beagleboard/linux/blob/4.1/arch/arm/boot/dts/am335x-bone-common.dtsi</code></p>

<p>in the .dts file disable i2c2 like that</p>

<pre><code>&amp;i2c2 {
    status = ""disabled"";
};
</code></pre>
",,,
53856640,2,53856579,2018-12-19T17:45:29.750,-2,,1762556,,2018-12-19T17:45:29.750,,3,,"<p>Testing that your pointer doesn't point into a <code>\0</code> is fine when you work with strings. Here you have an array of ints and a length so you can't really use a destination point to stop incrementing the pointer. You need to use that <code>len</code> just like in your first snippet but instead of accessing the <code>i</code>th element of your array, you can still increment the pointer. Something like this :</p>

<pre><code>int compute_average(int *avgs, int len) {
  int sum = 0;
  for (int i = 0; i &lt; len; i++)
    sum += *(avgs++);
  return (int)(sum / len);
}
</code></pre>
",,,
53873216,2,53872874,2018-12-20T17:11:26.607,1,,8866606,,2018-12-20T17:18:45.550,2018-12-20T17:18:45.550,0,,"<p><code>Data[]</code> contains pointers to dynamically allocated strings. When you leave the code block with the JSON parser, its destructor is called and therefore the allocated memory can and has been overwritten by something else.</p>

<p>I would suggest to use instead</p>

<pre><code>bool Data[...];
...
   // true for ""1"", false for ""0""
   Data[i] = strcmp(root[i], ""1"") == 0;
...
</code></pre>

<p><strong>EDIT</strong> if you need to store more ""complicated"" data, e.g. actual strings, you will need to make a copy of the string pointed to by <code>root[i]</code>.</p>
",,,
53903317,2,53891054,2018-12-23T11:42:39.913,0,,,user8587747,2018-12-23T11:42:39.913,,0,,"<p>I found a working solution, by reopening the serial port by failure.</p>

<pre><code>if (wiringPiSetup () == -1)
  {
    fprintf (stdout, ""Unable to start wiringPi: %s\n"", strerror (errno)) ;
  }
  REINIT:if ((fd = serialOpen (""/dev/ttyAMA0"", 115200)) &lt; 0)
  {
   fprintf (stderr, ""Unable to open serial device: %s\n"", strerror (errno)) ;
  }

  int input = 0;
  while (ros::ok())
  {
    while (serialDataAvail (fd))
    {
      input = serialGetchar (fd);
        NazaDecoder.decode(input);
        gps_data.gps_sats = round(NazaDecoder.getNumSat());
      gps_data.lat = NazaDecoder.getLat();
      gps_data.lon = NazaDecoder.getLon();
      gps_data.heading = round(NazaDecoder.getHeadingNc());
      gps_data.alt = NazaDecoder.getGpsAlt();
      chatter_pub.publish(gps_data);
      ros::spinOnce();
      loop_rate.sleep();
      if(input==-1){
        goto REINIT;
      }
    }
  }
  return 0;
</code></pre>
",,,
53901660,2,53900441,2018-12-23T06:23:56.877,1,,10552745,,2018-12-23T06:23:56.877,,0,,"<p>this should do the same (or better) as your version</p>

<pre><code>void loop() {
  delay(100);
  A = digitalRead(ButtonA);
  B = digitalRead(ButtonB);
  if (A == 0 || B == 0) {
      delay(150);
      A = digitalRead(ButtonA);
      B = digitalRead(ButtonB);
      if (A == 0 &amp;&amp; B == 0) {
          doAB();
      } else if (A == 0) {
          doA();
      } else {
          doB();
      }
  }
}
</code></pre>
",,,
53902937,2,53900441,2018-12-23T10:45:48.357,3,,4898562,,2018-12-24T02:38:33.760,2018-12-24T02:38:33.760,3,,"<p>Try combine all buttons state into one variable, like:</p>

<pre><code>int allBtnStates;
unsigned long btnTimeStamp = 0;
void loop() {
  A = digitalRead(ButtonA);
  B = digitalRead(ButtonB);
  allBtnStates = A + 2*B;
  if(allBtnStates &lt; 3){ //Any button pressed
    if(btnTimeStamp == 0) btnTimeStamp = millis(); //Create timestamp
    else if(millis() - btnTimeStamp &gt; 150){
      switch(allBtnStates){
        case 2: doA(); break; //Only A pressed
        case 1: doB(); break; //Only B pressed
        case 0: doAB(); break; //Both A and B pressed
      }
      btnTimeStamp = 0; //Reset timestamp
    }
  }
  //Monitor other input if needed
}
</code></pre>

<p>If you have button C, then change <code>allBtnStates = A + 2*B;</code> to <code>allBtnStates = A + 2*B + 4*C;</code> and work out all the conditions accordingly. Hope that helps!</p>
",,,
53914754,2,53914467,2018-12-24T14:37:06.000,1,,10099668,,2018-12-24T14:37:06.000,,3,,"<p>From the open(2) manpage:</p>

<pre><code>   O_NONBLOCK or O_NDELAY
          When possible, the file is opened in nonblocking mode.
          Neither the open() nor any subsequent operations on the file
          descriptor which is returned will cause the calling process to
          wait.
</code></pre>

<p>For a serial connection, the end result will be that if you ask to read some number of bytes from the serial port and there are no characters waiting, then read will return with -1 and 'errno' will probably be EAGAIN or EWOULDBLOCK.</p>

<p>So your usleep(8000) was probably an attempt to wait long enough for the device to respond but the device may not have data for you; especially if it is in the middle of an adc operation, it might take longer than 8ms.</p>

<p>There are a few things you can do:</p>

<p>You can (in pseudo code):</p>

<pre><code>int retries=10;
while(retries--) {
    read_length = read(fd, rd_buffer,sizeof(rd_buffer));
    if(read_length &gt; 0)
        break;
    usleep(1000);
}
</code></pre>

<p>Unfortunately, one side effect of this is that if the temperature sensor is sending you a lengthy string and your program read()s while the temperature sensor is still writing, you will get a partial string.   So if you know the length of string that you're waiting to receive, you could use an ioctl() to find out how many characters are waiting:</p>

<pre><code>ioctl(fd, FIONREAD, &amp;bytes_avail);
</code></pre>

<p>So the pseudo code would look more like:</p>

<pre><code>int retries=10;
int bytes_avail=0;
while(retries--) {
    if (ioctl(fd, FIONREAD, &amp;bytes_avail) &lt; 0) {
        fprintf(stderr, ""ioctl failed\n"");
        return;   // Do something here
    }
    if (bytes_avail &gt;= sizeof(rd_buffer)) {
        read_length = read(fd, rd_buffer,sizeof(rd_buffer));
        if(read_length &gt; 0)
            break;
    }
    usleep(1000);
}
</code></pre>

<p>If the temperature sensor sends an ascii string that is terminated with a newline or carriage-return, then the code would look different.</p>
",,,
53915231,2,53914554,2018-12-24T15:29:55.727,0,,10553341,,2018-12-24T15:29:55.727,,0,,"<p>You can do it recursively. </p>

<p>First part size <code>m = (str_size+N-1)/N;</code><br>
Then <code>str_size -= m;</code> and <code>N--;</code></p>

<p>A little example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

std::vector&lt;std::string&gt; split_string(const std::string&amp; s, int N) {
    std::vector&lt;std::string&gt; vect;
    if (N &gt; s.size()) return vect;
    vect.resize(N);
    int n = s.size();
    auto it = s.begin();
    int Nnew = N;
    for (int i = 0; i &lt; N; i++) {
        int m = (n+Nnew-1)/Nnew;
        vect[i] = std::string (it, it+m);
        it += m;
        n = n - m;
        Nnew--;
    }
    return vect;
}

int main() {
    int N = 3;
    std::string str = ""Very!HappyXmas"";
    auto result = split_string (str, N);
    for (auto s : result) {
        std::cout &lt;&lt; s &lt;&lt; ""\n"";
    }
    return 0;
}
</code></pre>
",,,
53915345,2,53914554,2018-12-24T15:42:15.517,-1,,4039976,,2018-12-26T08:25:31.547,2018-12-26T08:25:31.547,0,,"<p>Given <code>L</code> is the length of the text, you can extract the first <code>L%N</code> parts with length <code>l = L/N + 1</code> and the rest <code>N - L%N</code> parts with length <code>l = L/N</code>.</p>

<pre><code>std::size_t N = 3;
std::string str = ""some random stringxx"";

std::vector&lt;std::string&gt; splits(N);
for (std::size_t i = 0, L = str.size(); i &lt; N; ++i) {
    splits[i] = str.substr(i*(L/N) + std::min(i, L%N), L/N + (i &lt; L%N ? 1 : 0));
}

Output:
  - 'some ra'
  - 'ndom st'
  - 'ringxx' 
</code></pre>

<p><a href=""https://coliru.stacked-crooked.com/a/31efe1ef53ca89aa"" rel=""nofollow noreferrer"">Demo</a> </p>
",,,
53919289,2,53919253,2018-12-25T04:09:49.190,-2,,212215,,2018-12-25T23:23:39.023,2018-12-25T23:23:39.023,4,,"<p>Use <code>int32_t</code> instead of <code>unit32_t</code> for <code>data32</code>. Then before returning the value, shift it left by 8, then right by 8 to sign extend it.</p>

<p>So this code:</p>

<pre><code>uint32_t readData(){
  Wire.beginTransmission(address);
  Wire.write(0x10);
  Wire.endTransmission();
  Wire.requestFrom(address,3);
  byte dataMSB = Wire.read();
  byte data = Wire.read();
  byte dataLSB = Wire.read();
  int32_t data32 = dataMSB;
  data32 &lt;&lt;= 8;
  data32 |= data;
  data32 &lt;&lt;= 8;
  data32 |= dataLSB;
  return (data32 &lt;&lt; 8) &gt;&gt; 8;
}
</code></pre>
",,,
53919883,2,53919253,2018-12-25T06:24:04.150,2,,16406,,2018-12-25T12:32:03.987,2018-12-25T12:32:03.987,4,,"<p>The problem is that there’s no safe and portable way to use shifting for sign extension in C — at best it is implementation defined.  So if you want to do it portably, you need to convert your 2s-complement value manually into a signed integer.</p>

<pre><code>int32_t cvt24bit(uint32_t val) {
    val &amp;= 0xffffff;  // limit to 24 bits -- may not be necessary
    if (val &gt;= (UINT32_C(1) &lt;&lt; 23))
        return (int32_t)val - (INT32_C(1) &lt;&lt; 24);
    else
        return val;
}
</code></pre>

<p>this will take your 24-bit two’s-complement value in a uint32_t and convert it to a (signed) int32_t.</p>
",,,
53924195,2,53919253,2018-12-25T17:05:38.013,1,,298225,,2018-12-25T17:05:38.013,,0,,"<p>Conversion from 24-bit two’s complement in a <code>uint32_t</code> to <code>int32_t</code> can be done with:</p>

<pre><code>int32_t Convert(uint32_t x)
{
    int32_t t = x &amp; 0xffffff;
    return t - (t &gt;&gt; 23 &lt;&lt; 24);
}
</code></pre>

<p>The <code>x &amp; 0xffffff</code> ensures the number has no spurious bits above bit 23. If it is certain no such bits are set, then the statement can be just <code>int32_t t = x;</code>.</p>

<p>Then <code>t &gt;&gt; 23</code> removes bits 0 to 22, leave just bit 23, which is the sign bit for a 24-bit integer. Then <code>&lt;&lt; 24</code> scales this, producing either 0 (for positive numbers) or 2<sup>24</sup> (for negative numbers). Subtracting that from <code>t</code> produces the desired value.</p>
",,,
53939190,2,53930091,2018-12-27T02:41:09.397,0,,1513180,,2018-12-27T02:41:09.397,,0,,"<p>So, I do figured this out. The following code is close to reality example which I was posting earlier.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;

const uint8_t arr1[] = {0x00, 0x00, 0x03, 0x00};
const uint8_t arr2[] = {0xA1, 0x00, 0xFF, 0x00};

class A {
public:
    struct s1 {
        std::string name;
        uint8_t const * arr;
    };
    std::vector&lt;s1, std::allocator&lt;s1&gt;&gt; vect1;

    void myPublicMethod(std::string arrName, std::string name) {
        uint8_t const * ptr;
        if(arrName == ""A"") {
            ptr = arr1;
        } else if(arrName == ""B"") {
            ptr = arr2;
        }
        privateMethod1(ptr, name);
    }

    void myPublicMethod2() {
        auto i = vect1.begin();
        for(; i &lt; vect1.end(); i++) {
            doPrint(i-&gt;arr, i-&gt;name);
            // here the link between pointers broken,
            // doPrint() shows me random characters
        }
    }

private:
    void privateMethod1(uint8_t const * ptr, std::string name) {
        // this method receives pointer correctly, so I can doPrint(ptr)
        s1 myStruct;
        myStruct.name = name;
        myStruct.arr = ptr;
        vect1.push_back(myStruct);
    }

    void doPrint(const uint8_t arr[], std::string name) {
        for(uint16_t i = 0; i &lt; sizeof(*arr); i++) {
            if(name.length() &gt; 0) {
                std::cout &lt;&lt; arr[i] &lt;&lt; '\n';
            } else {
                std::cout &lt;&lt; ""No name\n"";
            }
        }
    }
};


int main() {
    A ca;
    ca.myPublicMethod(""A"", """");
    ca.myPublicMethod(""B"", ""image"");
    ca.myPublicMethod2();
    return 0;
}
</code></pre>

<p>This code is just a small part of a project (main code). I found imposible / unnecessary to post whole project because there are lots of unnecessary stuffs that definitely will require a bunch of time to understand. </p>

<p>Initially I thought there were a problem with a pointers, particularly in A::myPublicMethod, that creates *ptr, that then being transferred to A::privateMethod1 to store in vect1. I was wrong thinking there is a mistake while saving / transferring to vect1. Lately I didn't find any changes for vect1 in a main code. 
Vector vas created well, the problem was in method doPrint, particularly in if(name.length() > 0)... So again, I had to stick to the logic of main code without inventing an example which was a lil far from reality.</p>

<p>In conclusion thanks to @paulmckenzie who indirectly gave me a reason to stop thinking in pointers. It would help me a lot if someone just confirmed that following my first example, pointers are logically correct.</p>

<p>Cheers,</p>
",,,
53940684,2,53940073,2018-12-27T06:29:09.203,2,,1475978,,2018-12-27T09:03:41.367,2018-12-27T09:03:41.367,1,,"<p>Here is my advice on how to implement a random number generator on Arduino, or indeed any microcontroller:</p>

<ol>
<li><p>Seed the random number generator at bootup (in <code>setup()</code> in Arduino) only.<br>&nbsp;</p></li>
<li><p>Use a timer to consume random numbers, and/or consume random numbers when idle.</p>

<p>This way, even though the state immediately after power on is predictable, the state changes very rapidly, and becomes unpredictable (unless the microcontroller state is monitored very closely at something like microsecond intervals).<br>&nbsp;</p></li>
<li><p>Use exclusive-OR (<code>^</code>) to mix in entropy from sources that have at least some randomness, like say <a href=""http://robseward.com/misc/RNG2/"" rel=""nofollow noreferrer"">a hardware source based on avalanche noise</a>.</p>

<p>For best results, do it only occasionally. I would personally feed the entropy to a separate pseudorandom number generator, and mix its output to the primary generator state.<br>&nbsp;</p></li>
<li><p>Use human input (button presses et cetera, via high-resolution timers) as a source for entropy.</p>

<p>That is, measure the time between e.g. successive button presses at a very high resolution, and use a few least significant bits as entropy to mix into the pseudorandom number generator state.</p>

<p>After just a few button presses, the internal state of the pseudorandom number generator would basically be unpredictable.<br>&nbsp;</p></li>
<li><p>Use battery-backed SRAM (often available as part of real-time clock modules) to store a seed state for the next bootup.</p>

<p>Technically, you could also use EEPROM or Flash for this, but since they have a limited number of write cycles, I do not recommend using those for this.<br>&nbsp;</p></li>
</ol>

<p>As I've mentioned in other posts, I personally do not trust the built-in pseudorandom number generators, and instead implement one of the known linear feedback shift generator based ones (a Xorshift variant, or Mersenne Twister). They are well known and their output randomness characterized.</p>

<p>For an Arduino-based game, I'd probably use <a href=""https://en.wikipedia.org/wiki/Xorshift"" rel=""nofollow noreferrer"">Xorshift128</a> for the random number generator itself, and a Xorshift64* for obtaining entropy from hardware sources and using its output to perturb the main generator state every now and then (say, at button press, or similar occasions; less than once per second).</p>

<p>I would ensure that even when idle, the generators' states are advanced (by ""consuming"" pseudorandom numbers; just throwing them out), so that physical world timing would become a major factor in the sequences generated.</p>

<p>Various microcontrollers have different timers and hardware features available, so the exact code I would implement definitely depends on the hardware used.  Unfortunately, that means the code is not that portable across hardware; even small, innocuous-looking changes may mean the output becomes quite predictable.  I could write an example for Arduino Leonardo / Arduino Pro Micro (both based on ATmega32u4 microcontroller), because I have one at hand, but if you are using some other microcontroller, the code might be interesting, but misleading at worst if you tried to port it to another hardware architecture without knowing its details and behaviour.</p>

<hr>

<p>To generate pseudorandom integers within a range, I recommend using the exclusion method, rather than the modulo (<code>%</code>) method.  The exclusion method ensures uniform distribution; the modulo method can give a small bias to some values near the smaller end of the range.</p>

<p>The idea of the exclusion method is simple. You grab exactly the needed number of bits to cover the range, but exclude values outside the range. On average, you may consume up to twice as many random number bits, but with a fast generator like Xorshift, that is definitely not a problem.</p>

<p>The general pattern of a fixed 32-bit signed integer range function is</p>

<pre><code>static inline int32_t  rndrange(void)
{
    uint32_t  u;
    do {
        u = random32() &gt;&gt; SHIFT;
    } while (u &gt; LIMIT);
    return u + MINIMUM;
}
</code></pre>

<p>where <code>random32()</code> returns uniform pseudorandom 32-bit unsigned integers, <code>MINIMUM</code> is the smallest integer the function can return, <code>MINIMUM + LIMIT</code> is the maximum integer the function can return (<code>LIMIT = MAXIMUM - MINIMUM</code>), and <code>SHIFT</code> is</p>

<pre><code>31 if LIMIT == 1      ║  15    LIMIT &lt;= 131071
30    LIMIT &lt;= 3      ║  14    LIMIT &lt;= 262143
29    LIMIT &lt;= 7      ║  13    LIMIT &lt;= 524287
28    LIMIT &lt;= 15     ║  12    LIMIT &lt;= 1048575
27    LIMIT &lt;= 31     ║  11    LIMIT &lt;= 2097151
26    LIMIT &lt;= 63     ║  10    LIMIT &lt;= 4194303
25    LIMIT &lt;= 127    ║   9    LIMIT &lt;= 8388607
24    LIMIT &lt;= 255    ║   8    LIMIT &lt;= 16777215
23    LIMIT &lt;= 511    ║   7    LIMIT &lt;= 33554431
22    LIMIT &lt;= 1023   ║   6    LIMIT &lt;= 67108863
21    LIMIT &lt;= 2047   ║   5    LIMIT &lt;= 134217727
20    LIMIT &lt;= 4095   ║   4    LIMIT &lt;= 268435455
19    LIMIT &lt;= 8191   ║   3    LIMIT &lt;= 536870911
18    LIMIT &lt;= 16383  ║   2    LIMIT &lt;= 1073741823
17    LIMIT &lt;= 32767  ║   1    LIMIT &lt;= 2147483647
16    LIMIT &lt;= 65535  ║   0 if LIMIT &lt;= 4294967295
</code></pre>

<p>In Arduino, or any C or C++ code compiled using GCC, you can use</p>

<pre><code>static inline int  random_intrange(const int  minval,
                                   const int  maxval)
{
    if (maxval &gt; minval) {
        const unsigned int   limit = maxval - minval;
        const unsigned char  shift = __builtin_clz(limit);
        unsigned int         u;
        do {
            u = random_unsigned_int() &gt;&gt; shift;
        } while (u &gt; limit);
        return minval + u;
    } else
        return minval;
}

static inline unsigned int  random_uintrange(const unsigned int  minval,
                                             const unsigned int  maxval)
{
    if (maxval &gt; minval) {
        const unsigned int   limit = maxval - minval;
        const unsigned char  shift = __builtin_clz(limit);
        unsigned int         u;
        do {
            u = random_unsigned_int() &gt;&gt; shift;
        } while (u &gt; limit);
        return minval + u;
    } else
        return minval;
}
</code></pre>

<p>as long as <code>random_unsigned_int()</code> is an uniform pseudorandom number generator that returns <code>unsigned int</code>s, from <code>0</code> to <code>UINT_MAX</code>, inclusive.</p>
",,,
53956901,2,53956408,2018-12-28T10:18:29.990,1,,2429333,,2018-12-28T10:18:29.990,,0,,"<p>There are two problems with your code, first:</p>

<pre><code>...
// master side
char c=Wire.read();
...
// slave side            
Wire.write(analogRead(i));
</code></pre>

<p>you are treating integer values as if they were <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> encoded, they are not. You have to convert them to ASCII at some point (e.g. master side). Consider using <code>sscanf</code> or <code>snprintf</code> for conversion.  </p>

<p>Second, you are not <a href=""https://en.wikipedia.org/wiki/Null-terminated_string"" rel=""nofollow noreferrer"">NUL terminating</a> a C string. </p>
",,,
53979983,2,53978811,2018-12-30T17:47:02.320,2,,7380779,,2018-12-30T17:47:02.320,,1,,"<p>an example of what you want, i have used simple functions to easy understant the program, i am using LED_BUILTIN wich is the led 13 of arduino uno or mega</p>

<pre><code>unsigned long currentMillis;
unsigned long previousMillis = 0;
unsigned long interval;
int Compteur = 1;
int ledState = HIGH;
int state = 0;

void setup(){
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); // i begin with HIGH during 125ms
  interval = 125;
  previousMillis = 0;
}

// Main loop
void loop() {
  currentMillis = millis(); 
  if (currentMillis - previousMillis &gt;= interval) {

    previousMillis = currentMillis;
    switch (state) {
      case 0:
        ledState = LOW;
        interval = 75;
        state = 1;
        break;
      case 1:
        ledState = HIGH;
        interval = 125;
        state = 2; 
        break;
      case 2:
        ledState = LOW;
        interval = 500;
        state = 3; 
        break;
      case 3:
        ledState = HIGH;
        interval = 125;
        state = 0;
        Compteur++; // count the number of beginning new sequence         
        break;            
      default:
      // statements
      break;
    }
    digitalWrite(LED_BUILTIN, ledState);
  }
}
</code></pre>
",,,
53980940,2,53978811,2018-12-30T19:54:03.807,1,,10659910,,2018-12-30T19:54:03.807,,1,,"<p>If all you need to do is repeat that same pattern you might be able to do it a bit more simply... </p>

<pre><code>unsigned long on = 125;
unsigned long shortOff = 75;
unsigned long longOff = 500;

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(on);   
  digitalWrite(LED_BUILTIN, LOW);
  delay(shortOff);
  digitalWrite(LED_BUILTIN, HIGH);
  delay(on);
  digitalWrite(LED_BUILTIN, LOW);
  delay(longOff);
}
</code></pre>

<p>If you need to do something else 'concurrently' then <a href=""https://stackoverflow.com/questions/53978811/c-arduino-flash-led-different-intervals/53979983#53979983""> the answer by Frenchy </a> would be better.</p>
",,,
53981648,2,53980112,2018-12-30T21:41:36.977,7,,50617,,2019-01-01T08:24:48.880,2019-01-01T08:24:48.880,0,,"<p>This appears to be a bug in GLIBC.</p>

<p>The reason that <code>printf(""simple string"")</code> works differently from <code>printf(""foo %d"", 123)</code> is that GCC transforms the former into a <code>puts</code>, with the notion that they are equivalent.</p>

<p>As far as I can tell, they <em>should</em> be equivalent. <a href=""http://man7.org/linux/man-pages/man3/puts.3.html"" rel=""noreferrer"">This man page</a> states that <code>puts</code> outputs to <code>stdout</code>, just like <code>printf</code> does.</p>

<p>However, in GLIBC <code>printf</code> outputs to <code>stdout</code> <a href=""https://sourceware.org/git/?p=glibc.git;a=blob;f=stdio-common/printf.c;h=ea41dd557c9c04d16014f69ae709bbc7d5ac7581;hb=HEAD#l33"" rel=""noreferrer"">here</a>, but <code>puts</code> outputs to <code>_IO_stdout</code> <a href=""https://sourceware.org/git/?p=glibc.git;a=blob;f=libio/ioputs.c;h=c9967c3883b303979c9a184a1e928345d6dcf3c5;hb=HEAD#l40"" rel=""noreferrer"">here</a>, and these are <em>not</em> equivalent. <a href=""https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=761300"" rel=""noreferrer"">This has already been reported as a glibc bug</a> <a href=""https://sourceware.org/bugzilla/show_bug.cgi?id=24051"" rel=""noreferrer"">(upstream bug).</a></p>

<p>To work around this bug, you could build with <code>-fno-builtin-printf</code> flag. That prevents GCC from transforming <code>printf</code> into <code>puts</code>, and on my system produces:</p>

<pre><code>$ ./a.out
my_write_func received 126 bytes
Text is: ""This is a long string, fprintf'd to stdout
Hello world, this is a printf with a digit: 123
Hello world, this is plain printf.
""
</code></pre>

<p>This workaround is of course incomplete: if you call <code>puts</code> directly, or link in object files that call <code>printf(""simple string"")</code> and were <em>not</em> compiled with <code>-fno-builtin-printf</code> (perhaps from 3rd-party library), then you'll still have a problem.</p>

<p>Unfortunately you can't assign to <code>_IO_stdout</code> (which is a macro). The only other thing you could do (that I can think of) is link in your own <code>puts</code>, which just returns <code>printf(""%s"", arg)</code>. That should work if you are linking against <code>libc.so.6</code>, but may cause trouble if you link against <code>libc.a</code>.</p>
",,,
54031373,2,53984567,2019-01-03T23:49:43.020,0,,1269208,,2019-01-03T23:49:43.020,,0,,"<p>So, it appears that for my situation, I am converting individual bytes read from a UART to an integer</p>

<pre><code>char data[3]  = {0};
data[0] = 0x01
data[1] = 0x02
data[2] = 0x03

ParseData(data);

void ParseData(uint8_t * data)
{
    uint32_t val = (data[0] * 100) + (data[1] * 10) + data[2];
    ESP_LOGI(LOG_TAG, "" val # %i "", val);
} 
</code></pre>
",,,
54032248,2,54008315,2019-01-04T02:00:45.327,0,,6879826,,2019-01-04T02:08:17.800,2019-01-04T02:08:17.800,0,,"<p>Note that with <code>fprint(""%0.2f"",123/10)</code> OP code has undefined behavior due to a mismatch between the <code>double</code> type expected by the <code>%f</code> conversion specifier and the <code>int</code> value <code>123/10</code>.</p>

<p>Integer division is well-defined and does not suffer from rounding errors. The C Standard Library provides the <a href=""https://port70.net/~nsz/c/c11/n1570.html#7.22.6.2"" rel=""nofollow noreferrer""><code>div(), ldiv(), and lldiv()</code></a> functions to compute integer division and remainder values in a single operation, so why not take advantage?</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    for (int i = 0; i &lt; 1010; i += 500) {
        for (int j = 0; j &lt; 10; j++) {
            int num = i + j;
            div_t val = div(num, 10);
            printf(""%d --&gt; %d.%d\n"", num, val.quot, val.rem);
        }
    }

    return 0;
}
</code></pre>

<p>Program output:</p>

<pre class=""lang-none prettyprint-override""><code>0 --&gt; 0.0
1 --&gt; 0.1
2 --&gt; 0.2
3 --&gt; 0.3
4 --&gt; 0.4
5 --&gt; 0.5
6 --&gt; 0.6
7 --&gt; 0.7
8 --&gt; 0.8
9 --&gt; 0.9
500 --&gt; 50.0
501 --&gt; 50.1
502 --&gt; 50.2
503 --&gt; 50.3
504 --&gt; 50.4
505 --&gt; 50.5
506 --&gt; 50.6
507 --&gt; 50.7
508 --&gt; 50.8
509 --&gt; 50.9
1000 --&gt; 100.0
1001 --&gt; 100.1
1002 --&gt; 100.2
1003 --&gt; 100.3
1004 --&gt; 100.4
1005 --&gt; 100.5
1006 --&gt; 100.6
1007 --&gt; 100.7
1008 --&gt; 100.8
1009 --&gt; 100.9
</code></pre>
",,,
54158227,2,54057193,2019-01-12T09:22:07.210,1,,1098827,,2019-01-12T09:22:07.210,,0,,"<p>While I realize you say you want a global object shared between a library and your private libraries, I am going to assert that is not the best design pattern as it is brittle and error-prone (as you are experiencing). A better approach is to pass the <code>SysLog</code> object you create in your main code as an argument to any method that needs it. The reason this is better is because you are explicitly declaring then what methods can and should use the <code>Syslog</code> object.</p>

<p>However, if you really must have a global variable, the second best pattern is to use a accessor class that looks something like this:</p>

<p><strong>SysLogHelper.h</strong></p>

<pre><code>#ifndef __SysLogHelper_h__
#define __SysLogHelper_h__

#include &lt;Syslog.h&gt;

class SysLogHelper {
private:
    Syslog *_instance;

public:
    static Syslog&amp; instance( void );

    Syslog();
    virtual ~Syslog()
}
#endif // __SysLogHelper_h__
</code></pre>

<p><strong>SysLogHelper.cpp</strong></p>

<pre><code>#include ""SysLogHelper.h""

SysLogHelper gSysLogHelper();

Syslog&amp; SysLogHelper::instance( void ) {
    return gSysLogHelper._instance;
}

SysLogHelper::SysLogHelper() {
    _instance = Syslog(SyslogUDP, ""255.255.255.255"", 514, ""FlyballETS"", ""FlyballETSApp"", LOG_INFO, SYSLOG_PROTO_BSD);
}

SysLogHelper::~SysLogHelper() {
    delete _instance;
}
</code></pre>

<p>Then anywhere in your code you want to use the <code>SysLog</code> object, simply include the <code>SysLogHelper.h</code> header, and use your <code>SysLog</code> instance by calling the static method, something like this:</p>

<pre><code>#include ""SyslogHelper.h""
void GPSHandlerClass::init(HardwareSerial * SerialPort)
{
   SyslogHelper::instance().logf_P(""GPS Class initialized!"");
}
</code></pre>

<p>Feel free to rename things to your preference. Also, with some creativity, you can have more than one <code>SysLog</code> object in this accessor class, each configured differently.</p>
",,,
54060068,2,54060022,2019-01-06T09:03:49.207,0,,440558,,2019-01-06T09:24:56.047,2019-01-06T09:24:56.047,6,,"<p>First of all I recommend that you simply <em>clear</em> <code>PORTB</code> first. Then you can easily set just the bits you need to be set.</p>

<p>As for the big <code>if...else if</code> chain, you could shift down the value of <code>PIND</code> four bits, and complement it.</p>

<p>Something like:</p>

<pre><code>// Clear all bits (and turn off all LEDs)
PORTB = 0;

// Move the four high bits of PIND to the four lowest,
// gets the bitwise complement of that, and set those bits
// (Turning on some LEDs)
PORTB |= ~(PIND &gt;&gt; 4);
</code></pre>

<hr>

<p>Of course, you you can still use your current way to turn on/off the LEDs (but still without the long <code>if ... else if</code> chain):</p>

<pre><code>PORTB |= ~(PIND &gt;&gt; 4);
PORTB &amp;= ~(PIND &gt;&gt; 4);
</code></pre>
",,,
54073567,2,54060022,2019-01-07T11:30:50.003,0,,584518,,2019-01-07T11:30:50.003,2020-06-20T09:12:55.060,0,,"<p>This is not correct code and it could be done in easier and more readable ways.</p>
<ul>
<li><p>You should get rid of the binary notation as it is hard to read and not actually C standard.</p>
</li>
<li><p>You should only read hardware registers once and write to them once. Accessing the same register in a long <code>if else if</code> chain  as done here is a big no-no. The state of the port might change between reads.</p>
</li>
<li><p>When dealing with any form of switches, be it physical buttons, dip-switches, relays etc, you must absolutely implement some manner of <em>signal de-bouncing</em>. A button, when pressed, has an electromechanical bounce, which manifests itself as a spike on the line until it goes stable. You can view this with an oscilloscope by connecting one side of a button to supply through a resistor, and the other side to ground.</p>
<p>Failing to de-bounce such a signal is a very common embedded beginner mistake. It is most often done in software, by reading the button several times before making a decision. Alternatively through a RC filter in hardware, but that costs extra components.</p>
</li>
</ul>
<p>You should have code like this:</p>
<pre><code>#define LED0 (1u &lt;&lt; 0) // corresponding to PORTx:0
#define LED1 (1u &lt;&lt; 1) // corresponding to PORTx:1
...
</code></pre>
<p>Then you can declare an output matrix such as this:</p>
<pre><code>const uint8_t LED_OUTPUT [16] = 
{
  [0] = LED1 | LED2 | LED3,
  [1] = LED0 | LED2 | LED3,
  ...
};
</code></pre>
<p>Input is read from PIND once, debounced through a periodic read, possibly with a simple digital filter (like median of 3 reads), then shifted in place (right shift 4 steps) so it corresponds to a number 0 to 15:</p>
<pre><code>uint8_t index = get_buttons(); // function that returns the debounced valued read from PIND
PORTB = LED_OUTPUT[index];
</code></pre>
<p>And that's it.</p>
",,,
54066185,2,54065822,2019-01-06T21:39:00.163,3,,2670348,,2019-01-06T21:39:00.163,,1,,"<p>I'm just going to address the <code>i2s_read()</code> issue since <code>i2s_pop_sample()</code> is deprecated.</p>

<p>The way you're calling <code>i2s_read()</code>, you're using a pointer as a data buffer and passing an integer as a pointer.</p>

<p>Here's the prototype of <code>i2c_read()</code> taken from the <a href=""https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/i2s.html#_CPPv28i2s_read10i2s_port_tPv6size_tP6size_t10TickType_t"" rel=""nofollow noreferrer"">ESP-IDF manual</a>.</p>

<pre><code>esp_err_t i2s_read(i2s_port_ti2s_num, void *dest, size_t size, size_t *bytes_read, TickType_t ticks_to_wait)
</code></pre>

<ul>
<li><code>i2s_num</code> is the i2s port number</li>
<li><code>dest</code> is the address of the buffer to read the data into</li>
<li><code>size</code> is the size of the buffer</li>
<li><code>bytes_read</code> is a pointer to a <code>size_t</code> which will have the number of bytes read written to it</li>
<li><code>ticks_to_wait</code> is a timeout</li>
</ul>

<p>There are two problems with the arguments you passed to <code>i2s_read()</code>. You're calling it this way:</p>

<pre><code>int *samples;
int s;
samples = &amp;s;

i2s_read(I2S_NUM,&amp;samples,4,4,2); 
</code></pre>

<p>You're passing <code>&amp;samples</code> as the address of the buffer. So what you're telling <code>i2s_read()</code> is to read 4 bytes of data and store them in <code>samples</code>, which doesn't make a lot of sense since it's a pointer. You should just pass <code>&amp;s</code> as the buffer and skip mucking about with <code>samples</code>.</p>

<p>The second problem is you're passing <code>4</code> as the <code>bytes_read</code> argument. I'm actually surprised this even compiled. This makes <code>i2s_read()</code> attempt to store a <code>size_t</code> with the number of bytes read at address 4, which will certainly cause some kind of exception.</p>

<p>Try this:</p>

<pre><code>int32_t sample;
size_t bytes_read;

i2s_read(I2S_NUM, &amp;sample, 4, &amp;bytes_read, 2); 
</code></pre>

<p>This:</p>

<ol>
<li>makes no assumption about the storage size of <code>int</code> and guarantees a 4 byte (32 bit) integer for <code>sample</code></li>
<li>correctly passes a pointer to the 4 byte integer created to hold the data read by <code>i2s_read()</code></li>
<li>correctly passes a pointer to a <code>size_t</code> so that <code>i2s_read()</code> can store the number off bytes it read.</li>
</ol>

<p>And if you want to know how many bytes were actually read, that's in <code>bytes_read</code>.</p>
",,,
54066668,2,54066235,2019-01-06T22:55:43.187,0,,2684539,,2019-01-06T22:55:43.187,,1,,"<p>Pass directly functor to your class:</p>

<pre><code>template &lt;class F&gt;
class MillisTimer
{
private:
    F mF;
    const uint16_t mDelayTime;
    unsigned long mPreviousTime = 0;
    const bool mDebugMode;

public:
    MillisTimer(F f, uint16_t delayTime, bool debugMode = false) :
        f(f), mDelayTime(delayTime), mPreviousTime(millis()), mDebugMode(debugMode)
    {
    }

    void run() {
        if (millis() - mPreviousTime &gt;= mDelayTime)
        {
            if (mDebugMode) {
                Serial.println(""uId: "" + String((unsigned long)this)
                               + "" millis: "" + String(millis() + ""ms""));
            }
            mPreviousTime = millis();
            mF();
        }
    }
};

template &lt;typename F&gt;
MillisTimer&lt;F&gt; MakeMillisTimer(F f, uint16_t delayTime, bool debugMode = false)
{
    return {f, delayTime, debugMode};
}
</code></pre>

<p>With usage:</p>

<pre><code>auto MT_measureAndWrite = MakeMillisTimer(&amp;measureAndWrite, 1000);
auto MT_LCDrefresh =  = MakeMillisTimer([](){ LCDrefresh(1.5, 2.5, 3.5, 4, 5); }, 500);
</code></pre>
",,,
54092518,2,54092429,2019-01-08T13:07:52.620,2,,3233393,,2019-01-08T13:07:52.620,,0,,"<p>Detecting whether a function can be called is a piece of cake when you use <code>decltype</code> for the SFINAE check:</p>

<pre><code>template &lt;typename... ARGS&gt;
auto print(const ARGS &amp;... args) -&gt; decltype(this-&gt;serial-&gt;print(args...)) {
    if (serial != NULL) {
        return this-&gt;serial-&gt;print(args...);
    }
    return 0;
}
</code></pre>
",,,
54092534,2,54092429,2019-01-08T13:08:39.227,0,,2684539,,2019-01-08T13:08:39.227,,0,,"<p>Syntax for variadic template expension is</p>

<pre><code>template &lt;typename... ARGS&gt;
size_t print(const ARGS&amp;... args) {
    if (serial != nullptr) {
        return this-&gt;serial-&gt;print(args...);
    }
    return 0;
}
</code></pre>

<p>to make it SFINAE friendly, you might use:</p>

<pre><code>template &lt;typename... ARGS&gt;
auto print(const ARGS&amp;... args) -&gt; decltype(this-&gt;serial-&gt;print(args...))
{
    if (serial != nullptr) {
        return this-&gt;serial-&gt;print(args...);
    }
    return 0;
}
</code></pre>
",,,
54093107,2,54092429,2019-01-08T13:41:11.677,0,,794749,,2019-01-08T13:41:11.677,,0,,"<p>Since you want the same interface as <code>HardwareSerial</code>, with all the <code>print</code>, <code>println</code> and <code>write</code> methods, your <code>Logger</code> class should inherit from <code>Print</code> and then only implement the <code>write(uint8_t)</code> method that only calls <code>HardwareSerial</code>s <code>write(uint8_t)</code>.</p>

<pre><code>class Logger : public Print {
    public:
        virtual size_t write(uint8_t);
}
</code></pre>



<pre><code>size_t Logger::write(uint8_t c) {
    if (this-&gt;serial != NULL) {
       return this-&gt;serial-&gt;write(c);
    }
    return 0;
}
</code></pre>

<p>More on <code>Print</code> class: <a href=""https://playground.arduino.cc/Code/Printclass"" rel=""nofollow noreferrer"">https://playground.arduino.cc/Code/Printclass</a></p>
",,,
54111184,2,54110906,2019-01-09T13:23:42.637,5,,669576,,2019-01-09T13:23:42.637,,3,,"<p>You need to put the words into an array:</p>

<pre><code>const char *words[] = {""aye"", ""sup"", ""boi"", ""bruv""};
</code></pre>

<p>Then pick a random index and send the word at that index:</p>

<pre><code>// Calculate the number of words. Better than hardcoding
// 4. If you add/remove words from array, this code
// won't have to change
int num_words = sizeof(words) / sizeof(words[0]);
randnumber = random(0, num_words);
Serial.println(words[randnumber]);
</code></pre>

<p>You should also seed the RNG else you will get the same results each time. On a PC, people often seed the RNG with the current time, but there is no clock on the Arduino so it is more difficult. Here's a good discussion on that: <a href=""https://arduino.stackexchange.com/questions/50671/getting-a-truly-random-number-in-arduino"">Getting a truly random number in Arduino</a>. </p>
",,,
54176821,2,54173340,2019-01-14T06:46:45.323,0,,1089763,,2019-01-14T13:05:52.663,2019-01-14T13:05:52.663,4,,"<p>Does the <code>Serial.println(RED)</code> always print out the expected value?
Your <code>if-else</code>block itself does not seem to be problematic at first glance. It doesn't matter if you use <code>||</code> or <code>or</code>. They are equivalent.
The problem is the way you are checking the value:</p>

<p>Therefore that you have parenthesis around your OR statement, you create a bool-value. <code>if(RED==(A || JVCfront)</code> translates to:</p>

<ul>
<li>is <code>A</code> set or is <code>JVCfront</code> set; meaning, are they != 0 (yes they both are, so this expression is <code>true</code></li>
<li>is <code>RED == true</code> (no it is not, because <code>true</code> represents <code>1</code> in integer)</li>
<li>so the code in that block is not being executed</li>
</ul>

<p>If you want to solve it with an if-else, you need to:</p>

<pre><code>if(RED == A or RED == JVCfront)
{
    _mForward();
}
</code></pre>

<p>Anyway, I would suggest a switch-case statement:</p>

<pre><code>switch(RED):
{
    case A:
    {
        //intentional fallthrough
    }
    case JVCfront:
    {
        _mForward();
        break;
    }
    case B:
    {
        //intentional fallthrough
    }
    case JVCback:
    {
        _mBack();
        break;
    }
    case C: 
    {
        //intentional fallthrough
    }
    case JVCleft:
    {
        _mleft();
        break;
    }
    case D:
    {
        //intentional fallthrough
    }
    case JVCright:
    {
        _mright();
        break;
    }
    case X:
    {
        //intentional fallthrough
    }
    case JVCstop:
    {
        //intentional fallthrough
    }
    case JVCmenu:
    {
        //intentional fallthrough
    }
    case JVC3ok:
    {
        _mStop();
        break;
    }
    default:
    {
        _mStop();
    }
}
</code></pre>

<p>I personally find this kind of code much easier to read, and more understandable.
Please note: If you dont put a <code>break</code> into a case, it automatically executes the next <code>case</code> as well. This is why I wrote <code>//intentional fallthrough</code> in this part of the code. P.e. when <code>case A</code> is executed, nothing happens. It just falls through into <code>case JVCFront</code> and executes everything there.</p>
",,,
54184325,2,54183908,2019-01-14T15:23:26.003,2,,9632774,,2019-01-14T15:23:26.003,,0,,"<pre><code>byte HexCharToByte(char c) {
    if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
        return c - '0';
    } else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
        return c - 'A' + 10;
    } else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
        return c - 'a' + 10;
    }
}

void TransformMac(char input[6][2], byte output[6]) {
    for (int i = 0; i &lt; 6; ++i) {
        output[i] = (HexCharToByte(input[i][0]) &lt;&lt; 4) | HexCharToByte(input[i][1]); 
    }
}
</code></pre>
",,,
54206070,2,54189535,2019-01-15T20:03:13.073,0,,501717,,2019-01-15T20:03:13.073,,0,,"<p>I solved it by adding a virtual method that is overridden in every class that needs the Type-identification. For ease of coding I defined the code that should be repeated in every class in a single #define.</p>

<p>Any suggestions for improvement are welcome</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

static type_id generateId()
{
  static int typeID; // automatically init with 0
  return ++typeID;
}

template &lt;typename T&gt;
struct MetaTypeInfo
{
  static int getTypeInfo()
  {
    static const int typeID = generateId();
    return typeID;
  };
};

#define TYPEINFO(T)                               \
  static int getClassTypeId() {                   \
        return typeinfo.getTypeInfo();            \
    }                                             \
    virtual int getTypeId() {                     \
        return typeinfo.getTypeInfo();            \
    }                                             \
    static MetaTypeInfo&lt;T&gt; typeinfo


class ClassA {
public:
    virtual ~ClassA() {};
    TYPEINFO(ClassA);
    int i = 0;
};

class ClassB: public ClassA {
public:
    virtual ~ClassB() {};
    TYPEINFO(ClassB);
};

int main()
{
   ClassA a;
   ClassB b;
   ClassA* b2 = new ClassB();

   cout &lt;&lt; ""A: "" &lt;&lt; ClassA::getClassTypeId()       &lt;&lt; endl;
   cout &lt;&lt; ""B: "" &lt;&lt; ClassB::getClassTypeId()       &lt;&lt; endl;
   cout &lt;&lt; ""a: "" &lt;&lt; a.getTypeId() &lt;&lt; endl;
   cout &lt;&lt; ""b: "" &lt;&lt; b.getTypeId() &lt;&lt; endl;
   cout &lt;&lt; ""b2: "" &lt;&lt; (b2)-&gt;getTypeId() &lt;&lt; endl;

   return 0;
}
</code></pre>

<p>The output of this is:</p>

<pre><code>$main
A: 1
B: 2
a: 1
b: 2
b2: 2
</code></pre>
",,,
54205088,2,54203672,2019-01-15T18:46:14.880,0,,5127698,,2019-01-15T18:46:14.880,,0,,"<p>The <code>read</code> system call is not guaranteed to return the number of bytes requested. See <a href=""http://man7.org/linux/man-pages/man2/read.2.html"" rel=""nofollow noreferrer"">this</a> link for a full reference.</p>

<p>If <code>read</code> returns a non-negative value this value indicates the amount of bytes read, in your case 960 bytes.</p>

<p>To make sure that all bytes are read successfully you will need to put the call to <code>read</code> inside some form of loop. Perhaps something similar to this:</p>

<pre><code>char buffer[4000 + 1]; /* +1 to leave space for null-terminator */

memset(buffer, 0, sizeof(buffer)); /* Clear buffer */

size_t bytesToRead = 4000;
size_t bytesRead = 0;
while (bytesToRead &gt; 0)
{
    const ssize_t retVal = read(fd, buffer + bytesRead, bytesToRead);
    if (retVal &lt; 0)
    {
        /* Handle error */
    }

    const size_t bytes = (size_t) retVal;
    bytesRead += bytes;
    bytesToRead -= bytes;
}
</code></pre>
",,,
54213006,2,54208786,2019-01-16T08:33:02.883,0,,9247896,,2019-01-16T08:33:02.883,,1,,"<p>HC-05/HC-06 takes the string like a sequence of character. If you want to send 255 then HC-05 takes it like '2','5','5'. So your first work is determining whether it is an integer or string.
I have added the different prefix before the integer and the string and a common postfix('#') by which I can determine the end of the input. Hopefully, this helps you.</p>

<pre><code>while (Serial.available()) {

delay(3);  //small delay to allow input buffer to fill

char c = Serial.read();  //gets one byte from serial buffer
if (c == '#') {
  break;
}  //breaks out of capture loop to print readstring
readString += c;
}
</code></pre>

<p>After taking all the bit now you have to figure out what you have taken with the help of the prefix.</p>

<pre><code>if (readString.charAt(0) == 'i')
{
 //""i255,255,255#""
readString.replace(""i"", ""0"");
value1 = readString.substring(1, 3).toInt();
value2 = readString.substring(5, 7).toInt();
value3 = readString.substring(8, 11).toInt();

readString = """";

}
else if (readString.charAt(0) == 's')
{
 //Do as you wish
readString = """";
}
</code></pre>
",,,
54212706,2,54212549,2019-01-16T08:10:59.063,0,,2589553,,2019-01-16T08:14:21.930,2019-01-16T08:14:21.930,3,,"<p>What you are trying to do is to assign a string literal to a <code>char *</code> pointer -- that is bad (see more at <a href=""https://stackoverflow.com/questions/59670/how-to-get-rid-of-deprecated-conversion-from-string-constant-to-char-warnin"">How to get rid of <code>deprecated conversion from string constant to ‘char*’</code> warnings in GCC?</a>). Here is an possible approach:</p>

<pre><code>#define MAX_NAME_LEN 128
#define MAX_NICK_NAMES 10

struct widget_t {
    char name[MAX_NAME_LEN];
    uint8_t numberOfNicknames;
    char nicknames[MAX_NICK_NAMES][MAX_NAME_LEN];
};

widget_t SomeWidget;

void setUpFunction () {
    strcpy(SomeWidget.name, ""Lawn Mower"");
    SomeWidget.numberOfNicknames = 2;
    strcpy(SomeWidget.nicknames[0], ""Choppie McGrasschopper"");
    strcpy(SomeWidget.nicknames[1], ""Really Noisy"");
}
</code></pre>

<p>Anyway, since you tag your question with <code>C++</code> I would suggest you to use <code>std::string</code> and <code>std::vector</code> instead.</p>
",,,
54212771,2,54212549,2019-01-16T08:15:01.760,1,,9185797,,2019-01-16T09:49:47.273,2019-01-16T09:49:47.273,2,,"<p>The problem you have, is that <strong>c++</strong> does not support variable arrays. Instead you will have to allocate memory dynamically using <strong>new</strong> or in your case <strong>new[]</strong>.</p>

<p>First you need to change your data type to <code>char**</code>, almost equaliant to the one before. Then you can allocate as many strings you want like this <code>nicknames = new char*[number_of_nicknames]</code>.</p>

<p>Important is that with this method you will have to delte your nicknames manually like this: <code>delete[] nicknames;</code>. The best way to accomplish this is using RAII (delete your nicknames in your deconstructor)</p>

<p>When you have dynamic strings then you would use the following structure</p>

<pre><code>struct widget_t {
    // optional constructor to allocate nicknames

    ~widget_t()
    {
        for (int i = 0; i &lt; numberOfNicknames; ++i)
        {
            char* nickname = nicknames[i];

            if (nickname)
                delete[] nickname;
        }

        delete[] nicknames;
    }

    char *name;
    uint8_t numberOfNicknames;
    char **nicknames = NULL;
};
</code></pre>

<p>and with constant string the next</p>

<pre><code>struct widget_t {
    // optional constructor to allocate nicknames
    // allocate nicknames like
    // -&gt; nicknames = new const char*[numberOfNicknames];

    ~widget_t()
    {
         if (nicknames) delete[] nicknames;
    }

    char *name;
    uint8_t numberOfNicknames;
    const char **nicknames = NULL;
};
</code></pre>
",,,
54213449,2,54212549,2019-01-16T08:59:56.807,0,,1505939,,2019-01-16T08:59:56.807,,0,,"<p>One option would be:</p>

<pre><code>struct widget_t {
    char const *name;
    uint8_t numberOfNicknames;
    char const * const *nicknames;
};

static char const *mower_nicknames[] = { ""Choppie"", ""Bob"" };
widget_t SomeWidget = { ""Lawn Mower"", 2, mower_nicknames };

static char const *bus_nicknames[] = { ""Wheels"", ""Go"", ""Round"" };
widget_t OtherWidget = { ""Bus"", 3, bus_nicknames };

// no setup function needed
</code></pre>
",,,
54214234,2,54212549,2019-01-16T09:46:16.150,0,,3545273,,2019-01-16T09:46:16.150,,0,,"<p>There are different problems here.</p>

<p>First your last member in of an incomplete type because it is an array of undeclared dimension. This is not allowed in C++ but most compilers allows it as an extension with same semantics as C. This is rather tricky to use anyway, because it can only be used with allocated structs, where you allocate  memory for the struct itself <strong>and</strong> the incomplete array.</p>

<p>Next, you are trying to <em>assign</em> to a array. You cannot. Arrays are not first class objects in C++ (nor in C). You can initialize an array as a whole, but can only assign to an array element.</p>

<p>And last, you are assigning a C litteral string to a <code>char *</code>. This is bad, because the standard declares that litteral strings are <code>const</code> so using later the pointer to change a char would be Undefined Behaviour. It will work if you do not, but the pointers should at least be declared as <code>const</code>.</p>

<p>Here is how you could use all that:</p>

<pre><code>widget_t* setUpFunction () {
    // allocates a widget_t with 2 slots in nicknames
    widget_t *someWidget = (widget_t *) malloc(sizeof(widget_t) + 2 * sizeof(char *));
    someWidget.name = (char *)""Lawn Mower"";   // VERY DANGEROUS: pointer should be const
    someWidget.numberOfNicknames = 2;
    someWidget.nicknames[0] = (char *) ""Choppie McGrasschopper""; // SAME DANGER
    someWidget.nicknames[1] = (char *) ""Really Noisy""            // Still same danger
    return widget_t;
}
</code></pre>

<p>But all this is rather C-ish and should be avoided in C++. In addition, it still requires allocated memory, which may not be what you want for Arduino</p>
",,,
54216359,2,54216231,2019-01-16T11:43:53.217,0,,2079303,,2019-01-16T11:43:53.217,,0,,"<p>Besides being ill-formed, your macro isn't useful for what you want because you're calling <code>create_foo</code> on each invocation.</p>

<p>You can use static variables:</p>

<pre><code>void loop() {
    static Foo f1, f2;
    some_func(3, f1);
    some_func(40, f2);
}
</code></pre>
",,,
54217062,2,54216231,2019-01-16T12:26:29.497,0,,6387170,,2019-01-16T12:26:29.497,,0,,"<p>The first thing to note, is that your state is a boolean.  This will save you a few bytes of RAM.</p>

<p>The next thing to point out is that you want to ignore changes to the input for a period of time; this means you don't need to store the ""current"" state; just the last state... which will end up being the same.  This might not save you anything, since the 2 booleans and 1 boolean will likely just take a byte; but it gives the compiler a chance, and most importantly, makes things simpler.</p>

<p>With those 2 fairly minor improvements made, we get to the bigger ones.  Don't use macros unless you really know what you're doing; and even then reconsider.</p>

<p>Arduino example code tends to offer them because someone thought it would make it easier to learn; but honestly, they don't.  They're not a function, and your usage of it really isn't doing what you think it's doing.  Arduino offer limited ways to debug it, so you can't actually tell that your state will ALWAYS be high, because the macro expansion is this:</p>

<pre><code>int state = true; 
for(static auto d = create_debounce(); 
    debounce(d, val), 
    false;);
//New lines added for clarity.
</code></pre>

<p>Move it to a function; let the compiler optimise the code because it will <em>ALWAYS</em> do a better job than you as long as you write the code in a way that lets it.</p>
",,,
54225237,2,54225045,2019-01-16T20:55:15.417,1,,4593267,,2019-01-18T07:08:53.620,2019-01-18T07:08:53.620,8,,"<p>Q1) your version of <code>atoi()</code> is too simple, the standard version ignores leading whitespace characters and handles an optional sign before the number. <code>atoi("" -123junk"")</code> should evaluate to <code>-123</code>.</p>

<p>Q2) <code>atoi</code> is a standard function defined with the prototype <code>int atoi(const char *s);</code> it returns an integer.</p>

<p>Q3) There are a few mistakes in <code>Code 2</code>:</p>

<ul>
<li>you specify the size of the <code>char</code> array <code>s</code> as <code>i</code>, which is uninitialized. you should instead define the array with a reasonably large value such as <code>64</code>,</li>
<li>you should test for potential buffer overflow in the loop,</li>
<li>you should check for <code>EOF</code> to stop the loop in case end of file is encountered without a newline.</li>
</ul>

<p>Here is a modified version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    char s[64];
    size_t i;
    int c;
    for (i = 0; i &lt; sizeof(s) - 1 &amp;&amp; (c = getchar()) != EOF;) {
       s[i++] = c;
       if (c == '\n')
           break;
    }
    s[i] = '\0';
    printf(""%i"", atoi(s));
    return 0;
}
</code></pre>

<p>Q4) the expression <code>n = 10 * n + (s[i] - '0')</code> is evaluated for each new digit found in the string. It is indeed slightly inefficient to multiply the current value by 10 as long as no non-zero digit has been encountered, but writing the function this way is simple.</p>

<p>To avoid these useless multiplications, here is an alternative:</p>

<pre><code>int atoi(const char *s) {
    int n = 0;
    size_t i = 0;

    while (s[i] == '0')
        i++;
    if (s[i] &gt;= '1' &amp;&amp; s[i] &lt;= '9') {
        n = s[i++] - '0';
        while (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')
            n = 10 * n + (s[i++] - '0');
    }
    return n;
}
</code></pre>

<p>But this function is more cumbersome and might actually be less efficient that the simple version. Try and benchmark both on your system.</p>

<p>For completeness, here is a full portable version using <code>ctype.h&gt;</code> that handles optional initial whitespace, and an optional sign. It also handles overflow with defined behavior, although the standard version of <code>atoi()</code> is not required to do so.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

int atoi(const char *s) {
    int n = 0, d;

    /* skip optional initial white space */
    while (isspace((unsigned char)*s))
        s++;
    if (*s == '-') {
        /* convert negative number */
        s++;
        while (isdigit((unsigned char)*s)) {
            d = (*s++ - '0');
            /* check for potential arithmetic overflow */
            if (n &lt; INT_MIN / 10 || (n == INT_MIN / 10 &amp;&amp; -d &lt; INT_MIN % 10)) {
                n = INT_MIN;
                break;
            }
            n = n * 10 - d;
        }
    } else {
        /* ignore optional positive sign */
        if (*s == '+')
            s++;
        while (isdigit((unsigned char)*s)) {
            d = (*s++ - '0');
            /* check for potential arithmetic overflow */
            if (n &gt; INT_MAX / 10 || (n == INT_MAX / 10 &amp;&amp; d &gt; INT_MAX % 10)) {
                n = INT_MAX;
                break;
            }
            n = n * 10 + d;
        }
    }
    return n;
}

int main(int argc, char *argv[]) {
    int i, n;

    for (i = 1; i &lt; argc; i++) {
        n = atoi(argv[i]);
        printf(""\""%s\"" -&gt; %d\n"", argv[i], n);
    }
    return 0;
}
</code></pre>
",,,
54257654,2,54250050,2019-01-18T16:12:12.580,0,,2670348,,2019-01-18T17:57:24.023,2019-01-18T17:57:24.023,0,,"<p><code>WiFi.localIP()</code> returns an <code>IPAddress</code>, not a <code>String</code> (see its <a href=""https://www.arduino.cc/en/Reference/WiFiLocalIP"" rel=""nofollow noreferrer"">reference page</a>). You need to turn it into a <code>String</code> before you concatenate anything to it.</p>

<p>So instead of:</p>

<pre><code>Serial.print(WiFi.localIP() + ""\n"");
</code></pre>

<p>You need</p>

<pre><code>Serial.print(String(WiFi.localIP()) + ""\n"");
</code></pre>

<p>Even better, use <code>String.println()</code> and avoid the concatenation and <code>String</code> object construction:</p>

<pre><code>Serial.println(WiFi.localIP());
</code></pre>

<p>This works because there are versions of the <code>print()</code> and <code>println()</code> methods which take an <code>IPAddress</code> as an argument and know how to convert it into text.</p>

<p>Similarly, <code>WiFi.macAddress()</code> fills a 6 byte array holding the MAC address of the WiFi interface and does return not a <code>String</code> (see its <a href=""https://www.arduino.cc/en/Reference/WiFiMACAddress"" rel=""nofollow noreferrer"">reference page</a>). You can't easily construct a <code>String</code> from it and the <code>print</code> methods won't know how to handle it. </p>

<p>So instead of:</p>

<pre><code>Serial.print(WiFi.macAddress() + ""\n"");
</code></pre>

<p>You'll need to do something like:</p>

<pre><code>byte mac_address[6];

WiFi.macAddress(mac_address);
Serial.printf(""%02x:%02x:%02x:%02x:%02x:%02x\n"",
               mac_address[0], mac_address[1], mac_address[2],
               mac_address[3], mac_address[4], mac_address[5]);
</code></pre>
",,,
54273915,2,54256634,2019-01-20T05:42:23.897,1,,8078317,,2019-01-20T05:42:23.897,,0,,"<p>I did a test and found out exactely what is happening here.</p>

<p>It is the issue with strtok, and also the fact that you are giving character arrays to all these string functions without space for a string dilimiter, ie '0'.</p>

<p>This is the test functio which I wrote on a computer to test stuff out</p>

<pre><code>void printAllObjects(int location,char *x, char* strtokIndx, char *gva_testDate,char *gva_testTime)
{
    printf(""At location %d\n x pointer %d, string %s\n""
            "" strtokIndx pointer %d, string %s\n ""
            ""gva_testDate pointer %d, string %s\n ""
            ""gva_testTime pointer %d, string %s\n "",location,x,x,strtokIndx,strtokIndx,gva_testDate,gva_testDate,gva_testTime,gva_testTime);
}
</code></pre>

<p>Then I copied all of your arduino code over to my computer commented out all serial commands, added the stdio header, and used the above funcition at several locations.</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;String.h&gt;
#include &lt;stdio.h&gt;

using namespace std;

/*
 * 
 */

char gva_logfile[24] = {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '};
char gva_testDate[6] = {'Y', 'Y', 'm', 'm', 'D', 'D'}; // is appending?
char gva_testTime[6] = {'H', 'H', 'M', 'M', 'S', 'S'}; 

char lva_testDate[6];

//String y = ""BATCH|190117;151442$"";
//int lan = y.length(); // should be 20

char x[] = ""BATCH|190117;151442$"";
int lan = strlen(x);
//y.toCharArray(x, lan);
//strcpy(x, y);
//y.toCharArray(x, 20);

//strcpy(x, ""BATCH|190117;151442$"");


void printAllObjects(int location,char *x, char* strtokIndx, char *gva_testDate,char *gva_testTime)
{
    printf(""At location %d\n x pointer %d, string %s\n""
            "" strtokIndx pointer %d, string %s\n ""
            ""gva_testDate pointer %d, string %s\n ""
            ""gva_testTime pointer %d, string %s\n "",location,x,x,strtokIndx,strtokIndx,gva_testDate,gva_testDate,gva_testTime,gva_testTime);
}

void setup() {
  // put your setup code here, to run once:
//  Serial.begin(9600);
//
//  Serial.print(""&lt;"");
//  for(int i=0; i&lt;6; i++){
//    Serial.print(gva_testDate[i]); // works
//    //Serial.print(gva_testTime[i]); // works
//  }
//  Serial.println(""&gt;""); 
}



void loop() {
  // put your main code here, to run repeatedly:
  char tele[6] = {' ', ' ', ' ', ' ', ' ', ' '};
  while(1){
    char flarb[lan];
    strcpy(flarb, x);
    //Serial.println(flarb);

    if(strstr(flarb, ""BATCH|"")){
      char * strtokIndx;
      printAllObjects(1,x,strtokIndx,gva_testDate,gva_testTime);
      strtokIndx = strtok(x, ""|"");
      printAllObjects(2,x,strtokIndx,gva_testDate,gva_testTime);
      //strcpy(tele, strtokIndx);     // did nothing?
      strtokIndx = strtok(NULL, "";"");
      printAllObjects(3,x,strtokIndx,gva_testDate,gva_testTime);
      strcpy(gva_testDate, strtokIndx); // missing?
      printAllObjects(4,x,strtokIndx,gva_testDate,gva_testTime);

//      Serial.println(gva_testDate); // Not missing
      for(int i=0; i&lt;6; i++){
        lva_testDate[i] = gva_testDate[i];  
      }      

      strtokIndx = strtok(NULL, ""$"");
      printAllObjects(5,x,strtokIndx,gva_testDate,gva_testTime);
      strcpy(gva_testTime, strtokIndx); // is fine...
      printAllObjects(6,x,strtokIndx,gva_testDate,gva_testTime);

//      Serial.println(gva_testDate); // MISSING
//      Serial.println(lva_testDate);

      if(strstr(gva_testDate, ""YYmmDD"")!=NULL || strstr(gva_testTime, ""HHMMSS"")!=NULL){
          //if((gva_testDate == ""YYmmDD"") || (gva_testTime == ""HHMMSS"")){  
          char io[28]; // 16 + 2*6
          sprintf(io, ""063 ERROR: %s,%s"", gva_testDate, gva_testTime);
          //logArdData(io);
//          Serial.print(""&lt;"");
//          Serial.print(io);
//          Serial.println(""&gt;"");
//          Serial.flush();
        }
        //else if((strstr(gva_testDate, ""YYmmDD"") &amp;&amp; strstr(gva_testTime, ""HHMMSS""))==NULL){
        else if((strstr(gva_testDate, ""YYmmDD"")==NULL &amp;&amp; strstr(gva_testTime, ""HHMMSS"")==NULL)){  
          //else if((gva_testDate != ""YYmmDD"") &amp;&amp; (gva_testTime != ""HHMMSS"")){  
          char io[26]; // 14 + 2*6

          //sendArdData(gva_testDate); // is combinined?
          //sendArdData(gva_testTime); // still itself

          sprintf(io, ""Assigned %s,%s"", gva_testDate, gva_testTime); // is combining testDate and testTime, then printing testTime?
//          Serial.print(""&lt;"");
//          Serial.print(io);
//          Serial.println(""&gt;"");
          //sendArdData(io);
          //logArdData(io);
//          Serial.flush();        
        }
    }
  }
}
int main(int argc, char** argv) {
    setup();
    printf(""Entering loop\n"");
    loop();
    return 0;
}
</code></pre>

<p>This is the output I got</p>

<pre><code>Entering loop
At location 1
 x pointer 199946368, string BATCH|190117;151442$
 strtokIndx pointer 0, string (null)
 gva_testDate pointer 199946344, string YYmmDDHHMMSS
 gva_testTime pointer 199946350, string HHMMSS
 At location 2
 x pointer 199946368, string BATCH
 strtokIndx pointer 199946368, string BATCH
 gva_testDate pointer 199946344, string YYmmDDHHMMSS
 gva_testTime pointer 199946350, string HHMMSS
 At location 3
 x pointer 199946368, string BATCH
 strtokIndx pointer 199946374, string 190117
 gva_testDate pointer 199946344, string YYmmDDHHMMSS
 gva_testTime pointer 199946350, string HHMMSS
 At location 4
 x pointer 199946368, string BATCH
 strtokIndx pointer 199946374, string 190117
 gva_testDate pointer 199946344, string 190117
 gva_testTime pointer 199946350, string 
 At location 5
 x pointer 199946368, string BATCH
 strtokIndx pointer 199946381, string 151442
 gva_testDate pointer 199946344, string 190117
 gva_testTime pointer 199946350, string 
 At location 6
 x pointer 199946368, string BATCH
 strtokIndx pointer 199946381, string 151442
 gva_testDate pointer 199946344, string 190117151442
 gva_testTime pointer 199946350, string 151442
</code></pre>

<p>Based on this data this is my conclusion.</p>

<p>The strtok funciton modifies the original string and replaces the search caracter with a null, then copies over the string to a new index and gives the index back.</p>

<p>strcpy is not doing anything to your code, you have written the buffer values in such a manner that it seems like strcpy is doing nasty things, but it is just doing what it is supposed to do. copying strings till it finds a null. In most cases it would screw things alot for you but not in this specific case.</p>

<p>As can be seen in the results, gva_testDate amd gva_testTime have a pointer difference of 6, as such when gva_testTime gets populated, if you use gva_testDate as a string, the null is seen only at the end of 12 characters.</p>

<p>Also lva_testDate is supposed to be a buffer for you, you need to give it a value to start with or it becomes a null buffer and might end up modifying differt things based on what the code is compiled to.</p>

<p>To solve the issue, I initialised all your variables as so, the output is printed below that.</p>

<pre><code>char gva_testDate[] = ""YYmmDD""; // is appending?
char gva_testTime[] = ""HHMMSS"";

char lva_testDate[20];

//String y = ""BATCH|190117;151442$"";
//int lan = y.length(); // should be 20

char x[] = ""BATCH|190117;151442$"";
int lan = strlen(x);
</code></pre>

<p>output</p>

<pre><code>Entering loop
At location 1
 x pointer 107077760, string BATCH|190117;151442$
 strtokIndx pointer 0, string (null)
 gva_testDate pointer 107077736, string YYmmDD
 gva_testTime pointer 107077743, string HHMMSS
 At location 2
 x pointer 107077760, string BATCH
 strtokIndx pointer 107077760, string BATCH
 gva_testDate pointer 107077736, string YYmmDD
 gva_testTime pointer 107077743, string HHMMSS
 At location 3
 x pointer 107077760, string BATCH
 strtokIndx pointer 107077766, string 190117
 gva_testDate pointer 107077736, string YYmmDD
 gva_testTime pointer 107077743, string HHMMSS
 At location 4
 x pointer 107077760, string BATCH
 strtokIndx pointer 107077766, string 190117
 gva_testDate pointer 107077736, string 190117
 gva_testTime pointer 107077743, string HHMMSS
 At location 5
 x pointer 107077760, string BATCH
 strtokIndx pointer 107077773, string 151442
 gva_testDate pointer 107077736, string 190117
 gva_testTime pointer 107077743, string HHMMSS
 At location 6
 x pointer 107077760, string BATCH
 strtokIndx pointer 107077773, string 151442
 gva_testDate pointer 107077736, string 190117
 gva_testTime pointer 107077743, string 151442
</code></pre>

<p>I hope this helps.</p>
",,,
54280832,2,54280655,2019-01-20T20:49:56.070,3,,2187015,,2019-01-20T20:49:56.070,,1,,"<p>Most likely you are having alignment optimization affecting your code. You should use something like this</p>

<pre><code>#pragma pack(push, 1) // one byte alignment
struct s1 {
  uint16_t v16;
  uint32_t v32;
};
struct s2 {
  uint16_t v16_1;
  uint16_t v16_2;
  uint16_t v16_3;
};
#pragma pack(pop)
</code></pre>

<p>also you can improve reads like in the below to not manually do everything</p>

<pre><code>myFile.read(&amp;structvar2, sizeof(structvar2));
</code></pre>
",,,
54289245,2,54280752,2019-01-21T11:42:18.807,1,,1714692,,2019-01-21T11:42:18.807,,1,,"<p>First of all you are reading the value of the pin into <code>level</code> then in the while loop you are re-reading it: why is that? Can't you do something like:</p>

<pre><code>// Wait for button being released
while (level == LOW) {
    delay(100);
}
</code></pre>

<p>?</p>

<p>Also don't you want to reassign the <code>btn2_t0 = t1;</code> even when the time was smaller than 700 ms? Like:</p>

<pre><code>t1 = millis();
if (t1 - btn2_t0 &lt; 700) {
  btn2_t0 = t1;  
  return;
}
</code></pre>

<p>The behaviour depends on how you built your electronic circuit: is the button-press suppose to make the pin high or low? Be sure about the behaviour is the one you are expecting by either connecting a led and a resistor or using a Voltmeter.</p>

<p>However since your Python code worked I am assuming the electronic is correct and your algorithm too.</p>

<p>Be sure of course you are pressing the button long enough. Add some prints to your code to understand which branches it is executing because when there is electronic involved it is difficult to understand only by the code. </p>

<p>While waiting for news from you, in my opinion is better to do the following: define the callback as: <code>INT_EDGE_BOTH</code> so that it got called when the bottom is pressed and when the button is released. You can keep the time elapsed with a static variable.</p>

<pre><code>void yourCallback()
{
    unsigned long ela, t;
    int level = digitalRead(BUTTON_2_PIN);
    static unsigned long button_pressed_timestamp;
    //if button pressed:
    if(level==LOW)
    {
      //start counting
      button_pressed_timestamp = millis();
    }
    else //button released
    {
       duration = millis()-button_pressed_timestamp;
       button_pressed_timestamp = millis(); //just to be sure....
       if (duration &gt; 5000) {
          printf(""Self destruction sequence initiated!\n"");
       }  
       else if (duration &gt; 700) {
          player_previous();
       }
       else {
          player_next();
       }
    }


}
</code></pre>
",,,
54312099,2,54296146,2019-01-22T16:02:17.403,0,,2785528,,2019-01-22T16:02:17.403,,0,,"<p>Here is a partial example of a uint24_t that you might port to your tools (I don't know the 'current' arduino's tool set)</p>

<pre><code>// Note: compile with -std=c++17 for the using comma list
//       or remove these and put the ""std::"" into code
#include &lt;algorithm&gt;
using std::swap;

#include &lt;iostream&gt;
using std::cout, std::cerr, std::endl, std::hex, std::dec, std::cin; // c++17

#include &lt;string&gt;
using std::string, std::to_string; // c++17

#include &lt;sstream&gt;
using std::stringstream;


class Uint24_t
{
public:
   Uint24_t() : data {0,0,0}
      {
         cout &lt;&lt; ""\n  sizeof(Uint24_t)= "" &lt;&lt; sizeof(Uint24_t) // reports 3 bytes
              &lt;&lt; "" bytes, * 8= "" &lt;&lt; (sizeof(Uint24_t) * 8) &lt;&lt; "" bits."" &lt;&lt; endl;
      }

   Uint24_t(uint32_t initVal) : data {0,0,0}
      {
         data[0] = static_cast&lt;uint8_t&gt;((initVal &gt;&gt;  0) &amp; 0xff); // lsbyte
         data[1] = static_cast&lt;uint8_t&gt;((initVal &gt;&gt;  8) &amp; 0xff); //
         data[2] = static_cast&lt;uint8_t&gt;((initVal &gt;&gt; 16) &amp; 0xff); // msbyte
         cout &lt;&lt; ""\n  sizeof(Uint24_t)= "" &lt;&lt; sizeof(Uint24_t) // reports 3 bytes
              &lt;&lt; "" bytes, * 8= "" &lt;&lt; (sizeof(Uint24_t) * 8) &lt;&lt; "" bits."" &lt;&lt; endl;
      }

   ~Uint24_t() = default;

   std::string show() {
      stringstream ss;
      ss &lt;&lt; ""  show(): ""
         &lt;&lt; static_cast&lt;char&gt;(data[2]) &lt;&lt; "".""
         &lt;&lt; static_cast&lt;char&gt;(data[1]) &lt;&lt; "".""
         &lt;&lt; static_cast&lt;char&gt;(data[0]);
      return ss.str();
   }

   std::string dump() {
      stringstream ss;
      ss &lt;&lt; ""  dump(): "" &lt;&lt; hex
         &lt;&lt; static_cast&lt;int&gt;(data[2]) &lt;&lt; "".""
         &lt;&lt; static_cast&lt;int&gt;(data[1]) &lt;&lt; "".""
         &lt;&lt; static_cast&lt;int&gt;(data[0]);
      return ss.str();
   }

   void swap0_2() { swap(data[0], data[2]); }


private:
   uint8_t  data[3]; // 3 uint8_t 's
};



class T976_t // ctor and dtor compiler provided defaults
{
public:
   int operator()() { return exec(); } // functor entry

private: // methods

   int exec()
      {
         Uint24_t  u24(('c' &lt;&lt; 16) +  // msbyte
                       ('b' &lt;&lt;  8) +
                       ('a' &lt;&lt;  0));

         cout &lt;&lt; ""\n  sizeof(u24) = "" &lt;&lt; sizeof(u24) &lt;&lt; "" bytes""
              &lt;&lt; ""\n  "" &lt;&lt; u24.show()
              &lt;&lt; ""\n  "" &lt;&lt; u24.dump() &lt;&lt; std::endl;

         u24.swap0_2(); // swapping lsByte and msByte

         cout &lt;&lt; ""\n  sizeof(u24) = "" &lt;&lt; sizeof(u24) &lt;&lt; "" bytes""
              &lt;&lt; ""\n  "" &lt;&lt; u24.show()
              &lt;&lt; ""\n  "" &lt;&lt; u24.dump() &lt;&lt; std::endl;

         return 0;
      }



}; // class T976_t


int main(int , char**) { return T976_t()(); } // call functor
</code></pre>

<p>Typical output:</p>

<pre><code>sizeof(Uint24_t)= 3 bytes, * 8= 24 bits.

  sizeof(u24) = 3 bytes
    show(): c.b.a
    dump(): 63.62.61

  sizeof(u24) = 3 bytes
    show(): a.b.c
    dump(): 61.62.63
</code></pre>
",,,
54404321,2,54316980,2019-01-28T14:41:21.597,1,,1241224,,2019-01-28T14:41:21.597,,0,,"<p>The answer is, set both *_gpio_num members of pcnt_config_t to PCNT_PIN_NOT_USED and call pcnt_unit_config again:</p>

<pre><code>pcnt_config_t pcnt_config = {
    .pulse_gpio_num = PCNT_PIN_NOT_USED,
    .ctrl_gpio_num = PCNT_PIN_NOT_USED,
    .channel = PCNT_CHANNEL_0;
}
pcnt_unit_config(&amp;pcnt_config);
</code></pre>
",,,
54383884,2,54383773,2019-01-26T23:49:11.677,3,,10952215,,2019-01-26T23:49:11.677,,2,,"<p>aside from the obvious ""why use two threads if one is always waiting anyway?"" what you need to do is use some kind of ""state"" variable with the mutex:</p>

<pre><code>// start here
#define STATE_INITIAL 0
// go here when step 1 finishes
#define STATE_STEP1 1
// go here when step 2 finishes
#define STATE_STEP2 2
pthread_mutex_t my_mutex;
int cur_state;

void wait_my_turn(int desired_state) {
    pthread_mutex_lock(&amp;my_mutex);
    if (cur_state == desired_state) return;
    pthread_mutex_unload(&amp;my_mutex);
}

void finish_turn() {
    ++cur_state;
    if (cur_state == 3) cur_state = 1;
    pthread_mutex_unlock(&amp;my_mutex);
}

// in main, initialize mutex, lock it, and set cur_state to STATE_INITIAL
// until you are ready for threads to start.  Then you need to set it
// to STATE_STEP1 to allow that thread to begin.
// in your threads, begin with wait_my_turn(STATE_STEPn)
// and call finish_turn() when done
</code></pre>

<p>...not a great example, but you should get the gist of it.</p>
",,,
54391417,2,54391285,2019-01-27T18:21:31.447,4,,6110094,,2019-01-27T18:21:31.447,,3,,"<p>you need to learn C (C++ actually as arduino is programmed in C++). </p>

<p>strtol converts strings to numbers. </p>

<p>string in C is a array of char elements ending with zero (not <code>'0'</code> but <code>0</code>). So ""0x225"" is the array of <code>{'0', 'x', '2', '2', '5', 0}</code></p>

<p><code>'2'</code> is not the number <code>2</code>. It is ASCII representation of char '2' which is 50 in decimal.</p>

<pre><code>buff[0] = '0';
buff[1] = 'x';
buff[2] = '2';
buff[3] = '2';
buff[4] = '5';
buff[5] = 0;

val = strtol(buff, NULL, 16);


buff[0] = 48;
buff[1] = 120;
buff[2] = 50;
buff[3] = 50;
buff[4] = 53;
buff[5] = 0;

val = strtol(buff, NULL, 16);
</code></pre>

<hr>

<p>your code has many other issues. You need to understand what 25 and what 0x25 is (they are not equal). You should start from the book and PC compiler and learn language from the very basic stuff.</p>
",,,
54422290,2,54421840,2019-01-29T13:33:50.437,1,,10622916,,2019-01-30T08:28:42.210,2019-01-30T08:28:42.210,2,,"<p>It looks like your pixel array contains pixel columns for a 5x7 or 5x8 character matrix with the lowest bit in the top line and the left column first.</p>

<p>The two lines seem to produce</p>

<pre><code>.XXX. = bit x1
X...X = bit x2
X...X = bit x4
X...X = bit x8
XXXXX = bit 1x
X...X = bit 2x
X...X = bit 4x
..... = bit 8x
</code></pre>

<p>and</p>

<pre><code>XXXX.
X...X
X...X
XXXX.
X...X
X...X
XXXX.
.....
</code></pre>

<p>To get bold characters you have to think about how these should be displayed. In a 5x7 matrix it might not be possible to display all letters in bold, e.g. <code>M</code>. For A and B you could try to use patterns/numbers for patterns like this:</p>

<pre><code>.XXX.
XX.XX
XX.XX
XX.XX
XXXXX
XX.XX
XX.XX
.....

{0x7E, 0x7F, 0x11, 0x7F, 0x7E}
</code></pre>

<p>or</p>

<pre><code>XXXX.
XX.XX
XX.XX
XXXX.
XX.XX
XX.XX
XXXX.
.....

{0x7F, 0x7F, 0x49, 0x7F, 0x36}
</code></pre>

<p><strong>Automatic generation of bold characters</strong></p>

<p>It is possible to automatically generate the font (character generator) for bold characters from the regular one if you have enough background pixels between the character pixels by shifting the dots to the right by one and using an combining original and shifted values with bitwise <code>or</code>.</p>

<p>This automatic generation for fixed width characters may be difficult for characters with 3 vertical lines because you would need 9 pixels for this to have 1 column for the inter-character space. A simple algorithm could clear the rightmost column if you want to have 8 pixels width, but manual modification might produce nicer results.</p>

<p>Example <code>M</code> regular</p>

<pre><code>X.....X..
XX...XX..
X.X.X.X..
X..X..X..
X..X..X..
X..X..X..
X..X..X..
</code></pre>

<p><code>M</code> shifted to the right</p>

<pre><code>.X.....X.
.XX...XX.
.X.X.X.X.
.X..X..X.
.X..X..X.
.X..X..X.
.X..X..X.
</code></pre>

<p><code>M</code> bitwise or</p>

<pre><code>XX....XX.
XXX..XXX.
XXXXXXXX.
XX.XX.XX.
XX.XX.XX.
XX.XX.XX.
XX.XX.XX.
.........
</code></pre>

<p><code>M</code> bitwise or, last column cleared</p>

<pre><code>XX....X.
XXX..XX.
XXXXXXX.
XX.XX.X.
XX.XX.X.
XX.XX.X.
XX.XX.X.
........
</code></pre>

<p>A handmade correction for 8x8 looks nicer</p>

<pre><code>XX...XX.
XXX.XXX.
XXXXXXX.
XX.X.XX.
XX.X.XX.
XX.X.XX.
XX.X.XX.
........
</code></pre>

<p>A library for LCD probably contains a font table. Maybe there are already existing libraries that support bold characters.</p>

<p>A search for ""arduino lcd bold"" brought this top result: <a href=""https://forum.arduino.cc/index.php?topic=458712.0"" rel=""nofollow noreferrer"">https://forum.arduino.cc/index.php?topic=458712.0</a></p>
",,,
54721831,2,54446038,2019-02-16T09:53:05.370,1,,2425802,,2020-08-16T14:08:10.560,2020-08-16T14:08:10.560,3,,"<p>Based on the information that you provided in your comment, the tag contains a URI record (that, in turn, contains your data). The problem in your code is that you directly use the full payload of the URI record as a string. However, a URI record contains more that just a string. Particularly, the first byte of the payload is the prefix byte (typically a non-printable character). So it seems that <code>Serial.println()</code> (or rather your serial receiver) simply skips that character. <code>client.print()</code> will include that character into the HTTP request and will consequently create an invalid HTTP request (that looks as if the remaining bytes were omitted).</p>
<p>Therefore, you will have to follow the URI Record Type Definition to decode the payload into a proper URI before using it:</p>
<pre><code>NdefMessage message = tag.getNdefMessage();
for (int i = 0; i &lt; message.getRecordCount(); ++i) {
    NdefRecord record = message.getRecord(i);
    if (record.getType() == &quot;U&quot;) {
        String uri = &quot;&quot;;
        int payloadLength = record.getPayloadLength();
        if (payloadLength &gt; 0) {
            byte payload[payloadLength];
            record.getPayload(payload);
            
            switch (payload[0]) {
                case 0x000: break;
                case 0x001: uri += &quot;http://www.&quot;; break;
                case 0x002: uri += &quot;https://www.&quot;; break;
                case 0x003: uri += &quot;http://&quot;; break;
                case 0x004: uri += &quot;https://&quot;; break;
                case 0x005: uri += &quot;tel:&quot;; break;
                case 0x006: uri += &quot;mailto:&quot;; break;
                case 0x007: uri += &quot;ftp://anonymous:anonymous@&quot;; break;
                case 0x008: uri += &quot;ftp://ftp.&quot;; break;
                case 0x009: uri += &quot;ftps://&quot;; break;
                case 0x00A: uri += &quot;sftp://&quot;; break;
                case 0x00B: uri += &quot;smb://&quot;; break;
                case 0x00C: uri += &quot;nfs://&quot;; break;
                case 0x00D: uri += &quot;ftp://&quot;; break;
                case 0x00E: uri += &quot;dav://&quot;; break;
                case 0x00F: uri += &quot;news:&quot;; break;
                case 0x010: uri += &quot;telnet://&quot;; break;
                case 0x011: uri += &quot;imap:&quot;; break;
                case 0x012: uri += &quot;rtsp://&quot;; break;
                case 0x013: uri += &quot;urn:&quot;; break;
                case 0x014: uri += &quot;pop:&quot;; break;
                case 0x015: uri += &quot;sip:&quot;; break;
                case 0x016: uri += &quot;sips:&quot;; break;
                case 0x017: uri += &quot;tftp:&quot;; break;
                case 0x018: uri += &quot;btspp://&quot;; break;
                case 0x019: uri += &quot;btl2cap://&quot;; break;
                case 0x01A: uri += &quot;btgoep://&quot;; break;
                case 0x01B: uri += &quot;tcpobex://&quot;; break;
                case 0x01C: uri += &quot;irdaobex://&quot;; break;
                case 0x01D: uri += &quot;file://&quot;; break;
                case 0x01E: uri += &quot;urn:epc:id:&quot;; break;
                case 0x01F: uri += &quot;urn:epc:tag:&quot;; break;
                case 0x020: uri += &quot;urn:epc:pat:&quot;; break;
                case 0x021: uri += &quot;urn:epc:raw:&quot;; break;
                case 0x022: uri += &quot;urn:epc:&quot;; break;
                case 0x023: uri += &quot;urn:nfc:&quot;; break;
                default: break;
            }
            for (int j = 1; j &lt; payloadLength; ++j) {
                uri += (char)payload[j]; // NOTE: this is wrong since the string is UTF-8 encoded (but we translate it byte-by-byte)
            }
        }
        Serial.println(uri);
        request(uri);
    }
}
</code></pre>
<p>Be aware that there a still a few issues with the solution above:</p>
<ul>
<li>The string part of the URI (bytes starting at offset 1) is actually UTF-8 encoded. However, we treat it as if it was (more or less) ASCII encoded here. I haven't found any simple library to properly transform byte arrays into a UTF-8 encoded string representation on Arduino though.</li>
<li>If your resulting URI contains characters that have special meaning in URLs (such as &quot;/&quot;, &quot;:&quot;, &quot;&amp;&quot;, etc.), you would need to urlencode (see e.g. <a href=""https://stackoverflow.com/a/22053443/2425802"">here</a>) them before appending the string to the GET request. Otherwise, the resulting URI of the GET request may not be what you expected.</li>
<li><code>String</code> is certainly not the best choice in terms of memory efficiency.</li>
</ul>
",,,
54475108,2,54474686,2019-02-01T07:51:09.733,1,,982161,,2019-02-01T07:51:09.733,,0,,"<p>replace n with rows</p>

<pre><code>for(int i = 1, k = 0; i &lt;= rows; ++i, k = 0)
{
    for(space = 1; space &lt;= rows-i; ++space)
    {
        cout &lt;&lt;""  "";
    }

    while(k != 2*i-1)
    {
        cout &lt;&lt; ""* "";
        ++k;
    }
    cout &lt;&lt; endl;
}    
</code></pre>

<p>here the output</p>

<p><a href=""https://ideone.com/OPMeO1"" rel=""nofollow noreferrer"">https://ideone.com/OPMeO1</a></p>
",,,
54478586,2,54477942,2019-02-01T11:28:10.703,1,,894449,,2019-02-01T11:28:10.703,,1,,"<p>I've never messed with the ESP32 or web services running on microcontrollers, but I mostly write web services and applications for a living.</p>

<p>You could use JavaScript to read the form values and submit an HTTP request to a separate endpoint to store the username and password values, but HTML <a href=""https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form"" rel=""nofollow noreferrer"">already supports forms</a>.</p>

<p>The input tags you have now work with forms. All you have to do is add a form element around your inputs that specifies how to encode and transfer the form values, and what endpoint to send them to. The browser will take care of the rest when you click on the submit button:</p>

<pre><code>&lt;body&gt;
    &lt;div class=""login-box""&gt;
        &lt;form method=""post"" action=""/login""&gt;
            &lt;div class = ""box-head""&gt;
                &lt;div class = ""logo""&gt;&lt;img url=""logo.png""&gt;&lt;/div&gt;
                &lt;div class = ""network-title""&gt;&lt;h1&gt;Network Login&lt;/h1&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class =""textbox""&gt;            
                &lt;input type=""text"" placeholder=""Network Name"" name=""networkName"" value=""""&gt;
            &lt;/div&gt;        
            &lt;div class=""textbox""&gt;            
                &lt;input type=""password"" placeholder=""Password"" name=""networkPassword"" value=""""&gt;
            &lt;/div&gt;        
            &lt;input class=""button"" type=""submit"" value=""Sign in""&gt;
            &lt;input class=""button"" type=""reset"" value=""Restart""&gt;        
        &lt;/form&gt;
    &lt;/div&gt;    
&lt;/body&gt;
</code></pre>

<p>This would send an HTTP POST request to the <code>/login</code> endpoint with a body containing the form values encoded as <code>application/x-www-form-urlencoded</code>.</p>

<p>You don't need PHP to handle the request (and you don't have a PHP runtime to begin with). PHP executes logic on the HTTP server. In this case, the ESP32 is your HTTP server, and your logic is captured by the AsyncWebServer object inside your sketch.</p>

<p><a href=""https://github.com/me-no-dev/ESPAsyncWebServer#get-post-and-file-parameters"" rel=""nofollow noreferrer"">AsyncWebServerRequest can read form values</a> for you, so all you have to do is implement the correct handler on your server:</p>

<pre><code>server.on(""/login"", HTTP_POST, [](AsyncWebServerRequest *request) {
  if (!request-&gt;hasParam(""networkName"", true) || !request-&gt;hasParam(""networkPassword"", true)) {
    request-&gt;send(400, ""Missing fields"");
    return;
  }
  const char *networkName = request-&gt;getParam(""networkName"")-&gt;value().c_str();
  const char *networkPassword = request-&gt;getParam(""networkPassword"")-&gt;value().c_str();
  // Do stuff with networkName and networkPassword
  // ...
  // Redirect to new page
  request-&gt;redirect(""/whatever"");
});
</code></pre>
",,,
54514425,2,54495764,2019-02-04T10:40:41.103,1,,1373856,,2019-02-04T10:40:41.103,,1,,"<p>I assume that <code>enable</code> and <code>set_dir</code> are methods on the Motor class. So you need three instances of Motor in the Motor class. If you are fine with the default constructor for each Motor object then you can encapsulate them like:</p>

<pre><code>class Motors
{
  public:
    Motors() {
    }

    void go_home() {
      a.enable(1); b.enable(1); c.enable(1);
      a.set_dir(0); b.set_dir(0); c.set_dir(0);
      delay(mtime);
    }

  private:
    Motor a;
    Motor b;
    Motor c;
};
</code></pre>
",,,
54519091,2,54495764,2019-02-04T15:14:02.237,0,,5599108,,2019-02-04T15:14:02.237,,1,,"<pre><code>class Motors{
public:
  Motor a = Motor(xstep, xdir, xenable, xend, amax, true);
  Motor b = Motor(ystep, ydir, yenable, yend, bmax);
  Motor c = Motor(zstep, zdir, zenable, zend, cmax);

  Motors(){

  }

  void go_home(){
    a.enable(1); b.enable(1); c.enable(1);
    a.set_dir(0); b.set_dir(0); c.set_dir(0);
    delay(mtime) 
  }
};
</code></pre>
",,,
54518570,2,54518123,2019-02-04T14:43:59.213,2,,3100312,,2019-02-04T14:43:59.213,,0,,"<p>In addition to Story Teller's excellent explanation, to define global variables, use the following:</p>

<pre><code>// module.h
#include ""glo.h""

// glo.h
#ifndef EXTERN
# define EXTERN extern
#endif
EXTERN int myvar;

// main.c
#define EXTERN
#include ""glo.h""
</code></pre>

<p>In <code>main.c</code> all variables will be declared (i.e. space is allocated for them), in all other c files that include <code>glo.h</code>, all variables will be known.</p>
",,,
54555655,2,54555031,2019-02-06T14:14:16.143,0,,1813336,,2019-02-06T14:14:16.143,,0,,"<p>You need to make the function pointers all have the same signature.  I would use something like this;</p>

<pre><code>typedef int(*try_func)(void *arg);
</code></pre>

<p>And have a <code>try_this_action(...)</code> signature similar to the following;</p>

<pre><code>void try_this_action(char * msg, int max_trys, try_func func, void *arg)
</code></pre>

<p>You would then implement your actions similar to this;</p>

<pre><code>int power(void *pv)
{
    int *p = pv;    
    int on_off = *p;

    static int try = 0;

    if (on_off &amp;&amp; try++)
        return 1;
    return 0;
}

int signal(void *pv)
{
    static int try = 0;

    if (try++ &gt; 6)
        return 1;
    return 0;
}
</code></pre>

<p>And call them like this;</p>

<pre><code>int main(int c, char *v[])
{
    int on_off = 1;

    try_this_action(""Powering ON"", 3, power, &amp;on_off);
    try_this_action(""Signaling"", 10, signal, 0);
}
</code></pre>
",,,
54555717,2,54555031,2019-02-06T14:17:23.103,1,,2402272,,2019-02-06T14:17:23.103,,1,,"<blockquote>
  <p>A difficulty I have is that the functions called have different syntax
  (some take parameters, some other don't...).</p>
</blockquote>

<p>That is indeed an issue.  Along with it you have the possibility of variation in actual function arguments for the same function.</p>

<blockquote>
  <p>Is there a more elegant
  modulable way of doing this besides copy/paste the chunck of code
  everywhere I need it ?</p>
</blockquote>

<p>I think you could make a variadic function that uses specific knowledge of the functions to dispatch in order to deal with the differing function signatures and actual arguments.  I'm doubtful that I would consider the result more elegant, though.</p>

<p>I would be inclined to approach this job via a macro, instead:</p>

<pre><code>// desc:     a descriptive string, evaluated once
// action:   an expression to (re)try until it evaluates to true in boolean context
// attempts: the maximum number of times the action will be evaluated, itself evaluated once
#define try_this_action(desc, action, attempts) do { \
    int _attempts = (attempts);                      \
    DEBUG_PRINT(desc);                               \
    while(_attempts &amp;&amp; !(action)) {                  \
        _attempts -= 1;                              \
        DEBUG_PRINT(""."");                            \
        delay(100);                                  \
    }                                                \
    if (_attempts) {                                 \
        DEBUG_PRINTLN("" - Success"");                 \
    } else {                                         \
        DEBUG_PRINTLN("" - Failed."");                 \
        soft_reset();                                \
    }                                                \
    wdt_reset();                                     \
} while (0)
</code></pre>

<p>Usage would be just as you described:</p>

<pre><code>try_this_action(""Powering ON"", module.power(true), 3);
</code></pre>

<p><em>etc</em>..  Although the effect is as if you did insert the code for each action in each spot, using a macro such as this would yield code that is much easier to read, and that is not lexically repetitive.  Thus, for example, if you ever need to change the the steps for trying actions, you can do it once for all by modifying the macro.</p>
",,,
54556420,2,54555031,2019-02-06T14:53:47.287,0,,1883304,,2019-02-06T14:53:47.287,,0,,"<p>Functions of different arity may be abstracted with a generic signature (think about <code>main</code>). Instead of each giving each their own unique arguments, you simply supply them all with:</p>

<ol>
<li>An argument count.</li>
<li>A vector of pointers to the arguments.</li>
</ol>

<p>This is how your operating system treats all programs it runs anyways. I've given a very basic example below which you can inspect. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Define total function count */
#define MAX_FUNC        2

/* Generic function signature */
typedef void (*func)(int, void **, const char *);

/* Function pointer array (NULL - initialized) */
func functions[MAX_FUNC];

/* Example function #1 */
void printName (int argc, void **argv, const char *desc) {
    fprintf(stdout, ""Running: %s\n"", desc);
    if (argc != 1 || argv == NULL) {
        fprintf(stderr, ""Err in %s!\n"", desc);
        return;
    }
    const char *name = (const char *)(argv[0]);
    fprintf(stdout, ""Name: %s\n"", name);
}

/* Example function #2 */
void printMax (int argc, void **argv, const char *desc) {
    fprintf(stdout, ""Running: %s\n"", desc);
    if (argc != 2 || argv == NULL) {
        fprintf(stderr, ""Err in %s!\n"", desc);
        return;
    }
    int *a = (int *)(argv[0]), *b = (int *)(argv[1]);
    fprintf(stdout, ""Max: %d\n"", (*a &gt; *b) ? *a : *b);
}


int main (void) {
    functions[0] = printName;               // Set function #0
    functions[1] = printMax;                // Set function #1


    int f_arg_count[2] = {1, 2};            // Function 0 takes 1 argument, function 1 takes 2.
    const char *descs[2] = {""printName"", ""printMax""};
    const char *name = ""Natasi"";            // Args of function 0
    int a = 2, b = 3;                       // Args of function 1
    int *args[2] = {&amp;a, &amp;b};                // Args of function 1 in an array.

    void **f_args[2] = {(void **)(&amp;name), 
                      (void **)(&amp;args)};    // All function args.

    // Invoke all functions.    
    for (int i = 0; i &lt; MAX_FUNC; i++) {
        func f = functions[i];
        const char *desc = descs[i];
        int n = f_arg_count[i];
        void **args = f_args[i];
        f(n, args, desc);
    }

    return EXIT_SUCCESS;
}
</code></pre>
",,,
54557107,2,54555031,2019-02-06T15:28:51.533,0,,5157478,,2019-02-06T16:40:54.270,2019-02-06T16:40:54.270,0,,"<p>You can use a variadic function, declaring in the parameter list first those parameters that are always present, then the variable part.
In following code we define a type for action functions, void returning having as parameter an argument list:</p>

<pre><code>typedef void (*action)(va_list);
</code></pre>

<p>Then define the generic action routine that prepare for the action execution:</p>

<pre><code>void try_this_action(char *szActionName, int trials, action fn_action, ...)
{
    va_list args;
    va_start(args, fn_action);    //Init the argument list

    DEBUG_PRINT(szActionName);  // This line changes
    uint8_t attempts = 0;
    uint8_t max_attempts = trials;  // max_attempts changes
    //Here we call our function through the pointer passed as argument
    while (!fn_action(args) &amp;&amp; attempts &lt; max_attempts)
    {   // This line changes
        attempts++;
        DEBUG_PRINT(""."");
        if (attempts == max_attempts)
        {
            DEBUG_PRINTLN("" - Failed."");
            soft_reset();   // Start all over again
        }
        delay(100);
    }
    DEBUG_PRINTLN("" - Success"");
    wdt_reset();    // Reset watchdog timer, ready for next action
    va_end(args);
}
</code></pre>

<p>Each function must be coded to use an argument list:</p>

<pre><code>int power(va_list args)
{
    //First recover all our arguments using the va_arg macro
    bool cond = va_arg(args, bool);

    if (cond == true)
    {
        ... //do something
            return true;
    }
    return false;
}
</code></pre>

<p>The usage will be:</p>

<pre><code>try_this_action(""Powering ON"", 3, module.power, true);
try_this_action(""Waiting for signal"", 10, module.signal);
try_this_action(""Sending SMS"", 3, module.sendSMS, ""test"");
try_this_action(""Powering OFF"", 1, module.power, false);
</code></pre>

<p>If you need more info on variadic functions and usage of stdarg.h macros google the net. Start from here <a href=""https://en.cppreference.com/w/c/variadic"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/c/variadic</a>.</p>

<p>It could be coded also as a macro implementation, as the excellent proposal in the John Bollinger answer, but in that case you must consider that each macro usage will instantiate the whole code, that could be eventually even better for speed (avoiding a function call), but could be not suitable on systems with limited memory (embedded), or where you need reference to the function <code>try_this_action</code> (inexistent).</p>
",,,
54562461,2,54562271,2019-02-06T20:59:08.510,2,,2630032,,2019-02-06T20:59:08.510,,0,,"<p>You are defining a 2D-array with row-size <code>7</code>, but you access 8 elements of a single row:</p>

<pre><code> int storage[127][7];

 storage[48][0] =0b01111110;
 ...
 storage[48][7] =0b01111110;
</code></pre>

<p>Note that 0..7 are actually 8 elements, not 7. So you'd have to define <code>storage</code> as...</p>

<pre><code> int storage[127][8];
</code></pre>

<p>One might discuss now if <code>int storage[127][7];storage[48][7] =0b01111110</code> is undefined behaviour;</p>

<p>Yet the most probably behaviour is that <code>storage[48][7]</code> maps to the same memory address as <code>storage[49][0]</code>. Hence, when you assign <code>storage[49][0] =0b00000000;</code>, then you write to <code>storage[48][7]</code> ""as well"" and it will become <code>0b0000000</code>.</p>
",,,
54599781,2,54583818,2019-02-08T20:32:11.717,7,,565244,,2019-02-08T21:41:17.217,2019-02-08T21:41:17.217,3,,"<p>Found this: <a href=""https://www.esp8266.com/viewtopic.php?f=6&amp;t=15993"" rel=""noreferrer"">https://www.esp8266.com/viewtopic.php?f=6&amp;t=15993</a></p>

<p>This post of eduperez:</p>

<hr>

<p><em>""Android devices have the Google DNSs hard-coded, they will <strong>always use 8.8.8.8</strong> and 8.8.4.4, despite what the DHPC server might tell them to use. You need to configure your gateway to redirect all outgoing traffic to port 53 to your DNS.""</em></p>

<hr>

<p>That gives the idea, use <strong>8.8.8.8 as IP-address and as DNS-server address</strong>. 
Tada! Works like a charm!</p>

<p>So this sketch will work:</p>

<pre><code>#include &lt;ESP8266WiFi.h&gt;
#include &lt;WiFiClient.h&gt;
#include &lt;ESP8266WebServer.h&gt;
#include &lt;DNSServer.h&gt;
#include &lt;ESP8266mDNS.h&gt;
#include &lt;EEPROM.h&gt;

/*
   This example serves a ""hello world"" on a WLAN and a SoftAP at the same time.
   The SoftAP allow you to configure WLAN parameters at run time. They are not setup in the sketch but saved on EEPROM.
   Connect your computer or cell phone to wifi network ESP_ap with password 12345678. A popup may appear and it allow you to go to WLAN config. If it does not then navigate to http://192.168.4.1/wifi and config it there.
   Then wait for the module to connect to your wifi and take note of the WLAN IP it got. Then you can disconnect from ESP_ap and return to your regular WLAN.
   Now the ESP8266 is in your network. You can reach it through http://192.168.x.x/ (the IP you took note of) or maybe at http://esp8266.local too.
   This is a captive portal because through the softAP it will redirect any http request to http://192.168.4.1/
*/

/* Set these to your desired softAP credentials. They are not configurable at runtime */
#ifndef APSSID
#define APSSID ""TheGeekMan""
#define APPSK  ""12345678""
#endif

const char *softAP_ssid = APSSID;
const char *softAP_password = APPSK;

/* hostname for mDNS. Should work at least on windows. Try http://esp8266.local */
const char *myHostname = ""thegeekman"";

/* Don't set this wifi credentials. They are configurated at runtime and stored on EEPROM */
char ssid[32] = """";
char password[32] = """";

// DNS server
const byte DNS_PORT = 53;
DNSServer dnsServer;

// Web server
ESP8266WebServer server(80);

/* Soft AP network parameters */
//IPAddress apIP(192, 168, 4, 1);
IPAddress apIP(8, 8, 8, 8);
IPAddress netMsk(255, 255, 255, 0);


/** Should I connect to WLAN asap? */
boolean connect;

/** Last time I tried to connect to WLAN */
unsigned long lastConnectTry = 0;

/** Current WLAN status */
unsigned int status = WL_IDLE_STATUS;

/** Is this an IP? */
boolean isIp(String str) {
  for (size_t i = 0; i &lt; str.length(); i++) {
    int c = str.charAt(i);
    if (c != '.' &amp;&amp; (c &lt; '0' || c &gt; '9')) {
      return false;
    }
  }
  return true;
}

/** IP to String? */
String toStringIp(IPAddress ip) {
  String res = """";
  for (int i = 0; i &lt; 3; i++) {
    res += String((ip &gt;&gt; (8 * i)) &amp; 0xFF) + ""."";
  }
  res += String(((ip &gt;&gt; 8 * 3)) &amp; 0xFF);
  return res;
}

/** Load WLAN credentials from EEPROM */
void loadCredentials() {
  EEPROM.begin(512);
  EEPROM.get(0, ssid);
  EEPROM.get(0 + sizeof(ssid), password);
  char ok[2 + 1];
  EEPROM.get(0 + sizeof(ssid) + sizeof(password), ok);
  EEPROM.end();
  if (String(ok) != String(""OK"")) {
    ssid[0] = 0;
    password[0] = 0;
  }
  Serial.println(""Recovered credentials:"");
  Serial.println(ssid);
  Serial.println(strlen(password) &gt; 0 ? ""********"" : ""&lt;no password&gt;"");
}

/** Store WLAN credentials to EEPROM */
void saveCredentials() {
  EEPROM.begin(512);
  EEPROM.put(0, ssid);
  EEPROM.put(0 + sizeof(ssid), password);
  char ok[2 + 1] = ""OK"";
  EEPROM.put(0 + sizeof(ssid) + sizeof(password), ok);
  EEPROM.commit();
  EEPROM.end();
}

/** Handle root or redirect to captive portal */
void handleRoot() {
  if (captivePortal()) { // If caprive portal redirect instead of displaying the page.
    return;
  }
  server.sendHeader(""Cache-Control"", ""no-cache, no-store, must-revalidate"");
  server.sendHeader(""Pragma"", ""no-cache"");
  server.sendHeader(""Expires"", ""-1"");

  String Page;
  Page += F(
            ""&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;""
            ""&lt;h1&gt;HELLO WORLD!!&lt;/h1&gt;"");
  if (server.client().localIP() == apIP) {
    Page += String(F(""&lt;p&gt;You are connected through the soft AP: "")) + softAP_ssid + F(""&lt;/p&gt;"");
  } else {
    Page += String(F(""&lt;p&gt;You are connected through the wifi network: "")) + ssid + F(""&lt;/p&gt;"");
  }
  Page += F(
            ""&lt;p&gt;You may want to &lt;a href='/wifi'&gt;config the wifi connection&lt;/a&gt;.&lt;/p&gt;""
            ""&lt;/body&gt;&lt;/html&gt;"");

  server.send(200, ""text/html"", Page);
}

/** Redirect to captive portal if we got a request for another domain. Return true in that case so the page handler do not try to handle the request again. */
boolean captivePortal() {
  if (!isIp(server.hostHeader()) &amp;&amp; server.hostHeader() != (String(myHostname) + "".local"")) {
    Serial.println(""Request redirected to captive portal"");
    server.sendHeader(""Location"", String(""http://"") + toStringIp(server.client().localIP()), true);
    server.send(302, ""text/plain"", """");   // Empty content inhibits Content-length header so we have to close the socket ourselves.
    server.client().stop(); // Stop is needed because we sent no content length
    return true;
  }
  return false;
}

/** Wifi config page handler */
void handleWifi() {
  server.sendHeader(""Cache-Control"", ""no-cache, no-store, must-revalidate"");
  server.sendHeader(""Pragma"", ""no-cache"");
  server.sendHeader(""Expires"", ""-1"");

  String Page;
  Page += F(
            ""&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;""
            ""&lt;h1&gt;Wifi config&lt;/h1&gt;"");
  if (server.client().localIP() == apIP) {
    Page += String(F(""&lt;p&gt;You are connected through the soft AP: "")) + softAP_ssid + F(""&lt;/p&gt;"");
  } else {
    Page += String(F(""&lt;p&gt;You are connected through the wifi network: "")) + ssid + F(""&lt;/p&gt;"");
  }
  Page +=
    String(F(
             ""\r\n&lt;br /&gt;""
             ""&lt;table&gt;&lt;tr&gt;&lt;th align='left'&gt;SoftAP config&lt;/th&gt;&lt;/tr&gt;""
             ""&lt;tr&gt;&lt;td&gt;SSID "")) +
    String(softAP_ssid) +
    F(""&lt;/td&gt;&lt;/tr&gt;""
      ""&lt;tr&gt;&lt;td&gt;IP "") +
    toStringIp(WiFi.softAPIP()) +
    F(""&lt;/td&gt;&lt;/tr&gt;""
      ""&lt;/table&gt;""
      ""\r\n&lt;br /&gt;""
      ""&lt;table&gt;&lt;tr&gt;&lt;th align='left'&gt;WLAN config&lt;/th&gt;&lt;/tr&gt;""
      ""&lt;tr&gt;&lt;td&gt;SSID "") +
    String(ssid) +
    F(""&lt;/td&gt;&lt;/tr&gt;""
      ""&lt;tr&gt;&lt;td&gt;IP "") +
    toStringIp(WiFi.localIP()) +
    F(""&lt;/td&gt;&lt;/tr&gt;""
      ""&lt;/table&gt;""
      ""\r\n&lt;br /&gt;""
      ""&lt;table&gt;&lt;tr&gt;&lt;th align='left'&gt;WLAN list (refresh if any missing)&lt;/th&gt;&lt;/tr&gt;"");
  Serial.println(""scan start"");
  int n = WiFi.scanNetworks();
  Serial.println(""scan done"");
  if (n &gt; 0) {
    for (int i = 0; i &lt; n; i++) {
      Page += String(F(""\r\n&lt;tr&gt;&lt;td&gt;SSID "")) + WiFi.SSID(i) + ((WiFi.encryptionType(i) == ENC_TYPE_NONE) ? F("" "") : F("" *"")) + F("" ("") + WiFi.RSSI(i) + F("")&lt;/td&gt;&lt;/tr&gt;"");
    }
  } else {
    Page += F(""&lt;tr&gt;&lt;td&gt;No WLAN found&lt;/td&gt;&lt;/tr&gt;"");
  }
  Page += F(
            ""&lt;/table&gt;""
            ""\r\n&lt;br /&gt;&lt;form method='POST' action='wifisave'&gt;&lt;h4&gt;Connect to network:&lt;/h4&gt;""
            ""&lt;input type='text' placeholder='network' name='n'/&gt;""
            ""&lt;br /&gt;&lt;input type='password' placeholder='password' name='p'/&gt;""
            ""&lt;br /&gt;&lt;input type='submit' value='Connect/Disconnect'/&gt;&lt;/form&gt;""
            ""&lt;p&gt;You may want to &lt;a href='/'&gt;return to the home page&lt;/a&gt;.&lt;/p&gt;""
            ""&lt;/body&gt;&lt;/html&gt;"");
  server.send(200, ""text/html"", Page);
  server.client().stop(); // Stop is needed because we sent no content length
}

/** Handle the WLAN save form and redirect to WLAN config page again */
void handleWifiSave() {
  Serial.println(""wifi save"");
  server.arg(""n"").toCharArray(ssid, sizeof(ssid) - 1);
  server.arg(""p"").toCharArray(password, sizeof(password) - 1);
  server.sendHeader(""Location"", ""wifi"", true);
  server.sendHeader(""Cache-Control"", ""no-cache, no-store, must-revalidate"");
  server.sendHeader(""Pragma"", ""no-cache"");
  server.sendHeader(""Expires"", ""-1"");
  server.send(302, ""text/plain"", """");    // Empty content inhibits Content-length header so we have to close the socket ourselves.
  server.client().stop(); // Stop is needed because we sent no content length
  saveCredentials();
  connect = strlen(ssid) &gt; 0; // Request WLAN connect with new credentials if there is a SSID
}

void handleNotFound() {
  if (captivePortal()) { // If caprive portal redirect instead of displaying the error page.
    return;
  }
  String message = F(""File Not Found\n\n"");
  message += F(""URI: "");
  message += server.uri();
  message += F(""\nMethod: "");
  message += (server.method() == HTTP_GET) ? ""GET"" : ""POST"";
  message += F(""\nArguments: "");
  message += server.args();
  message += F(""\n"");

  for (uint8_t i = 0; i &lt; server.args(); i++) {
    message += String(F("" "")) + server.argName(i) + F("": "") + server.arg(i) + F(""\n"");
  }
  server.sendHeader(""Cache-Control"", ""no-cache, no-store, must-revalidate"");
  server.sendHeader(""Pragma"", ""no-cache"");
  server.sendHeader(""Expires"", ""-1"");
  server.send(404, ""text/plain"", message);
}

void setup() {
  delay(1000);
  Serial.begin(9600);
  Serial.println();
  Serial.println(""Configuring access point..."");
  /* You can remove the password parameter if you want the AP to be open. */
  WiFi.softAPConfig(apIP, apIP, netMsk);
  WiFi.softAP(softAP_ssid, softAP_password);
  delay(500); // Without delay I've seen the IP address blank
  Serial.print(""AP IP address: "");
  Serial.println(WiFi.softAPIP());

  /* Setup the DNS server redirecting all the domains to the apIP */
  dnsServer.setErrorReplyCode(DNSReplyCode::NoError);
  dnsServer.start(DNS_PORT, ""*"", apIP);

  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */
  server.on(""/"", handleRoot);
  server.on(""/wifi"", handleWifi);
  server.on(""/wifisave"", handleWifiSave);
  server.on(""/generate_204"", handleRoot);  //Android captive portal. Maybe not needed. Might be handled by notFound handler.
  server.on(""/fwlink"", handleRoot);  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.
  server.onNotFound(handleNotFound);
  server.begin(); // Web server start
  Serial.println(""HTTP server started"");
  loadCredentials(); // Load WLAN credentials from network
  connect = strlen(ssid) &gt; 0; // Request WLAN connect if there is a SSID
}

void connectWifi() {
  Serial.println(""Connecting as wifi client..."");
  WiFi.disconnect();
  WiFi.begin(ssid, password);
  int connRes = WiFi.waitForConnectResult();
  Serial.print(""connRes: "");
  Serial.println(connRes);
}

void loop() {
  if (connect) {
    Serial.println(""Connect requested"");
    connect = false;
    connectWifi();
    lastConnectTry = millis();
  }
  {
    unsigned int s = WiFi.status();
    if (s == 0 &amp;&amp; millis() &gt; (lastConnectTry + 60000)) {
      /* If WLAN disconnected and idle try to connect */
      /* Don't set retry time too low as retry interfere the softAP operation */
      connect = true;
    }
    if (status != s) { // WLAN status change
      Serial.print(""Status: "");
      Serial.println(s);
      status = s;
      if (s == WL_CONNECTED) {
        /* Just connected to WLAN */
        Serial.println("""");
        Serial.print(""Connected to "");
        Serial.println(ssid);
        Serial.print(""IP address: "");
        Serial.println(WiFi.localIP());

        // Setup MDNS responder
        if (!MDNS.begin(myHostname)) {
          Serial.println(""Error setting up MDNS responder!"");
        } else {
          Serial.println(""mDNS responder started"");
          // Add service to MDNS-SD
          MDNS.addService(""http"", ""tcp"", 80);
        }
      } else if (s == WL_NO_SSID_AVAIL) {
        WiFi.disconnect();
      }
    }
    if (s == WL_CONNECTED) {
      MDNS.update();
    }
  }
  // Do work:
  //DNS
  dnsServer.processNextRequest();
  //HTTP
  server.handleClient();
}
</code></pre>

<hr>

<p><a href=""https://i.stack.imgur.com/qXU3e.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/qXU3e.png"" alt=""Example""></a>   </p>
",,,
54595238,2,54593409,2019-02-08T15:07:59.437,1,,1312382,,2019-02-08T15:07:59.437,,0,,"<p>At first, as denoted in comments, type punning is undefined behaviour in C++. So you should only ever read the union member you last assigned a value to. Second problem is that the order in which bit fields are filled is implementation defined (some compilers might place the first member at MSB of the underlying type, most would prefer the LSB, though).</p>

<p>To get around any of these problems, I'd do the work you try to get simplified with bitfields manually:</p>

<pre><code>class UniColor
{
    uint32_t color; // defined in cstdint header; safer than unsigned long or int!
public:
    UniColor(uint32_t color) : color(color) { }
    UniColor(uint8_t red, uint8_t green, uint8_t blue)
        : color
        (
              static_cast&lt;uint32_t&gt;(red)   &lt;&lt; 16
            | static_cast&lt;uint32_t&gt;(green) &lt;&lt; 8
            | static_cast&lt;uint32_t&gt;(blue)
        )
        { }

    uint8_t red() // getter
    {
        return color &gt;&gt; 16;
    }
    void red(uint8_t value) // setter
    {
        color = color &amp; 0x0000ffffU | static_cast&lt;uint32_t&gt;(red) &lt;&lt; 16
    }
    uint8_t green()
    {
        return color &gt;&gt; 8 &amp; 0xffU;
    }
    // rest analogously
};
</code></pre>

<p>You'll notice that I set up the 32 bits as <code>0xuurrggbb</code> (u: unused); if you prefer or need a different order, then adjust the bit shifts appropriately in above functions. You might even consider using the so far unused byte for the alpha channel...</p>
",,,
54677234,2,54593409,2019-02-13T18:41:26.727,0,,11033704,,2019-02-13T18:55:53.023,2019-02-13T18:55:53.023,0,,"<p>Finally, after researching I have not found a easy/universal way to reverse the bit fields. I have chosen to create a class to allocate the fields efficiently:</p>

<pre><code>class RGBColor
{
    public:
        union{
          struct {
            unsigned blue:8;
            unsigned green:8;
            unsigned red:8;
          };
          struct {
            unsigned b:8;
            unsigned g:8;
            unsigned r:8;
          };
          unsigned long hex:24;
        };
        RGBColor(unsigned _r, unsigned _g, unsigned _b) : r(_r), g(_g), b(_b) {};
        RGBColor(unsigned _hex = 0x000000) : hex(_hex) {};
        void operator=(unsigned _hex)
        {
            hex = _hex;
        }
        void operator=(unsigned a[3])
        {
            r = a[0];
            g = a[1];
            b = a[2];
        }
};
</code></pre>

<p>It works. It is heavier than a simple structure without methods, but as we say in Spain: <em>there is no rose without thorns</em>.</p>
",,,
54612310,2,54611864,2019-02-10T00:44:16.820,2,,565244,,2019-02-11T18:22:50.190,2019-02-11T18:22:50.190,0,,"<p>Okay, I was <strong>wrong</strong>, sorry, F() makes also sense inside functions. To prove it, i did some tests. </p>

<p>Did some tests with this simple sketch (uncomment the one you want to test):</p>

<pre><code>// Printing 33 chars
// 1.
//void printStr() { Serial.println( ""0123456789ABCDEFGHo!@#$%^&amp;*()_+&lt;&gt;?"" ); }
//void printStr() { Serial.println( F(""0123456789ABCDEFGHo!@#$%^&amp;*()_+&lt;&gt;?"" )); }
// 2.
void printStr() { String s = ""0123456789ABCDEFGHo!@#$%^&amp;*()_+&lt;&gt;?""; Serial.println( s ); }
//void printStr() { String s; s+=F(""0123456789ABCDEFGHo!@#$%^&amp;*()_+&lt;&gt;?""); Serial.println( s ); }

void setup() {
  Serial.begin(9600);
}

void loop() {
 printStr();
 delay(1000);
}
</code></pre>

<p>Results:</p>

<p><strong>Without</strong> use of <strong>F()</strong> 26816 bytes</p>

<pre><code>The sketch uses 263136 bytes (25%) of program storage space. Maximum is 1044464 bytes.
Global variables use 26816 bytes (32%) of the dynamic memory. 
Remain 55104 bytes for local variables. Maximum is 81920 bytes.
</code></pre>

<p><strong>With</strong> use of <strong>F()</strong> 26788 bytes </p>

<pre><code>The sketch uses 263212 bytes (25%) of program storage space. Maximum is 1044464 bytes.
Global variables use 26788 bytes (32%) of the dynamic memory. 
Remain 55132 bytes for local variables. Maximum is 81920 bytes.
</code></pre>

<p>-28 bytes difference with F(). But okay, now we know for sure! ;-)</p>

<hr>

<h2>Update 11 jan 2019</h2>

<p><strong>Background info why it works this way:</strong></p>

<p>The RAM is split up into different chunks for different purposes. There’s a chunk where all the global and static variables are stored (aka BSS and data areas). There’s the stack where local variables created within function are stored, and finally there’s the heap, which is where dynamic variables are stored.</p>

<p>If you want to know more about how these chunks of memory relate to each other you can read more on <a href=""https://en.wikipedia.org/wiki/Data_segment"" rel=""nofollow noreferrer"">Wikipedia</a>. </p>

<hr>

<p><em>Info copied from this <a href=""https://hackingmajenkoblog.wordpress.com/2016/02/04/the-evils-of-arduino-strings/"" rel=""nofollow noreferrer"">article</a>.</em></p>
",,,
54618490,2,54618065,2019-02-10T16:26:55.623,2,,905902,,2019-02-10T18:47:08.160,2019-02-10T18:47:08.160,3,,"<p><strong>at least</strong> add <strong><code>volatile</code></strong> to your flag's definition, or the loop will be removed by the optimiser (for-O2, or higher)</p>

<p>(check with <code>cc -Wall -O4 -S signal.c</code>)</p>

<hr>

<pre><code>#include &lt;stdbool.h&gt;
// volatile sig_atomic_t
volatile bool
        b_Alive=false;
</code></pre>

<hr>

<p>main():</p>

<pre><code>...
timer.it_value.tv_sec = 0;
timer.it_value.tv_usec = 20000;
timer.it_interval.tv_sec = 0;
timer.it_interval.tv_usec = 20000;
setitimer(ITIMER_REAL, &amp;timer, NULL);

// Prepare main-loop:            

b_Alive = true;
    syslog(LOG_NOTICE + LOG_DAEMON, ""Sucessfully initialized."");
    /** ... and do nothing, while the timer works:                                    */
    while (b_Alive) {
        pause(); //, suspend, wait or anything?
    }
    exit(EXIT_SUCCESS);
</code></pre>

<hr>

<p>And, the timertypes (from the fine manual):</p>

<hr>

<pre><code>   ITIMER_REAL    This timer counts down in real (i.e., wall clock) time.  At each expiration, a SIGALRM signal is generated.

   ITIMER_VIRTUAL This timer counts down against the user-mode CPU time consumed by the process.  (The measurement includes CPU time consumed by all threads in the process.)  At each
                  expiration, a SIGVTALRM signal is generated.
</code></pre>

<hr>

<p>And, since <code>pause()</code> does not consume any CPU ticks, the timer would never expire when using ITIMER_VIRTUAL. (also: a different signal is delivered)</p>
",,,
54659065,2,54658621,2019-02-12T21:39:57.487,1,,1644736,,2019-02-12T21:39:57.487,,0,,"<p>You are trying to put data into a const char* const variable. A const char* const is a pointer to a string where the pointer can not change, and the string data that is pointed to can not change, hence the const's. </p>

<p>The warning is because there is no overloaded == operator for const char*. For this type of comparison generally you will use <a href=""http://linux.die.net/man/3/strcmp"" rel=""nofollow noreferrer""><code>strcmp()</code></a>.</p>

<p>However, since you are using c++, you probably want to use a <code>std::string</code> which should solve both of the referenced compiler messages like so:</p>

<pre><code>#include &lt;string&gt;
// ...
bool isWM8750()
    {
      std::ifstream id(hardwareID);
      if (id.is_open())
      {
        std::string value;
        id &gt;&gt; value;
        id.close();

        if (value == ""0"")
        {
          return true;
        }
      }
      return false;
    }
</code></pre>

<p>Some more examples with raspberry pi gpios here: <a href=""http://www.hertaville.com/introduction-to-accessing-the-raspberry-pis-gpio-in-c.html"" rel=""nofollow noreferrer"">http://www.hertaville.com/introduction-to-accessing-the-raspberry-pis-gpio-in-c.html</a></p>
",,,
54671498,2,54671220,2019-02-13T13:34:44.630,2,,6150775,,2019-02-13T13:34:44.630,,0,,"<p>Stop the loop while the button press is still held in:</p>

<pre><code>int buttonPin = 12;

void setup() 
{
 // put your setup code here, to run once:

   pinMode(buttonPin, INPUT);
}


void loop() 
{
 // put your main code here, to run repeatedly:

  int buttonState = digitalRead(buttonPin);

  for(int i = 0; i &lt; sizeof(mariomelody); i++)
  {
    if(buttonState == HIGH)
    {
      tone(8, mariomelody[i], 70); 
      delay();
    }  
    while(digitalRead(buttonPin) == HIGH)
    {
    // wait until the button is released
    }
    while(digitalRead(buttonPin) == LOW)
    {
    //wait until the button is pressed again
    }
  }
}
</code></pre>
",,,
54671500,2,54671220,2019-02-13T13:34:53.130,1,,865874,,2019-02-13T13:34:53.130,,0,,"<p>I'm guessing that you want to play the melody while the button is pressed, and stop if the button is released.</p>

<p>Then it would be something like:</p>

<pre><code>int i = 0;
void loop() 
{
    if(digitalRead(buttonPin) == HIGH)
    {
      tone(8, mariomelody[i], 70); 
      i = (i + 1) % sizeof(mariomelody);
      delay();
    }  
}
</code></pre>

<p>To avoid resetting the position to the begin of the melody you need <code>i</code> to be a global variable.</p>

<p>If you want the button to switch on and off the melody you'll need another global variable <code>playing</code>:</p>

<pre><code>bool playing = false;
void loop()
{
    if(digitalRead(buttonPin) == HIGH)
    {
        playing = !playing;
        while (digitalRead(buttonPin) == HIGH)
             ; //wait for release
    }
    if (playing) {
        //the rest is the same
    }
}
</code></pre>
",,,
54706811,2,54706042,2019-02-15T10:00:45.753,1,,898348,,2019-02-15T10:08:29.773,2019-02-15T10:08:29.773,0,,"<p>I don't know the mario melody, but anyway I think your code is wrong:</p>

<p>Try this:</p>

<pre><code>void loop()
{
  for (int i = 0; i &lt; sizeof(mariomelody) / sizeof(mariomelody[0]); i++)
  {
    while (digitalRead(buttonPin) == LOW)
    {
      // wait until button is pressed
    }

    tone(8, mariomelody[i], 20);

    while (digitalRead(buttonPin) == HIGH)
    {
      // wait until button is released
    }          
  }
}
</code></pre>
",,,
54723273,2,54721928,2019-02-16T12:55:40.950,0,,4964791,,2019-02-16T12:55:40.950,,0,,"<p>You're almost there.  Generally speaking in C++ you need to pass a static class method for callback functions.  </p>

<p>The error you received after changing your method to static is expected as you're trying to access a member of an <em>instance</em> of the class <strong>Comm</strong> which cannot be done in a static method in which there is no 'this'.</p>

<p>Here's one of many techniques to consider, but please read over the SO post <a href=""https://stackoverflow.com/questions/1000663/using-a-c-class-member-function-as-a-c-callback-function"">Using a C++ class member function as a C callback function</a>.  </p>

<p>Anyway the approach here is to leverage a <em>static pointer to an instance</em>.</p>

<pre><code>class Comm {
private:
    static Comm* pSingletonInstance;

    static void OnReceiveHandler() {
        if (pSingletonInstance)
            pSingletonInstance-&gt;receiveData();
    }
    static void OnSendHandler(int s) {
        if (pSingletonInstance)
            pSingletonInstance-&gt;sendData(s);
    }
    void initI2c() {
        Comm::pSingletonInstance = this; // Assign the static singleton used in the static handlers.
        Wire.onReceive(Comm::OnSendHandler);
        Wire.onRequest(Comm::OnReceiveHandler);
        Wire.begin(option_address);
    }
}
// static initializer for the static member.
Comm* Comm::pSingletonInstance = 0;
</code></pre>

<p>Again there are <em>many ways</em> to get around this issue but above is an easy one and likely suitable for your project.  If you need to manage multiple instances of Comm, you'll have to do something quite different.</p>

<p>Good luck!</p>
",,,
54725765,2,54724651,2019-02-16T17:27:24.843,0,,4228275,,2019-02-16T17:34:11.107,2019-02-16T17:34:11.107,2,,"<p>You probably need to use <code>cv::</code> and remove these <code>CV_</code> (they are usually legacy flags). You can see their definition <a href=""https://github.com/opencv/opencv/blob/master/modules/videoio/include/opencv2/videoio.hpp#L131-L180"" rel=""nofollow noreferrer"">here</a>. Also, <code>FRAME_WIDTH</code> and <code>FRAME_HEIGHT</code> are not from OpenCV and I don't see where you defined them.</p>

<pre class=""lang-cpp prettyprint-override""><code>// [...]
Camera.set(cv::CAP_PROP_FORMAT, cv::CV_8UC3);
Camera.set(cv::CAP_PROP_FRAME_WIDTH, FRAME_WIDTH);   // FRAME_WIDTH?
Camera.set(cv::CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT); // FRAME_HEIGHT?
// [...]
</code></pre>

<p>You can also check which properties you can set reading the <a href=""https://github.com/cedricve/raspicam/blob/master/src/raspicam_cv.h#L91-L108"" rel=""nofollow noreferrer""><code>raspicam/raspicam_cv.h</code></a>:</p>

<pre class=""lang-cpp prettyprint-override""><code>/**Sets a property in the VideoCapture. 
 * 
 * 
 * Implemented properties:
 * cv::CAP_PROP_FRAME_WIDTH,cv::CAP_PROP_FRAME_HEIGHT,
 * cv::CAP_PROP_FORMAT: CV_8UC1 or CV_8UC3
 * cv::CAP_PROP_BRIGHTNESS: [0,100]
 * cv::CAP_PROP_CONTRAST: [0,100]
 * cv::CAP_PROP_SATURATION: [0,100]
 * cv::CAP_PROP_GAIN: (iso): [0,100]
 * cv::CAP_PROP_EXPOSURE: -1 auto. [1,100] shutter speed from 0 to 33ms
 * cv::CAP_PROP_WHITE_BALANCE_RED_V : [1,100] -1 auto whitebalance
 * cv::CAP_PROP_WHITE_BALANCE_BLUE_U : [1,100] -1 auto whitebalance
 * cv::CAP_PROP_MODE : [1,7] 0 auto mode
 *
 */

bool set ( int propId, double value );
</code></pre>
",,,
54752633,2,54744985,2019-02-18T17:38:54.190,1,,7478597,,2019-02-18T17:47:36.467,2019-02-18T17:47:36.467,1,,"<p>I had a look onto the <a href=""https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WPS/WPS.ino"" rel=""nofollow noreferrer"">example</a> linked in OP's question.</p>

<p>The relevant part is</p>

<pre><code>void setup(){
  // contents skipped
  WiFi.onEvent(WiFiEvent);
  // contents skipped
}
</code></pre>

<p>Thereby <code>WiFiEvent</code> is a free function which is defined above:</p>

<pre><code>void WiFiEvent(WiFiEvent_t event, system_event_info_t info){
  switch(event){
    // some cases to handle various events
    default:
      break;
  }
}
</code></pre>

<p>The OP wants to refactor this event handler into his <code>class ApiClient</code>:</p>

<pre><code>class ApiClient
{
  public:
    ApiClient(String apiUrl);
    void sendValue(String key, String value);
    void wpsInitConfig();
    void WiFiEvent(WiFiEvent_t event, system_event_info_t info);
    String wpspin2string(uint8_t a[]);
    String requestUrl;
    String _apiUrl;
    int chipid;

  private:
};
</code></pre>

<p>The essential difference is that <code>WiFiEvent()</code> becomes a member function due to this, and OP got the reported error</p>

<pre class=""lang-none prettyprint-override""><code>no instance of overloaded function ""WiFiClass::onEvent"" matches the argument list -- argument types are: (void (system_event_id_t event, system_event_info_t info)) -- object type is: WiFiClass
</code></pre>

<p>Out of curiosity, I digged a bit in the github project and finally found the declaration of <code>WiFiClass::onEvent()</code> &ndash; it's inherited from <a href=""https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/src/WiFiGeneric.h"" rel=""nofollow noreferrer""><code>class WiFiGenericClass</code></a>:</p>

<pre><code>class WiFiGenericClass
{
  public:
    WiFiGenericClass();

    wifi_event_id_t onEvent(WiFiEventCb cbEvent, system_event_id_t event = SYSTEM_EVENT_MAX);
    wifi_event_id_t onEvent(WiFiEventFuncCb cbEvent, system_event_id_t event = SYSTEM_EVENT_MAX);
    wifi_event_id_t onEvent(WiFiEventSysCb cbEvent, system_event_id_t event = SYSTEM_EVENT_MAX);
    // a lot more - skipped
};
</code></pre>

<p>Thus, there are actually three declarations of <code>onEvent()</code> with two parameters, thereby the 2<sup>nd</sup> parameter of each has a default argument. (Hence, the call <code>WiFi.onEvent(WiFiEvent);</code> with only one argument in the example was OK.)</p>

<p>To puzzle this out completely, I looked for <code>WiFiEventCb</code>, <code>WiFiEventFuncCb</code>, and <code>WiFiEventSysCb</code> and found them in the same header file above of <code>class WiFiGenericClass</code>:</p>

<pre><code>typedef void (*WiFiEventCb)(system_event_id_t event);
typedef std::function&lt;void(system_event_id_t event, system_event_info_t info)&gt; WiFiEventFuncCb;
typedef void (*WiFiEventSysCb)(system_event_t *event);
</code></pre>

<p>This is what the three <code>typedef</code>s mean:</p>

<ol>
<li><code>WiFiEventCb</code> ... a function pointer to a (free) function which returns <code>void</code> and has one parameter of type <code>system_event_id_t</code></li>
<li><code>WiFiEventFuncCb</code> ... a <code>std::function</code> object for anything returning <code>void</code> and having two parameters of types <code>system_event_id_t</code> and <code>system_event_info_t</code></li>
<li><code>WiFiEventSysCb</code> ... a function pointer to a (free) function which returns <code>void</code> and has one parameter of type <code>system_event_id_t*</code>.</li>
</ol>

<p>Obviously, the example used the 2<sup>nd</sup> <code>onEvent()</code> as it is the only one accepting functions with two parameters.</p>

<p>Support of <a href=""https://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow noreferrer""><code>std::function</code></a> is very nice, because it accepts anything callable with matching signature:</p>

<ul>
<li>free functions,</li>
<li>functors,</li>
<li>lambdas (which are actually nothing else than one of the former).</li>
</ul>

<p>So, to make the <code>ApiClient::WiFiEvent()</code> compatible, there are two options:</p>

<ol>
<li>declare <code>ApiClient::WiFiEvent()</code> as static member function</li>
<li>bind <code>ApiClient::WiFiEvent()</code> with an instance with which it is called.</li>
</ol>

<p>The first option restricts the usability of <code>ApiClient::WiFiEvent()</code> as <code>static</code> member functions are called without an instance of the resp. class. The drawback &ndash; there is no instance in the member function available (i.e. explicit or implicit access to <code>this</code> prohibited) which may or may not be acceptable.</p>

<p>The second option can be achieved easily by using a <a href=""https://en.cppreference.com/w/cpp/language/lambda"" rel=""nofollow noreferrer"">lambda</a> as adapter. For this, the event handler registration in <code>ApiClient::ApiClient()</code> has to be changed:</p>

<pre><code>//ERROR: wifi.onEvent(WiFiEvent);
//Instead:
wifi.onEvent(
  [this](WiFiEvent_t event, system_event_info_t info) {
    this-&gt;WiFiEvent(event, info);
  });
</code></pre>

<p>This effectively registers a functor with the accepted signature which captures <code>this</code> of <code>ApiClient</code> so that a valid call of member function with instance can be done. The return type of lambda is implicitly declared to <code>void</code> because there is no <code>return</code> in the body of the lambda.</p>

<p>Finally, I'd like to mention that capturing in lambdas is something which has to be done carefully. If <code>wifi</code> outlives <code>this</code> (i.e. the instance of <code>ApiClient</code>) then it may call <code>ApiClient::WiFiEvent()</code> without a valid <code>this</code>-pointer.</p>

<p>To make it ""bullet-proof"", the destructor of <code>ApiClient</code> could call <code>removeEvent()</code> using the <code>wifi_event_id_t</code> which is returned by <code>onEvent()</code>. (This should be stored in <code>ApiClient</code> for this purpose.)</p>
",,,
54767392,2,54767297,2019-02-19T13:25:45.527,4,,6229173,,2019-02-19T13:25:45.527,,4,,"<p>You are simply reading an unlimited amount of values without checking if your buffer is full. From your code:</p>

<pre><code>char rcv[64] {};
int i = 0;
while (modem.available()) {
    rcv[i++] = (char)modem.read();
}
</code></pre>

<p>It's quite obvious your char-array rcv will overflow after receiving 64 chars. Maybe you should stop reading once your receive-buffer is full?</p>

<pre><code>char rcv[64] {};
int i = 0;
while (modem.available() &amp;&amp; i &lt; 64) {
    rcv[i++] = (char)modem.read();
}
</code></pre>

<p>Or you could overwrite the oldest value after reading new ones.</p>

<pre><code>char rcv[64] {};
int i = 0;
while (modem.available()) {
    rcv[i % 64] = (char)modem.read();
    ++i;
}
</code></pre>
",,,
54823712,2,54823232,2019-02-22T09:16:57.747,2,,6229173,,2019-02-22T09:16:57.747,,7,,"<p>You increment your counter when analogRead() returns something between 200 and 250 without playing a note. To fix this, use the same threshold on both calls (i.e. check for >200 and &lt;=200 instead of >200 and &lt;250).</p>

<p>Another possible issue is that your pressure sensor is bouncing. You could wrap your analogRead()s into functions like below to prevent this:</p>

<pre><code>void read_dbnc_low(int pin)
{
  while (1) {
    if (analogRead(pin) &lt; 200) {
      delay(1); // 1ms

      if (analogRead(pin) &lt; 200) {
        delay(1);  // 1ms

        if (analogRead(pin) &lt; 200) {
          return;
        }
      }
    }
  }
}

void read_dbnc_high(int pin)
{
  while (1) {
    if (analogRead(pin) &gt;= 200) {
      delay(1); // 1ms

      if (analogRead(pin) &gt;= 200) {
        delay(1);  // 1ms

        if (analogRead(pin) &gt;= 200) {
          return;
        }
      }
    }
  }
}
</code></pre>

<p>And modify your for-loop:</p>

<pre><code>for (int i = 0; i &lt; sizeof(mariomelody) / sizeof(mariomelody[0]); i++)
{
  read_dbnc_low(pressurePin);
  digitalWrite(ledPin, LOW);
  read_dbnc_high(pressurePin);
  digitalWrite(ledPin, HIGH);
  tone(buzzerPin, mariomelody[i], 20);
}
</code></pre>
",,,
54825008,2,54823307,2019-02-22T10:26:54.793,0,,2458991,,2019-02-22T10:26:54.793,,0,,"<p>You can implement your own <em>split</em> as <em>strtok</em> except the role of the second argument :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char * split(char *str, const char * delim)
{
  static char * s;
  char * p, * r;

  if (str != NULL)
    s = str;

  p = strstr(s, delim);

  if (p == NULL) {
    if (*s == 0)
      return NULL;

    r = s;
    s += strlen(s);
    return r;
  }

  r = s;
  *p = 0;
  s = p + strlen(delim);

  return r;
}

int main()
{
  char s[] = ""AAAA... A1... 3. B1."";
  char * p = s;
  char * t;

  while ((t = split(p, ""..."")) != NULL) {
    printf(""'%s'\n"", t);
    p = NULL;
  }

  return 0;
}
</code></pre>

<p>Compilation and execution:</p>

<pre><code>/tmp % gcc -g -pedantic -Wextra s.c
/tmp % ./a.out
'AAAA'
' A1'
' 3. B1.'
/tmp % 
</code></pre>

<p>I print between '' to show the return spaces, because I am not sure you want them, so delim is not only ... in that case</p>
",,,
54825875,2,54823307,2019-02-22T11:14:39.370,3,,4386427,,2019-02-22T11:14:39.370,,0,,"<p>The main problem is that <code>strtok</code> does <strong>not</strong> find a string inside another string. <code>strtok</code> looks for a character in a string. When you give multiple characters to <code>strtok</code> it looks for <strong>any</strong> of these. Consequently, writing <code>strtok(array, ""..."");</code> is exactly the same as writing <code>strtok(array, ""."");</code>. That is why you get a split after ""3.""</p>

<p>There are multiple ways of doing what you want. Below I'll show you an example using <code>strstr</code>. Unlike <code>strtok</code>the <code>strstr</code> function do find a substring inside a string - just what you are looking for. But.. <code>strstr</code> is not a tokenizer so some extra code is required to print the substrings.</p>

<p>Something like this should do:</p>

<pre><code>int main()
{
  char array[] = ""AAAA... A1... 3. B1..."";

  char* ps = array;
  char* pf = strstr(ps, ""...""); // Find first substring
  while(pf)
  {
    int len = pf - ps;          // Number of chars to print
    printf(""%.*s\n"", len, ps);
    ps = pf + 3;
    pf = strstr(ps, ""..."");     // Find next substring
  }
  return 0;
}
</code></pre>
",,,
54836613,2,54823307,2019-02-22T23:29:21.597,0,,2785528,,2019-02-22T23:36:27.117,2019-02-22T23:36:27.117,2,,"<p>Because you tagged this as c++, here is a c++ 'version' of your code:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl; 

#include &lt;vector&gt;
using std::vector;

#include &lt;string&gt;
using std::string;


class T965_t
{
   string         array;
   vector&lt;string&gt; strings;

public:
   T965_t() : array(""AAAA... A1... 3. B1."") 
      {
         strings.reserve(10);
      }

   ~T965_t() = default;

   int operator()() { return setup(); } // functor entry

private: // methods

   int setup()
      {
         cout &lt;&lt; endl;
         const string pat1 (""... "");
         string s1 = array; // working copy

         size_t indx = s1.find(pat1, 0); // find first ... pattern
         // start search at ---------^
         do
         {
            if (string::npos == indx)  // pattern not found
            {
               strings.push_back (s1); // capture 'remainder' of s1
               break;                  // not found, kick out
            }

            // else 
            // extract --------vvvvvvvvvvvvvvvvv
            strings.push_back (s1.substr(0, indx));  // capture
            // capture to vector

            indx += pat1.size(); // i.e. 4

            s1.erase(0, indx); // erase previous capture 

            indx = s1.find(pat1, 0);          // find next

         } while(true);

         for(uint n = 0; n &lt; strings.size(); n++)
            cout &lt;&lt; strings[n] &lt;&lt; ""\n"";

         cout &lt;&lt; endl;
         return 0;
      }

}; // class T965_t

int main(int , char**) { return T965_t()(); } // call functor
</code></pre>

<p>With output:</p>

<pre><code>AAAA
A1
3. B1.
</code></pre>

<p>Note: I leave changing ""3. B1."" to ""3.B1."", and adding commas at end of each line (except the last) as an exercise for the OP if required.</p>
",,,
54856973,2,54854205,2019-02-24T22:00:37.887,0,,1730895,,2019-02-24T22:00:37.887,,0,,"<p>I ran your code through the UNIX <code>indent</code> tool.  It's available for most platforms.
The indentation is not just to keep it pretty, it keeps the code read-able.  Also there are many programmers editors that will find the ""matching"" bracket/parenthesis (e.g.: '%' in <code>vim</code>).</p>

<p>The code looks to me like it's missing an <code>if</code> condition or suchlike around <code>if ( digitalRead( pirPin ) == HIGH )</code>, since there's a block - or at least a section inside <code>{</code> with no clear reason for it.</p>

<p>Essentially your code is missing 3 lots of <code>}</code>, one of which is closing the aforementioned block.  It should not be hard to repair with a careful read-through.  But failing that, just add them at the end.</p>

<pre><code>void loop(  )
{
    if ( digitalRead( pirPin ) == HIGH )
    {
        digitalWrite( ledPin, HIGH );   //the led visualizes the sensors output pin state
        if ( lockLow )
        {
            //makes sure we wait for a transition to LOW before any further output is made:
            lockLow = false;
            Serial.println( ""---"" );
            Serial.print( ""motion detected at "" );
            Serial.print( millis(  ) / 1000 );
            Serial.println( "" sec"" );
            delay( 50 );
        }
        takeLowTime = true;
    }

    if ( digitalRead( pirPin ) == LOW )
    {
        digitalWrite( ledPin, LOW );    //the led visualizes the sensors output pin state

        if ( takeLowTime )
        {
            lowIn = millis(  ); //save the time of the transition from high to LOW
            takeLowTime = false;        //make sure this is only done at the start of a LOW phase
        }
        //if the sensor is low for more than the given pause, 
        //we assume that no more motion is going to happen
        if ( !lockLow &amp;&amp; millis(  ) - lowIn &gt; pause )
        {
            //makes sure this block of code is only executed again after 
            //a new motion sequence has been detected
            lockLow = true;

            for ( int pos1 = 0; pos1 &lt;= 89; pos1 += 1 )
            {
                servo1.write( pos1 );
                delay( 10 );
            }
            for ( int pos1 = 89; pos1 &gt;= 1; pos1 -= 1 )
            {
                servo1.write( pos1 );
                delay( 10 );
            }
            Serial.print( ""motion ended at "" ); //output
            Serial.print( ( millis(  ) - pause ) / 1000 );
            Serial.println( "" sec"" );
            delay( 50 );

            {

                if ( digitalRead( pirPin ) == HIGH )
                {
                    digitalWrite( ledPin, HIGH );       //the led visualizes the sensors output pin state
                    if ( lockLow )
                    {
                        //makes sure we wait for a transition to LOW before any further output is made:
                        lockLow = false;
                        Serial.println( ""---"" );
                        Serial.print( ""motion detected at "" );
                        Serial.print( millis(  ) / 1000 );
                        Serial.println( "" sec"" );
                        delay( 50 );
                    }
                    takeLowTime = true;
                }

                if ( digitalRead( pirPin ) == LOW )
                {
                    digitalWrite( ledPin, LOW );        //the led visualizes the sensors output pin state

                    if ( takeLowTime )
                    {
                        lowIn = millis(  );     //save the time of the transition from high to LOW
                        takeLowTime = false;    //make sure this is only done at the start of a LOW phase
                    }
                    //if the sensor is low for more than the given pause, 
                    //we assume that no more motion is going to happen
                    if ( !lockLow &amp;&amp; millis(  ) - lowIn &gt; pause )
                    {
                        //makes sure this block of code is only executed again after 
                        //a new motion sequence has been detected
                        lockLow = true;

                        for ( int pos1 = 0; pos1 &lt;= 89; pos1 += 1 )
                        {
                            servo1.write( pos1 );
                            delay( 10 );
                        }
                        for ( int pos1 = 89; pos1 &gt;= 1; pos1 -= 1 )
                        {
                            servo1.write( pos1 );
                            delay( 10 );
                        }
                        Serial.print( ""motion ended at "" );     //output
                        Serial.print( ( millis(  ) - pause ) / 1000 );
                        Serial.println( "" sec"" );
                        delay( 50 );
                    }
                }
            }                   //THE ISSUE IS HERE
</code></pre>
",,,
54903362,2,54902816,2019-02-27T10:31:22.693,4,,4093378,,2019-02-27T10:31:22.693,,1,,"<p>Each time <code>loop</code> is called, 32 bytes of memory is allocated. An Arduino Uno doesn't have much memory so it quickly runs out. You need to deallocate the memory when you're finished using. Here's an analogy.</p>

<p>RAM is a piece of string. This string has a fixed length. You can cut off a piece of this string and use it for whatever you like. This is allocation. If you keep cutting of 32 bytes from your string you'll eventually run out. You need to tape the piece of string back onto the main string when you're finished using it. This is deallocation.</p>

<p>That was a pretty crappy analogy but I hope you got the idea! To solve the immediate problem you can simply append <code>free(result)</code> to the end of the function to deallocate every time you allocate. To really solve the problem properly, you should allocate on the stack instead of the heap. When you allocate on the stack, the memory is automatically deallocated at the end of the scope. To allocate 32 bytes on the stack, you would simply do this:</p>

<pre><code>char result[32];
</code></pre>

<p>The memory in <code>result</code> is only valid within it's enclosing scope (the <code>loop</code> function). The above snippet is basically equivalent to this:</p>

<pre><code>char result_0;
char result_1;
char result_2;
// ...
char result_29;
char result_30;
char result_31;
</code></pre>

<p>Stack allocation is much faster than heap allocation (<code>malloc</code> and <code>free</code>) because the compiler knows exactly how much memory you're using. This has its downsides though. In order to stack allocate memory, the compiler needs to know how much memory you're using! You can't do this:</p>

<pre><code>int size = get_a_number_from_somewhere();
char result[size];
</code></pre>

<p>because the compiler doesn't know how much memory to allocate. This however:</p>

<pre><code>int size = get_a_number_from_somewhere();
char *result = malloc(size);
// ...
free(result);
</code></pre>

<p>is totally fine.</p>

<p>In general, you should stack allocate when the amount of memory you need is a compile-time constant (e.g. <code>32</code>) and heap allocate otherwise. Every time you write <code>malloc</code>, think carefully about where the corresponding <code>free</code> should go.</p>
",,,
54905077,2,54902816,2019-02-27T12:03:54.070,0,,11059346,,2019-02-27T12:03:54.070,,2,,"<p>Why you don't use <code>String()</code>, like the code bellow:</p>

<pre><code>uint32_t counter = 0;

void setup() {
    Serial.begin(9600);
    while(!Serial);
}

void loop() {

    Serial.print(""{\""n\"": "");
    Serial.print(String(counter));
    Serial.println("" }"");

    delay(100);
    counter++;
}
</code></pre>
",,,
54908771,2,54908601,2019-02-27T15:20:19.983,2,,1782465,,2019-02-27T15:28:39.060,2019-02-27T15:28:39.060,0,,"<p>Declaring a pointer to some <code>T</code> only requires that <code>T</code> be declared, not necessarily defined. So just do this:</p>

<pre><code>union Entry;

typedef struct {
  char* entryName;
  const te_UIEntryType entryType = UI_ENTRY_SUBMENU;
  union Entry *entries[];
} ts_EntrySubmenu;

typedef union Entry {
  /* as before */
} tsEntry;
</code></pre>
",,,
54908807,2,54908601,2019-02-27T15:22:28.140,4,,1687119,,2019-02-27T15:22:28.140,,2,,"<p>You need to forward declare <code>tuEntry</code> so that you can use it in <code>ts_EntrySubmenu</code>.  You'll need to give a tag name to that union so it can be  referenced later.</p>

<p>Also, you can't initialize a field of a struct or union as a default when it is defined in C.  You need to set that field in each relevant instance.</p>

<pre><code>typedef union tuEntry tuEntry;

typedef struct {
  char* entryName;
  const te_UIEntryType entryType;   // no default value
  tuEntry *entries[];
} ts_EntrySubmenu;


union tuEntry
{
  tsEntry entry;
  ts_EntryInt entryInt;
  ts_EntrySingle entrySingle;
  ts_EntryBool entryBool;
  ts_EntryDiscrete entryDiscrete;
  ts_EntrySubmenu entrySubmenu;
};
</code></pre>
",,,
54908942,2,54908601,2019-02-27T15:28:46.900,1,,2402272,,2019-02-27T15:35:41.930,2019-02-27T15:35:41.930,0,,"<blockquote>
  <p>Problem is, the submenu entry is a member of the union, so it needs to
  be defined before the union.</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>But it has a pointer to an array of
  instances of this union, which causes a compile error because the
  union's not defined yet.</p>
</blockquote>

<p>The union does not need to have been defined for you to declare a pointer to that type.  It only needs to have been <em>declared</em>.  The definition can come later.</p>

<blockquote>
  <p>Is there a typesafe way of dealing with this, or does my pointer in
  the submenu entry have to be a void*?</p>
</blockquote>

<p>Yes.  Forward-declare the union before the structure definition, and put the union definition later.  This does require you to provide a tag for your union type, else the forward declaration and later definition would not refer to the same type.</p>

<p>Example:</p>

<pre><code>typedef union entry tuEntry;

typedef struct {
  // ...
  tuEntry *entries[];
} ts_EntrySubmenu;


union entry
{
  // ...
  ts_EntrySubmenu entrySubmenu;
};
</code></pre>

<hr>

<p>Additionally, I cannot help noticing that your original code completely avoids declaring any structure or union tags.  I want to make sure you understand that that's a <em>style choice</em>, and especially that the <code>typedef</code> keyword is not about defining types, but rather about declaring <em>aliases</em> for type names.  Your style is not inherently wrong, but it does not support what you want to do.  You need to use structure and union types with tags to link multiple declarations of the same type in the same scope.</p>
",,,
54944872,2,54944742,2019-03-01T12:38:56.693,0,,11042630,,2019-03-01T12:44:56.237,2019-03-01T12:44:56.237,0,,"<p>My fist thought on this would be to embed your script into a C++ program. Python itself suggests <a href=""https://docs.python.org/2/extending/embedding.html"" rel=""nofollow noreferrer"">this</a>. This would be the cleanest way. So you can control, if and when you get new data from your ADC.</p>

<p>Short excerpt from the link:</p>

<blockquote>
  <p>The simplest form of embedding Python is the use of the very high level interface. This interface is intended to execute a Python script without needing to interact with the application directly. This can for example be used to perform some operation on a file.</p>
</blockquote>

<pre><code>#include &lt;Python.h&gt;

int
main(int argc, char *argv[])
{
  Py_SetProgramName(argv[0]);  /* optional but recommended */
  Py_Initialize();
  PyRun_SimpleString(""from time import time,ctime\n""
                     ""print 'Today is',ctime(time())\n"");
  Py_Finalize();
  return 0;
}
</code></pre>

<blockquote>
  <p>The Py_SetProgramName() function should be called before Py_Initialize() to inform the interpreter about paths to Python run-time libraries. Next, the Python interpreter is initialized with Py_Initialize(), followed by the execution of a hard-coded Python script that prints the date and time. Afterwards, the Py_Finalize() call shuts the interpreter down, followed by the end of the program. In a real program, you may want to get the Python script from another source, perhaps a text-editor routine, a file, or a database. Getting the Python code from a file can better be done by using the PyRun_SimpleFile() function, which saves you the trouble of allocating memory space and loading the file contents.</p>
</blockquote>

<p>And so on and so forth. This will guide you in your way. May your project be good =)</p>
",,,
54945332,2,54944742,2019-03-01T13:07:29.860,0,,2261538,,2019-03-01T13:07:29.860,,0,,"<p>If you mean at runtime, probably the simpelst way is via a <code>std::system</code> call</p>

<p>From <a href=""https://en.cppreference.com/w/cpp/utility/program/system"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/cpp/utility/program/system</a>:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main()
{
    std::system(""ls -l &gt;test.txt""); // execute the UNIX command ""ls -l &gt;test.txt""
    std::cout &lt;&lt; std::ifstream(""test.txt"").rdbuf();
}
</code></pre>

<p>Possible output:</p>

<pre><code>total 16
-rwxr-xr-x 1 2001 2000 8859 Sep 30 20:52 a.out
-rw-rw-rw- 1 2001 2000  161 Sep 30 20:52 main.cpp
-rw-r--r-- 1 2001 2000    0 Sep 30 20:52 test.txt
</code></pre>

<p>And just run your python whatever instead.</p>
",,,
54962461,2,54952967,2019-03-02T19:57:54.237,0,,10696971,,2019-03-02T19:57:54.237,,0,,"<p>Ok so apparently the problem was</p>

<p>1.ImShow Requires a frame to show and No where in my code did I assign ""image"" a value</p>

<ol start=""2"">
<li>In order to recieve output from a stream I have to get it frame by frame, I cant just show the whole stream</li>
</ol>

<p>error: (-215:Assertion failed) size.width>0 &amp;&amp; size.height>0 in function 'imshow'</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv )
{
 VideoCapture vcap;


 const string videoStreamAddress = ""udp://&lt;myIp&gt;:&lt;myPort&gt;"";

 vcap.open(videoStreamAddress);
 if(!vcap.isOpened())
 {
     printf(""nope"");
 }
 else
 {
     for(;;)
     {
         Mat frame;
         vcap &gt;&gt; frame;
         imshow(""stuff"", frame);
         if( waitKey(10) == 27) break;
     }
     printf(""Sucsess!"");

 }
return 0;
}
</code></pre>
",,,
54983691,2,54983032,2019-03-04T12:52:16.460,0,,11059346,,2019-03-04T12:52:16.460,,0,,"<p>The problem is your path. You must put the file, you are using just the path and if the path do not exist will throw an error. In your case you just using <code>std::string path = ""/NbData"";</code>, that is you path not your file.
To be able to open your file you need make sure your path exist. Try use the code bellow, he will check if the path exist case not will create and then try to open your file.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int main() {

    std::ios::sync_with_stdio(false);
    std::string path = ""./test_dir/"";
    std::string file = ""test.txt"";

    // Will check if thie file exist, if not will creat
    struct stat info;
    if (stat(path.c_str(), &amp;info) != 0) {
        std::cout &lt;&lt; ""cannot access "" &lt;&lt; path &lt;&lt; std::endl;
        system((""mkdir "" + path).c_str());
    } else if(info.st_mode &amp; S_IFDIR) {
        std::cout &lt;&lt; ""is a directory"" &lt;&lt; path &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; ""is no directory"" &lt;&lt; path &lt;&lt; std::endl;
        system((""mkdir "" + path).c_str());
    }

    std::ofstream nbData(path + file);
    if (!nbData) {
        std::cout &lt;&lt; ""Error during process..."";
        return 0;
    }
    nbData.seekp(std::ios::beg);

    return 0;
}
</code></pre>
",,,
54995435,2,54995265,2019-03-05T04:30:57.780,1,,106104,,2019-03-05T04:30:57.780,,3,,"<p>Use a macro.</p>

<p>You can selectively include code using <code>#ifdef</code> ... <code>#endif</code>. Example:</p>

<pre><code>#ifdef ARDUINO_VERSION
#include ""Arduino.h""
#endif

void setup() {
    // no setup
}

void loop() {
#ifdef ARDUINO_VERSION
    digitalWrite(1, HIGH);
#else
    printf(""Setting pin 1 high\n"");
#endif
}
</code></pre>

<p>There's also <code>#ifndef</code> which does the opposite, it only includes the code if ARDUINO_VERSION <em>isn't</em> defined.</p>

<p>Now you're probably asking, how does the compiler know whether it's the ARDUINO_VERSION or not? Good question. Based on <a href=""https://forum.arduino.cc/index.php?topic=129535.0"" rel=""nofollow noreferrer"">this</a> thread it looks like Arduino will define <code>ARDUINO</code> for you, so you can use <code>#ifdef ARDUINO</code>. Alternatively, since you should have more control over how tests are compiled, you could use <code>#ifdef TEST_VERSION</code> and then compile your tests with the <code>-DTEST_VERSION</code> option.</p>
",,,
55009784,2,55009675,2019-03-05T19:01:50.923,0,,432358,,2019-03-05T19:01:50.923,,2,,"<p>In your class <code>Led</code> you have <code>controller</code> as a field and you do not initialize it, but use assignment to it in <code>Led</code> constructor body, so it must be default constructed first. Solution could be to initialize it and make a copy:</p>

<pre><code>Led::Led(int Pin, i2cController &amp;Controller) :
    controller( Controller ),
    pin( Pin )
{
}
</code></pre>

<p>then your problem should disappear</p>
",,,
55009808,2,55009675,2019-03-05T19:02:56.790,0,,9428851,,2019-03-12T21:02:53.147,2019-03-12T21:02:53.147,2,,"<p>Issue is from constructor of Led class. Constructor is trying to initialize default <code>i2cController controller;</code> field. Constructor is also looking for default i2cController constructor without parameters, which is not defined. </p>

<p>If you need a reference make it like the following. </p>

<pre><code>class i2cController
{
private:
  int foo;

public:
  explicit i2cController(int Foo)
     foo(Foo) 
  {}
  void write(int value);
};

class Led
{
Led(Led&amp;) = delete;
Led&amp; operator=(Led&amp;) = delete;
private:
  i2cController &amp;controller;
  int pin;

public:
  Led(int pin, i2cController &amp;Controller);
  ~Led() noexcept;
  void turnOn();
};

Led::Led(int Pin, i2cController &amp;Controller)
  controller(Controller),
  pin(Pin)
{}
Led::~Led() noexcept
{}
</code></pre>

<p>If you need a copy</p>

<pre><code>class Led
{
private:
  i2cController controller;
  int pin;

public:
  Led(int pin,const i2cController &amp;Controller);
  void turnOn();
};

Led::Led(int Pin,const const i2cController &amp;Controller)
  controller(Controller),
  pin(Pin)
{}
</code></pre>
",,,
55012710,2,55012540,2019-03-05T22:35:59.180,3,,10773340,,2019-03-05T22:35:59.180,,2,,"<p>Your if else statement in case 1 is not correct. 
The first if should be like this</p>

<pre><code>if (i &gt;= 0) {tok[i] = '\0';}
</code></pre>

<p>You are missing the brackets.
And the else statement should also be included in brackets like this.</p>

<pre><code>      if (strcmp(tok, ""person"") == 0) 
      {
        state = 2;
        Serial.println(state);
      }
      else 
      {
        state = 1000;
      }
</code></pre>

<p>Or if it is just one line of code like yours, you could write it in a separate line.</p>

<pre><code>      if (strcmp(tok, ""person"") == 0) 
      {
        state = 2;
        Serial.println(state);
      }
      else 
        state = 1000;
</code></pre>

<p>Otherwise it will assign value 1000 to state, that's why the for loop would skip all the switch cases.</p>

<p>My English is not very good. Hope you understand it.</p>
",,,
55026181,2,55012774,2019-03-06T15:03:37.123,2,,198927,,2019-03-10T19:39:29.243,2019-03-10T19:39:29.243,1,,"<p>This is a <a href=""https://github.com/espressif/esp-adf/issues/18"" rel=""nofollow noreferrer"">known issue</a> with the samples. The ESP32-LYRATD-MSC ships with the ZL38063 DSP chip, but as you can see from sample, it expects to configure the ESP8388:</p>

<pre><code>audio_hal_codec_config_t audio_hal_codec_cfg =  AUDIO_HAL_ES8388_DEFAULT(); // offending line
audio_hal_codec_cfg.i2s_iface.samples = AUDIO_HAL_16K_SAMPLES;
audio_hal_handle_t hal = audio_hal_init(&amp;audio_hal_codec_cfg, 0);
audio_hal_ctrl_codec(hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START);
</code></pre>

<p>To resolve, configure for the ZL38063 instead:</p>

<pre><code>audio_hal_handle_t init_audio_codec()
{
#if (CONFIG_ESP_LYRAT_V4_3_BOARD || CONFIG_ESP_LYRAT_V4_2_BOARD)
    audio_hal_codec_config_t audio_hal_codec_cfg = AUDIO_HAL_ES8388_DEFAULT();
    return audio_hal_init(&amp;audio_hal_codec_cfg, 0);
#endif

#if (CONFIG_ESP_LYRATD_MSC_V2_1_BOARD || CONFIG_ESP_LYRATD_MSC_V2_2_BOARD)
    audio_hal_codec_config_t audio_hal_codec_cfg = AUDIO_HAL_ZL38063_DEFAULT();
    return audio_hal_init(&amp;audio_hal_codec_cfg, 2);
#endif
}
</code></pre>

<h2>Then, in <code>app_main()</code>:</h2>

<pre><code>audio_hal_ctrl_codec(init_audio_codec(), AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START);
</code></pre>
",,,
55014342,2,55014300,2019-03-06T01:54:42.750,1,,579123,,2019-03-06T01:54:42.750,,6,,"<p>Your comparator for your if statement needs a second equals (==):</p>

<pre><code>if(closed == true){
    if(flexValue&gt;handOpen){
        handOpenCount = handOpenCount + 1;
        closed = false;}
}
</code></pre>

<p>Your current if statement will set closed to true and, in doing so, returns as true.</p>
",,,
55031458,2,55031186,2019-03-06T20:13:22.623,1,,11059346,,2019-03-06T20:13:22.623,,0,,"<p>Yes you kind of can use your arduino sketch into <strong>Raspbian</strong> but you must use some libs. I recommend you look at this <a href=""http://wiringpi.com/"" rel=""nofollow noreferrer"">site</a>, the only change is the pinout. WiringPi lib is a PIN based GPIO access library written in C for the BCM2835, BCM2836 and BCM2837, so you can use almost every function like arduino but in Raspberry. Also the way it will be compiled and executed will change. I recommend you learn a little bit of linux and how to compile C++/C code by command line.</p>

<p>There is some example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;wiringPi.h&gt;

using namespace std;


/* Defines */
#define LED  2

int main (int argc, char *argv[]) {
  if (wiringPiSetup() == -1) {
    cout &lt;&lt; ""Unable configure wiringPi! Exiting..."" &lt;&lt; endl;
    return 1;
  }

  pinMode(LED, OUTPUT);

  while (1 &lt; 2) {
    digitalWrite(LED, HIGH);
    delay(500);
    digitalWrite(LED, LOW);
    delay(500);
  }

  return 0;
}

</code></pre>
",,,
55036635,2,55036226,2019-03-07T05:26:11.007,0,,11156380,,2019-03-07T05:32:08.947,2019-03-07T05:32:08.947,0,,"<p>Since Sample time (time after which PID is calculated) is always the same it does not matter whether u divide the integral term with sample time as this sample time will just act as a Ki constant but it is better to divide the integral term by sample time so that if u change the sample time the PID change with the sample time but it is not compulsory.</p>

<p>Here is the PID_Calc function I wrote for my Drone Robotics competition in python. Ignore ""[index]"" that was an array made by me to make my code generic.</p>

<pre><code>def pid_calculator(self, index):

    #calculate current residual error, the drone will reach the desired point when this become zero
    self.Current_error[index] = self.setpoint[index] - self.drone_position[index]      

    #calculating values req for finding P,I,D terms. looptime is the time Sample_Time(dt).
    self.errors_sum[index] = self.errors_sum[index] + self.Current_error[index] * self.loop_time 
    self.errDiff = (self.Current_error[index] - self.previous_error[index]) / self.loop_time

    #calculating individual controller terms - P, I, D.
    self.Proportional_term = self.Kp[index] * self.Current_error[index]
    self.Derivative_term = self.Kd[index] * self.errDiff
    self.Intergral_term = self.Ki[index] * self.errors_sum[index] 

    #computing pid by adding all indiviual terms
    self.Computed_pid = self.Proportional_term + self.Derivative_term + self.Intergral_term 

    #storing current error in previous error after calculation so that it become previous error next time
    self.previous_error[index] = self.Current_error[index]

    #returning Computed pid
    return self.Computed_pid
</code></pre>

<p>Here if the link to my whole PID script in git hub. 
See if that help u.
Press the up button ig=f u like the answer and do star my Github repository i u like the script in github.
Thank you.</p>
",,,
55046694,2,55046212,2019-03-07T14:53:37.473,0,,11033538,,2019-03-07T14:53:37.473,,3,,"<p>Try this</p>

<pre class=""lang-cpp prettyprint-override""><code>template &lt;typename T, typename U&gt;
void addVectorToVector(std::vector&lt;T&gt;* oldVector, std::vector&lt;U&gt; &amp;input) 
{
    for (int i = 0; i &lt; input.size(); i++) {
        T inputVar = (T) input[i];
        oldVector-&gt;push_back(inputVar);
    }

}
</code></pre>
",,,
55071736,2,55069755,2019-03-08T22:14:23.990,0,,131929,,2019-03-08T22:14:23.990,,0,,"<p>I can't be 100% sure (can't test right now) but this sounds like you're missing the DNS resolution.</p>

<p>Try this</p>

<pre><code>...
IPAddress local_IP(192, 168, 1, 111);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 255, 0);
IPAddress dns(8, 8, 8, 8); // Google DNS

void setup() {

  USE_SERIAL.begin(115200);

  WiFi.begin(""networkSSID"", ""myPassword"");

  WiFi.config(local_IP, gateway, subnet, dns);
  ...
</code></pre>
",,,
55081050,2,55080058,2019-03-09T19:17:21.350,0,,168986,,2019-03-09T19:51:43.280,2019-03-09T19:51:43.280,0,,"<p>There is insufficient information for a real answer, so this is rather instruction on the debugging you should already have done and described in your question.</p>

<p>You need to work out what amongst all of that code is not working.</p>

<p>Start with the simplest possible blinking implementation (deliberately slow): </p>

<pre><code>void setup() 
{
  pinMode(relayPin, OUTPUT);
}

void loop() 
{
  digitalWrite(relayPin, HIGH); 
  delay(1000);                
  digitalWrite(relayPin, LOW); 
  delay(1000);                
}
</code></pre>

<p>If that does not work, you have discounted all the MQTT stuff at least.</p>

<p>If it does work, the code you have will do nothing if the response is neither ""ON"" nor ""OFF"" because your code requires one or the other, when in fact you are only interested on ""OFF"" so change to (again deliberately slow):</p>

<pre><code>      if( response == ""OFF"" )
      {
        Serial.println( ""Asserting OFF"" );
        digitalWrite(relayPin, HIGH);
      }
      else
      {
        Serial.println( ""BLINKING"" );
        digitalWrite(relayPin, LOW);
        delay(1000);
        digitalWrite(relayPin, HIGH);
        delay(1000);
      }
</code></pre>

<p>Now if that blinks but you cannot switch it off, then ""OFF"" is not the response you are getting, or possibly it is transient and is not maintained indefinitely, in which case you need a static variable to latch the response.  Observe the serial output to see what path the code takes on each <code>loop()</code> iteration.  </p>
",,,
55094451,2,55094137,2019-03-11T02:20:38.867,0,,6024122,,2019-03-11T02:55:19.143,2019-03-11T02:55:19.143,0,,"<p>I was able to obtain a <a href=""https://stackoverflow.com/help/mcve"">MCVE</a> from your example:</p>



<pre><code>class DataTypes
{
    public:
    struct _theStructNameHere_t
    {

    };
};

class Library
{
    public:
        DataTypes dataTypes;
        DataTypes::_theStructNameHere_t getMyDataType();
};

int main(int argc, char *argv[])
{
    Library myLib;
    myLib.dataTypes._theStructNameHere_t response;
}
</code></pre>

<p>which gives a similar error as your code:</p>



<pre><code>~$ g++ test.cpp 
test.cpp: In function 'int main(int, char**)':
test.cpp:20:21: error: invalid use of 'struct DataTypes::_theStructNameHere_t'
     myLib.dataTypes._theStructNameHere_t response;
</code></pre>

<p>The problem is that you use an instance to access the <code>struct</code> type/name. To fix it, replace</p>

<pre><code>myLib.dataTypes._theStructNameHere_t response = ...;
</code></pre>

<p>with</p>

<pre><code>DataTypes::_theStructNameHere_t response = ...;
</code></pre>

<hr>

<p><strong>Notes:</strong></p>

<ul>
<li>Instead of using classes to create separate namespaces, please consider using <strong>namespaces</strong> directly. This is a feature of <code>C++</code> which is available under <em>Arduino</em>.</li>
</ul>



<pre><code>namespace Library {

namespace DataTypes {

struct _theStructNameHere_t
{
    ...
};

...

} /*** namespace Library::DataTypes ***/

} /*** namespace Library ***/
</code></pre>

<ul>
<li><p>Please read <strong>StackOverflow</strong> guidelines concerning <a href=""https://stackoverflow.com/help/how-to-ask"">how to ask a good question</a>, in particular the section about <a href=""https://stackoverflow.com/help/mcve"">Mininimal, Complete and Verifiable Example</a>.</p></li>
<li><p>Sooner or later someone will tell you that there is no such thing as <code>C/C++</code>; <code>C</code> is <code>C</code> and <code>C++</code> is <code>C++</code>; <code>Arduino</code> lives in its own world, even if is based on <code>C++</code>. Thus, you might want to remove <code>C</code> and <code>C++</code> tags from your question.</p></li>
</ul>
",,,
55127353,2,55125784,2019-03-12T17:23:08.090,2,,10622916,,2019-03-12T17:23:08.090,,1,,"<p>After fixing the assignment of <code>strtok</code>'s result to <code>data</code> as shown in bruno's answer there is another bug that can lead to a crash.</p>

<p>Your function <code>loop()</code> calls <code>recvWithStartEndMarkers()</code> first, then <code>publishReceived()</code>.</p>

<pre><code>void loop() {
  client.loop();
  recvWithStartEndMarkers();
  showNewData();
  publishReceived();
}
</code></pre>

<p>In function <code>recvWithStartEndMarkers</code> you read some data into a local array <code>receivedChars</code>, feed this into <code>strtok</code> and write a pointer returned from <code>strtok</code> to a global variable <code>data</code>.</p>

<pre><code>void recvWithStartEndMarkers() {
  int numChars = 32;
  char receivedChars[numChars]; /* this is a local variable with automatic storage */
  /* ... */

    while (Serial.available() &gt; 0 &amp;&amp; newData == false) {
      /* ... */
          receivedChars[ndx] = rc;
          ndx++;
          if (ndx &gt;= numChars) {
            ndx = numChars - 1;
          }
          /* ... */
          receivedChars[ndx] = '\0'; // terminate the string
          /* Now there is a terminated string in the local variable */
          /* ... */

          //Split the string
          /* ... */
          const char s[2] = "":"";
          data = strtok(receivedChars, s); /* strtok modifies the input in receivedChars and returns a pointer to parts of this array. */ 
          /* ... */
}
</code></pre>

<p>After leaving the function the memory that was <code>receivedChars</code> is no longer valid. This means <code>data</code> will point to this invalid memory on the stack.</p>

<p>Later you want to access the global variable <code>data</code> in a function <code>publishReceived()</code>. Accessing this memory is is unspecified behavior. You may still get the data, you may get something else or your program may crash.</p>

<pre><code>void publishReceived() {
  /* ... */
    char publishText[30]; //TODO: make it JSON
    strcpy( publishText, data ); /* This will try to copy whatever is now in the memory that was part of receivedChars inside recvWithStartEndMarkers() but may now contain something else, e.g. local data of function publishReceived(). */
  /* ... */
</code></pre>

<p>To fix this you could use <code>strdup</code> in <code>recvWithStartEndMarkers()</code>:</p>

<pre><code>data = strtok(receivedChars, s);
if(data != NULL) data = strdup(data);
</code></pre>

<p>Then you have to <code>free(data)</code> somewhere when you no longer need the data or before calling <code>recvWithStartEndMarkers()</code> again.</p>

<p>Or make <code>data</code> an array and use <code>strncpy</code> in <code>recvWithStartEndMarkers()</code>.</p>
",,,
55165999,2,55165811,2019-03-14T15:11:25.173,3,,2570677,,2019-03-14T15:25:00.890,2019-03-14T15:25:00.890,0,,"<p>You seem to have a dangling pointer issue.
You create the client object on the stack:</p>

<pre class=""lang-cpp prettyprint-override""><code>PubSubClient client(espClient);
</code></pre>

<p>then refer to it:</p>

<pre class=""lang-cpp prettyprint-override""><code>this-&gt;client = &amp; client;
</code></pre>

<p>However, once the function <code>SimpleMQTT::begin()</code> exits, <code>client</code> is deleted along with the rest of the function's stack.</p>

<p>You should create the client object on the heap instead.
Change the code to:</p>

<pre class=""lang-cpp prettyprint-override""><code>void SimpleMQTT::begin() {
    Serial.println(""setserver"");
    WiFiClient* espClient = new WiFiClient();
    PubSubClient* client = new PubSubClient(espClient); // Allocate an object on the heap
    client.setServer(this-&gt;serverAddress, this-&gt;port);
    while(!client-&gt;connected()) {
        if (client-&gt;connect(this-&gt;deviceName)) {
            Serial.println(""connected to mqtt"");
            client-&gt;publish(""connecting"", ""connected"");
        } else {
            Serial.println(""failed to connect"");
        }
    }
    this-&gt;client = client;
    this-&gt;client-&gt;publish(""connecting"",""conn2"");
}
</code></pre>

<p><code>espClient</code> should also be a member of your class.</p>

<p>Here is a more elaborate explanation of <a href=""https://en.wikipedia.org/wiki/Dangling_pointer"" rel=""nofollow noreferrer"">danling pointers</a>.</p>
",,,
55200933,2,55190804,2019-03-16T20:00:01.533,0,,7380779,,2019-03-17T07:13:11.567,2019-03-17T07:13:11.567,2,,"<p>if you want to trap the distance you could do this process to validate your sensor has no problem (i suppose wiring is right):</p>

<pre><code>// defines pins numbers
const int triggerPin = 7;
const int echoPin = 6;
// defines variables
long duration;
int distance;
void setup() {
    pinMode(triggerPin, OUTPUT); // Sets the trigPin as an Output
    pinMode(echoPin, INPUT); // Sets the echoPin as an Input
    Serial.begin(115200); // Starts the serial communication
}

void loop() {
    delay(50);
    // Clears the triggerPin
    digitalWrite(triggerPin, LOW);
    delayMicroseconds(2);
    // Sets the triggerPin on HIGH state for 10 micro seconds
    digitalWrite(triggerPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(triggerPin, LOW);
    // Reads the echoPin, returns the sound wave travel time in microseconds
    duration = pulseIn(echoPin, HIGH);
    // Calculating the distance
    distance= duration*0.034/2;
    // Prints the distance on the Serial Monitor
    Serial.print(""Distance: "");
    Serial.println(distance);
}
</code></pre>

<p>In order to generate the ultrasound you need to set the Trig on a High State for 10 µs. That will send out an 8 cycle sonic burst which will travel at the speed sound and it will be received in the Echo pin. The Echo pin will output the time in microseconds the sound wave traveled.</p>

<p>the speed of the sound is 340 m/s or 0.034 cm/µs so you divide by 2 to trap the distance</p>
",,,
55201414,2,55201313,2019-03-16T20:56:39.620,0,,4891009,,2019-03-16T20:58:23.010,2019-03-16T20:58:23.010,5,,"<p>Not sure if you are using the struct</p>

<pre><code>struct tm
{
  int   tm_sec;
  int   tm_min;
  int   tm_hour;
  int   tm_mday;
  int   tm_mon;
  int   tm_year;
  int   tm_wday;
  int   tm_yday;
  int   tm_isdst;
#ifdef __TM_GMTOFF
  long  __TM_GMTOFF;
#endif
#ifdef __TM_ZONE
  const char *__TM_ZONE;
#endif
};
</code></pre>

<p>from <a href=""https://github.com/espressif/arduino-esp32/blob/master/tools/sdk/include/newlib/time.h"" rel=""nofollow noreferrer"">arduino-esp32</a>.</p>

<p>Because in this struct the smalles resolution is seconds.
Why not using one of the integrated timers?</p>
",,,
55201787,2,55201623,2019-03-16T21:44:44.210,1,,777689,,2019-03-16T21:53:50.123,2019-03-16T21:53:50.123,2,,"<p>There's not much sublety, just (imo) bad documentation and suboptiomal API on PubSubClient.</p>

<p>The PubSubClient constructor takes a reference to the client.</p>

<pre><code>PubSubClient(IPAddress, uint16_t, MQTT_CALLBACK_SIGNATURE,Client&amp; client);
</code></pre>

<p>And then takes a pointer to it to store as a member.</p>

<p>This means that it expects the <code>Client</code> instance it takes a reference to to outlive the <code>PubSubClient</code> instance.</p>

<p>There's no garbage collection taking place. It's just that if you declare an object with automatic storage duration then it will be destroyed when it goes out of scope.</p>

<p>So the reason is essentially this:</p>

<pre><code>struct B{
    int num;
};

struct A{
    A(B&amp; param){
        m_b = &amp;param;
    }
    B* m_b;
};

A obj;

setup()
{
    B b;
    obj = A(b); 
    //after this function ends b is considered destroyed
}

loop()
{
    //the following line accesses a member of the already destroyed object
    print(obj.m_b-&gt;num);
}
</code></pre>

<p>This test case exhibits essentially the same ""use after free"" as your code (it probably won't crash but it does contain the same undefined behavior). </p>

<p>The <code>PubSubClient</code> taking a reference to the client and storing the pointer for later use is a bad pattern in my opinion. It should take a pointer to the client to make it more apparent that this is what happens.</p>
",,,
55214381,2,55214290,2019-03-18T03:29:21.910,1,,434551,,2019-03-18T21:38:48.017,2019-03-18T21:38:48.017,1,,"<p>A general advice:</p>

<blockquote>
  <p>Define variables with the smallest scope possible. In your case, unless there is a reason to make <code>t</code> and <code>d</code> global variables, don't make them global variables. Make them function local variables.</p>
</blockquote>

<p>Change your code to:</p>

<pre><code>void loop(){
   int t = 0;
   int d = 0;

   ...

   Serial.println(t);
}
</code></pre>

<p>This will solve your immediate problem and, more importantly, your code will be cleaner.</p>
",,,
55266545,2,55265279,2019-03-20T17:10:32.417,0,,2011372,,2019-03-20T17:10:32.417,,2,,"<p>TL;DR The ESP server doesn't serve the <code>/jquery-1.9.0.min.js</code> and <code>/events.html</code> files that the original HTML references. Read on for details.</p>

<p>When <code>$('#big-box').load('events.html')</code> code executes, the browser makes a HTTP GET call in background to your ESP server, at path <code>/event.html</code>. The requests on that path doesn't seem to be handled on ESP side. To handle requests on that path, you'd need something like this:</p>

<pre><code>server.on('/event.html`, [](AsyncWebServerRequest *request) {
    request-&gt;send(SPIFFS, ""/events-log.html"", ""text/html"", false, processor);
})`.
</code></pre>

<p>Additionally, you'd need to create <code>events-log.html</code> file with following content (basically everything that <code>big-box</code> div contained):</p>

<pre><code>&lt;div class=""textbox""&gt;%PLACEHOLDER_1%&lt;/div&gt;
&lt;div class=""textbox""&gt;%PLACEHOLDER_2%&lt;/div&gt;
&lt;div class=""textbox""&gt;%PLACEHOLDER_3%&lt;/div&gt;
&lt;div class=""textbox""&gt;%PLACEHOLDER_4%&lt;/div&gt;
&lt;div class=""textbox""&gt;%PLACEHOLDER_5%&lt;/div&gt;
</code></pre>

<p>Also note, that the <code>jquery-1.9.0.min.js</code> file that you included in your HTML file (using script tag) wouldn't be loaded for same reason. The browser will try to send a HTTP GET request to <code>/jquery-1.9.0.min.js</code>, and since request on that path isn't handled, browser will get 404 error. </p>

<p>If the computer on which you are accessing this page has internet access, then you can load jQuery from CDN by changing your script tag to following snippet. If the machine doesn't have internet access then you'd need to download the jQuery file, save it to SPIFFS, and serve it in same manner as the other files.</p>

<pre><code>   &lt;script type=""text/javascript"" src=""https://code.jquery.com/jquery-1.12.4.min.js""&gt;&lt;/script&gt;
</code></pre>
",,,
55339865,2,55271832,2019-03-25T14:16:08.380,1,,4209269,,2019-03-25T14:16:08.380,,0,,"<p><strong>update the vibrate variable</strong> within the while loop. You don't need to use <strong>break</strong> </p>

<pre><code>void updateVibrate(){
       //UPDATE THE VIBRATE VARIABLE
    }

    if (vibrate == 1){ //this is the input sensing to the arduino. 
      //It is either 1 or 0
      //constantly run a while loop IF vibrate ==1
      i=51;
      while(vibrate ==1){
         analogWrite(Motor,i); //constantly outputing a pulse of increasing magnitude
         delay(10); //delay it for a certain period of time
         i=i+50; //increment i 
         if (i&gt;=255){
           i=51;
         }
       updateVibrate();//Call function which will update the vibrate (Global) Variable
      }
    }
    else{ //do something else. Has it's own functions}
</code></pre>

<p>Alternatively, when you have fixed number of iterations, you can use for loop with break statement</p>
",,,
55325845,2,55325315,2019-03-24T16:16:23.297,1,,2458991,,2019-03-24T16:16:23.297,,0,,"<p>If the class is defined like that :</p>

<pre><code>const int ROWS = 4;
const int COLS = 4;

class Matrix2d
{
  public:

   char keys [ROWS][COLS];

  private:

};
</code></pre>

<p>that means <em>keys</em> is an attributes of the instance of <em>Matrix2d</em>, but the form </p>

<pre><code>char Matrix2d::keys [ROWS][COLS] =

{
{'1','2','3','A'},
{'4','5','6','B'},
{'7','8','9','C'},
{'*','0','#','D'}
};
</code></pre>

<p>defines and initializes an attribute of the class <em>Matrix2d</em>, this is incompatible</p>

<hr>

<p>If you want an attribute of the class (a 'static' one) do</p>

<pre><code>const int ROWS = 4;
const int COLS = 4;

class Matrix2d
{
  public:
     static char keys [ROWS][COLS];    
};

char Matrix2d::keys [ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
</code></pre>

<p>If you want an attribute of instances having that default value do</p>

<pre><code>class Matrix2d
{
  public:
     char keys [ROWS][COLS] = {
       {'1','2','3','A'},
       {'4','5','6','B'},
       {'7','8','9','C'},
       {'*','0','#','D'}
     };
};
</code></pre>

<p>In both case I encourage you to change the visibility</p>
",,,
55400788,2,55396304,2019-03-28T15:00:32.330,0,,,user10865637,2019-03-28T15:33:28.323,2019-03-28T15:33:28.323,0,,"<p>I discarded  Serial.parseInt() function, removed the switch statments and followed  @Arno Bozo advise on serial listening while following this tutorial on <a href=""http://forum.arduino.cc/index.php?topic=396450.0"" rel=""nofollow noreferrer"">http://forum.arduino.cc/index.php?topic=396450.0</a>
I came up with what I want and here is the code </p>

<pre><code>const int redPin = 3;
const byte numChars = 32;
char receivedChars[numChars];
char tempChars[numChars];        // temporary array for use when parsing

      // variables to hold the parsed data
boolean newData = false;

int InitVal = 0; // change to init value or red
int red = 0;

void setup() {
  // initialize serial:
  Serial.begin(9600);
  // make the pins outputs:
  pinMode(redPin, OUTPUT);

}

void loop() {
    recvWithStartEndMarkers();
    if (newData == true) {
        strcpy(tempChars, receivedChars);
            // this temporary copy is necessary to protect the original data
            //   because strtok() used in parseData() replaces the commas with \0
        parseData();
        One();
        newData = false;
    }
    else {
      Zero();

    }
}


 ///////////////////// ///////////////////// /////////////////////
void recvWithStartEndMarkers() {
    static boolean recvInProgress = false;
    static byte ndx = 0;
    char startMarker = '&lt;';
    char endMarker = '&gt;';
    char rc;

    while (Serial.available() &gt; 0 &amp;&amp; newData == false) {
        rc = Serial.read();

        if (recvInProgress == true) {
            if (rc != endMarker) {
                receivedChars[ndx] = rc;
                ndx++;
                if (ndx &gt;= numChars) {
                    ndx = numChars - 1;
                }
            }
            else {
                receivedChars[ndx] = '\0'; // terminate the string
                recvInProgress = false;
                ndx = 0;
                newData = true;
            }
        }

        else if (rc == startMarker) {
            recvInProgress = true;
        }
    }
}

 ///////////////////// ///////////////////// /////////////////////

void parseData() {      // split the data into its parts

    char * strtokIndx; // this is used by strtok() as an index

    strtokIndx = strtok(tempChars,"","");      // get the first part - the string
    InitVal = atoi(strtokIndx); // copy it to messageFromPC

    strtokIndx = strtok(NULL, "",""); // this continues where the previous call left off
    red = atoi(strtokIndx);     // convert this part to an integer

}


 ///////////////////// ///////////////////// /////////////////////
void One() {

  if (InitVal == 0){

    delay(20);
    Serial.println(0);
    delay(20);
  }      
 }
 ///////////////////// ///////////////////// /////////////////////
void Zero() {

  if (InitVal == 1){

    delay(20);
    Serial.println(red);
    delay(20);
  }      
 }
</code></pre>

<p>In Summary the code works like this</p>

<p>1.In serial monitor send this &lt;1,123> : 1 = the trigger point for the switch statement ; 123 = PWM value.</p>

<ol start=""2"">
<li>Arduino receives instructions and it prints out the pwm value</li>
<li>If you send &lt;0,123> it prints a zero once</li>
</ol>
",,,
55402781,2,55396304,2019-03-28T16:38:34.633,0,,7447144,,2019-03-28T16:38:34.633,,0,,"<p>I post a refined code here. The architecture may be reused for serial treatment. I have written it as an example for people I meet and who are learning with arduino.</p>

<p>I have made comments and explanation of ways to avoid delay. Here it is used to print current value of pwm every 1s, without stopping with a delay(1000).</p>

<pre><code>#include &lt;Arduino.h&gt;

// with schedule(f,i) , the function f() will be called every i ms
//   schedule(f,i)   lines are put in loop()  function
//   f is of type   void f(void)
#define schedule(f,i) {static unsigned long l=0;unsigned long c=millis();if((unsigned long)(c-l)&gt;=i){l=c;f();}}

const int ledPin = 13;

void setup()   {
    Serial.begin(9600);
    pinMode(ledPin, OUTPUT);
}

boolean newCommandHasArrived=false, newParsedCommand=false;
String personalSerialBuffer="""";   // char[] would be better; but String are so convenient
enum ECommand {ecmdNoPwm=0, ecmdPwm=1, ecmdBad=10 };
ECommand cmd=ecmdNoPwm;
int cmdArg=0;

boolean readSerialBuffer(String &amp;personalSerialBuffer);
boolean parseCommand(String &amp;apersonalSerialBuffer, ECommand &amp;acmd, int &amp;acmdArg);
void executeCommand(ECommand acmd, int &amp;acmdArg);
void printCurrentValue()  {Serial.println(String(""cval:"") + cmdArg);}


void loop() {
    // transfer serial buffer in personal buffer
    newCommandHasArrived = readSerialBuffer(personalSerialBuffer);

    if (newCommandHasArrived)   {
        newCommandHasArrived = false;
        newParsedCommand = parseCommand(personalSerialBuffer, cmd, cmdArg);
    }

    if (newParsedCommand)   {
        newParsedCommand = false;
        executeCommand(cmd, cmdArg);
    }

    // I print current value every 1000ms
    //delay(1000);    // you can often use delay without pb, but it is a bad usage
    // Here I provide you with a quick way to execute a task every 1000ms
    {
        const unsigned long  delayBetweenExecution=1000;
        static unsigned long lastTime=0;
        unsigned long current = millis();
        // note that C++ says that overflow on unsigned is well defined
        // it calculates modulo arithmetic
        if ((unsigned long)(millis() - lastTime) &gt;= delayBetweenExecution)   {
            lastTime = current;
            Serial.println(String(""cval:"") + cmdArg);
        }
    }

    // We can make it shorter thanks to a macro:
    //   but you have to define a void function(void)  that uses only global variable
    //   because it has no argument :
    // void printCurrentValue()  {Serial.print(String(""cval:"") + cmdArg);}
    //schedule(printCurrentValue, 1000);
}



boolean readSerialBuffer(String &amp;personalSerialBuffer)   {
    if (Serial.available() &gt; 0) {
        personalSerialBuffer.concat(Serial.readString());
    }

    // the frame is considered finished, if it ends with \n
    if (personalSerialBuffer.endsWith(""\n""))
        return true;
    else
        return false;
}

boolean parseCommand(String &amp;apersonalSerialBuffer, ECommand &amp;acmd, int &amp;acmdArg)   {
    // format [ 1, 123]\n
    // I omit [  then I read first int : 1
    // Note: I cannot detect if no int is found because it will return 0 that is a valid cmd
    int readCmd = apersonalSerialBuffer.substring(1).toInt();

    // conversion readCmd to acmd
    switch (readCmd)   {
    case 0:
        acmd = ecmdNoPwm;   break;
    case 1:
        acmd = ecmdPwm;   break;
    default:
        Serial.println(String(""new command unknown: "") +
                       apersonalSerialBuffer);
        apersonalSerialBuffer = """";
        return false;
    }

    // find beginning of 2nd part, separated by ','
    int sepPos = apersonalSerialBuffer.indexOf(',');
    // no ',' : indexOf returns -1
    if (sepPos == -1)   {
        Serial.println(String(""new command could not be parsed: "") +
                       apersonalSerialBuffer);
        apersonalSerialBuffer = """";
        return false;
    }
    // Note: I cannot detect if no int is found because it will return 0 that is a valid cmd
    acmdArg = apersonalSerialBuffer.substring(sepPos+1).toInt();

    // All is fine
    // I have to reset buffer before leaving
    apersonalSerialBuffer = """";
    return true;
}

void executeCommand(ECommand acmd, int &amp;acmdArg)   {
    switch(acmd)   {
    case ecmdNoPwm:
        // I erase acmdArg
        acmdArg = 0;
        analogWrite(ledPin, acmdArg);
        Serial.println(""cmd no pwm"");
        break;
    case ecmdPwm:
        analogWrite(ledPin, acmdArg);
        Serial.print(""cmd pwm:"");  Serial.println(acmdArg);
        break;
    default:
        analogWrite(ledPin, 0);
        Serial.println(""Bad cmd"");
    }
}
</code></pre>
",,,
55417460,2,55417238,2019-03-29T12:28:59.903,0,,2458991,,2019-03-29T12:28:59.903,,2,,"<p>in</p>

<blockquote>
<pre><code>uint8_t writeBuffer[4] = { 18, 52, 86, 120 };
</code></pre>
</blockquote>

<p>if the index 0 contains the lower byte just do for instance</p>

<pre><code>uint8_t writeBuffer[4] = { 18, 52, 86, 120 };
unsigned long v = writeBuffer[0];

for (size_t i = 1; i != 4; ++i)
  v += ((unsigned long) writeBuffer[i]) &lt;&lt; (i * 8);
</code></pre>

<p>if the index 0 contains the higher byte just do for instance</p>

<pre><code>uint8_t writeBuffer[4] = { 18, 52, 86, 120 };
unsigned long v = writeBuffer[3];

for (size_t i = 1; i != 4; ++i)
  v += ((unsigned long) writeBuffer[3 - i]) &lt;&lt; (i * 8);
</code></pre>
",,,
55461826,2,55452548,2019-04-01T18:58:41.513,0,,10868044,,2019-04-01T18:58:41.513,,2,,"<p>You can try this bit of code and modify to fit.</p>

<pre><code>#include &lt;ESP8266WiFi.h&gt;

#ifndef STASSID
#define STASSID ""your-ssid""
#define STAPSK  ""your-password""
#endif

const char* ssid     = STASSID;
const char* password = STAPSK;

void setup() {
  Serial.begin(115200);

  Serial.println();
  Serial.println();
  Serial.print(""Connecting to "");
  Serial.println(ssid);

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
</code></pre>

<p>All of the code posted above needs to be included in your setup function. Then if you want to reconnect in the middle of your loop function, just insert the following from the above code.</p>

<pre><code>  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
</code></pre>

<p>Also, just so you know, all of this code can be found in the examples of the Arduino IDE for the ESP8266WiFi Client.</p>
",,,
55490428,2,55489106,2019-04-03T08:25:32.620,2,,5840652,,2019-04-03T08:25:32.620,,2,,"<p>STM's HAL library offers a ReadPin function analog to the WritePin function you already used.</p>

<p>It's declaration looks as follows:</p>

<pre><code>GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
</code></pre>

<p>Which means you could read the state of a certain pin like this:</p>

<pre><code>GPIO_PinState ld6_state = HAL_GPIO_ReadPin(LD6_GPIO_Port, LD6_Pin);
</code></pre>

<p>GPIO_PinState is an enumeration:</p>

<pre><code>typedef enum
{
  GPIO_PIN_RESET = 0,
  GPIO_PIN_SET
}GPIO_PinState;
</code></pre>

<p>All that's left is comparing the return value of the read function (ld6_state) to either of the enumeration values. As mentioned by the first answer you'll most likely experience some bouncing of your inputs which is caused by the mechanical construction of your buttons. I guess figuring out how to solve that is part of the assignment so I'll leave that up to you. Keywords to look for: debounce or debouncing</p>
",,,
55491276,2,55489106,2019-04-03T09:08:00.003,3,,2081408,,2019-04-03T09:08:00.003,,0,,"<p>If the assignment is specifically asking for a ""state machine"" then the software should somehow have different internal ""states"" corresponding to the different LED output requirements. There are lots of ways to represent a state machine -- (were you shown one?) -- For example:</p>

<pre><code>// enumeration of the required states
enum OutputState {
    stateAllOff, // I'm *guessing* this is the required initial state?
    stateLeftLED,
    stateRightLED,
    // ... any other states that are specified.
    // ... but *not* random combinations of LEDs that are not part of the specification.
};

enum OutputState currentState = stateAllOff; // or whatever initial state is required

// [...] I'm not going to do the actual assignment here
</code></pre>

<p>A state machine doesn't have to read the LED states, it just ""remembers"" them in the <code>currentState</code> variable. Now the rest of the code becomes a straightforward implementation of the conditions you were given so...</p>

<blockquote>
  <p>""if Left LED is on and Down is Pressed Change to Right LED""</p>
</blockquote>

<pre><code>    if (currentState == stateLeftLED) {
        if (Joystick == ""D"") {
            WriteLED ('R', LED_ON);
            WriteLED ('L', LED_OFF);
            currentState = stateRightLED;
        }
    }
</code></pre>
",,,
55588390,2,55511331,2019-04-09T08:34:22.023,0,,11310167,,2019-04-09T08:34:22.023,,0,,"<p>Basing on the solution of this problem <a href=""https://stackoverflow.com/questions/33745187/python-compilation-error-long-bit-definition-appears-wrong-for-platform"">Python compilation error: ""LONG_BIT definition appears wrong for platform""</a> .I changed in <strong>lib/python2.7/Include/pyconfig.h</strong> this line <code>#define SIZEOF_LONG 8</code>  bye this line <code>#define SIZEOF_LONG 4</code> (explanation : '4' for 32 bits and '8' for 64 bits ).</p>

<p>but now I have a new error that i does't understand :::</p>

<pre><code>t/usr/lib/arm-linux-gnueabihf -lQt5Widgets -lQt5Gui -lQt5Qml -lQt5Network -lQt5Xml -lQt5Core -Wl,-rpath-link,/opt/qtrpi/raspbian/sysroot/opt/vc/lib -lGLESv2 -lpthread 
/home/Documents/project/digitalsignage/lib/python2.7//libpython2.7.a : erreur lors de l'ajout de symboles : Format de fichier non reconnu
collect2: error: ld a retourné le statut de sortie 1
Makefile:170: recipe for target 'DigitalSignal' failed
make: *** [DigitalSignal] Error 1
</code></pre>

<p>can anyone what is the meaning of this error ???</p>
",,,
55536918,2,55527046,2019-04-05T13:51:17.730,0,,8078317,,2019-04-07T01:26:27.357,2019-04-07T01:26:27.357,2,,"<p>These are the issues with what you are doing.</p>

<p>1) The code that you have written takes 42 seconds to iterate through the loop. So you check if the alertDelay has finished once ever 42 seconds.
2) The second time around the code reaches the back to the start of the loop, you first end up setting the alertDelay again before checking if it is running or is finished, which resets it, as such, your code never reaches the part where it displays the crash.</p>

<p>This is how I would have done things </p>

<pre><code>#include &lt;LiquidCrystal.h&gt;

int red = 22;
int yellow = 23;
int green = 24;
int red2 = 25;
int yellow2 = 26;
int green2 = 27;
const int pingPin = 7; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor
long duration, inches, cm;

long alertDisplayTime = millis(), nextLedSwitchTime = millis();
bool displayAlert = false;

int switch_number=-1;

const int rs = 36, en = 38, d4 = 40, d5 = 42, d6 = 44, d7 = 46;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // put your setup code here, to run once:
  pinMode(red, OUTPUT);
  pinMode(yellow, OUTPUT);
  pinMode(green, OUTPUT);
  pinMode(red2, OUTPUT);
  pinMode(yellow2, OUTPUT);
  pinMode(green2, OUTPUT);
  pinMode(pingPin, OUTPUT);
  pinMode(echoPin, INPUT);
  lcd.begin(16,2);
  Serial.begin(9600); // Starting Serial Terminal
  nextLedSwitchTime=1000+millis();
}

void loop() {
  lcd.clear();

  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(pingPin, LOW);
  duration = pulseIn(echoPin, HIGH);
  cm = microsecondsToCentimeters(duration);
  Serial.print(inches);
  Serial.print(""in, "");
  Serial.print(cm);
  Serial.print(""cm"");
  Serial.println();
  delay(100);

  if (cm&gt;=11){
    lcd.setCursor(0,0);
    lcd.print(""Intersection"");
     lcd.setCursor(0, 1);
     lcd.print(""Clear"");
    displayAlert=false;
  }

  else if ((cm&lt;7)&amp;&amp;(!displayAlert)){
    lcd.setCursor(0,0);
    lcd.print(""Intersection"");
    lcd.setCursor(0, 1);
    lcd.print(""Clear"");
    alertDisplayTime = millis()+7000;
    displayAlert=true;
    Serial.println(""delay started"");
  }

  if ((displayAlert==true)&amp;&amp;(alertDisplayTime&lt;millis())) {
    Serial.println(""There is a crash up ahead"");
    lcd.setCursor(0,0);
    lcd.print(""Crash Up Ahead"");
    lcd.setCursor(0,1);
    lcd.print(""Use Caution"");
    displayAlert=false;
  }
  if(nextLedSwitchTime&gt;=millis()){
    return;
  }
  long delay_time=0;
  switch_number++;
  switch(switch_number){
    case 0:
  //'2'refers to intersection number 2
  //green off,red2 on, yellow on for 3 seconds
  digitalWrite(red2, HIGH);
  digitalWrite(green, LOW);
  digitalWrite(yellow, HIGH);
  delay_time=3000;
  break;
    case 1:
  // turn off yellow1, then turn red on for 3 seconds
  digitalWrite(yellow, LOW);
  digitalWrite(red, HIGH);
  delay_time=3000;
  //after 3 seconds keep red 1 on and turn red2 off and green2 on,
  break;
    case 2:
  //green2 stays on for 15 seconds to let traffic through
  digitalWrite(red2, LOW);
  digitalWrite(green2, HIGH);
  //after 15 seconds green2 turns off, yellow 2 turns on
  delay_time=15000;
  break;
    case 3:
  //yellow2 turns on for 3 seconds,
  digitalWrite(green2, LOW);
  digitalWrite(yellow2, HIGH);
  //after 3 seconds, yellow2 turns off, and red 2 turns on
  delay_time=3000;
  break;
    case 4:
  digitalWrite(yellow2, LOW);
  digitalWrite(red2, HIGH);
  //3 seconds after red2 turns on, red 1 turns off and
  delay_time=3000;
  break;
    case 5:
  //green 1 turns on for 3 seconds
  //red2 stays on
  digitalWrite(red, LOW);
  digitalWrite(green, HIGH);
  delay_time = 14000;
    switch_number=-1;
  }
  nextLedSwitchTime = millis()+delay_time;
}

long microsecondsToCentimeters(long microseconds) {
  return microseconds / 29 / 2;
}
</code></pre>

<p>What this code does is it never blocks the loop funciton, so your pusle in function is carried out almost every second along with the check for the crash.
Also, i have set a bit, which tells the code that the alert delay has already started, which ensures that your code does not reset it.</p>
",,,
55540995,2,55540460,2019-04-05T17:56:28.627,0,,1527,,2019-04-05T17:56:28.627,,0,,"<p>Every time the milliseconds change, you write about 30 bytes. 30 bytes at 4800 baud is 30/480 * 1000 ms = 62ms. So once the buffer is full, this will block. But you assume that only one millisecond has elapsed in your calculation.</p>

<p>Also the way you count pulses is skewed:</p>

<pre><code>// ai0 is activated if DigitalPin nr 2 is going from LOW to HIGH
// Check pin 3 to determine the direction

// ai[1] is activated if DigitalPin nr 3 is going from LOW to HIGH
// Check with pin 2 to determine the direction
</code></pre>

<p>so if we have the offset encoding, we get two counter increments per pulse cycle:</p>

<pre><code>pin 2   ________********________********

pin 3   ****________********________****


                !ai0            !ai0
                    !ai1            !ai1
                counter++       counter++
                    counter++       counter++
</code></pre>

<p>So you're probably incrementing counter 800 times a revolution..</p>
",,,
55563092,2,55560673,2019-04-07T19:54:36.630,0,,11004853,,2019-04-07T19:54:36.630,,0,,"<p>""You have the problem because you tried to define <code>DHT dht(1, DHT22);</code> multiple time.</p>

<p>Try this: 
<br> your .h file should look like</p>

<pre><code>#ifndef temperaturaPOO_h
#define temperaturaPOO_h
#include ""Arduino.h"" 
#include &lt;DHT.h&gt;

class temperaturaPOO {  
private:
    DHT dht;            //define dth here
    int sensor_humedad;
    int sensor_temperatura;
    public:
        temperaturaPOO(int); // ?? x
        void mostrar();     
};
#endif
</code></pre>

<p>and .cpp</p>

<pre><code>#include ""temperaturaPOO.h""
temperaturaPOO::temperaturaPOO(int pin){
    dth = DHT(pin, DHT22);
}

void temperaturaPOO::mostrar()
{
    sensor_humedad = dht.readHumidity();  
    sensor_temperatura = dht.readTemperature();

    Serial.print(""Humidity:"");
    Serial.println(sensor_humedad);
    Serial.print(""Temperature:"");
    Serial.println(sensor_temperatura);
}
</code></pre>
",,,
55563201,2,55560673,2019-04-07T20:07:05.983,0,,9513106,,2019-04-07T20:35:04.323,2019-04-07T20:35:04.323,0,,"<p>The answer is in <a href=""https://stackoverflow.com/questions/26602268/arduino-c-classes-how-to-make-instance-variables-of-another-class-library"">one of the links you posted</a>. The comments explain how to initialize objects in a constructor. When you pass a member constructor, you want to use <a href=""https://stackoverflow.com/questions/926752/why-should-i-prefer-to-use-member-initialization-list"">initializer list</a>.</p>

<p>The header should look something like this.</p>

<pre class=""lang-cpp prettyprint-override""><code>#ifndef temperaturaPOO_h
#define temperaturaPOO_h
#include ""Arduino.h"" 
#include &lt;DHT.h&gt;

class temperaturaPOO {  
    int sensor_humedad;
    int sensor_temperatura;
public:
    temperaturaPOO(int);
    void mostrar();

private:
    DHT dht;
};
#endif
</code></pre>

<p>And here is the implementation. Look how <code>dht</code> is initialized.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;temperaturaPOO.h&gt;

temperaturaPOO::temperaturaPOO(int pin): dht(pin, DHT22) {}

void temperaturaPOO::mostrar()
{
    sensor_humedad = dht.readHumidity();  
    sensor_temperatura = dht.readTemperature();

    Serial.print(""Humidity:"");
    Serial.println(sensor_humedad);
    Serial.print(""Temperature:"");
    Serial.println(sensor_temperatura);
}
</code></pre>
",,,
55579966,2,55560673,2019-04-08T18:50:59.577,0,,11322286,,2019-04-08T18:50:59.577,,0,,"<p>Thanks, it works!!</p>

<p>I did not read the sensor data, so I added these two lines at the beginning of the method and it works properly.</p>

<p>temperaturaPOO.cpp</p>

<pre><code>void temperaturaPOO::mostrar()
{
    dht.begin(); // add this
    delay(2000); // add this
    sensor_humedad = dht.readHumidity();  
    sensor_temperatura = dht.readTemperature();
    Serial.print(""Humidity:"");
    Serial.println(sensor_humedad);
    Serial.print(""Temperature:"");
    Serial.println(sensor_temperatura);
}
</code></pre>

<p>I have one doubt in the initialization of the attributes of the constructor:</p>

<p>How do you read this line, in other words how to be documented to make a good understanding, thank you!</p>

<p>This Line:</p>

<pre><code>temperaturaPOO::temperaturaPOO(int pin): dht(pin, DHT22) {}
</code></pre>
",,,
55574324,2,55570854,2019-04-08T13:13:27.913,0,,4638274,,2019-04-08T13:13:27.913,,0,,"<p>Thanks to KIIV I have been able to edit my code like this.</p>

<p>SSDReader.h</p>

<pre><code>#pragma once
#include &lt;Arduino.h&gt;
#include &lt;SPIFFS.h&gt;

using namespace fs;
class SSDReader : public SPIFFSFS {
  public:
    SSDReader() : SPIFFSFS{ SPIFFS } { };
    void getConfig();

  protected:
};
</code></pre>

<p>SSDReader.cpp</p>

<pre><code>#include ""SSDReader.h""

//SSDReader::SSDReader() {}


void SSDReader::getConfig() {

}
</code></pre>

<p>main.cpp</p>

<pre><code>#include &lt;Arduino.h&gt;
#include ""include/SSDReader.h""
//#include ""include/Display.h""

// Variables
SSDReader ssd;
bool enableSerial = false;

//Display display;

void setup() {
  if (enableSerial)
    Serial.println(9600);

  // Init SSDReader
  if (!ssd.begin()) {

  }

}

void loop() {

}
</code></pre>

<p>And it works. Thank you very much. I am going to selfstudy more.</p>
",,,
55579574,2,55579371,2019-04-08T18:23:20.770,7,,2064761,,2019-04-08T19:05:48.880,2019-04-08T19:05:48.880,4,,"<p>I believe this code should have been ill-formed based on <a href=""http://eel.is/c++draft/stmt.dcl#3"" rel=""nofollow noreferrer"">[stmt.dcl]/3</a>:</p>

<blockquote>
  <p>It is possible to transfer into a block, but not in a way that bypasses declarations with initialization (including ones in conditions and init-statements). <strong>A program that jumps from a point where a variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed</strong> unless the variable has vacuous initialization ([dcl.init]).</p>
</blockquote>

<p>emphasis mine. Your variable <code>mask</code> does not have <a href=""http://eel.is/c++draft/basic#life-1"" rel=""nofollow noreferrer"">vacuous initialization</a>. At least as far as my understanding goes, ""ill-formed"" implicitly requires a diagnostic, i.e., a standard-conforming compiler must produce an error message. So no undefined behavior, this should simply never have compiled.</p>

<p>Thus, I would say that the lack of a diagnostic here is definitely to be considered a compiler bug. Note, however, that none of the GCC versions that one can try on godbolt accept this code (and they go quite far back). It would seem that the Arduino IDE must be using a hopelessly outdated/broken version of GCC if it did indeed compile this code without a flinch&hellip;</p>

<p><a href=""https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5BwAMAQTnyAbqjzoA1ADMIeFgQ0APAJRKOAdj4KNNjYIDuhZAg0QTS2xotX5n5E0FMDVoQD09bNBZBAz0DAE8vAGYAEQ0AFi4ORJ9w2wAjYkwmAGssnzCbf0CNLlDrXI0CotLsiq9zZLMOpSljRmkAVilSFmlZYdRpAGF%2BfjtRcSDuRNphgjHevuKQLkSAOkSucwBOI/NzWgA2Li5LxP6pNOGAWzpZWRGN0kmpYcEQD7rKTjPpwWAwRAoVDPAAOeAYmDIFAgaFh8MRKGYbAA%2BgRiCIWMVSFp4QREf8IHkvnk9ExiHFpKtSKjnph9AB5FgMBnA4ZYZ6sYAIr74QrIAh4ZSYf680iYQyYZAiMmM4axTAML4MPAFOlxKYYSRSJl4vCvY29RiClCzXiMHX/SB9VAwiWoKLSP4LCR0PqaqRDT6yn6GAAclwAtJc0hpkFjgK48QTisZXLhCCQvLt6BoDWiEcQsytUzNePw1htjFsdqG9tcjsdrmlm4k7rsHk9SK8Bh9RsHPUIAaQgSDSGDIaICDDleRKKi4QW6HL8ERiEv7MQmDDVX7BsM%2B%2BNvtJlrQNI4CC4w5Ho7H44n8YTjBXeVXSAgilg1xBd48XiAe0Gh4/H8Q4jpspDbLcezmK2pznAMtBpIkaRXA8iT7l8wHDpWY4QuO%2BFIPO6JInO0ILhiwCCCwW6CAgqAEMSpLkpQVKyjS1H0qqzLQqyHJcjyh78oKwqyqKioSlKMqHvKirKkaTLqv6h7arq9IGlgXGmuaqx%2BtanBlnaKmOt%2B3yung7oyl6Yg%2BrQP6BgeEzSFeUYxsAyDIPeyaphA6arkWOZ5uRhbLFwJa2jwz4gn075MJ%2BlDVgB/qdt2vaYQO/yAjhBEgJO04MciRGLlwy4Zmu9AbluO4PPZaUyLsXBnoQl7hi5GhuR5EBJo%2BkXgTFcUmUlf4AQ5R6/IOmUvglsh7AMxzNgh5ihokiQDAMK1oRh/ZjWBoJ4XhhFkcRs4oodi7KMgMIwtiyi0Mc2JcLI2KGNGjEMGSxAUqxh7sXqXEsmyBCctyIqYAKbAiYJeBihJ0pfDJSoqha5D6BqWo6puamGppxBmlV8Y2gZAhGfAzpmRZ6XepItnVZtQFOTezyCOdGg3ccewPWmK6ZiepC5qdiJFokYWEz1r59RiJnbIk5gzR2Q2pVtIETaO2W5TOBX82u9yYFzZWkBV24WnZtOOXVy2NReRgM0zHms%2Bzh47dFH4Sz%2ByX/grdNjRl2GTRBIBpGzaSyKtaShlwVzRmklwDBtgGm6L1YB3sxwrYhzbmJcc2HLQMf%2Blwf60O8cejQnDz512bwe/HPtRaQUofeZoxpEAA%3D%3D"" rel=""nofollow noreferrer"">example of proper compilers complaining about this</a></p>

<p>To fix the issue, simply wrap your variable in a block scope such that there's no possible control flow that could enter the scope in which the variable is declared without passing its declaration, as you have already discovered yourself. For example, turn this</p>

<pre><code>void f(int x)
{
    switch (x)
    {
    case 1:
        const int y = 42;  // error
        break;

    case 2:
        break;
    }
}
</code></pre>

<p>into</p>

<pre><code>void f(int x)
{
    switch (x)
    {
    case 1:
        {
            const int y = 42;  // OK
            break;
        }

    case 2:
        break;
    }
}
</code></pre>
",,,
55661983,2,55645481,2019-04-13T04:22:53.823,0,,11266288,,2019-04-13T04:22:53.823,,0,,"<p>void loop()</p>

<p>{</p>

<p>while (sgps.available())</p>

<p>{</p>

<pre><code>int c = sgps.read();

if (gps.encode(c))
{

  float slat,slon;
  gps.f_get_position(&amp;slat, &amp;slon);
  Serial.print(""Latitude :"");
  Serial.println(slat, 6);
  Serial.print(""Longitude:"");
  Serial.println(slon, 6);
</code></pre>

<p>String loc = String(slat,6)+"" ""+String(slon,6);</p>

<p>Serial.println (""Sending Message"");</p>

<p>sim.println(""AT+CMGF=1"");    //Sets the GSM Module in Text Mode</p>

<p>delay(1000);</p>

<pre><code>Serial.println (""Set SMS Number"");

sim.println(""AT+CMGS=\"""" + number + ""\""\r""); //Mobile phone number to send message

 delay(1000);
</code></pre>

<p>String SMS = String(""<a href=""https://www.google.com/maps/"" rel=""nofollow noreferrer"">https://www.google.com/maps/</a>"")+ String(slat,6)+"",""+String(slon,6);</p>

<p>sim.println(SMS);</p>

<p>delay(100);</p>

<p>sim.println((char)26);// ASCII code of CTRL+Z</p>

<p>delay(1000);</p>

<p>_buffer = _readSerial();</p>

<pre><code>}
</code></pre>

<p>}</p>

<p>}</p>
",,,
55647515,2,55647368,2019-04-12T08:31:14.113,3,,2955790,,2019-04-12T08:31:14.113,,2,,"<pre><code>CC = gcc
CFLAGS = -Wall -O0 -std=gnu99 -I/usr/local/include -g
LDFLAGS = -L/usr/local/lib -pthread -lm -lwiringPi
FUSEFLAGS = `pkg-config fuse --cflags --libs`

SOURCES = $(wildcard *.c)
PROGS = $(patsubst %.c,%,$(SOURCES))
BINS = $(SOURCES:.c=)

all: $(PROGS)

%: %.c
&lt;___T___A___B___&gt;$(CC) $&lt;  $(CFLAGS) $(LDFLAGS) -o $@ $(FUSEFLAGS)

clean:
&lt;___T___A___B___&gt;$(RM) *.o *.a $(BINS)
</code></pre>

<p>Where I have written <code>&lt;___T___A___B___&gt;</code>, there should be 1 tab and not spaces !</p>
",,,
55650147,2,55648053,2019-04-12T10:59:39.137,0,,11350794,,2019-04-12T11:25:55.100,2019-04-12T11:25:55.100,0,,"<p>you are clearing the lcd display frequently, so it will look like flickering.</p>

<p>i used a two more variables to find, Is there any need to update the display? change the display contents only if required, I didn't compile code but hope this will  solve your problem, i use similar technique in my projects. </p>

<pre><code>prev_menu=-1;
update_display=true;

void loop() {
  drawMenu(RotaryEncoder());
  delay(300);
}


void drawMenu(byte rotaryPosition) {
  stateBtnSelect = digitalRead(BTN_SELECT);
  if (stateBtnSelect == HIGH &amp;&amp; previousBtnState == LOW &amp;&amp; millis() - time &gt; debounce) {
    if (state == HIGH)
        state = LOW;
    else
      state = HIGH;
    time = millis();
    update_display=true;
  }
  previousBtnState = stateBtnSelect;

    if(prev_menu != rotaryPosition)
            update_display=true;
    else
        update_display=false;

  //Switch the value of the rotary encoder
  switch (rotaryPosition) {
    case 0:
      displayMenuItem(0);
      if (state == HIGH) {
        prg_Pong();
      }
      break;
    case 1:
      displayMenuItem(1);
      if (state == HIGH) {
        prg_Ascroll();
      }
      break;
    case 2:
      displayMenuItem(2);
      if (state == HIGH) {
        prg_Clock();
      }
      break;
    case 3:
      displayMenuItem(3);
      if (state == HIGH) {
        prg_Flame();
      }
      break;
    case 4:
      displayMenuItem(4);
      if (state == HIGH) {
        prg_Heartbeat();
      }
      break;
    default:
      break;
  }
}

//Display a menu item
void displayMenuItem(byte item)
{
  //menu strings (mai n categories)
    if(  update_display){

    String menuItems[MAX_MENU_ITEMS] = {""Pong game"", ""A. Scroller"", ""Clock"", ""Flame/temp"", ""Heartbeat""};
    lcd.clear();
    lcd.setCursor(6, 0);
    lcd.print(""Menu"");
    lcd.setCursor(0, 1);
    lcd.write(byte(0));
    lcd.print(menuItems[item]);
    prev_menu=item;

    }
}


void prg_Pong()
{
if(update_display){
  lcd.clear();
  delay(100);
  lcd.print(""run pong"");
    update_display=false;

  }
  mtx_clear();

  //print cirlce once
  MessageEncoder(ReturnLetter(24), BitStream);
  for (int j = 0; j &lt; 8; j++)
  {
    displayData(~BitStream[j] &amp; Kolommen[j]);
  }
}
</code></pre>
",,,
55657006,2,55656641,2019-04-12T17:37:47.280,0,,669576,,2019-04-12T17:52:00.957,2019-04-12T17:52:00.957,0,,"<p>You are returning a pointer to a <code>static</code> variable. This makes every <code>arrayThings[t].mac</code> point to it. A couple fixes.</p>

<p>Use <code>new</code> (Arduino IDE uses C++ by default. If you are using C, use <code>malloc()</code>):</p>

<pre class=""lang-c++ prettyprint-override""><code>char* CombineChars(char* str1, char* str2)
{
    char *strOut = new char[strlen(str1) + strlen(str2) + 2];
    ....
</code></pre>

<p>And don't forget to <code>delete</code> (or <code>free()</code>). However calling <code>new</code> too often on an Arduino can fragment the heap, so it should be used sparingly.</p>

<p>Another option is to make your structs have arrays. This avoids <code>new/delete</code> altogether:</p>

<pre><code>typedef struct { 
    char name[256];
    char mac[256];
} objThing;

bool CombineChars(char *str1, char *str2, char *dest, size_t dest_size)
{
    // Ok to be static. Just a temp buffer
    static char strOut[256];
    size_t required_space = strlen(str1) + strlen(str2) + 2;
    if (required_space &lt;= sizeof(strOut) &amp;&amp; required_space &lt;= dest_size) {
        sprintf(strOut, ""%s-%s"", str1, str2);
        strcpy(dest, strOut);
        return true;
    }
    return false;
}
</code></pre>

<p>Or just use Arduino <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/stringobject/"" rel=""nofollow noreferrer"">Strings</a>:</p>

<pre><code>typedef struct { 
    String name;
    String mac;
} objThing;


String separator = ""-"";
for (uint8_t t = 0; t &lt; sizeof(arrayThings)/sizeof(objThing); t++)
{
    char* new_mac = string2char(MAC_ADDRESS);
    arrayThings[t].mac = arrayThings[t].name + separator + new_mac;
}
</code></pre>
",,,
55678340,2,55678021,2019-04-14T17:57:30.417,3,,104458,,2019-04-14T17:57:30.417,,9,,"<p>You tagged this question as C++, so I'll ask:</p>

<p>Can you use <code>vector</code> and <code>string</code> in your embedded code?</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;

struct stUSRREC {
  std::string username;
  bool online;
  stUSRREC(const char* name, bool isOnline) :
       username(name), 
       online(isOnline)
  {
  }
};

std::vector&lt;stUSRREC&gt; userRecords;
</code></pre>

<p>The use of <code>string</code> as the username type means you only allocate as many characters needed to hold the name instead of allocated an assumed max size of <code>sizeOfUsername</code>.  The use of <code>vector</code> allows you to dynamically grow your record set.</p>

<p>Then to add a new record:</p>

<pre><code>stUSRREC record(""bob"", true);
userRecords.push_back(record);
</code></pre>

<p>And you may not need <code>NumOfrecs</code> anymore.  That's covered by <code>userRecrods.size()</code></p>
",,,
55680739,2,55680701,2019-04-14T22:52:22.377,0,,10848591,,2019-04-14T22:52:22.377,,2,,"<p>returning a local array(declared inside the function) is going to cause you problems because it gets out of scope as soon as the function ends. To return a local array it has to be dynamically allocated so it can outlive the function</p>

<pre><code>float* result (float x, float y, float z)
{
  float* coordArray=malloc(3*sizeof(float));

  coordArray[0] = x;
  coordArray[1] = y;
  coordArray[2] = z;
  return coordArray; 
}
</code></pre>
",,,
55684499,2,55680701,2019-04-15T07:39:42.983,0,,4929220,,2019-04-15T19:25:57.340,2019-04-15T19:25:57.340,10,,"<p>As it was said in the other answer, as <code>coordArray</code> has been allocated in your function, it will get out of scope whenever your program exit this function, thus the values pointed by your pointer will no longer be correct.</p>

<p>If you need to call this function several times and want to avoid memory leaks from <code>malloc</code> you can declare <code>float coordArray[3]</code> as a global variable, update it in your function <code>result</code> which will then be a <code>void</code> function.</p>

<p>Something like</p>

<pre><code>//global declaration
float coordArray[3]

/*
Setup and other code
*/

void result (float x, float y, float z)
{
  coordArray[0] = x;
  coordArray[1] = y;
  coordArray[2] = z;
}
</code></pre>

<p>This way you will avoid your error.</p>

<p>Note: global variables are usually considered as not clean in C/C++, however, for embedded systems with low memory requirements and where a memory leak will have big consequences very fast, it is usually advised <strong>not to</strong> use dynamic allocation.</p>

<p>Hope it helps!</p>

<p>** EDIT **</p>

<p>As your result is <code>void</code>, you should not assign its return value to something, it is returning nothing. Just calling <code>result(yaw, pitch, roll);</code> will update <code>coordArray</code>.</p>

<p>In order to convert this array to string you should do it sequentially as <code>dtostrf</code> expects a <code>double</code> and you have several of them:</p>

<pre><code>for (unsigned int i=0; i&lt;3;i++){
  char tamp[4];
  dtostrf(coordArray[i], 1, 3, tamp); //convert one of your coordinates
  for (unsigned int j=0;j&lt;3;j++) txStringYaw[4*i+j] = tamp[j]; //concatenate it inside txStringYaw
}
</code></pre>

<p>I did not test that though, there might be a small syntax error.</p>

<p>Note: i do not know if I understood your problem well, but in my code <code>txStringYaw</code> will contain your three coordinates. You can adapt it easily in order to have only the Yaw if you want!</p>
",,,
55695557,2,55684371,2019-04-15T18:49:02.223,4,,4561887,,2019-04-16T22:57:07.887,2019-04-16T22:57:07.887,3,,"<h1>How to properly include C/C++ headers and source files in your Arduino Project.</h1>

<p><em>This answer has been tested and compiled to ensure it works.</em> (Completed in Linux Ubuntu with the Arduino 1.8.7 IDE).</p>

<p>You have 2 problems. </p>

<p><strong>1st:</strong> Arduino's unusual build process (<a href=""https://github.com/arduino/Arduino/wiki/Build-Process"" rel=""nofollow noreferrer"">described here</a>) doesn't allow including from sub-folders in your project directory where your <code>.ino</code> file for this project is located.</p>

<p><em>[UPDATE: THIS ONE MAY HAVE BEEN MY MISTAKE ONLY, NOT YOURS, when I was duplicating your code on my PC: I accidentally used <code>foo.c</code> instead of <code>foo.cpp</code>]</em><br>
<strong>2nd:</strong> C++ can only be used inside C++ source files, so you must change <code>foo.c</code> to <code>foo.cpp</code>, since <code>Serial.println()</code> is a C++ call to a C++ class's (<code>Serial</code>'s) <code>println()</code> method.</p>

<p><strong>To fix 1</strong>, simply change your folder structure to have everything in a single folder:</p>

<pre><code>project
├── foo.cpp
├── foo.hh
└── project.ino
</code></pre>

<p>I present an alternate fix for #1 below too.</p>

<p><strong>To fix 2</strong>, (this is mandatory!) make <code>foo.c</code> --> <code>foo.cpp</code> and (optionally, but recommended, to show it is a C++ header file) <code>foo.h</code> --> <code>foo.hh</code>. Update your includes in the .ino and .cpp file now too to <code>#include ""foo.hh""</code>.</p>

<p>That's it! Now close the Arduino IDE, then reopen it and reopen your project, and you'll see the following new tabs show up:</p>

<p><a href=""https://i.stack.imgur.com/9DdkP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9DdkP.png"" alt=""enter image description here""></a></p>

<p>It now compiles just fine!</p>

<h1>Learning: how did I figure this out?</h1>

<p>First, turn on verbose compilation in the Arduino IDE: File --> Preferences --> check the box for ""Show verbose output during 'compilation'"". </p>

<p>Now, when you compile, all errors will show up in the bottom of the IDE window, as well as the <em>exact</em> compilation or linking commands which throw the error.</p>

<p>Once I fixed the folder structure, but your files were still C instead of C++ files, I saw this error: </p>

<pre><code>Compiling sketch...
/home/gabriel/Downloads/Install_Files/Arduino/arduino-1.8.7/hardware/tools/avr/bin/avr-gcc -c -g -Os -w -std=gnu11 -ffunction-sections -fdata-sections -MMD -flto -fno-fat-lto-objects -mmcu=atmega328p -DF_CPU=16000000L -DARDUINO=10807 -DARDUINO_AVR_NANO -DARDUINO_ARCH_AVR -I/home/gabriel/Downloads/Install_Files/Arduino/arduino-1.8.7/hardware/arduino/avr/cores/arduino -I/home/gabriel/Downloads/Install_Files/Arduino/arduino-1.8.7/hardware/arduino/avr/variants/eightanaloginputs /tmp/arduino_build_233569/sketch/foo.c -o /tmp/arduino_build_233569/sketch/foo.c.o
/tmp/arduino_build_233569/sketch/foo.c: In function 'bar':
foo.c:9:5: error: 'Serial' undeclared (first use in this function)
     Serial.println(""bar"");
     ^
/tmp/arduino_build_233569/sketch/foo.c:9:5: note: each undeclared identifier is reported only once for each function it appears in
exit status 1
'Serial' undeclared (first use in this function)

</code></pre>

<p>Notice the file it failed to compile was <code>/tmp/arduino_build_233569/sketch/foo.c</code>, and that the <code>avr-gcc</code> C compiler (rather than the <code>avr-g++</code> C++ compiler) was in use at the time. </p>

<p>I then opened the <code>/tmp/arduino_build_233569/sketch/foo.c</code> file to examine it and look for anything unusual about it. </p>

<p>Next, I used Eclipse to start tracking down includes, to see where <code>Serial</code> gets pulled in (it should have been obvious to me already what the problem was, but I didn't see it yet). I found the following:</p>

<p><strong>Arduino.h</strong> is found in ""Arduino/Source/Arduino/hardware/arduino/avr/cores/arduino/Arduino.h"". It includes <code>""HardwareSerial.h""</code>. This header <code>extern</code>s the <code>Serial</code> object:</p>

<pre><code>#if defined(UBRRH) || defined(UBRR0H)
  extern HardwareSerial Serial;
  #define HAVE_HWSERIAL0
#endif
</code></pre>

<p>HOWEVER, looking back at <code>Arduino.h</code> you'll see that <code>HardwareSerial.h</code> is ONLY included if you are compiling with C++:</p>

<pre><code>#ifdef __cplusplus   &lt;========= This means that the following headers are ONLY included if you are compiling with C++! BOOM! That's when it hit me! You're compiling a C file with the C compiler to access a C++ object. That's not ok. Use the C++ compiler!
#include ""WCharacter.h""
#include ""WString.h""
#include ""HardwareSerial.h""
#include ""USBAPI.h""
#if defined(HAVE_HWSERIAL0) &amp;&amp; defined(HAVE_CDCSERIAL)
#error ""Targets with both UART0 and CDC serial not supported""
#endif
</code></pre>

<p><code>#ifdef __cplusplus</code> means that the headers above are ONLY included if you are compiling with C++! That's when it hit me! You're compiling a C file with the C compiler to access a C++ object. That's not ok. You must use the C++ compiler instead. Do this simply by changing <code>foo.c</code> to <code>foo.cpp</code>. Done.</p>

<h1>Alternate fix for your problem #1 (the folder structure):</h1>

<p>Find your ""Sketchbook location"" from Arduino IDE: File --> Preferences. Mine, for example, is <code>/home/gabriel/dev/Arduino/Sketches</code>.</p>

<p>Now, go there and create a ""libraries"" folder. For me that would now be <code>/home/gabriel/dev/Arduino/Sketches/libraries</code>. Everything inside this folder is now considered an Arduino ""library"", and can be included. Move <code>foo.h</code> [do NOT use <code>foo.hh</code> in this case] and <code>foo.cpp</code> there, like this:</p>

<pre><code>/home/gabriel/dev/Arduino/Sketches/libraries/foo
├── foo.cpp
└── foo.h     &lt;==== NOT foo.hh in this case!

</code></pre>

<p>Now close and reopen the Arduino IDE, then go to Sketch --> Include Library --> foo, and it will automatically add the following line for you:</p>

<pre><code>#include &lt;foo.h&gt;
</code></pre>

<p>The reason you can't use <code>foo.hh</code> in this case is simply because Arduino is looking for <code>.h</code> files only when you add your library include using the menus in this way. <strong>That's a bug as far as I'm concerned, and should probably be reported to the Arduino developers.</strong> Feel free to take that on.</p>

<h1>Addendum:</h1>

<p>16 Apr. 2019:<br>
A <a href=""https://www.google.com/search?q=arduino%20add%20include%20path&amp;oq=arduino%20add%20include%20&amp;aqs=chrome.0.0j69i57j0l2.2410j0j4&amp;sourceid=chrome&amp;ie=UTF-8"" rel=""nofollow noreferrer"">google search for ""arduino add include path""</a> led me to this: <a href=""https://forum.arduino.cc/index.php?topic=445230.0"" rel=""nofollow noreferrer"">https://forum.arduino.cc/index.php?topic=445230.0</a>, where user @pert says:</p>

<blockquote>
  <p>In recent versions of the Arduino IDE(including 1.6.10) if you want to include libraries from the sketch folder you need to put them in a src subfolder. For example:  </p>

<pre><code>Blink  
|_Blink.ino  
|_src  
   |_BlinkLib  
       |_BlinkLib.h  
</code></pre>
</blockquote>

<p>He then says you can include like this:</p>

<blockquote>
<pre><code>#include ""src/BlinkLib/BlinkLib.h""  
</code></pre>
</blockquote>

<p>I haven't tried this, but that'd be super useful if it works. Give it a shot and let me know if it works. Be sure to tell us which OS and Arduino IDE version you are using. </p>

<p>See additional discussion on Github here: <a href=""https://github.com/arduino/Arduino/issues/5186"" rel=""nofollow noreferrer"">https://github.com/arduino/Arduino/issues/5186</a>.</p>
",,,
55744475,2,55698070,2019-04-18T10:50:44.603,3,,10721977,,2019-04-18T10:50:44.603,,0,,"<p>After a while of figuring out what the problem was, There were couple of issues.</p>

<ul>
<li><p>The baud-rate was too fast, I had to reduce it down to 9600.</p></li>
<li><p>The encoding from python was supposed to be sent as ASCII.</p></li>
<li>On Arduino reading the string until '\n' was needed.</li>
<li><p>Statically allocating the JsonDocument to 512 bytes worked. </p>

<p>The arduino JSON-<a href=""https://arduinojson.org/v6/assistant/"" rel=""nofollow noreferrer"">Assistant</a> has a method of finding out the require allocation for the architecture used.</p></li>
</ul>

<p>The python code below.</p>

<pre><code>import time
import json
import serial
from pprint import pprint
import random

if __name__ == ""__main__"":
    print (""Ready..."")
    ser  = serial.Serial(""COM3"", baudrate= 9600, 
           timeout=2.5, 
           parity=serial.PARITY_NONE, 
           bytesize=serial.EIGHTBITS, 
           stopbits=serial.STOPBITS_ONE
        )
    data = {}
    data[""operation""] = ""sequence""

    data=json.dumps(data)
    print (data)
    if ser.isOpen():
        ser.write(data.encode('ascii'))
        ser.flush()
        try:
            incoming = ser.readline().decode(""utf-8"")
            print (incoming)
        except Exception as e:
            print (e)
            pass
        ser.close()
    else:
        print (""opening error"")
</code></pre>

<p>The arduino code.</p>

<pre><code>#include &lt;ArduinoJson.h&gt;
void setup() {
  Serial.begin(9600); 
  while(!Serial) {
  }
}

void loop() {
  int     size_ = 0;
  String  payload;
  while ( !Serial.available()  ){}
  if ( Serial.available() )
    payload = Serial.readStringUntil( '\n' );
  StaticJsonDocument&lt;512&gt; doc;

  DeserializationError   error = deserializeJson(doc, payload);
  if (error) {
    Serial.println(error.c_str()); 
    return;
  }
  if (doc[""operation""] == ""sequence"") {
     Serial.println(""{\""Success\"":\""True\""}"");
  }
  else {
      Serial.println(""{\""Success\"":\""False\""}"");
   }
  delay(20);
}
</code></pre>

<p>Hope someone finds this useful. </p>
",,,
55732457,2,55698142,2019-04-17T16:44:55.107,0,,11365366,,2019-04-17T16:44:55.107,,2,,"<p>I figured out what my problem was. It was not with cmake but with the supportFile.h and supportFile2.h. I made the following changes to both files:</p>

<pre><code>// .h file #include and #define section

#ifdef __cplusplus
extern ""C"" {
#endif

extern // to all .h functions section

#ifdef __cplusplus
}
#endif
</code></pre>

<p>After doing so, everything compiled and ran.</p>
",,,
55698427,2,55698382,2019-04-15T23:13:17.207,0,,4967403,,2019-04-15T23:13:17.207,,4,,"<p>Sometimes we have to provide additional overloads to disambiguate between options. In this case, we'd provide additional overloads for <code>printdata</code>. </p>

<p>The best option is to just add additional <code>printdata</code> functions for <code>int</code>s, <code>double</code>s, and other datatypes you care about, but if you're fine printing them with as <code>unsigned int</code>s and <code>float</code>s, you can just cast them. </p>

<pre><code>void printdata(uint32_t data) 
{
  Serial.printf(""Printing unsigned integer %d"", data);
}

// ints should be printed as unsigned ints?
void printdata(int data) {
  printdata((uint32_t)data); //Call unsigned version
}

void printdata(float data) 
{
  Serial.printf(""Printing float %i"", data);
}

//doubles should be printed as floats
void printdata(double data)
{
  printdata((float)data);
}
</code></pre>
",,,
55698494,2,55698382,2019-04-15T23:21:29.110,1,,5141304,,2019-04-16T18:21:52.500,2019-04-16T18:21:52.500,6,,"<p>Consider <code>std::is_integral</code> from the <code>&lt;type_traits&gt;</code> header and also C++17 <code>constexpr if</code>.</p>

<p><code>std::is_integral</code> will tell you if a given type is an integral type at compile time.</p>

<p><code>constexpr if</code> is basically an if statement that is evaluated at compile time. The branch not taken is never executed (in fact it's not even compiled).</p>

<pre><code>#include &lt;type_traits&gt;

void printdata(uint32_t data)
{
    Serial.printf(""Printing unsigned integer %d"", data);
}

void printdata(float data)
{
    Serial.printf(""Printing float %i"", data);
}

template&lt;typename Data&gt;
void myTemplate(const Data&amp; d)
{
    // uses C++17 constexpr if
    if constexpr (std::is_integral_v&lt;Data&gt;) printdata(static_cast&lt;uint32_t&gt;(d));
    else printdata(static_cast&lt;float&gt;(d));
}
</code></pre>

<p><strong>EDIT:</strong> However, if you can't use C++17 you will need to use fancier template logic, which I'll demonstrate next. I'll also avoid using anything from the <code>type_traits</code> header because you mentioned you don't have access to it for some reason?</p>

<p><strong>NOTE:</strong> The code I'm about to show is very gross and I would never recommend writing it outside of academic exercises or curiosity. The reason for this is the lack of the <code>type_traits</code> header, which means we have to define much more than we would otherwise have to with e.g. SFINAE. Additionally, most template code uses lots of <code>type_traits</code> stuff, which makes this even more awkward.</p>

<p>So at this point (without the <code>type_traits</code> header or C++17), <strong>I would suggest not using templates and simply make overloads for every type you want to use</strong> <code>printdata</code> with, which avoids the issue of ambiguous overloads.</p>

<pre><code>// given a type T, defines a static member function called f that routes to the correct form of printdata.
// default implementation goes to int version.
template&lt;typename T&gt; struct _get_version { static void f(T val) { printdata(static_cast&lt;uint32_t&gt;(val)); } };

// specialize this for all the floating point types (float, double, and long double).
template&lt;&gt; struct _get_version&lt;float&gt; { static void f(float val) { printdata(static_cast&lt;float&gt;(val)); } };
template&lt;&gt; struct _get_version&lt;double&gt; { static void f(double val) { printdata(static_cast&lt;float&gt;(val)); } };
template&lt;&gt; struct _get_version&lt;long double&gt; { static void f(long double val) { printdata(static_cast&lt;float&gt;(val)); } };

template&lt;typename Data&gt;
void myTemplate(Data d)
{
    // get the version Data should use, then use its internal f function
    _get_version&lt;Data&gt;::f(d);
}
</code></pre>
",,,
55738392,2,55735757,2019-04-18T02:40:51.840,1,,2577244,,2019-04-18T02:40:51.840,,5,,"<p>When  <code>ioctl(file, I2C_SLAVE, addr)</code> runs you're saying <strong>""On I2C talk to the multiplexer.""</strong></p>

<p>Then, with </p>

<p><code>buf[0] = 0x01; // to select channel 0
write(file, buf, 10);</code></p>

<p>you make the multiplexer connect the VL680 that's connected to multiplexer first port to the I2C bus.</p>

<p>After you talked to the multiplexer with </p>

<p><code>write(file, buf, 10);</code> </p>

<p>and before you talk to the distance sensor with</p>

<p><code>doTheSameAsOneOnlyVL680();</code> </p>

<p>you need to run some code in order to say <strong>""On I2C talk to the distance sensor.""</strong></p>

<p>Something like:</p>

<pre><code>if(ioctl(file, I2C_SLAVE, vl680Addr) &lt; 0) 
{
    printf(""Fail to reach distance sensor \n"");
    exit(EXIT_FAILURE);
}
</code></pre>

<p>, where <code>vl680Addr</code> is the address (you'll need to define that) for the VL680 laser distance sensor, </p>
",,,
55740265,2,55740114,2019-04-18T06:30:11.513,2,,11224588,,2019-04-18T06:30:11.513,,1,,"<p>Well, I think your best bet is to go with <code>for</code> loop to search for <code>studentName</code>. Depending on what C++ revision you are using:</p>

<pre><code>student searchForName(const std::string &amp; name)
{
    for (auto item : studentRecs)
    {
        if (item.studentName == name)
            return item;
    }
    return student();
}
</code></pre>

<p>or if you are constrained to pre-C++11:</p>

<pre><code>student searchForName(const std::string &amp; name)
{
    for (std::size_t cnt = 0; cnt &lt; studentRecs.size(); ++cnt)
    {
        if (studentRecs[cnt].studentName == name)
            return item;
    }
    return student();
}
</code></pre>

<p>The rest is very similar.</p>

<p>BTW.: You can change:</p>

<pre><code>...
  // Get the size
  int dsize = static_cast&lt;int&gt;(studentRecs.size());

  // Loop, print the records
  for (int i = 0; i &lt; dsize; ++i) {
...
</code></pre>

<p>to:</p>

<pre><code>...
  // Loop, print the records
  for (std::size_t i = 0; i &lt; studentRecs.size(); ++i) {
...
</code></pre>
",,,
56056640,2,55765324,2019-05-09T09:43:54.933,0,,6049604,,2019-05-09T09:43:54.933,,0,,"<p>In order to achieve this, there are a couple approaches you could take. You could download a cross-compiler for the Pi and keep the source code only on your development machine. Then when you wanted to run code/tests on the Pi, you would use the cross-compiler to produce an output that could run on the Pi, transfer the executables to the Pi, and return the results back to the development machine. This approach would probably be quite fast, and if your project contains many files, it might be a good way to go about it. Setting up a cross-compiler isn’t the simplest thing to do, but there are many documented cases online of people who have already done it.</p>

<p>The other approach would be to develop the source code on your development machine but build the code for the Pi on the Pi itself. This removes the need to set up a cross-compiler and it makes getting the test results back to your development machine very simple.</p>

<p>You can use your text editor to develop the code on development machine. Then rsync to transfer your source files to the Raspberry Pi. Finally, You can install Ruby and Ceedling (a C unit testing tool) on your development machine and on the Pi to assist in running tests. Here’s how to make it all happen.</p>

<ul>
<li>Set Up SSH Keys</li>
</ul>

<p>This step is important because it allows you to transfer files from your development machine to the Pi and execute commands remotely without having to type in a username and password every time. First, make sure you have an SSH key generated on your development machine. If you don’t, or if you’re not sure, check out this excellent <a href=""https://help.github.com/articles/generating-ssh-keys"" rel=""nofollow noreferrer"">GitHub article that explains how to generate one</a>.</p>

<p>ow if you open up your ~/.ssh (or your/user/directory/.ssh on Windows) directory on your development machine, you should have a file called rd_isa.pub. This is the “public” piece of your SSH key. You need to transfer this file to the Raspberry Pi so that it can recognize you as an approved user. Do that with the following command:</p>

<p>scp ~/.ssh/id_rsa.pub user@remote.host:pubkey.txt</p>

<p>Make sure to replace ‘user’ with a username on the Raspberry Pi and ‘remote.host’ with the IP address of the Pi.</p>

<p>Once you’ve done that, you need to append the key to the “authorized_keys” file on the Pi. To do so you will need to SSH into the Pi and manually edit/create the file. That can be done as follows:</p>

<pre><code>scp ~/.ssh/id_rsa.pub user@remote.host:pubkey.txt

ssh user@remote.host

mkdir ~/.ssh

cat pubkey.txt &gt;&gt; ~/.ssh/authorized_keys

rm ~/pubkey.txt
</code></pre>

<ul>
<li>Install ‘rsync’</li>
</ul>

<p>The next step is to install rsync, a utility that allows you synchronize directories between two computers. When we make changes on our local machine, rsync will transfer those changes to the Pi for testing. rsync is smart enough to only transfer files that have been updated since the last transfer, which will speed up the process. For rsync to work, it must be installed on both your development machine and the Raspberry Pi. To install it on the Pi execute the following command.</p>

<pre><code>sudo apt-get install rsync
</code></pre>

<p>The process for installing rsync on your development machine will vary greatly depending on which OS you are running. On the Mac, it’s already installed. Some Linux distros come with it as well. Windows, on the other hand, is a little behind the game. Search Google for “Installing rsync on Windows” for instructions on getting it setup.</p>

<ul>
<li>Install Ruby</li>
</ul>

<p>Ruby is another component that needs to be installed on by the development machine and the target. Ruby is a scripting language that Ceedling uses to automate unit test execution. Again, refer to the all-wise Google for instructions on installing the latest version on your dev machine. To install Ruby on the Raspberry Pi use the following command:</p>

<pre><code>sudo apt-get install ruby
</code></pre>

<ul>
<li>Install Rake</li>
</ul>

<p>Rake is a Ruby gem (package) that provides build automation support similar to ‘make’. Once you have Ruby installed, Rake is as simple to install as typing the following:</p>

<pre><code>sudo gem install rake
</code></pre>

<ul>
<li>Setup a Ceedling Project</li>
</ul>

<p>Finally We can already write code locally and execute tests on our development machine using the command “rake test:all”.  </p>

<p>The final thing we need to do is set up a custom rake task that will run tests on the Pi without having to manually SSH into it. Look in the root directory of your Ceedling project and you will see a file named Rakefile.rb. This is where we will put our custom rake task. Add the following to the bottom of the file:</p>

<pre><code>desc ""Run rake test:all on RPi with latest changes""

desc ""Update the RPi with the latest changes on dev machine.""
task :update_pi_source do

  #send the latest changes to the pi
  puts cmd = ""rsync -r -v . #{REMOTE_RPI_USER}@#{REMOTE_RPI_IP_ADDR}:#{REMOTE_RPI_PROJ_ROOT} --exclude=#{PROJECT_BUILD_ROOT}""
  system(cmd)
end

desc ""Run rake test:all in the project directory on the pi""
task :run_all_tests_pi do

  #execute tests on the pi
  puts cmd = ""ssh #{REMOTE_RPI_USER}@#{REMOTE_RPI_IP_ADDR} ""cd #{REMOTE_RPI_PROJ_ROOT} &amp;amp;&amp;amp; rake test:all""""
  system(cmd)
end

task :pi_test_all &gt; [:update_pi_source, :run_all_tests_pi] do
end
</code></pre>

<p>This actually defines three rake tasks. The first one, update_pi_src, is the task that uses rsync to update the source code on the Pi. The second one, run_all_tests_pi, uses SSH to execute the necessary command to compile the code and run the tests on the Pi. The third task, pi_test_all, is just a wrapper that combines the first two.</p>

<p>Hope it helps.</p>
",,,
55805863,2,55804381,2019-04-23T06:59:52.107,3,,9072753,,2021-02-16T08:27:08.383,2021-02-16T08:27:08.383,0,,"<p>A 5 min search give me <a href=""https://www.arduino.cc/en/Reference/WiFiLocalIP"" rel=""nofollow noreferrer"">the WiFi.localIp() function description</a>, from there I knew it returned <code>IPAddress</code> object. Following to <a href=""https://forum.arduino.cc/index.php?topic=228884.0"" rel=""nofollow noreferrer"">forum.arduino.cc Topic: How to manipulate IPAddress variables / convert to string</a> you can use following function to convert it to string:</p>
<pre><code>// author apicquot from https://forum.arduino.cc/index.php?topic=228884.0
String IpAddress2String(const IPAddress&amp; ipAddress)
{
    return String(ipAddress[0]) + String(&quot;.&quot;) +
           String(ipAddress[1]) + String(&quot;.&quot;) +
           String(ipAddress[2]) + String(&quot;.&quot;) +
           String(ipAddress[3]);
}
</code></pre>
<p><code>IPAddress</code> may be handled just as an array of 4 <code>int</code>s.</p>
",,,
55817377,2,55817008,2019-04-23T18:31:27.480,2,,5754656,,2019-04-23T18:31:27.480,,0,,"<p>From the documentation of <a href=""https://www.arduino.cc/reference/en/language/functions/digital-io/digitalread/"" rel=""nofollow noreferrer""><code>digitalRead()</code></a> (Which returns <code>HIGH</code> or <code>LOW</code>), the value is stored in an <code>int</code>, so using <code>int</code> seems like a safe bet.</p>

<p>The function <a href=""https://www.arduino.cc/reference/en/language/functions/digital-io/digitalwrite/"" rel=""nofollow noreferrer""><code>digitalWrite()</code></a> takes a pin status (<code>HIGH</code> or <code>LOW</code>) as a parameter, and searching through <a href=""https://github.com/search?q=org%3Aarduino+%22void+digitalWrite%22&amp;type=Code"" rel=""nofollow noreferrer"">the GitHub repositories from Arduino</a> for the definition of that function, there are three different definitions:</p>

<pre><code>void digitalWrite(uint32_t, uint32_t);
void digitalWrite(uint8_t, uint8_t);
void digitalWrite(pin_size_t, PinStatus);
</code></pre>

<p>Where <code>PinStatus</code> is an enum:</p>

<pre><code>typedef enum {
  LOW     = 0,
  HIGH    = 1,
  CHANGE  = 2,
  FALLING = 3,
  RISING  = 4,
} PinStatus;
</code></pre>

<p>But <code>HIGH</code> and <code>LOW</code> are always defined as <code>1</code> and <code>0</code>, which can definitely be stored in an int (And can be converted to those three types)</p>
",,,
55839203,2,55838136,2019-04-24T22:03:38.770,2,,3216326,,2019-04-24T22:13:04.713,2019-04-24T22:13:04.713,1,,"<p>Per a suggestion posted, I read on GitHub the following:</p>

<p><strong>No pre-processing is done to files in a sketch with any extension other than .ino. Additionally, .h files in the sketch are not automatically #included from the main sketch file.</strong> Further, if you want to call functions defined in a .c file from a .cpp file (like one generated from your sketch), you'll need to wrap its declarations in an 'extern ""C"" {}' block that is defined only inside of C++ files.</p>

<p>So that explains my problem.  I enclosed my simple function 'WiFi_Setup()' with in a class and now it compiles successfully.</p>

<pre><code>class WifiNetwork
{
protected:

public:
    void WiFi_Setup();
};
</code></pre>

<p>It seems Arduino wants everything to live in classes.</p>
",,,
55865643,2,55865432,2019-04-26T10:27:17.600,1,,212063,,2019-04-26T10:27:17.600,,0,,"<p>You have to program this behavior by yourself.</p>

<pre><code>int sevenDown = 0;
while(1) {
    if(!sevenDown &amp;&amp; digitalRead(7)) {
        sevenDown = 1\n"");
    }
    if(sevenDown &amp;&amp; !digitalRead(7)) {
        printf(""Button-1 pressed\n"");
        sevenDown = 0;
    }
}
</code></pre>
",,,
56085530,2,55932766,2019-05-10T22:26:24.733,0,,10135377,,2019-05-10T22:26:24.733,,5,,"<p>I'd like to suggest that your current solution is <em>fine</em>. </p>

<p>You have a device that needs to know a value that's store in a remote database. As far as the device is concerned, the value could change at any time, and the device needs to update its own state when the remote value changes.</p>

<p>Having it act as a Host that receives connections or notifications of any kind from the remote server would probably be problematic. You mentioned that you'd have to set up port-forwarding. You'd also be adding the security concerns of a Host server to this device, and you'd need to worry about maintaining a consistent IP address (or something).</p>

<p>The ideal solution will depend on <em>what</em> you're trying to accomplish. <em>Why</em> don't you want to poll the server every five seconds?</p>

<p>Of course the actual question you asked was </p>

<blockquote>
  <p>how [to] postpone the HTTP GET response until the moment that the user changes the device status with a button click?</p>
</blockquote>

<p>Postponing the <em>response</em> is hardly a normal thing to do, and you're going to run into all kinds of problems with timeouts, which I'm not going to address here (for brevity), and it'll be a struggle to get your system to do anything <em>else</em> at the same time, but it <em>can</em> be done:</p>

<p><strong>client device</strong>:</p>

<pre><code>static DateTime lastUpdated = now();//or whatever

void loop() 
{
  HTTPClient http; //Declare object of class HTTPClient
  String getData, Link, payload;
  bool succeeded;

  //HTTP GET REQUEST
  getData = ""?device="" + deviceName + ""&amp;lastUpdated="" + lastUpdated.asEpochInt(); //or whatever
  Link = ""http://.../getStatus.php"" + getData;

  try
  { 
    http.begin(Link); 
    int httpCode = http.GET(); //Send the request
    payload = http.getString(); //Get the response from database
    succeed = true;
  }
  catch(TimeoutError te) //or whatever
  {
    succeeded = false;
  }

  if(succeeded)
  {
    lastUpdated = now()

    if(payload==""ON"")
    {
      digitalWrite(LEDPin, HIGH);//change pin status
    }
    else if(payload==""OFF"")
    {
      digitalWrite(LEDPin, LOW);//change pin status
    }
  }

  http.end(); 

  //delay(5000); //send the next one right away.
}  
</code></pre>

<p><strong>host server</strong></p>

<pre class=""lang-php prettyprint-override""><code>&lt;?php

$db = mysqli_connect(...);

if(!empty($_GET['device']))
{
  $device_name = $_GET['device'];
  $threshold = DateTimeImmutable::createFromFormat('U', $_GET['lastUpdated'])

  $query_status = ""SELECT status FROM devices WHERE device = ? AND lastUpdated &gt; ?"";

  $stmt = mysqli_prepare($db, $query_status);
  if ($stmt === false) {
     error_log(mysqli_error($db));
     die(""Sorry, there has been a software error"");
  }

  $ok = mysqli_stmt_bind_param($stmt, ""s"", $device_name)
    &amp;&amp; mysqli_stmt_bind_param($stmt, ""s"", $threshold-&gt;format('Y-m-d H:i:s'));
  if ($ok === false) {
    error_log(mysqli_stmt_error($db));
    die(""Sorry, there has been a software error"");
  }

  $waiting = TRUE;
  while($waiting)
  {
    $ok = mysqli_stmt_execute($stmt);
    if ($ok === false) {
      error_log(mysqli_stmt_error($db));
      die(""Sorry, there has been a software error"");
    }

    $result = $stmt-&gt;get_result();

    if ($result-&gt;num_rows &gt; 0) 
    {
      $waiting = FALSE;
      while($row = $result-&gt;fetch_assoc()) 
      {
        echo $row[""status""];
      }
    }
    else {
      usleep(100);
    }
  }
}//or else what?
?&gt;
</code></pre>

<p>And we could take this even farther (make it even worse) by pushing our while loop down into the MySQL, but that would require learning the details of MySQL Stored Procedures, and no amount of internet points is worth that.</p>

<h1>Just because you can, doesn't mean you should.</h1>
",,,
55970417,2,55962132,2019-05-03T13:03:35.107,0,,2819922,,2019-05-03T13:03:35.107,,3,,"<h1>genericDataStruct.h:</h1>

<pre><code>#ifndef USERSTRUCT
typedef struct UserDataStruct_t{
    char            header[NSL_PACKET_HEADER_LENGTH];
    int8_t          b1;       ///&lt;  b1  (Generic packet byte  1 of 35 )
    int8_t          b2;       ///&lt;  b2  (Generic packet byte  2 of 35 )
    int8_t          b3;       ///&lt;  b3  (Generic packet byte  3 of 35 )
    // ... etc
    int8_t          b35;      ///&lt;  b35 (Generic packet byte 35 of 35 )

};
#endif   
typedef union DataPacket_t {
    UserDataStruct_t payloadData;
    byte Packet[sizeof(UserDataStruct_t)];
};
</code></pre>

<h1>customDatastruct.h</h1>

<pre><code>#define USERSTRUCT
typedef struct UserDataStruct_t{
    char            header[NSL_PACKET_HEADER_LENGTH];
    float           temp;   // assuming byte order and float representation fit
// ...
};
</code></pre>

<p>However, sizes of <code>UserDatastruct_t</code> must match, as while compiling <code>myLib.cpp</code> customDatastruct.h is unknown and  myLib::sendData simply uses the 
<code>byte Packet[sizeof(UserDataStruct_t)];</code> part of the union.</p>
",,,
55975975,2,55974470,2019-05-03T19:22:31.087,0,,9513106,,2019-05-03T19:40:30.963,2019-05-03T19:40:30.963,1,,"<p>If you press the start button only at the beginning of the program, why don't you just wait for a button action in <code>setup()</code>? </p>

<pre class=""lang-cpp prettyprint-override""><code>void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);
  pinMode(startPin,INPUT_PULLUP);
  pinMode(stopPin,INPUT_PULLUP);

  while (digitalRead(startPin) != LOW); // &lt;- wait for button action
}
</code></pre>

<p>In <code>loop()</code>, you want to count up until the stop button is pressed. If you do hardware reset afterwards, you can just put the program into an infinite loop once the stop button has been pressed. </p>

<pre class=""lang-cpp prettyprint-override""><code>void loop() {
  lcd.setCursor(0, 1);
  sprintf(timeline,""%0.2d mins %0.2d secs"", minutes, seconds);
  lcd.print(timeline);
  delay(1000);

  seconds++; 

  if (seconds == 60) {
    seconds = 0;
    minutes ++; 
  }

  if (digitalRead(stopPin) == LOW) {
    delay(500);
    sprintf(timeline,""%0.2d mins %0.2d secs"", minutes, seconds);
    while(true) {} // infinite loop
  }
}
</code></pre>
",,,
56452697,2,55976683,2019-06-04T23:56:18.430,4,,10420909,,2019-06-05T00:11:54.040,2019-06-05T00:11:54.040,0,,"<p>For people who are still interested. Here is a working solution for me, which I only tested briefly. (C++)</p>

<pre><code>#include &lt;unistd.h&gt;        //Needed for I2C port
#include &lt;fcntl.h&gt;          //Needed for I2C port
#include &lt;sys/ioctl.h&gt;      //Needed for I2C port
#include &lt;linux/i2c-dev.h&gt;  //Needed for I2C port
#include &lt;linux/i2c.h&gt;      //Needed for I2C port

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;cerrno&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;

const std::string i2c_filename = ""/dev/i2c-1"";
const int i2c_addr = 0x5b;          //&lt;&lt;&lt;&lt;&lt;The I2C address of the slave

static inline int i2c_rdwr_block(int fd, uint8_t reg, uint8_t read_write, uint8_t length, unsigned char* buffer)
{
    struct i2c_smbus_ioctl_data ioctl_data;
    union i2c_smbus_data smbus_data;

    int rv; 

    if(length &gt; I2C_SMBUS_BLOCK_MAX) 
    {
        std::cerr &lt;&lt; ""Requested Length is greater than the maximum specified"" &lt;&lt; std::endl;
        return -1;
    }

    // First byte is always the size to write and to receive 
    // https://github.com/torvalds/linux/blob/master/drivers/i2c/i2c-core-smbus.c  
    // (See i2c_smbus_xfer_emulated CASE:I2C_SMBUS_I2C_BLOCK_DATA)
    smbus_data.block[0] = length;

    if ( read_write != I2C_SMBUS_READ )
    {
        for(int i = 0; i &lt; length; i++)
        {
            smbus_data.block[i + 1] = buffer[i];
        }
    }


    ioctl_data.read_write = read_write;
    ioctl_data.command = reg;
    ioctl_data.size = I2C_SMBUS_I2C_BLOCK_DATA;
    ioctl_data.data = &amp;smbus_data;

    rv = ioctl (fd, I2C_SMBUS, &amp;ioctl_data);
    if (rv &lt; 0)
    {
        std::cerr &lt;&lt; ""Accessing I2C Read/Write failed! Error is: "" &lt;&lt; strerror(errno) &lt;&lt; std::endl;
        return rv;
    }

    if (read_write == I2C_SMBUS_READ)
    {
        for(int i = 0; i &lt; length; i++)
        {
            // Skip the first byte, which is the length of the rest of the block.
            buffer[i] = smbus_data.block[i+1];
        }
    }

    return rv;
}

static int setup_i2c(std::string filename)
{
    //----- OPEN THE I2C BUS -----

    int fd;
    int rv;

    if ((fd = open(filename.c_str(), O_RDWR)) &lt; 0)
    {
        //ERROR HANDLING: you can check errno to see what went wrong
        std::cout &lt;&lt; ""Failed to open the i2c bus. Error code: "" &lt;&lt; fd &lt;&lt; std::endl;
        return fd;
    }

    if ((rv = ioctl(fd, I2C_SLAVE, i2c_addr)) &lt; 0)
    {
        std::cout &lt;&lt; ""Failed to acquire bus access and/or talk to slave. Error code: "" &lt;&lt; rv &lt;&lt; std::endl;
        //ERROR HANDLING; you can check errno to see what went wrong
        return rv;
    }

    return fd;
}

int main()
{
    int fd_i2c = setup_i2c(i2c_filename);
    int i2c_data_length = 3;
    int rv;
    unsigned char buffer[i2c_data_length + 1] = {0};

    if (fd_i2c &lt; 0)
    {
        std::cerr &lt;&lt; ""Set UP I2C Bus Error. Exit now!"" &lt;&lt; std::endl;
        return -1;
    }

    //std::cout &lt;&lt; ""File Descriptor: "" &lt;&lt; fd_i2c &lt;&lt; std::endl;

    //rv = read_i2c(fd_i2c, buffer, i2c_data_length);
    rv = i2c_rdwr_block(fd_i2c, 0x22, I2C_SMBUS_READ, i2c_data_length, buffer);

    if (rv &lt; 0)
    {
        std::cerr &lt;&lt; ""Reading I2C Bus Error..."" &lt;&lt; std::endl;
        return -1;
    }

    std::cout &lt;&lt; ""Buffer Value: "" ;

    for (int i = 0; i &lt; i2c_data_length; i++)
    {
        std::cout &lt;&lt; ""0x"" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; (int) buffer[i] &lt;&lt; "" "" ;
    }

    std::cout &lt;&lt; std::endl;

    unsigned char values[i2c_data_length] = {0};
    values[0] = 0x01;
    values[1] = 0x02;
    values[2] = 0x03;

    //rv = write_i2c(fd_i2c, values, i2c_data_length);
    rv = i2c_rdwr_block(fd_i2c, 0x22, I2C_SMBUS_WRITE, i2c_data_length, values);

    if (rv &lt; 0)
    {
        std::cerr &lt;&lt; ""Writing I2C Bus Error..."" &lt;&lt; std::endl;
        return -1;
    }

    return 0;
}
</code></pre>

<p>The key for this block of code is the option <strong>I2C_SMBUS_I2C_BLOCK_DATA</strong> (which is defined in ""linux/i2c-dev.h"", also see ""linux/i2c.h""). This will translate your SMBus block data into I2C Block data. Specifically, SMBus block data is--""command, block_size, data"", while I2C block data is --""command, data"" and using the two wire timing to determine the STOP signal.</p>

<p>Please refer to Linux Kernel source code 
 <a href=""https://github.com/torvalds/linux/blob/master/drivers/i2c/i2c-core-smbus.c"" rel=""nofollow noreferrer"">linux/drivers/i2c/i2c-core-smbus.c</a> 
And function,</p>

<pre><code>static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
                   unsigned short flags,
                   char read_write, u8 command, int size,
                 union i2c_smbus_data *data)
</code></pre>

<p>(i2c_smbus_xfer is the first function called, and is fallen back to i2c_smbus_xfer_emulated is the adapter does not have native support for the SMBus. Therefore these two functions should implement the same thing.)</p>

<p>Look at </p>

<pre><code>case I2C_SMBUS_I2C_BLOCK_DATA:
</code></pre>

<p>carefully which shows you how the translation from SMBus to I2C Bus is done. </p>

<p>Also compare</p>

<pre><code>case I2C_SMBUS_BLOCK_DATA:
</code></pre>

<p>And see how it does not do the translation. (Send SMBus data directly)</p>

<p>More can be referred to the linux kernel documentation on <a href=""https://www.mjmwired.net/kernel/Documentation/i2c/dev-interface"" rel=""nofollow noreferrer"">i2c device interface</a>, as well as the <a href=""https://github.com/torvalds/linux/tree/master/drivers/i2c"" rel=""nofollow noreferrer"">i2c driver</a> source code</p>
",,,
56057040,2,56026771,2019-05-09T10:06:45.827,0,,10986180,,2019-05-09T10:06:45.827,,0,,"<p>Finnaly i found the solution, it was just to replace in the while ""rec_data[0]"" by ""rec_data"" : </p>

<pre><code> rec_data[0] = 0x04;

 while (1)
  {
    //reception data
    HAL_I2C_Master_Transmit(&amp;hi2c1, 0xD0, i2cData, 1, 10);
    HAL_Delay(500);
    HAL_I2C_Master_Receive(&amp;hi2c1, 0xD0, rec_data, 1, 10);
    HAL_Delay(500);
  }
</code></pre>

<p>thanks again guy !! ;)</p>
",,,
56154277,2,56027387,2019-05-15T16:57:01.907,1,,6621126,,2019-05-15T16:57:01.907,,0,,"<p>After some trial and error, we found out it's much easier than we thought.  If you are using X.509 certificates for client authentication, you don't need to include anything in the HTTP message content to specify your authentication.  The minimum required for an Azure device-to-cloud message using X.509 certificates for authentication is:</p>

<pre><code>POST /devices/&lt;id&gt;/messages/events?api-version=2018-06-30 HTTP/1.1
Host:&lt;fully-qualified-iothubname&gt;.azure-devices.net
Content-Length:&lt;number-of-bytes-in-the-JSON-body&gt;

{""deviceID"":""&lt;id&gt;"",&lt;your-JSON-formatted-custom-d2c-message-data&gt;}
</code></pre>

<p>where <code>&lt;id&gt;</code> is the device ID as listed on the Azure IoT Hub and <code>&lt;fully-qualified-iothubname&gt;</code> is the IoT Hub name.  I believe Azure supports chunked encoding if you want to do that instead of using the <code>Content-Length</code> header.</p>
",,,
56073408,2,56042093,2019-05-10T08:16:25.480,0,,5392438,,2019-05-10T08:25:32.363,2019-05-10T08:25:32.363,0,,"<p>Solution: Don't try to do what i did on arduino if it does not work.</p>

<p>I found that if i remove all functions inside the union except one it will compile if that function has the parameter list (uint8_t data[]) but not when i add any second parameter to the parameter list, and i have no idea why.</p>

<p>Much of the different issues i'm running into seem undocumented, so i'm going to abandon the union functions and take the easy but less elegant solution of placing the functions outside of the union and defining the union members as public, like this:</p>

<pre><code>static union {
    float floatValue;
    uint32_t uint32Value;
    uint16_t uint16Value;
    uint8_t inValue[4];
};

float bytesToFloat(uint8_t data[]){
    inValue[ 0 ] = data[ 3 ];
    inValue[ 1 ] = data[ 2 ];
    inValue[ 2 ] = data[ 1 ];
    inValue[ 3 ] = data[ 0 ];
    return floatValue;
}
uint32_t bytesToUint32(uint8_t data[]){
    inValue[ 0 ] = data[ 3 ];
    inValue[ 1 ] = data[ 2 ];
    inValue[ 2 ] = data[ 1 ];
    inValue[ 3 ] = data[ 0 ];
    return uint32Value;
}
uint16_t bytesToUint16(uint8_t data[]){
    inValue[ 0 ] = data[ 1 ];
    inValue[ 1 ] = data[ 0 ];
    return uint16Value;
}

void setup() {
    uint8_t t1[4] = {0x0A, 0xC3, 0x53, 0x48}; //180573000
    cout &lt;&lt; bytesToUint32(t1) &lt;&lt; endl;
    uint8_t t2[2] = {0x07, 0xE3}; //2019
    cout &lt;&lt; bytesToUint16(t2) &lt;&lt; endl;
    uint8_t t3 = 0x05; //5
    cout &lt;&lt; t3 * 1 &lt;&lt; endl;
    cout.precision(5);
    uint8_t t4[9][4] = {
            {0x3F, 0x7F, 0xCC, 0x8C}, //0.99921
            {0x3D, 0x21, 0x43, 0x00}, //0.039371
            {0x3B, 0x92, 0x07, 0xDF}, //0.0044565
            {0xBD, 0x21, 0xBE, 0x6E}, //-0.039488
            {0x3F, 0x7F, 0xAE, 0x7E}, //0.99876
            {0x3C, 0xF9, 0x64, 0x38}, //0.030443
            {0xBB, 0x55, 0x26, 0x18}, //-0.0032524
            {0xBC, 0xFA, 0xA3, 0x24}, //-0.030595
            {0x3F, 0x7F, 0xE0, 0xFC}, //0.99953
    };
    for (int i = 0; i &lt; 9; i++) {
        cout &lt;&lt; bytesToFloat(t4[ i ]) &lt;&lt; endl;
    }
}
</code></pre>
",,,
56050473,2,56050370,2019-05-09T00:01:19.517,2,,8968982,,2019-05-09T00:40:43.987,2019-05-09T00:40:43.987,4,,"<p>I think your problem is here:</p>

<pre><code>    if (entrada == 3) {
      Seria1.write(""AT+ADDR?"");
      entrada = 0;
    if (entrada == 9) {

      nome();

      }
    if (entrada == 4) {
</code></pre>

<p>Basically if entrada == 3, then you enter this block where you potentially call nome().</p>

<p>However, if entrada == 3, it can not possibly be equal to nine. Further, you reset entrada to 0 just before testing if it is 9. So there is no way entrada can be 9 and thus no way for nome to be called.</p>

<p>Probably you intended for the code to read like this:</p>

<pre><code>    if (entrada == 3) {
      Seria1.write(""AT+ADDR?"");
      entrada = 0;
    }                // The previous if statement was not ended.
    if (entrada == 9) {

      nome();

    }
    if (entrada == 4) {
</code></pre>

<p>You will need to remove a closing brace from further down in the code.</p>

<p>Also, I noted that you have this:</p>

<pre><code>    if (entrada == 4) {
        char comando[] = ""AT+NAME="";
        Serial.println (""Digite o nome do dispositivo desejado"");
        while(!Serial.available() ){
        }
          int nome = Serial.read();             // See below
          Seria1.write (comando + nome);
          entrada = 0;
        }
      }
</code></pre>

<p>Usually it is not a good idea to use the same name for a variable and other purposes (i.e. the nome() function). In this case it is probably OK, but it could get confusing later - especially if this block of code got larger and you needed to call the nome() function from within it.</p>

<p>Lastly, the echo == line of code does not do anything. Is that what you intended?</p>

<pre><code>  if (entrada == 1) 
  { 
    echo == entrada;      // This is a non-operation. Did you mean for it to be something else?
    padrao();

    }
</code></pre>

<p>I hope this helps with your project. :-)</p>
",,,
56149385,2,56054661,2019-05-15T12:28:56.027,0,,6049604,,2019-05-15T12:28:56.027,,0,,"<p>Here are the steps you need to do to connect your raspberry pi to Azure IOT hub using python</p>

<p>1) Setup your PI</p>

<p>For setup , you can use this <a href=""https://www.raspberrypi.org/documentation/remote-access/ssh/"" rel=""nofollow noreferrer"">link</a> to enable SSH on your pi.</p>

<p>Enable I2C on your Pi
Use below link to enable I2C.
<a href=""https://www.raspberrypi.org/documentation/configuration/raspi-config.md"" rel=""nofollow noreferrer"">https://www.raspberrypi.org/documentation/configuration/raspi-config.md</a></p>

<p>2) Connect your sensor with your PI</p>

<p>3) Download and setup referenced modules</p>

<ol>
<li><p>Clone the client application to local:</p>

<pre><code>sudo apt-get install git-core
</code></pre>

<p>git clone <a href=""https://github.com/Azure-Samples/iot-hub-python-raspberrypi-client-app.git"" rel=""nofollow noreferrer"">https://github.com/Azure-Samples/iot-hub-python-raspberrypi-client-app.git</a></p></li>
</ol>

<p>Because the Azure IoT SDKs for Python are wrappers on top of the [SDKs for C][azure-iot-sdk-c], you will need to compile the C libraries if you want or need to generate the Python libraries from source code.</p>

<pre><code>cd ./iot-hub-python-raspberrypi-client-app
   sudo chmod u+x setup.sh
   sudo ./setup.sh
</code></pre>

<p>In the above script, we run ./setup.sh without parameter, so the shell will automatically detect and use the version of python installed (Search sequence 2.7->3.4->3.5). Alternatively, you can use a parameter to specify the python version which you want to use like this: sudo ./setup.sh [--python-version|-p] [2.7|3.4|3.5]</p>

<pre><code>Known build issues:

1.) On building the Python client library (`iothub_client.so`) on Linux devices that have less than **1GB** RAM, you may see build getting **stuck** at **98%** while building `iothub_client_python.cpp` as shown below

``[ 98%] Building CXX object python/src/CMakeFiles/iothub_client_python.dir/iothub_client_python.cpp.o``

If you run into this issue, check the **memory consumption** of the device using `free -m command` in another terminal window during that time. If you are running out of memory while compiling iothub_client_python.cpp file, you may have to temporarily increase the **swap space** to get more available memory to successfully build the Python client side device SDK library.
</code></pre>

<p>You can refer the sample code <a href=""https://github.com/Azure-Samples/iot-hub-python-raspberrypi-client-app"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Hope it helps.</p>
",,,
56109195,2,56107735,2019-05-13T09:14:38.587,1,,8968982,,2019-05-13T10:34:48.270,2019-05-13T10:34:48.270,13,,"<p>Here are a couple of observations based upon what we know so far.</p>

<p>I believe capacitive touch sensors do not return HIGH / LOW results unless they are a ""digital capacatitive touch sensor"". Non digital ones will likely return an analog values, so you might need to use an AnalogRead function.</p>

<p>In this case your code might read something like this:</p>

<pre><code>  senVal1 = analogRead(sen1);
  if (senVal1 &gt; 800) {
    // Do sensor is touched stuff
  }
</code></pre>

<p>Also, assuming your LED's are connected to Arduino via their cathodes (i.e. LOW = ON), then you never seem to turn any of the LED's off. That is there is no code like this:</p>

<pre><code>  digitalWrite(LEDX, HIGH);
</code></pre>

<p>So the result is probably that all of the LED's will come on and stay on.</p>

<p>Finally, you might want to introduce some debounce and / or hasn't let go yet. Consider the following:</p>

<pre><code>void loop() {
  // read the state of the sensor0 value:
  senState0 = digitalRead(sen0);        // This appears to be in the wrong place!!!!
  // check if the sensortouch is pressed.
  // if it is, the sensorState is HIGH:
  if ( senState0 == HIGH ) {
    if (sentouchCount1 % numberOfLED1 == 0 ){ 
      digitalWrite(LEDR,LOW);
      digitalWrite(LEDR1,LOW);
      }
</code></pre>

<p>The loop function will be called many times per second (e.g. thousands of times per second). Your logic is effectively ""Is Sensor0 pressed?"". This test is executed many, many times per second. So, your tests involving ""sentouchCount1"" will be exectued many many times per second.</p>

<p><strong>Assuming</strong> you actually change the value of sentouchCount1 somewhere by adding one to it, this will quickly cycle through all possible values of the if statements resulting in all of the LED's appearing to instantaneously turn on.</p>

<p>However, you do not change the value of sentouchCount1, so only the first if that turns on LEDR and LEDR1 is probably activated.</p>

<p>Oh, and in relation to the ""hasn't let go"" bit, consider the following code:</p>

<pre><code>boolean isPressed = false;

loop() {
  if (senState0 == HIGH &amp;&amp; !isPressed) {
     // do stuff when we detect that the switch is pressed
     isPressed = true;      // Make sure we don't keep doing this for the entire
                            // duration the user is touching the switch!
  } else if (senState0 == LOW &amp;&amp; isPressed) {
    isPressed = false;      // User has let go of the button, so enable the
                            // previous if block that takes action when the user
                            // presses the button.
  }        // You might need to search ""debouncing a switch"", but I do not think this is required for capacative touch sensors (especially digital ones).
</code></pre>

<p>As per my comment below, you probably need to do something like this:</p>

<pre><code>boolean isSensor1Touched = false;

void loop() {
  // read the state of the sensor0 value:
  senState0 = digitalRead(sen0);        // This appears to be in the wrong place!!!!
  // check if the sensortouch is pressed.
  // if it is, the sensorState is HIGH:
  if ( senState0 == HIGH &amp;&amp; ! isSensor1Touched) {
    sentouchCount1++;
    isSensor1Touched = true;
    if (sentouchCount1 % numberOfLED1 == 0 ){ 
      digitalWrite(LEDR,LOW);
      digitalWrite(LEDR1,LOW);
      }
    if (sentouchCount1 % numberOfLED1 == 1 ){ 
      digitalWrite(LEDG,LOW);
      digitalWrite(LEDG1,LOW);
    }
    if (sentouchCount1 % numberOfLED1 == 2){ 
      digitalWrite(LEDB,LOW);
      digitalWrite(LEDB1,LOW);
    }
  } else if (senState0 == LOW &amp;&amp; isSensor1Touched) {
    isSensor1Touched = false;
  }

  // Then repeat for other sensors...
</code></pre>
",,,
56117309,2,56113435,2019-05-13T17:35:26.903,1,,168986,,2019-05-14T08:37:22.157,2019-05-14T08:37:22.157,13,,"<p>A more reliable approach to running the motor until the button is released is to use a ""no-code"" timeout.  That is, if the ""no code"" state persists for a period longer than the auto-repeat period, then it has been released.</p>

<p>It is not clear in your code what the 1 second analogue pulse is for, but placing long delays in your <code>loop()</code> function makes your system far less responsive.  Better to poll the system tick and ""do stuff"" when it is time to do so.  Also magic numbers should be avoided if you want anyone to understand your code and avoid errors in maintenance.</p>

<p>The following uses system tick polling to implement the ""no-code"" timeout.  I have omitted the motor on/off code because it is not clear what you are doing there with the 1 second delays.</p>

<pre><code>#define NO_CODE        0xFFFFFFFFul
#define MOTOR_ON_CODE  0xFF906Ful
#define MOTOR_OFF_CODE 0xFFE01Ful
#define STOP_TIME_MS   250ul  // stop after button release for 250ms

void loop( )
{
    static unsigned long last_on_time = 0 ; 

    if( irrecv.decode( &amp;results ) )
    {
        irrecv.resume() ;

        unsigned long code = results.value ;

        // If motor off code or no code timeout...
        if( code == MOTOR_OFF_CODE ||
            (code == NO_CODE &amp;&amp; millis() - last_on_time &gt; STOP_TIME_MS) )
        {
            // Motor off
            ...
        }
        else if( code == MOTOR_ON_CODE )
        {
            // Continuously update last on time while button is held
            last_on_time = millis() ;

            // Motor on
            ...
        }
    }
}
</code></pre>

<p>I have included response to the motor-off code, but that may not be necessary, since the motor will be switched off 250ms (or whatever time you choose) after the ON button is released in any case.  You might instead have a forward/reverse button and release either to stop:</p>

<pre><code>#define NO_CODE        0xFFFFFFFFul
#define MOTOR_FWD_CODE 0xFF906Ful
#define MOTOR_REV_CODE 0xFFE01Ful
#define STOP_TIME_MS   250ul  // stop after button release for 250ms

void loop( )
{
    static unsigned long last_on_time = 0 ; 

    if( irrecv.decode( &amp;results ) )
    {
        irrecv.resume() ;

        unsigned long code = results.value ;
        switch( code )
        {
            case NO_CODE :
            {
                if( millis() - last_on_time &gt; STOP_TIME_MS )
                {
                    // Motor off
                    ...          
                }
            }
            break ;

            case MOTOR_FWD_CODE :
            {
                // Continuously update last on time while button is held
                last_on_time = millis() ;

                // Motor forward
                ...
            }
            break ;

            case MOTOR_FWD_CODE :
            {
                // Continuously update last on time while button is held
                last_on_time = millis() ;

                // Motor reverse
                ...
            }
            break ;
        }
    }
}
</code></pre>
",,,
56152699,2,56133361,2019-05-15T15:16:31.457,0,,11499024,,2019-05-15T15:16:31.457,,0,,"<p>Finally, the reading program works perfectly.</p>

<p>there was just a problem on that line.</p>

<pre><code>register_addr = i &gt;&gt; 8;
</code></pre>

<p>I shifted right by 8 bits without really knowing why</p>

<p>so I replaced this line with</p>

<pre><code>register_addr = i;
</code></pre>

<p>And so I have the expected return (the values ​​correspond to those expected)</p>

<pre><code>data on 0xC0 : 0x14
data on 0xC1 : 0x00
data on 0xC2 : 0x00
data on 0xC3 : 0x00
data on 0xC4 : 0x02
data on 0xC5 : 0x00
data on 0xC6 : 0xB0
data on 0xC7 : 0x12
data on 0xC8 : 0xE6
data on 0xC9 : 0xBD
data on 0xCA : 0xD1
data on 0xCB : 0x58
data on 0xCC : 0xB9
data on 0xCD : 0x00
data on 0xCE : 0x05
data on 0xCF : 0x33
data on 0xD0 : 0x00
data on 0xE1 : 0x00
data on 0xE2 : 0x00
data on 0xE3 : 0x00
data on 0xE4 : 0x00
</code></pre>

<p>As for the writing program, it was already working (he wrote well in the registers indicated). But, the written values ​​are wrong (except for the first register).</p>

<p>Write : </p>

<pre><code>Valeur de registre pour 0xC0 : 00010100

Valeur de registre pour 0xC1 : 11111111

Valeur de registre pour 0xC2 : 11111111

</code></pre>

<p>Read :</p>

<pre><code>data on 0xC0 : 0x14
data on 0xC1 : 0x7F
data on 0xC2 : 0x1F

</code></pre>

<p>Do you have any idea where this might come from?</p>
",,,
56153257,2,56152672,2019-05-15T15:48:52.550,0,,1774667,,2019-05-15T15:48:52.550,,0,,"<p>Sure you can visit every point in a 256^3 space continuously.</p>

<p>The easiest way is to start with a line, then turn a line into a plane, then turn a plane into a cube.</p>

<pre><code>struct simple_generator {
  int current = 0;
  int min = 0;
  int max = 255;
  int direction = 1;
  bool advance() // returns false iff we hit the end
  {
    if (current + direction &gt; max || current+direction &lt; min) {
      direction = -direction;
      return false;
    }
    current += direction;
    return true;
   }
 };
</code></pre>

<p>now let's make a generator from this.</p>

<pre><code>template&lt;std::size_t N&gt;
struct shape_generator {
  simple_generator state[N];
  int operator[](std::size_t i) const { return state[i].current; }
  bool advance() {
    for (std::size_t i = 0; i &lt; N; ++i) {
      if (state[i].advance())
        return true;
    }
    return false;
  }
};
</code></pre>

<p>now what this does it advances the first simple generator until it overflows (which causes the generator stand still and reverse directions).  If it overflows, it ""recursively"" advances the next one.</p>

<p>If every generator overflows, it returns false.  Otherwise it returns true.</p>

<p>This will generate a pretty boring curve, as it mostly looks like ""blue goes to top, then back down, back to top, and back down"".  Only after many cycles does any green show up.  And only after many cycles of green does any red show up.</p>

<p>A fancier one would use an approximation of a real space-filling curve, like the Hilbert curve.  But that should work</p>

<p><a href=""http://coliru.stacked-crooked.com/a/c48eb993ff617b97"" rel=""nofollow noreferrer"">Live example with a max of 5</a>, because running it for 256^3 elements seems rude.</p>
",,,
56166786,2,56166622,2019-05-16T10:47:40.987,2,,9072753,,2021-01-05T16:29:16.430,2021-01-05T16:29:16.430,3,,"<p>From <a href=""https://www.kernel.org/doc/Documentation/gpio/sysfs.txt"" rel=""nofollow noreferrer"">kernel gpio/sysfs.txt</a>:</p>
<blockquote>
<pre><code>&quot;value&quot; ... reads as either 0 (low) or 1 (high). If the GPIO
  is configured as an output, this value may be written;
  any nonzero value is treated as high.

  If the pin can be configured as interrupt-generating interrupt
  and if it has been configured to generate interrupts (see the
  description of &quot;edge&quot;), you can poll(2) on that file and
  poll(2) will return whenever the interrupt was triggered. If
  you use poll(2), set the events POLLPRI and POLLERR. If you
  use select(2), set the file descriptor in exceptfds. After
  poll(2) returns, either lseek(2) to the beginning of the sysfs
  file and read the new value or close the file and re-open it
  to read the value.

&quot;edge&quot; ... reads as either &quot;none&quot;, &quot;rising&quot;, &quot;falling&quot;, or
  &quot;both&quot;. Write these strings to select the signal edge(s)
  that will make poll(2) on the &quot;value&quot; file return.

  This file exists only if the pin can be configured as an
  interrupt generating input pin.
</code></pre>
</blockquote>
<p>The preferred way is usually to configure the interrupt with <code>/sys/class/gpio/gpioN/edge</code> and <code>poll(2)</code> for <code>POLLPRI | POLLERR</code> (important it's <em>not</em> POLLIN!) on <code>/sys/class/gpio/gpioN/value</code>. If your process is some &quot;real-time&quot; process that needs to handle the events in real time, consider decreasing it's niceness.</p>
<p>You can even find some example code on github that uses poll, ex. <a href=""https://github.com/luisaburini/GPIO-interrupt/blob/master/gpio-poll.c"" rel=""nofollow noreferrer"">this repo</a>.</p>
",,,
56249124,2,56196903,2019-05-22T04:00:28.943,0,,11519533,,2019-05-22T04:00:28.943,,0,,"<p>I have elected to use the asf functions available for the SAM3X8E.  I am not sure if this will work on all 4 ports simultaneously.</p>

<pre><code> void enable_NVIC_interrupts(){
 // PORT A NVIC
 pmc_enable_periph_clk(ID_PIOA);
 pio_set_input(PIOA, PIO_PA29, PIO_PULLUP;
 pio_handler_set(PIOA, ID_PIOC, PIO_PA29, PIO_IT_EDGE, int_RINGMODULATOR);
 pio_enable_interrupt(PIOA, PIO_PA29);
 NVIC_EnableIRQ(PIOA_IRQn);

 // PORT B NVIC
 pmc_enable_periph_clk(ID_PIOB);
 pio_set_input(PIOB, PIO_PB25, PIO_PULLUP;
 pio_handler_set(PIOB, ID_PIOB, PIO_PB25, PIO_IT_EDGE, int_TREMOLO);
 pio_enable_interrupt(PIOB, PIO_PB25);
 NVIC_EnableIRQ(PIOB_IRQn);

 // PORT C NVIC
 pmc_enable_periph_clk(ID_PIOC);
 pio_set_input(PIOC, PIO_PC22, PIO_PULLUP;
 pio_handler_set(PIOC, ID_PIOC, PIO_PC22, PIO_IT_EDGE, int_DISTORTION);
 pio_enable_interrupt(PIOC, PIO_PC22);
 NVIC_EnableIRQ(PIOC_IRQn);

 // PORT D NVIC
 pmc_enable_periph_clk(ID_PIOD);
 pio_set_input(PIOD, PIO_PD7, PIO_PULLUP;
 pio_handler_set(PIOD, ID_PIOD, PIO_PD7, PIO_IT_EDGE, int_REVERB);
 pio_enable_interrupt(PIOD, PIO_PD7);
 NVIC_EnableIRQ(PIOD_IRQn);
</code></pre>
",,,
56215551,2,56210248,2019-05-20T06:43:56.383,0,,34989,,2019-05-20T14:00:08.127,2019-05-20T14:00:08.127,3,,"<p>You should receive 4 bytes (On most architectures, <code>sizeof(float)</code> is always 4) so check your received data:</p>

<pre><code>if (len(receivedMessage) == 4)
</code></pre>

<p>The four bytes represents a float so to convert it:</p>

<pre><code>temperature = float.fromhex(''.join(format(x, '02x') for x in receivedMessage))
</code></pre>

<p>The four bytes is converted to an hex string and converted to a float.</p>

<p>Edit (not tested): </p>

<pre><code>receivedMessage = []
radio.read(receivedMessage, radio.getDynamicPayloadSize())

if (len(receivedMessage) == 4)
   temperature = float.fromhex(''.join(format(x, '02x') for x in receivedMessage))
   print '%.2f' % temperature 
</code></pre>
",,,
56210649,2,56210292,2019-05-19T18:09:56.530,0,,3629249,,2019-05-19T18:09:56.530,,1,,"<p>after removing all the 'unneeded' code and correcting several small errors, the result is:</p>

<pre><code>// if you really want 'const', 
// then all references must also be 'const'
float a[25][25];

// the second parameter is from a float value
// not from an array of float values
float dot_product( float v[][25], float u )
{
    // initialize the float variable from a float literal
    // rather than from a double literal
    float result = 0.0f;

    for (int i = 0; i &lt; 25; i++)
    {
        // since the function exits after summing a single
        // row, the 'j' is replaced with 0
        result += u * v[0][i];
    }
    return result;
}


void forward(float x)
{
    float lm = 0.0f;

    for (int k=0; k&lt;25; k++)
    {
        // note: passing address of 'a[k]'
        lm += dot_product( &amp;a[k], x );
    }
}
</code></pre>
",,,
56244167,2,56244100,2019-05-21T18:12:11.727,4,,1687119,,2019-05-21T18:12:11.727,,2,,"<p>When you do this:</p>

<pre><code>char * ptr = malloc(1);
</code></pre>

<p>You're only allocating enough space for a single byte.  When you then try to <code>strcat</code> or <code>strcpy</code> anything to it, you're writing past the bounds of allocated memory.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Assigning <code>""""</code> to <code>ptr</code> also won't work because it now points to a (empty) string literal and string literals can't be modified.  Assigning <code>NULL</code> also won't work because it's undefined behavior to dereference a <code>NULL</code> pointer.</p>

<p>You need to allocate enough space to hold the entire string plus the terminating null byte:</p>

<pre><code>char *ptr = malloc(10 + strlen(wifi_ssid) + 3 + strlen(WIFI_PASS) + 1 + 1);
strcpy(ptr, ""AT+CWJAP=\"""");
strcat(ptr, wifi_ssid);
strcat(ptr,""\"",\"""");
strcat(ptr,WIFI_PASS);
strcat(ptr,""\"""");
</code></pre>
",,,
56308041,2,56293608,2019-05-25T19:29:44.307,0,,6700019,,2019-05-25T19:29:44.307,,0,,"<p>Unfortunately, there is no regular expression for Arduino, so you need to do it manually.</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;SoftwareSerial.h&gt;

String inputTXT;

SoftwareSerial mySerial(10, 11); // RX, TX

void setup()
{
    //setup
    Serial.begin(9600);
    mySerial.begin(9600);
    mySerial.write(""AT"");
    delay(100);
    mySerial.write(""AT+ROLE1""); // Master mode
    delay(100);
    mySerial.write(""AT+IMME1""); //wait for a connection command before connecting
    delay(100);
    mySerial.write(""AT+RESET"");
    delay(50);
}

void loop()
{

    delay(3000);
    mySerial.write(""AT+DISI?"");
    if (mySerial.available())
    {
        inputTXT = mySerial.readString();
        int pos = 0;
        String result = """";
        const String regx = ""00000000:00000000000000000000000000000000:0000000000:"";
        const int regx_len = regx.length();
        while ((pos = inputTXT.indexOf(regx, pos)) != -1)
        {
            // substring from &lt;starting point&gt; to &gt;starting point + 12&gt;
            result = inputTXT.substring(pos + regx_len, pos + regx_len + 12);
            Serial.println(result);
            // move starter point to end of last result
            pos = pos + regx_len + 12;
        }
    }
}
</code></pre>
",,,
56318581,2,56314418,2019-05-27T01:13:27.363,1,,3915,,2019-05-27T01:13:27.363,,2,,"<p>@Clifford <a href=""https://github.com/rpi-ws281x/rpi-ws281x-go/blob/d1c4b49fa01da378f9c24e72a1cf042795dc5a44/ws2811_arm.go#L58"" rel=""nofollow noreferrer"">MakeWS2811(...)</a> does take a pointer, but it looks like it makes a copy of the options in C.</p>

<p>However the returned instance has a <a href=""https://github.com/rpi-ws281x/rpi-ws281x-go/blob/d1c4b49fa01da378f9c24e72a1cf042795dc5a44/ws2811.go#L135"" rel=""nofollow noreferrer"">Leds(nChannel)</a> method, giving direct access to set the colours of LEDs. You can reduce the colour value to reduce the brightness (approximately). </p>

<pre><code>...
opt.Channels[0].Brightness = ... original value 0 to 255
ws, err := MakeWS2811(&amp;opts)
...

ws.Leds(0)[0] = 0xff //bright red
ws.Leds(0)[1] = 0x7f //half as bright
ws.Render()
</code></pre>

<p>Note each time the C lib renders, it still <a href=""https://github.com/jgarff/rpi_ws281x/blob/5b73b22517040423a657cc5e245529a9ed90d4d6/ws2811.c#L1140"" rel=""nofollow noreferrer"">scales</a> the colours you set by the original brightness.</p>
",,,
56356195,2,56347508,2019-05-29T08:28:41.987,0,,8548828,,2019-05-29T12:59:34.170,2019-05-29T12:59:34.170,3,,"<p><code>Serial.println('\n');</code> is not needed. Because the <code>ln</code> in the name means that it wil print a newline.</p>

<p><code>rfid.uid.uidByte</code> is a array of <a href=""https://github.com/miguelbalboa/rfid/blob/master/src/MFRC522.h#L322"" rel=""nofollow noreferrer"">10 bytes</a>.<br>
<code>Firebase.getString(""UID1"")</code> <a href=""https://buildmedia.readthedocs.org/media/pdf/firebase-arduino/latest/firebase-arduino.pdf#page=7"" rel=""nofollow noreferrer"">returns</a> a arduino <a href=""https://www.arduino.cc/reference/en/language/variables/data-types/stringobject/"" rel=""nofollow noreferrer""><code>String</code></a></p>

<p>You can't compare an array to a <code>String</code>. But you can compare the elements of a <code>String</code> to the elements of an array.</p>

<pre><code>String handle = Firebase.getString(""UID1"");
uint8_t lengthToCompare = rfid.uid.size;
if(handle.length() != lengthToCompare){ // this only works if you compare the whole string
    // not equal
}

bool equal = true;
for(int i=0;i&lt;lengthToCompare;++i) {
    equal &amp;= handle.c_str()[i] == rfid.uid.uidByte[i]; // compare if equal and variable 
                                                       // equal remains true if so
}
// equal now holds if the sequences where equal
</code></pre>

<p>As said before <code>rfid.uid.uidByte = Firebase.getString(""UID1"")</code> is not a comparison but a assignment, and a bad one at that because a <code>String</code> is being assigned to a array of bytes. The comparison operator is <code>==</code>.</p>

<p>Also when posting on StackOverflow (or working with your code): <a href=""http://releases.llvm.org/download.html"" rel=""nofollow noreferrer""><code>clang-format.exe -i &lt;filename&gt;</code></a> is your friend. (assuming you are using windows of course, I wouldn't want to presume your OS preferences)</p>
",,,
56354563,2,56351072,2019-05-29T06:47:27.103,1,,5840652,,2019-05-29T07:01:39.983,2019-05-29T07:01:39.983,0,,"<p>Before I post my solution I need to advice against reading from registers directly. Whoever is giving you this task wants to be a smart-ass and thinks that calling the HAL_GPIO_ReadPin function results in some kind of unbearable overhead which is most definitely not true. In fact, if all the port defines from JOY_A_GPIO_Port to JOY_CTR_GPIO_Port are different and optimizations are turned on, then the compiler is very likely to produce optimal code. Furthermore replacing the function call with direct register reads reduces the reuse-ability of the application code.</p>

<p>Anyhow, lets apply some changes...</p>

<p>Lets start off with a 1:1 translation which uses direct register access:</p>

<pre><code>uint8_t ReadJoystick() 
{
  uint8_t JoystickPosition = 0u;

  // Get current joystick value
  if ((JOY_A_GPIO_Port-&gt;IDR &amp; JOY_A_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'L';
  else if ((JOY_B_GPIO_Port-&gt;IDR &amp; JOY_B_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'U';
  else if ((JOY_C_GPIO_Port-&gt;IDR &amp; JOY_C_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'D';
  else if ((JOY_D_GPIO_Port-&gt;IDR &amp; JOY_D_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'R';
  else if ((JOY_CTR_GPIO_Port-&gt;IDR &amp; JOY_CTR_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'C';

  return JoystickPosition;
}
</code></pre>

<p>In case you haven't fully understood the code yet:</p>

<ul>
<li>xxx_Port->IDR reads the input data register for the whole port</li>
<li>A bitwise &amp; masks the input and gives us only the specific pin we are
looking for</li>
</ul>

<p>As I mentioned before this is not going to bring any performance improvements whatsoever.</p>

<p>However we might improve the code a little if some of the port defines are equal and point to the same memory address. In practice this is common because embedded designers are usually keen to join IO pins of an external device on a single port. E.g. lets assume JOY_A_GPIO_Port == JOY_B_GPIO_Port, then we could read the input data register of this port just once into a local variable like this:</p>

<pre><code>uint8_t ReadJoystick() 
{
  uint8_t JoystickPosition = 0;

  // Read input data register for AB once
  uint32_t ab_port = JOY_AB_GPIO_Port-&gt;IDR;

  // Get current joystick value
  if ((ab_port &amp; JOY_A_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'L';
  else if ((ab_port &amp; JOY_B_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'U';
  else if ((JOY_C_GPIO_Port-&gt;IDR &amp; JOY_C_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'D';
  else if ((JOY_D_GPIO_Port-&gt;IDR &amp; JOY_D_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'R';
  else if ((JOY_CTR_GPIO_Port-&gt;IDR &amp; JOY_CTR_Pin) == GPIO_PIN_RESET)
    JoystickPosition = 'C';

  return JoystickPosition;
}
</code></pre>

<p>This effectively just saved us one register read. Of course the more joystick pins there are on a single port the better.</p>

<p>/edit
ST provides an alternative function for reading a whole port in their ""LL"" library:</p>

<pre><code>__STATIC_INLINE uint32_t LL_GPIO_ReadInputPort(GPIO_TypeDef *GPIOx)
{
  return (uint32_t)(READ_REG(GPIOx-&gt;IDR));
}
</code></pre>
",,,
56378801,2,56378428,2019-05-30T12:57:53.290,2,,3702377,,2019-05-30T13:35:06.080,2019-05-30T13:35:06.080,3,,"<p>Before <code>print(result.registers)</code> try the following code snippet:</p>

<pre><code>if not result.isError():
    print(result.registers)
else:
    print(""error: {}"".format(result))
</code></pre>

<p>Also, fill in other <code>ModbusSerialClient()</code> argument.</p>

<p>Here is updated of your code snippet:</p>

<pre><code>from pymodbus.client.sync import ModbusSerialClient

class ModbusRTU:
    def __init__(self, graph_name, port, baudrate=9600,
                 stopbits=1, bytesize=8, parity='N',
                 timeout=1):
        self.graph_name = graph_name
        self.client = ModbusSerialClient(
            method='rtu',
            port=port,
            baudrate=baudrate,
            parity=parity,
            timeout=timeout,
            stopbits=stopbits,
            bytesize=bytesize
        )
        self.connection = self.client.connect()
        result = self.client.read_input_registers(address=1,
                                                  count=2,
                                                  unit=1)
        if not result.isError():
            print(result.registers)
        else:
            print(""error: {}"".format(result))

if __name__ == '__main__':
    modbus = ModbusRTU(
        graph_name='/dev/ttyACM0',
        port='/dev/ttyACM0', baudrate=9600,
        stopbits=1, bytesize=8, parity='N',
        timeout=1
    )
</code></pre>
",,,
56415238,2,56378428,2019-06-02T12:52:03.003,1,,11422153,,2019-06-02T12:57:16.203,2019-06-02T12:57:16.203,0,,"<p>I already found out the solution for this thanks for the help of few people. The QModMaster uses a library called libmodbus. Since the Arduino simulated slave and sensor worked with QModMaster, it would be easier to change the previous library and instead use libmodbus. Luckily, there is a python equivalent for libmodbus which is pylibmodbus. This is the link for the library <a href=""https://github.com/stephane/pylibmodbus"" rel=""nofollow noreferrer"">https://github.com/stephane/pylibmodbus</a>.</p>

<pre><code>    from pylibmodbus import ModbusRtu


    class ModbusRTU:
        def __init__(self, port, baudrate=9600, databit=8, parity='None', 
                     stopbit=1, timeout=1000):
            self.parity = {'Odd': 'O', 'Even': 'E', 'None': 'N'}
            self.modbus = ModbusRtu(device=port.encode('ascii'),   
                                    data_bit=databit, baud=baudrate,
                                    parity=self.parity[parity] \
                                           .encode('ascii'), 
                                    stop_bit=stopbit)
            self.modbus.set_response_timeout(timeout/1000)
            self.modbus.connect()
            self.modbus.set_slave(1)
            result = self.modbus.read_registers(0, 2)
            print(result)
            self.modbus.close()


    if __name__ == '__main__':
        main = ModbusRTU('/dev/ttyACM0', baudrate=9600, databit=8, 
                         parity='None', stopbit=1)
</code></pre>
",,,
57721595,2,56387774,2019-08-30T06:31:59.423,0,,4409883,,2019-08-30T06:31:59.423,,0,,"<p>""Make sure SD card lines have pull-up resistors in place."" is the default error message when communication with the SD Card (module) does not work.</p>

<pre><code>esp_err_t ret = esp_vfs_fat_sdmmc_mount(""/sdcard"", &amp;host, &amp;slot_config, &amp;mount_config, &amp;card);

if (ret != ESP_OK) {
    if (ret == ESP_FAIL) {
        ESP_LOGE(TAG, ""Failed to mount filesystem. ""
            ""If you want the card to be formatted, set format_if_mount_failed = true."");
    } else {
        ESP_LOGE(TAG, ""Failed to initialize the card (%d). ""
            ""Make sure SD card lines have pull-up resistors in place."", ret);
    }
    return;
}
</code></pre>

<p>The information about the pull-up resistors is only a hint what might be wrong similar to: Maybe one of your wires is not connected correctly.</p>

<p>I had the same error when I tried that code using an SD-Card module with SPI connection which I used previously with Arduino.</p>

<p>After trying lots of things and looking at info all over the internet it seems to me that this never worked with SPI and an SD-Card module which uses SPI. I remember I found info like ""this will be implemented later"" but I don't remember where I read that.</p>

<p>Later I found there are other SD-Card modules which don't use SPI. </p>

<p>I used this one and it worked.</p>

<p><a href=""https://i.stack.imgur.com/1Xp6o.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1Xp6o.jpg"" alt=""9 Pin Micro SD TF Card Reader Read &amp; Write Module""></a>
<a href=""https://www.ebay.com/itm/9-Pin-Micro-SD-TF-Card-Reader-Read-Write-Module-Storage-Board-Memory-Arduino/401316600781"" rel=""nofollow noreferrer"">https://www.ebay.com/itm/9-Pin-Micro-SD-TF-Card-Reader-Read-Write-Module-Storage-Board-Memory-Arduino/401316600781</a></p>

<p>This is not connected with SPI and that option has to be selected in the code here:</p>

<pre><code>// This example can use SDMMC and SPI peripherals to communicate with SD card.
// By default, SDMMC peripheral is used.
// To enable SPI mode, uncomment the following line:

//#define USE_SPI_MODE
</code></pre>

<p>And later in the code there is this section:</p>

<pre><code>// To use 1-line SD mode, uncomment the following line:
host.flags = SDMMC_HOST_FLAG_1BIT;
</code></pre>

<p>I was able to get it running by using the 1BIT mode with above module.
I didn't get it running using all connections (I think that is called SD Mode or 1 Line SD Mode).</p>
",,,
56423939,2,56413144,2019-06-03T08:50:03.977,0,,6601582,,2019-06-03T08:50:03.977,,0,,"<p>Your <code>ReadFile()</code> may return TRUE (success) with no data in <code>pBuf</code>. To solve this issue you can set <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-_commtimeouts"" rel=""nofollow noreferrer""><code>ReadIntervalTimeout</code></a> to, for example, 10 (milliseconds) instead of <code>MAXDWORD</code> because:</p>

<blockquote>
  <p>A value of MAXDWORD, combined with zero values for both the
  ReadTotalTimeoutConstant and ReadTotalTimeoutMultiplier members,
  specifies that the read operation is to return immediately with the
  bytes that have already been received, <strong>even if no bytes have been
  received</strong>.</p>
</blockquote>

<p>(Below not directly related to your issue but some tips for your code.)</p>

<p>Since you set up synchronous operation instead of asynchronous operation, there are some redundant code lines:</p>

<pre><code>OVERLAPPED ol;
memset (&amp;ol, 0, sizeof(OVERLAPPED));
ol.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

WaitForSingleObject();
</code></pre>

<p>In order to make overlapped operation take effect. You need set <code>FILE_FLAG_OVERLAPPED</code> flag for <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea"" rel=""nofollow noreferrer""><code>CrateFile()</code></a> and configure OVERLAPPED structure for <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-writefile#parameters"" rel=""nofollow noreferrer""><code>WriteFile()</code></a> and <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-readfile#parameters"" rel=""nofollow noreferrer""><code>ReadFile()</code></a>;</p>

<pre><code>//...

    HANDLE hPort = CreateFile(
        L""COM8"",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);

//...

    WriteFile(hComm, pBuf, iLen, NULL, &amp;ol);

//...

    ReadFile(hComm, pBuf, 1, NULL, &amp;ol);
</code></pre>
",,,
56425110,2,56424722,2019-06-03T10:06:38.323,0,,11215897,,2019-06-03T10:06:38.323,,2,,"<p>Thanks for the advice. I modified the code like follows (peeking at Node.JS), and it is working fine now on both platforms.</p>

<pre><code>int help(char *req, char *res){
  strcpy(res, ""This is the help string...\n"");
  return 0;
}

typedef struct {
  char* command;
  int (*cmdExec)(char *request, char *result);
}S_COMMAND;

S_COMMAND cmdTable[]= {
  {""he"", help}
};

int main(void){
    char text[20];

    cmdTable[0].cmdExec(""0"", text);
}
</code></pre>
",,,
56428468,2,56426827,2019-06-03T13:32:31.227,1,,5271927,,2019-06-03T13:32:31.227,,2,,"<p>In teensy TimeLib.h it's defined as:</p>

<pre><code>#if !defined(__time_t_defined) // avoid conflict with newlib or other posix libc
typedef unsigned long time_t;
#endif
</code></pre>

<p>and the <code>sys/_types.h</code> defines it as:</p>

<pre><code>#define _TIME_T_    long        /* time() */
typedef _TIME_T_    __time_t;
</code></pre>

<p>Used in several places as:</p>

<pre><code>#if !defined(__time_t_defined) &amp;&amp; !defined(_TIME_T_DECLARED)
typedef _TIME_T_    time_t;
#define __time_t_defined
#define _TIME_T_DECLARED
#endif
</code></pre>

<p>So it's not such a mystery it's ignored. Otherwise you wouldn't be able to compile because of conflicting types.</p>
",,,
56440100,2,56439555,2019-06-04T08:28:36.653,0,,10397400,,2019-06-04T08:28:36.653,,1,,"<p>When dealing with two programs running on different processors they will never start sending/receiving at the same time. What you likely see is not that the results are merged wrong it is more likely the reading program started and stopped half way through the data.</p>

<p>When sending data over a line it is best that you:</p>

<p>On the Arduino:</p>

<ol>
<li>First frame the data.</li>
<li>Send the frame.</li>
</ol>

<p>On Linux:</p>

<ol start=""3"">
<li>Read in data in a buffer.</li>
<li>Search the buffer for a complete frame and deframe.</li>
</ol>

<p><strong>1. Framing the data</strong></p>

<p>With framing the data I mean that you need a structure which you can recognize and validate on the receiving side. For example you could add the characters STX and ETX as <a href=""https://en.wikipedia.org/wiki/Control_character"" rel=""nofollow noreferrer"">control characters</a> around your data. When the length of your data varies it is also required to send this. </p>

<p>In the following example we take that the data array is never longer than 255 bytes. This means that you can store the length in a single byte. Below you see pseudo code of how a frame could look like:</p>

<pre><code>STX LENGTH DATA_ARRAY ETX
</code></pre>

<p>The total length of the bytes which will be send are thus the length of the data plus three.</p>

<p><strong>2. Sending</strong></p>

<p>Next you do not use println but Serial.write(buf, len) instead.</p>

<p><strong>3. Receiving</strong></p>

<p>On the receiving side you have a buffer in which all data received will be appended.</p>

<p><strong>4. Deframing</strong>
Next each time new data has been added search for an STX character, assume the next character is the length. Using the length +1 you should find a ETX. If so you have found a valid frame and you can use the data. Next remove it from the buffer.</p>

<pre class=""lang-cpp prettyprint-override""><code>for(uint32_t i = 0; i &lt; (buffer.size() - 2); ++i)
{
  if(STX == buffer[i])
  {
    uint8_t length = buffer[i+2];
    if(buffer.size() &gt; (i + length + 3) &amp;&amp; (ETX == buffer[i + length + 2]))  
    {
      // Do something with the data.

      // Clear the buffer from every thing before i + length + 3
      buffer.clear(0, i + length + 3);

      // Break the loop as by clearing the data the current index becomes invalid.
      break; 
    }
  }
}
</code></pre>

<p>For an example also using a Cyclic Redundancy Check (CRC) see <a href=""https://stackoverflow.com/questions/17073302/what-type-of-framing-to-use-in-serial-communication"">here</a></p>
",,,
56461781,2,56460727,2019-06-05T13:45:19.463,1,,6782754,,2019-06-07T09:34:12.703,2019-06-07T09:34:12.703,0,,"<p>You probably cannot filter all unwanted messages. But you can narrow down a bit.
For a suitable mask you must treat the ones and the zeros separately.</p>

<pre><code>uint32 mask_ones = mask_zeros = ~0;

for (int id = startId; id &lt; endId; id++)
{
  mask_ones  &amp;=  id;
  mask_zeros &amp;= ~id;
}
uint32 mask = mask_ones | mask_zeroes;
uint32 value = startId &amp; mask;
</code></pre>

<p>This creates a mask which includes all bits that are set to 1 in every allowed value and also all bits that are set to 0 in every allowed value.
This should get rid of all values above <code>0x37</code>.</p>

<p>Example:</p>

<pre><code>ones = zeros = 11111111
CAN Message: 30 110000 =&gt; mask_ones = 00110000; mask_zeros = 11001111
CAN Message: 31 110001 =&gt; mask_ones = 00110000; mask_zeros = 11001110
CAN Message: 32 110010 =&gt; mask_ones = 00110000; mask_zeros = 11001100
CAN Message: 33 110011 =&gt; mask_ones = 00110000; mask_zeros = 11001100
CAN Message: 34 110100 =&gt; mask_ones = 00110000; mask_zeros = 11001000
CAN Message: 35 110101 =&gt; mask_ones = 00110000; mask_zeros = 11001000
unwanted:
CAN Message: 36 110110
CAN Message: 37 110111
CAN Message: 38 111000

mask =  00110000 | 11001000 = 11111000 = 0xF8
value =  00110000 &amp; 11111000 = 00110000 = 0x30
</code></pre>

<p>Update:
The calculation above was broken. Fixed it.</p>
",,,
56472020,2,56471826,2019-06-06T06:33:27.027,1,,11217628,,2019-06-06T11:18:06.947,2019-06-06T11:18:06.947,0,,"<p><code>&lt;&lt;</code> is a shift operator, so the value in <code>buff[0]</code> is shifted by 8 bit to the left, then this value is linked by a <em>or</em> function. Finally the resulting value is divided by 1.2</p>

<p>Example:</p>

<pre><code>buff[0] = 0000 0001              // assume this value for buff[0] (1 in decimal)
buff[1] = 0110 1000              // assume this value for buff[1] (104 in decimal)

buff[0]&lt;&lt;8:                      // move 8 bit to the left
0000 0001 0000 0000

buff[0]&lt;&lt;8 | buff[1]:            // link by or function
0000 0001 0000 0000 | 0000 0000 0110 1000 = 0000 0001 0110 1000     // 360 in decimal
</code></pre>

<p>so</p>

<pre><code>value = 360 / 1.2 = 300 
</code></pre>

<p>be aware that <code>value</code> is an <em>int</em> and thus it will neglect decimal digits</p>
",,,
56507333,2,56498186,2019-06-08T14:35:26.777,0,,11315464,,2019-06-08T14:35:26.777,,0,,"<p>The problem was that I did not call my Bluetooth Object by reference.
Instead of giving my function the Bluetooth Object I should point to it:</p>

<pre><code>void getCurrentMessage(BluetoothSerial* ESP_BT, char* receivedChars, int InputSize)
{
 Serial.println(""DEBUG: getCurrentMessageInit"");
 static byte ndx = 0;

 char rc;

 while (ESP_BT-&gt;available() &gt; 0){
   ESP_BT-&gt;println(""DEBUG: Message Available"");    
   Serial.println(""DEBUG: Message Available"");
   rc = ESP_BT.read();
   receivedChars[ndx] = rc;
   ndx++;
   delay(100);
   if (ndx &gt;= InputSize){
     while(ESP_BT-&gt;available() &gt; 0){
       ESP_BT-&gt;read();
     }
   }
 }
} 
</code></pre>
",,,
56535515,2,56511761,2019-06-11T02:04:45.470,0,,8954291,,2019-06-11T02:04:45.470,,0,,"<p>Look at Joshua's answer for why. It's a great answer. As for what to <em>do</em> about it, you need to actually call <code>delay</code>.</p>

<pre><code>void setup()
{
    Serial.begin(9600);
}

void loop()
{
    delay(1000);
    Serial.println(""Hi there"");
}
</code></pre>
",,,
56511881,2,56511826,2019-06-09T04:07:47.833,2,,706055,,2019-06-09T05:57:07.863,2019-06-09T05:57:07.863,1,,"<p>It seems that you construct a second <code>UdpMsg</code> variable in:</p>

<pre><code>  if(udp.read(buffer, 50) &gt; 0){
    Serial.print(""Recevied UDP: "");
    Serial.println((char *)buffer);
    String UdpMsg ((char *)buffer); // &lt;--- 2nd UdpMsg, released after 'if' clause
  }
</code></pre>

<p>While <code>UdpMsg</code> at this line:</p>

<pre><code>if ( UdpMsg == ""relay01_off"" )
</code></pre>

<p>refers to the first one, the global, that keeps its initial value ""12345"".</p>
",,,
56600342,2,56599335,2019-06-14T14:37:15.593,0,,6700019,,2019-06-14T14:37:15.593,,2,,"<p>You don't need to create your <code>object</code> each time. Just define it as a global variable and change its values on your loop. Something like this:</p>

<pre><code>#include &lt;DHT.h&gt;
#include &lt;DHT_U.h&gt;
#include &lt;ArduinoJson.h&gt;
#define DHTPIN 2
#define DHTTYPE DHT11

DHT dht(DHTPIN, DHTTYPE);
int humidity, temperature;

StaticJsonDocument&lt;50&gt; doc;
JsonObject object;

void setup()
{
  // put your setup code here, to run once:
  Serial.begin(9600);
  Serial.println(""Begin"");
  dht.begin();
  object = doc.to&lt;JsonObject&gt;();
}

void loop()
{
  humidity = dht.readHumidity();
  temperature = dht.readTemperature();
  object[""ID""] = ""Node01"";
  object[""humidity""] = humidity;
  object[""temperature""] = temperature;
  serializeJson(doc, Serial);
  Serial.println("""");
  delay(2000);
}
</code></pre>
",,,
56681474,2,56618546,2019-06-20T07:54:43.727,0,,5329483,,2019-06-20T07:54:43.727,,0,,"<p>And here my shot in the dark. You have a memory overwrite anywhere and this kills <code>cols[]</code>. If you move the variable from global scope to local scope the outcome varies. Add some 'detector' code:</p>

<pre><code>volatile unsigned int cols[7] = { 0xFFFF0000, 0xFFFF7F00, 0xFFFFFF00, 0xFF00FF00, 0xFF0000FF, 0xFF4B0082, 0xFF9400D3 };
drawNum(&amp;display, 0x1234ABCD);

//test code
drawNum(&amp;display, cols[0]==0xFFFF0000);    
drawNum(&amp;display, cols[1]==0xFFFF7F00);

for (int i=0; i&lt;7; i++)
  drawNum(&amp;display, cols[i]);      

//test code
drawNum(&amp;display, cols[0]==0xFFFF0000);    
drawNum(&amp;display, cols[1]==0xFFFF7F00);
</code></pre>

<p>I added the volatile keyword to avoid optimizations by the compiler. It shouldn't mask away the observed wrong output.</p>
",,,
56622032,2,56621670,2019-06-16T19:34:57.117,4,,4151599,,2019-06-16T19:57:23.447,2019-06-16T19:57:23.447,6,,"<p>The Arduino toolchain includes a preprocessor that attempts to make writing C++ easier.  One of the things Arduino's preprocessor does is insert declarations for all of the functions in your sketch at the top of the file.  That means that the actual C++ code passed to g++ looks like this:</p>

<pre><code>#include &lt;Arduino.h&gt;
#line 1 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
#line 1 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
#line 1 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
bool baz();
#line 3 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
foo bar();
#line 5 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
void setup();
#line 10 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
void loop();
#line 1 ""E:\\Documents\\Arduino\\sketch_jun16a\\sketch_jun16a.ino""
bool baz() { return false; }
typedef uint32_t foo;
foo bar() { return 1; }

void setup() {
  // put your setup code here, to run once:

}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>

<p>As you can see, <code>foo bar();</code> is declared before the name <code>foo</code> is introduced by your <code>typedef</code>.</p>

<p>To work around this, add your own declaration of <code>bar</code>.  Arduino's preprocessor will only add declarations of functions that you haven't declared yourself:</p>

<pre><code>bool baz() { return false; }
typedef uint32_t foo;
foo bar();
foo bar() { return 1; }

void setup() {
  // put your setup code here, to run once:

}

void loop() {
  // put your main code here, to run repeatedly:

}
</code></pre>

<hr>

<p>As for why this isn't an issue when the <code>typedef</code> is the first line of the sketch: it looks like Arduino's preprocessor lifts <code>typedef</code> and <code>using</code> declarations along with existing function declarations and class definitions up to the top of the file, before the function declarations it adds, but only if they appear before any function definitions (not counting class member functions defined inline in the class definition).</p>
",,,
56633188,2,56631246,2019-06-17T14:15:41.533,0,,9112798,,2019-06-17T15:56:05.760,2019-06-17T15:56:05.760,2,,"<p>Try replacing</p>

<pre class=""lang-c prettyprint-override""><code>  client.beginRequest();
  client.post(""/input"");
  client.sendHeader(""Content-Type"", ""application/json"");
  client.sendHeader(""Content-Length"", postData.length());
  client.beginBody();
  client.println(postData);
  client.endRequest();
</code></pre>

<p>with just</p>

<pre class=""lang-c prettyprint-override""><code>String contentType = ""application/json"";
client.post(""/input"", contentType, postData);
</code></pre>

<p>or</p>

<pre class=""lang-c prettyprint-override""><code>client.post(""/input"", ""application/json"", postData.c_str());
</code></pre>

<p>You don't need to explicitly specify the request headers - or call <code>beginRequest()</code>, etc. - when using the <code>post()</code> method(s) in that library.</p>
",,,
56634054,2,56631611,2019-06-17T15:05:23.927,0,,1469714,,2019-06-17T15:05:23.927,,3,,"<p>The server returns a <code>id</code> member that's a <code>Number</code> <code>""id"":4</code>, while you are generating a <code>id</code> that's a <code>String</code> <code>""id"":""200""</code>.</p>

<p>You need to adjust your code to either one. If it's a number (and it seems so), you need to send <code>""id"":200</code> and change your code to get a number:</p>

<pre><code>unsigned id = (double)doc[""id""];

// And to generate it:
String json = ""{\""id\"" : 100 , \""cmd\"" : \""0xff\""}"";

</code></pre>

<p>Also, with JSON, beware of hexadecimal encoding, has it's not converted to number (you have to do it yourself by receiving a <code>const char*</code> and calling <code>sscanf</code> or <code>strtol</code> or ...) and it's not convenient. It's better to use base-10 encoding instead:</p>

<pre><code>String json = ""{\""id\"" : 100 , \""cmd\"" : 255}"";
</code></pre>
",,,
56638674,2,56638490,2019-06-17T20:42:53.000,1,,721269,,2019-06-17T20:42:53.000,,2,,"<pre><code>// append the 64-bit big endian ml at the end
if (ml &lt; 0x80000000)
    blocks[(numCycles*16)-1] = (uint32_t) ml;
else {
    blocks[(numCycles*16)-2] = (uint32_t) ml;
    blocks[(numCycles*16)-1] = (uint32_t) (ml &gt;&gt; 32);
}
</code></pre>

<p>This puts the most-significant 32-bit value first and the least-significant 32-bit value second. That's half the reason your code works.</p>

<p>The other half is that while the 32-bit values are in little-endian form, you are reading their <em>values</em> on a little-endian platform. That will always give you the correct value. You never try to access the individual bytes of the 32-bit values, so which bytes goes where makes no difference.</p>
",,,
56643146,2,56642550,2019-06-18T06:44:29.917,1,,6700019,,2019-06-20T06:32:58.143,2019-06-20T06:32:58.143,4,,"<p>You can use <a href=""https://arduinojson.org/v6/api/jsonobject/createnestedobject/"" rel=""nofollow noreferrer""><code>createnestedobject</code></a>, also remember that you are creating nested json objects in a loop so you need to take care of the size of your Json document (<code>256</code>).</p>

<p>EDIT: For example when your nested object exceeds a fixed value, You can use <a href=""https://arduinojson.org/v5/api/jsonbuffer/clear/"" rel=""nofollow noreferrer""><code>clear()</code></a> function to clear the JSON object.</p>

<pre><code>#define MAX_ELEMENTS 10

int receive_count = 0;
StaticJsonDocument&lt;256&gt; doc;
JsonObject object = doc.to&lt;JsonObject&gt;();

void loop()
{
    network.update();
    if (network.available())
    {
        RF24NetworkHeader header;
        network.read(header, &amp;pack0, sizeof(pack0));
        if (header.from_node)
        {
            JsonObject ID = object.createNestedObject(String(header.from_node));
            ID[""Temperature""] = pack0.temperature;
            ID[""Humidity""] = pack0.humidity;
            ID[""Soil""] = pack0.soil;
            serializeJsonPretty(object, Serial);
            Serial.println("""");
            receive_count++;
            //reset counter if reached and clear object
            if (receive_count &gt;= MAX_ELEMENTS)
            {
                doc.clear();
                object = doc.to&lt;JsonObject&gt;();
                receive_count = 0;
            }
        }
    }
}
</code></pre>
",,,
56662264,2,56662192,2019-06-19T07:27:29.537,4,,4431643,,2019-06-19T07:27:29.537,,0,,"<blockquote>
  <p>How can i make the output of button1 same with the output of button2?</p>
</blockquote>

<p>You are getting <code>1 0 1 0 1 0 1 0</code> for <code>button 1</code> because first <code>if</code> and last <code>else</code> block will be executed each time when <code>button1</code> is pressed.</p>

<p>Add <code>else</code> to second <code>if</code>.  </p>

<pre><code>if (digitalRead(BUTTON1) == LOW) {
    delay(500);
    i = ""1"";
    Serial.println(i);
  } 
  else if (digitalRead(BUTTON2) == LOW) {
    delay(500);
    j = ""2"";
    Serial.println(j);
  } 
  else {
    delay(500);
    x = ""0"";
    Serial.println(x);
  }
</code></pre>
",,,
56674804,2,56667451,2019-06-19T19:42:52.380,2,,2522782,,2019-06-19T19:42:52.380,,0,,"<p>Take a look at the code here: <a href=""https://github.com/Azure-Samples/iot-hub-feather-huzzah-client-app/blob/ab3d6e46f1b94192f8c8a96fb7b47d714df99439/app/app.ino#L114"" rel=""nofollow noreferrer"">https://github.com/Azure-Samples/iot-hub-feather-huzzah-client-app/blob/ab3d6e46f1b94192f8c8a96fb7b47d714df99439/app/app.ino#L114</a>. This is calling a function that returns a JSON string in the buffer passed as the second parameter. This function is defined here: <a href=""https://github.com/Azure-Samples/iot-hub-feather-huzzah-client-app/blob/ab3d6e46f1b94192f8c8a96fb7b47d714df99439/app/message.ino#L42"" rel=""nofollow noreferrer"">https://github.com/Azure-Samples/iot-hub-feather-huzzah-client-app/blob/ab3d6e46f1b94192f8c8a96fb7b47d714df99439/app/message.ino#L42</a>. </p>

<p>You would need to replace the content of readMessage with your code above to return your data in JSON form. However, you will need a little additional code. The code in loop has a 10ms delay and calls IoTHubClient_LL_DoWork on each iteration. For the Azure IoT SDK to work reliably this is required. Since you are only reading your sensor every 333ms you will need to track the time for yourself. For example, in loop you would only call readMessage each time loop has been executed 33 times. Something like this (quick and dirty for the sake of demonstration only):</p>

<pre><code>static int messageCount = 1;
static int loopCounter = 0;
void loop()
{
    if (++loopCounter == 33)
    {
        if (!messagePending &amp;&amp; messageSending)
        {
            char messagePayload[MESSAGE_MAX_LEN];
            bool temperatureAlert = readMessage(messageCount, messagePayload);
            sendMessage(iotHubClientHandle, messagePayload, temperatureAlert);
            messageCount++;
            delay(interval);
        }
        loopCounter = 0;
    }
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    delay(10);
}
</code></pre>

<p>This would give you a reading every 330ms. You will also need to add your connection string too.</p>
",,,
56701035,2,56687570,2019-06-21T09:54:04.950,-1,,11567249,,2019-06-21T09:54:04.950,,0,,"<p>thanks i just copy paste the code for a single sensor 4 times after each other and made each of them for another sensor there is just a small delay in each sensor but thats alright. new code is as following:</p>

<pre><code>// this constant won't change. It's the pin number of the sensor's output:
const int pingPin = 7;
const int pingPin2= 6;
const int pingPin3 = 5;
const int pingPin4 = 4;

void setup() {
  // initialize serial communication:
  Serial.begin(9600);
}

void loop() {
  // establish variables for duration of the ping, and the distance result
  // in inches and centimeters:
  long duration, inches, cm;

  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  pinMode(pingPin, OUTPUT);
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(5);
  digitalWrite(pingPin, LOW);

  // The same pin is used to read the signal from the PING))): a HIGH pulse
  // whose duration is the time (in microseconds) from the sending of the ping
  // to the reception of its echo off of an object.
  pinMode(pingPin, INPUT);
  duration = pulseIn(pingPin, HIGH);

  // convert the time into a distance
  inches = microsecondsToInches(duration);
  cm = microsecondsToCentimeters(duration);

  Serial.print(inches);
  Serial.print(""in, ""); 
  Serial.print(cm);
  Serial.print(""cm"");
  Serial.println();

  delay(400);

  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  pinMode(pingPin2, OUTPUT);
  digitalWrite(pingPin2, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin2, HIGH);
  delayMicroseconds(5);
  digitalWrite(pingPin2, LOW);

  // The same pin is used to read the signal from the PING))): a HIGH pulse
  // whose duration is the time (in microseconds) from the sending of the ping
  // to the reception of its echo off of an object.
  pinMode(pingPin2, INPUT);
  duration = pulseIn(pingPin2, HIGH);

  // convert the time into a distance
  inches = microsecondsToInches(duration);
  cm = microsecondsToCentimeters(duration);

  Serial.print(inches);
  Serial.print(""in, ""); 
  Serial.print(cm);
  Serial.print(""cm"");
  Serial.println();

  delay(400);


  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  pinMode(pingPin3, OUTPUT);
  digitalWrite(pingPin3, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin3, HIGH);
  delayMicroseconds(5);
  digitalWrite(pingPin3, LOW);

  // The same pin is used to read the signal from the PING))): a HIGH pulse
  // whose duration is the time (in microseconds) from the sending of the ping
  // to the reception of its echo off of an object.
  pinMode(pingPin3, INPUT);
  duration = pulseIn(pingPin3, HIGH);

  // convert the time into a distance
  inches = microsecondsToInches(duration);
  cm = microsecondsToCentimeters(duration);

  Serial.print(inches);
  Serial.print(""in, ""); 
  Serial.print(cm);
  Serial.print(""cm"");
  Serial.println();

  delay(400);

  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  pinMode(pingPin4, OUTPUT);
  digitalWrite(pingPin4, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin4, HIGH);
  delayMicroseconds(5);
  digitalWrite(pingPin4, LOW);

  // The same pin is used to read the signal from the PING))): a HIGH pulse
  // whose duration is the time (in microseconds) from the sending of the ping
  // to the reception of its echo off of an object.
  pinMode(pingPin4, INPUT);
  duration = pulseIn(pingPin4, HIGH);

  // convert the time into a distance
  inches = microsecondsToInches(duration);
  cm = microsecondsToCentimeters(duration);

  Serial.print(inches);
  Serial.print(""in, ""); 
  Serial.print(cm);
  Serial.print(""cm"");
  Serial.println();

  delay(400);
}

long microsecondsToInches(long microseconds) {
  // According to Parallax's datasheet for the PING))), there are 73.746
  // microseconds per inch (i.e. sound travels at 1130 feet per second).
  // This gives the distance travelled by the ping, outbound and return,
  // so we divide by 2 to get the distance of the obstacle.
  // See: http://www.parallax.com/dl/docs/prod/acc/28015-PING-v1.3.pdf
  return microseconds / 74 / 2;
}

long microsecondsToCentimeters(long microseconds) {
  // The speed of sound is 340 m/s or 29 microseconds per centimeter.
  // The ping travels out and back, so to find the distance of the object we
  // take half of the distance travelled.
  return microseconds / 29 / 2;
}
</code></pre>
",,,
56699035,2,56696428,2019-06-21T07:47:26.207,2,,9112798,,2019-06-21T07:47:26.207,,0,,"<p>The syntax you have used is not valid for initialization of nested <code>struct</code>s. See <a href=""https://en.cppreference.com/w/c/language/struct_initialization"" rel=""nofollow noreferrer"">here</a> -> Nested initialization section - for valid syntax.</p>

<p>The following are valid alternatives for what you are trying to achieve.</p>

<p>Using designators ...</p>

<pre class=""lang-c prettyprint-override""><code>struct Glove glove = {                                                                                 
    .index = {
        .pin = 20
    },                                                                                                 
    .middle = {                                                                                        
        .pin = 22                                                                                      
    },
    .ring = {
        .pin = 24 
    },
    .thumb = {
        .pin = 26                                                                                      
    },                                                                                                 
};
</code></pre>

<p>Relying on the declaration order of the struct elements ...</p>

<pre class=""lang-c prettyprint-override""><code>struct Glove glove3 = {
    {20}, // index - pin 
    {22}, // middle - pin                                                                              
    {24}, // ring - pin                                                                                
    {0}, // pinkie - pin                                                                               
    {26}, // thumb - pin                                                                               
};
</code></pre>

<p>Using designators for outer elements, declaration order for inner ...</p>

<pre class=""lang-c prettyprint-override""><code>struct Glove glove2 = {                                                                                
    .index = {20}, // pin = 20                                                                         
    .middle = {22}, // pin = 22                                                                        
    .ring = {24}, // pin = 24                                                                          
    .thumb = {26}, // pin = 26                                                                         
    };
</code></pre>

<p>Being inconsistent ...</p>

<pre class=""lang-c prettyprint-override""><code>struct Glove glove4 = {
    .index = {20}, // index.pin = 20                                                                   
    {22}, // middle.pin = 22                                                                           
    // Since we are using designators we can change the order                                          
    .thumb = {26}, // thumb.pin = 26                                                                   
    .pinkie = {.pin = 24}, // pinkie.pin = 24                                                          
    };
</code></pre>
",,,
56709420,2,56708674,2019-06-21T19:30:35.770,4,,9112798,,2021-02-21T19:56:35.420,2021-02-21T19:56:35.420,1,,"<p>It seems you are using the <a href=""https://github.com/espressif/arduino-esp32/tree/master/libraries/WebServer/src"" rel=""nofollow noreferrer"">WebServer</a> class from the ESP32 Arduino libraries. As you have gleaned already, the callback specified in the <code>on()</code> method does not accept any arguments.</p>
<p>You have an alternative, however. You can specify a 'placeholder' in the URL path - using curly brackets - <code>{}</code>. In the callback, then, the corresponding argument can be retrieved by using the <code>pathArg()</code> method - which accepts the argument index as parameter.</p>
<p>Example ...</p>
<p>You could define your API endpoint as <code>/readBatt/&lt;battery number&gt;</code>. To configure the server to handle requests to this endpoint, then, you would use something like</p>
<pre class=""lang-cpp prettyprint-override""><code>#include &lt;uri/UriBraces.h&gt;
server.on(UriBraces(&quot;/readBatt/{}&quot;), runTest);
</code></pre>
<p>In your callback, you would retrieve the first argument as follows ...</p>
<pre class=""lang-cpp prettyprint-override""><code>static void runTest() {
  String batteryNumber = server.pathArg(0);
  Serial.println(&quot;Request to read battery&quot;);
  String response = &quot;You attempted to read battery &quot; + batteryNumber;
  response += &quot;.\nThis endpoint is a placeholder. Check again soon!&quot;;
  server.send(200, &quot;text/plain&quot;, response);
}
</code></pre>
<p>Finally ... Suppose your ESP8266 was running on local IP address 192.168.1.9. You could access your new API endpoint by opening</p>
<blockquote>
<p><a href=""http://192.168.1.9/readBatt/1"" rel=""nofollow noreferrer"">http://192.168.1.9/readBatt/1</a></p>
</blockquote>
<p>in your browser. (Replace <code>1</code> with the relevant battery number.)</p>
<p>I don't think there are versions of the <code>pathArg()</code> which return an integer, unfortunately, so you may have to perform a conversion at some point.</p>
",,,
56750328,2,56748323,2019-06-25T08:59:10.637,1,,6110094,,2019-06-25T12:46:01.227,2019-06-25T12:46:01.227,0,,"<p>Your function is just horrible written. It is so bad - that even it does not make any sense to analyze it. BTW forget the recursion in the uC development.  Always think about the algorithm. Here you have much simpler and definitely more efficient:</p>

<pre><code>char *findAndReplace(char *haystack, const char *needle, const char *repl)
{
    size_t needle_len;
    size_t repl_len;
    size_t haystack_len;
    const char *pos = strstr(haystack, needle);

    if(pos)
    {
        needle_len = strlen(needle);
        repl_len = strlen(repl);
        haystack_len = strlen(haystack);

        if(needle_len != repl_len)
        {
            memmove((void *)(pos + repl_len), (void *)(pos + needle_len), haystack_len - (pos - haystack) + 1);
        }

        memcpy((void *)pos, (void *)repl, repl_len);
    }
    return haystack;
}
</code></pre>

<p>of course the haystack has to be:</p>

<ol>
<li>modifiable </li>
<li>big enough to accommodate the amended string</li>
</ol>

<blockquote>
  <p>but to use the function I thought calloc() is essential for my function.</p>
</blockquote>

<p>Forget about malloc and friends when programming uCs.  Otherwise you will get into serious problems. Dynamic memory allocation in the low memory enronments is a bit tricky , and ""big computer"" mechanisms fail miserably here</p>
",,,
56757807,2,56756589,2019-06-25T15:49:46.163,5,,2670348,,2019-06-25T15:49:46.163,,0,,"<p>When the ESP32 enters deep sleep, it turns off the processor that's running your code. The contents of memory and the current state of the processor are lost. It costs power to maintain the contents of its memory and the CPU state, and the point of deep sleep is to save as much power as possible, so it stops powering these things.</p>

<p>So when it restarts out of deep sleep it's as if it just powered up. Your <code>setup()</code> function will run again and will need to do any initialization again.</p>

<p>There are a couple of ways to preserve state across sleep cycles.</p>

<p>Obviously you can store data in flash memory using <code>EEPROM</code> or <code>SPIFFS</code>. Writing to flash is slow and costs a lot of power, so this isn't great if you're running off a battery.</p>

<p>You can also store data in the static RAM that's part of the real-time-clock (RTC). This RAM is built into the ESP32 and is maintained during deep sleep. Its contents will be lost or cleared when the ESP32 loses power or is flashed.</p>

<p>You can declare a variable to live in the RTC RAM using <code>RTC_DATA_ATTR</code>. For instance:</p>

<pre><code>RTC_DATA_ATTR unsigned wakeups;

void setup() {
  wakeups++;

  Serial.begin(115200);
  Serial.printf(""%u wakeups\n"", wakeups);

  // do other stuff and enter deep sleep
}
</code></pre>

<p>There's only 8KB of static RAM so you can't store huge amounts of data there.</p>

<p>You also need to be careful using it. Storing complex C++ objects in it will almost certainly not work correctly across deep sleep restarts. Storing pointers to data (like a <code>char*</code> pointing to a C string) will not work because the data the pointer pointed to will be lost after restarting from deep sleep.</p>

<p>How deep sleep affects any electronics connected to the ESP32 is difficult to predict. The ESP32 will stop powering its GPIO lines during deep sleep. Whether the devices remain powered and how they react to the GPIO lines floating depends on the device. If they remain powered they may retain their state from the previous cycle. It really depends on the device and the circuitry.</p>

<p><a href=""https://randomnerdtutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/"" rel=""noreferrer"">This article</a> is a good tutorial on deep sleep and has more information.</p>
",,,
56768348,2,56767642,2019-06-26T08:22:43.947,1,,8647388,,2019-06-26T08:22:43.947,,0,,"<pre><code>if( val == '1') // Forward
{
  digitalWrite(m1a, HIGH);
  digitalWrite(m1b, LOW);
  digitalWrite(m2a, HIGH);
  digitalWrite(m2b, LOW);
  delay(1);
  digitalWrite(m1a, LOW);
  digitalWrite(m2a, LOW);
}
</code></pre>

<p>To </p>

<pre><code>if( val == '1') // Forward
{
  digitalWrite(m1a, HIGH);
  digitalWrite(m1b, LOW);
  digitalWrite(m2a, HIGH);
  digitalWrite(m2b, LOW);
  delay(1);
  digitalWrite(m1a, LOW);
  digitalWrite(m2a, LOW);
  val = ' ';

}
</code></pre>
",,,
56772243,2,56771664,2019-06-26T11:56:57.017,3,,4431643,,2019-06-26T11:56:57.017,,2,,"<p>You can have <code>string</code> variable which stores all the <code>read</code> values into it and once <code>!</code> is read it will start processing it. </p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
SoftwareSerial BlueTooth(5, 6); // (TXD, RXD) of HC-06

char input; // to store input character received via BT.
String data;

void setup()  
{
  pinMode(13, OUTPUT);     // Arduino Board LED Pin
  BlueTooth.begin(9600);  
}

void loop() 
{
  if (BlueTooth.available())
  {
    input=(BlueTooth.read());

      if (input != '!') {
          data += input;
      }
      else{
          String message_id = String(data.substring(0,2)); //gets only ""bt""
          data.remove(0,3); //data becomes ""50"" since '!' is not added to data

          int message_value = data.toInt();

          if(message_id == ""bt""){
               brightness = message_value;
          }
      }
  }
}
</code></pre>
",,,
56774202,2,56771664,2019-06-26T13:38:16.430,0,,5157478,,2019-06-28T12:31:40.410,2019-06-28T12:31:40.410,9,,"<p>You can use a typical trick used in cases as your, encoding multibyte character literals in a single <code>unsigned int</code>, that on Arduino uno and Mega 2560 is 16 bits in little endian format.</p>

<p>With reference to C standard <strong>ISO/IEC 9899:201x</strong> § <strong>""6.4.4.4 Character constants""</strong>.</p>

<p>The subparagraph 10 explain our case:</p>

<blockquote>
  <p>An integer character constant has type int. The value of an integer
  character constant containing a single character that maps to a
  single-byte execution character is the numerical value of the
  representation of the mapped character interpreted as an integer. The
  value of an integer character constant containing more than one
  character (e.g., 'ab'), or containing a character or escape sequence
  that does not map to a single-byte execution character, is
  <strong>implementation-defined</strong>. If an integer character constant contains a
  single character or escape sequence, its value is the one that results
  when an object with type char whose value is that of the single
  character or escape sequence is converted to type int.</p>
</blockquote>

<p>Where 'implementation-defined' in our case is managed as described below.</p>

<p>In this case the multibyte char constant <code>'bt'</code> can be coded as the 16 bits integer <code>0x6274</code>, where <code>'b'=0x62</code> and <code>'t'=0x74</code>.</p>

<p>The compiler should also be smart enough to convert the multibyte char sequence in the int value.</p>

<p>In the following snippet we consider that the char array <code>msg</code> holds the received message, and we use a simple and functional <code>switch</code> statement (that requires an integer value) casting the <code>msg</code> variable to an unsigned integer.:</p>

<pre><code>char msg[10];
...
switch (*((unsigned int *)msg))
{
    case 'tb':     //Note the reverse order of command characters due to endianess
        int value = atoi(msg+2);    //Convert number to int
        ....     //do something
    break;

    ....    //other cases
}
</code></pre>

<p>casting the <code>msg</code> pointer variable to a pointer to  unsigned integer the compiler will interpret the first 2 chars as the integer in the way explained above, and act the switch based on their value.</p>

<p>The following sample use your code modified for use of a switch. It assumes that the command has a fixed length equal to <code>MAX_MSG_LEN</code> (2 characters for command, 2 characters for the value and the end of message):</p>

<pre><code>// Bluetooth module used - HC-06

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial BlueTooth(5, 6); // (TXD, RXD) of HC-06

#define MAX_MSG_LEN 5       //Max message length
#define OFFSET_TO_VALUE     //Offset in input buffer to value

char BT_input[10];  // to store input characters received via BT.

void setup()
{
    pinMode(13, OUTPUT);    // Arduino Board LED Pin
    BlueTooth.begin(9600);
}

void loop()
{
    if (BlueTooth.available())
    {
        /*
         * Read in the message up to the '!'
         */
        int i=0;
        do
        {
            BT_input[i] = (BlueTooth.read());
        } while (i&lt;MAX_MSG_LEN &amp;&amp; BT_input[i++]!='!');

        /*
         * If message length is exactly what we expect
         * we can process the message.
         * Note that because of endianess the command
         * chare are rversed.
         */
        if (i == MAX_MSG_LEN)
        {
            switch (*((unsigned int *)BT_input))
            {
                case 'tb':  // command 'bt'
                    process_brigthness(atoi(BT_input + OFFSET_TO_VALUE));
                    break;

                case 'no':  // command 'on'
                {
                    digitalWrite(13, HIGH);
                    BlueTooth.println(""Now LED is ON"");
                    break;
                }

                case 'fo':  // command 'of' for off
                {
                    digitalWrite(13, LOW);
                    BlueTooth.println(""Now LED is OFF"");
                    break;
                }

                default:    // unknown command
                {
                    unknown_command();
                    break;
                }
            }
        }
        else
        {
            /*
             * Process communication error
             */
            communication_error();
        }
    }
}
</code></pre>

<p>Or using an union of the input stream and the command structure:</p>

<pre><code>// Bluetooth module used - HC-06

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial BlueTooth(5, 6); // (TXD, RXD) of HC-06

#define MAX_MSG_LEN 5       //Max message length
#define OFFSET_TO_VALUE     //Offset in input buffer to value

union tag_BT_input              // to store input characters received via BT.
{
    char   stream[MAX_MSG_LEN];
    struct
    {
        unsigned int cmd;       //Command
        char         val[2];    //value
        char         eom;       //End of message marker '!'
    }msg;
} BT_input;

void setup()
{
    pinMode(13, OUTPUT);    // Arduino Board LED Pin
    BlueTooth.begin(9600);
}

void loop()
{
    if (BlueTooth.available())
    {
        /*
         * Read in the message up to the '!'
         */
        int i=0;
        do
        {
            BT_input.stream[i] = (BlueTooth.read());
        } while (i&lt;MAX_MSG_LEN &amp;&amp; BT_input.stream[i++]!='!');

        /*
         * If message length is exactly what we expect
         * we can process the message.
         * Note that because of endianess the command
         * chare are rversed.
         */
        if (i == MAX_MSG_LEN)
        {
            switch (BT_input.msg.cmd)
            {
                case 'tb':  // command 'bt'
                    process_brigthness(atoi(BT_input.msg.val));
                    break;

                case 'no':  // command 'on'
                {
                    digitalWrite(13, HIGH);
                    BlueTooth.println(""Now LED is ON"");
                    break;
                }

                case 'fo':  // command 'of' for off
                {
                    digitalWrite(13, LOW);
                    BlueTooth.println(""Now LED is OFF"");
                    break;
                }

                default:    // unknown command
                {
                    unknown_command();
                    break;
                }
            }
        }
        else
        {
            /*
             * Process communication error
             */
            communication_error();
        }
    }
}
</code></pre>
",,,
56789818,2,56784110,2019-06-27T11:14:09.957,1,,4931630,,2019-06-27T11:14:09.957,,4,,"<p>Which input is shorted does not show you what direction the encoder was turned. But the order in which they were shorted does.</p>

<p>Normally, rotary encoders have two outputs which are shorted to the ground pin: first shorted, then second shorted, then first released, then second released - this full sequence happened between each click. (Of course there are encoders which have additional ""click"" in the middle of the sequence, or have no clicks at all, but most of them do like described above).</p>

<p><a href=""https://i.stack.imgur.com/wb530.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wb530.png"" alt=""enter image description here""></a></p>

<p>So, generally speaking, each ""CLICK!"" movement you may consider as 4 phases:</p>

<ul>
<li><strong>0.</strong> Both inputs are released (high) - default position</li>
<li><strong>1.</strong> Input A is shorted to ground (low), input B is released (high)</li>
<li><strong>2.</strong> Both inputs are shorted (low)</li>
<li><strong>3.</strong> Input A is released (high), B is shorted (low).</li>
</ul>

<p>Rotation in one direction is a passage thru phases 0-1-2-3-0. Another direction is 0-3-2-1-0. So, whatever direction the encoder is rotated, both inputs will be shorted to ground at some particular moment.</p>

<p>As you can see from the picture above, usually the bouncing happens only at one of inputs. So, you may consider the bouncing as jumping between two adjacent phases, what makes the debounce much simpler.</p>

<p>Since those phases are changes very fast you have to pool input pins very fast, may be 1000 times per second, to handle fast rotations.</p>

<p>Code to handle the rotation may be as follows:</p>

<pre><code>signed int encoder_phase = 0;

void pull_encoder() {
    int phase = ((PORTC.IN &amp; (1 &lt;&lt; INPUT_A_PINNO)) ? 0 : 1)
                ^ ((PORTC.IN &amp; (1 &lt;&lt; INPUT_B_PINNO)) ? 0 : 0b11);
    // the value of phase variable is 0 1 2 or 3, as described above
    int phase_shifted = (phase - encoder_phase) &amp; 3;
    if (phase_shifted == 2) { // jumped instantly over two phases - error
        encoder_phase = 0;
    } else if (phase_shifted == 1) { // rotating forward
        encoder_phase++;
        if (encoder_phase &gt;= 4) { // Full cycle
            encoder_phase = 0;
            handle_clockwise_rotation();
        }
    } else if (phase_shifted == 3) { // rotating backward; 
        encoder_phase--;
        if (encoder_phase &lt;= -4) { // Full cycle backward
            encoder_phase = 0;
            handle_counterclockwise_rotation();
        }
    }
    if (phase == 0) {
        encoder_phase = 0; // reset 
    }
}
</code></pre>
",,,
56794836,2,56793937,2019-06-27T15:58:56.980,0,,721269,,2019-06-27T15:58:56.980,,0,,"<pre><code>    if(Step == 1){
        sleep_for(1s);
        while(Step == 10){
</code></pre>

<p>We only pass the <code>if</code> if <code>Step</code> is 1. But we only enter the <code>while</code> loop if <code>Step</code> is 10, which it never will be since it had to be 1 or we wouldn't have gotten to the <code>while</code> in the first place. So the code inside the <code>while</code> loop will not execute.</p>

<pre><code>            while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) &gt; 0){
                recvBuff[n] = 0;
                if(fputs(recvBuff, stdout) == EOF){
                    printf(""\n Error : Fputs error\n"");
                }
            }
</code></pre>

<p>This is broken. Each iteration of the <code>while</code> loop overwrites the previously received bytes. If the message being sent is ""10"" and the first <code>read</code> gets the ""1"", the second read that gets the ""0"" will overwrite the ""1"" and the <code>atoi</code> call will get 0 instead of 10!</p>
",,,
56797617,2,56797493,2019-06-27T19:38:01.813,3,,73299,,2019-06-27T19:38:01.813,,2,,"<p>It seems like you're trying to implement a simple state machine. For that, you need to switch your loop / if statements around. In pseudocode:</p>

<pre><code>int mode; // 0: green, 1: red and so on
while(true) {
    // check button presses
    if(buttonpress) {
        mode = mode+1;
    }
    if(mode==1)
        make_leds_more_green();
    else if(mode==2)
        make_leds_more_red();
    //...
    delay(1);
}
</code></pre>
",,,
56797727,2,56797493,2019-06-27T19:49:33.993,1,,10515734,,2019-06-27T20:32:47.923,2019-06-27T20:32:47.923,2,,"<p>You can try a hand made non-blocking</p>

<ol>
<li>Remove the <code>for</code></li>
<li>Remove the <code>delay</code></li>
<li>Use <code>millis()</code> with period</li>
</ol>

<pre><code>#define DELAY  5000

int step;

void greenToRed() {
    // Non blocking, only check if the waiting period passed
    if(changeToRed &amp;&amp; millis() &gt; time_1 + DELAY){
        // Update the time
        time_1 = millis();
        // Update the step
        step -= 1;

        analogWrite(redpin, 255 - step);
        analogWrite(greenpin, step);
        analogWrite(bluepin, 0);
        Serial.println(""Green to red"");

        // Finish condition
        if(step =&lt; 0) {
            changeToRed = 0;
        }
    }
}

void loop() {
    if (results.value == 0xFFE21D) {
        changeToRed = 1;
        step = 255;
    }
    greenToRed();
}
</code></pre>
",,,
56797741,2,56797493,2019-06-27T19:51:16.663,3,,2192494,,2019-06-27T19:51:16.663,,2,,"<p>Tstenner's state machine is one way to go. I'll outline another below, but the basic idea is that you need the loop to continue as you fade the LEDs in/out in single steps. Here's my co-routine approach:</p>

<pre><code>int pins[3] = { redpin, greenpin, bluepin };
int current[3] = { 0, 0, 0 };
int target[3] = { 0, 0, 0 };

led_tick() {
  for (int i = 0; i &lt; 3; i += 1) {
    if (current[i] == target[i]) continue;
    if (current[i] &lt; target[i]) {
      current[i] += 1;
    } else {
      current[i] -= 1;
    }
    analogWrite(pins[i], current[i]);
  }
}

loop() {
  // handle buttons, change target values
  led_tick();
  delay(1);  // making this non-blocking would be even better

}
</code></pre>
",,,
56871807,2,56871626,2019-07-03T13:58:00.120,1,,11669560,,2019-07-03T14:43:36.060,2019-07-03T14:43:36.060,1,,"<p>You may let the OS spare resources (compute other things) by telling your program to sleep.</p>

<pre><code>usleep(int timeInMicroseconds);
</code></pre>

<p>this will make the program sleep for timeInMicroseconds.</p>

<p>As your program take in account Button pushes sleeping for a even a few milliseconds shouldn't make your program less efficient in detecting pushes.</p>

<p>The more your program will sleep the more it will release the CPU, but also be less reactive to detect your pushes (and even doesn't detect them if the sleep period is too long). It's a balance; some trial and error should give you a good value.  </p>

<pre><code>#include &lt;unistd.h&gt;

while(1)
{
   if (digitalRead(butPin)) // Button is released if this returns 1
   {
       digitalWrite(ledPin, LOW);     // Regular LED off
   }
   else 
   {

   }
   usleep(5000); //Sleep for 5ms
}
</code></pre>

<p>Another option would be to use interruption: 
<a href=""http://wiringpi.com/reference/priority-interrupts-and-threads/"" rel=""nofollow noreferrer"">Interruption with wiringPi</a>.</p>
",,,
56901933,2,56901397,2019-07-05T11:11:30.500,0,,7042963,,2019-07-05T11:11:30.500,,0,,"<p>In place of usage compiler don't know about <code>updateMenu()</code> function, so you should tell him about this function earlier by simple declaration of <code>updateMenu()</code> function.</p>

<p>To do this, you need to place below line:</p>

<pre class=""lang-cpp prettyprint-override""><code>void updateMenu();
</code></pre>

<p>before definition of <code>setup()</code> function:</p>

<pre class=""lang-cpp prettyprint-override""><code>...
void updateMenu();

void setup() {
  Serial.begin(9600);
...

</code></pre>

<p>P.S By default CPP programmer put declaration of their functions (if needed) on the top of their code (just after the <code>#include</code> lines). </p>
",,,
56936909,2,56929233,2019-07-08T14:17:51.370,1,,2670348,,2019-07-08T14:17:51.370,,0,,"<p>In your code:</p>

<pre><code>const char *dev_uuid;
dev_uuid = device.getServiceUUID().toString().c_str(); 

strcpy(dev_uuid, device.getServiceUUID().toString().c_str());

dev_uuid = device.getServiceUUID().toString();

strcpy(dev_uuid, device.getServiceUUID().toString();
</code></pre>

<p>Your <code>strcpy()</code> attempts cannot possibly work the way you wrote them. You have an uninitialized pointer (<code>dev_uuid</code>) and you're copying data into... wherever it happens to point to. This is why you're getting panics.</p>

<p>Use a <code>String</code> object, not a C string, instead:</p>

<pre><code>String dev_uuid;

dev_uuid = device.getServiceUUID().toString();
</code></pre>

<p>There's a huge difference between the Arduino <code>String</code> class and C strings. Generally if you see a <code>toString()</code> method, it's the Arduino String class. Reading the documentation should make it clear that a method returns a <code>String</code>; if it does, you should assign the return value to a <code>String</code>.</p>

<p>C strings are much more difficult to work with. You're directly manipulating pointers to memory and the contents of memory. They always need one byte more for their null termination character than their length indicates. You need to make sure that there's memory allocated for them before you copy into them. </p>
",,,
56940138,2,56939302,2019-07-08T17:47:28.760,0,,1147688,,2019-07-08T17:47:28.760,,0,,"<p>This fixed it:</p>

<pre class=""lang-cpp prettyprint-override""><code>    float getVoltage() {
        if (atCmd(""AT+CBC\r"") == 1) {
            char *p = strchr(buffer, 'V');
            if (p) {
                p -= 5;  // get voltage
                double vo = atof(p) ;
                //printf(""%1.3f\n"", vo);
                return vo;
            }
        }
        return 0;
    }
</code></pre>
",,,
56957155,2,56939302,2019-07-09T16:41:08.713,1,,3518383,,2019-07-10T08:41:55.883,2019-07-10T08:41:55.883,2,,"<p>You can do it using the C function <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow noreferrer""><code>strtok</code></a> to tokenize the buffer</p>

<pre><code>void setup() {
  Serial.begin(115200);

  char buffer[20]  = ""+CBC: 1,66,3.900V"";

  const char* delims = "" ,V"";
  char* tok = strtok(buffer, delims); // +CVB:

  tok = strtok(NULL, delims);
  int first = atoi(tok);

  tok = strtok(NULL, delims);
  int second = atoi(tok);

  tok = strtok(NULL, delims);
  float voltage = atof(tok);

  Serial.println(first);
  Serial.println(second);
  Serial.println(voltage);

}

void loop() {
}
</code></pre>
",,,
56968957,2,56961041,2019-07-10T10:41:04.840,0,,8424708,,2019-07-10T10:41:04.840,,1,,"<p>Thanks a lot, I used the pigpio.h library.
Compile comand: <code>gcc pulse.c -pthread -lpigpio -lrt</code>
It is necessary to use the gpioServo <code>function (pin, pulse);</code>
The values ​​should be in the range from 1000 to 2000, since when working with these motors a signal with a different time interval is needed, the speed depends on it. From 1000 to 2000 are microseconds. Here is a small diagram:
But with PWM SIGNAL, I didn’t quite understand how to change the PWM frequency, or is it 50 by default?</p>

<p><a href=""https://i.stack.imgur.com/PbsET.png"" rel=""nofollow noreferrer"">Scheme ESC to Arduino or Raspbarry Pi</a></p>

<p><strong>VERY IMPORTANT!!! WARGNING !!!</strong>
I highly recommend setting microsecond values ​​(speeds) to no more than 1000-1200, as the speed is very high and you can injure yourself. Be careful.</p>

<p>There are still different libraries and other languages, they are presented on this site:</p>

<p><a href=""https://elinux.org/RPi_GPIO_Code_Samples"" rel=""nofollow noreferrer"">Other lib and lan</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;pigpio.h&gt;

int main(){

    if(gpioInitialise() &lt; 0){
        fprintf(stderr, ""pigpio initialisation faled\n"");
        return 1;
    }

    gpioSetMode(23, PI_OUTPUT);

    //Unlock ESC
    gpioServo(23, 1500);
    time_sleep(1);

    int speed = 1200;        

    while(1){
        //for(int speed = 1100; speed &lt; 2000; speed+=100){
            //for(int i = 0; i &lt; 20; i++){
                gpioServo(23, speed);
                //time_sleep(0.2);
            //}
            //printf(""us = %d\n"", speed);
        //}
    }

    return 0;
}
</code></pre>
",,,
56963143,2,56962670,2019-07-10T03:45:17.847,0,,6700019,,2019-07-10T03:45:17.847,,1,,"<p>You are making the logic too much complicated. Just read the button state in your loop and if it was <code>HIGH</code> do your motorcycle job. The next time loop runs as you haven't pressed the button it would become <code>LOW</code> and won't go into if statement.</p>

<pre><code>const int pwm_pin = 9;
const int dir_1a_pin = 8;
const int dir_2a_pin = 7;
int buttonPin = 2;

void MotorCycle()
{
    digitalWrite(dir_1a_pin, HIGH);
    digitalWrite(dir_2a_pin, LOW);
    analogWrite(pwm_pin, 255);
    delay(8000);

    digitalWrite(dir_1a_pin, LOW);
    digitalWrite(dir_2a_pin, HIGH);
    analogWrite(pwm_pin, 255);
    delay(12000);
}

void setup()
{
    pinMode(buttonPin, INPUT);
    pinMode(pwm_pin, OUTPUT);
    pinMode(dir_1a_pin, OUTPUT);
    pinMode(dir_2a_pin, OUTPUT);
}

void loop()
{
    // if button pressed
    if (digitalRead(buttonPin) == HIGH)
    {
        MotorCycle();
    }
}
</code></pre>
",,,
56969893,2,56969573,2019-07-10T11:36:41.690,0,,7333037,,2019-07-10T11:36:41.690,,0,,"<pre><code>#define VERSION        1
#define TYPE           ""this""
...

bool update(const char* json) {
   ...
   const char* theType = doc[""type""];     // ""this""
   int theVer          = doc[""version""];  // 2

   return (theVer &gt; VERSION) &amp;&amp; !strcmp(TYPE,theType) ;
}
</code></pre>
",,,
56969938,2,56969573,2019-07-10T11:38:59.257,0,,7862667,,2019-07-10T11:38:59.257,,0,,"<p>Maybe this code will help you:</p>

<pre><code>bool func()
{
    const string str = ""value"";
    int number = 3;
    return str == const_string &amp;&amp; number == const_number ? true : false;
}
</code></pre>
",,,
56970006,2,56969573,2019-07-10T11:42:20.253,1,,560648,,2019-07-10T11:49:54.287,2019-07-10T11:49:54.287,0,,"<p><code>#define</code> is irrelevant.</p>

<p>After preprocessing, your snippet is exactly equivalent to:</p>

<pre><code>bool update(const char* json) {
    const char* theType = doc[""type""];     // ""this""
    int theVer          = doc[""version""];  // 2

    if ( (theVer &gt; 1) &amp;&amp; (theType == ""this"") ) {
        return true
    } else {
        return false;
    }
}
</code></pre>

<p>So the problem is reduced to ""how do we compare two C-strings?"", with a much simpler example like this:</p>

<pre><code>int main()
{
   const char* theType = ""this"";
   const bool  matches = (theType == ""this"");
}
</code></pre>

<p>The answer is, <a href=""https://stackoverflow.com/q/8004237/560648"">not with <code>==</code>, but with <code>strcmp</code></a>.</p>
",,,
56970345,2,56969573,2019-07-10T12:05:35.983,2,,10290252,,2019-07-10T12:18:55.797,2019-07-10T12:18:55.797,7,,"<p>I know L.F's answer has already been accepted but i wish to dissent on their advice to use <code>strcmp</code>.  you shouldn't even be using <code>#define</code> anymore but <code>constexpr</code> instead. This allows you to be clear on typing and, in my experience, <code>constexpr</code> play's nicer with intellisense.</p>

<p>What you should use for <code>TYPE</code> is <code>constexpr std::string_view</code>. which wont force you to use old c libraries and can be compared with <code>std::string</code> using the == operator.</p>

<pre><code>#include &lt;string_view&gt;
#include &lt;string&gt;

constexpr int THIS = 1;
constexpr std::string_view TYPE = ""this"";
...

bool update(const std::string &amp; json) {
    ...
    std::string theType = doc[""type""]; // ""this""
    int theVer = doc[""version""];  // 2

    if ( (theVer &gt; VERSION) &amp;&amp; (theType == TYPE) ) {
        return true
    } else {
        return false;
    }
}
</code></pre>

<p><a href=""https://en.cppreference.com/w/cpp/language/constexpr"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/cpp/language/constexpr</a>
<a href=""https://en.cppreference.com/w/cpp/string/basic_string_view"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/cpp/string/basic_string_view</a></p>
",,,
56985650,2,56981860,2019-07-11T09:11:54.633,0,,2858170,,2019-07-11T09:11:54.633,,1,,"<p>Please refer to the manual befor using any functions. The manual clearly states that your approach is not going to work.</p>

<p>From the Arduino Reference Manual:</p>

<blockquote>
  <p><code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> (recommended)</p>
  
  <p><code>attachInterrupt(interrupt, ISR, mode)</code> (not recommended)</p>
  
  <p><code>attachInterrupt(pin, ISR, mode)</code> (Not recommended. Additionally, this
  syntax only works on Arduino SAMD Boards, Uno WiFi Rev2, Due, and
  101.)</p>
  
  <p>Example Code</p>

<pre><code>const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;

void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(interruptPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, CHANGE);
}

void loop() {
  digitalWrite(ledPin, state);
}

void blink() {
  state = !state;
}
</code></pre>
</blockquote>
",,,
56989719,2,56989254,2019-07-11T12:53:52.597,2,,3447475,,2019-07-11T12:53:52.597,,1,,"<p>In this case array SAMPLES can be considered as a 2-dimensional array , thus SAMPLES[0][0] , will give the 1st element of 1st 1-dimensional array of SAMPLES , SAMPLES[0][1], will give the 2nd element of 1st 1-d array of SAMPLES , and so on , considering this terminology in mind we can do , </p>

<pre><code>#include &lt;iostream&gt;

const int SAMPLES[][4] = {{2223, 1612, 930, 10}, {1855, 814, 530, 20}, {1225, 463, 438, 30}, {1306, 504, 552, 40}, ...};

byte samplesCount = sizeof(SAMPLES) / sizeof(SAMPLES[0]);

for (byte i = 0; i &lt; samplesCount; i++)
{
    //taking values of r,g,b as before    
    a=SAMPLES[i][0];//getting values of r,g,b 
    b=SAMPLES[i][1];//using the knowledge that SAMPLES[i][j]
    c=SAMPLES[i][2];//denotes jth element of ith 1-d array of SAMPLES
    colourDistance = getColourDistance(r, g, b, a, b, c);
}
</code></pre>
",,,
57028817,2,57026300,2019-07-14T15:37:16.823,0,,3518383,,2019-07-14T17:26:20.383,2019-07-14T17:26:20.383,2,,"<p>if you want the members to be references like this</p>

<pre><code>protected:
   Relay&amp; relay;
   DHT&amp; sensor;
</code></pre>

<p>use member initializer list to set reference in cpp (note that the parameters are references too so change it in .h too)</p>

<pre class=""lang-c prettyprint-override""><code>ClimateController::ClimateController(Relay&amp; _relay, DHT&amp; _sensor, float minValue, float maxValue) 
   : relay(_relay), sensor(_sensor) {
    this-&gt;minValue = minValue;
    this-&gt;maxValue = maxValue;
    this-&gt;currentValue = 0;
}
</code></pre>

<p>in .ino create <code>dht</code> as global variable </p>

<pre><code>DHT dhtDHT(PIN0, DHT22, 1);
</code></pre>

<p>and pass it to constructor like you do it now</p>

<pre><code>heatingController = new ClimateController(relay1, dht, 0.0, 30.0);
</code></pre>
",,,
57033478,2,57033281,2019-07-15T05:01:34.620,0,,11771534,,2019-07-15T05:01:34.620,,0,,"<p>Figured it out. Here it now works</p>

<pre><code>//Way at the Top
boolean oldState = LOW;

//Down in Loop
 boolean newState = digitalRead(15);

  if (deviceConnected) {
    if (newState != oldState) {
      if (newState == LOW) {
        pCharacteristic-&gt;setValue(""ON"");

      }
      else {
        pCharacteristic-&gt;setValue(""OFF"");

      }
      pCharacteristic-&gt;notify();
    };

    oldState = newState;
</code></pre>
",,,
57047831,2,57047065,2019-07-15T22:18:00.427,0,,3344853,,2019-07-16T00:14:17.543,2019-07-16T00:14:17.543,6,,"<p>Try this to test if you can get back what you send.</p>

<h2>C Code 1:</h2>

<pre><code>const int BUFFER_LENGTH = 10;          // Define the buffer length.
char buffer[BUFFER_LENGTH + 1];        // Extra one for NULL terminator.

while(1)
{
    if (UART1_Data_Ready())
    {
        memset(buffer, 0, BUFFER_LENGTH + 1);          // Clear the buffer.
        UART1_Read_Text(buffer, ""\0"", BUFFER_LENGTH);  // Double quotes for terminator string. Only read BUFFER_LENGTH number of chars.
        UART1_Write_Text(buffer);
    }
}
</code></pre>

<h2>C Code 2:</h2>

<pre><code>char one_char = 0;

while(1)
{
    if (UART1_Data_Ready() == 1)
    {
        one_char = UART1_Read();
        UART1_Write(one_char);
    }
}
</code></pre>

<h2>C# Code:</h2>

<pre><code>private void sendData()
{
    Console.WriteLine(""sending"");
    string Seuil = SeuilVal.Text + '\0';  // Text plus NULL terminator.
    ComPort.Write(Seuil);                 // Send the user's text plus NULL terminator straight out the port.
    Console.WriteLine(Seuil);
    //SeuilVal.Clear();                     // Clear screen after sending data.
}
</code></pre>
",,,
57053011,2,57052902,2019-07-16T08:23:47.243,1,,4328180,,2019-07-16T08:23:47.243,,1,,"<p>The class you are defining in PgWeightTestItem.h is called <code>PgWeightStandards</code> and not <code>PgWeightTestItem</code>. By renaming one of them you should be fine. PgWeightTestItem.h could be as follows: </p>

<pre><code>#ifndef PgWeightTestItem_h
#define PgWeightTestItem_h

#include ""Arduino.h""

class PgWeightTestItem {

public:
    PgWeightTestItem(float &amp; referenceAv, float &amp; referenceMin, float &amp; referenceMax);

    /*public properties*/

private:
    /*private properties*/
};

#endif
</code></pre>
",,,
57063025,2,57058805,2019-07-16T17:59:22.570,1,,5577765,,2019-07-16T22:08:09.423,2019-07-16T22:08:09.423,2,,"<p>The buffer which is returned by <a href=""https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#ft_load_char"" rel=""nofollow noreferrer""><code>FT_Load_Char</code></a> contains one byte for each pixel of the glyph.<br>
If you would use modern OpenGL the you could use the format <code>GL_RED</code> for the bitmap format and the internal texture image format. the rest would do the <a href=""https://www.khronos.org/opengl/wiki/Shader"" rel=""nofollow noreferrer"">Shader program</a>.<br>
Since you use <a href=""https://www.khronos.org/opengl/wiki/Legacy_OpenGL"" rel=""nofollow noreferrer"">Legacy OpenGL</a> you've to use a format that converts the byte value to an RGB value. Use <code>GL_LUMINANCE</code> for that. <a href=""https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glTexImage2D.xml"" rel=""nofollow noreferrer""><code>GL_LUMINANCE</code></a> converts <em>""into an RGBA element by replicating the luminance value three times for red, green, and blue and attaching 1 for alpha""</em>.</p>

<pre class=""lang-c prettyprint-override""><code>glTexImage2D(
    GL_TEXTURE_2D,
    0,
    GL_LUMINANCE,
    face-&gt;glyph-&gt;bitmap.width,
    face-&gt;glyph-&gt;bitmap.rows,
    0,
    GL_LUMINANCE,
    GL_UNSIGNED_BYTE,
    face-&gt;glyph-&gt;bitmap.buffer
);
</code></pre>

<p>Note that two-dimensional texturing has to be enabled, see <a href=""https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml"" rel=""nofollow noreferrer""><code>glEnable</code></a>:</p>

<pre class=""lang-cpp prettyprint-override""><code>glEnable(GL_TEXTURE_2D)
</code></pre>

<hr>

<p>If you want to draw the text with an transparent background, then you can use <a href=""https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glTexImage2D.xml"" rel=""nofollow noreferrer""><code>GL_ALPHA</code></a>: </p>

<pre class=""lang-c prettyprint-override""><code>glTexImage2D(
    GL_TEXTURE_2D,
    0,
    GL_ALPHA,
    face-&gt;glyph-&gt;bitmap.width,
    face-&gt;glyph-&gt;bitmap.rows,
    0,
    GL_ALPHA,
    GL_UNSIGNED_BYTE,
    face-&gt;glyph-&gt;bitmap.buffer
);
</code></pre>

<p>When you draw the text, then you've to enable <a href=""https://www.khronos.org/opengl/wiki/Blending"" rel=""nofollow noreferrer""><code>Blending</code></a>:</p>

<pre class=""lang-c prettyprint-override""><code>void drawText(char* inString, float x, float y, float scale, colour col) {

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glEnable(GL_TEXTURE_2D);

    // [...]

    glDisable(GL_TEXTURE_2D);
    glDisable(GL_BLEND);
}
</code></pre>

<hr>

<p>Further <code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</code> should be called before <code>getChars();</code>. </p>
",,,
57061794,2,57061737,2019-07-16T16:31:20.173,3,,1782465,,2019-07-16T16:31:20.173,,0,,"<p>Since the slaves are non-static member functions, <code>master</code> needs to be a pointer to a member function and not a pointer to a function. The code would look like this:</p>

<pre><code>class Foo
{
    public:
            Foo();

            int counter = 0;

            void slaveA() { counter++; };
            void slaveB() { counter--; };

            void (Foo::*master)() = &amp;Foo::slaveA;

            void toggleSlave()
            {
                _useB = !_useB;

                if (_useB)
                    master = &amp;Foo::slaveB;
                else
                    master = &amp;Foo::slaveA;
            }

    private:
            bool _useB = false;
};

void loop()
{
    if (random(2) == 0)
        foo.toggleSlave();

    (foo.*foo.master)();
    Serial.println(foo.counter);
    delay(500);
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/78ea4e624f9ad819"" rel=""nofollow noreferrer"">[Live example]</a></p>

<p>Since the syntax <code>(foo.*foo.master)()</code> is rather ugly, I suggest making <code>master</code> a function in <code>foo</code> and the member pointer its implementation detail:</p>

<pre><code>class Foo
{
    public:
            Foo();

            int counter = 0;

            void slaveA() { counter++; };
            void slaveB() { counter--; };

            void master() {
              (this-&gt;*_master)();
            }

            void toggleSlave()
            {
                _useB = !_useB;

                if (_useB)
                    _master = &amp;Foo::slaveB;
                else
                    _master = &amp;Foo::slaveA;
            }

    private:
            void (Foo::*_master)() = &amp;Foo::slaveA;
            bool _useB = false;
};

void loop()
{
    if (random(2) == 0)
        foo.toggleSlave();

    foo.master();
    Serial.println(foo.counter);
    delay(500);
}
</code></pre>
",,,
57084561,2,57083604,2019-07-17T22:02:29.833,0,,1428695,,2019-07-17T22:02:29.833,,1,,"<p>I don't know how the fancy <code>ioctl</code> stuff works, but I'd try to do all initialization outside of this function, including setting all the GPIO's to output.</p>

<p>You should probably just have one function call to set/clear a relay. I'd do something like this to start:</p>

<pre><code>void RelayOnOff(unsigned char relay, unsigned char enable)
{
    //Init to all off
    static unsigned char data = 0x00;
    ...  
    if (enable){
        data |= ( 1 &lt;&lt; relay );
    }
    else{
        data &amp;= ~( 1 &lt;&lt; relay );
    }
    config[0] = 0x09;
    config[1] = data;
    write(file, config, 2);
}
</code></pre>

<p>You pass in what relay you want to control, and a boolean value for enable/disable. If you make the data variable static, it'll ""remember"" that value from function call to function call. The enable/disable sets/clears the bit for whatever relay you pass in (0-7).</p>
",,,
57107775,2,57106262,2019-07-19T07:41:49.287,0,,6755083,,2019-07-20T14:17:35.350,2019-07-20T14:17:35.350,0,,"<p>As your code will work without the serial monitor, you can try this snippet:</p>

<pre><code>void setup() {
  /* other codes */
  Serial.begin(57600);
  int numTries = 0;
  while (!Serial.available()){
    if( ++numTries &gt;= 10) break;
    delay(100);
  }       
}
</code></pre>

<p><strong>Edited:</strong> I was assuming that you got stuck during the initial setup stage when <code>Serial</code> monitor don't respond. Since you like to blink the LED only once, you can do like so using <code>static</code> keyword. When a variable is declared as static, space for it gets allocated for the lifetime of the program. </p>

<pre><code>void loop() {    
  static bool done = false; // will initialize only once
  digitalWrite(stimulation, HIGH);   
  digitalWrite(led, HIGH); 
  delay(20);                         
  digitalWrite(stimulation, LOW);    
  digitalWrite(led, LOW);
  delay(30);
  if(!done &amp;&amp; Serial.available()) {
     Serial.println(""Stimulation Done :)"");
     done = true;
  }                          
}
</code></pre>
",,,
57116382,2,57106262,2019-07-19T16:27:28.713,0,,10307350,,2019-07-20T21:14:07.367,2019-07-20T21:14:07.367,2,,"<pre><code>#define stimulation 4
#define led 13
unsigned long startMillis;
unsigned long currentMillis;
const unsigned long stimTime = 20*60000;  // Stimulation Time (60s = 60000ms)

void setup() {
  Serial.begin(115200);
  pinMode(stimulation,OUTPUT);       
  pinMode(led, OUTPUT);
  digitalWrite(stimulation, LOW);   // force laser OFF before starting 
  digitalWrite(led, LOW);
  Serial.println(""Standby:"");
  Serial.println(""Press any key to start stimulation"");
  while (!Serial.available()){}     // do absolutely nothing until serial input received
  startMillis = millis();           // time (ms) when input received
  Serial.println(""Now you wait 20min :)"");       
}  
void loop() {
  currentMillis = millis();         // time (ms) beginning of the loop
  if (currentMillis - startMillis &lt;= stimTime) {  
  digitalWrite(stimulation, HIGH);  // Laser ON
  digitalWrite(led, HIGH);          // Internal Led ON 
  delay(20);                        // Keep laser ON for 20ms
  digitalWrite(stimulation, LOW);   // Laser OFF
  digitalWrite(led, LOW);           // Internal Led OFF
  delay(30);                        // Keep laser OFF for 30ms
}   
  else {                            // After 20min do nothing (stop stimulation)
    }                          
}

</code></pre>
",,,
57123269,2,57123169,2019-07-20T09:07:53.620,2,,1848654,,2019-07-20T09:07:53.620,,0,,"<p>In general, you initialize fields in your constructor:</p>

<pre><code>class MqttConfig
{
  public:
    MqttConfig();

  private:
    PubSubClient _mqttClient;
};

// ...
MqttConfig::MqttConfig()
    : _mqttClient(WiFiClient{})
{
}
</code></pre>

<hr>

<p>As for your last attempt:</p>

<pre><code>// This compiles, but does something I don't understand
WiFiClient GetWiFiClient();       
PubSubClient _mqttClient(WiFiClient);
</code></pre>

<p>These are method declarations.</p>
",,,
57123438,2,57123174,2019-07-20T09:33:25.153,0,,11764098,,2019-07-20T12:52:53.927,2019-07-20T12:52:53.927,3,,"<p>I can't figure out the problem, but you can try the following code. It's stronger I think.</p>

<pre><code>float getFloat()
{
    float res;
    while (Serial.available() &lt; sizeof(res))
        ;
    Serial.readBytes((char*)&amp;res, sizeof(res));
    return res;
}

void loop()
{
    // ...
    AZ = getFloat();
    AL = getFloat();
    // ...
}
</code></pre>
",,,
57124691,2,57123174,2019-07-20T12:24:39.627,0,,2280439,,2019-07-20T12:40:05.677,2019-07-20T12:40:05.677,3,,"<p>Thanks for your answers.</p>

<p>The problem is not about the parsing as you said but with the LCD display.</p>

<p>I've tried converting floats to array and geting only 16 characters:</p>

<pre><code>  char str[16];
  AZ=getFloat();
  AL=getFloat();
  char buffer1[20];
  char buffer2[20];
  dtostrf(AZ,7,5,buffer1);
  dtostrf(AL,7,5,buffer2);
  for (int i=0;i&lt;8;i++){
    if (i&gt;1){
      str[i]=buffer1[i-2];
      str[i+8]=buffer2[i-2];
    }
  }
  Serial.println(str);
</code></pre>

<p>But I get this on serial output : <code>AZ358.54AL48.544\x12.BBHE\xb3CGm=\r\n</code> => fixed with <code>\0</code>
I think the problem is elswhere : I have to send twice the floats via the next code to get the last if not, I get the previous data on my arduino but i think the limitation comes from there :</p>

<pre><code>  def sendFloatToArduino(self,data):
    self.serial.write(struct.pack('&lt;f', data))
    self.serial.flush()

  def pointer(self,AZ,AL):
#send the data
    print(""AZ : ""+str(AZ)+"" ; AL : ""+str(AL))
    self.sendFloatToArduino(AZ)
    self.sendFloatToArduino(AL)
    self.sendFloatToArduino(AZ)
    self.sendFloatToArduino(AL)
#wait for ack
    while (self.serialArduino.in_waiting==0):
      pass
    print(self.serialArduino.readline())
</code></pre>
",,,
57157944,2,57155294,2019-07-23T06:31:39.290,0,,3648681,,2019-07-23T06:31:39.290,,0,,"<p>The xxxx in the edit should probably be 2^16 aka 65536:</p>

<pre><code>#include &lt;cassert&gt;
using namespace std;

int main(int argc, char * argv[]) {

unsigned int data2 = 12345678;
uint16_t LSB = data2 &amp; 0xffff;
uint16_t MSB = data2 &gt;&gt; 16;
unsigned long  val = (1&lt;&lt;16) * MSB + LSB;
unsigned long  val2 = 65536 * MSB + LSB;
assert(val == data2);
assert(val2 == data2);
}
</code></pre>
",,,
57541921,2,57175348,2019-08-18T05:33:27.367,4,,3210032,,2019-08-18T05:33:27.367,,1,,"<p>There is no <code>SoftwareSerial.h</code> available for the Arduino Nano 33 IoT because it is not required. This board offers much more: Hardware serials that can be assigned to different pins.</p>

<p>This feature is offered by the micro controller Atmel SAMD21G and it is called I/O multiplexing (details available page 21 in <a href=""https://cdn.sparkfun.com/datasheets/Dev/Arduino/Boards/Atmel-42181-SAM-D21_Datasheet.pdf"" rel=""nofollow noreferrer"">the data sheet Atmel SAM D21E / SAM D21G / SAM D21J</a>). The micro controller is offering 6 SERCOM that you can assign to (nearly) any pins.</p>

<p>Some of the SERCOM are already used by the Arduino Nano 33 IoT:</p>

<ul>
<li>SERCOM2 for SPI NINA</li>
<li>SERCOM3 for MOSI/MISO</li>
<li>SERCOM4 for I2C bus</li>
<li>SERCOM5 for Serial debugging (USB)</li>
</ul>

<p>We still have the SERCOM0 and SERCOM1.</p>

<p>The details of the pins assignments are described in the <code>variant.cpp</code> and <code>variant.h</code> files. As Arduino is open-source, you can easily find them on <a href=""https://github.com/arduino/ArduinoCore-samd"" rel=""nofollow noreferrer"">the GitHub repository for SAMD boards</a>.</p>

<p>For the Arduino Nano 33 IoT, the pins assignments are described in:</p>

<ul>
<li><a href=""https://github.com/arduino/ArduinoCore-samd/blob/master/variants/nano_33_iot/variant.cpp"" rel=""nofollow noreferrer"">variants/nano_33_iot/variant.cpp</a></li>
<li><a href=""https://github.com/arduino/ArduinoCore-samd/blob/master/variants/nano_33_iot/variant.h"" rel=""nofollow noreferrer"">variants/nano_33_iot/variant.h</a></li>
</ul>

<p>By reading the <code>variant.cpp</code>, we understand the pin assignment and especially the link between the SAMD pin (PAxx or PBxx) and the Arduino pin.</p>

<p>The SAMD pins are important to make the link with the PORT Function Multiplexing of the <a href=""https://cdn.sparkfun.com/datasheets/Dev/Arduino/Boards/Atmel-42181-SAM-D21_Datasheet.pdf"" rel=""nofollow noreferrer"">the data sheet Atmel SAM D21E / SAM D21G / SAM D21J</a>.</p>

<p>A SERCOM can be <em>classic</em> or <em>alternate</em>. In the data sheet, the <em>classic</em> is in the column C and the <em>alternate</em> is in the column D. A SERCOM is defined by its index and the pad. For example: <code>SERCOM0/PAD[3]</code> is also called <code>0.3</code>.</p>

<p><strong>Remark:</strong> The pads are defined from 0 to 3 for the RX but the TX is defined only on 0 and 2. It is an important consideration when you choose the pins to use.</p>

<p><a href=""https://i.stack.imgur.com/pNIdV.png"" rel=""nofollow noreferrer"">For reference, see the table I used to select the SERCOM to assign.</a></p>

<p>Enough of theory, go for the solution...</p>

<p>Add a <strong>hardware serial on pins 5 (RX) and 6 (TX)</strong> of the Arduino Nano 33 IoT:</p>

<pre><code>#include &lt;Arduino.h&gt;
#include ""wiring_private.h""

Uart mySerial (&amp;sercom0, 5, 6, SERCOM_RX_PAD_1, UART_TX_PAD_0);

// Attach the interrupt handler to the SERCOM
void SERCOM0_Handler()
{
    mySerial.IrqHandler();
}

void setup() {
  // Reassign pins 5 and 6 to SERCOM alt
  pinPeripheral(5, PIO_SERCOM_ALT);
  pinPeripheral(6, PIO_SERCOM_ALT);

  // Start my new hardware serial
  mySerial.begin(9600);
}

void loop() {
  // Do something with mySerial...
}
</code></pre>

<p>Another example, add a <strong>hardware serial on pins 13 (RX) and 8 (TX)</strong> of the Arduino Nano 33 IoT:</p>

<pre><code>#include &lt;Arduino.h&gt;
#include ""wiring_private.h""

Uart mySerial (&amp;sercom1, 13, 8, SERCOM_RX_PAD_1, UART_TX_PAD_2);

// Attach the interrupt handler to the SERCOM
void SERCOM1_Handler()
{
    mySerial.IrqHandler();
}

void setup() {
  // Reassign pins 13 and 8 to SERCOM (not alt this time)
  pinPeripheral(13, PIO_SERCOM);
  pinPeripheral(8, PIO_SERCOM);

  // Start my new hardware serial
  mySerial.begin(9600);
}

void loop() {
  // Do something with mySerial...
}
</code></pre>
",,,
57216481,2,57215422,2019-07-26T08:54:06.697,2,,11829247,,2019-07-26T08:54:06.697,,1,,"<p>This is a somewhat fluffy question, but I will try to give you some ideas on how to proceed.</p>

<p>As I understand it, your problem is that you want execution to continue in the background while the user is fiddling with the menu. But this is a problem since an Arduino only has a single execution thread.</p>

<p>First I would make a main loop in this style:</p>

<pre><code>while (true) {
  ReadSensors()
  ReadButtons();
  SetOutputs();
  DisplayScreen();
}
</code></pre>

<p>Then I would make very sure to program all of those functions as so that they can be called multiple times in a row without problem causing issues, AND while making sure that none of them block or wait on anything. You want that loop to be running continuously.</p>

<p>If it is a problem if the sensors are read too quickly, then do something like:</p>

<pre><code>void ReadSensors()
{
  if (now - lastRead &lt; deltaTime)
    return;

  if (!SensorsReadyToBeRead()) {
    PrepareSensorsForRead(); // &lt;- again make sure this does not contain any delays
    return;
  }

  ReadSensorDataIntoMemorySomehow(); // &lt;- make sure this also does not contain any delays
}
</code></pre>

<p>You can do something similar for the outputs.</p>

<p>Then make a state machine for the menu:</p>

<pre><code>Enum MenuStates {
  NO_MENU,
  MAIN_MENU,
  TIME_MENU,
  PUMP_MENU,
  ...
}
</code></pre>

<p>Possibly with a sub-state machine for each menu.</p>

<p>Then whenever you detect a button press you update the state of the state machine(s), and in the <code>DisplayScreen()</code> function you display something based on the current state of the state machine(s). Do make sure to only update the states in <code>ReadButtons()</code> though; state machines are relatively simple if you separate update and response, but quickly go off the rails in complexity if you have multiple places that change the state.</p>

<p>Anyway, a fluffy answer to a fluffy question - I hope you can use some of the ideas, but no guarantees that this is the <em>best</em> way of doing something like this.</p>
",,,
57217713,2,57217187,2019-07-26T10:03:27.640,2,,10734452,,2019-07-26T10:15:35.090,2019-07-26T10:15:35.090,2,,"<ul>
<li>You could try to send from the host to the STM bytes with specific bit pattern, <strong>wait at least 500ms between each sends</strong> to avoid merging bytes.</li>
</ul>

<p><code>0x01</code>, <code>0x55</code>, <code>0xFF</code></p>

<p><em>Note what you read from the STM.</em></p>

<ul>
<li>Then try the same thing from the STM to the host.</li>
</ul>

<p><em>Note what you read from the host</em></p>

<ul>
<li>Then you can <strong>deduce</strong> something from the differences:</li>
</ul>

<p>If you are sure you are always sending one byte from one side and you get different reading from the other side (like your pattern), it very looks like a synchronization issue. Meaning : baudrate, not the parity or stop bit because in that case the pattern would be always the same like 0x01 converted in a 0x10.</p>

<p>But it will be much easier with a logic analyzer :)</p>

<p>I could also be noise.
When you look at your pattern bytes, it's very different from 0x01:</p>

<pre><code>0x01 : 0b00000001
0x1B : 0b00011011
0x08 : 0b00001000
0xD4 : 0b11010100
0x9F : 0b10011111
0x79 : 0b01111001
</code></pre>
",,,
57306873,2,57294369,2019-08-01T10:22:46.667,0,,11864731,,2019-08-01T10:22:46.667,,0,,"<p>Thanks to <a href=""https://stackoverflow.com/users/1599004/sawdust"">sawdust</a>, I know, that the problem was relying on the flags which are ""set by default"". Because they weren't. To fix my code, I added those flags, with the help of <a href=""https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/#flow-control-crtscts"" rel=""nofollow noreferrer"">this guide</a> about Linux serial programming:</p>

<pre><code>options.c_cflag &amp;= ~CRTSCTS;
options.c_cflag |= CREAD | CLOCAL;
options.c_lflag &amp;= ~ICANON;
options.c_lflag &amp;= ~ECHO;
options.c_lflag &amp;= ~ECHOE;
options.c_lflag &amp;= ~ECHONL;
options.c_lflag &amp;= ~ISIG;
options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
options.c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);
options.c_oflag &amp;= ~OPOST; 
options.c_oflag &amp;= ~ONLCR;
</code></pre>
",,,
57300730,2,57300672,2019-08-01T01:26:36.110,1,,2805305,,2019-08-01T01:26:36.110,,1,,"<p>Arduino doesn't have the usual capabilities to run tasks in parallel (it doesn't have multithreading). There are however some workarounds. See <a href=""https://arduino.stackexchange.com/questions/286/how-can-i-create-multiple-running-threads"">https://arduino.stackexchange.com/questions/286/how-can-i-create-multiple-running-threads</a> for more details.</p>

<p>Fortunately in your case you don't need to run the loops in parallel. You can rethink your algorithm in one loop by turning at the same time the pins at opposite sides. Something like this:</p>

<pre><code>for (int i = 0; i &lt; pinCount; ++i) {
    // turn the pins on:
    digitalWrite(ledPins[i], HIGH);
    digitalWrite(ledPins[pinCount - i - 1], HIGH);

    delay(timer);

    // turn the pins off:
    digitalWrite(ledPins[i], HIGH);
    digitalWrite(ledPins[pinCount - i - 1], LOW);
}
</code></pre>
",,,
57309108,2,57308789,2019-08-01T12:28:56.457,4,,11723965,,2019-08-01T12:40:09.187,2019-08-01T12:40:09.187,2,,"<p>What you need to do is break the float into bytes and then send/receive them one by one.
<strong>Note: The following code assumes sender and receiver using same endian system.</strong></p>

<pre><code>//Sender
float f = 4.1;
int i = 0;
for (; i &lt; sizeof(float); ++i)
    serialPutchar(fd, ((char*)&amp; f)[i]);


// receiver
float f;
int i = 0;
for (; i &lt; sizeof(float); ++i)
    ((char*)&amp; f)[i]) = serialGetchar(fd);
</code></pre>
",,,
57310561,2,57308789,2019-08-01T13:48:08.113,0,,2410359,,2019-08-01T13:48:08.113,,1,,"<p>A <code>float</code> needs to send data as multiple bytes, not just one call of <code>serialPutchar()</code> which sends only 1.</p>

<p>When receiving multiple bytes over a serial channel, it is easy for a byte to be dropped or for the receiver to begin in mid-stream. I recommend employing framing the data, in some fashion to cope.</p>

<p>Example: Send as text with sentinels</p>

<pre><code>// Sender
char buf[30];
snprintf(buf, sizeof buf, ""&lt;%a&gt;"", some_float);
serialPutString(fd, buf);

// Receive
while (serialGerChar(fd) != '&lt;') {
  ;
}
char buf[30*2];
for (i=0; i&lt;sizeof buf - 1; i++) {
  buf[i] = serialGetChar(fd);
  if (buf[i] == '&gt;') {
    break;
  }
}
buf[i] = '\0';
f = strtod(buf, &amp;endptr);
// additional checks possible here.
</code></pre>

<p>Robust code does not assume incoming data is well formed and check for various problem like incomplete, excessive, non-numeric text.</p>
",,,
57314680,2,57313478,2019-08-01T18:04:12.147,1,,11831074,,2019-08-01T18:04:12.147,,0,,"<p>No you can not declare single bits. Only in a multiple of 8 (aka bytes). In C++ variables of type <em>char</em> are size of 1 byte. If you want to transmit/compare a sequence of bits you can use <em>char</em>s or an array of <em>char</em>s. </p>

<pre><code>char single_byte = 32; // same as 0010 0000
char some_bytes[3] = {8, 254, 1}; // same as 0000 1000 1111 1110 0000 0001
</code></pre>

<p>To check if a bit is set at a specific position, you can use bitwise operators like <strong>&amp;</strong>.</p>

<pre><code>// example:
// check if the second bit of the second byte in some_bytes is set

char filter = 64; // 0100 0000
if (some_bytes[1] &amp; filter) // 1111 1110 &amp; 0100 000 = 0100 0000
// returns true
</code></pre>
",,,
57324419,2,57315755,2019-08-02T10:14:40.613,0,,9072753,,2019-08-02T10:14:40.613,2020-06-20T09:12:55.060,0,,"<p>The <a href=""http://wiringpi.com/reference/priority-interrupts-and-threads/"" rel=""nofollow noreferrer"">documentation</a> I've found is rather specific (emphasis mine):</p>
<blockquote>
<p>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</p>
<p>This function is run at a high priority (if the program is run using sudo, or as root) and <strong>executes concurrently</strong> with the main program. It has full access to all the global variables, open file handles and so on.</p>
</blockquote>
<p>The <a href=""https://github.com/UplinkCoder/wiringpi/blob/master/wiringPiISR.c#L106"" rel=""nofollow noreferrer"">sources</a> don't leave anything to imagination. It just crates a new thread:</p>
<pre><code>pthread_create (&amp;threadId, NULL, interruptHandler, &amp;pin) ;
</code></pre>
<p>that waits for interrupt and executes your handler:</p>
<pre><code>static void *interruptHandler (void *arg)
{
  int pin = *(int *)arg ;

  (void)piHiPri (55) ;

  for (;;)
  {
    if (waitForInterrupt (pin, -1) &gt; 0)
      isrFunctions [pin] () ;
  }

  return NULL ;
}
</code></pre>
<p>So your handler runs as a separate thread and your behavior is expected.</p>
",,,
57337889,2,57337789,2019-08-03T11:27:42.533,3,,5249307,,2019-08-03T11:27:42.533,,0,,"<p>Consider the code after <code>BTN</code> has been expanded:</p>

<pre><code>if (!digitalRead(A2)) {
    while (!digitalRead(A2)) {}
    while (digitalRead(A2)) {
        // move code
    }
    while (!digitalRead(A2)) {}
}
</code></pre>

<p>So it’s saying:</p>

<ul>
<li>if the button is down;</li>
<li>wait until it is no longer down;</li>
<li>then do movement code until the button is down again</li>
<li>and wait until it’s no longer down.</li>
</ul>

<p>(<strong>Note</strong> This code doesn’t consider switch bounce at all, it’s likely to behave somewhat erratically.)</p>
",,,
57350828,2,57349244,2019-08-04T23:19:22.113,0,,5280925,,2019-08-04T23:19:22.113,,1,,"<p>I'm unable to reproduce your error. The following code compiles in Arduino IDE:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include ""Arduino.h""
#include ""Stepper.h""

class ClassTest
{
  public:
    ClassTest() = default;
    void SetupMotor(Stepper* step);
    void MoveMotor(String, int );
  private:
    Stepper* _myStepper1;
};

void ClassTest::SetupMotor(Stepper* step)
{
  _myStepper1 = step;
  _myStepper1-&gt;setSpeed(200);
}

void ClassTest::MoveMotor(String motor, int stepCount)
{
  _myStepper1-&gt;step(200);

}

ClassTest test;

Stepper myStepper1 = Stepper(200, 8, 9, 10, 11);

void setup() {
  test.SetupMotor(&amp;myStepper1);
}
void loop() {
  test.MoveMotor(""Motor1"", 200);
}

</code></pre>
",,,
57447899,2,57378093,2019-08-11T06:46:13.037,0,,7189752,,2019-08-16T06:40:47.873,2019-08-16T06:40:47.873,0,,"<p>If anyone else faces this, I found a large performance improvement from doing the following: </p>

<ul>
<li>Removing DNS </li>
<li>Reseting the WiFi config</li>
<li>Explicitly setting the module to AP mode - this is referenced by this <a href=""https://github.com/esp8266/Arduino/issues/1094#issuecomment-338000385"" rel=""nofollow noreferrer"">Github issue</a> comment. This seems to be the primary driver of improvement.</li>
</ul>

<p>So the code is now: </p>

<pre><code>// Set up WiFi mode [Improve AP stability - no dual STA mode]
ESP.eraseConfig();
WiFi.mode(WIFI_AP);

IPAddress apIP(10, 10, 10, 1);                      
IPAddress subnet(255,255,255,0);              
WiFi.softAPConfig(apIP, apIP, subnet);
WiFi.softAP(ACCESS_POINT_NAME);     // No password
WiFi.printDiag(Serial);
</code></pre>

<p>The reasoning is that while in STA mode, the ESP may channel hop (depending on the environment), and the AP gets pulled with it. So any client connected before the channel hop will have to reconnect. </p>
",,,
57409134,2,57402680,2019-08-08T09:17:37.883,0,,8828044,,2019-08-08T09:17:37.883,,0,,"<p>I figured out how to get it working, I'm posting the code if anyone has a similar issue in the future:</p>

<pre><code>#define memoryAddr 0x50
byte in=0x00;

#include &lt;Wire.h&gt;

void setup() {
  Serial.begin(9600);
  Wire.begin();
  Serial.println(""writing"");

  Wire.beginTransmission(memoryAddr);
  Wire.write(0x00);  // first the MSB (8-bits)
  Wire.write(0x00);
  delay(10); 
  Wire.write(0x00); //data
  Wire.endTransmission();

  delay(10);
  Serial.println(""reading"");

  Wire.beginTransmission(memoryAddr); //writing the address to be read
  Wire.write(0x00);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(10);
  Wire.beginTransmission(memoryAddr);
  Wire.requestFrom(memoryAddr,10,true);
  while(Wire.available()){
    in=Wire.read();
    Serial.println(in,HEX);

  }
  Wire.endTransmission();
  Serial.println(""Done"");
}

void loop() {
}
</code></pre>
",,,
57433722,2,57430102,2019-08-09T16:05:00.033,3,,485343,,2019-08-09T16:05:00.033,,2,,"<p>Assuming you're using the <a href=""https://github.com/espressif/esp-idf"" rel=""nofollow noreferrer"">ESP-IDF</a> SDK, the toolchain is based on GCC 5.2 targeting the xtensa-lx106 instruction set, with a partially open-source C runtime library.</p>

<p><code>std::mutex</code> in GNU libstdc++ delegates to pthread_mutex_lock/unlock calls. ESP-IDF SDK contains a <a href=""https://github.com/espressif/esp-idf/blob/master/components/pthread/pthread.c"" rel=""nofollow noreferrer"">pthread emulation layer</a>, where we can see what <a href=""https://github.com/espressif/esp-idf/blob/master/components/pthread/pthread.c#L639"" rel=""nofollow noreferrer""><code>pthread_mutex_lock</code></a> and <a href=""https://github.com/espressif/esp-idf/blob/master/components/pthread/pthread.c#L685"" rel=""nofollow noreferrer""><code>pthread_mutex_unlock</code></a> actually do:</p>

<pre><code>static int IRAM_ATTR pthread_mutex_lock_internal(esp_pthread_mutex_t *mux, TickType_t tmo)
{
    if (!mux) {
        return EINVAL;
    }

    if ((mux-&gt;type == PTHREAD_MUTEX_ERRORCHECK) &amp;&amp;
        (xSemaphoreGetMutexHolder(mux-&gt;sem) == xTaskGetCurrentTaskHandle())) {
        return EDEADLK;
    }

    if (mux-&gt;type == PTHREAD_MUTEX_RECURSIVE) {
        if (xSemaphoreTakeRecursive(mux-&gt;sem, tmo) != pdTRUE) {
            return EBUSY;
        }
    } else {
        if (xSemaphoreTake(mux-&gt;sem, tmo) != pdTRUE) {
            return EBUSY;
        }
    }

    return 0;
}

int IRAM_ATTR pthread_mutex_unlock(pthread_mutex_t *mutex)
{
    esp_pthread_mutex_t *mux;

    if (!mutex) {
        return EINVAL;
    }
    mux = (esp_pthread_mutex_t *)*mutex;
    if (!mux) {
        return EINVAL;
    }

    if (((mux-&gt;type == PTHREAD_MUTEX_RECURSIVE) ||
        (mux-&gt;type == PTHREAD_MUTEX_ERRORCHECK)) &amp;&amp;
        (xSemaphoreGetMutexHolder(mux-&gt;sem) != xTaskGetCurrentTaskHandle())) {
        return EPERM;
    }

    int ret;
    if (mux-&gt;type == PTHREAD_MUTEX_RECURSIVE) {
        ret = xSemaphoreGiveRecursive(mux-&gt;sem);
    } else {
        ret = xSemaphoreGive(mux-&gt;sem);
    }
    if (ret != pdTRUE) {
        assert(false &amp;&amp; ""Failed to unlock mutex!"");
    }
    return 0;
}
</code></pre>

<p>So as you can see it mainly delegates the calls to the RTOS semaphore API, with some additional checks.</p>

<p>Chances are you don't need/want those checks. Given the tiny i-cache of the esp32 chip and the excruciatingly slow serial RAM, I would prefer to stay as close to the hardware as possible (i.e. don't use <code>std::mutex</code> unless it does exactly what you need).</p>
",,,
57500845,2,57434935,2019-08-14T19:24:25.333,3,,668773,,2019-08-14T22:08:12.933,2019-08-14T22:08:12.933,10,,"<p>You say you have two shields? Each shield having a IHM02A1 driver on it? Please elaborate...</p>

<p>If that is the case, You can use the same SPI bus but you will need a separate chip select line for each shield.</p>

<p>I'm not much of a Arduino user so I'm not to familiar with their drivers. I download the example project and had a quick look:</p>

<p>As for the IHM02A1 class, the constructor looks like this:</p>

<pre><code>XNucleoIHM02A1(L6470_init_t *init_0, L6470_init_t *init_1, uint8_t flag_irq, uint8_t busy_irq, uint8_t standby_reset, uint8_t ssel, SPIClass *spi);
</code></pre>

<p>where the parameters have the following descriptions:</p>

<pre><code>/**
 * @brief Constructor.
 * @param init_0        pointer to the initialization structure of the first motor.
 * @param init_1        pointer to the initialization structure of the second motor.
 * @param flag_irq      pin name of the FLAG pin of the component.
 * @param busy_irq      pin name of the BUSY pin of the component.
 * @param standby_reset pin name of the STBY\RST pin of the component.
 * @param ssel          pin name of the SSEL pin of the SPI device to be used for communication.
 * @param spi           SPI device to be used for communication.
 */
</code></pre>

<p>The 6th parameters is the select pin. This is where you have to specify the select pin for each shield.</p>

<p>You will then need two instances of the class XNucleoIHM02A1, one for each shield. It is NOT an instance per motor. The class already makes provision for two motors.</p>

<pre><code>XNucleoIHM02A1 *x_nucleo_ihm02a1_shield1; // Class for shield 1
XNucleoIHM02A1 *x_nucleo_ihm02a1_shield2; // Class for shield 2

x_nucleo_ihm02a1_shield1 = new XNucleoIHM02A1(&amp;init[0], &amp;init[1], FLAG1, BUSY1, STBY_RST1, SS1, &amp;dev_spi);
x_nucleo_ihm02a1_shield2 = new XNucleoIHM02A1(&amp;init[0], &amp;init[1], FLAG2, BUSY2, STBY_RST2, SS2, &amp;dev_spi);
</code></pre>

<p>where SS1 and SS2 are the chip select pins. Note: You will have to fill these with actual pin numbers.</p>

<p>You also have to ensure that the rest of the parameters are defined correctly. You will most probably need separate pins for FLAG, BUSY and STBY/RST for each shield. Therefore I defined the parameters, FLAG1,FLAG2, BUSY1, BUSY2, STBY_RST1, STBY_RST2. Note: You will have to fill these with actual pin numbers.</p>

<p><strong>Addendum:</strong></p>

<p>If you need different parameters for each motor, then you will need four different init structures:</p>

<pre><code>L6470_init_t init_shield1[L6470DAISYCHAINSIZE] = {...};
L6470_init_t init_shield2[L6470DAISYCHAINSIZE] = {...};

x_nucleo_ihm02a1_shield1 = new XNucleoIHM02A1(&amp;init_shield1[0], &amp;init_shield1[1], FLAG1, BUSY1, STBY_RST1, SS1, &amp;dev_spi);
x_nucleo_ihm02a1_shield2 = new XNucleoIHM02A1(&amp;init_shield2[0], &amp;init_shield2[1], FLAG2, BUSY2, STBY_RST2, SS2, &amp;dev_spi);
</code></pre>

<p>But if all the motors have the same parameters and/or requirements, then you only need one init structure</p>

<pre><code>L6470_init_t init[L6470DAISYCHAINSIZE] = {...};

x_nucleo_ihm02a1_shield1 = new XNucleoIHM02A1(&amp;init[0], &amp;init[1], FLAG1, BUSY1, STBY_RST1, SS1, &amp;dev_spi);
x_nucleo_ihm02a1_shield2 = new XNucleoIHM02A1(&amp;init[0], &amp;init[1], FLAG2, BUSY2, STBY_RST2, SS2, &amp;dev_spi);
</code></pre>

<p>You will need to call ""get_components"" for each shield:</p>

<pre><code>// For easier reading
#define L6470_S1M1 (0u) // Index of shield1 motor1
#define L6470_S1M2 (1u) // Index of shield1 motor2
#define L6470_S2M1 (0u) // Index of shield2 motor1
#define L6470_S2M2 (1u) // Index of shield2 motor2

L6470 **motors_shield1 = x_nucleo_ihm02a1_shield1-&gt;get_components();
L6470 **motors_shield2 = x_nucleo_ihm02a1_shield2-&gt;get_components();
</code></pre>

<p>Then you operate on the motors in the following manner:</p>

<pre><code>motors_shield1[L6470_S1M1]-&gt;set_home(); // Home motor1 on shield1
motors_shield1[L6470_S1M2]-&gt;set_home(); // Home motor2 on shield1
motors_shield2[L6470_S2M1]-&gt;set_home(); // Home motor1 on shield2
motors_shield2[L6470_S2M2]-&gt;set_home(); // Home motor2 on shield2
</code></pre>
",,,
57499584,2,57499440,2019-08-14T17:40:18.130,7,,4967403,,2019-08-14T20:13:17.263,2019-08-14T20:13:17.263,15,,"<p>You should <em>not</em> be setting everything to volatile. Volatile has a specific purpose, and that's to prevent the compiler from optimizing out reads and writes to memory. Let's look at a really simple example.</p>

<pre><code>int regular_sum(int* ptr) {
    int a = *ptr;
    int b = *ptr;
    return a + b;
}
int volatile_sum(int volatile* ptr) {
    int a = *ptr;
    int b = *ptr;
    return a + b; 
}
</code></pre>

<p>When we look at the assembly, we see that in <code>regular_sum</code>, the compiler realizes you're dereferencing the same pointer twice, and it optimizes it to just one dereference. But in <code>volatile_sum</code>, the compiler inserts both dereferences:</p>

<pre><code>regular_sum(int*):
        mov     eax, DWORD PTR [rdi]
        add     eax, eax
        ret
volatile_sum(int volatile*):
        mov     eax, DWORD PTR [rdi]
        mov     edx, DWORD PTR [rdi]
        add     eax, edx
        ret
</code></pre>

<p><strong>Optimizations are good</strong>, and most of the time, you won't need to use volatile. If you're doing memory-mapped IO, or you're writing values to pins as though they were a pointer, <em>that's</em> where you use volatile. To reiterate what Nathan Oliver said,</p>

<blockquote>
  <p>You only need to use volatile on variables where the hardware can change the value of the variable because the compiler can't know about that. This is what volatile is for, letting the compiler know this is a special variable that could be changed in a manner it doesn't know about. If the hardware cant change the value on you, then you don't need volatile. </p>
</blockquote>

<p>But if you're doing computations on an object, <em>don't</em> use volatile. Do the computations on a normal object, and then copy the result to your volatile pointer. </p>

<p><strong>Volatile and Interrupt Service Routines.</strong></p>

<p>It is appropriate to use <code>volatile</code> on global variables that might be modified by Interrupt Service Routines. That being said, <code>volatile</code> cannot be used with objects like <code>std::bitset</code> because <code>std::bitset</code> does not have support for volatile operations, and <code>std::bitset</code> is not trivially copyable. </p>

<p>In this regard, you have two options:</p>

<ul>
<li>Use a container that contains volatile primitives (e.g, <code>std::vector&lt;volatile bool&gt;</code></li>
<li>Write your own class, with support for volatile. </li>
</ul>

<p>If you have a class that <em>is</em> trivially copyable, then you can do something like the following. First, we have to define functions to allow us to copy to and from volatile types:</p>

<pre><code>template&lt;class T&gt;
T volatile_copy(T const volatile&amp; source) {
    static_assert(std::is_trivially_copyable_v&lt;T&gt;, ""Input must be trivially copyable"");
    T dest;
    auto* dest_ptr = dynamic_cast&lt;char*&gt;(&amp;dest);
    auto* source_ptr = dynamic_cast&lt;char const volatile*&gt;(&amp;source);

    for(int i = 0; i &lt; sizeof(T); i++) {
        dest_ptr[i] = source_ptr[i];
    }

    return dest;
}

template&lt;class T&gt;
void volatile_assign(T volatile&amp; dest, T const&amp; source) {
    static_assert(std::is_trivially_copyable_v&lt;T&gt;, ""Input must be trivially copyable"");
    auto* source_ptr = dynamic_cast&lt;char*&gt;(&amp;source);
    auto* dest_ptr   = dynamic_cast&lt;char volatile*&gt;(&amp;dest);

    for(int i = 0; i &lt; sizeof(T); i++) {
        dest_ptr[i] = source_ptr[i];
    }
}
</code></pre>

<p>Then, we may write a class normally, and as long as it's trivially copyable we can create a copy from a volatile version:</p>

<pre><code>struct MyBitset {
    uint64_t bits;
    // Logic

    void flip() {
        bits = ~bits;
    }
    void addOne() {
        bits++;
    }
};

volatile MyBitset flags;

void interrupt_handler() {
    auto local = volatile_copy(flags);

    // Do stuff to local

    volatile_assign(flags, local); 
};
</code></pre>

<p>We can also encapsulate this behavior in a class, so that we can ""check out"" volatile variables:</p>

<pre><code>template&lt;class T&gt;
struct Checkout {
    T local;
    T volatile&amp; source;
    Checkout(T volatile&amp; source)
      : local(volatile_copy(source))
      , source(source) {}
    void save() {
        volatile_assign(source, local);
    }
    ~Checkout() {
        save();
    }
};
</code></pre>

<p>Using this allows us to create local copies of <code>volatile</code> variables, make modifications to them, and the result will be saved automatically:</p>

<pre><code>volatile MyBitset flags;

void interrupt_handler() {
    auto f = Checkout(::flags);

    f.local.flip(); //We can call whatever member functions we want on the local

    // When the function exits, changes made to the local are automatically assigned to the volatile global
}
</code></pre>
",,,
57500708,2,57500244,2019-08-14T19:12:48.933,0,,2558231,,2019-08-14T20:31:17.673,2019-08-14T20:31:17.673,6,,"<p>In documentation <a href=""https://github.com/PaulStoffregen/SoftwareSerial/blob/master/SoftwareSerial.cpp"" rel=""nofollow noreferrer"">https://github.com/PaulStoffregen/SoftwareSerial/blob/master/SoftwareSerial.cpp</a>, you can see that both functions work with uint_8t -- which is guaranteed to have 8 bits (1 byte). That holds up to 256 of value, so <strong>1500 mod 256 is 220</strong>.</p>

<p>Looks like the library is prepared to transmit only char-sized data, so you need to convert bigger numbers on both size.</p>

<p>For sending int:</p>

<pre><code>int n = pwmValue;

while (n &gt; 0) {
    int digit = n % 10;
    n = n / 10;
    BTSerial.write(digit);
}
</code></pre>

<p>For receiving int:</p>

<pre><code>int n = 0; //future result
int decs = 1;
int temp;

while ((temp = BTSerial.read()) != -1) {
    n += temp * decs;
    decs *= 10;
}
</code></pre>
",,,
57500843,2,57500244,2019-08-14T19:24:14.963,1,,11294831,,2019-08-14T20:53:23.340,2019-08-14T20:53:23.340,1,,"<p>With the multi-byte variant of <code>write()</code> you could use:</p>

<pre><code>BTSerial.write(&amp;pwmValue, sizeof pwmValue);
</code></pre>

<p>For receiving you need a loop:</p>

<pre><code>union {
    int  i;
    char c[0];
} pwmValue;
int receivedBytes = 0;

void loop() {
    if (BTSerial.available()) {
        pwmValue.c[receivedBytes] = BTSerial.read();
        receivedBytes++;
        if (receivedBytes == sizeof pwmValue) {
            Serial.println(pwmValue.i);
            receivedBytes = 0;
        }
    }
}
</code></pre>
",,,
57529375,2,57529214,2019-08-16T18:20:42.907,-1,,3249421,,2019-08-16T18:20:42.907,,3,,"<p>I found problem. It was in serial port spamming. I have added check if current value is not equal with previous value and it have started work and next small issue was in receiver. I read value before it was available.</p>

<pre><code>#include &lt;PPMReader.h&gt;
#include &lt;InterruptHandler.h&gt; 

int ppmInputPin = 3;
int channelAmount = 2;

PPMReader ppm(ppmInputPin, channelAmount);

volatile unsigned long previousValue1 = 0;

void setup()
{
  Serial.begin(9600);
  Serial.write(""AT\r\n"");
  delay(10);
  Serial.write(""AT\r\n"");
  Serial.write(""AT+INQ\r\n"");
  delay(5000);
  Serial.write(""AT+CONN1\r\n"");
  Serial.println(""Transmitter started"");
}

void loop()
{
  unsigned long value1 = ppm.latestValidChannelValue(1, 0);

  if(previousValue1 != value1) {
    previousValue1 = value1;
    Serial.println(value1);
  }

}
</code></pre>
",,,
57534204,2,57529214,2019-08-17T07:26:53.140,0,,11476836,,2019-08-17T07:26:53.140,,0,,"<p>The first thing you need to ask yourself when implementing a device-to-device communication is how fast should I be sending? and if I send at that rate: is the receiver going to be able to keep pace (reading, doing processing or whatever it needs to do and answer back)?</p>

<p>This is obviously not about the baud rate but about what your loops are doing. You are using two different libraries: <em>PPMReader</em> and <em>Servo</em>. Now, pay attention to what each device is doing in their respective loops:</p>

<pre><code>//Sending
void loop() {
  unsigned long value1 = ppm.latestValidChannelValue(1, 0);
  Serial.println(value1);
}

//Receiving
void loop() {
  int pwmValue = Serial.parseInt();
  if(pwmValue &gt; 900 &amp;&amp; pwmValue &lt; 2001) {
  servo.writeMicroseconds(pwmValue);
  }
}
</code></pre>

<p>I don't really know how long it takes to execute each line of code (take a look <a href=""https://learn.sparkfun.com/blog/1687"" rel=""nofollow noreferrer"">here</a> for some comments on that) but you cannot seriously expect both loops to magically synchronize themselves. Considering they are doing very different things (leaving out the serial part) dealing with different hardware, I would expect one of them to take significantly longer than the other. Think about what happens if that's the case.</p>

<p>As I said, I have no idea how long it takes to call <code>ppm.latestValidChannelValue(1, 0)</code> but for the sake of my argument let's say it takes 0.1 milliseconds. To have an estimate of the time it takes to complete one iteration around the loop you need to add the time it takes to print one (or two) bytes to the port with <code>Serial.println(value1)</code> but that's easier, maybe around <a href=""https://forum.arduino.cc/index.php?topic=239851.0"" rel=""nofollow noreferrer"">20-100 microseconds</a> is a good ballpark figure. With these estimates, you end up reading 5000 times per second. If you are not happy or you don't trust my estimates I would suggest you do your own tests with a counter or a timer. If you do the same exercise for the other side of the link and let's say you get it's twice as fast, it runs 10000 times per second, how do you think it would happen with the communication? Yes, that's right: it will get clogged and run at snail pace.</p>

<p>Here you should carefully consider if you really need that many readings (you did not elaborate on what you're actually doing so I have no idea, but I lean on thinking you don't). If you don't, just add a delay on the sender's side to slow it down to a reasonable (maybe 10-20 iterations per second) speed.</p>

<p>There are other things to improve on your code: you should check you have received data in the buffer before reading it (not after). And you need to be careful with <code>Serial.parseInt()</code>, which sometimes leads to unexpected results but this answer is already too long and I don't want to extend it even more.</p>
",,,
57739796,2,57536768,2019-08-31T16:29:04.297,1,,11476836,,2019-08-31T16:29:04.297,,9,,"<p>I'm not familiar at all with your board so take this answer with a pinch of salt, but I've noticed some funny things on your files.</p>

<p>First off, you need to define the I2C pin you want to use for toggling the direction inside the UART pinmux:</p>

<pre><code>auart2_2pins_b: auart2-2pins@1 {
reg = &lt;1&gt;;
fsl,pinmux-ids = &lt;
        MX28_PAD_AUART2_RX__AUART2_RX
        MX28_PAD_AUART2_TX__AUART2_TX
        MX28_PAD_I2C0_SCL__I2C0_SCL
    &gt;;
    fsl,drive-strength = &lt;MXS_DRIVE_4mA&gt;;
    fsl,voltage = &lt;MXS_VOLTAGE_HIGH&gt;;
    fsl,pull-up = &lt;MXS_PULL_DISABLE&gt;;
};
</code></pre>

<p>Make sure you double-check the pin name you want to use, I cannot be sure that is the right one.</p>

<p>Then, you seem to be missing the <code>pinctrl</code> for the I2C controller:</p>

<pre><code>i2c0: i2c@80058000 {
        pinctrl-names = ""default"";
        pinctrl-0 = &lt;&amp;i2c0_pins_a&gt;;
        status = ""okay"";

        pca8575: gpio@20 {
            compatible = ""nxp,pca8575"";
            reg = &lt;0x20&gt;;   // PCA8575PW Address -0-0-0
            gpio-controller;
            #gpio-cells = &lt;2&gt;;
        };
    };
</code></pre>

<p>I could not confirm your <code>reg</code> and your pin numbers but I'm assuming you took it from your board's documentation. If you didn't, make sure you find a reliable source for your hardware.</p>

<p>Finally, I'm not sure why you want to have the RTS line active low, most transceivers have a DE/~RE input, which means you need to have the line active high to drive the bus. Maybe your driver is different...</p>

<p>What you are trying to do is documented to be working for other boards so I guess unless there is a bug you should be able to make it work.</p>
",,,
57541916,2,57541848,2019-08-18T05:32:22.870,0,,5728157,,2019-08-18T05:32:22.870,,3,,"<p>I assume the problem is that you are passing a member function pointer to <code>coapServer</code> in order to be called at some point in the future.</p>

<p>If this is right, I assume that the function pointer you pass as argument to <code>coap.server()</code> must be a non-member function as you didn't pass the object pointer any time.</p>

<p>Try to transform <code>getListOfWiFi</code> in a static one (include the keyword <code>static</code> in the function signature):</p>

<pre><code>static void getListOfWiFi(coapPacket *packet, IPAddress ip, int port, int obs);
</code></pre>

<p>Or just declare this function outside of any class/struct.</p>

<p>And in the <code>COAPService</code> ctor, just pass its address:</p>

<pre><code>COAPService::COAPService()
{
    // the static_cast you made here doesn't make much sense.
    coap.server(getListOfWiFi, ""wifilist"");
    coap.start(5683);
}
</code></pre>
",,,
57549940,2,57546519,2019-08-19T02:47:21.777,1,,11936229,,2019-08-19T12:39:20.330,2019-08-19T12:39:20.330,9,,"<p>One problem is simply calling Serial.available() simply returns the number of bytes available to be read in the buffer; it could be exactly the number of bytes you need, it could be less, or more. Because of this, you might read extra data, too little, or too much data. More so, in higher level transmission protocols sometimes after a device receives data it will send an ACK(acknowledgement) back to the sender, saying it is ready for more data. </p>

<p>Edit** It should also be noted that the comment talking about mutex's isn't correct. Mutexes are typically used to synchronize code across multiple threads of execution on the <strong>same</strong> device. The key is that they are a shared resource across the thread's heap space. This is <strong>NOT</strong> the case when using two different arduino devices; thus, even if you could use them, it would be useless.</p>

<p>For your code, I would suggest the following edits to the transmitter:</p>

<pre><code>#define MIN_TIMEOUT 3
void recieveAck(){
  bool validAck = false;
  uint8_t timeout_cnt = 0x00;
  while(timeout_cnt &lt; MIN_TIMEOUT){
    //Wait for receiving device to respond with two bytes then send next
    char incomingBytes[2];
    Serial.readBytes(incomingBytes, 0x02);
    if(incomingBytes[0] == 0xBB &amp;&amp; incomingBytes[1] == 0xCC)
      break;
    timeout_cnt++;
  }
}
void loop()
{

  if(delay()) {
    String mil = String(millis());
    String sendingText = mil + "";"" + mil + "";"" + mil + ""."";
    Serial.println(sendingText);
    recieveAck();
  }
}
</code></pre>

<p>And to the receiver:</p>

<pre><code>#define NEXT_INC_SIZE 2 //Expects one byte at a time
void sendAck(){
  char outData[2];
  outData[0] = 0xBB;
  outData[1] = 0xCC;
  Serial.write(outData, 2); //Write the ack data
}
void loop() {
  if(Serial.available() &gt;= NEXT_INC_SIZE){
    char incomingBytes[2];
    Serial.readByte(incomingBytes, NEXT_INC_SIZE); //Read exactly how many bytes you need
    //Do stuff with the data here....
    sendAck();
  }
}
</code></pre>
",,,
57550329,2,57550162,2019-08-19T03:58:59.500,0,,1870232,,2019-08-19T03:58:59.500,,3,,"<p>You could do something like the following: 
(<sub> Not sure if Arduino can have like following </sub>)</p>

<pre><code>template &lt;typename F&gt;
class TestClass {
    public:
    TestClass( F func )
        :m_func(func)
    {

    }

    void executeFP()
    {
        m_func();
    }

    private:
    F *m_func;

};

void doStuff()
{

    std::cout &lt;&lt; ""test"" &lt;&lt; std::endl;
}

bool doAnotherStuff( )
{
    std::cout &lt;&lt;""test "" &lt;&lt; 40 +2 &lt;&lt; std::endl;

    return true;

}

int main()
{
    TestClass&lt;decltype(doStuff)&gt; someObj ( doStuff );

    TestClass&lt;decltype(doAnotherStuff)&gt; someObj2 ( doAnotherStuff );

    someObj.executeFP();

    someObj2.executeFP();

}
</code></pre>

<p>See <a href=""https://rextester.com/QURFB67112"" rel=""nofollow noreferrer"">here</a></p>
",,,
57550576,2,57550162,2019-08-19T04:41:18.140,1,,11880191,,2019-08-19T17:44:36.460,2019-08-19T17:44:36.460,4,,"<p>Arduino doesn't have <code>std::function</code>, because AVR GCC doesn't ship with the Standard Library, so those suggestions in the comments won't work for that specific platform. </p>

<p>If you need similar behavior for Arduino or other embedded platforms, you can use <a href=""https://github.com/ETLCPP/etl"" rel=""nofollow noreferrer"">ETL</a>'s <code>etl::function</code> or <code>etl::delegate</code>, or create your own implementation. <code>std::function</code> uses heap allocations for type erasure, which is usually not a good choice for embedded.</p>

<p>The simplest implementation would use C-style function pointers:</p>

<pre class=""lang-cpp prettyprint-override""><code>// Generic definition of the function type
template &lt;typename F&gt;
class function;

// R: return type
// Args: Any arguments a function can take
template &lt;typename R, typename... Args&gt;
class function&lt;R(Args...)&gt; {
 public:
  // Type definition of the equivalent C function pointer
  using function_type = R (*)(Args...);

  // Default constructor: empty function. 
  // Never call the function while not initialized if using it this way.
  function() = default;

  // Constructor: store the function pointer
  function(function_type f) : function_ptr(f){};

  // Call operator: calls the function object like a normal function
  // PS: This version does not do perfect forwarding.
  R operator()(Args... args) { return function_ptr(args...); }

 private:
  function_type function_ptr;
};

// A helper function can be used to infer types!
template &lt;typename R, typename... Args&gt;
function&lt;R(Args...)&gt; make_function(R (*f)(Args...)) {
  return {f};
}
</code></pre>

<p><a href=""https://godbolt.org/z/GbcRgm"" rel=""nofollow noreferrer"">Live example</a>, with some use cases.</p>

<p>Of course, you can also just use the C pointer for this case, but this class can be extended for other types. If you need more complex behavior, like functors, member functions and capturing lambdas, see ETL's implementations I cited above.</p>
",,,
57564984,2,57564167,2019-08-19T23:21:45.437,3,,2443300,,2019-08-20T09:11:18.290,2019-08-20T09:11:18.290,5,,"<p>There are some mistake in your code.
In <code>webserver.h</code>:</p>

<pre><code>...
private:
    // Singleton Declarations
    static bool instanceFlag;
    static WebServer *single;
    WebServer() {}
    // Other Declarations
    FS *filesystem;
    ESP8266WebServer *server; // &lt;--- remove the parentheses and make it a pointer
    String getContentType(String);
    bool handleFileRead(String);
...
</code></pre>

<p>In <code>webserver.cpp</code>:</p>

<p>In <code>WebServer::initialize</code> I am guessing you want to initialize the class <code>server</code> and <code>filesystem</code> not locals, so it should probably look like this:</p>

<pre><code>void WebServer::initialize (int port) {
    server = new ESP8266WebServer(port);
    filesystem = new FS();
    ...
}
</code></pre>

<p>And now everywhere you use the server you have to use the <code>-&gt;</code> operator.
For example:</p>

<pre><code>void WebServer::handleLoop() {
    single-&gt;server-&gt;handleClient();
}
</code></pre>

<p>Please keep in mind that <code>server</code> and <code>filesystem</code> objects have to be deleted to avoid memory leaks.</p>

<p><strong>EDIT:</strong></p>

<p>You get the new error because FS has no constructor without arguments.
FS's constructor looks like this: <code>FS(FSImplPtr impl) : _impl(impl) { }</code>, <a href=""https://github.com/esp8266/Arduino/blob/master/cores/esp8266/FS.h#L36"" rel=""nofollow noreferrer"">here</a> you can see that FSImplPtr is a typedef for <code>std::shared_ptr&lt;FileImpl&gt;</code>, so you need to provide this as a parameter.</p>

<p>It works your way, because SPIFFS's existence is declared <a href=""https://github.com/esp8266/Arduino/blob/master/cores/esp8266/FS.h#L250"" rel=""nofollow noreferrer"">here</a> and is of type FS.</p>

<p>If you want to use <code>SPIFFS</code>, you have to use it like this: <code>filesystem = &amp;SPIFFS;</code>, not like you mentioned in the comments (<code>FS* filesystem = &amp;SPIFFS;</code>) because your way creates a new temporary variable named <code>filesystem</code>, and probably you expect to initiate the <code>filesystem</code> in the class, not a local one.</p>
",,,
57567058,2,57566932,2019-08-20T05:15:06.557,-3,,11571672,,2019-08-20T05:24:25.397,2019-08-20T05:24:25.397,0,,"<p>I think you try something like this:</p>

<pre><code>template&lt;class T, bool(*cmp)(int,int)&gt;
class strMap{


};
</code></pre>
",,,
57568915,2,57566932,2019-08-20T07:48:11.383,2,,9528746,,2019-08-20T07:52:47.763,2019-08-20T07:52:47.763,6,,"<p>One way would be to just rely on aggregate initialization of a plain array member:</p>

<pre><code>template&lt; class T, int N&gt;
struct StringMap {
    // Do not add a constructor!

    Pair&lt;T&gt; values[N];
};

class Parent {
    void testfunc(int data){}
    void testfunc2(int data){}
    StringMap&lt;void (Parent::*)(int), 2&gt; map{
        Pair&lt;void (Parent::*)(int)&gt;{""command1"", &amp;Parent::testfunc},
        Pair&lt;void (Parent::*)(int)&gt;{""command2"", &amp;Parent::testfunc2}
        };
};
</code></pre>

<p><a href=""https://godbolt.org/z/sjbE4B"" rel=""nofollow noreferrer"">https://godbolt.org/z/sjbE4B</a></p>

<p>To keep it simple I left the size to be specified manually. There's probably a way to deduce not only the size but also the <code>T</code>, but I don't think the code becomes clearer that way.</p>

<p>Also note that if you specify too large an <code>N</code>, the remaining array entries will be zero-initialized, you have to get that one right. (But you do get a compile-time error if you use too many initializers).</p>
",,,
57568938,2,57566932,2019-08-20T07:49:48.960,0,,1397944,,2019-08-20T07:49:48.960,,0,,"<p>So I went back and reviewed the documenation on uniform initialization a bunch more and came up this this as a starting point, but i would like it to be simplified as much as possible. compiles on godbolt.org, and in the arduino studio.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;string&gt;

template&lt;typename T&gt;
struct Pair {
    std::string first;
    T second;
};

template&lt;class T,int size&gt;
struct Map {
    template&lt;class... Ts&gt; //somehow enableif size and parameter pack match
    Map(Ts ...input){
        for( int i = 0; i &lt; sizeof...(input); ++i){
        }
    }

    //Rudimentary linear search
    T find(std::string name){
        for( auto i : list){
            if(! i.first.compare(name) ) return i.second;
        }
    }
    Pair&lt;T&gt; list[size];
};

struct Parent{
    void func1( int num ){}
    void func2( int num ){}
    void func3( int num ){}

    Map&lt;void (Parent::*)(int),3&gt; map{
        Pair&lt;void (Parent::*)(int)&gt;{""func1"",&amp;Parent::func1},
        Pair&lt;void (Parent::*)(int)&gt;{""func2"",&amp;Parent::func2},
        Pair&lt;void (Parent::*)(int)&gt;{""func3"",&amp;Parent::func3}
    };

    void call(std::string name){
        auto func = map.find(name);
        (this-&gt;*func)( 1 );
    }
};

int main(){
    Parent parent;
    parent.call(""func1"");
    return 0;
}
</code></pre>
",,,
57575288,2,57570586,2019-08-20T13:54:58.587,5,,1883304,,2019-08-20T13:54:58.587,,1,,"<p>Turns out I was doing it correctly. It was my router that had failed to refresh the hostname adequately. For consistency I will restate what I did to solve this problem:</p>

<hr>

<p>The <a href=""https://docs.espressif.com/projects/esp-idf/en/release-v3.0/api-guides/wifi.html#system-event-sta-start"" rel=""noreferrer"">Espressif WiFi Guide</a> indicates that the event <code>SYSTEM_EVENT_STA_START</code> is generated once <code>esp_wifi_start()</code> returns successfully. </p>

<p>The generation of this event also means that the event task will initialize the LwIP network interface (netif). Since we know that the TCP/IP adapter will surely have been initialized at this point, we can invoke the hostname change function. Here is an example of a handler that does that, taken right from their example: </p>

<pre><code>void wifi_event_handler (void *handler_arg, esp_event_base_t base, int32_t id,
    void *event_data) {
    esp_err_t err;

    // If esp_wifi_start() returned ESP_OK and WiFi mode is in station mode
    if (base == WIFI_EVENT &amp;&amp; id == WIFI_EVENT_STA_START) {
        const char *name;

        // Set the hostname for the default TCP/IP station interface
        if ((err = tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_STA, g_hostname))
                != ESP_OK) {
            fprintf(stderr, ""Err: %s"", esp_err_to_name(err));
        } else {
            if ((err = tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_STA, &amp;name)) != ESP_OK) {
                fprintf(stderr, ""Err Get Hostname: %s\n"", esp_err_to_name(err));
            } else {
                printf(""Hostname: %s\n"", (name == NULL ? ""&lt;None&gt;"" : name));
            }
        }
        ...
    }
    ...
}
</code></pre>

<p>In this example I get the hostname after setting it, and print it to <code>stdout</code>. You can validate it if you are running the monitor for the ESP32. The hostname set will be the one visible from the router page. </p>
",,,
57639437,2,57639210,2019-08-24T15:51:21.017,0,,1775859,,2019-08-24T15:56:11.137,2019-08-24T15:56:11.137,2,,"<p>If you're using modern C++ (11 or newer, which I understand arduino support), and your data is stored in an array you can simply do the following:</p>

<pre><code>int values[5] = { 16, 2, 77, 40, 12071 }

for(auto const&amp; value: values) {
   // Do stuff
}
</code></pre>
",,,
57639491,2,57639210,2019-08-24T15:59:12.743,1,,11032044,,2019-08-24T15:59:12.743,,1,,"<p>You can use <code>C structure</code>. To do so you need to declare a structure first describing your object type. </p>

<pre><code>struct component
{
  int id;
  char pin[10];
  char name[50];
};

component components[] = {
  {
   1,
   ""A0"",
   ""light""},
  {
   2,
   ""A1"",
   ""sound""},
  {
   1,
   ""A0"",
   ""heat""}

};

int main ()
{

    int len = sizeof(components)/sizeof(components[0]);
    for (int i=0 ; i&lt;len ; i++)
    {
        printf(""{ id: %d , pin: \""%s\"" , name: \""%s\"" }\n"",components[i].id, components[i].pin, components[i].name);
    }
    return 0;
} 
</code></pre>

<p>Output:</p>

<pre><code>{ id: 1 , pin: ""A0"" , name: ""light"" }
{ id: 2 , pin: ""A1"" , name: ""sound"" }
{ id: 1 , pin: ""A0"" , name: ""heat"" }
</code></pre>
",,,
57684805,2,57672568,2019-08-28T03:50:08.323,11,,44729,,2020-12-21T19:56:52.457,2020-12-21T19:56:52.457,9,,"<p>Alrighty, got it working on my Raspberry Pi 3 with <code>2019-07-10-raspbian-buster-lite.img</code>, both with the default Broadcom <a href=""https://en.wikipedia.org/wiki/Proprietary_device_driver"" rel=""noreferrer"">blobs</a> &amp; the KMS/DRM backend:</p>
<ol>
<li><p>Install SDL2 build dependencies:</p>
<pre><code> # install everything Debian uses to build SDL
 sudo apt build-dep libsdl2

 # needed for the KMSDRM backend:
 sudo apt install libdrm-dev libgbm-dev
</code></pre>
</li>
<li><p>Grab the latest stable <a href=""https://www.libsdl.org/release/SDL2-2.0.10.tar.gz"" rel=""noreferrer"">SDL source tarball</a> or tag (<a href=""https://hg.libsdl.org/SDL/rev/bc90ce38f1e2"" rel=""noreferrer""><code>release-2.0.10</code></a>) from <a href=""http://hg.libsdl.org/SDL"" rel=""noreferrer"">Mercurial</a>/<a href=""https://github.com/SDL-mirror/SDL"" rel=""noreferrer"">Git</a> and extract it somewhere like <code>~/sdl-src</code></p>
</li>
<li><p>Run SDL's <a href=""https://en.wikipedia.org/wiki/Autoconf"" rel=""noreferrer""><code>configure</code></a> script:</p>
<pre><code> cd ~/sdl-src
 ./configure --enable-video-kmsdrm
</code></pre>
<p>Here's my <code>configure</code> summary, note the <code>rpi</code> and <code>kmsdrm(dynamic)</code> entries in the <code>Video drivers</code> list:</p>
<pre><code> SDL2 Configure Summary:
 Building Shared Libraries
 Building Static Libraries
 Enabled modules : atomic audio video render events joystick haptic sensor power filesystem threads timers file loadso cpuinfo assembly
 Assembly Math   :
 Audio drivers   : disk dummy oss alsa(dynamic) pulse(dynamic) sndio(dynamic)
 Video drivers   : dummy rpi x11(dynamic) kmsdrm(dynamic) opengl opengl_es1 opengl_es2 vulkan wayland(dynamic)
 X11 libraries   : xcursor xdbe xinerama xinput2 xinput2_multitouch xrandr xscrnsaver xshape xvidmode
 Input drivers   : linuxev linuxkd
 Using libsamplerate : YES
 Using libudev       : YES
 Using dbus          : YES
 Using ime           : YES
 Using ibus          : YES
 Using fcitx         : YES
</code></pre>
</li>
<li><p>Build &amp; install SDL; took ~4.5 minutes on my Rpi3:</p>
<pre><code> make -j4 &amp;&amp; sudo make install
</code></pre>
</li>
<li><p>Build test program:</p>
<pre><code> g++ main.cpp `pkg-config --cflags --libs sdl2`
</code></pre>
</li>
<li><p>(Optional) Enable the &quot;Full KMS&quot; driver if you want to use the KMSDRM backend instead of the default OpenGL ES blobs:</p>
<pre><code> $ sudo raspi-config
 select '7 Advanced Options'
 select 'A7 GL Driver'
 select 'G3 GL (Full KMS)'
 reboot
</code></pre>
</li>
<li><p>Run test program:</p>
<pre><code> $ ./a.out 
 Testing video drivers...
 The path /dev/dri/ cannot be opened or is not available
 The path /dev/dri/ cannot be opened or is not available
 SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy
 SDL_VIDEODRIVER usable   : RPI
 The path /dev/dri/ cannot be opened or is not available
 The path /dev/dri/ cannot be opened or is not available
 SDL_VIDEODRIVER selected : RPI
 SDL_RENDER_DRIVER available: opengl opengles2 opengles software
 SDL_RENDER_DRIVER selected : opengles2
</code></pre>
<p>You can use environment variables to override the default video/render driver selection:</p>
<pre><code> SDL_VIDEODRIVER=KMSDRM SDL_RENDER_DRIVER=software ./a.out
</code></pre>
<p>I had to hold SDL's hand a bit with envvars to get the KMSDRM backend to load:</p>
<pre><code> # no envvars, fails:
 $ ./a.out 
 Testing video drivers...
 SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy
 SDL_VIDEODRIVER usable   : KMSDRM
 SDL_VIDEODRIVER selected : KMSDRM
 SDL_CreateWindow(): Could not initialize OpenGL / GLES library

 # with envvars, succeeds:
 $ SDL_VIDEO_EGL_DRIVER=libEGL.so SDL_VIDEO_GL_DRIVER=libGLESv2.so ./a.out
 Testing video drivers...
 SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy
 SDL_VIDEODRIVER usable   : KMSDRM
 SDL_VIDEODRIVER selected : KMSDRM
 SDL_RENDER_DRIVER available: opengl opengles2 opengles software
 SDL_RENDER_DRIVER selected : opengl
</code></pre>
</li>
</ol>
<p>Here's the test program I've been using:</p>
<pre><code>#include &lt;SDL.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main( int argc, char** argv )
{
    SDL_Init( 0 );

    std::cout &lt;&lt; &quot;Testing video drivers...&quot; &lt;&lt; '\n';
    std::vector&lt; bool &gt; drivers( SDL_GetNumVideoDrivers() );
    for( int i = 0; i &lt; drivers.size(); ++i )
    {
        drivers[ i ] = ( 0 == SDL_VideoInit( SDL_GetVideoDriver( i ) ) );
        SDL_VideoQuit();
    }

    std::cout &lt;&lt; &quot;SDL_VIDEODRIVER available:&quot;;
    for( int i = 0; i &lt; drivers.size(); ++i )
    {
        std::cout &lt;&lt; &quot; &quot; &lt;&lt; SDL_GetVideoDriver( i );
    }
    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; &quot;SDL_VIDEODRIVER usable   :&quot;;
    for( int i = 0; i &lt; drivers.size(); ++i )
    {
        if( !drivers[ i ] ) continue;
        std::cout &lt;&lt; &quot; &quot; &lt;&lt; SDL_GetVideoDriver( i );
    }
    std::cout &lt;&lt; '\n';

    if( SDL_Init( SDL_INIT_EVERYTHING ) &lt; 0 )
    {
        std::cerr &lt;&lt; &quot;SDL_Init(): &quot; &lt;&lt; SDL_GetError() &lt;&lt; '\n';
        return EXIT_FAILURE;
    }
    std::cout &lt;&lt; &quot;SDL_VIDEODRIVER selected : &quot; &lt;&lt; SDL_GetCurrentVideoDriver() &lt;&lt; '\n';

    SDL_Window* window = SDL_CreateWindow
        (
        &quot;SDL2&quot;,
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        640, 480,
        SDL_WINDOW_SHOWN
        );
    if( nullptr == window )
    {
        std::cerr &lt;&lt; &quot;SDL_CreateWindow(): &quot; &lt;&lt; SDL_GetError() &lt;&lt; '\n';
        return EXIT_FAILURE;
    }

    std::cout &lt;&lt; &quot;SDL_RENDER_DRIVER available:&quot;;
    for( int i = 0; i &lt; SDL_GetNumRenderDrivers(); ++i )
    {
        SDL_RendererInfo info;
        SDL_GetRenderDriverInfo( i, &amp;info );
        std::cout &lt;&lt; &quot; &quot; &lt;&lt; info.name;
    }
    std::cout &lt;&lt; '\n';

    SDL_Renderer* renderer = SDL_CreateRenderer( window, -1, SDL_RENDERER_ACCELERATED );
    if( nullptr == renderer )
    {
        std::cerr &lt;&lt; &quot;SDL_CreateRenderer(): &quot; &lt;&lt; SDL_GetError() &lt;&lt; '\n';
        return EXIT_FAILURE;
    }
    SDL_RendererInfo info;
    SDL_GetRendererInfo( renderer, &amp;info );
    std::cout &lt;&lt; &quot;SDL_RENDER_DRIVER selected : &quot; &lt;&lt; info.name &lt;&lt; '\n';

    bool running = true;
    unsigned char i = 0;
    while( running )
    {
        SDL_Event ev;
        while( SDL_PollEvent( &amp;ev ) )
        {
            if( ( ev.type == SDL_QUIT ) ||
                ( ev.type == SDL_KEYDOWN &amp;&amp; ev.key.keysym.sym == SDLK_ESCAPE ) )
            {
                running = false;
            }
        }

        SDL_SetRenderDrawColor( renderer, i, i, i, SDL_ALPHA_OPAQUE );
        SDL_RenderClear( renderer );
        SDL_RenderPresent( renderer );
        i++;
    }

    SDL_DestroyRenderer( renderer );
    SDL_DestroyWindow( window );
    SDL_Quit();
    return 0;
}
</code></pre>
",,,
57692415,2,57690525,2019-08-28T12:26:58.497,0,,10993861,,2019-08-28T12:26:58.497,,2,,"<p>Try this code.</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

const byte rxPin = 2;
const byte txPin = 3;

SoftwareSerial ESP8266 (rxPin, txPin);

unsigned long lastTimeMillis = 0;

void setup() {
  Serial.begin(9600);   
  ESP8266.begin(9600);
  delay(2000);
}

void printResponse() {
  while (ESP8266.available()) {
    Serial.println(ESP8266.readStringUntil('\n')); 
  }
}

void loop() {

  if (millis() - lastTimeMillis &gt; 30000) {
    lastTimeMillis = millis();

    ESP8266.println(""AT+CIPMUX=1"");
    delay(1000);
    printResponse();

    ESP8266.println(""AT+CIPSTART=4,\""TCP\"",\""192.168.1.19\"",80"");
    delay(1000);
    printResponse();

    String cmd = ""GET /test.html HTTP/1.1"";
    ESP8266.println(""AT+CIPSEND=4,"" + String(cmd.length() + 4));
    delay(1000);

    ESP8266.println(cmd);
    delay(1000);
    ESP8266.println(""""); 
  }

  if (ESP8266.available()) {
    Serial.write(ESP8266.read());
  }

}
</code></pre>
",,,
57729045,2,57728898,2019-08-30T14:53:15.413,3,,11958215,,2019-08-30T15:12:08.507,2019-08-30T15:12:08.507,0,,"<p>You need to get the ""edge"" of the signal. Try this:</p>

<pre><code>#define btnPin 2

uint8_t btn_prev;

void setup() {
  pinMode(btnPin, INPUT_PULLUP);

  btn_prev = digitalRead(btnPin);
}

void loop() {
 uint8_t btn = digitalRead(btnPin);

 if (btn == LOW &amp;&amp; btn_prev == HIGH)
  {
    //your code here
  }

  btn_prev = digitalRead(btnPin);
}
</code></pre>

<p>You can think of a buttons signal as a square. When the button is not pressed there is nothing, when you press it, the voltage flows, so it looks like this:</p>

<p><a href=""https://i.stack.imgur.com/0n6t5.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0n6t5.jpg"" alt=""enter image description here""></a></p>

<p>So your original code was changing the value for the entire ""on"" duration. The code above, looks for the ""rising edge"" in the diagram, which is theoretically a single moment in time.</p>

<p>If this doesn't work for you, then look at the ""Debouncing"" tutorial from Arduino where it also adds in the concept of time until your code is triggered <a href=""https://www.arduino.cc/en/tutorial/debounce"" rel=""nofollow noreferrer"">here</a>.</p>
",,,
